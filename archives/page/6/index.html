
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Eden">
    <title>Archives - Eden</title>
    <meta name="author" content="kirkzhang">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Eden">
<meta property="og:url" content="https://simonteo58.github.io/archives/page/6/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@nil">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/nil"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-jtle2hiadqi6creqze7vuhnn9ct7bmrwzzyznr4cpumzvckdy7pw9sbtrdse.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Eden
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/nil" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/nil" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Google +"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/23/leetcode/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"
                            aria-label=": 94.二叉树的中序排序"
                        >
                            94.二叉树的中序排序
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-23T00:10:00+08:00">
	
		    Jun 23, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/leetcode/">leetcode</a>, <a class="category-link" href="/categories/leetcode/leetcode%E9%A2%98%E8%A7%A3/">leetcode题解</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <pre class="language-text" data-language="text"><code class="language-text">/*
 * @lc app=leetcode.cn id=94 lang=cpp
 *
 * [94] 二叉树的中序遍历
 *
 * https://leetcode.cn/problems/binary-tree-inorder-traversal/description/
 *
 * algorithms
 * Easy (75.91%)
 * Likes:    1465
 * Dislikes: 0
 * Total Accepted:    855.6K
 * Total Submissions: 1.1M
 * Testcase Example:  '[1,null,2,3]'
 *
 * 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
 * 
 * 
 * 
 * 示例 1：
 * 
 * 
 * 输入：root = [1,null,2,3]
 * 输出：[1,3,2]
 * 
 * 
 * 示例 2：
 * 
 * 
 * 输入：root = []
 * 输出：[]
 * 
 * 
 * 示例 3：
 * 
 * 
 * 输入：root = [1]
 * 输出：[1]
 * 
 * 
 * 
 * 
 * 提示：
 * 
 * 
 * 树中节点数目在范围 [0, 100] 内
 * -100 &lt;= Node.val &lt;= 100
 * 
 * 
 * 
 * 
 * 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
 * 
 */
// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
</code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;stack&gt;
#include&lt;vector&gt;

 struct TreeNode &#123;
    int val;
      TreeNode *left; 
      TreeNode *right;
      TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
      TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 &#125;;

class Solution &#123;
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
        std::stack&lt;TreeNode*&gt;  treeStack ;
        std::vector&lt;int&gt; nodes;

        while (root || !treeStack.empty())&#123;
            if (root)&#123;
                treeStack.push(root);
                root &#x3D; root-&gt;left;

            &#125;else &#123;
                root &#x3D; treeStack.top();
                treeStack.pop();
                nodes.push_back(root -&gt; val);
                root &#x3D; root -&gt; right;

            &#125;
        &#125;
        return nodes;

    &#125;
&#125;;

&#x2F;&#x2F; @lc code&#x3D;end</code></pre>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/23/leetcode/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%B8%93%E6%B3%A8%E5%8A%9B/"
                            aria-label=": 如何提高专注力-How to Get Your Brain to Focus-TED"
                        >
                            如何提高专注力-How to Get Your Brain to Focus-TED
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T23:10:43+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TED/">TED</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>《How to Get Your Brain to Focus-TED》–TED<br>A few years ago, I began to observe<br>几年前 我开始意识到<br>something in my own behavior<br>我的某些行为<br>that made me a bit uncomfortable.<br>让我有点不舒服<br>And that was that from the moment that I woke up<br>那就是从我起床的那一刻开始<br>to the morning then to the end of the day<br>到一天结束<br>my life was a series of screens.<br>我的生活充斥着各种屏幕<br>I started the day with the thing that woke me up<br>早晨第一个叫醒我的是我的手机<br>first thing in the morning – my phone.<br>我的一天就这么开始了<br>And so I sat there in bed,<br>然后我就坐在床上<br>watching various cooking videos on Instagram<br>在ins上看各种各样的美食视频<br>and bouncing around between a bunch of different applications.<br>在不同的APP之间切换<br>But then, it was time to get out of bed and cook breakfast.<br>接着 我该起床做早饭了<br>And so the thing that I focused then on,<br>于是我关注的对象<br>in addition to the omelette in the pan<br>除了锅里的煎鸡蛋<br>was the iPad that was right next to the oven.<br>还有烤箱边上的iPad<br>And then it was time to do some work.<br>接下来我该去工作了<br>And so I went to a different screen,<br>我又到了另一个设备前<br>which was attached to another screen itself.<br>这个设备也自带一个屏幕<br>All the while this little devil on my wrist was tapping,<br>与此同时 我手腕上的这个小玩意儿 也一直在滴滴答答地响<br>and beeping, and blooping, and distracting me<br>分散着我的注意力<br>as I was trying to get important stuff done.<br>让我无法专心完成重要的工作<br>But there was one particular offender<br>但是在所有的这些设备中<br>out of all of these different devices<br>有一样最烦人<br>that I wasted more time on than anything else<br>浪费我时间最多<br>that was this dastardly thing – my phone.<br>那就是我的手机<br>I can spend hours on this thing every single day,<br>我每天要在上面耗费好几个小时<br>and so I decided to essentially for all intents and purposes<br>因此我决定 无论如何<br>get rid of the thing for a month.<br>要远离手机一个月<br>As an experiment, I thought I’m gonna live on this thing<br>作为试验 我把手机使用时间<br>for just 30 minutes every single day at a maximum.<br>设置为每天最多30分钟<br>And so this is the amount of time I have for maps,<br>每天就最多用这么多时间来查地图<br>this is the amout of time to call my mother,<br>给妈妈打电话<br>this is the amount of time that I have for everything that I could possibly wanna do.<br>这就是做所有我需要做的事情的时间<br>To listen to music, to listen to podcast.<br>听音乐 听广播<br>And I obsevered what happened during this time.<br>然后我观察这段时间发生的事情<br>It took about a week<br>我用了一个星期<br>to adjust downward into a new lower level of stimulation.<br>才把我的大脑调整到这个低刺激状态<br>But once I did,<br>但是我做到了之后<br>I noticed that three curious things began to happen.<br>三件神奇的事情发生了<br>First, my attention span grew.<br>首先 我的注意力持续时间增加了<br>It was like I could focus on things<br>也就是说我能更容易地进入专注状态了<br>not effortlessly but with much more ease<br>不说毫不费劲吧 但的确是比<br>than I could before this experiment started.<br>试验开始前更容易了<br>In addition to this though, as I was going about the world<br>除此之外 当我探索世界时<br>and especially when my mind wandered a bit,<br>特别是大脑有点走神的时候<br>I have more ideas that my mind arrived at.<br>我脑海里会涌现出更多的想法<br>And on top of this<br>而且<br>I had more plans and thoughts about the future.<br>我对未来有了更多的规划和思考<br>Getting rid of one simple device led to these three effects.<br>远离一个设备 就能带来这三点效果<br>Why?<br>为什么呢<br>Noticing this, a few years back led me on this long journey<br>从几年前注意到这点开始 我花了很长时间<br>to get to the bottom of what it takes to focus in a world of distraction.<br>研究如何才能专注 避免被其他事物分散注意力<br>I poured over hundreds of research papers<br>我把成百上千份研究报告铺开<br>from front to back of my office.<br>摊满了我的办公室<br>I don’t know if you’ve ever watched one of those crime shows<br>不知道大家看没看过刑侦节目<br>where somebody’s solving a murder<br>警察在破解谋杀案时<br>and so they have this big bristled board<br>他们在一块巨大的 透明板上系着绳子<br>and their string attached to papers,<br>贴着纸<br>attached to memos, attached to newspaper,<br>备忘录和报纸<br>but this is like what the state of my office was.<br>我的办公室就像那个样子<br>I flew out to meet experts around the world who study focus.<br>我飞到世界各地 去见研究专注力的专家们<br>I conducted more experiments on myself and tell the point.<br>我在自己身上做了更多试验 都指向同一点<br>I have 25,000 words of research notes about<br>我记了两万五千字的研究笔记<br>why this is the case.<br>来分析原因<br>How does technology influence our attention and our ability to focus?<br>科技是如何影响我们的注意力和专注力的<br>I want to start with the attention spans that we have.<br>首先我想讲一讲我们的注意力持续时间<br>This is how we pay attention to the world around us<br>也就是我们如何关注身边的世界<br>and how much control we have over our focus.<br>我们能在多大程度上控制自己的注意力<br>The research around this particular area is fascinating.<br>这个领域的研究令人惊叹<br>It turns out that when we to work in front of a computer<br>原来 当我们在电脑前工作时<br>especially when our phone is nearby,<br>尤其是手机在旁边的时候<br>we focus on one thing for just 40 seconds<br>我们专心做一件事的时间只有40秒<br>before we switch to doing something else.<br>然后就会被其它东西转移注意力<br>And when we have things like Slack open as we are doing some work,<br>而如果我们工作时开着Slack软件<br>this lowers to 35 seconds.<br>专注时间则会下降到35秒<br>But the reason that this is the case is not<br>但是通过这个研究<br>what we might think after looking at the research.<br>我发现原因并不是我们所想的那样<br>We think the problem is that our brains are distracted.<br>我们以为是大脑被分散了注意力<br>But after looking at the research this is what I’ve come to know as a symptom<br>但在读完研究报告后 我认识到这其实是一种征兆<br>for the deeper problem which runs much more deeply.<br>在更深层次的原因之下<br>It’s the root cause of this distraction.<br>有一个关键的问题<br>It’s not that we are distracted. It’s that our brains are over stimulated.<br>我们的大脑并不是被分散了注意力 而是被过度刺激了<br>It’s that we crave distraction in the first place.<br>我们一开始就渴望分心<br>Our brains love these tiny little nuggets of<br>我们的大脑喜欢这些小想法<br>information, and social media, and e-mail,<br>信息 社交媒体 邮件<br>and these things that we do over the course of the day.<br>以及一天里我们所做的所有事情<br>There is even a mechanism in our mind called the “novelty bias”<br>我们大脑里甚至还有一种机制叫做“新奇偏见”<br>by which our mind rewards us with a hit of dopamine,<br>大脑会释放多巴胺<br>one of those wonderful pleasure chemicals,<br>一种令人愉悦的化学物质<br>the same one that we get when we eat and order a whole medium pizza from Domino’s,<br>我们在吃一整块中份披萨<br>that you know the same one that we get when we make love.<br>或者做爱时大脑也会释放同样的多巴胺<br>We get that same stimulation when we check Facebook.<br>我们在刷Facebook时也会得到同样的刺激<br>We get these dopamine coursing through our mind and so we not only crave distraction<br>这些多巴胺在我们大脑中流动 所以我们不仅想要分神<br>but our mind rewards us for seeking out<br>我们大脑还会因为我们的探索而奖励我们<br>and finding distraction in the first place.<br>并且在第一时间找到让我们分神的东西<br>So this is the state of our minds today.<br>这是今天我们大脑的状态<br>We are at these hyper-stimulated state<br>在这样一个超级刺激状态下<br>where we bounce around between this bunch of different objects of attention<br>我们的注意力在不同的对象上不断跳跃<br>that are very very stimulating for our mind.<br>这对我们大脑刺激很大<br>So I thought, OK, if the phone had this impact on my attention span,<br>那么 鉴于手机对我们的注意力有如此大的影响<br>what if I lowered how stimulated I was even more still.<br>如果减少刺激会怎么样呢<br>And so, you know, this feeling that we experience<br>想象一下这种感觉<br>when we go from being in a state of high stimulation to a state of low stimulation,<br>当我们从高刺激状态进入低刺激状态时<br>it has a name. That name is called “boredom”.<br>这个过程有个名字 叫做厌倦<br>You know this is restlessness that we feel<br>你知道这会令我们感到焦躁<br>when we have this super busy week and then we were lying down a couch on a Sunday afternoon<br>忙碌的工作日过后 在一个阳光明媚的下午 躺在沙发上<br>and thinking, “What am I doing now?”<br>然后想：“我接下来要干嘛呢？”<br>So I challenged to put out a call<br>于是我鼓起勇气打了一个电话<br>to the readers on my website and I asked them,<br>打给我网站的读者 我问他们<br>“What is the most boring thing that you can think of doing?<br>“你认为你能想到的最无聊的事是什么<br>I’m gonna make myself bored for an hour a day for a month.”<br>我将在一个月里每天都让自己无聊一个小时”<br>And so I did some stuff that<br>所以接下来我做了这些事情<br>I still upset about from my readers to this day.<br>我到现在都觉得那天我不该问那些读者<br>Day 1 I read the iTunes terms and conditions for one hour.<br>第一天我阅读了一个小时iTunes的使用条款<br>It’s actually shorter and more readable than you might think.<br>其实这个比你想象中更短 更有意思<br>Day 4 I waited on hold of with Air Canada’s baggage claims department.<br>第四天我给加拿大航空公司行李认领部门打了电话<br>It’s very easy this is a trick. If you wanna make yourself bored<br>当你想要无聊的时候 去搞一个这样的恶作剧是很简单的<br>don’t call the reservations department, call the baggage claim people,<br>注意不要打预订部门电话 要打行李认领部门电话<br>‘coz you are gonna wait for hours if you ever get through it all.<br>不然你将会等一个小时 要是你熬得住的话<br>Day 19 I counted all the zeros that I could<br>第19天我数了圆周率前一万位中<br>in the first ten thousand digits of pi.<br>所有零的个数<br>Day 24 I watched a clock<br>第24天我看一个闹钟<br>“tick…tick…” for one hour.<br>滴答……滴答……整整一个小时<br>And 27 other activities this month.<br>还有我这个月的其他27个活动<br>‘Geeze.’ I still think that.<br>现在回想起来都觉得 “哦 天呐”<br>But curiously, I noticed the exact same effects<br>但是神奇的是<br>as I did during the smartphone experiment.<br>这竟和我当初做手机实验时的效果一样<br>It took about a week for my mind<br>我花了一周时间<br>to adjust downward into a newer lower level of stimulation.<br>来把我的大脑调整到低刺激状态<br>And this map curiously on top of research that shows<br>这个实验很神奇的显示了<br>that it takes our mind about 8 days to fully calm down and rest,<br>我们的大脑需要花费大约8天的时间才能平静下来<br>like when we are on a vacation as an example.<br>就像在度假时一样<br>Our vacations need to be longer than they are today.<br>我们的假期应该更长一点<br>But I also noticed that my attention span expanded.<br>我也发现我的注意力提高了<br>I was able to focus even more effortlessly,<br>我更容易集中注意力了<br>because I wasn’t surrounded by fewer distractions,<br>因为我不再被那些能使我分心的事物包围<br>but my mind was so much less stimulated<br>我的大脑不再处于高刺激状态<br>that it did not seek the distraction in the first place.<br>不再容易突然分神<br>But the fun part where these ideas and plans that struck me that didn’t before.<br>有趣的是 我还有了之前没有过的一些想法和计划<br>And the reason that this is the case is because my mind had a chance<br>这是因为我的大脑有机会<br>to wander more often.<br>去思考更多了<br>There is a great quote that I love<br>这里有一句我很喜欢的话<br>that you might be familiar with from J.R.R Tolkien,<br>你们可能知道这句话 J.R.R.托尔金说的<br>where he says that, “Not all those who wander are lost.”<br>“不是所有踌躇的人都迷失了方向”<br>And the exact same thing is true.<br>确实如此<br>It turns out with regard to our focus with regard to our attention.<br>这与我们注意力的集中有关<br>If you think back to when your best most brilliant ideas strike you,<br>你回想一下 除非你有一个绝妙的想法<br>you rarely focused on something.<br>否则你很少在某件事上集中注意力<br>Maybe this morning you were taking a shower,<br>可能你在今天早上洗了一个澡<br>or maybe some morning in the past and<br>或者可能在过去的某一个早晨<br>then your mind had a chance to connect several of the constellations of ideas<br>你的脑海里出现了很多的想法<br>that were swirling around in your mind to create an idea<br>它会在你思考的时候打乱你<br>that would never have materialized otherwise<br>你将永远无法把这些主意具体化<br>if you were focused on something else, on your phone, for example.<br>如果你一直把你的注意力放在其他东西上 比如手机<br>This is a mode especially when we do this deliberately<br>尤其在我们故意这样做的时候 这就变成了一种模式<br>when we deliberately let our mind wander.<br>我们故意让大脑去漫游<br>I called this mode “Scatterfocus”.<br>我将这种模式称为“分散注意力”<br>And the research shows that it lets our mind come up with ideas.<br>这个研究显示它能令你的大脑产生想法<br>It lets our mind plan because of where our mind wanders to.<br>这也能让我们的大脑按我们所想的进行计划<br>This is fascinating.<br>这很吸引人<br>It turns out that when we just let our attention at rest,<br>它显示了当我们让自己的注意力放松时<br>it goes to three main places.<br>大脑会做三件事<br>We think about the past.<br>回忆过去<br>We think about the present.<br>考虑现在<br>And we think about the future.<br>以及思考未来<br>But we think about the past less than we might think,<br>但是我们回忆过去的时间要比我们想象的短<br>only about 12% of the time.<br>仅占我们所想时间的12%<br>And often that time we were recalling ideas<br>回忆过去通常只是<br>in these thoughts wandering episodes.<br>一个小插曲<br>But the present, which is a much more productive place to wander.<br>因为现在更值得去思考<br>We wandered to think about the present 28% of the time,<br>我们用28%的时间来思考现在<br>and so this is, you know it’s something as simple as you’re typing up an e-mail.<br>就像你在写邮件时<br>And you can’t find a way to free something<br>你找不到办法去放松<br>because it’s very delicate maybe it’s political.<br>因为你需要很小心 可能这封邮件是关于政治的<br>You go and walk to another room,<br>你走到其他房间<br>you go to another room of the house, of the office.<br>你走到家里或办公室里的其他房间<br>The solution hits you because your mind had a chance to approach it<br>你突然就有了解决方法 因为你的大脑有机会<br>and prod at that problem from different directions.<br>去看到问题的不同方面<br>But here is the thing.<br>但有一点<br>Our minds wandered to think about the future<br>我们的大脑想要思考更多关于未来的事<br>more than the past and the present combined.<br>比关于过去和现在的事加起来还要多<br>Whenever our mind is wandering we think about the future 48% of the time.<br>无论什么时候 我们大脑所想的48%是关于未来的<br>This is why when we were taking a shower we plan out<br>这就是为什么我们在洗澡的时候<br>our entire day even though it hasn’t started yet.<br>会做一整天的计划 尽管这天还没到来<br>This is called our mind’s “prospective bias”<br>这叫做“预知偏见”<br>and it occurs when our mind wanders.<br>并且在我们神游的时候也会出现<br>If you are good with math, or maths I should say,<br>如果你数学很好的话<br>not in Canada anymore,<br>当然 在加拿大是不可能的<br>these numbers don’t add up to 100<br>这些数字很难加到100<br>because the rest of time our mind is dull.<br>由于我们的大脑在某些时间是迟钝的<br>It’s blank or doesn’t have an idea inside of it that is rooted in time.<br>所以有时候它会是空白的<br>But whatever it is for you that lets your mind wander,<br>但是无论如何 让你的大脑去想<br>something that is simple,<br>一些简单的事情<br>something that doesn’t consume your full attention.<br>不会消耗你全部注意力的事情<br>Mine happens to be something that is not necessarily stereotypical<br>对于我这个年龄和性别来说<br>of my age, and gender, demographic.<br>我有一些奇怪的癖好<br>But I love to knit.<br>我喜欢织毛线<br>Knitting is one of my favorite hobbies.<br>这是我最大的爱好之一<br>I knit in planes. I knit on trains. I knit in hotel rooms.<br>我在飞机上 火车上 在宾馆 我都会织<br>I was knitting in the hotel room before this event today<br>这几天我在住的宾馆里就有织毛线<br>‘coz it helps calm you down. It helps settle your nerves.<br>因为这能让我平静 能减少焦虑<br>And I come up with so many ideas when I knit.<br>我的许多想法都是织毛线的时候想到的<br>I have a notepad next to me.<br>我会在旁边放一本记事本<br>But whatever it is for you,<br>但对你来说可能是别的<br>might be taking an extra long shower, might be taking a bath,<br>可能是洗个很久的淋浴 或是泡澡<br>upgrading your shower to a bath,<br>将淋浴升级为浴缸<br>so you can soak not just with your body but with your ideas as well.<br>你浸透的不仅是身体 还有你的思想<br>Could be simple if you are at work walking from one room to another in the office.<br>工作时从一间办公室走到另外一间<br>Very simple change but if you don’t use your phone during that walk,<br>虽然很简单 但如果你在走路时不使用手机<br>your mind will go to the meeting that you are about to attend.<br>你的头脑将会更专注于即将参加的会议<br>It’ll go to the call that you are just on.<br>它会转移到你刚刚接到的那通电话<br>It’ll wander to the ideas that are circulating.<br>转移到刚刚盘旋在你脑中的想法<br>And it’ll make you more creative in this way.<br>这样你就变得更有创造力了<br>It could be something as simple as waiting in line,<br>这就和排队等候一样简单<br>and just, I don’t know, waiting in line.<br>就像在排队<br>It could be getting a massage and whatever it is that lets your mind<br>可以是做个按摩或者任何能让你大脑放松的事<br>I love this picture so much [chuckle]<br>我超喜欢这张图<br>Whatever you love doing, here is a pro-tip.<br>无论你喜欢做什么 给你一个提示<br>Ask the masseuse to let you have a notepad in the session,<br>在这段时间里叫按摩师给你一个便条<br>because ideas always come to you and you are always incubating things,<br>因为想法一直涌向你 并且你会不断产生新想法<br>and so capture them so you can act upon them later.<br>抓住它们 这样后面你就能行动起来<br>But I think after doing this deep dive into the research,<br>但是在深入研究以后<br>we need to make two fundamental shifts<br>我认为我们需要两个基本的转变<br>with regard to how we think about our intention.<br>关于如何思考我们的目的<br>We think that we need to fit more in,<br>我们认为自己应该更加适应<br>you know, there is all this talk about hustling.<br>你知道很多演讲都是关于奋斗的<br>I’m an anti-hustler.<br>我是一个反对忙碌的人<br>I’m one of the laziest people you’ll ever meet,<br>我是你们见过最懒的人之一<br>and I think that’s what gives me so many ideas to talk and write about.<br>我认为这恰好给了我很多想法去说 去写<br>We don’t need to fit more in.<br>我们不需要再去适应<br>We are doing enough. We are doing too much.<br>我们做的足够了 够多了<br>We are doing so much that our mind never wanders anymore.<br>我们做的如此之多 以至于我们的大脑不再漫游<br>It’s sad. This is when our best ideas and plans come to us.<br>这很可惜 我们本来可以有更好的想法和计划<br>We need more space.<br>我们需要更多空间<br>If you look at what allows traffic to move down the highway,<br>看看高速公路 是什么让交通移动<br>what allows it to move forward isn’t how fast cars are moving as you might expect.<br>不是你以为的车在以多么快的速度前进<br>It’s how much spaces exists between the cars<br>而是车辆之间存在的空间<br>that allows traffic to move forward.<br>这才是让交通向前移动的原因<br>Our work and our life are the same way.<br>我们的工作和生活也是如此<br>The second shift.<br>第二个转变<br>We like to think of distraction as the enemy of focus.<br>我们喜欢把三心二意当做全神贯注的敌人<br>It is not.<br>不是这样的<br>It is the symptom of why we find it difficult to focus,<br>为什么我们很难集中注意力<br>which is the fact that our mind is over stimulated.<br>因为我们大脑被过度刺激了<br>I have a challenge for you.<br>我给你们一个挑战<br>It’s a two-week challenge,<br>一个为期两周的挑战<br>but it’s a challenge to make your mind a bit less stimulated<br>这是个能减少对你大脑的刺激<br>and simply notice what happens to your attention,<br>并且只关注对你注意力影响的挑战<br>how many ideas do you get,<br>你有多少想法<br>how does your focus change,<br>你的注意力是如何转变的<br>how many plans do you make.<br>你制定了多少计划<br>So for two weeks, make your mind less stimulated.<br>所以在两周里 让你的大脑少受刺激<br>There are so many great features on phones and devices<br>在手机上和其他设备上有如此多的诱惑<br>that will let us eliminate a lot of the time we waste on our devices.<br>这会让我们减少大量浪费在这些设备上的时间<br>Use those features, not only to become aware of how you spend your time,<br>使用这些方法 不仅能让你意识到 自己是如何利用时间的<br>but how you can spend less so you have more ideas.<br>而且能让你知道如何产生更多的想法<br>Have a disconnection ritual every evening.<br>每天来个晚上断网仪式<br>One of my favorite daily rituals I disconnect from internet completely from 8pm to 8am.<br>我最喜欢的日常仪式之一 就是晚上八点到早上八点的断网<br>My fiancee and I, we have a weekly disconnection ritual,<br>我和我的未婚妻每周都有一个断网仪式<br>a technology sabbath every Sunday<br>每个星期天的科技安息日<br>so we can disconnect from the digital world<br>这样我们就能与数字世界断开联系<br>and reconnect with the physical world, the real actual world.<br>与物理世界和现实世界重新连接<br>Rediscover boredom. You don’t have to do it for an hour.<br>重新回归到无聊 你不一定要坚持断网满一个小时<br>Please don’t call our Canada, it’s just a world of help.<br>请不要打电话给我们加拿大人 这是一个互相帮助的世界<br>But rediscover boredom, just for a few minutes.<br>重新回归到无聊 即使只有几分钟<br>Lay on the couch and where does your mind go.<br>躺在沙发上 跟着自己的想法走<br>And scatter your attention.<br>分散你的注意力<br>You’ll find some remarkably fruitful things, in that attentional zone.<br>在那个专注的时间段里 你会收获很多<br>If there is one thing that I’ve found to be true<br>在我探索这个世界 关于我们如何集中注意力之后<br>after doing this deep dive into this world on how we focus,<br>如果有一件已经被我证实是正确的事情<br>it’s that state of our attention is what determines the state of our lives.<br>那就是我们注意力的状态决定我们的生活状态<br>If we are distracted in each moment,<br>如果我们与每个瞬间断开联系<br>those moments of distraction and over-stimulation build up and accumulate<br>这些分心和受到过度刺激的瞬间就会累积<br>to create a life that feels more distracted and overwhelming,<br>会制造一个更加容易分心并且疲惫的生活<br>like we don’t have a clear direction.<br>就像我们失去了明确的方向<br>But, when we become less stimulated, when we make our mind more calm,<br>但当我们受到更少的刺激 大脑更加冷静的时候<br>we get the benefits of added productivity and focus on ideas and creativity,<br>我们就能够集中想法和创造力 从而得到益处<br>but we also live a better life because of it.<br>我们也会因此生活的更好<br>Thank you so much!<br>谢谢大家</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%B8%93%E6%B3%A8%E5%8A%9B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"
                            aria-label=": 算法导论"
                        >
                            算法导论
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T22:07:23+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="1-1算法"><a href="#1-1算法" class="headerlink" title="1.1算法"></a>1.1算法</h2><p>非正式地讲,算法是任何公认的计算程序,它以一些数值或一组数值作为输入,在一定的时间内产生一些数值或一组数值作为输出.<br>因此,一个算法是一连串的计算步骤.因此,算法是将输入转化为输出的一系列计算步骤.</p>
<p>你也可以把算法看作是解决一个精心设计的计算问题的工具.问题的陈述以一般条款(term)规定了问题实例所需的输入&#x2F;输出关系,<br>通常是任意大的输入.算法描述了一个特定的计算程序,用于实现所有实例的输入&#x2F;输出关系. 进而完成所有问题的输入&#x2F;输出关系.</p>
<p>举个例子,假设你需要将一串数字按单调递增的顺序排序.这个问题在实践中经常出现,并提供了许多标准设计技术和为分析工具提供了肥沃的土壤(提供了很多理论时间机会).下面是我们如何正式确定排序问题的.<br>Input: A sequence of n numbers (a1,a2….ani)<br>Output:一个输入序列的排列组合（重新排序）(a1’,a2’….an’),即(a1’小于 a2’ 小于 …an’)(这表示排序的意思,是一种广义定义)</p>
<h2 id="15-动态规划"><a href="#15-动态规划" class="headerlink" title="15.动态规划"></a>15.动态规划</h2><p>简单讲跟分治方法很像,但是分治是将将问题分解然后一个一个解决,但是动态规划是找子问题重叠的情况,既不同的子问题有公共的子问题,及将子问题求解一遍再将其保存到表格中.传统的递归时间复杂度会有2的N次幂,而用DP改写就会有N的2次幂</p>
<h3 id="15-1-钢条切割"><a href="#15-1-钢条切割" class="headerlink" title="15.1 钢条切割"></a>15.1 钢条切割</h3><p>一个钢条,按照不同长度切割可以卖出不同价格</p>
<table>
<thead>
<tr>
<th>length</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>price</td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>17</td>
<td>17</td>
<td>20</td>
<td>30</td>
</tr>
</tbody></table>
<ol>
<li><p>传统递归<br>其实是尝试遍了所有的可能性.所以开销很大<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b543d0ff04056b6813faff9f3c32e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>就如上图,每一个分治就是一种可能</p>
</li>
<li><p>自底向上的动态规划</p>
</li>
</ol>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; Cut-Rod with bottom-up method
int BottomUpCutRod(const std::vector&lt;int&gt; &amp;p, const int &amp;n)
&#123;
    std::vector&lt;int&gt; r&#123;0&#125;;
    for (auto j &#x3D; 1; j &lt;&#x3D; n; ++j)
    &#123;
        int q &#x3D; INT8_MIN;
        for (auto i &#x3D; 1; i &lt;&#x3D; j; ++i)
        &#123;
            q &#x3D; std::max(q, p.at(i) + r.at(j - i));
        &#125;
        r.push_back(q);
    &#125;
    return r.at(n);
&#125;</code></pre>

<h3 id="15-2-最大子序和"><a href="#15-2-最大子序和" class="headerlink" title="15.2 最大子序和"></a>15.2 最大子序和</h3><p>这道题是来自leetcode.给你一个整数数组 nums,请你找出一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和.子数组 是数组中的一个连续部分.<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb52e9f8c446efbe01435060ce41c4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<pre class="language-golang" data-language="golang"><code class="language-golang"> &#x2F;&#x2F; &#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;
func maxSubArray(nums []int) int &#123;


 if len(nums) &#x3D;&#x3D; 0 &#123;
  return 0
 &#125;
 res :&#x3D; -32768
 f_n :&#x3D; -1

 for i :&#x3D; 0; i &lt; len(nums); i++ &#123;
  f_n &#x3D; Max(nums[i], f_n+nums[i])
  res &#x3D; Max(f_n, res)
 &#125;
 return res
&#125;

func Max(a int, b int) int &#123;

 if a &gt;&#x3D; b &#123;
  return a
 &#125;
 return b
&#125;</code></pre>

<p>这里主要是使用了<strong>kadane</strong>算法,使用一个变量跟踪最大值,f_n &#x3D; Max(nums[i], f_n+nums[i])是kadane的核心思想,如果我下个位置的数字大于你们前面的和,说明前面的结果就不是最大整数和</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB/"
                            aria-label=": 如何阅读-TED"
                        >
                            如何阅读-TED
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T22:05:35+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TED/">TED</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>TED<br>1.做笔记</p>
</blockquote>
<p>2.费曼学习法</p>
<p>​ 写下假设找出知识上的差距。<br>3.存档你的笔记</p>
<p>​ 理清框架，并起一个标题</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/API_design%E5%8E%9F%E5%88%99/"
                            aria-label=": API Design Patterns"
                        >
                            API Design Patterns
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T21:55:02+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/WEB-API/">WEB-API</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1. API介绍"></a>1. API介绍</h2><h3 id="1-1-什么是API"><a href="#1-1-什么是API" class="headerlink" title="1.1 什么是API"></a>1.1 什么是API</h3><p>定义一组与系统交互的界面,是的用户有相对较小的权限操作系统</p>
<h3 id="1-2-为什么API重要"><a href="#1-2-为什么API重要" class="headerlink" title="1.2 为什么API重要"></a>1.2 为什么API重要</h3><p>不需要像GUI那样很”cosmetic”</p>
<h3 id="1-3-什么是面向资源API"><a href="#1-3-什么是面向资源API" class="headerlink" title="1.3 什么是面向资源API"></a>1.3 什么是面向资源API</h3><ul>
<li>RPC-API<br>RPC APIs are often designed in terms of interfaces and methods. As more and more of these are added over time, the end result can be an overwhelming and confusing API surface due to the fact that developers must learn each method individually. Obviously this is both time consuming and error-prone.<br>RPC的命名没有严格的要求，无状态的，随着RPC的接口增加，接口管理就会面临混乱结果</li>
<li>HTTP-API<br>The architectural style of REST was introduced, primarily designed to work well with HTTP&#x2F;1.1, but also to help tackle this problem. Its core principle is to define named resources that can be manipulated using a small number of methods. The resources and methods are known as nouns and verbs of APIs. With the HTTP protocol, the resource names naturally map to URLs, and methods naturally map to HTTP methods POST, GET, PUT, PATCH, and DELETE. This results in much fewer things to learn, since developers can focus on the resources and their relationship, and assume that they have the same small number of standard methods.<br>通常url就是资源的映射，对资源的CRUD就是对应HTTP的PATCH,POST,GET DELETE</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cloud.google.com/apis/design/resources">https://cloud.google.com/apis/design/resources</a></p>
</blockquote>
<h3 id="1-4-什么是”good”API"><a href="#1-4-什么是”good”API" class="headerlink" title="1.4 什么是”good”API"></a>1.4 什么是”good”API</h3><ul>
<li>Operational<br>你的API必须得work,高效。</li>
<li>Expressive<br>你的method必须是具有描述意义的，告诉用户你能做什么</li>
<li>Simple<br>Another common position on simplicity takes the old saying about the “common<br>case” (“Make the common case fast”) but focuses instead on usability while leaving<br>room for edge cases. This restatement is to “make the common case awesome and the<br>advanced case possible.” This means that whenever you add something that might<br>complicate an API for the benefit of an advanced user, it’s best to keep this complication sufficiently hidden from a typical user only interested in the common case. This<br>keeps the more frequent scenarios simple and easy, while still enabling more<br>advanced features for those who want them</li>
<li>Predictable<br>方法和参数需要见名知意<br>APIs built using well-known, well-defined, clear</li>
</ul>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><ul>
<li>Interfaces are contracts that define how two systems should interact with one another.</li>
<li>APIs are special types of interfaces that define how two computer systems interact with one another, coming in many forms, such as downloadable libraries and web APIs.</li>
<li>Web APIs are special because they expose functionality over a network, hiding the specific implementation or computational requirements needed for that functionality.</li>
<li>Resource-oriented APIs are a way of designing APIs to reduce complexity byrelying on a standard set of actions, called methods, across a limited set of things, called resources.</li>
<li>What makes APIs “good” is a bit ambiguous, but generally good APIs are operational, expressive, simple, and predictable.</li>
<li>对数据和系统的抽象会决定你的API – 李沐</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/API_design%E5%8E%9F%E5%88%99/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%88%87shell%E8%85%B3%E6%9C%AC%E7%B7%A8%E7%A8%8B%E5%A4%A7%E5%85%A8/"
                            aria-label=": Linux命令行与shell腳本編程大全"
                        >
                            Linux命令行与shell腳本編程大全
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T21:53:01+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/linux/">linux</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#1-linux%E5%85%A5%E9%97%A8">1. linux入门</a></li>
<li><a href="#2-%E8%B5%B0%E8%BF%9Bshell">2. 走进shell</a></li>
<li><a href="#3-%E5%9F%BA%E6%9C%ACshell%E5%91%BD%E4%BB%A4">3. 基本shell命令</a><ul>
<li><a href="#31-%E5%90%AF%E5%8A%A8shell">3.1 启动shell</a></li>
<li><a href="#32-bash-%E6%89%8B%E5%86%8C">3.2 bash 手册</a></li>
<li><a href="#34-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">3.4 文件系统</a></li>
</ul>
</li>
<li><a href="#4-%E5%85%B6%E4%BB%96shell%E5%91%BD%E4%BB%A4">4. 其他shell命令</a><ul>
<li><a href="#41-%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F">4.1 监控程序</a><ul>
<li><a href="#411-ps%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">4.1.1 ps查看进程</a></li>
<li><a href="#412-top%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7">4.1.2 top实时监控</a></li>
<li><a href="#413-kill%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B">4.1.3 kill结束进程</a></li>
<li><a href="#414-%E7%B3%BB%E7%BB%9Fperformance%E7%9B%91%E6%8E%A7">4.1.4 系统performance监控</a></li>
</ul>
</li>
<li><a href="#42-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9B%91%E6%8E%A7">4.2 磁盘空间监控</a><ul>
<li><a href="#421-mount%E6%8C%82%E5%9C%A8%E5%AD%98%E5%82%A8%E5%AA%92%E4%BD%93">4.2.1 mount挂在存储媒体</a></li>
<li><a href="#422-unmount-%E5%8D%B8%E8%BD%BD%E8%AE%BE%E5%A4%87">4.2.2 unmount 卸载设备</a></li>
<li><a href="#423-df-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5">4.2.3 df 查看磁盘使用情况</a></li>
<li><a href="#424-du-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4">4.2.4 du 磁盘空间</a></li>
</ul>
</li>
<li><a href="#43-%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6">4.3 处理文件</a><ul>
<li><a href="#431-sort---%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F">4.3.1 sort - 文件排序</a></li>
<li><a href="#432-grep---%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6">4.3.2 grep - 搜索文件</a></li>
<li><a href="#433-zip--gzipgz-compressz-bzip2bz2-%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE">4.3.3 zip , gzip:gz, compress:Z, bzip2:bz2 压缩数据</a></li>
<li><a href="#434-tar-%E5%BD%92%E6%A1%A3%E6%95%B0%E6%8D%AE">4.3.4 tar 归档数据</a></li>
<li><a href="#435-find-%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4">4.3.5 find 搜索命令</a></li>
<li><a href="#436-uname-%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E4%BF%A1%E6%81%AF">4.3.6 uname 显示系统内核信息</a></li>
</ul>
</li>
<li><a href="#44-date%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6%E6%A0%BC%E5%BC%8F%E5%8C%96">4.4 date命令及其格式化</a></li>
</ul>
</li>
<li><a href="#5-%E7%90%86%E8%A7%A3shell">5. 理解shell</a><ul>
<li><a href="#51-shell%E7%9A%84%E7%B1%BB%E5%9E%8B">5.1 shell的类型</a></li>
<li><a href="#52-shell%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB">5.2 shell的父子关系</a><ul>
<li><a href="#521-%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8">5.2.1 进程列表</a></li>
<li><a href="#522-%E5%AD%90shell%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95">5.2.2 子shell的其他用法</a></li>
</ul>
</li>
<li><a href="#53-%E7%90%86%E8%A7%A3shell%E7%9A%84%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4">5.3 理解shell的内建命令</a><ul>
<li><a href="#531-%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4">5.3.1 外部命令</a></li>
<li><a href="#532-%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4">5.3.2 内部命令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">6. 环境变量</a></li>
<li><a href="#7-linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">7. linux文件权限</a><ul>
<li><a href="#71-linux%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7">7.1 linux的安全性</a><ul>
<li><a href="#711-%E6%B7%BB%E5%8A%A0linux%E7%94%A8%E6%88%B7">7.1.1 添加linux用户</a></li>
<li><a href="#712-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7">7.1.2 删除用户</a></li>
<li><a href="#712-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7">7.1.2 修改用户</a></li>
</ul>
</li>
<li><a href="#72-%E4%BD%BF%E7%94%A8linux%E7%BB%84">7.2 使用linux组</a></li>
<li><a href="#73-%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">7.3 理解文件权限</a></li>
<li><a href="#74-%E6%94%B9%E5%8F%98%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E7%BD%AE">7.4 改变安全性设置</a></li>
<li><a href="#75-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6">7.5 共享文件</a></li>
</ul>
</li>
<li><a href="#9-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F">9. 安装软件程序</a><ul>
<li><a href="#91-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">9.1 包管理工具</a></li>
<li><a href="#92-%E5%9F%BA%E4%BA%8Edebian%E7%9A%84%E7%B3%BB%E7%BB%9F">9.2 基于Debian的系统</a><ul>
<li><a href="#921-%E7%94%A8aptitude-%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85">9.2.1 用aptitude 管理软件包</a></li>
</ul>
</li>
<li><a href="#93-%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85">9.3 基于源码安装</a></li>
</ul>
</li>
<li><a href="#10-%E4%BD%BF%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8">10. 使用编辑器</a><ul>
<li><a href="#101-vim-%E7%BC%96%E8%BE%91%E5%99%A8">10.1 vim 编辑器</a></li>
</ul>
</li>
<li><a href="#11%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC">11.基本脚本</a></li>
<li><a href="#12-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4">12. 使用结构化命令</a></li>
<li><a href="#13-for-%E5%BE%AA%E7%8E%AF">13. for 循环</a><ul>
<li><a href="#131-for%E5%91%BD%E4%BB%A4">13.1 for命令</a></li>
<li><a href="#132-c%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC">13.2 C语言风格</a></li>
<li><a href="#133-while%E8%AF%AD%E5%8F%A5">13.3 while语句</a></li>
<li><a href="#134-until%E5%91%BD%E4%BB%A4">13.4 until命令</a></li>
<li><a href="#135-%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BB%A5%E7%89%B9%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6%E5%88%86%E5%89%B2%E6%95%B0%E6%8D%AE">13.5 循环处理数据并以特定分隔符分割数据</a></li>
</ul>
</li>
<li><a href="#14-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">14. 处理用户输入</a><ul>
<li><a href="#141-%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E8%84%9A%E6%9C%AC%E5%90%8D%E5%92%8C%E6%B5%8B%E8%AF%95%E5%8F%82%E6%95%B0">14.1 读取参数，脚本名和测试参数</a></li>
<li><a href="#142-%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9">14.2 处理选项</a></li>
<li><a href="#143-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">14.3 获取用户输入</a></li>
</ul>
</li>
<li><a href="#15-%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE">15. 呈现数据</a><ul>
<li><a href="#151-%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">15.1 理解输入和输出</a><ul>
<li><a href="#1511-%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.1.1 标准文件描述符</a></li>
<li><a href="#1512-%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF">15.1.2 重定向错误</a></li>
</ul>
</li>
<li><a href="#152-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA">15.2 在脚本中重定向输出</a><ul>
<li><a href="#1521-%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91">15.2.1 临时重定向</a></li>
<li><a href="#1522-%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91">15.2.2 永久重定向</a></li>
</ul>
</li>
<li><a href="#153-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5">15.3 在脚本中重定向输入</a></li>
<li><a href="#154-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91">15.4 创建自己的重定向</a><ul>
<li><a href="#1541-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.1 创建输出文件描述符</a></li>
<li><a href="#1542-%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.2 重定向文件描述符</a></li>
<li><a href="#1543-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.3 创建输入文件描述符</a></li>
<li><a href="#1544-%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.4 创建读写文件描述符</a></li>
<li><a href="#1545-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.5 关闭文件描述符</a></li>
</ul>
</li>
<li><a href="#155-%E5%88%97%E5%87%BA%E6%9C%AA%E5%85%B3%E9%97%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.5 列出未关闭的文件描述符</a></li>
<li><a href="#156-%E7%BB%84%E7%BB%87%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA">15.6 组织命令输出</a></li>
<li><a href="#157-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">15.7 创建临时文件</a><ul>
<li><a href="#1571-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">15.7.1 创建本地临时文件</a></li>
<li><a href="#1572-%E5%9C%A8temp%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">15.7.2 在&#x2F;temp&#x2F;创建临时文件</a></li>
<li><a href="#1573-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95">15.7.3 创建临时目录</a></li>
</ul>
</li>
<li><a href="#158-%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF">15.8 记录消息</a></li>
<li><a href="#159-%E5%AE%9E%E6%88%98">15.9 实战</a></li>
</ul>
</li>
<li><a href="#16-%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC">16. 控制脚本</a><ul>
<li><a href="#161-%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7">16.1 处理信号</a><ul>
<li><a href="#1611-%E9%87%8D%E6%B8%A9linux%E4%BF%A1%E5%8F%B7">16.1.1 重温linux信号</a></li>
<li><a href="#1612-%E7%94%9F%E6%88%90%E4%BF%A1%E5%8F%B7">16.1.2 生成信号</a></li>
<li><a href="#1613-%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7">16.1.3 捕获信号</a></li>
<li><a href="#1614-%E6%8D%95%E8%8E%B7%E8%84%9A%E6%9C%AC%E9%80%80%E5%87%BA">16.1.4 捕获脚本退出</a></li>
<li><a href="#1615-%E4%BF%AE%E6%94%B9%E6%88%96%E7%A7%BB%E9%99%A4%E6%8D%95%E8%8E%B7">16.1.5 修改或移除捕获</a></li>
</ul>
</li>
<li><a href="#162-%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">16.2 以后台模式运行脚本</a><ul>
<li><a href="#1621-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">16.2.1 后台运行脚本</a></li>
<li><a href="#1622-%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%90%8E%E5%8F%B0%E4%BD%9C%E4%B8%9A">16.2.2 运行多个后台作业</a></li>
<li><a href="#1623-%E5%9C%A8%E9%9D%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">16.2.3 在非控制台下运行程序</a></li>
</ul>
</li>
<li><a href="#164-%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6">16.4 作业控制</a><ul>
<li><a href="#1641-%E6%9F%A5%E7%9C%8B%E4%BD%9C%E4%B8%9A">16.4.1 查看作业</a></li>
<li><a href="#1642-%E9%87%8D%E5%90%AF%E5%81%9C%E6%AD%A2%E7%9A%84%E4%BD%9C%E4%B8%9A">16.4.2 重启停止的作业</a></li>
</ul>
</li>
<li><a href="#165-%E8%B0%83%E6%95%B4%E8%B0%A6%E8%AE%A9%E5%BA%A6">16.5 调整谦让度</a><ul>
<li><a href="#1651-nice-%E5%91%BD%E4%BB%A4">16.5.1 nice 命令</a></li>
<li><a href="#1652-renice-%E5%91%BD%E4%BB%A4">16.5.2 renice 命令</a></li>
</ul>
</li>
<li><a href="#166-%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A">16.6 定时运行作业</a><ul>
<li><a href="#1661-%E7%94%A8at%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%AE%A1%E5%88%92%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A">16.6.1 用at命令来计划执行作业</a></li>
<li><a href="#1662-%E5%AE%89%E6%8E%92%E9%9C%80%E8%A6%81%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC">16.6.2 安排需要定期执行的脚本</a></li>
<li><a href="#1663-%E4%BD%BF%E7%94%A8%E6%96%B0shell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC">16.6.3 使用新shell启动脚本</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#17-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">17. 创建函数</a><ul>
<li><a href="#171-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0">17.1 基本的脚本函数</a><ul>
<li><a href="#1711-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">17.1.1 创建函数</a></li>
<li><a href="#1712-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0">17.1.2 使用函数</a></li>
</ul>
</li>
<li><a href="#172-%E8%BF%94%E5%9B%9E%E5%80%BC">17.2 返回值</a><ul>
<li><a href="#1721-%E9%BB%98%E8%AE%A4%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81">17.2.1 默认退出状态码</a></li>
<li><a href="#1722-%E4%BD%BF%E7%94%A8return%E5%91%BD%E4%BB%A4">17.2.2 使用return命令</a></li>
<li><a href="#1723-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA">17.2.3 使用函数输出</a></li>
</ul>
</li>
<li><a href="#173-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">17.3 在函数中使用变量</a><ul>
<li><a href="#1731-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">17.3.1 向函数传递参数</a></li>
<li><a href="#1732-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F">17.3.2 在函数中处理变量</a></li>
</ul>
</li>
<li><a href="#174-%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0">17.4 数组变量和函数</a><ul>
<li><a href="#1742-%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84">17.4.2 从函数中返回数组</a></li>
</ul>
</li>
<li><a href="#175-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92">17.5 函数递归</a></li>
<li><a href="#176-%E5%88%9B%E5%BB%BA%E5%BA%93">17.6 创建库</a></li>
<li><a href="#177-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0">17.7 在命令行上使用函数</a><ul>
<li><a href="#1771-%E5%9C%A8%E5%91%BD%E4%BB%A4%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">17.7.1 在命令上创建函数</a></li>
<li><a href="#1772-%E5%9C%A8bashrc-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">17.7.2 在.bashrc 文件中定义函数</a></li>
</ul>
</li>
<li><a href="#178-%E5%AE%9E%E4%BE%8B">17.8 实例</a><ul>
<li><a href="#1781-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93">17.8.1 下载安装第三方库</a></li>
<li><a href="#1782-%E6%9E%84%E5%BB%BA%E5%BA%93">17.8.2 构建库</a></li>
<li><a href="#1783-shtool%E5%BA%93%E5%87%BD%E6%95%B0">17.8.3 shtool库函数</a></li>
<li><a href="#1784-%E4%BD%BF%E7%94%A8%E5%BA%93">17.8.4 使用库</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#18-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E4%B8%AD%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B">18. 图形化界面中脚本编程</a></li>
<li><a href="#19%E5%88%9D%E8%AF%86sed%E5%92%8Cgawk">19.初识sed和gawk</a><ul>
<li><a href="#191-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86">19.1 文本处理</a><ul>
<li><a href="#1911-sed%E7%BC%96%E8%BE%91%E5%99%A8">19.1.1 sed编辑器</a></li>
<li><a href="#1912-gawk%E7%A8%8B%E5%BA%8F">19.1.2 gawk程序</a></li>
</ul>
</li>
<li><a href="#192-sed-%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80">19.2 sed 编辑器基础</a><ul>
<li><a href="#1921-%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%9B%BF%E6%8D%A2%E9%80%89%E9%A1%B9">19.2.1 更多的替换选项</a></li>
<li><a href="#1922-%E4%BD%BF%E7%94%A8%E5%9C%B0%E5%9D%80">19.2.2 使用地址</a></li>
<li><a href="#1923-%E5%88%A0%E9%99%A4%E8%A1%8C">19.2.3 删除行</a></li>
<li><a href="#1924-%E6%8F%92%E5%85%A5%E5%92%8C%E9%99%84%E5%8A%A0%E6%96%87%E6%9C%AC">19.2.4 插入和附加文本</a></li>
<li><a href="#1925-%E4%BF%AE%E6%94%B9%E8%A1%8C">19.2.5 修改行</a></li>
<li><a href="#1926-%E8%BD%AC%E6%8D%A2%E5%91%BD%E4%BB%A4">19.2.6 转换命令</a></li>
<li><a href="#1927-%E5%9B%9E%E9%A1%BE%E6%89%93%E5%8D%B0">19.2.7 回顾打印</a></li>
<li><a href="#1928-%E4%BD%BF-%E7%94%A8-sed-%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6">19.2.8 使 用 sed 处理文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">20.正则表达式</a><ul>
<li><a href="#201-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">20.1 什么是正则表达式</a></li>
<li><a href="#202-%E5%AE%9A%E4%B9%89bre%E6%A8%A1%E5%BC%8F">20.2 定义BRE模式</a><ul>
<li><a href="#2021-%E7%BA%AF%E6%96%87%E6%9C%AC">20.2.1. 纯文本</a></li>
<li><a href="#2022-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">20.2.2 特殊字符</a></li>
<li><a href="#2023-%E9%94%9A%E5%AE%9A%E5%AD%97%E7%AC%A6">20.2.3 锚定字符</a></li>
<li><a href="#2024-%E7%82%B9%E5%AD%97%E7%AC%A6">20.2.4 点字符</a></li>
<li><a href="#2025-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">20.2.5 字符数组</a></li>
<li><a href="#2026-%E6%8E%92%E9%99%A4%E5%9E%8B%E5%AD%97%E7%AC%A6">20.2.6 排除型字符</a></li>
<li><a href="#2027-%E5%8C%BA%E9%97%B4">20.2.7 区间</a></li>
<li><a href="#2028-%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">20.2.8 特殊的字符数组</a></li>
<li><a href="#2029-%E6%98%9F%E5%8F%B7">20.2.9 星号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendindex">AppendIndex</a></li>
</ul>
<h1 id="1-linux入门"><a href="#1-linux入门" class="headerlink" title="1. linux入门"></a>1. linux入门</h1><p>linux是一款开源操作系统统称，其有很多发行版本，像ubuntu..，它的核心是其<code>内核</code>，早期由linus torvalds开发</p>
<p><img src="/./../picture/linux_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/linus.png" alt="linus本人"></p>
<p>内核主要负责以下四种功能:</p>
<ul>
<li><p>系统内存管理</p>
</li>
<li><p>软件程序管理<br>  linux管理所有运行程序的进程.内核启动时会将<code>init</code>进程加载到<code>虚拟内存</code>，一些发行版本在<code>/etc/inittab</code>位置进行管理自启动进程,ubuntu则是在<code>/etc/init.d</code>或者<code>/etc/rcX.d</code>,<code>/etc/rcX.d</code>，<code>X</code>是某一特定是某一特定类型的进程，如下<code>rc0.d/</code>,<code>rc1.d/</code>,<code>rc2.d/</code>,<code>rc3.d/</code>,<code>rc4.d/</code>,<code>rc5.d/</code>,<code>rc6.d/</code>,<code>rcS.d/</code>运行级为<strong>1</strong>时，只启动基本的系统进程以及一个控制台终端进程。称之为<strong>单用户模式</strong>。单用户模式通常用来在系统有问题时进行紧急的文件系统维护。在这种模式下，仅有一个人（通常是系统管理员）能登录到系统上操作数据（这块部分以后涉及再补充也来的急，别深究）</p>
</li>
<li><p>硬件设备管理<br>两种方式将驱动程序插入到系统内核</p>
<ol>
<li>编译进内核的设备驱动代码<ul>
<li>以前加入新的驱动要重新编译内核，效率低下</li>
</ul>
</li>
<li>可插入内核的设备驱动模块<br> 可插拔式内核驱动，Linux系统将硬件设备当成特殊的文件，称为<code>设备文件</code>。设备文件有3种分类：<ul>
<li>字符型设备文件</li>
<li>块设备文件</li>
<li>网络设备文件</li>
</ul>
</li>
</ol>
</li>
<li><p>文件系统管理<br>  linux自有的诸多文件系统外，Linux还支持从其他操作系统（比如Microsoft Windows）采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持</p>
</li>
</ul>
<h1 id="2-走进shell"><a href="#2-走进shell" class="headerlink" title="2. 走进shell"></a>2. 走进shell</h1><p>在图形化桌面出现之前，与Unix(linux是兼容unix操作系统)系统进行交互的唯一方式就是借助由shell所提供的<code>文本命令</code>行界面(command line interface，CLI),是一种同Linux系统交互的直接接口</p>
<h1 id="3-基本shell命令"><a href="#3-基本shell命令" class="headerlink" title="3. 基本shell命令"></a>3. 基本shell命令</h1><h2 id="3-1-启动shell"><a href="#3-1-启动shell" class="headerlink" title="3.1 启动shell"></a>3.1 启动shell</h2><ul>
<li><code>/etc/passwd</code>包含用户的基本信息,如下输出</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">christine: x :501:501:Christine Bresnahan:&#x2F;home&#x2F;christine:&#x2F;bin&#x2F;bash</code></pre>

<p>位置以此类推是用户名,密码,UID,GID,用户文本描述,家目录,默认启动启动bash作为自己的shell命令(第七章将有详细描述),目前绝大多数linux发行版将密码放在<code>/etc/shadow</code>目录下,普通方式是无法直接看到的</p>
<h2 id="3-2-bash-手册"><a href="#3-2-bash-手册" class="headerlink" title="3.2 bash 手册"></a>3.2 bash 手册</h2><p>linux自带命令手册，方便用户查看相关命令的具体选项和参数。在手册左上角括号内的数字表明对应的内容区域。每个内容区域都分配了一个数字，</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>可执行程序或shell命令</td>
</tr>
<tr>
<td>2</td>
<td>系统调用</td>
</tr>
<tr>
<td>3</td>
<td>库调用</td>
</tr>
<tr>
<td>4</td>
<td>特殊文件</td>
</tr>
<tr>
<td>5</td>
<td>文件格式与约定</td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>概览,约定及杂项</td>
</tr>
<tr>
<td>8</td>
<td>超级用户和系统管理员命令</td>
</tr>
<tr>
<td>9</td>
<td>内核例程</td>
</tr>
</tbody></table>
<p>如果你忘了命令的关键字那么可以使用<code>man -k</code>的方式查找命令，比如<code>mkdir</code>,就可以使用<code>man -k mkdir</code>,就可以检索出与<code>mkdir</code>相关的命令.<br>包括对系统主机名的概述。要想查看所需要的页面，输入<code>man section linux-CMD-sytax</code>。对手册页中的第1部分而言，就是输入<code>man 1 hostname</code>。对于手册页中的第7部分，就是输入<code>man 7 hostname</code><br>手册页不是唯一的参考资料。还有另一种叫作info页面的信息。可以输入<code>info info</code>来了解info页面的相关内容。</p>
<h2 id="3-4-文件系统"><a href="#3-4-文件系统" class="headerlink" title="3.4 文件系统"></a>3.4 文件系统</h2><p>简单理解，linux文件系统跟windows的文件布局是不一样的。</p>
<ul>
<li><p>linux 文件系统</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;bin</td>
<td>二进制目录，存放许多用户级的GNU工具</td>
</tr>
<tr>
<td>&#x2F;boot</td>
<td>启动目录，存放启动文件</td>
</tr>
<tr>
<td>&#x2F;dev</td>
<td>设备目录，Linux在这里创建设备节点</td>
</tr>
<tr>
<td>&#x2F;etc</td>
<td>系统配置文件目录</td>
</tr>
<tr>
<td>&#x2F;home</td>
<td>主目录，Linux在这里创建用户目录</td>
</tr>
<tr>
<td>&#x2F;lib</td>
<td>库目录，存放系统和应用程序的库文件</td>
</tr>
<tr>
<td>&#x2F;media</td>
<td>媒体目录，可移动媒体设备的常用挂载点</td>
</tr>
<tr>
<td>&#x2F;mnt</td>
<td>挂载目录，另一个可移动媒体设备的常用挂载点</td>
</tr>
<tr>
<td>&#x2F;opt</td>
<td>可选目录，常用于存放第三方软件包和数据文件</td>
</tr>
<tr>
<td>&#x2F;proc</td>
<td>进程目录，存放现有硬件及当前进程的相关信息</td>
</tr>
<tr>
<td>&#x2F;root</td>
<td>root用户的主目录</td>
</tr>
<tr>
<td>&#x2F;sbin</td>
<td>系统二进制目录，存放许多GNU管理员级工具</td>
</tr>
<tr>
<td>&#x2F;run</td>
<td>运行目录，存放系统运作时的运行时数据</td>
</tr>
<tr>
<td>&#x2F;srv</td>
<td>服务目录，存放本地服务的相关文件</td>
</tr>
<tr>
<td>&#x2F;sys</td>
<td>系统目录，存放系统硬件信息的相关文件</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>临时目录，可以在该目录中创建和删除临时工作文件</td>
</tr>
<tr>
<td>&#x2F;usr</td>
<td>用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</td>
</tr>
<tr>
<td>&#x2F;var</td>
<td>可变目录，用以存放经常变化的文件，比如日志文件</td>
</tr>
</tbody></table>
<p><img src="/./../picture/linux_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/linux_folder_setup.jpg" alt="linux文件系统图"></p>
</li>
<li><p>遍历目录(cd命令)<br>需要你知道文件树状结构,这样才能知道你将访问文件的具体位置，无论是<code>相对路径</code>还是<code>绝对路径</code><br><code>cd</code>命令，这时要注意文件系统的相对路径和绝对路径问题，linux通过这两种方式确定目录位置，符号<code>/</code>是表示根目录</p>
<ul>
<li>绝对路径  通过从root目录开始一层一层的进行访问，最终访问到目标文件或者目录,<code>/bin/bash</code>从根目录定位到bash</li>
<li>相对路径<ul>
<li><code>./</code> 当前目录</li>
<li><code>../</code> 上层目录</li>
<li><code>~/</code> 表示当前用户home目录</li>
</ul>
</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">cd ~&#x2F;   # 进到对应账号的home目录下
cd &#x2F;home&#x2F;kirkzhang  #使用绝对路径进入家目录</code></pre>
</li>
<li><p>目录列表(ls命令)<br><code>ls</code>按照字母序列,参数<code>-l</code> 显示长列表,更多参数查看ls手册,另一个替换命令<code>getfacl</code>查询问价权限</p>
<ul>
<li>问号（?）代表一个字符</li>
<li>星号（*）代表零个或多个字符</li>
</ul>
</li>
<li><p>文件链接</p>
<ul>
<li>软连接<br>当我们需要相同文件时,不必要在每个文件夹下都放一份文件夹，只需要使用软链接<br>ls -s &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql &#x2F;usr&#x2F;bin</li>
<li>硬链接</li>
</ul>
</li>
</ul>
<h1 id="4-其他shell命令"><a href="#4-其他shell命令" class="headerlink" title="4. 其他shell命令"></a>4. 其他shell命令</h1><h2 id="4-1-监控程序"><a href="#4-1-监控程序" class="headerlink" title="4.1 监控程序"></a>4.1 监控程序</h2><h3 id="4-1-1-ps查看进程"><a href="#4-1-1-ps查看进程" class="headerlink" title="4.1.1 ps查看进程"></a>4.1.1 ps查看进程</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">ps 选项
-A 显示所有进程 
-N 显示与指定参数不符的所有进程 
-a 显示除控制进程(session leader)和无终端进程外的所有进程 
-d 显示除控制进程外的所有进程 
-e 显示所有进程 
-C cmdlist 显示包含在cmdlist列表中的进程 
-G grplist 显示组ID在grplist列表中的进程 
-U userlist 显示属主的用户ID在userlist列表中的进程 
-g grplist 显示会话或组ID在grplist列表中的进程② 
-p pidlist 显示PID在pidlist列表中的进程
-f 完整格式输出</code></pre>

<p>  命令输出关键词意义</p>
<table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>UID</td>
<td>启动这些进程的用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程的ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程的进程号（如果该进程是由另一个进程启动的）</td>
</tr>
<tr>
<td>C</td>
<td>进程生命周期中的CPU利用率</td>
</tr>
<tr>
<td>STIME</td>
<td>进程启动时的系统时间</td>
</tr>
<tr>
<td>TTY</td>
<td>进程启动时的终端设</td>
</tr>
<tr>
<td>TIME</td>
<td>运行进程需要的累计CPU时间</td>
</tr>
<tr>
<td>CMD</td>
<td>启动的程序名称</td>
</tr>
</tbody></table>
<h3 id="4-1-2-top实时监控"><a href="#4-1-2-top实时监控" class="headerlink" title="4.1.2 top实时监控"></a>4.1.2 top实时监控</h3><ul>
<li>第一行：当前时间，系统运行时间，登录用户数，系统的平均负载(15分钟的参数越大且超过2，说明有问题)  </li>
<li>第二行：进程状态  </li>
<li>第三行：CPU相关数值，使用率</li>
</ul>
<table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程的ID</td>
</tr>
<tr>
<td>USER</td>
<td>进程属主的名字</td>
</tr>
<tr>
<td>PR</td>
<td>进程的优先级</td>
</tr>
<tr>
<td>NI</td>
<td>进程的谦让度度</td>
</tr>
<tr>
<td>VIRT</td>
<td>进程占用的虚拟内存总量</td>
</tr>
<tr>
<td>RES</td>
<td>进程占用的物理内存总量</td>
</tr>
<tr>
<td>SHR</td>
<td>进程和其他进程共享的内存总量</td>
</tr>
<tr>
<td>S</td>
<td>进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表 跟踪状态或停止状态，Z代表僵化状态)</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程使用的CPU时间比例</td>
</tr>
<tr>
<td>%MEM</td>
<td></td>
</tr>
<tr>
<td>TIME+</td>
<td>自进程启动到目前为止的CPU时间总量</td>
</tr>
<tr>
<td>COMMAND</td>
<td>进程所对应的命令行名称，也就是启动的程序名</td>
</tr>
</tbody></table>
<h3 id="4-1-3-kill结束进程"><a href="#4-1-3-kill结束进程" class="headerlink" title="4.1.3 kill结束进程"></a>4.1.3 kill结束进程</h3><table>
<thead>
<tr>
<th>信号</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>HUP</td>
<td>挂起</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>中断</td>
</tr>
<tr>
<td>3</td>
<td>QUIT</td>
<td>退出</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>无条件终止</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>段错误</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>尽可能终止</td>
</tr>
<tr>
<td>17</td>
<td>STOP</td>
<td>无条件终止</td>
</tr>
<tr>
<td>18</td>
<td>TSTP</td>
<td>停止或暂停，但在后台运行</td>
</tr>
<tr>
<td>19</td>
<td>CONT</td>
<td>在STOP或TSTP之后恢复执行</td>
</tr>
</tbody></table>
<h3 id="4-1-4-系统performance监控"><a href="#4-1-4-系统performance监控" class="headerlink" title="4.1.4 系统performance监控"></a>4.1.4 系统performance监控</h3><p>  这个要下载<code>sysstat</code>程序<br>    - iostat - reports CPU statistics and input&#x2F;output statistics for block devices and partitions.<br>    - mpstat - Processors Statistics<br>      <pre class="language-bash" data-language="bash"><code class="language-bash">&#96;mpstat -P ALl&#96;     #所有processor
&#96;mpstat -P ALL 2 5&#96; #迭代五次间隔两秒</code></pre><br>    - pidstat - Process and Kernel Threads Statistics<br>    - tapestat - reports statistics for tape drives connected to the system<br>    - cifsiostat - reports CIFS statistics.</p>
<h2 id="4-2-磁盘空间监控"><a href="#4-2-磁盘空间监控" class="headerlink" title="4.2 磁盘空间监控"></a>4.2 磁盘空间监控</h2><h3 id="4-2-1-mount挂在存储媒体"><a href="#4-2-1-mount挂在存储媒体" class="headerlink" title="4.2.1 mount挂在存储媒体"></a>4.2.1 mount挂在存储媒体</h3><p>  <code>mount</code>提供如下信息<code>媒体设备名</code>,<code>挂载点</code>,<code>文件类型</code>,<code>访问方式</code>  </p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">#将A设备挂在到B目录上,type 参数指定了磁盘被格式化的文件系统类型,如&#96;vfat&#96;,&#96;iso9660&#96;,&#96;ntfs&#96;,例如&#96;mount -t vfat &#x2F;dev&#x2F;sdb1 &#x2F;media&#x2F;  disk&#96;
mount -t type  A  B  </code></pre>

<ul>
<li><p>mount参数列表，详情见man手册，或者如下</p>
<table>
<thead>
<tr>
<th>参 数</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>挂载&#x2F;etc&#x2F;fstab文件中指定的所有文件系统</td>
</tr>
<tr>
<td>-f</td>
<td>使 mount 命令模拟挂载设备，但并不真的挂载</td>
</tr>
<tr>
<td>-F</td>
<td>和 -a 参数一起使用时，会同时挂载所有文件系统</td>
</tr>
<tr>
<td>-v</td>
<td>详细模式，将会说明挂载设备的每一步</td>
</tr>
<tr>
<td>-I</td>
<td>不启用任何&#x2F;sbin&#x2F;mount.filesystem下的文件系统帮助文件</td>
</tr>
<tr>
<td>-l</td>
<td>给ext2、ext3或XFS文件系统自动添加文件系统标签</td>
</tr>
<tr>
<td>-n</td>
<td>挂载设备，但不注册到&#x2F;etc&#x2F;mtab已挂载设备文件中</td>
</tr>
<tr>
<td>-p</td>
<td>num进行加密挂载时，从文件描述符 num 中获得密码短语</td>
</tr>
<tr>
<td>-s</td>
<td>忽略该文件系统不支持的挂载选项</td>
</tr>
<tr>
<td>-r</td>
<td>将设备挂载为只读的</td>
</tr>
<tr>
<td>-w</td>
<td>将设备挂载为可读写的（默认参数）</td>
</tr>
<tr>
<td>-L label</td>
<td>将设备按指定的 label 挂载</td>
</tr>
<tr>
<td>-U uuid</td>
<td>将设备按指定的 uuid 挂载</td>
</tr>
<tr>
<td>-O</td>
<td>和 -a 参数一起使用，限制命令只作用到特定的一组文件系统上</td>
</tr>
<tr>
<td>-o</td>
<td>给文件系统添加特定的选项</td>
</tr>
</tbody></table>
</li>
<li><p><code>-o</code>参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。以下为常用的选项</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">ro #只读挂载  
rw #读写挂载
user #允许普通用户挂在
loop #挂载一个文件
check&#x3D;none #挂载时进行完整性校验</code></pre></li>
</ul>
<h3 id="4-2-2-unmount-卸载设备"><a href="#4-2-2-unmount-卸载设备" class="headerlink" title="4.2.2 unmount 卸载设备"></a>4.2.2 unmount 卸载设备</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">unmount [directory | device] # &#x2F;&#x2F;卸载文件应在外侧目录完成,命令行提示符仍然在挂载设备的文件系统目录中，&#96;umount&#96; 命令无法卸载该镜像</code></pre>

<h3 id="4-2-3-df-查看磁盘使用情况"><a href="#4-2-3-df-查看磁盘使用情况" class="headerlink" title="4.2.3 df 查看磁盘使用情况"></a>4.2.3 df 查看磁盘使用情况</h3><p>  命令格式: df [OPTION]… [FILE]…</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">-h  # 以M,G描述问价大小
-a, --all
    # include pseudo, duplicate, inaccessible file systems
-B, --block-size&#x3D;SIZE
    # scale sizes by SIZE before  printing  them;  e.g.,  &#39;-BM&#39;  prints  sizes  in  units  of
    # 1,048,576 bytes; see SIZE format below
-h, --human-readable
    # print sizes in powers of 1024 (e.g., 1023M)
-H, --si
    #print sizes in powers of 1000 (e.g., 1.1G)
-i, --inodes
    #list inode information instead of block usage
-k  like --block-size&#x3D;1K
-l, --local
    #limit listing to local file systems
--no-sync
    #do not invoke sync before getting usage info (default)
--output[&#x3D;FIELD_LIST]
    #use the output format defined by FIELD_LIST, or print all fields if FIELD_LIST is omit‐ted.
-P, --portability
    #use the POSIX output format
--sync invoke sync before getting usage info
--total
    #elide all entries insignificant to available space, and produce a grand total
-t, --type&#x3D;TYPE
    #limit listing to file systems of type TYPE
-T, --print-type
    #print file system type
-x, --exclude-type&#x3D;TYPE
    #limit listing to file systems not of type TYPE
-v  (ignored)
--help display this help and exit
--version
    #output version information and exit
</code></pre>

<h3 id="4-2-4-du-磁盘空间"><a href="#4-2-4-du-磁盘空间" class="headerlink" title="4.2.4 du 磁盘空间"></a>4.2.4 du 磁盘空间</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">-c #显示所有已列出文件总的大小(还是不宜读)
-h #按用户易读的格式输出大小，即用K替代千字节
-s #显示每个输出参数的总计
-d # 限制查询深度</code></pre>

<h2 id="4-3-处理文件"><a href="#4-3-处理文件" class="headerlink" title="4.3 处理文件"></a>4.3 处理文件</h2><h3 id="4-3-1-sort-文件排序"><a href="#4-3-1-sort-文件排序" class="headerlink" title="4.3.1 sort - 文件排序"></a>4.3.1 sort - 文件排序</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">-n  #sort命令会把数字当做字符来执行标准的字符排序,解决
-M  #按照月份排序
-k  #和&#96;-t&#96;参数在对按字段分隔的数据进行排序时非常有用&#96;sort -t &#39;:&#39; -k 3 -n &#x2F;etc&#x2F;passwd&#96;
-n  #按照数值排序du -hs * | sort -nr
-r  #反向排序 </code></pre>

<h3 id="4-3-2-grep-搜索文件"><a href="#4-3-2-grep-搜索文件" class="headerlink" title="4.3.2 grep - 搜索文件"></a>4.3.2 grep - 搜索文件</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">-i	              # 忽略大小写
-c	              # 只输出匹配行的数量
-l	              # 只列出符合匹配的文件名，不列出具体的匹配行
-n	              # 列出所有的匹配行，显示行号
-h	              # 查询多文件时不显示文件名
-s	              # 不显示不存在、没有匹配文本的错误信息
-v	              # 显示不包含匹配文本的所有行
-w	              # 匹配整词
-x	              # 匹配整行
-r	              # 递归搜索
-q	              # 禁止输出任何结果，已退出状态表示搜索是否成功
-b	              # 打印匹配行距文件头部的偏移量，以字节为单位
-o	              # 与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位
-F	              # 匹配固定字符串的内容
-E	              # 支持扩展的正则表达式
grep [tf] file1 #支持正则匹配</code></pre>

<p>  egrep, fgrep 功能更强大</p>
<h3 id="4-3-3-zip-gzip-gz-compress-Z-bzip2-bz2-压缩数据"><a href="#4-3-3-zip-gzip-gz-compress-Z-bzip2-bz2-压缩数据" class="headerlink" title="4.3.3 zip , gzip:gz, compress:Z, bzip2:bz2 压缩数据"></a>4.3.3 zip , gzip:gz, compress:Z, bzip2:bz2 压缩数据</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">gzip #压缩文件
gzcat #查看文件内容
gunzip #用来解压文件  </code></pre>

<h3 id="4-3-4-tar-归档数据"><a href="#4-3-4-tar-归档数据" class="headerlink" title="4.3.4 tar 归档数据"></a>4.3.4 tar 归档数据</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">-c #~ create&#96;创建一个新的tar文件
-r #追加文件到tar文件末尾
-x #~ extract&#96;抽取tar文件
-v #显示文件列表
-z #将输出重定向给gzip命令
-f # file&#96;输出文件结果到文化，&#96;tar -cvf test.tar test&#x2F; test2&#x2F;&#96; 创建一个新文件
-t # list&#96;列举tar内容
-C #指定具体目录
tar -xvf test.tar&#96;令从tar文件test.tar中提取内容。如果tar文件是从一个目录结构创建的，那整个目录结构都会在当前目录下重新创建</code></pre>

<h3 id="4-3-5-find-搜索命令"><a href="#4-3-5-find-搜索命令" class="headerlink" title="4.3.5 find 搜索命令"></a>4.3.5 find 搜索命令</h3><p>  语法结构: find [路径] [参数]</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">-name              # 匹配名称
-perm              # 匹配权限（mode为完全匹配，-mode为包含即可）
-user              # 匹配所有者
-group            # 匹配所有组
-mtime -n +n      # 匹配修改内容的时间（-n指n天以内，+n指n天以前）
-atime -n +n      # 匹配访问文件的时间（-n指n天以内，+n指n天以前）
-ctime -n +n      # 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）
-nouser            # 匹配无所有者的文件
-nogroup          # 匹配无所有组的文件
-newer f1 !f2      # 匹配比文件f1新但比f2旧的文件
-type b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f  # 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）
-size              # 匹配文件的大小(+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件)
-prune            # 忽略某个目录
-exec …… &#123;&#125;\;     # 后面可跟用于进一步处理搜索结果的命令</code></pre>

<p>  具体实例</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash"># 搜索文件大于1M大小的文件
find &#x2F;etc -size +1M
# 搜索所有属于指定用户的文件
find &#x2F;home -user linuxprobe
# 在&#x2F;var&#x2F;log目录下搜索所有指定后缀的文件，后缀不需要大小写。
find &#x2F;var&#x2F;log -iname &quot;*.log&quot;
# 在&#x2F;var&#x2F;log目录下搜索所有后缀不是.log的文件：
find &#x2F;var&#x2F;log ! -name &quot;*.log&quot;
# 全盘搜索系统中所有类型为目录，且权限为1777的目录文件
find &#x2F; -type d -perm 1777
#全盘搜索系统中所有后缀为.mp4的文件，并删除所有查找到的文件：
find &#x2F; -name &quot;*.mp4&quot; -exec rm -rf &#123;&#125; \;</code></pre>

<h3 id="4-3-6-uname-显示系统内核信息"><a href="#4-3-6-uname-显示系统内核信息" class="headerlink" title="4.3.6 uname 显示系统内核信息"></a>4.3.6 uname 显示系统内核信息</h3><p>  语法格式:uname [参数]<br>  常用参数</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">-a	      # 显示系统所有相关信息
-m	      # 显示计算机硬件架构
-n	      # 显示主机名称
-r	      # 显示内核发行版本号
-s	      # 显示内核名称
-v	      # 显示内核版本
-p	      # 显示主机处理器类型
-o	      # 显示操作系统名称
-i	      # 显示硬件平台</code></pre>
<h2 id="4-4-date命令及其格式化"><a href="#4-4-date命令及其格式化" class="headerlink" title="4.4 date命令及其格式化"></a>4.4 date命令及其格式化</h2><ul>
<li><p>格式化占位符</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">%D – Display date as mm&#x2F;dd&#x2F;yy
%Y – Year (e.g., 2020)
%m – Month (01-12)
%B – Long month name (e.g., November)
%b – Short month name (e.g., Nov)
%d – Day of month (e.g., 01)
%j – Day of year (001-366)
%u – Day of week (1-7)
%A – Full weekday name (e.g., Friday)
%a – Short weekday name (e.g., Fri)
%H – Hour (00-23)
%I – Hour (01-12)
%M – Minute (00-59)
%S – Second (00-60)</code></pre>
</li>
<li><p>date时间加减</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">echo  &#96;date --date&#x3D;&quot;-5 day&quot; +%Y%m%d&#96;
echo  &#96;date --date&#x3D;&quot;-5 month&quot; +%Y%m%d&#96;
echo  &#96;date --date&#x3D;&quot;-5 year&quot; +%Y%m%d&#96;</code></pre>
</li>
<li><p>set和change系统时间</p>
<p><code>date --set=&quot;20100513 05:30&quot;</code>谨慎使用</p>
</li>
<li><p>展示某一日期文件的日期</p>
<p><code>--file</code>选项打印出文件中每一行存在的日期字符串。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">date --file&#x3D;</code></pre>
</li>
<li><p>重写日期</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">date -d &#39;TZ&#x3D;&quot;Australia&#x2F;Sydney&quot; 04:30 next Monday&#39;</code></pre>

<p>下面命令可以列出<code>timezone</code></p>
<pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl list-timezones</code></pre>
</li>
<li><p>与其他shell混用</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">mysqldump  database_name &gt; database_name-$(date +%Y%m%d).sql
</code></pre>
</li>
<li><p>使用Unix纪元时间（纪元转换）。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">date +%s # To show the number of seconds from the epoch to the current day, use the %s format control
date -d &quot;1984-04-08&quot; +&quot;%s&quot; # To see how many seconds passed from epoch to a specific date, enter</code></pre></li>
</ul>
<p>一个完整的带有详细时间的<code>date</code>命令是<code>date --date=&quot;-5 day&quot;  +&quot;%Y-%m-%d %H:%M:%S&quot;</code></p>
<h1 id="5-理解shell"><a href="#5-理解shell" class="headerlink" title="5. 理解shell"></a>5. 理解shell</h1><h2 id="5-1-shell的类型"><a href="#5-1-shell的类型" class="headerlink" title="5.1 shell的类型"></a>5.1 shell的类型</h2><p>不同Linux系统有很多种shell,<code>cat /etc/passwd</code>可以看到用户默认登录默认的shell</p>
<ul>
<li>Debian的是dash</li>
<li>csh</li>
<li>sh(你经常会看到某些发行版使用软链接将默认的系统shell设置成bash shell，如本书所使用的CentOS发行版)</li>
</ul>
<h2 id="5-2-shell的父子关系"><a href="#5-2-shell的父子关系" class="headerlink" title="5.2 shell的父子关系"></a>5.2 shell的父子关系</h2><p>在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中的一些东西造成影响</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-c string</td>
<td>从 string 中读取命令并进行处理</td>
</tr>
<tr>
<td>-i</td>
<td>启动一个能够接收用户输入的交互shell</td>
</tr>
<tr>
<td>-l</td>
<td>以登录shell的形式启动</td>
</tr>
<tr>
<td>-r</td>
<td>启动一个受限shell，用户会被限制在默认目录中</td>
</tr>
<tr>
<td>-s</td>
<td>从标准输入中读取命令</td>
</tr>
</tbody></table>
<h3 id="5-2-1-进程列表"><a href="#5-2-1-进程列表" class="headerlink" title="5.2.1 进程列表"></a>5.2.1 进程列表</h3><ol>
<li><code>(pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)</code>,括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令</li>
<li>语法为 <code>&#123; command; &#125;</code> 。使用花括号进行命令分组,并不会像进程列表那样创建出子shell</li>
<li>( pwd ; (echo $BASH_SUBSHELL)) 创建子shell的子shell</li>
<li>在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢<br>处理速度。在交互式的CLI shell会话中，子shell同样存在问题。它并非真正的多进程处理，因为<br>终端控制着子shell的I&#x2F;O</li>
</ol>
<h3 id="5-2-2-子shell的其他用法"><a href="#5-2-2-子shell的其他用法" class="headerlink" title="5.2.2 子shell的其他用法"></a>5.2.2 子shell的其他用法</h3><ol>
<li>后台运行模式( &amp; )</li>
<li>进程列表置于后台 (sleep 2 ; echo $BASH_SUBSHELL ; sleep 2) &amp;</li>
<li>携程<ul>
<li>coproc My_Job { sleep 10; }, My_Job 是自定义名字，必须确保在第一个花括号（ { ）和命令名之间有一个空格</li>
<li>将<code>协程</code>与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,<br>然后把命令 <code>coproc</code> 放在前面就行了<code>coproc ( sleep 10; sleep 2 )</code></li>
</ul>
</li>
</ol>
<h2 id="5-3-理解shell的内建命令"><a href="#5-3-理解shell的内建命令" class="headerlink" title="5.3 理解shell的内建命令"></a>5.3 理解shell的内建命令</h2><h3 id="5-3-1-外部命令"><a href="#5-3-1-外部命令" class="headerlink" title="5.3.1 外部命令"></a>5.3.1 外部命令</h3><p>当外部命令执行时，会创建出一个子进程。这种操作被称为<code>衍生</code>(forking),有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于&#x2F;bin、&#x2F;usr&#x2F;bin、&#x2F;sbin或&#x2F;usr&#x2F;sbin中</p>
<ul>
<li><code>which ps</code></li>
<li><code>type -a ps</code></li>
<li>当进程必须执行衍生操作时，它需要花费时间和精力来设置新子进程的环境。所以说，外部命令多少还是有代价的,就算衍生出子进程或是创建了子shell，你仍然可以通过发送信号与其沟通，这一点无论是<br>在命令行还是在脚本编写中都是极其有用的</li>
</ul>
<h3 id="5-3-2-内部命令"><a href="#5-3-2-内部命令" class="headerlink" title="5.3.2 内部命令"></a>5.3.2 内部命令</h3><ol>
<li>命令<code>type -a</code>显示出了每个命令的两种实现。注意， which 命令只显示出了外部命令文件</li>
<li><code>!数字</code>可以使用.bash_history文件的命令</li>
<li><code>alias -p</code>,有一个别名取代了标准命令 <code>ls</code>.它自动加入了<code>--color</code>选项，表明终端支持彩色模式的列表</li>
<li><code>alias li=&#39;ls -li&#39;</code>,一个别名仅在它所被定义的shell进程中才有效</li>
</ol>
<h1 id="6-环境变量"><a href="#6-环境变量" class="headerlink" title="6. 环境变量"></a>6. 环境变量</h1><ul>
<li>login shell : 用户成功登陆后使用的是 Login shell。例如，当你通过终端、SSH 或使用 “su -“ 命令来切换账号时都会使用的Login Shell</li>
<li>non-login shell : Non Login Shell 是指通过 login shell 开启的shell,Non-login shell执行<code>~/.bashrc</code>脚本来初始shell环境</li>
<li>交互式shell ： 就是终端等待你输入命令的就是交互式shell</li>
<li>非交互式shell : 非交互式模式，以shell script(非交互)方式执行。在这种模式 下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF，shell也就终止了</li>
</ul>
<p>如何快速辨别是login shell 还是non-login shell ,可通过<code>echo $0</code>如果是输出<code>-bash</code>说明是login shell,<code>bash</code>说明是non-login shell  </p>
<ul>
<li><p>全局环境变量对于所有shell都是可见的,对于子shell来说这是非常重要的,<code>printenv</code>or<code>env</code>命令查看全局命令</p>
</li>
<li><p>局部变量，<code>set</code>返回全局变量，用户自定义变量,所以返回局部变量有点复杂，以字母序进行排序</p>
</li>
<li><p>用户自定义变量</p>
<p><code>echo $my_variable -&gt; my_variable=Hello</code>可赋值,并且当你想要使用自定义变量时候要使用<code>$&#123;my_variable&#125;</code>语法，大小写敏感</p>
</li>
<li><p>设置全局环境变量</p>
<ul>
<li><p><code>export my_variable</code>导出为全局变量，在子shell中修改该值，只会在子shell中生效</p>
</li>
<li><p><code>unset my_variable</code>删除环境变量,这条规则的一个例外就是使用 printenv 显示某个变量的值)</p>
</li>
<li><p>默认的环境变量，直接使用就好了</p>
<p><img src="/./../picture/linux_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/linux_default_variables.png" alt="linux_default_variables"><br><img src="/./../picture/linux_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/linux_default_variables_1.png" alt="linux_default_variables_1"></p>
</li>
<li><p>设置<code>path</code>环境变量,当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序.<code>PATH</code>环境变量定义了用于进行命令和程序查找的目录</p>
</li>
<li><p>定位环境变量</p>
<ul>
<li>登录式shell<br>在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作<code>启动文件</code>或<code>环境文件</code>。bash检查启动文件的方式取决于你启动bash的方式，启动bash shell有3种方式<ul>
<li><p>登录时作为默认登录shell(login shell)<br>当你登录系统的时候，bash shell会作为登陆式shell进行启动，会在如下文件五个不同启动文件读取命令<code>/etc/profile</code>,<code>$HOME/.bash_profile</code>,<code>$HOME/.bash_login</code>,<code>$HOME/.profile</code>,<code>$HOME/.bashrc</code></p>
<ul>
<li><code>/etc/profile</code>  是系统默认的bash shell主启动文件，系统上每个用户登陆时候都会读取这个主启动文件，<br>两个发行版的<code>/etc/profile</code>文件都用到了同一个特性：for语句。它用来迭代<code>/etc/profile.d</code>目录，这为Linux系统提供了一个放置特定应用程序启动文件的地方，<br>当用户登录时，shell会执行这些文件。在本书所用的Ubuntu Linux系统中，<br><code>/etc/profile.d</code>目录下包含以下文件  </li>
<li>shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略,这里没提到<code>$HOME/.bashrc</code>文件，这个文件通常是通过其他文件运行  <ul>
<li><code>$HOME/.bash_profile</code></li>
<li><code>$HOME/.bash_login</code></li>
<li><code>$HOME/.profile</code></li>
</ul>
</li>
</ul>
<p><strong>NOTE</strong> : 要留意的是有些Linux发行版使用了可拆卸式认证模块(Pluggable AuthenticationModules ，PAM)。在这种情况下，PAM文件会在bash shell启动之前处理，这些文件中可能会包含环境变量。PAM文件包括<code>/etc/environment</code>文 件 和<code>$HOME/.pam_environment</code>文件</p>
</li>
</ul>
</li>
<li>交互式shell(non-login shell)<br>如果你的shell不是登录系统时候启动的，那么你启动的shell就是交互式shell，它不会访问<code>/etc/profile</code>只会检查<code>.bashrc</code>文件，<code>.bashrc</code>文件有两个作用：一是查看&#x2F;etc目录下通用的<code>bashrc</code>文件，二是为用户提供一个定制自己的命令别名(参见第5章)和私有脚本函数的地方(将在第17章中讲到)</li>
<li>非交互shell<br>TBC</li>
<li>环境变量的持久化<br>  对全局环境变量来说（Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修改过的变量设置放在<code>/etc/profile</code>文件中，但这可不是什么好主意。如果你升级了所用的发行版，这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。最好是在<code>/etc/profile.d</code>目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。在大多数发行版中，存储个人用户永久性bash shell变量的地方是<code>$HOME/.bashrc</code>文件。这一点适用于所有类型的shell进程。但如果设置了<code>BASH_ENV</code>变量，那么记住，除非它指向的是$HOME&#x2F;.bashrc，否则你应该将非交互式shell的用户变量放在别的地方</li>
</ul>
</li>
</ul>
</li>
<li><p>环境变量数组<br>  <code>mytest=(one two three four five)</code>定义了环境变量数组,<code>echo $&#123;mytest[2]&#125;</code>使用下标索引可以访问具体值,<code>echo $&#123;mytest[*]&#125;</code>可以访问所有的值,<code>unset mytest[2]</code>删除某个值,<code>unset mytest</code>删除全部</p>
</li>
<li><p>总结<br>  bash shell会在启动时执行几个启动文件。这些启动文件包含了环境变量的定义，可用于为每个bash会话设置标准环境变量。每次登录Linux系统，bash shell都会访问<code>/etc/profile</code>启动文件以及3个针对每个用户的本地启动文件：<code>$HOME/.bash_profile</code>、<code>$HOME/.bash_login</code>和<code>$HOME/.profile</code>。用户可以在这些文件中定制自己想要的环境变量和启动脚本。</p>
</li>
</ul>
<h1 id="7-linux文件权限"><a href="#7-linux文件权限" class="headerlink" title="7. linux文件权限"></a>7. linux文件权限</h1><p>用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是<code>登录名</code>。登录名是用户用来登录系统的最长八字符的字符串（字符可以是数字或字母），同时会关联一个对应的密码</p>
<h2 id="7-1-linux的安全性"><a href="#7-1-linux的安全性" class="headerlink" title="7.1 linux的安全性"></a>7.1 linux的安全性</h2><ul>
<li><p><code>/etc/passwd</code>包含用户的基本信息,所有在服务器后台运行都需要个<code>系统账户</code>运行</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">1. 登录用户名
2. 用户密码
3. 用户账户的UID（数字形式）
4. 用户账户的组ID（GID）（数字形式）
5. 用户账户的文本描述（称为备注字段）
6. 用户HOME目录的位置
7. 用户的默认shell</code></pre>

<p>root固定分配UID是0，Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作<code>系统账户</code>，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个(application account)，如果全都是root权限登录系统就很危险，被攻陷就直接是root权限。</p>
</li>
<li><p><code>/etc/shadow</code>真正存密码的文件,只允许root用户访问</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">1. 与&#x2F;etc&#x2F;passwd文件中的登录名字段对应的登录名
2. 加密后的密码
3. 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）
4. 多少天后才能更改密码
5. 多少天后必须更改密码
6. 密码过期前提前多少天提醒用户更改密码
7. 密码过期后多少天禁用用户账户
8. 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）
9. 预留字段给将来使用</code></pre></li>
</ul>
<h3 id="7-1-1-添加linux用户"><a href="#7-1-1-添加linux用户" class="headerlink" title="7.1.1 添加linux用户"></a>7.1.1 添加linux用户</h3><ul>
<li><p><code>useradd</code>命令添加默认配置的用户,<code>/etc/default/useradd</code>可以加入<code>-D</code>选项查看默认参数如下(一些Linux发行版会把Linux用户和组工具放在&#x2F;usr&#x2F;sbin目录下，这个目录可能不在<code>PATH</code>环境变量里)</p>
<ul>
<li>新用户会被添加到GID为100 的公共组；</li>
<li>新用户的HOME目录将会位于&#x2F;home&#x2F;loginname；</li>
<li>新用户账户密码在过期后不会被禁用；</li>
<li>新用户账户未被设置过期日期；</li>
<li>新用户账户将bash shell作为默认shell；</li>
<li>系统会将&#x2F;etc&#x2F;skel目录下的内容复制到用户的HOME目录下；</li>
<li>系统为该用户账户在mail目录下创建一个用于接收邮件的文件</li>
</ul>
<p><code>/etc/skel</code>下面它们是bash shell环境的标准启动文件,允许管理员把它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系统文件,<code>useradd</code>参数可以控制这些默认值,ubuntu系统在<code>/etc/skel</code>下，默认命令行参数</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">-c comment 给新用户添加备注
-d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话）
-e expire_date 用YYYY-MM-DD格式指定一个账户过期的日期
-f inactive_days 指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示禁用这个功能
-g initial_group 指定用户登录组的GID或组名
-G group ... 指定用户除登录组之外所属的一个或多个附加组
-k 必须和-m一起使用，将&#x2F;etc&#x2F;skel目录的内容复制到用户的HOME目录
-m 创建用户的HOME目录
-M 不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项）
-n 创建一个与用户登录名同名的新组
-r 创建系统账户
-p passwd 为用户账户指定默认密码
-s shell 指定默认的登录shell 
-u uid 为账户指定唯一的UID </code></pre>

<p>同时也可以更改默认值的参数</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">-b default_home  更改默认的创建用户HOME目录的位置
-e expiration_date  更改默认的新账户的过期日期
-f inactive  更改默认的新用户从密码过期到账户被禁用的天数
-g group  更改默认的组名称或GID 
-s shell  更改默认的登录shell 
# 更改用户默认shell
useradd -D -s &#x2F;bin&#x2F;tsch</code></pre></li>
</ul>
<h3 id="7-1-2-删除用户"><a href="#7-1-2-删除用户" class="headerlink" title="7.1.2 删除用户"></a>7.1.2 删除用户</h3><p>to_be_continue</p>
<h3 id="7-1-2-修改用户"><a href="#7-1-2-修改用户" class="headerlink" title="7.1.2 修改用户"></a>7.1.2 修改用户</h3><p>to_be_continue</p>
<h2 id="7-2-使用linux组"><a href="#7-2-使用linux组" class="headerlink" title="7.2 使用linux组"></a>7.2 使用linux组</h2><ul>
<li>&#x2F;etc&#x2F;group 存储一个组的信息，低于500是系统的，高于500是用户组的<ul>
<li>组名</li>
<li>组密码</li>
<li>GID</li>
<li>属于该组的用户列表</li>
</ul>
</li>
<li>创建组</li>
<li>修改组</li>
</ul>
<h2 id="7-3-理解文件权限"><a href="#7-3-理解文件权限" class="headerlink" title="7.3 理解文件权限"></a>7.3 理解文件权限</h2><ul>
<li><p>理解文件权限符号</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">&#96;-&#96;代表文件
&#96;d&#96; 代表目录
&#96;l&#96; 代表链接
&#96;c&#96; 代表字符型设备
&#96;b&#96; 代表块设备
&#96;n&#96; 代表网络设备
&#96;r&#96; 可写
&#96;w&#96; 可写
&#96;x&#96; 可执行
文件owner,和对象组</code></pre>
</li>
<li><p>设置默认文件权限<br>设置<code>umask</code>的值,默认文件权限等于文件最大权限，减去<code>umask</code>值，第一位代表了一项特别的安全特性，叫作粘着位（sticky bit）<br>rwx &#x3D; 4 + 2 + 1 &#x3D; 7, rw &#x3D; 4 + 2 &#x3D; 6, rx &#x3D; 4 +1 &#x3D; 5.</p>
</li>
</ul>
<h2 id="7-4-改变安全性设置"><a href="#7-4-改变安全性设置" class="headerlink" title="7.4 改变安全性设置"></a>7.4 改变安全性设置</h2><ul>
<li><p>chmod 改文件权限，如果使用的符号模式设置就是<code>u</code>代表用户，<code>g</code>代表组，<code>o</code>代表其他，<code>a</code>代表所有，<code>+</code>代表增加权限，<code>-</code>代表移除权限，<code>=</code>将权限设置成后面的值，额外的第三作用符号如下</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">&#96;X&#96; ：如果对象是目录或者它已有执行权限，赋予执行权限。
&#96;s&#96; ：运行时重新设置UID或GID。
&#96;t&#96; ：保留文件或目录。
&#96;u&#96; ：将权限设置为跟属主一样。
&#96;g&#96; ：将权限设置为跟属组一样。
&#96;o&#96; ：将权限设置为跟其他用户一样</code></pre>
</li>
<li><p>chown 改文件所属<br><code>chown option owner file[.group] file</code><br><code>chown owner.group file</code>直接改属主和组<br><code>chown owner .</code> 属主和组都同名<br><code>chgrp</code> 更改文件目录的默认属组</p>
</li>
</ul>
<h2 id="7-5-共享文件"><a href="#7-5-共享文件" class="headerlink" title="7.5 共享文件"></a>7.5 共享文件</h2><p>Linux还为每个文件和目录存储了3个额外的信息位。</p>
<ul>
<li>设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。</li>
<li>设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。</li>
<li>粘着位：进程结束后文件还驻留（粘着）在内存中。<br>如果你用的是八进制模式，你需要知道这些位的位置</li>
</ul>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>八进制值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>0</td>
<td>所有位都清零</td>
</tr>
<tr>
<td>001</td>
<td>1</td>
<td>粘着位置位</td>
</tr>
<tr>
<td>010</td>
<td>2</td>
<td>SGID位置位</td>
</tr>
<tr>
<td>011</td>
<td>3</td>
<td>SGID位和粘着位都置位</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>SUID位置位</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>SUID位和粘着位都置位</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>SUID位和SGID位都置位</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>所有位都置位</td>
</tr>
</tbody></table>
<p>首先，用 <code>mkdir</code> 命令来创建希望共享的目录。然后通过 <code>chgrp</code> 命令将目录的默认属组改为包<br>含所有需要共享文件的用户的组（你必须是该组的成员）。最后，将目录的SGID位置位，以保证<br>目录中新建文件都用shared作为默认属组  </p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ mkdir testdir
$ ls -l
drwxrwxr-x 2 rich rich 4096 Sep 20 23:12 testdir&#x2F;
$ chgrp shared testdir
$ chmod g+s testdir  &#x2F;&#x2F; chmod 6770 testdir
$ ls -l
drwxrwsr-x 2 rich shared 4096 Sep 20 23:12 testdir&#x2F;
$ umask 002
$ cd testdir
$ touch testfile
$ ls -l
total 0
-rw-rw-r-- 1 rich shared 0 Sep 20 23:13 testfile
</code></pre>

<h1 id="9-安装软件程序"><a href="#9-安装软件程序" class="headerlink" title="9. 安装软件程序"></a>9. 安装软件程序</h1><h2 id="9-1-包管理工具"><a href="#9-1-包管理工具" class="headerlink" title="9.1 包管理工具"></a>9.1 包管理工具</h2><p>管理版本</p>
<h2 id="9-2-基于Debian的系统"><a href="#9-2-基于Debian的系统" class="headerlink" title="9.2 基于Debian的系统"></a>9.2 基于Debian的系统</h2><p>基于 Debian 的系统</p>
<ul>
<li>dpkg 包管理工具</li>
<li>apt</li>
<li>apt-get</li>
<li>aptitude</li>
</ul>
<h3 id="9-2-1-用aptitude-管理软件包"><a href="#9-2-1-用aptitude-管理软件包" class="headerlink" title="9.2.1 用aptitude 管理软件包"></a>9.2.1 用aptitude 管理软件包</h3><p><code>apt</code>,<code>dpkg</code>是包管理工具，<code>aptitude</code>是完整的软件包管理系统</p>
<ol>
<li>aptitude show wine  显示包wine的详细信息</li>
<li>aptitude install package_name</li>
<li>aptitude search package_name<br> 如果看到一个 <code>i</code> ，说明这个包现在已经安装到了你的系统上了。如果看到一个 <code>p</code> 或 <code>v</code> ，说明这个包可用，但还没安装</li>
<li>aptitude safe-upgrade</li>
<li>aptitude remove&#x2F;purge package_name</li>
<li><code>/etc/apt/sources.list</code>前面有deb说明是编译过的，deb-src是源代码，package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。你可以看到诸如main、restricted、universe和partner这样的值</li>
</ol>
<p>dpkg -L vim  显示vim的所有安装信息<br>dpkg –search vim</p>
<h2 id="9-3-基于源码安装"><a href="#9-3-基于源码安装" class="headerlink" title="9.3 基于源码安装"></a>9.3 基于源码安装</h2><p>C++编译要使用CMake</p>
<h1 id="10-使用编辑器"><a href="#10-使用编辑器" class="headerlink" title="10. 使用编辑器"></a>10. 使用编辑器</h1><h2 id="10-1-vim-编辑器"><a href="#10-1-vim-编辑器" class="headerlink" title="10.1 vim 编辑器"></a>10.1 vim 编辑器</h2><ol>
<li><p>移动光标</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">文件很大,用方向键移动
gg 移动到最后一行
num G 移动到指定行数
G 移动到第一行
w file_name 将文件保存到另一个文件中
Pagedown + Pageup 翻页
w file_name 保存为另一个文件
</code></pre>
</li>
<li><p>编辑数据</p>
<pre class="language-none"><code class="language-none">
x 删除光标当前所在字符(剪切)
dd 是切除当前行, p 是粘贴(剪切)
dw 删除光标当前所在当前字符(剪切)
yw 复制一个单词  y$复制整个行
u 撤销
a 在文件尾追加数据
A 在当前行尾追加数据
r char 用char 替换当前光标位置字符
R char 用text文本替换当前文本字符
</code></pre></li>
<li><p>替换数据</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">:s&#x2F;old&#x2F;new&#x2F;  替换数据
:s&#x2F;olr&#x2F;new&#x2F;g  替换文件中一行所有old
:m,ns&#x2F;old&#x2F;new&#x2F;g 替换行号之间的所有old
:$s&#x2F;old&#x2F;new&#x2F;g 替换整个文件中的old
:$s&#x2F;old&#x2F;new&#x2F;gc 替换整个文件中的old，但是每次都提醒</code></pre></li>
</ol>
<h1 id="11-基本脚本"><a href="#11-基本脚本" class="headerlink" title="11.基本脚本"></a>11.基本脚本</h1><ul>
<li><p>创建shell脚本<br><code>#!/bin/bash</code>,bash找你的文件都是从path目录下，如果没有设置path目录那么就需要通过绝对路径和相对路径引用你的命令。然后是注意你的文件权限<code>umask</code>决定了你文件创建时候的默认权限</p>
</li>
<li><p>文本信息<br>echo可使用单引号和双引号来划定文本字符串</p>
<ol>
<li><code>echo  &quot;This is a test to see if you&#39;re paying attention&quot;</code>  文本中有单引号</li>
<li><code>echo  &#39;Rich says &quot;scripting is easy&quot;.&#39;</code> 文本中有双引号</li>
<li>如果是单&#x2F;双引号混合会怎样？</li>
<li>文本字符串和命令输出到同一行</li>
</ol>
</li>
<li><p>使用变量</p>
<ol>
<li>用户变量区分大小写长度不超过20个字符</li>
<li>变量,等号,值之间不能出现空格</li>
<li>引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符.没有美元符号引用变量进行赋值shell就会将其理解为字符串</li>
<li>命令替换分为<code>$()</code>和` `,testing&#x3D;$(date)他们中间没有空格.命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的.在命令行提示符下使用路径.&#x2F;运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。在命令行提示符下运行脚本时一定要留心！</li>
<li></li>
</ol>
</li>
<li><p>输入输出重定向</p>
<ul>
<li><code>&gt;</code>会覆盖,<code>&gt;&gt;</code>追加</li>
<li><code>wc &lt; test6</code> 输入重定向,内联重定向<code>&lt;&lt;</code>,在命令行上使用内联输入重定向时,shell会用PS2环境变量中定义的次提示符（参见第6章）</li>
<li>管道，Linux管道命令（断条符号）允许你将命令的输出直接重定向到另一个命令的输入。【这里的问题还很多】</li>
</ul>
</li>
<li><p>执行数学计算</p>
<ol>
<li><code>expr</code>命令,特别注意<code>expr 1+5</code>这种是不起作用的(建议以后少用)</li>
<li><code>$[ ]</code>对<code>expr</code>的改进,bash shell数学运算符只支持整数运算,<code>zsh</code>支持浮点运算</li>
<li><code>bc</code>计算器<ul>
<li><p><code>scale=4</code> 保留四位精度，<code>3.44 / 5 = .6880</code>, 支持定义变量</p>
</li>
<li><p>在脚本中使用<code>bc</code>,<code>variable=$(echo &quot;scale=4 ;3.44 / 5&quot; | bc)</code>,<code>var3=$(echo &quot;scale=4; $var1 / $var2&quot; | bc)</code>这里的var1和var2都是预定义的</p>
</li>
<li><p>将表达式定义到一个文件中，或者内联表达式</p>
 <pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash 
var1&#x3D;10.46 
var2&#x3D;43.67 
var3&#x3D;33.2 
var4&#x3D;71 
var5&#x3D;$(bc &lt;&lt; EOF 
scale &#x3D; 4 
a1 &#x3D; ( $var1 * $var2) 
b1 &#x3D; ($var3 * $var4) 
a1 + b1 
EOF 
)

echo The final answer for this mess is $var5</code></pre></li>
</ul>
</li>
</ol>
</li>
<li><p>退出脚本</p>
<ol>
<li><code>0</code>成功结束，<code>1</code>一般未知错误，<code>2</code>不适合的shell命令，<code>126</code>命令不可执行,<code>127</code>没找到命令，<code>128</code>无效退出参数，<code>128+x</code>与linux信号x相关的严重错误，<code>130</code>通过ctrl+退出，<code>255</code>正常范围之外的退出状态码</li>
<li><code>exit</code>退出命令，可以自定义状态码，退出状态码最大只能是255，所以超过255会进行模运算</li>
</ol>
</li>
</ul>
<h1 id="12-使用结构化命令"><a href="#12-使用结构化命令" class="headerlink" title="12. 使用结构化命令"></a>12. 使用结构化命令</h1><ul>
<li><p>if statement</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">## style 1
if pwd
then
  echo &quot;it works&quot;
fi
## style 2
if pwd ; then 
  echo &quot;it works&quot;
fi

# style 3 
## 如果grep返回0 就去执行echo statement
if grep $testuser &#x2F;etc&#x2F;passwd
then 
  echo &quot;this is my first command&quot;
  echo &quot;this is my second command&quot;
fi
## if elif else  ,在elif语句中，紧跟其后的else语句属于elif代码块。它们并不属于之前的if-then代码块 
if pwd 
then 
  echo 1
else | elif command  ;then  echo 3 ; else  fi
  echo 2
fi
</code></pre>
</li>
<li><p>test命令</p>
<p>如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。支持符合条件检查</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">## 单一逻辑校验
if [ condition ] 
then 
  commands
fi
## 符合逻辑校验
if [ condition1 ] &amp;&amp; [ condition2 ] || [ condition ] 
then 
  commands
fi</code></pre>

<ul>
<li><p>数值比较</p>
<ul>
<li>n1 -eq n2   等于</li>
<li>n1 -ge n2   大于等于</li>
<li>n1 -gt n2   大于</li>
<li>n1 -le n2   小于等于</li>
<li>n1 -lt n2   小于</li>
</ul>
</li>
<li><p>字符串比较</p>
<ul>
<li>str1 &#x3D; str2 字面量相等，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内</li>
<li>str1 !&#x3D; str2 不相等</li>
<li>str1 &lt; str2   小于. <code>if [ $val1 &gt; $val2 ]</code>直接这样比较字符串会创建一个文件。所以必须要转义<code>if [ $val1 \&gt; $val2 ]</code>。在比较测试中，大写字母被认为是小于小写字母的。比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果但sort命令恰好相反，本地语言设置（英语），A在a前面</li>
<li>str1 &gt; str2   大于</li>
<li>-n str1  判断长度是否为非零</li>
<li>-z str1  判断长度是否为零</li>
</ul>
</li>
<li><p>文件比较</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-d file</td>
<td>d&#x3D;directory. 检查file是否存在并是一个目录</td>
</tr>
<tr>
<td>-e file</td>
<td>e&#x3D;exist. 检查file是否存在</td>
</tr>
<tr>
<td>-f file</td>
<td>f&#x3D;file. 检查file是否存在并是一个文件</td>
</tr>
<tr>
<td>-r file</td>
<td>r&#x3D;read. 检查file是否存在并可读</td>
</tr>
<tr>
<td>-s file</td>
<td>s&#x3D;检查file 是否存在并非空</td>
</tr>
<tr>
<td>-w file</td>
<td>w&#x3D;write. 检查file是否存在并可写</td>
</tr>
<tr>
<td>-x file</td>
<td>检查file 是否存在并可执行</td>
</tr>
<tr>
<td>-O file</td>
<td>O&#x3D;all user 检查file是否存在并属当前用户所有</td>
</tr>
<tr>
<td>-G file</td>
<td>G&#x3D;group 检查file是否存在并且默认组与当前用户相同</td>
</tr>
<tr>
<td>file1 -nt file2</td>
<td>检查file1是否比file2新</td>
</tr>
<tr>
<td>file1 -ot file2</td>
<td>检查file1是否比file2旧</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>(( ))和[[ ]]提供高级特性</p>
<ul>
<li>(( )) 提供更加方便的数学表达式计算，像其他oop语言一样</li>
<li>[[ ]] 提供更加方便的字符串处理功能</li>
</ul>
</li>
<li><p><code>case</code>命令</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">case variable in 
pattern1 | pattern2 ) command1;;
pattern3) command2;;
*) command3;;
esac
</code></pre></li>
</ul>
<h1 id="13-for-循环"><a href="#13-for-循环" class="headerlink" title="13. for 循环"></a>13. for 循环</h1><h2 id="13-1-for命令"><a href="#13-1-for命令" class="headerlink" title="13.1 for命令"></a>13.1 for命令</h2><ul>
<li>for 基本语句</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">list&#x3D;&quot;Alabama Alaska Arizona Arkansas Colorado&quot; 
list&#x3D;$list&quot; Connecticut&quot;
for v in v_list
do
  echo 1

done
</code></pre>

<p>v_list如果有单引号，1.用转义字符转义。2.用双引号定义用到的单引号的值。3.如果在单独的数据值中有空格，就必须用双引号将这些值圈起来，可直接拼接值。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">file&#x3D;&quot;path of your file&quot;
for state in $(cat $file) 
do 
 echo &quot;Visit beautiful $state&quot; 
done
</code></pre>

<p>读取文件内容进行迭代<br>(ubuntu没有IFS环境变量和IFS.OLD)</p>
<ul>
<li><p>更改字段分隔符<br>默认分隔符是<code>空格</code>，<code>制表符</code>，<code>换行符</code>环境变量IFS,控制着字段分隔符，有时候想灵活一点,有些地方用的换行符，但是其他地方继续保留原先的分隔符，可使用IFS&#x3D;$’\n’, IFS.OLD&#x3D;$IFS,IFS&#x3D;$’\n’,但是如果想加入冒号作为换行符可以更改<code>/etc/passwd</code>文件加上IFS&#x3D;:,如果想加多个可以依次在后面加IFS&#x3D;’\n’:;”</p>
</li>
<li><p>通配符</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!bin&#x2F;bash
for file in &#x2F;home&#x2F;rich&#x2F;test&#x2F;* 
do 
  if [ -d &quot;$file&quot; ] 
  then 
    echo &quot;$file is a directory&quot; 
  elif [ -f &quot;$file&quot; ] 
  then 
    echo &quot;$file is a file&quot; 
  fi 
done
## 目录文件都会匹配
##请注意这次条件判断有些特别使用了if [ -d &quot;$file&quot; ] 因为在linux中文件名有空格是合法的
</code></pre></li>
</ul>
<h2 id="13-2-C语言风格"><a href="#13-2-C语言风格" class="headerlink" title="13.2 C语言风格"></a>13.2 C语言风格</h2><pre class="language-bash" data-language="bash"><code class="language-bash">
for (( a&#x3D;1,b&#x3D;10;a&lt;&#x3D;10;a++,b--))
do
  echo 1
done
</code></pre>

<h2 id="13-3-while语句"><a href="#13-3-while语句" class="headerlink" title="13.3 while语句"></a>13.3 while语句</h2><pre class="language-bash" data-language="bash"><code class="language-bash">while true
do
  echo

done
</code></pre>

<p><code>break</code> 还可以指定跳出循环层数,两层<code>for</code>就跳出最内层,<code>break n</code>就会跳出.<br><code>continue</code>结束本次循环，n为1，表明跳出的是当前的循环。如果你将n设为2，break命令就会停止下一级的外部循环  </p>
<ul>
<li><p>处理循环中的输出</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">for file in &#x2F;home&#x2F;rich&#x2F;* 
do 
if [ -d &quot;$file&quot; ] 
then 
  echo &quot;$file is a directory&quot; 
elif 
  echo &quot;$file is a file&quot;  
fi 
done &gt; output.txt</code></pre>
</li>
<li><p>处理多个测试命令</p>
<p>这种情况下要注意，判断了所有条件，因为有一个条件返回为false，所以相当于逻辑<code>与</code>判断</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# testing a multicommand while loop 
var1&#x3D;10 
while echo $var1 
        [ $var1 -ge 0 ] 
do 
echo &quot;This is inside the loop&quot; 
var1&#x3D;$[ $var1 - 1 ] 
done 
</code></pre></li>
</ul>
<p>while 或者for的嵌套循环中，内部循环可以读到外部变量</p>
<h2 id="13-4-until命令"><a href="#13-4-until命令" class="headerlink" title="13.4 until命令"></a>13.4 until命令</h2><p>有点像其他语言的<br>do …. while 语法</p>
<h2 id="13-5-循环处理数据并以特定分隔符分割数据"><a href="#13-5-循环处理数据并以特定分隔符分割数据" class="headerlink" title="13.5 循环处理数据并以特定分隔符分割数据"></a>13.5 循环处理数据并以特定分隔符分割数据</h2><p>主要是修改IFS变量</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash 
# changing the IFS value 
IFS.OLD&#x3D;$IFS 
IFS&#x3D;&#39;\n&#39;
for entry in $(cat &#x2F;etc&#x2F;passwd) 
do 
 echo &quot;Values in $entry –&quot; 
 IFS&#x3D;&#39;:&#39;
  for value in $entry 
  do 
    echo &quot; $value&quot; 
  done 
done </code></pre>

<h1 id="14-处理用户输入"><a href="#14-处理用户输入" class="headerlink" title="14. 处理用户输入"></a>14. 处理用户输入</h1><h2 id="14-1-读取参数，脚本名和测试参数"><a href="#14-1-读取参数，脚本名和测试参数" class="headerlink" title="14.1 读取参数，脚本名和测试参数"></a>14.1 读取参数，脚本名和测试参数</h2><ul>
<li><p>.&#x2F;sumAB.sh  a  b  ## 这里$0是程序名, <code>$1</code>是a, <code>$2</code>是b. 超过九个就一定要花括号引用变量比如<code>$&#123;10&#125;</code>，<code>$#</code>返回参数个数， <code>$&#123;!#&#125;</code>获取最后一个参数，如果没有参数就会输出脚本名，<code>$*</code>变量会将所有参数当成单个参数,<code>$@</code>变量会组成数组，轻松访问所有的参数.</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">for param in &quot;$@&quot;
do 
echo &quot;\$@ Parameter #$count &#x3D; $param&quot; 
count&#x3D;$[ $count + 1 ] 
done </code></pre>
</li>
<li><p>如果程序名是<code>./test.sh</code>,那么echo $0 就是<code>./test.sh</code></p>
</li>
<li><p>如果程序名是<code>bash  /usr/lib/test.sh</code>,那么echo $0 就是<code>/usr/lib/test.sh</code></p>
</li>
<li><p>定义了参数位置，如果不传参会报错</p>
</li>
<li><p><code>name=$(basename $0)</code> 可以只返回脚本名</p>
</li>
<li><p><code>if [ -n &quot;$1&quot; ]</code>是指<code>$1</code>不为空</p>
</li>
<li><p><code>shift</code>命令会移动命令参数,<code>shift n</code>可以指定跳过<code>n</code>参数.</p>
</li>
</ul>
<h2 id="14-2-处理选项"><a href="#14-2-处理选项" class="headerlink" title="14.2 处理选项"></a>14.2 处理选项</h2><p>bash命令提供了<code>选项</code>和<code>参数</code>来控制,可以通过<code>shift</code>命令来控制</p>
<ul>
<li><p>处理简单的选项</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# extracting command line options as parameters 
# 
echo 
while [ -n &quot;$1&quot; ] 
do 
case &quot;$1&quot; in 
  -a) echo &quot;Found the -a option&quot; ;; 
  -b) echo &quot;Found the -b option&quot; ;; 
  -c) echo &quot;Found the -c option&quot; ;; 
  *) echo &quot;$1 is not an option&quot; ;; 
esac
shift 
done 
$ .&#x2F;test15.sh -a -b -c -d</code></pre>
</li>
<li><p>分离选项和参数</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# extracting options and parameters 
echo 
while [ -n &quot;$1&quot; ] 
do 
  case &quot;$1&quot; in 
    -a) echo &quot;Found the -a option&quot; ;; 
    -b) echo &quot;Found the -b option&quot;;; 
    -c) echo &quot;Found the -c option&quot; ;; 
    --) shift 
              break ;; 
    *) echo &quot;$1 is not an option&quot;;; 
  esac 
shift 
done 
# 
count&#x3D;1 
for param in $@ 
do 
  echo &quot;Parameter #$count: $param&quot; 
  count&#x3D;$[ $count + 1 ] 
done 
$ .&#x2F;test16.sh -c -a -b -- test1 test2 test3</code></pre>
</li>
<li><p>处理带值的选项</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# extracting command line options and values 
echo 
while [ -n &quot;$1&quot; ] 
do 
  case &quot;$1&quot; in 
    -a) echo &quot;Found the -a option&quot;;; 
    -b) param&#x3D;&quot;$2&quot; 
    echo &quot;Found the -b option, with parameter value $param&quot; 
    shift ;; 
    -c) echo &quot;Found the -c option&quot;;; 
    --) shift 
    break ;; 
    *) echo &quot;$1 is not an option&quot;;; 
  esac 
  shift 
done 
# 
count&#x3D;1 
for param in &quot;$@&quot; 
do 
  echo &quot;Parameter #$count: $param&quot; 
  count&#x3D;$[ $count + 1 ] 
done 
$ .&#x2F;test17.sh -a -b test1 -d</code></pre>

<p>case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是$1，额外的参数值就应该位于$2（因为所有的参数在处理完之后都会被移出）。只要将参数值从$2变量中提取出来就可以了</p>
</li>
<li><p>使用getopt与getopts命令<br>getopts命令会用到两个环境变量。如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。<br>OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。<br>这样你就能在处理完选项之后继续处理其他命令行参数了。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# simple demonstration of the getopts command 
# 
echo 
  while getopts :ab:c opt 
do 
  case &quot;$opt&quot; in 
  a) echo &quot;Found the -a option&quot; ;; 
  b) echo &quot;Found the -b option, with value $OPTARG&quot;;; 
  c) echo &quot;Found the -c option&quot; ;; 
  *) echo &quot;Unknown option: $opt&quot;;; 
  esac 
done
$ bash .&#x2F;test19.sh -a -b &quot;1 2&quot; -c  # 在参数中加空格
$ bash .&#x2F;test19.sh -abtest1        # 可以挨在一起
$ bash .&#x2F;test19.sh -d              # 返回问号
$ bash .&#x2F;test19.sh -a -b 456 -cdefg# 如果有参数的就要分开写</code></pre>

<ul>
<li>使用OPTIND参数和OPTARG参数</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# Processing options &amp; parameters with getopts 
# 
echo 
while getopts :ab:cd opt 
do 
case &quot;$opt&quot; in 
  a) echo &quot;Found the -a option&quot; ;; 
  b) echo &quot;Found the -b option, with value $OPTARG&quot; ;; 
  c) echo &quot;Found the -c option&quot; ;; 
  d) echo &quot;Found the -d option&quot; ;; 
  *) echo &quot;Unknown option: $opt&quot; ;; 
esac 
done 
# 
shift $[ $OPTIND - 1 ] 
# 
echo 
  count&#x3D;1 
for param in &quot;$@&quot; 
do 
  echo &quot;Parameter $count: $param&quot; 
  count&#x3D;$[ $count + 1 ] 
done</code></pre>
</li>
<li><p>选项标准化</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有对象</td>
</tr>
<tr>
<td>-c</td>
<td>生成一个计数</td>
</tr>
<tr>
<td>-d</td>
<td>指定一个目录</td>
</tr>
<tr>
<td>-e</td>
<td>扩展一个对象</td>
</tr>
<tr>
<td>-f</td>
<td>指定读入数据的文件</td>
</tr>
<tr>
<td>-h</td>
<td>显示命令的帮助信息</td>
</tr>
<tr>
<td>-i</td>
<td>忽略文本大小写</td>
</tr>
<tr>
<td>-l</td>
<td>产生输出的长格式版本</td>
</tr>
<tr>
<td>-n</td>
<td>使用非交互模式（批处理）</td>
</tr>
<tr>
<td>-o</td>
<td>将所有输出重定向到的指定的输出文件</td>
</tr>
<tr>
<td>-q</td>
<td>以安静模式运行</td>
</tr>
<tr>
<td>-r</td>
<td>递归地处理目录和文件</td>
</tr>
<tr>
<td>-s</td>
<td>以安静模式运行</td>
</tr>
<tr>
<td>-v</td>
<td>生成详细输出</td>
</tr>
<tr>
<td>-x</td>
<td>排除某个对象</td>
</tr>
<tr>
<td>-y</td>
<td>对所有问题回答yes</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="14-3-获取用户输入"><a href="#14-3-获取用户输入" class="headerlink" title="14.3 获取用户输入"></a>14.3 获取用户输入</h2><ul>
<li><p><code>read</code>命令，</p>
<ul>
<li>read命令包含了-p选项，允许你直接在read命令行指定提示符,</li>
<li>read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量</li>
<li><code>-t</code>代表超时</li>
<li><code>-n 1</code>read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量</li>
<li><code>-s</code> 选项可以避免在read命令中输入的数据出现在显示器上</li>
<li>从文件中读取数据</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;单个变量
read -p &quot;please enter your age&quot; age
&#x2F;&#x2F;多个变量
read -p &quot;please enter your name&quot; first last
&#x2F;&#x2F; 超时参数
read -t 5 -p 
&#x2F;&#x2F; 获取指定字符个数
read -n1  -p &quot;Do you want to continue [Y&#x2F;N]?&quot; answer
&#x2F;&#x2F;隐藏输入
read -s -p &quot;Enter your password: &quot; pass 
&#x2F;&#x2F; 从文件中读取数据
#!&#x2F;bin&#x2F;bash
# reading data from a file 
# 
count&#x3D;1 
cat test | while read line 
do 
  echo &quot;Line $count: $line&quot; 
  count&#x3D;$[ $count + 1] 
done 
echo &quot;Finished processing the file&quot; </code></pre></li>
</ul>
<h1 id="15-呈现数据"><a href="#15-呈现数据" class="headerlink" title="15. 呈现数据"></a>15. 呈现数据</h1><p>这一章主要是讲如何将脚本输出重定型向到系统其他位置</p>
<h2 id="15-1-理解输入和输出"><a href="#15-1-理解输入和输出" class="headerlink" title="15.1 理解输入和输出"></a>15.1 理解输入和输出</h2><h3 id="15-1-1-标准文件描述符"><a href="#15-1-1-标准文件描述符" class="headerlink" title="15.1.1 标准文件描述符"></a>15.1.1 标准文件描述符</h3><p>Linux系统将每个对象(操作的文件，linux万物皆文件)当作文件处理。这包括输入和输出进程。Linux用文件描述符（filedescriptor）来标识每个文件对象</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">文件描述符  缩 写   描 述
0           STDIN   标准输入
1           STDOUT  标准输出
2           STDERR  标准错误</code></pre>

<ol>
<li>STDIN实例<br><code>cat</code> 就会从STDIN输入数据，这时候你输入什么屏幕就会显示什么<br><code>cat &lt; file.txt</code>通过STDIN通过重定向符号使<code>cat</code>查看一个非STDIN文件的输入</li>
<li>STDOUT  </li>
<li>STDERR<br>shell通过特殊的<code>STDERR</code>文件描述符来处理错误消息。<code>STDERR</code>文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置</li>
</ol>
<h3 id="15-1-2-重定向错误"><a href="#15-1-2-重定向错误" class="headerlink" title="15.1.2 重定向错误"></a>15.1.2 重定向错误</h3><ol>
<li>只重定向错误<br>通过<code>2&gt; file.txt</code>的方式将错误信息重定向到文件中</li>
<li>重定向错误和数据<br><code>ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</code> 这种就是将<code>STDERR</code>重定向到test6,然后将<code>STDOUT</code>重定向到test7.<br>也可以将STDERR和STDOUT的输出重定向到同一个输出文件使用<code>&amp;&gt;</code>,比如<code>ls -al test test2 test3 badtest &amp;&gt; test7</code>，bash消息赋予error更高的优先级</li>
</ol>
<h2 id="15-2-在脚本中重定向输出"><a href="#15-2-在脚本中重定向输出" class="headerlink" title="15.2 在脚本中重定向输出"></a>15.2 在脚本中重定向输出</h2><p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>
<ul>
<li>临时重定向行输出</li>
<li>永久重定向脚本中的所有命令</li>
</ul>
<h3 id="15-2-1-临时重定向"><a href="#15-2-1-临时重定向" class="headerlink" title="15.2.1 临时重定向"></a>15.2.1 临时重定向</h3><p>如果使用上文提到的<code>STDERR</code>重定向方法就会将全局的<code>STDERR</code>信息都重定向到文件中，但是如果只重定向自己特定某些error信息就可以使用临时重定向，必须在文件描述符数字之前加一个<code>&amp;</code></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"># 举个例子 .&#x2F;test8
#!&#x2F;bin&#x2F;bash
# testing STDERR messages 
echo &quot;This is an error&quot; &gt;&amp;2 
echo &quot;This is normal output&quot; </code></pre>
<p>临时重定向就是需要在脚本中一行一行的重定向log<br>如果像平常一样运行这个脚本，你可能看不出什么区别,因为所有输出都到了STDOUT,但是默认情况下,linux会将STDERR导向STDOUT,但是,如果你在运行脚本时重定向了STDERR,脚本中所有导向STDERR的文本都会被重定向。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ .&#x2F;test8 2&gt; test9
This is normal output 
$ cat test9 
This is an error </code></pre>

<h3 id="15-2-2-永久重定向"><a href="#15-2-2-永久重定向" class="headerlink" title="15.2.2 永久重定向"></a>15.2.2 永久重定向</h3><p>脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可以用<code>exec</code>命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# redirecting all output to a file 
exec 1&gt;testout 
echo &quot;This is a test of redirecting all output&quot; 
echo &quot;from a script to another file.&quot; 
echo &quot;without having to redirect every individual line&quot; </code></pre>

<h2 id="15-3-在脚本中重定向输入"><a href="#15-3-在脚本中重定向输入" class="headerlink" title="15.3 在脚本中重定向输入"></a>15.3 在脚本中重定向输入</h2><p><code>exec</code>命令允许你将STDIN重定向到Linux系统上的文件中<code>exec 0&lt; testfile</code></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"># redirecting file input 
exec 0&lt; testfile 
count&#x3D;1 
while read line 
do 
 echo &quot;Line #$count: $line&quot; 
 count&#x3D;$[ $count + 1 ] 
done </code></pre>

<h2 id="15-4-创建自己的重定向"><a href="#15-4-创建自己的重定向" class="headerlink" title="15.4 创建自己的重定向"></a>15.4 创建自己的重定向</h2><h3 id="15-4-1-创建输出文件描述符"><a href="#15-4-1-创建输出文件描述符" class="headerlink" title="15.4.1 创建输出文件描述符"></a>15.4.1 创建输出文件描述符</h3><p>可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件<br>描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。这里有个在脚本中使用其<br>他文件描述符的简单例子。(不是太理解这句话)</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#.&#x2F;test13
#!&#x2F;bin&#x2F;bash
# using an alternative file descriptor 
exec 3&gt;test13out 
echo &quot;This should display on the monitor&quot; 
echo &quot;and this should be stored in the file&quot; &gt;&amp;3 
echo &quot;Then this should be back on the monitor&quot; 
$ .&#x2F;test13
This should display on the monitor 
Then this should be back on the monitor 
$ cat test13out 
and this should be stored in the file 
</code></pre>

<p>从表现上看,只有自己定义的重定向的输出会重定向到test13out文件。其他的还是会输出到STDOUT这个<br>脚本用exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内容会像预想中那样<br>显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入了另一个文件。这样你就可以<br>在显示器上保持正常的输出，而将特定信息重定向到文件中（比如日志文件）。</p>
<h3 id="15-4-2-重定向文件描述符"><a href="#15-4-2-重定向文件描述符" class="headerlink" title="15.4.2 重定向文件描述符"></a>15.4.2 重定向文件描述符</h3><p>现在介绍怎么恢复已重定向的文件描述符。你可以分配另外一个文件描述符给标准文件描述<br>符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用<br>该文件描述符重定向回STDOUT。听起来可能有点复杂，但实际上相当直接。这个简单的例子能<br>帮你理清楚。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"># .&#x2F;test14 
#!&#x2F;bin&#x2F;bash
# storing STDOUT, then coming back to it 
exec 3&gt;&amp;1
exec 1&gt;test14out 
echo &quot;This should store in the output file&quot; 
echo &quot;along with this line.&quot; 
exec 1&gt;&amp;3
echo &quot;Now things should be back to normal&quot; 
$ 
$ .&#x2F;test14 
Now things should be back to normal 
$ cat test14out 
This should store in the output file 
along with this line. 
$ </code></pre>

<p>这个方法可能有点叫人困惑，但这是一种在脚本中临时重定向输出，然后恢复默认输出设置<br>的常用方法。</p>
<h3 id="15-4-3-创建输入文件描述符"><a href="#15-4-3-创建输入文件描述符" class="headerlink" title="15.4.3 创建输入文件描述符"></a>15.4.3 创建输入文件描述符</h3><p>可以用和<strong>重定向输出文件描述符</strong>同样的办法重定向输入文件描述符。在重定向到文件之前，<br>先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它<br>原来的位置</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash 
# redirecting input file descriptors 
exec 6 &lt; &amp;0 
exec 0&lt; testfile 
count&#x3D;1 
while read line 
do 
 echo &quot;Line #$count: $line&quot; 
 count&#x3D;$[ $count + 1 ] 
done 
exec 0&lt;&amp;6 
read -p &quot;Are you done now? &quot; answer 
case $answer in 
Y|y) echo &quot;Goodbye&quot;;; 
N|n) echo &quot;Sorry, this is the end.&quot;;; 
esac
$ .&#x2F;test15
Line #1: This is the first line.
Line #2: This is the second line. 
Line #3: This is the third line. 
Are you done now? y 
Goodbye </code></pre>

<h3 id="15-4-4-创建读写文件描述符"><a href="#15-4-4-创建读写文件描述符" class="headerlink" title="15.4.4 创建读写文件描述符"></a>15.4.4 创建读写文件描述符</h3><p>(第一遍不是很懂)<br>尽管看起来可能会很奇怪，但是你也可以打开单个文件描述符来作为输入和输出。可以用同<br>一个文件描述符对同一个文件进行读写。<br>不过用这种方法时，你要特别小心。由于你是对同一个文件进行数据读写，shell会维护一个<br>内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。如果不够小<br>心，它会产生一些令人瞠目的结果。看看下面这个例子。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">
#!&#x2F;bin&#x2F;bash 
# testing input&#x2F;output file descriptor 
exec 3&lt;&gt; testfile 
read line &lt;&amp;3 
echo &quot;Read: $line&quot; 
echo &quot;This is a test line&quot; &gt;&amp;3 
$ cat testfile 
This is the first line. 
This is the second line. 
This is the third line. 

#输出

$ .&#x2F;test16 
Read: This is the first line. </code></pre>

<p>这个例子用了exec命令将文件描述符3分配给文件testfile以进行文件读写。接下来，它<br>通过分配好的文件描述符，使用read命令读取文件中的第一行，然后将这一行显示在STDOUT上。<br>最后，它用echo语句将一行数据写入由同一个文件描述符打开的文件中。<br>在运行脚本时，一开始还算正常。输出内容表明脚本读取了testfile文件中的第一行。但如果<br>你在脚本运行完毕后，查看testfile文件内容的话，你会发现写入文件中的数据覆盖了已有的数据。<br>当脚本向文件中写入数据时，它会从文件指针所处的位置开始。read命令读取了第一行数<br>据，所以它使得文件指针指向了第二行数据的第一个字符。在echo语句将数据输出到文件时，<br>它会将数据放在文件指针的当前位置，覆盖了该位置的已有数据。</p>
<h3 id="15-4-5-关闭文件描述符"><a href="#15-4-5-关闭文件描述符" class="headerlink" title="15.4.5 关闭文件描述符"></a>15.4.5 关闭文件描述符</h3><p>(第一遍不是很懂)<br>如果你创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们。然而在有些<br>情况下，你需要在脚本结束前手动关闭文件描述符。<br>要关闭文件描述符，将它重定向到特殊符号&amp;-。脚本中看起来如下：<br><code>exec 3&gt;&amp;- </code><br>该语句会关闭文件描述符3，不再在脚本中使用它。这里有个例子来说明当你尝试使用已关<br>闭的文件描述符时会怎样。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cat badtest 
#!&#x2F;bin&#x2F;bash 
# testing closing file descriptors 
exec 3&gt; test17file 
echo &quot;This is a test line of data&quot; &gt;&amp;3 
exec 3&gt;&amp;- 
echo &quot;This won&#39;t work&quot; &gt;&amp;3 
$ .&#x2F;badtest 
.&#x2F;badtest: 3: Bad file descriptor 
$ </code></pre>
<p>一旦关闭了文件描述符，就不能在脚本中向它写入任何数据，否则shell会生成错误消息。<br>在关闭文件描述符时还要注意另一件事。如果随后你在脚本中打开了同一个输出文件，shell<br>会用一个新文件来替换已有文件。这意味着如果你输出数据，它就会覆盖已有文件。考虑下面这<br>个问题的例子。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cat test17 
#!&#x2F;bin&#x2F;bash 
#testing closing file descriptors 
exec 3&gt; test17file 
echo &quot;This is a test line of data&quot; &gt;&amp;3 
exec 3&gt;&amp;- 
cat test17file 
exec 3&gt; test17file 
echo &quot;This&#39;ll be bad&quot; &gt;&amp;3 
$ .&#x2F;test17 
This is a test line of data 
$ cat test17file 
This&#39;ll be bad 
$ </code></pre>


<h2 id="15-5-列出未关闭的文件描述符"><a href="#15-5-列出未关闭的文件描述符" class="headerlink" title="15.5 列出未关闭的文件描述符"></a>15.5 列出未关闭的文件描述符</h2><p>你能用的文件描述符只有9个，你可能会觉得这没什么复杂的。但有时要记住哪个文件描述<br>符被重定向到了哪里很难。为了帮助你理清条理，bash shell提供了<code>lsof</code>命令。<code>$$</code>可以读取当前程序运行的的PID,<code>-a</code><br>对其他两个选项的输出做AND运算  </p>
<pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;sbin&#x2F;lsof -a -p $$ -d 0,1,2
# lsof的默认输出
COMMAND     正在运行的命令名的前9个字符
PID         进程的PID 
USER        进程属主的登录名
FD          文件描述符号以及访问类型（r代表读，w代表写，u代表读写）
TYPE        文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）
DEVICE      设备的设备号（主设备号和从设备号）
SIZE        如果有的话，表示文件的大小
NODE        本地文件的节点号
NAME        文件名</code></pre>

<p>与STDIN、STDOUT和STDERR关联的文件类型是字符型。因为STDIN、STDOUT和STDERR文<br>件描述符都指向终端，所以输出文件的名称就是终端的设备名。所有3种标准文件都支持读和写<br>（尽管向STDIN写数据以及从STDOUT读数据看起来有点奇怪）。<br>现在看一下在打开了多个替代性文件描述符的脚本中使用lsof命令的结果。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cat test18 
#!&#x2F;bin&#x2F;bash 
# testing lsof with file descriptors 
exec 3&gt; test18file1 
exec 6&gt; test18file2 
exec 7&lt; testfile 
&#x2F;usr&#x2F;sbin&#x2F;lsof -a -p $$ -d0,1,2,3,6,7 
$ .&#x2F;test18 
COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME 
test18 3594 rich 0u CHR 136,0 2 &#x2F;dev&#x2F;pts&#x2F;0 
test18 3594 rich 1u CHR 136,0 2 &#x2F;dev&#x2F;pts&#x2F;0 
test18 3594 rich 2u CHR 136,0 2 &#x2F;dev&#x2F;pts&#x2F;0 
18 3594 rich 3w REG 253,0 0 360712 &#x2F;home&#x2F;rich&#x2F;test18file1 
18 3594 rich 6w REG 253,0 0 360715 &#x2F;home&#x2F;rich&#x2F;test18file2 
18 3594 rich 7r REG 253,0 73 360717 &#x2F;home&#x2F;rich&#x2F;testfile 
$ </code></pre>

<p>该脚本创建了3个替代性文件描述符，两个作为输出（3和6），一个作为输入（7）。在脚本<br>运行lsof命令时，可以在输出中看到新的文件描述符。我们去掉了输出中的第一部分，这样你<br>就能看到文件名的结果了。文件名显示了文件描述符所使用的文件的完整路径名。它将每个文件<br>都显示成REG类型的，这说明它们是文件系统中的常规文件。</p>
<p>(第一遍不是很懂)</p>
<h2 id="15-6-组织命令输出"><a href="#15-6-组织命令输出" class="headerlink" title="15.6 组织命令输出"></a>15.6 组织命令输出</h2><p>如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这<br>会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。<br>要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名<br>字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。<br>在Linux系统上null文件的标准位置是&#x2F;dev&#x2F;null。你重定向到该位置的任何数据都会被丢掉，<br>不会显示。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">
cat &#x2F;dev&#x2F;null&#x2F; &gt; test18
# 这时候test18文件就是空的
</code></pre>

<h2 id="15-7-创建临时文件"><a href="#15-7-创建临时文件" class="headerlink" title="15.7 创建临时文件"></a>15.7 创建临时文件</h2><h3 id="15-7-1-创建本地临时文件"><a href="#15-7-1-创建本地临时文件" class="headerlink" title="15.7.1 创建本地临时文件"></a>15.7.1 创建本地临时文件</h3><pre class="language-bash" data-language="bash"><code class="language-bash">mktemp   kirk.XXXXXX  # 这里面的XXXXXX是必须的</code></pre>

<p>这是在本地目录创建临时文件</p>
<h3 id="15-7-2-在-x2F-temp-x2F-创建临时文件"><a href="#15-7-2-在-x2F-temp-x2F-创建临时文件" class="headerlink" title="15.7.2 在&#x2F;temp&#x2F;创建临时文件"></a>15.7.2 在&#x2F;temp&#x2F;创建临时文件</h3><pre class="language-bash" data-language="bash"><code class="language-bash">mktemp -t kirk.XXXXXX</code></pre>

<p>在&#x2F;temp&#x2F;目录下创建了一个临时文件夹</p>
<h3 id="15-7-3-创建临时目录"><a href="#15-7-3-创建临时目录" class="headerlink" title="15.7.3 创建临时目录"></a>15.7.3 创建临时目录</h3><pre class="language-bash" data-language="bash"><code class="language-bash">mktemp -d kirk.XXXXXX</code></pre>

<p>在&#x2F;temp&#x2F;目录下创建文件夹</p>
<h2 id="15-8-记录消息"><a href="#15-8-记录消息" class="headerlink" title="15.8 记录消息"></a>15.8 记录消息</h2><p>有时候想把STDOUT输出到指定文件，又想输出到屏幕上，可以考虑使用<code>tee</code>命令,但是tee命令会覆盖以前的内容<br>但是如果你想把输出追加到文件中需要使用<code>-a</code>选项</p>
<h2 id="15-9-实战"><a href="#15-9-实战" class="headerlink" title="15.9 实战"></a>15.9 实战</h2><p>稍后完善</p>
<h1 id="16-控制脚本"><a href="#16-控制脚本" class="headerlink" title="16. 控制脚本"></a>16. 控制脚本</h1><h2 id="16-1-处理信号"><a href="#16-1-处理信号" class="headerlink" title="16.1 处理信号"></a>16.1 处理信号</h2><p>linux利用信号与运行在系统中的进程进行通信，</p>
<h3 id="16-1-1-重温linux信号"><a href="#16-1-1-重温linux信号" class="headerlink" title="16.1.1 重温linux信号"></a>16.1.1 重温linux信号</h3><p>linux可以与程序产生30多种信号</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">信 号     值       描 述
1         SIGHUP  挂起进程
2         SIGINT  终止进程
3         SIGQUIT 停止进程
9         SIGKILL 无条件终止进程
15        SIGTERM 尽可能终止进程
17        SIGSTOP 无条件停止进程，但不是终止进程
18        SIGTSTP 停止或暂停进程，但不终止进程
19        SIGCONT 继续运行停止的进程</code></pre>

<p>默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，<br>交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。<br>如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退<br>出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。</p>
<h3 id="16-1-2-生成信号"><a href="#16-1-2-生成信号" class="headerlink" title="16.1.2 生成信号"></a>16.1.2 生成信号</h3><ol>
<li>crtl+C 生成SIGINT(2)终止进程信号</li>
<li>crtl+Z 生成SIGTSTP(17)停止shell中运行的任何进程<br>停止shell中运行的任何进程。停止（stopping）进程，跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置<br>继续运行。在16.4节中，你会了解如何重启一个已经停止的进程。可以使用<code>ps -l</code>命令来显示各进程</li>
</ol>
<h3 id="16-1-3-捕获信号"><a href="#16-1-3-捕获信号" class="headerlink" title="16.1.3 捕获信号"></a>16.1.3 捕获信号</h3><p>trap命令允许你来指定shell<br>脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再<br>由shell处理，而是交由本地处理。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash 
# Testing signal trapping 
# 
trap &quot;echo &#39; Sorry! I have trapped Ctrl-C&#39;&quot; SIGINT 
# 
echo This is a test script 
# 
count&#x3D;1 
while [ $count -le 10 ] 
do 
 echo &quot;Loop #$count&quot; 
 sleep 1 
 count&#x3D;$[ $count + 1 ] 
done</code></pre>

<p>该脚本使用trap命令捕获信号，使我们编写的脚本处理信号而不是shell处理<br>当使用<code>ctrl-C</code>时候，我们脚本的trap命令就会处理这个SIGINT信号</p>
<h3 id="16-1-4-捕获脚本退出"><a href="#16-1-4-捕获脚本退出" class="headerlink" title="16.1.4 捕获脚本退出"></a>16.1.4 捕获脚本退出</h3><p>除了在shell脚本中捕获退出，你也可以在shell退出时就行捕获，这是shell完成任务时一种执行命令的一种方式，要捕获shell的退出只需要在trap命令后面加上<code>EXIT</code>信号就行.</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">
#!&#x2F;bin&#x2F;bash 
# Trapping the script exit 
# 
trap &quot;echo Goodbye...&quot; EXIT 
# 
count&#x3D;1 
while [ $count -le 5 ] 
do 
 echo &quot;Loop #$count&quot; 
 sleep 1 
 count&#x3D;$[ $count + 1 ] 
done 
#1. 脚本正常执行完，然后执行了trap脚本
#2. ctrl-c 命令也会触发退出命令,ctrl-c之后就不会执行剩余代码。</code></pre>

<h3 id="16-1-5-修改或移除捕获"><a href="#16-1-5-修改或移除捕获" class="headerlink" title="16.1.5 修改或移除捕获"></a>16.1.5 修改或移除捕获</h3><p>捕获或移除这节一句话概括就是设置trap命令的有效期，或者叫生命周期。也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上<br>两个破折号就行了，</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">
#!&#x2F;bin&#x2F;bash 
# Modifying a set trap 
# 
trap &quot;echo &#39; Sorry... Ctrl-C is trapped.&#39;&quot; SIGINT 
# 
count&#x3D;1 
while [ $count -le 5 ] 
do 
 echo &quot;Loop #$count&quot; 
 sleep 1 
 count&#x3D;$[ $count + 1 ] 
done 
# 
trap &quot;echo &#39; I modified the trap!&#39;&quot; SIGINT 
# 
count&#x3D;1 
while [ $count -le 5 ] 
do 
 echo &quot;Second Loop #$count&quot; 
 sleep 1 
 count&#x3D;$[ $count + 1 ] 
done
</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">$ .&#x2F;test3.sh
Loop #1 
Loop #2 
Loop #3 
^C Sorry... Ctrl-C is trapped. 
Loop #4 
Loop #5 
Second Loop #1 
Second Loop #2 
^C I modified the trap! 
Second Loop #3 
Second Loop #4 
Second Loop #5 
$
</code></pre>

<p>也可以在trap命令后使用单破折号来恢复信号的默认行为<br>移除信号捕获后，脚本按照默认行为来处理SIGINT信号，也就是终止脚本运行。但如果信<br>号是在捕获被移除前接收到的，那么脚本会按照原先trap命令中的设置进行处理。<br>在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，<br>脚本会照旧执行trap中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。<br>总结:<br>修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的trap命令进行处理。trap根绝接收到信号会<br>立刻从sleep中唤醒</p>
<h2 id="16-2-以后台模式运行脚本"><a href="#16-2-以后台模式运行脚本" class="headerlink" title="16.2 以后台模式运行脚本"></a>16.2 以后台模式运行脚本</h2><h3 id="16-2-1-后台运行脚本"><a href="#16-2-1-后台运行脚本" class="headerlink" title="16.2.1 后台运行脚本"></a>16.2.1 后台运行脚本</h3><p>当<code>&amp;</code>符放到命令后时，它会将命令和bash shell分离开来,然后给分配一个<code>调度号</code>和<code>PID号</code>,在后台模式中，<br>进程运行时不会和终端会话上的STDIN、STDOUT以及STDERR关联</p>
<h3 id="16-2-2-运行多个后台作业"><a href="#16-2-2-运行多个后台作业" class="headerlink" title="16.2.2 运行多个后台作业"></a>16.2.2 运行多个后台作业</h3><p>当我们同时运行多个后台运行程序的时候，然后使用<code>ps</code>命令这时候发现很多进程与<code>pts/0</code>绑定着，如果终端会话退出，那么后台进程也会随之退出</p>
<h3 id="16-2-3-在非控制台下运行程序"><a href="#16-2-3-在非控制台下运行程序" class="headerlink" title="16.2.3 在非控制台下运行程序"></a>16.2.3 在非控制台下运行程序</h3><p>有时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退<br>出了终端会话。这可以用<code>nohup</code>命令来实现.和普通后台进程一样，shell会给命令分配一个作业号，Linux系统会为其分配一个<code>PID号</code>。区<br>别在于，当你使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号。<br>由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。<br>为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为<br>nohup.out的文件中。<br>当多个命令同时使用nohup命令时候，且同时修改nohup命令的时候，他们会追加到nohup.out命令</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"># 命令demo
nohup .&#x2F;test1.sh &amp;</code></pre>
<h2 id="16-4-作业控制"><a href="#16-4-作业控制" class="headerlink" title="16.4 作业控制"></a>16.4 作业控制</h2><h3 id="16-4-1-查看作业"><a href="#16-4-1-查看作业" class="headerlink" title="16.4.1 查看作业"></a>16.4.1 查看作业</h3><p><code>jobs</code>命令可以查看分配给shell的作业，<code>jobs -l</code>可以查看完整的PID  </p>
<pre class="language-bash" data-language="bash"><code class="language-bash">参数  描述
-l    列出进程的PID以及作业号
-n    只列出上次shell发出的通知后改变了状态的作业
-p    只列出作业的PID 
-r    只列出运行中的作业
-s    只列出已停止的作业
#你可能注意到了jobs命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用
#作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。
#当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加
#号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。</code></pre>

<h3 id="16-4-2-重启停止的作业"><a href="#16-4-2-重启停止的作业" class="headerlink" title="16.4.2 重启停止的作业"></a>16.4.2 重启停止的作业</h3><p>在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你<br>当前工作的终端，所以在使用该功能时要小心了。<br>要以后台模式重启一个作业，可用bg命令加上作业号</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">
[1]+ Stopped .&#x2F;test11.sh 
$ bg # 这时候就重启了.&#x2F;test11.sh 作业，以后台模式
# 如果重启多个就是用bg 2
# 要以前台模式重启作业，可用带有作业号的fg命令。
</code></pre>

<h2 id="16-5-调整谦让度"><a href="#16-5-调整谦让度" class="headerlink" title="16.5 调整谦让度"></a>16.5 调整谦让度</h2><ol>
<li>在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调<br>度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统<br>中，由shell启动的所有进程的调度优先级默认都是相同的。  </li>
<li>调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell<br>以优先级0来启动所有进程。<br>最低值20是最高优先级，而最高值19是最低优先级，这太容易记混了。只要记住那句俗<br>语“好人难做”就行了。  </li>
<li>有时你想要改变一个shell脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他<br>进程过多的处理能力），还是给予它更高的优先级（这样它就能获得更多的处理时间），你都可以<br>通过nice命令做到。</li>
</ol>
<h3 id="16-5-1-nice-命令"><a href="#16-5-1-nice-命令" class="headerlink" title="16.5.1 nice 命令"></a>16.5.1 nice 命令</h3><p>nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice<br>的-n命令行来指定新的优先级级别。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">nice -n 10 .&#x2F;test4.sh &gt; test4.out &amp;  # 注意，必须将nice命令和要启动的命令放在同一行中。</code></pre>

<p>一旦用nice命令设置了优先级，就不可以用nice重新设置优先级</p>
<h3 id="16-5-2-renice-命令"><a href="#16-5-2-renice-命令" class="headerlink" title="16.5.2 renice 命令"></a>16.5.2 renice 命令</h3><p>有时你想改变系统上已运行命令的优先级。这正是renice命令可以做到的。它允许你指定<br>运行进程的PID来改变它的优先级。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">renice -n 10 -p 5055 # -p应该是指进程</code></pre>

<p>renice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一<br>些限制:  </p>
<ul>
<li>只能对属于你的进程执行renice；</li>
<li>只能通过renice降低进程的优先级；</li>
<li>root用户可以通过renice来任意调整进程的优先级。<br>如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令</li>
</ul>
<h2 id="16-6-定时运行作业"><a href="#16-6-定时运行作业" class="headerlink" title="16.6 定时运行作业"></a>16.6 定时运行作业</h2><h3 id="16-6-1-用at命令来计划执行作业"><a href="#16-6-1-用at命令来计划执行作业" class="headerlink" title="16.6.1 用at命令来计划执行作业"></a>16.6.1 用at命令来计划执行作业</h3><ol>
<li><p>at命令的格式<br> at命令只执行一次，区别于cron</p>
 <pre class="language-bash" data-language="bash"><code class="language-bash">at [-f filename] time # -f 后面用来指定读取命令</code></pre>

<p> time : 参数指定运行时间，如果错过就会在第二天同一时间再运行<br> time能识别多种时间格式</p>
<ul>
<li>标准小时和分钟的格式，比如10：15</li>
<li>AM&#x2F;PM指示符，比如10：15PM</li>
<li>特定可命名时间，比如now,noon,midnight,或者teatime(4 PM)</li>
<li>标准日期格式，比如MMDDYY,MM&#x2F;DD&#x2F;YY,DD.MM.YY</li>
<li>文本日期比如jul 4或Dec 25 加不加年份都可以。</li>
<li>你也可以指定增量时间<ul>
<li>当前时间+25 min</li>
<li>明天10：15 PM</li>
<li>10：15+7天<br> 通过<code>at</code>命令都会被提交到作业队列，针对不同的优先级存在26种不同的作业队列，使用<br> a-z和A-Z来指代，即使通过at命令提交过作业，也可以通过-q参数指定不同的队列字母<br> 作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的<br> 作业会被提交到a作业队列</li>
</ul>
</li>
</ul>
</li>
<li><p>获取作业的输出<br>at命令利用sendemail应用程序发送邮件，这样其实很麻烦，但是可以将输出重定向到STDOUT<br>和STDERR,再如果可以使用<code>-M</code>屏蔽输出</p>
</li>
<li><p>列出等待的作业<br>atq命令可以查看系统中哪些作业处于等待状态</p>
</li>
<li><p>删除作业<br>atrm删除等待种的作业</p>
</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash">#demo
atq 命令可以列出作业编号
atrm 作业编号 # 只能删除你提交的作业，不能删除其他人的。</code></pre>

<h3 id="16-6-2-安排需要定期执行的脚本"><a href="#16-6-2-安排需要定期执行的脚本" class="headerlink" title="16.6.2 安排需要定期执行的脚本"></a>16.6.2 安排需要定期执行的脚本</h3><ol>
<li><p>cron时间表</p>
 <pre class="language-bash" data-language="bash"><code class="language-bash">min hour dayofmonth month dayofweek command</code></pre>

<p> 比如你想每天10：15运行一个命令可以使用cron时间表条目</p>
 <pre class="language-bash" data-language="bash"><code class="language-bash">min hour dayofmonth  month dayofweek  command
15  10   *           *     *          command</code></pre>

<p> 但是如果想在每周一的下午4点15分执行，可写为</p>
 <pre class="language-bash" data-language="bash"><code class="language-bash">15 16 * * 1 command</code></pre>

<p> 可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）<br> 或数值（0为周日，6为周六）,dayofmonth表项指定月份中的日期值（1~31）。</p>
<p> 聪明的读者可能会问如何设置一个在每个月的最后一天执行的命令，因为你无法设置<br> dayofmonth的值来涵盖所有的月份。这个问题困扰着Linux和Unix程序员，也激发了不少解<br> 决办法。常用的方法是加一条使用date命令的if-then语句来检查明天的日期是不是01：</p>
 <pre class="language-bash" data-language="bash"><code class="language-bash">00 12 * * * if [ &#96;date +%d -d tomorrow&#96; &#x3D; 01 ] ; then ; command</code></pre>

<p> 它会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。</p>
<p> 命令必须要指定要运行的脚本名字，或者添加重定向符号<br> cron程序会用提交作业的用户账户运行该脚本。因此，你必须有访问该命令和命令中指定的<br> 输出文件的权限。</p>
</li>
<li><p>构建cron时间表<br>可以使用crontab -l来处理cron时间表<br>默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。<br>在添加条目时，crontab命令会启用一个文本编辑器（参见第10章），使用已有的cron时间表作<br>为文件内容（或者是一个空文件，如果时间表不存在的话）。</p>
</li>
<li><p>浏览cron目录</p>
<p> 如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个<br> 基本目录：hourly、daily、monthly和weekly。</p>
<ul>
<li>&#x2F;etc&#x2F;cron.daily</li>
<li>&#x2F;etc&#x2F;cron.hourly</li>
<li>&#x2F;etc&#x2F;cron.monthly</li>
<li>&#x2F;etc&#x2F;cron.weekly<br> 因此，如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它</li>
</ul>
</li>
<li><p>anacron程序<br>如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么<br>这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问<br>题，许多Linux发行版还包含了anacron程序。<br>anacron<br>程序只会处理位于cron目录的程序，比如&#x2F;etc&#x2F;cron.monthly。它用时间戳来决定作业<br>是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于&#x2F;var&#x2F;spool&#x2F;anacron。</p>
</li>
</ol>
<pre class="language-bash" data-language="bash"><code class="language-bash">sudo cat &#x2F;var&#x2F;spool&#x2F;anacron&#x2F;cron.monthly
20150626</code></pre>

<p>anacron程序使用自己的时间表（通常位于&#x2F;etc&#x2F;anacrontab）来检查作业目录。<br>anacron时间表的基本格式和cron时间表略有不同：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">period delay identifier command</code></pre>

<p>period条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间<br>戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。<br>command条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的<br>任何脚本。<br>注意，anacron不会运行位于&#x2F;etc&#x2F;cron.hourly的脚本。这是因为anacron程序不会处理执行时间<br>需求小于一天的脚本。<br>identifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误<br>邮件中的作业。</p>
<h3 id="16-6-3-使用新shell启动脚本"><a href="#16-6-3-使用新shell启动脚本" class="headerlink" title="16.6.3 使用新shell启动脚本"></a>16.6.3 使用新shell启动脚本</h3><p>.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是<br>当你登入bash shell时，另一次是当你启动一个bash shell时。如果你需要一个脚本在两个时刻都得<br>以运行，可以把这个脚本放进该文件中。</p>
<h1 id="17-创建函数"><a href="#17-创建函数" class="headerlink" title="17. 创建函数"></a>17. 创建函数</h1><h2 id="17-1-基本的脚本函数"><a href="#17-1-基本的脚本函数" class="headerlink" title="17.1 基本的脚本函数"></a>17.1 基本的脚本函数</h2><h3 id="17-1-1-创建函数"><a href="#17-1-1-创建函数" class="headerlink" title="17.1.1 创建函数"></a>17.1.1 创建函数</h3><p>有两种方式定义函数  </p>
<pre class="language-bash" data-language="bash"><code class="language-bash">function name()&#123;
command;
&#125;</code></pre>

<p>另一种更像是高级编程语言定义函数  </p>
<pre class="language-bash" data-language="bash"><code class="language-bash">name()&#123;
command;
&#125;</code></pre>

<h3 id="17-1-2-使用函数"><a href="#17-1-2-使用函数" class="headerlink" title="17.1.2 使用函数"></a>17.1.2 使用函数</h3><p>正常情况就像是其他高级语言一样，但是bash的函数有个特殊情况。如果是重定义了一个旧函数，<br>那么就会覆盖以前的定义,正如下面的例子</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# testing using a duplicate function name 
function func1 &#123; 
echo &quot;This is the first definition of the function name&quot; 
&#125; 
func1 
function func1 &#123; 
 echo &quot;This is a repeat of the same function name&quot; 
&#125; 
func1 
echo &quot;This is the end of the script&quot;
</code></pre>

<h2 id="17-2-返回值"><a href="#17-2-返回值" class="headerlink" title="17.2 返回值"></a>17.2 返回值</h2><h3 id="17-2-1-默认退出状态码"><a href="#17-2-1-默认退出状态码" class="headerlink" title="17.2.1 默认退出状态码"></a>17.2.1 默认退出状态码</h3><p>即使是在函数中，command1,command2,command3 中的1，2执行错误，3成功了，那么退出<br>状态码也是0.所以说默认退出状态码是很危险的。</p>
<h3 id="17-2-2-使用return命令"><a href="#17-2-2-使用return命令" class="headerlink" title="17.2.2 使用return命令"></a>17.2.2 使用return命令</h3><p>return的demo如下</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# using the return command in a function 
function dbl &#123; 
 read -p &quot;Enter a value: &quot; value 
 echo &quot;doubling the value&quot; 
 return $[ $value * 2 ] 
&#125; 
dbl 
echo &quot;The new value is $?&quot;
</code></pre>

<p>dbl函数会将$value的值翻倍，然后返回，有两点要小心</p>
<ul>
<li>记住，函数一结束就取返回值</li>
<li>记住，退出码必须是0~255</li>
</ul>
<p>也可以返回字符串和较大的数值，可以看下一节</p>
<h3 id="17-2-3-使用函数输出"><a href="#17-2-3-使用函数输出" class="headerlink" title="17.2.3 使用函数输出"></a>17.2.3 使用函数输出</h3><pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# using the echo to return a value 
function dbl &#123; 
 read -p &quot;Enter a value: &quot; value 
 echo $[ $value * 2 ] 
&#125; 
result&#x3D;$(dbl) 
echo &quot;The new value is $result&quot;

#$ .&#x2F;test5b
#Enter a value: 200 
#The new value is 400</code></pre>

<p>可以看到是将一函数结果执行取值运算得到返回值。<br>通过这种技术，你还可以返回浮点值和字符串值。这使它成为一种获取函数返回值的强<br>大方法。</p>
<h2 id="17-3-在函数中使用变量"><a href="#17-3-在函数中使用变量" class="headerlink" title="17.3 在函数中使用变量"></a>17.3 在函数中使用变量</h2><h3 id="17-3-1-向函数传递参数"><a href="#17-3-1-向函数传递参数" class="headerlink" title="17.3.1 向函数传递参数"></a>17.3.1 向函数传递参数</h3><p>错误传递参数代码</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash 
# trying to access script parameters inside a function 
function badfunc1 &#123; 
 echo $[ $1 * $2 ] 
&#125; 
if [ $# -eq 2 ] 
then 
 value&#x3D;$(badfunc1) 
 echo &quot;The result is $value&quot; 
else 
 echo &quot;Usage: badtest1 a b&quot; 
fi 
# $ .&#x2F;badtest1
# Usage: badtest1 a b 
# $ .&#x2F;badtest1 10 15 
# .&#x2F;badtest1: * : syntax error: operand expected (error token is &quot;* 
# &quot;) 
# The result is 
# 脚本的$1和$2和函数调用的$1,$2变量是不一样的</code></pre>

<p>接下来是正确的代码</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash 
# trying to access script parameters inside a function 
function func7 &#123; 
 echo $[ $1 * $2 ] 
&#125; 
if [ $# -eq 2 ] 
then 
 value&#x3D;$(func7 $1 $2) 
 echo &quot;The result is $value&quot; 
else 
 echo &quot;Usage: badtest1 a b&quot; 
fi 
#$ 
#$ .&#x2F;test7 
#Usage: badtest1 a b 
#$ .&#x2F;test7 10 15 
#The result is 150 
</code></pre>

<p>通过将$1和$2变量传给函数，它们就能跟其他变量一样供函数使用了</p>
<h3 id="17-3-2-在函数中处理变量"><a href="#17-3-2-在函数中处理变量" class="headerlink" title="17.3.2 在函数中处理变量"></a>17.3.2 在函数中处理变量</h3><ul>
<li>全局变量<br>全局变量被覆盖</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash 
# demonstrating a bad use of variables 
function func1 &#123; 
 temp&#x3D;$[ $value + 5 ] 
 result&#x3D;$[ $temp * 2 ] 
&#125; 
temp&#x3D;4 
value&#x3D;6 
func1 
echo &quot;The result is $result&quot; 
if [ $temp -gt $value ] 
then 
 echo &quot;temp is larger&quot; 
else 
 echo &quot;temp is smaller&quot; 
fi 

#$ .&#x2F;badtest2
#The result is 22 
#temp is larger 
# 说明TEMP变量受到了影响，读和写都是改变的全局变量</code></pre>

<ul>
<li>局部变量<br>local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，<br>那么shell将会保持这两个变量的值是分离的</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# demonstrating the local keyword 
function func1 &#123; 
 local temp&#x3D;$[ $value + 5 ] 
 result&#x3D;$[ $temp * 2 ] 
&#125; 
temp&#x3D;4 
value&#x3D;6 
func1 
echo &quot;The result is $result&quot; 
if [ $temp -gt $value ] 
then 
 echo &quot;temp is larger&quot; 
else 
 echo &quot;temp is smaller&quot; 
fi 
#$ .&#x2F;test9
#The result is 22 
#temp is smaller </code></pre>

<p>if里面的$temp参数是全局的，因为已经在函数外</p>
<h2 id="17-4-数组变量和函数"><a href="#17-4-数组变量和函数" class="headerlink" title="17.4 数组变量和函数"></a>17.4 数组变量和函数</h2><p>直接传入只会传入数组的第一个值，可考虑如下方法</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash 
# array variable to function test 
function testit &#123; 
 local newarray 
 newarray&#x3D;(;&#39;echo &quot;$@&quot;&#39;) 
 echo &quot;The new array value is: $&#123;newarray[*]&#125;&quot; 
&#125; 
myarray&#x3D;(1 2 3 4 5) 
echo &quot;The original array is $&#123;myarray[*]&#125;&quot; 
testit $&#123;myarray[*]&#125; 
#$ 
#$ .&#x2F;test10 
#The original array is 1 2 3 4 5 
#The new array value is: 1 2 3 4 5 
</code></pre>
<p>第二种也可以</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# adding values in an array 
function addarray &#123; 
 local sum&#x3D;0 
 local newarray 
 newarray&#x3D;($(echo &quot;$@&quot;)) 
 for value in $&#123;newarray[*]&#125; 
 do 
      sum&#x3D;$[ $sum + $value ] 
 done
 echo $sum 
&#125;
myarray&#x3D;(1 2 3 4 5)
echo &quot;The original array is: $&#123;myarray[*]&#125;&quot; 
arg1&#x3D;$(echo $&#123;myarray[*]&#125;) 
result&#x3D;$(addarray $arg1) 
echo &quot;The result is $result&quot; 

#$ .&#x2F;test11 
#The original array is: 1 2 3 4 5 
#The result is 15 </code></pre>

<h3 id="17-4-2-从函数中返回数组"><a href="#17-4-2-从函数中返回数组" class="headerlink" title="17.4.2 从函数中返回数组"></a>17.4.2 从函数中返回数组</h3><pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# returning an array value 
function arraydblr &#123; 
 local origarray 
 local newarray 
 local elements 
 local i 
 origarray&#x3D;($(echo &quot;$@&quot;)) 
 newarray&#x3D;($(echo &quot;$@&quot;)) 
 elements&#x3D;$[ $# - 1 ] 
 for (( i &#x3D; 0; i &lt;&#x3D; $elements; i++ )) 
 &#123; 
 newarray[$i]&#x3D;$[ $&#123;origarray[$i]&#125; * 2 ] 
 &#125; 
 echo $&#123;newarray[*]&#125; 
&#125; 
myarray&#x3D;(1 2 3 4 5) 
echo &quot;The original array is: $&#123;myarray[*]&#125;&quot; 
arg1&#x3D;$(echo $&#123;myarray[*]&#125;) 
result&#x3D;($(arraydblr $arg1)) 
echo &quot;The new array is: $&#123;result[*]&#125;&quot; 
</code></pre>
<p>arraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来<br>重新生成一个新的数组变量。</p>
<h2 id="17-5-函数递归"><a href="#17-5-函数递归" class="headerlink" title="17.5 函数递归"></a>17.5 函数递归</h2><pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# using recursion 
function factorial &#123; 
 if [ $1 -eq 1 ] 
 then 
 echo 1 
 else 
 local temp&#x3D;$[ $1 - 1 ] 
 local result&#x3D;$(factorial $temp) 
 echo $[ $result * $1 ] 
fi 
&#125;
read -p &quot;Enter value: &quot; value 
result&#x3D;$(factorial $value) 
echo &quot;The factorial of $value is: $result&quot; 

#$ .&#x2F;test13
#Enter value: 5 
#The factorial of 5 is: 120 
</code></pre>

<h2 id="17-6-创建库"><a href="#17-6-创建库" class="headerlink" title="17.6 创建库"></a>17.6 创建库</h2><p>问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash
# using a library file the wrong way 
.&#x2F;myfuncs 
result&#x3D;$(addem 10 15) 
echo &quot;The result is $result&quot;

$ .&#x2F;badtest4 
.&#x2F;badtest4: addem: command not found 
The result is </code></pre>

<p>使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是<br>创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p>
<h2 id="17-7-在命令行上使用函数"><a href="#17-7-在命令行上使用函数" class="headerlink" title="17.7 在命令行上使用函数"></a>17.7 在命令行上使用函数</h2><p>和在shell脚本中将脚本函数当命令使用一样，在命令行界面中你也可以这样做。这个功能很，不错，因为一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数。有几种方法可以实现。</p>
<h3 id="17-7-1-在命令上创建函数"><a href="#17-7-1-在命令上创建函数" class="headerlink" title="17.7.1 在命令上创建函数"></a>17.7.1 在命令上创建函数</h3><ul>
<li><p>简单点直接定义 <code>function divem &#123; echo $[ $1 / $2 ]; &#125; </code></p>
</li>
<li><p>另一种采用多行式</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ function multem &#123; 
&gt; echo $[ $1 * $2 ] 
&gt; &#125; 
$ multem 2 5 </code></pre></li>
</ul>
<h3 id="17-7-2-在-bashrc-文件中定义函数"><a href="#17-7-2-在-bashrc-文件中定义函数" class="headerlink" title="17.7.2 在.bashrc 文件中定义函数"></a>17.7.2 在.bashrc 文件中定义函数</h3><ol>
<li><p>直接定义函数</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cat .bashrc
# .bashrc 
# Source global definitions 
if [ -r &#x2F;etc&#x2F;bashrc ]; then 
. &#x2F;etc&#x2F;bashrc 
fi 
function addem &#123; 
echo $[ $1 + $2 ] 
&#125; </code></pre>
</li>
<li><p>读取函数文件<br>直接定义在特地的文件内，然后读取在<code>.bashrc</code>中读取</p>
</li>
</ol>
<h2 id="17-8-实例"><a href="#17-8-实例" class="headerlink" title="17.8 实例"></a>17.8 实例</h2><h3 id="17-8-1-下载安装第三方库"><a href="#17-8-1-下载安装第三方库" class="headerlink" title="17.8.1 下载安装第三方库"></a>17.8.1 下载安装第三方库</h3><h3 id="17-8-2-构建库"><a href="#17-8-2-构建库" class="headerlink" title="17.8.2 构建库"></a>17.8.2 构建库</h3><p>下载，编译，安装。这里面涉及到<code>CMAKE</code>的相关知识</p>
<h3 id="17-8-3-shtool库函数"><a href="#17-8-3-shtool库函数" class="headerlink" title="17.8.3 shtool库函数"></a>17.8.3 shtool库函数</h3><p>这里就是介绍些shtool提供的一些函数，后面会很有用，但是需要与公司内的环境做适配</p>
<h3 id="17-8-4-使用库"><a href="#17-8-4-使用库" class="headerlink" title="17.8.4 使用库"></a>17.8.4 使用库</h3><p>编译，安装完后，就可以在脚本中使用了</p>
<h1 id="18-图形化界面中脚本编程"><a href="#18-图形化界面中脚本编程" class="headerlink" title="18. 图形化界面中脚本编程"></a>18. 图形化界面中脚本编程</h1><p>暂时不需要</p>
<h1 id="19-初识sed和gawk"><a href="#19-初识sed和gawk" class="headerlink" title="19.初识sed和gawk"></a>19.初识sed和gawk</h1><p>你得熟悉Linux中的sed和gawk工具。这两个工具能够极大简化需要进行的数据处<br>理任务。</p>
<h2 id="19-1-文本处理"><a href="#19-1-文本处理" class="headerlink" title="19.1 文本处理"></a>19.1 文本处理</h2><h3 id="19-1-1-sed编辑器"><a href="#19-1-1-sed编辑器" class="headerlink" title="19.1.1 sed编辑器"></a>19.1.1 sed编辑器</h3><p>sed编辑器被称作流编辑器（stream editor），和普通的交互式文本编辑器恰好相反。在交互式<br>文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。流编<br>辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。</p>
<ul>
<li>一次输入一行</li>
<li>根据所提供的编辑器命令匹配数据。</li>
<li>按照命令修改流中数据</li>
<li>将最后结果输出到STDOUT</li>
</ul>
<blockquote>
<p>sed  options  script  file</p>
</blockquote>
<pre class="language-bash" data-language="bash"><code class="language-bash">echo &#39;this is a test&#39; | sed  &#39;s&#x2F;test&#x2F;big test&#x2F;&#39;  使用s命令将test替换为big test
sed &#39;s&#x2F;dog&#x2F;cat&#x2F;&#39;  data.txt    这是修改文件中dog为cat
sed  -e  &#39;s&#x2F;brown&#x2F;red;  s&#x2F;blue&#x2F;yellow&#x2F;&#39;   data&#x2F;txt</code></pre>

<ol>
<li>在命令行定义编辑器命令</li>
</ol>
  <pre class="language-bash" data-language="bash"><code class="language-bash">echo &quot;This is a test&quot; | sed &#39;s&#x2F;test&#x2F;big test&#x2F;&#39;</code></pre>

<p>  这里使用了<code>sed</code>的s命令，是指替换字符串，符合replace A B,用B替换A.重要的是，要记住，<br>  sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT。如果你查看原来<br>  的文本文件，它仍然保留着原始数据。<br>2. 在命令行使用多个编辑器命令</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">sed -e &#39;s&#x2F;brown&#x2F;green&#x2F;; s&#x2F;dog&#x2F;cat&#x2F;&#39; data1.txt </code></pre>

<p>  这种情况一定要加分号,也可以使用</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">$ sed -e &#39;
&gt; s&#x2F;brown&#x2F;green&#x2F; 
&gt; s&#x2F;fox&#x2F;elephant&#x2F; 
&gt; s&#x2F;dog&#x2F;cat&#x2F;&#39; data1.txt 
</code></pre>

<p>  必须记住，要在封尾<strong>单引号</strong>所在行结束命令。bash shell一旦发现了封尾的单引号，就会执行<br>  命令。开始后，sed命令就会将你指定的每条命令应用到文本文件中的每一行上。</p>
<ol start="3">
<li>从文件中读取编辑器命令</li>
</ol>
  <pre class="language-bash" data-language="bash"><code class="language-bash">sed -f script.sed  data.txt
# 命令文件
$ cat script1.sed
s&#x2F;brown&#x2F;green&#x2F;
s&#x2F;fox&#x2F;elephant&#x2F; 
s&#x2F;dog&#x2F;cat&#x2F;</code></pre>

<h3 id="19-1-2-gawk程序"><a href="#19-1-2-gawk程序" class="headerlink" title="19.1.2 gawk程序"></a>19.1.2 gawk程序</h3><p>虽然<code>sed</code>很好，很强大，但是还是有局限性，通常你需要一个用来处理文件中的数据的更高级工具，<br>它能提供一个类编程环境来修改和重新组织文件中的数据。这正是<code>gawk</code>能够做到的。<br>提供了一种编程语言而不只是编辑器命令。在gawk编程语言中，你可以做下面的事情：</p>
<ul>
<li>定义变量来保存数据；</li>
<li>使用算术和字符串操作符来处理数据；</li>
<li>使用结构化编程概念（比如if-then语句和循环）来为数据处理增加处理逻辑；</li>
<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。</li>
</ul>
<ol>
<li><p>基本格式</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">gawk options program file</code></pre>
<p>  可用选项</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">-F fs  指定行中划分数据字段的字段分隔符
-f file  从指定的文件中读取程序
-v var&#x3D;value  定义gawk程序中的一个变量及其默认值
-mf N  指定要处理的数据文件中的最大字段数
-mr N  指定数据文件中的最大数据行数
-W keyword  指定gawk的兼容模式或警告等级</code></pre>
</li>
<li><p>从命令行读取程序脚本<br>  <code>gawk &#39;&#123;print &quot;Hello World!&quot;&#125;&#39;</code> ，可能让你失望了，什么都没有，gawk需要从STDIN读取数据，所以你输入任何字符都会返回hello world,<br>  Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk</p>
</li>
<li><p>使用数据字段变量<br>  gawk会将如下变量分配给它在文本行中发现的数据字段：<br>  $0代表整个文本行；<br>  $1代表文本行中的第1个数据字段；<br>  $2代表文本行中的第2个数据字段；<br>  $n代表文本行中的第n个数据字段。<br>  自动为文件每一行数据分配一个变量gawk ‘{print $1}’ data2.txt 数据文件中每一行的第一个字符<br>  <code>gawk -F: &#39;&#123;print $1&#125;&#39; /etc/passwd</code></p>
</li>
<li><p>在程序脚本中使用多个命令<br>  <code>&quot;my name is rich&quot; | gawk &#39;&#123;$4=&quot;Christine&quot;; print $0&#125;&#39;</code> , 给第四个字段名赋值，并输出文本名 ，<br>  注意， gawk程序在输出中已经将原文本中的第四个数据字段替换成了新值。如果不指定文件名就会从标准输入等待输入<br>  也可以多行</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">$ gawk &#39;&#123;
&gt; $4&#x3D;&quot;Christine&quot; 
&gt; print $0&#125;&#39; 
$My name is Rich 
$My name is Christine</code></pre>
</li>
<li><p>从文件中读取程序</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">gawk -F:  -f  script2.gawk  &#x2F;etc&#x2F;passwd
cat script2.gawk
&#123;print $1 &quot;&#39;s home directory is &quot; $6&#125;</code></pre></li>
</ol>
<p>  script2.gawk程序脚本会再次使用print命令打印&#x2F;etc&#x2F;passwd文件的主目录数据字段（字段变<br>  量$6），以及userid数据字段（字段变量$1）。</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">$ cat   script3

&#123;
text &#x3D; &quot;&#39;s home directory is &quot;
print $1 text $6 
&#125;</code></pre>

<p>  script3.gawk程序脚本定义了一个变量(text)来保存print命令中用到的文本字符串。注意，gawk<br>  程序在引用变量值时并未像shell脚本一样使用美元</p>
<ol start="6">
<li>在处理数据前运行脚本<br>  awk允许在执行脚本文件之前先执行某段特定程序<code>BEGIN</code>实现了这个功能</li>
</ol>
  <pre class="language-bash" data-language="bash"><code class="language-bash">gawk &#39;BEGIN &#123;print &quot;Hello World!&quot;&#125;&#39;</code></pre>
<p>  但是执行这行命令就会立刻退出,如果想正常的程序脚本中处理数据，必须使用另一个脚本区域来定义程序</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">gawk &#39;BEGIN &#123;print &quot;The data3 File Contents:&quot;&#125;
&gt; &#123;print $0&#125;&#39; data3.txt </code></pre>
<p>  在gawk执行了BEGIN脚本后，它会用第二段脚本来处理文件数据。这么做时要小心，两段<br>  脚本仍然被认为是gawk命令行中的一个文本字符串。你需要相应地加上单引号</p>
<ol start="7">
<li>处理数据后运行脚本<br>  会在最后执行的一段程序代码</li>
</ol>
  <pre class="language-bash" data-language="bash"><code class="language-bash">cat script4.gawk
BEGIN &#123;
print &quot;The latest list of users and shells&quot; 
print &quot; UserID \t Shell&quot; 
print &quot;-------- \t -------&quot; 
FS&#x3D;&quot;:&quot; 
&#125; 
&#123; 
print $1 &quot; \t &quot; $7 
&#125; 
END &#123; 
print &quot;This concludes the listing&quot; 
&#125; </code></pre>

<h2 id="19-2-sed-编辑器基础"><a href="#19-2-sed-编辑器基础" class="headerlink" title="19.2 sed 编辑器基础"></a>19.2 sed 编辑器基础</h2><h3 id="19-2-1-更多的替换选项"><a href="#19-2-1-更多的替换选项" class="headerlink" title="19.2.1 更多的替换选项"></a>19.2.1 更多的替换选项</h3><ol>
<li>替换标记<blockquote>
<p>s&#x2F;pattern&#x2F;replacement&#x2F;flags<br>  一句话概括就是自定义替换范围，具体详情参考下面list</p>
</blockquote>
</li>
</ol>
<ul>
<li>数字， 说明新文本将替换第几处的位置</li>
<li>g，说明文本将替换所有</li>
<li>p, 输出被替换命令修改过的行</li>
<li>w file ， 将结果输出到新文件中<code>sed &#39;s/test/trial/w test.txt&#39; data5.txt </code> 输出结果会打印到test.txt文件</li>
<li>option 位置是 n 说明禁止输出</li>
</ul>
<ol start="2">
<li>替换字符<br>  在替换文件路径时候涉及到<code>转义字符</code>这样很影响阅读性  <pre class="language-bash" data-language="bash"><code class="language-bash">sed &#39;s&#x2F;\&#x2F;bin\&#x2F;bash&#x2F;\&#x2F;bin\&#x2F;csh&#x2F;&#39; &#x2F;etc&#x2F;passwd</code></pre>
  上面命令太难看，可以选择下面的方式  <pre class="language-bash" data-language="bash"><code class="language-bash">sed &#39;s!&#x2F;bin&#x2F;bash!&#x2F;bin&#x2F;csh!&#39; &#x2F;etc&#x2F;passwd </code></pre></li>
</ol>
<h3 id="19-2-2-使用地址"><a href="#19-2-2-使用地址" class="headerlink" title="19.2.2 使用地址"></a>19.2.2 使用地址</h3><p>  sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用<br>  于特定行或某些行，则必须用行寻址（line addressing).<br>  在sed编辑器中有两种形式的行寻址：</p>
<ul>
<li>以数字形式表示行区间</li>
<li>用文本模式来过滤出行</li>
</ul>
<ol>
<li>数字方式的行寻址<br>sed编辑器会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号。<pre class="language-bash" data-language="bash"><code class="language-bash">$ sed &#39;2s&#x2F;dog&#x2F;cat&#x2F;&#39; data1.txt
The quick brown fox jumps over the lazy dog 
The quick brown fox jumps over the lazy cat 
The quick brown fox jumps over the lazy dog 
The quick brown fox jumps over the lazy dog </code></pre>
如果想修改2，3行可使用<pre class="language-bash" data-language="bash"><code class="language-bash">sed &#39;2,3s&#x2F;dog&#x2F;cat&#x2F;&#39; data1.txt </code></pre>
如果想将命令作用到文本中从某行开始到结尾，可以用特殊地址——美元符<pre class="language-bash" data-language="bash"><code class="language-bash">sed &#39;2,$s&#x2F;dog&#x2F;cat&#x2F;&#39; data1.txt
The quick brown fox jumps over the lazy dog 
The quick brown fox jumps over the lazy cat 
The quick brown fox jumps over the lazy cat 
The quick brown fox jumps over the lazy cat</code></pre></li>
<li>使用文本模式过滤器<br>sed编辑器允许指定文本模式来过滤出命令要作用的行。必须用正斜线将要指定的pattern封起来。<br>sed编辑器会将该命令作用到包含指定文本模式的行上。<br>说白了就是支持正则表达式来匹配字符串<pre class="language-bash" data-language="bash"><code class="language-bash">sed &#39;&#x2F;Samantha&#x2F;s&#x2F;bash&#x2F;csh&#x2F;&#39; &#x2F;etc&#x2F;passwd </code></pre></li>
<li>命令组合<br>  如果需要在单行上执行多条命令，可以用花括号将多条命令组合在一起。sed编辑器会处理地址行处列出的每条命令。  <pre class="language-bash" data-language="bash"><code class="language-bash">sed &#39;3,$&#123;
&gt; s&#x2F;brown&#x2F;green&#x2F; 
&gt; s&#x2F;lazy&#x2F;active&#x2F; 
&gt; &#125;&#39; data1.txt </code></pre></li>
</ol>
<h3 id="19-2-3-删除行"><a href="#19-2-3-删除行" class="headerlink" title="19.2.3 删除行"></a>19.2.3 删除行</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">sed &#39;d&#39; data1.txt  # 删除整个data1文件内容
sed &#39;3d&#39; data6.txt  # 删除data6文件地三行
sed &#39;3,$d&#39; data6.txt  # 删除data6文件第三行及后面的行
sed &#39;&#x2F;number 1&#x2F;d&#39; data6.txt  # 删除第一行
sed &#39;&#x2F;1&#x2F;,&#x2F;3&#x2F;d&#39; data6.txt  #也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed编辑器会删除两个指定行之间的所有行（包括指定的行）。
$ cat data7.txt 
This is line number 1. 
This is line number 2. 
This is line number 3. 
This is line number 4. 
This is line number 1 again. 
This is text you want to keep. 
This is the last line in the file. 
$ 
$ sed &#39;&#x2F;1&#x2F;,&#x2F;3&#x2F;d&#39; data7.txt  # 这个命令只会匹配数字的模式串
This is line number 4. </code></pre>
<p>  第二个出现数字“1”的行再次触发了删除命令，因为没有找到停止模式，所以就将数据流<br>  中的剩余行全部删除了。当然，如果你指定了一个从未在文本中出现的停止模式，显然会出现另<br>  外一个问题。</p>
<h3 id="19-2-4-插入和附加文本"><a href="#19-2-4-插入和附加文本" class="headerlink" title="19.2.4 插入和附加文本"></a>19.2.4 插入和附加文本</h3><ul>
<li>插入</li>
<li>附加<br>new line中的文本将会出现在sed编辑器输出中你指定的位置。记住，当使用插入命令时，<br>文本会出现在数据流文本的前面.<pre class="language-bash" data-language="bash"><code class="language-bash">$ echo &quot;Test Line 2&quot; | sed &#39;i\Test Line 1&#39; </code></pre>
当使用附加命令时，文本会出现在数据流文本的后面。<pre class="language-bash" data-language="bash"><code class="language-bash">$ echo &quot;Test Line 2&quot; | sed &#39;a\Test Line 1&#39; 
$ sed &#39;3i\ 
&gt; This is an inserted line.&#39; data6.txt  # 指定插入的位置
$ sed &#39;3a\
&gt; This is an appended line.&#39; data6.txt # 指定append的位置
sed &#39;$a\
&gt; This is a new line of text.&#39; data6.txt  # append到最后一行
$ sed &#39;1i\
&gt; This is one line of new text.\ 
&gt; This is another line of new text.&#39; data6.txt  # 要插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后一行。</code></pre></li>
</ul>
<h3 id="19-2-5-修改行"><a href="#19-2-5-修改行" class="headerlink" title="19.2.5 修改行"></a>19.2.5 修改行</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">$ sed &#39;3c\
&gt; This is a changed line of text.&#39; data6.txt 
$ sed &#39;&#x2F;number 3&#x2F;c\
&gt; This is a changed line of text.&#39; data6.txt </code></pre>
<p>  文本模式修改命令会修改它匹配的数据流中的任意文本行。<br>  <pre class="language-bash" data-language="bash"><code class="language-bash">$ sed &#39;&#x2F;number 1&#x2F;c\ 
&gt; This is a changed line of text.&#39; data8.txt # 正则表达式
sed &#39;2,3c\
&gt; This is a new line of text.&#39; data6.txt  # 用一行覆盖了2，3行</code></pre></p>
<h3 id="19-2-6-转换命令"><a href="#19-2-6-转换命令" class="headerlink" title="19.2.6 转换命令"></a>19.2.6 转换命令</h3>  <pre class="language-bash" data-language="bash"><code class="language-bash">[address]y&#x2F;inchars&#x2F;outchars&#x2F; </code></pre>
<p>  如你在输出中看到的，inchars模式中指定字符的每个实例都会被替换成outchars模式中<br>  相同位置的那个字符。<br>  转换命令是一个全局命令，也就是说，它会文本行中找到的所有指定字符自动进行转换，而<br>  不会考虑它们出现的位置。<br>  <pre class="language-bash" data-language="bash"><code class="language-bash">$ echo &quot;This 1 is a test of 1 try.&quot; | sed &#39;y&#x2F;123&#x2F;456&#x2F;&#39;</code></pre></p>
<h3 id="19-2-7-回顾打印"><a href="#19-2-7-回顾打印" class="headerlink" title="19.2.7 回顾打印"></a>19.2.7 回顾打印</h3><ul>
<li>p命令用来打印文本行；</li>
<li>等号（&#x3D;）命令用来打印行号；</li>
<li>l（小写的L）命令用来列出行。</li>
</ul>
<ol>
<li>打印行<pre class="language-bash" data-language="bash"><code class="language-bash">$ echo &quot;this is a test&quot; | sed &#39;p&#39; # 打印原行
this is a test 
this is a test
$ sed -n &#39;&#x2F;number 3&#x2F;p&#39; data6.txt # 打印匹配行
This is line number 3. 
$ sed -n &#39;2,3p&#39; data6.txt  # 取范围
$ sed -n &#39;&#x2F;3&#x2F;&#123;  # 这个3是模式匹配
&gt; p 
&gt; s&#x2F;line&#x2F;test&#x2F;p 
&gt; &#125;&#39; data6.txt </code></pre>
在命令行上用-n选项，你可以禁止输出其他行，只打印匹配文本模式的行。</li>
<li>打印行号  <pre class="language-bash" data-language="bash"><code class="language-bash">$ sed &#39;&#x3D;&#39; data1.txt  
$ sed -n &#39;&#x2F;number 4&#x2F;&#123;
&gt; &#x3D; 
&gt; p 
&gt; &#125;&#39; data6.txt  # 模式匹配第四行，然后打印修改前数据</code></pre></li>
<li>列出行<pre class="language-bash" data-language="bash"><code class="language-bash">$ sed -n &#39;l&#39; data9.txt  # 可以打印出特殊字符，甚至是制表符
$ cat data10.txt
This line contains an escape character. 
$ 
$ sed -n &#39;l&#39; data10.txt 
This line contains an escape character. \a$ 
$ </code></pre>
 data10.txt文本文件包含了一个转义控制码来产生铃声。当用cat命令来显示文本文件时，你<br> 看不到转义控制码，只能听到声音（如果你的音箱打开的话）。但是，利用列出命令，你就能显<br> 示出所使用的转义控制码</li>
</ol>
<h3 id="19-2-8-使-用-sed-处理文件"><a href="#19-2-8-使-用-sed-处理文件" class="headerlink" title="19.2.8 使 用 sed 处理文件"></a>19.2.8 使 用 sed 处理文件</h3><ol>
<li>sed支持写文件  <pre class="language-bash" data-language="bash"><code class="language-bash">[address]w filename</code></pre>
  filename可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文<br>  件的写权限。地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间<br>  或文本模式。  <pre class="language-bash" data-language="bash"><code class="language-bash">$ sed -n &#39;&#x2F;Browncoat&#x2F;w Browncoats.txt&#39; data11.txt  #文本模式匹配
$ sed &#39;1,2w test.txt&#39; data6.txt  # 文件选址</code></pre></li>
<li>从文件读取数据<br>  filename参数指定了数据文件的绝对路径或相对路径。你在读取命令中使用地址区间，只<br>  能指定单独一个行号或文本模式地址。sed编辑器会将文件中的文本插入到指定地址后。  <pre class="language-bash" data-language="bash"><code class="language-bash">$ cat data12.txt
This is an added line. 
This is the second added line. 
$ 
$ sed &#39;3r data12.txt&#39; data6.txt 
This is line number 1. 
This is line number 2. 
This is line number 3. 
This is an added line. 
This is the second added line. 
This is line number 4. </code></pre>
  将data12.txt的文件插入到 data6.txt文件流中第三行后面<br>  读取命令的另一个很酷的用法是和删除命令配合使用  <pre class="language-bash" data-language="bash"><code class="language-bash">$ sed &#39;&#x2F;LIST&#x2F;&#123;
&gt; r data11.txt 
&gt; d 
&gt; &#125;&#39; notice.std</code></pre></li>
</ol>
<h1 id="20-正则表达式"><a href="#20-正则表达式" class="headerlink" title="20.正则表达式"></a>20.正则表达式</h1><h2 id="20-1-什么是正则表达式"><a href="#20-1-什么是正则表达式" class="headerlink" title="20.1 什么是正则表达式"></a>20.1 什么是正则表达式</h2><p>正则表达式就是某种模板(筛子)，正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是<br>一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。</p>
<ul>
<li>POSIX基础正则表达式（basic regular expression，BRE）引擎</li>
<li>POSIX扩展正则表达式（extended regular expression，ERE）引擎</li>
</ul>
<h2 id="20-2-定义BRE模式"><a href="#20-2-定义BRE模式" class="headerlink" title="20.2 定义BRE模式"></a>20.2 定义BRE模式</h2><h3 id="20-2-1-纯文本"><a href="#20-2-1-纯文本" class="headerlink" title="20.2.1. 纯文本"></a>20.2.1. 纯文本</h3><p><code>echo &quot;This is a test&quot; | sed -n &#39;/this/p&#39;</code> 这里面p是print,少了-n是打印两条，this没匹配到所以没有显示<br>空格也是普通的字符，比如<code>sed -n /  /p data.set</code></p>
<h3 id="20-2-2-特殊字符"><a href="#20-2-2-特殊字符" class="headerlink" title="20.2.2 特殊字符"></a>20.2.2 特殊字符</h3><p><code>echo &quot;3 / 2&quot; | sed -n &#39;///p&#39;</code> 正斜线也需要转义字符，故正确的是<code>echo &quot;3 / 2&quot; | sed -n &#39;/\//p&#39;</code></p>
<h3 id="20-2-3-锚定字符"><a href="#20-2-3-锚定字符" class="headerlink" title="20.2.3 锚定字符"></a>20.2.3 锚定字符</h3><ol>
<li><p><code>^</code>锚定字符<br>主要是锚定字符串行首。如果模式出现在行首之外的位置则不匹配，如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了<code>echo &quot;This is ^ a test&quot; | sed -n &#39;/s ^/p&#39;</code><br>&#96;&#96;</p>
</li>
<li><p><code>$</code>锚定结尾<br>特殊字符美元符<code>$</code>定义了行尾锚点。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。<code>echo &quot;This is a good book&quot; | sed -n &#39;/book$/p&#39;</code></p>
</li>
<li><p>组合锚定</p>
 <pre class="language-bash" data-language="bash"><code class="language-bash">$ cat data4
this is a test of using both anchors  # 这一行会被忽略
I said this is a test 
this is a test 
I&#39;m sure this is a test. 
$ sed -n &#39;&#x2F;^this is a test$&#x2F;p&#39; data4 
this is a test</code></pre>

<p> 第二种情况</p>
 <pre class="language-bash" data-language="bash"><code class="language-bash">$ cat data5
This is one test line. 
This is another test line. 
$ sed &#39;&#x2F;^$&#x2F;d&#39; data5 
This is one test line. 
This is another test line. </code></pre>

<p> 定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行。由于空白行在两个换行符之间没有文本，刚好匹配了正则表达式模式。sed编辑器用删除命令d来删除匹配该正则表达式模式的行，因此删除了文本中的所有空白行。这是从文档中删除空白行的有效方法</p>
</li>
</ol>
<h3 id="20-2-4-点字符"><a href="#20-2-4-点字符" class="headerlink" title="20.2.4 点字符"></a>20.2.4 点字符</h3><p>特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cat data6
This is a test of a line. 
The cat is sleeping. 
That is a very nice hat. 
This test is at line four. 
at ten o&#39;clock we&#39;ll go home. 
$ sed -n &#39;&#x2F;.at&#x2F;p&#39; data6 
The cat is sleeping. 
That is a very nice hat. 
This test is at line four. 
</code></pre>

<h3 id="20-2-5-字符数组"><a href="#20-2-5-字符数组" class="headerlink" title="20.2.5 字符数组"></a>20.2.5 字符数组</h3><p>点字符在模糊匹配上很有用，但是你想在某一位置上指定字符范围，那么字符数组就会很有用</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ sed -n &#39;&#x2F;[ch]at&#x2F;p&#39; data6
The cat is sleeping. 
That is a very nice hat. 
</code></pre>

<h3 id="20-2-6-排除型字符"><a href="#20-2-6-排除型字符" class="headerlink" title="20.2.6 排除型字符"></a>20.2.6 排除型字符</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ sed -n &#39;&#x2F;[
ch]at&#x2F;p&#39; data6
This test is at line four. </code></pre>

<p>通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字<br>符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at<br>开头的行仍然未能匹配模式</p>
<h3 id="20-2-7-区间"><a href="#20-2-7-区间" class="headerlink" title="20.2.7 区间"></a>20.2.7 区间</h3><p>想想匹配邮编那个case，实在是太麻烦，我们可以简化为<code>区间</code>表示  </p>
<pre class="language-bash" data-language="bash"><code class="language-bash">sed -n &#39;&#x2F;^[0-9][0-9][0-9][0-9][0-9]$&#x2F;p&#39; data8 </code></pre>

<p>也可以指定多个区间<code>sed -n &#39;/[a-ch-m]at/p&#39; data6</code>,该字符组允许区间a<del>c、h</del>m中的字母出现在at文本前</p>
<h3 id="20-2-8-特殊的字符数组"><a href="#20-2-8-特殊的字符数组" class="headerlink" title="20.2.8 特殊的字符数组"></a>20.2.8 特殊的字符数组</h3><pre class="language-bash" data-language="bash"><code class="language-bash">#BRE特殊字符组
组                      描 述
[[:alpha:]]             匹配任意字母字符，不管是大写还是小写
[[:alnum:]]             匹配任意字母数字字符0~9、A~Z或a~z 
[[:blank:]]             匹配空格或制表符
[[:digit:]]             匹配0~9之间的数字
[[:lower:]]             匹配小写字母字符a~z 
[[:print:]]             匹配任意可打印字符
[[:punct:]]             匹配标点符号    
[[:space:]]             匹配任意空白字符：空格、制表符、NL、FF、VT和CR 
[[:upper:]]             匹配任意大写字母字符A~Z </code></pre>

<h3 id="20-2-9-星号"><a href="#20-2-9-星号" class="headerlink" title="20.2.9 星号"></a>20.2.9 星号</h3><p>在字符后面放置<strong>星号</strong>表明该字符必须在匹配模式的文本中出现0次或多次</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ echo &quot;ik&quot; | sed -n &#39;&#x2F;ie*k&#x2F;p&#39;
ik 
$ echo &quot;iek&quot; | sed -n &#39;&#x2F;ie*k&#x2F;p&#39; 
iek 
$ echo &quot;ieek&quot; | sed -n &#39;&#x2F;ie*k&#x2F;p&#39; 
ieek 
$ echo &quot;ieeek&quot; | sed -n &#39;&#x2F;ie*k&#x2F;p&#39;</code></pre>

<p>另一个方便的特性是将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量<br>的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ echo &quot;this is a regular pattern expression&quot; | sed -n &#39;
&gt; &#x2F;regular.*expression&#x2F;p&#39; 
this is a regular pattern expression </code></pre>

<p>星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。  </p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ echo &quot;bt&quot; | sed -n &#39;&#x2F;b[ae]*t&#x2F;p&#39;
bt 
$ echo &quot;bat&quot; | sed -n &#39;&#x2F;b[ae]*t&#x2F;p&#39; 
bat 
$ echo &quot;bet&quot; | sed -n &#39;&#x2F;b[ae]*t&#x2F;p&#39; 
bet 
$ echo &quot;btt&quot; | sed -n &#39;&#x2F;b[ae]*t&#x2F;p&#39; 
btt 
$ 
$ echo &quot;baat&quot; | sed -n &#39;&#x2F;b[ae]*t&#x2F;p&#39; 
baat 
$ echo &quot;baaeeet&quot; | sed -n &#39;&#x2F;b[ae]*t&#x2F;p&#39; 
baaeeet 
$ echo &quot;baeeaeeat&quot; | sed -n &#39;&#x2F;b[ae]*t&#x2F;p&#39; 
baeeaeeat 
$ echo &quot;baakeeet&quot; | sed -n &#39;&#x2F;b[ae]*t&#x2F;p&#39; 
$ </code></pre>

<p>只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。</p>
<h1 id="AppendIndex"><a href="#AppendIndex" class="headerlink" title="AppendIndex"></a>AppendIndex</h1><ul>
<li>re-read 意思是重新理解该章节</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%88%87shell%E8%85%B3%E6%9C%AC%E7%B7%A8%E7%A8%8B%E5%A4%A7%E5%85%A8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%BB%E7%A0%94%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/"
                            aria-label=": 如何在读研的道路上快速失败"
                        >
                            如何在读研的道路上快速失败
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T21:14:38+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>原创:陈怡然 陈老师有话说</p>
<ol>
<li>为自己找出一堆把其他个人兴趣爱好或者其他事情放在学习之上的理由：比如人活着就是为了享受生活，要事业家庭平衡之类（说真的，这是人生观问题。也许一开始你就根本不需要&#x2F;不应该读研）；</li>
<li>认为很多必须要做的事情或者要解决的问题拖到最后会不了了之、奇迹般迎刃而解、或者导师会忘(这怎么可能)</li>
<li>为导师不经常找自己而沾沾自喜(其实大部分时候那只是因为他觉得不值得在你身上瞎耽误功夫)</li>
<li>花很多时间计算到底怎么做才能快速达到最低毕业要求赶紧毕业（易经：取法乎上，仅得其中；取法乎中，仅得其下)</li>
<li>每次都指望从师兄师姐那里临时榨点什么以混过和导师的1-on-1（以为导师和师兄师姐傻啊？）；</li>
<li>总觉得别人做的东西简单容易上手好发文章，不断在不同的题目中跳来跳去（世上那有什么容易的东西，只有你看不到的努力)</li>
<li>对导师和同学的建议与帮助出于本能的拒绝并试图证明别人是错的(自尊&#x2F;自信&#x2F;自负&#x2F;自卑大多数时候其实我们自己不是那么容易分的清楚，但别人的善心只会offer一次)</li>
<li>总觉得自己比别人聪明，研究做不出来或者文章总不中只是一时粗心或者运气不好(不断重复发生的事情其实就是规律)</li>
<li>在每次觉得做不出来、或者做不完的时候玩消失，或者对更大、更复杂的任务说No（盖章：此人难当大任)</li>
<li>每次都刚刚做到最低要求，把剩余的工作扔给导师或者合作的同学，并为自己节省下的时间和努力沾沾自喜(你可能还没认识到别人对你的支持永远和你自己的付出成正比这一事实)</li>
<li>觉得自己很努力了，但是却怎么也达不到目标或者导师要求(如果确实不是你还有没有挤出来的时间，而你也不愿意承认自己确实不行，那么就多花点时间观察别人学习的方法和效率吧)</li>
<li>开始承认自己确实不行，并把全部精力放在劝说老师降低标准放自己毕业上(你可能没理解这件事情的难度在于你要求他降低的是对所有人的标准，而不单单是对你自己的)</li>
<li>觉得导师是个傻X(这个其实也不是没有可能。强扭的瓜不甜，我支持你用脚投票。或许到时双方都会大大的松了一口气，多年以后江湖再见还能把酒言欢).</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%BB%E7%A0%94%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E4%BB%8E0%E5%88%B01_%E5%BC%80%E5%90%AF%E5%95%86%E4%B8%9A%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%98%E5%AF%86/"
                            aria-label=": 从0到1:开启商业与未来的秘密"
                        >
                            从0到1:开启商业与未来的秘密
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T20:51:26+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/">非技术类</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="第八章-秘密"><a href="#第八章-秘密" class="headerlink" title="第八章:秘密"></a>第八章:秘密</h2><p>还记得我们的反主流问题吗：在什么重要问题上你与其他人有不同看法？如果我们今天对自然的了解已经达到未来才能达到的程度，如果今天所有的真理已被领悟，如果再无秘密可探索，那么这个问题就寻不到好答案。除非世界上还有秘密有待发现，否则与众不同的想法就毫无意义。 如果世界上还有很多秘密，那就还可能出现很多有望改变世界的企业.</p>
<pre class="language-text" data-language="text"><code class="language-text">作者提出一个模型。 尝试（不是秘密） 困难（有秘密要探索）不可能（验证弦理论），
人们可以完成困难的事情，但是不能完成不可能的事情</code></pre>

<h2 id="8-1-为什么人们不探索发现秘密"><a href="#8-1-为什么人们不探索发现秘密" class="headerlink" title="8.1 为什么人们不探索发现秘密"></a>8.1 为什么人们不探索发现秘密</h2><p>因为人类都愿意悲观的思考问题。四种社会趋势使人们不愿相信秘密</p>
<ol>
<li>渐进主义：从小被教育只要学习考试规定的内容就可以了。不要做“出格”的事情</li>
<li>风险规避： 人之常情，探索秘密就会经历错误的选择。会花费时间思考和纠正。经受制度带来的压力。</li>
<li>自满：既然能享受现有成果，为什么还要探索秘密？</li>
<li>地球的扁平化：人们认为世界是平的，是高度一至的。如果发现新事物，难道世界其他地方的人就没发现吗？鉴于此想法，导致人不愿意去探索</li>
</ol>
<p>我们可以用一种乐观的方式来描述以上这些趋势带来的结果：创立任何狂热教派在今天看来都异想天开。而在40年前，人们更加认同这样一个观点——并不是所有知识都是众所周知的。从共产党到印度教克利须纳派，大多数人认为他们可以加入先锋觉醒组织，以得到一条指引自己前进的道路。如今极少有人对非正统观念持严肃认真的态度，主流认为这是进步的标志。现在，疯狂的异端教派越来越少，我们应该为之感到高兴，但是为了这一收获，我们付出了沉重的代价：丧失了对等待被挖掘的秘密的好奇之心。</p>
<blockquote>
<p>上面内容更像是作者对非主流思想的一种趋向，因为人们认为主流思想才是进步思想，二而对于非正统思想持一种抵触。这样的好处是，疯狂的异教徒少了，但也丢了挖掘秘密的好奇心</p>
</blockquote>
<h2 id="8-2-恪守常规的世界"><a href="#8-2-恪守常规的世界" class="headerlink" title="8.2 恪守常规的世界"></a>8.2 恪守常规的世界</h2><p>不去发现秘密让人们的思想，认识，得不到良序的发展，没有人权，没有更多的自由。世界在发展，还有很多秘密仍需要发展。</p>
<p>例如：在经济学上，因为人们过度相信市场经济，认为市场经济可以调控一切经济活动。但是2008年的经济危机。说明过度相信市场经济，市场泡沫会在某个阶段爆发出来。<br>当一个公司不思进取就会慢慢像惠普一样，慢慢的被时代，环境，对手淘汰掉。</p>
<h2 id="8-3-相信秘密"><a href="#8-3-相信秘密" class="headerlink" title="8.3 相信秘密"></a>8.3 相信秘密</h2><p>事实上还是有很多秘密存在，人们相信秘密的存在。因为这个世界还有很多问题存在，因为问题的存在，以及人们追求高效，简单，快捷处理问题的速求，以及这背后带来的巨大财富，促使人们去寻找解决问题的出路，并坚定的选择去探索秘密。<br>在工程，科学还有很多事情要去做，商业也是如此，它建立在这个世界的开放未知的秘密之上，这个秘密关乎世界如何运作，也是因为相信秘密的存在促成很多大公司的建立，以及源源不断的新公司的成立</p>
<h2 id="8-4-发现秘密"><a href="#8-4-发现秘密" class="headerlink" title="8.4 发现秘密"></a>8.4 发现秘密</h2><ul>
<li>自然的密码</li>
<li>人的秘密</li>
</ul>
<p>当你要创建公司的时候要问自己两个秘密，哪些自然秘密还是未知的，哪些人的秘密是未知的。作者举了个物理学博士面试工程师的故事来说明，不要以为自己理解专业知识丰富而忽略了人的因素.</p>
<pre class="language-text" data-language="text"><code class="language-text">不记得在哪里看到过一句话，做成事情，要满足明面的规则，也要满足潜规则。硬性技能和软技能，都要把握住。</code></pre>

<h2 id="8-5-秘密的作用"><a href="#8-5-秘密的作用" class="headerlink" title="8.5 秘密的作用"></a>8.5 秘密的作用</h2><p>所有伟大的公司都是都是基于鲜为人知的秘密创立的。当你与人分享你的秘密的时候就会招来竞争者</p>
<pre class="language-text" data-language="text"><code class="language-text">当你想阐述的答案与大众价值观相左，就不要人人皆知，和不告诉别人之间有个平衡点，这个平衡点会将帮助你达成目标------ 发现秘密</code></pre>

<p>秘密能将你引向鲜花和掌声，以及带来荣誉，将你带向耀眼月亮。选择那条崎岖，隐晦的路吧。</p>
<h2 id="第九章-基础决定命运"><a href="#第九章-基础决定命运" class="headerlink" title="第九章:基础决定命运"></a>第九章:基础决定命运</h2><p>最近有个想法一直浮现在脑海中“在世界上的所有知识当中，抑或是自己选择的道路所需要的知识，都应该是有个‘根’知识，这个‘根’知识很重要，它是学习其他知识的基础，影响着你吸取其他知识”。一开始就要打好基础，一个一个的过，不要有侥幸心理，在开始做的时候就要做到尽善尽美</p>
<h2 id="9-1-初创时的“联姻”"><a href="#9-1-初创时的“联姻”" class="headerlink" title="9.1 初创时的“联姻”"></a>9.1 初创时的“联姻”</h2><p>如果个人能力不行，就需要与其他人合作，这话说起来简单，但有诸多细节需要探讨，比如这个人的脾气，性格等等。随时都可能导致某人与团队不和，进而使工作无法推荐所以作者在投资一家公司时候会看领导层的硬实力，也就是专业技能，和他们之间的默契程度，他们要有深厚交情.</p>
<h2 id="9-2-所有权，股权，控制权"><a href="#9-2-所有权，股权，控制权" class="headerlink" title="9.2 所有权，股权，控制权"></a>9.2 所有权，股权，控制权</h2><p>要做好这三个权力的分配。如果想控制公司，要保证董事会人数尽可能的少</p>
<h2 id="9-3-要么上车，要么下车"><a href="#9-3-要么上车，要么下车" class="headerlink" title="9.3 要么上车，要么下车"></a>9.3 要么上车，要么下车</h2><p>作者的这个观点我不太认同，那跨国公司，不同国家间不同人群的协同工作，有些公司也可做的很好</p>
<h2 id="9-4-现金奖励不是王道"><a href="#9-4-现金奖励不是王道" class="headerlink" title="9.4 现金奖励不是王道"></a>9.4 现金奖励不是王道</h2><p>这点作者的意思在初创时候，不要给太多的现金来捆绑住员工的忠诚度。因为给的钱多，很可能会将公司掏空.</p>
<h2 id="9-5-股票激励才能使员工全力以赴"><a href="#9-5-股票激励才能使员工全力以赴" class="headerlink" title="9.5 股票激励才能使员工全力以赴"></a>9.5 股票激励才能使员工全力以赴</h2><p>股票流通差，站在员工角度其实就是在赌这个公司的运气，因为公司破产股票就一文不值。站在老板角度就是在让员工与公司共成长。进而也减少现金开销</p>
<h2 id="9-6-让创业延续"><a href="#9-6-让创业延续" class="headerlink" title="9.6 让创业延续"></a>9.6 让创业延续</h2><p>最有价值的公司始终鼓励发明创造，之前度过相关的文章是说微创新，在企业内部创业。如果每次创业实际恰当，使公司向着创新道路发展。进而无限创业下去。  </p>
<blockquote>
<p>居家办公或者在办公室办公也好。大家都会产生些许许摩擦，如何团结团队凝聚力这也是个关键问题，就像是实际工作中，如果把team给你管理，你是否可以推动工作前进呢？需要后面学习别人如何处理团队人事相关问题。别指望少付出还能持续创收，管理会碰到麻烦，但不应害怕，专注解决人，和工作上的问题</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E4%BB%8E0%E5%88%B01_%E5%BC%80%E5%90%AF%E5%95%86%E4%B8%9A%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%98%E5%AF%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"
                            aria-label=": docker从入门到实践"
                        >
                            docker从入门到实践
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T20:47:28+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/CICD/">CICD</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AFdocker">1. 什么是docker</a></li>
<li><a href="#2docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">2.docker镜像基本概念与基本命令</a><ul>
<li><a href="#21-%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">2.1 镜像基本命令</a></li>
<li><a href="#22-%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F">2.2 定制镜像</a><ul>
<li><a href="#221-%E4%BD%BF%E7%94%A8dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F">2.2.1 使用Dockerfile定制镜像</a></li>
<li><a href="#222-%E7%9B%B4%E6%8E%A5%E7%94%A8-git-repo%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">2.2.2 直接用 Git repo构建镜像</a></li>
<li><a href="#223-%E7%94%A8%E7%BD%91%E7%BB%9C%E4%BD%8D%E7%BD%AE%E4%B8%8Atar%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">2.2.3 用网络位置上tar构建镜像</a></li>
<li><a href="#224-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AE%9A%E5%88%B6">2.2.4 从标准输入输出定制</a></li>
<li><a href="#225-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA">2.2.5 从标准输入中读取上下文压缩包进行构建</a></li>
</ul>
</li>
<li><a href="#23-dockerfile%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3">2.3 Dockerfile构建命令详解</a><ul>
<li><a href="#231-copy%E5%A4%8D%E5%88%B6">2.3.1 COPY复制</a></li>
<li><a href="#232-add%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4">2.3.2 ADD更高级的复制命令</a></li>
<li><a href="#233-cmd%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4">2.3.3 CMD容器启动命令</a></li>
<li><a href="#234-entrypoint-%E5%85%A5%E5%8F%A3%E7%82%B9">2.3.4 ENTRYPOINT 入口点</a></li>
<li><a href="#235-env-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">2.3.5 ENV 设置环境变量</a></li>
<li><a href="#236-arg-%E6%9E%84%E5%BB%BA%E6%8C%87%E4%BB%A4">2.3.6 ARG 构建指令</a></li>
<li><a href="#237-volume-%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%8D%B7">2.3.7 VOLUME 定义匿名卷</a></li>
<li><a href="#238-expose-%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3">2.3.8 EXPOSE 暴露端口</a></li>
<li><a href="#239-workdir-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95">2.3.9 WORKDIR 指定工作目录</a></li>
<li><a href="#2310-user%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7">2.3.10 USER指定当前用户</a></li>
<li><a href="#2311-healthcheck-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5healthcheck-%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%97%E9%80%89%E9%A1%B9">2.3.11 HEALTHCHECK 健康检查<code>HEALTHCHECK</code> 支持下列选项</a></li>
<li><a href="#2312-onbuild-%E4%B8%BA%E4%BB%96%E4%BA%BA%E4%BD%9C%E5%AB%81%E8%A1%A3%E8%A3%B3">2.3.12 ONBUILD 为他人作嫁衣裳</a></li>
<li><a href="#2313-label-%E4%B8%BA%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE">2.3.13 LABEL 为镜像添加元数据</a></li>
<li><a href="#2314-shell%E6%8C%87%E4%BB%A4">2.3.14 shell指令</a></li>
<li><a href="#2315-%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">2.3.15 参考文档</a></li>
</ul>
</li>
<li><a href="#24-dockerfile-%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">2.4 Dockerfile 多阶段构建</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">实战多阶段构建镜像</a></li>
<li><a href="#25-%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81%E7%9A%84docker%E9%95%9C%E5%83%8F">2.5 构建多种系统架构支持的docker镜像</a></li>
<li><a href="#26-%E5%85%B6%E5%AE%83%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%9A%84%E6%96%B9%E5%BC%8F">2.6 其它制作镜像的方式</a></li>
</ul>
</li>
<li><a href="#3-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8">3. 操作容器</a><ul>
<li><a href="#31-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">3.1 容器基本操作</a></li>
</ul>
</li>
<li><a href="#4-%E8%AE%BF%E9%97%AE%E4%BB%93%E5%BA%93">4. 访问仓库</a></li>
<li><a href="#5-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86">5. 数据管理</a><ul>
<li><a href="#51-%E6%95%B0%E6%8D%AE%E5%8D%B7">5.1 数据卷</a></li>
<li><a href="#52-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95">5.2 挂载主机目录</a></li>
</ul>
</li>
<li><a href="#6-%E7%BD%91%E7%BB%9C">6. 网络</a><ul>
<li><a href="#61-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84">6.1 端口映射</a></li>
<li><a href="#62-%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94">6.2 容器互联</a></li>
<li><a href="#63-%E9%85%8D%E7%BD%AEdns">6.3. 配置DNS</a></li>
</ul>
</li>
<li><a href="#7-%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">7. 高级网络配置</a></li>
<li><a href="#8-docker-buildx">8. Docker Buildx</a></li>
<li><a href="#9-docker-compose">9. Docker Compose</a><ul>
<li><a href="#91-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAweb%E5%BA%94%E7%94%A8">9.1 搭建一个web应用</a></li>
</ul>
</li>
<li><a href="#10-%E5%AE%89%E5%85%A8">10. 安全</a></li>
<li><a href="#11-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">11. 底层实现</a></li>
<li><a href="#12-kubernetes">12. Kubernetes</a></li>
<li><a href="#13-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B---cicd">13. 实战案例 - CI&#x2F;CD</a></li>
</ul>
<h1 id="1-什么是docker"><a href="#1-什么是docker" class="headerlink" title="1. 什么是docker"></a>1. 什么是docker</h1><p>Docker是云技术的一次革新，2013年以Apache协议开源，基于linux内核的<strong>cgroup</strong>,<strong>namespace</strong>以及OverlayFS的<strong>UnionFS</strong>实现，对进程进行封装，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主机因此称为容器</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b5d51fa80b2435386d16496375409c2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f40405bc364cd295076c36c9d354e5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>镜像<br>操作系统分为<code>内核</code>和<code>用户空间</code>，而docker的镜像就是一种特殊的文件系统，除了提供容器运行所需的程序，库，资源，配置等文件外，还包括为运行时准备的的一些配置参数</p>
</li>
<li><p>分层存储<br>Docker 设计时，就充分利用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
</li>
<li><p>容器<br>容器跟镜像的关系就像是面向对象中类和实例的概念，容器的实质是进程，与宿主机的进程不同，容器拥有自己独立的命空间，因此拥有自己的root文件系统，自己的网络配置，自己的进程空间，自己的用户id空间。进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。<br>一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong><br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失（后面建议挂载volume）</p>
</li>
<li><p>仓库<br><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/basic_concept/repository">仓库</a></p>
</li>
</ul>
<h1 id="2-docker镜像基本概念与基本命令"><a href="#2-docker镜像基本概念与基本命令" class="headerlink" title="2.docker镜像基本概念与基本命令"></a>2.docker镜像基本概念与基本命令</h1><h2 id="2-1-镜像基本命令"><a href="#2-1-镜像基本命令" class="headerlink" title="2.1 镜像基本命令"></a>2.1 镜像基本命令</h2><p>拉取镜像:</p>
<ul>
<li>docker pull [OPTION] NAME</li>
</ul>
<pre class="language-text" data-language="text"><code class="language-text">&lt;域名/IP>[:端口号]</code></pre>

<p>运行镜像：</p>
<ul>
<li>docker run -it –rm 镜像 [命令 &#x2F;bin&#x2F;bash]  参数<br>列举镜像：</li>
<li>docker image ls</li>
<li>docker images</li>
<li>docker image ls -f since&#x3D;mongo:3.2 &#x2F;&#x2F;查看某个镜像之前创建的镜像，同理也有查看某个镜像之后的镜像</li>
<li>docker ps &#x3D; docker container ls &#x2F;&#x2F;现实运行中的容器<br>查看镜像体积</li>
<li>docker system df<br>虚悬镜像<br>仓库名和版本号都是none，这是因为新版本的镜像跟旧镜像冲突，，删除虚悬镜像</li>
<li>docker image prune</li>
<li>docker image ls -f dangling&#x3D;true &#x2F;&#x2F;列举虚悬镜像</li>
<li>docker image ls -a &#x2F;&#x2F;有些none镜像不是虚悬镜像是中间镜像<br>以特定格式显示</li>
<li>docker image ls -q</li>
<li><code>docker image ls --format &quot;&#123;&#123; .ID &#125;&#125;:&#123;&#123; .Repository &#125;&#125;&quot; </code> &#x2F;&#x2F;支持go模板用法,方便其他程序调用</li>
<li><code>docker image ls --format &quot;table &#123;&#123; .ID &#125;&#125; \t &#123;&#123; .Repository &#125;&#125; \t &#123;&#123; .Tag &#125;&#125;&quot;</code> &#x2F;&#x2F; 会显示title<br>删除镜像</li>
<li>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</li>
<li>docker image rm $(docker image ls -q redis)  &#x2F;&#x2F;使用docker image ls命令配合使用</li>
</ul>
<p>untageged和删除  </p>
<ul>
<li>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因</li>
</ul>
<p>利用commit来持久化容器变化到镜像(黑箱镜)</p>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">docker commit \
--author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \
--message &quot;修改了默认网页&quot; \
webserver \
nginx:v2</code></pre>

<ul>
<li><code>docker history</code> 具体查看镜像内的历史记录</li>
</ul>
<h2 id="2-2-定制镜像"><a href="#2-2-定制镜像" class="headerlink" title="2.2 定制镜像"></a>2.2 定制镜像</h2><h3 id="2-2-1-使用Dockerfile定制镜像"><a href="#2-2-1-使用Dockerfile定制镜像" class="headerlink" title="2.2.1 使用Dockerfile定制镜像"></a>2.2.1 使用Dockerfile定制镜像</h3><p><strong>From</strong> 关键字指定基础镜像<br><em><strong>RUN</strong></em> 执行命令,在撰写 Dockerfile 的时候,要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建，使用docker build 构建编写的Dockerfile  </p>
<blockquote>
<p><code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能,当服务端需要本地文件时候该怎么获得</p>
</blockquote>
<p><em><strong>COPY</strong></em>  复制 <strong>上下文（context）</strong> 目录下的源文件</p>
<blockquote>
<p>COPY .&#x2F;package.json &#x2F;app&#x2F;</p>
</blockquote>
<p>复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>,<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像</p>
<ul>
<li>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile</li>
<li>如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的</li>
<li>实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code></li>
</ul>
<h3 id="2-2-2-直接用-Git-repo构建镜像"><a href="#2-2-2-直接用-Git-repo构建镜像" class="headerlink" title="2.2.2 直接用 Git repo构建镜像"></a>2.2.2 直接用 Git repo构建镜像</h3><pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile"># $env:DOCKER_BUILDKIT&#x3D;0
# export DOCKER_BUILDKIT&#x3D;0
$ docker build -t hello-world https:&#x2F;&#x2F;github.com&#x2F;docker-library&#x2F;hello-world.git#master:amd64&#x2F;hello-world
Step 1&#x2F;3 : FROM scratch
---&gt;
Step 2&#x2F;3 : COPY hello &#x2F;
---&gt; ac779757d46e
Step 3&#x2F;3 : CMD [&quot;&#x2F;hello&quot;]
---&gt; Running in d2a513a760ed
Removing intermediate container d2a513a760ed
---&gt; 038ad4142d2b
Successfully built 038ad4142d2b</code></pre>

<h3 id="2-2-3-用网络位置上tar构建镜像"><a href="#2-2-3-用网络位置上tar构建镜像" class="headerlink" title="2.2.3 用网络位置上tar构建镜像"></a>2.2.3 用网络位置上tar构建镜像</h3><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建.  </p>
<h3 id="2-2-4-从标准输入输出定制"><a href="#2-2-4-从标准输入输出定制" class="headerlink" title="2.2.4 从标准输入输出定制"></a>2.2.4 从标准输入输出定制</h3><p>docker build - &lt; Dockerfile<br>cat Dockerfile | docker build -<br>因为没有上下文，所以Dockerfile里面不可以使用<code>copy</code>  </p>
<h3 id="2-2-5-从标准输入中读取上下文压缩包进行构建"><a href="#2-2-5-从标准输入中读取上下文压缩包进行构建" class="headerlink" title="2.2.5 从标准输入中读取上下文压缩包进行构建"></a>2.2.5 从标准输入中读取上下文压缩包进行构建</h3><p>docker build - &lt; context.tar.gz<br>说白了就是解压后进行构建</p>
<h2 id="2-3-Dockerfile构建命令详解"><a href="#2-3-Dockerfile构建命令详解" class="headerlink" title="2.3 Dockerfile构建命令详解"></a>2.3 Dockerfile构建命令详解</h2><h3 id="2-3-1-COPY复制"><a href="#2-3-1-COPY复制" class="headerlink" title="2.3.1 COPY复制"></a>2.3.1 COPY复制</h3><ul>
<li>将上下文目录的文件复制到容器中的对应的目录下</li>
<li>支持通配符</li>
<li>源路径是相对路径，目标路径支持绝对路径</li>
<li><code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候</li>
<li>example</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">COPY requirements.txt &#x2F;code  &#x2F;&#x2F;copy 文件到容器中的&#x2F;code目录下</code></pre>

<h3 id="2-3-2-ADD更高级的复制命令"><a href="#2-3-2-ADD更高级的复制命令" class="headerlink" title="2.3.2 ADD更高级的复制命令"></a>2.3.2 ADD更高级的复制命令</h3><ul>
<li>源路径是tar包会在目标路径下解压(非常实用)</li>
<li><code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</li>
<li><code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组</li>
</ul>
<pre class="language-none"><code class="language-none">ADD --chown&#x3D;55:mygroup files* &#x2F;mydir&#x2F;
ADD --chown&#x3D;bin files* &#x2F;mydir&#x2F;
ADD --chown&#x3D;1 files* &#x2F;mydir&#x2F;
ADD --chown&#x3D;10:11 files* &#x2F;mydir&#x2F;</code></pre>

<h3 id="2-3-3-CMD容器启动命令"><a href="#2-3-3-CMD容器启动命令" class="headerlink" title="2.3.3 CMD容器启动命令"></a>2.3.3 CMD容器启动命令</h3><p>容器既然是进程，那么启动时就需要指定运行参数  </p>
<ul>
<li>example<br><code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM ubuntu:18.04
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*
CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]</code></pre>

<p>这个时候运行容器，docker run myip 就会打印ip相关信息，但是如果你想加参数<code>-i</code>，以如下方式<br><code>docker run myip -i</code> 就会报错，因为myip后面传入的参数会被认为是命令，而正确是的方式是<br><code>docker run myip curl -s http://myip.ipip.net -i</code>，显然这不是一个好的方案。可以使用2.3.4的参数来设计</p>
<h3 id="2-3-4-ENTRYPOINT-入口点"><a href="#2-3-4-ENTRYPOINT-入口点" class="headerlink" title="2.3.4 ENTRYPOINT 入口点"></a>2.3.4 ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数,例子如下</p>
<ul>
<li>场景一:让镜像像命令一样使用<code>ENTRYPOINT</code></li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM ubuntu:18.04
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*
ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]
&#x2F;&#x2F;再次尝试跑 docker run myip -i，就会将-i作为参数传给curl命令</code></pre>

<ul>
<li>场景二: 应用运行前的准备工作<br>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM alpine:3.4
RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis
ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]
EXPOSE 6379
CMD [ &quot;redis-server&quot; ]
&#x2F;&#x2F;redis服务创建了redis用户，并在最后ENTRYPOINT指定了entrypoint.sh的脚本,该脚本的内容就是根据CMD的内容
&#x2F;&#x2F;来判断，如果是redis-server的话，则切换到redis用户身份启动服务器，否则依旧使用root身份执行。比如：</code></pre>

<h3 id="2-3-5-ENV-设置环境变量"><a href="#2-3-5-ENV-设置环境变量" class="headerlink" title="2.3.5 ENV 设置环境变量"></a>2.3.5 ENV 设置环境变量</h3><p>可以为后面的RUN命令提供环境变量，是以键值对的形式存在，如果value部分有空格，需要使用双引号括起来</p>
<h3 id="2-3-6-ARG-构建指令"><a href="#2-3-6-ARG-构建指令" class="headerlink" title="2.3.6 ARG 构建指令"></a>2.3.6 ARG 构建指令</h3><p>ARG指令有生效范围，如果在FROM之前指定的，那么只能用于<code>FROM</code>指令中</p>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">ARG DOCKER_USERNAME&#x3D;library
FROM $&#123;DOCKER_USERNAME&#125;&#x2F;alpine
RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</code></pre>

<p><code>RUN</code>拿不到变量值，要想使用只能是在<code>FROM</code>命令后面重新指定<code>ARG</code>,多阶段构建需要指定各个阶段的<code>ARG</code></p>
<h3 id="2-3-7-VOLUME-定义匿名卷"><a href="#2-3-7-VOLUME-定义匿名卷" class="headerlink" title="2.3.7 VOLUME 定义匿名卷"></a>2.3.7 VOLUME 定义匿名卷</h3><p><code>VOLUME /data</code> 挂在匿名卷,向容器&#x2F;data写入的数据最终会落入host磁盘<br><code>$ docker run -d -v mydata:/data xxxx</code><br>就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置</p>
<h3 id="2-3-8-EXPOSE-暴露端口"><a href="#2-3-8-EXPOSE-暴露端口" class="headerlink" title="2.3.8 EXPOSE 暴露端口"></a>2.3.8 EXPOSE 暴露端口</h3><p>与-p &lt;宿主端口&gt;:&lt;容器端口&gt;, 映射端口不通，EXPOSE是暴漏容器端口给其他容器</p>
<h3 id="2-3-9-WORKDIR-指定工作目录"><a href="#2-3-9-WORKDIR-指定工作目录" class="headerlink" title="2.3.9 WORKDIR 指定工作目录"></a>2.3.9 WORKDIR 指定工作目录</h3><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录</p>
<h3 id="2-3-10-USER指定当前用户"><a href="#2-3-10-USER指定当前用户" class="headerlink" title="2.3.10 USER指定当前用户"></a>2.3.10 USER指定当前用户</h3><p><code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h3 id="2-3-11-HEALTHCHECK-健康检查HEALTHCHECK-支持下列选项"><a href="#2-3-11-HEALTHCHECK-健康检查HEALTHCHECK-支持下列选项" class="headerlink" title="2.3.11 HEALTHCHECK 健康检查HEALTHCHECK 支持下列选项"></a>2.3.11 HEALTHCHECK 健康检查<code>HEALTHCHECK</code> 支持下列选项</h3><ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM nginx
RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*
HEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \
CMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1

&#x2F;&#x2F;这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），
&#x2F;&#x2F;如果健康检查命令超过 3 &#x2F;&#x2F;秒没响应就视为失败，并且使用 &#96;curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1&#96;
&#x2F;&#x2F;作为健康检查命令。</code></pre>

<h3 id="2-3-12-ONBUILD-为他人作嫁衣裳"><a href="#2-3-12-ONBUILD-为他人作嫁衣裳" class="headerlink" title="2.3.12 ONBUILD 为他人作嫁衣裳"></a>2.3.12 ONBUILD 为他人作嫁衣裳</h3><h3 id="2-3-13-LABEL-为镜像添加元数据"><a href="#2-3-13-LABEL-为镜像添加元数据" class="headerlink" title="2.3.13 LABEL 为镜像添加元数据"></a>2.3.13 LABEL 为镜像添加元数据</h3><p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">LABEL org.opencontainers.image.authors&#x3D;&quot;yeasy&quot;
LABEL org.opencontainers.image.documentation&#x3D;&quot;https:&#x2F;&#x2F;yeasy.gitbooks.io&quot;</code></pre>

<h3 id="2-3-14-shell指令"><a href="#2-3-14-shell指令" class="headerlink" title="2.3.14 shell指令"></a>2.3.14 shell指令</h3><p><code>SHELL</code> 指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell程序，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code></p>
<h3 id="2-3-15-参考文档"><a href="#2-3-15-参考文档" class="headerlink" title="2.3.15 参考文档"></a>2.3.15 参考文档</h3><ul>
<li><p><code>Dockerfie</code> 官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
</li>
<li><p><code>Dockerfile</code> 最佳实践文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p>
</li>
<li><p><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a target="_blank" rel="noopener" href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></p>
</li>
</ul>
<h2 id="2-4-Dockerfile-多阶段构建"><a href="#2-4-Dockerfile-多阶段构建" class="headerlink" title="2.4 Dockerfile 多阶段构建"></a>2.4 Dockerfile 多阶段构建</h2><ul>
<li>以前是全部放到一个Dockerfile里面，将编译，测试，打包放在一起，可能导致镜像层次过多，源代码泄露风险</li>
<li>分多个Dockerfile编写，然后指定文件逐个构建</li>
<li>使用多阶段构建</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM golang:alpine as builder
RUN apk --no-cache add git
WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;
RUN go get -d -v github.com&#x2F;go-sql-driver&#x2F;mysql
COPY app.go .
RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .
FROM alpine:latest as prod
RUN apk --no-cache add ca-certificates
WORKDIR &#x2F;root&#x2F;
COPY --from&#x3D;0 &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;app .
CMD [&quot;.&#x2F;app&quot;]
&#x2F;&#x2F; 构建镜像  docker build -t go&#x2F;helloworld:3 .</code></pre>

<pre><code>- 我们可以使用 `as` 来为某一阶段命名，例如`FROM golang:alpine as builder`
- 例如当我们只想构建 `builder` 阶段的镜像时，增加 `--target=builder` 参数即可 `$ docker build --target builder -t username/imagename:tag .`
</code></pre>
<ul>
<li>构建时从其他镜像复制文件<br>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件<br><code>$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code></li>
</ul>
<h2 id="实战多阶段构建镜像"><a href="#实战多阶段构建镜像" class="headerlink" title="实战多阶段构建镜像"></a>实战多阶段构建镜像</h2><p><a target="_blank" rel="noopener" href="https://github.com/nigelpoulton/dotnet-docker-samples.git">实战地址</a>  </p>
<ul>
<li><p>生产环境多阶段构建需要保持镜像精简，可以通过&amp;&amp;精简镜像层</p>
</li>
<li><p>run指令执行完会残留构建镜像完后的文件，直接上生产及其不妥，docker提供了多种方式解决这个问题，重瞳方式叫<code>建造者模式</code></p>
<ol>
<li>构建<code>Dockerfile.dev</code>文件</li>
<li>在此基础之上构建新一层镜像</li>
<li>编写Dockerfile.prod，把上一步容器的相关代码和文件复制过来</li>
</ol>
</li>
<li><p>多阶段构建方式<br>分析Dockerfile文件</p>
</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM mcr.microsoft.com&#x2F;dotnet&#x2F;sdk:6.0 AS build
WORKDIR &#x2F;source

# copy csproj and restore as distinct layers
COPY *.sln .
COPY aspnetapp&#x2F;*.csproj .&#x2F;aspnetapp&#x2F;
RUN dotnet restore

# copy everything else and build app
COPY aspnetapp&#x2F;. .&#x2F;aspnetapp&#x2F;
WORKDIR &#x2F;source&#x2F;aspnetapp
RUN dotnet publish -c release -o &#x2F;app --no-restore

# final stage&#x2F;image
FROM mcr.microsoft.com&#x2F;dotnet&#x2F;aspnet:6.0
WORKDIR &#x2F;app
COPY --from&#x3D;build &#x2F;app .&#x2F;
ENTRYPOINT [&quot;dotnet&quot;, &quot;aspnetapp.dll&quot;]</code></pre>

<p>首先注意到，<code>Dockerfile</code>有三个<code>FROM</code>指令。每一个<code>FROM</code>指令构成一个单独的<strong>构建阶段</strong>  </p>
<ol>
<li><p>阶段<code>0</code>：<code>build-env</code><br> <code>build-env</code>阶段拉取了<code>aspnetcore-build:2.0</code>作为基础镜像，然后设置了工作目录，复制一些应用代码，接着执行两个<code>RUN</code>指令，生成<code>1</code>个镜像层并显著得到一个比原镜像大得多的镜像，包含许多构建工具和应用代码</p>
</li>
<li><p>阶段<code>1</code>：<code>microsoft/aspnetcore:2.0</code><br> <code>aspnetcore:2.0</code>阶段拉取了<code>aspnetcore:2.0</code>作为基础镜像，设置工作目录，然后执行<code>COPY --from</code>指令从<code>build-env</code>阶段生成的镜像中复制一些应用代码过来，最后执行<code>ENTRYPOINT</code>指令指定容器的默认应用程序</p>
</li>
</ol>
<p>上述构建过程的重点在于<code>COPY --from</code>指令<strong>表示从之前的构建阶段复制生产环境相关的应用代码，而不会复制生产环境不需要的构件</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7053651f6091402c9c8ff10c99d1ae34~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-5-构建多种系统架构支持的docker镜像"><a href="#2-5-构建多种系统架构支持的docker镜像" class="headerlink" title="2.5 构建多种系统架构支持的docker镜像"></a>2.5 构建多种系统架构支持的docker镜像</h2><p><code>$ docker manifest inspect golang:alpine</code><br>查看manifest列表</p>
<ul>
<li>创建manifest 列表</li>
<li>设置manifest列表</li>
<li>查看manifest列表</li>
<li>推送manifest列表</li>
<li>测试</li>
<li><a target="_blank" rel="noopener" href="https://www.docker.com/blog/multi-arch-all-the-things/">官方博客</a></li>
</ul>
<h2 id="2-6-其它制作镜像的方式"><a href="#2-6-其它制作镜像的方式" class="headerlink" title="2.6 其它制作镜像的方式"></a>2.6 其它制作镜像的方式</h2><ul>
<li>从 rootfs 压缩包导入</li>
</ul>
<pre class="language-docker" data-language="docker"><code class="language-docker">$ docker import \
    http:&#x2F;&#x2F;download.openvz.org&#x2F;template&#x2F;precreated&#x2F;ubuntu-16.04-x86_64.tar.gz \
    openvz&#x2F;ubuntu:16.04

Downloading from http:&#x2F;&#x2F;download.openvz.org&#x2F;template&#x2F;precreated&#x2F;ubuntu-16.04-x86_64.tar.gz
sha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213
&#x2F;&#x2F; 从web远程下载ubuntu然后制作镜像</code></pre>

<ul>
<li>Docker 镜像的导入和导出 <code>docker save</code> 和 <code>docker load</code> ，目前已经不推荐</li>
</ul>
<h1 id="3-操作容器"><a href="#3-操作容器" class="headerlink" title="3. 操作容器"></a>3. 操作容器</h1><h2 id="3-1-容器基本操作"><a href="#3-1-容器基本操作" class="headerlink" title="3.1 容器基本操作"></a>3.1 容器基本操作</h2><p>两种启动容器方式，从镜像到容器，启动停止的容器</p>
<ul>
<li>新建容器</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">$ docker run -dit --name new_name ubuntu:18.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;
Hello world</code></pre>

<p>-itd 意思是指容器绑定标准输入输出，然后绑定个伪终端，然后以守护态运行<br>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令</p>
<ul>
<li>stop&#x2F;restart 容器<br>docker container ls &#x2F;&#x2F;查看容器<br>docker container restart<br>docker container stop&#x2F;start</li>
<li>进入容器<br><code>docker attach</code> 进入容器<br><code>docker exec -it</code> 进入容器</li>
<li>导出&#x2F;导入容器<br><code>docker export 7691a814370e &gt; ubuntu.tar</code><br><code>docker import - test/ubuntu:v1.0</code><br><code>docker import url</code></li>
<li>删除容器<br><code>docker container rm trusting_newton</code><br><code>docker container prune</code> 清理所有种植状态的容器</li>
</ul>
<h1 id="4-访问仓库"><a href="#4-访问仓库" class="headerlink" title="4. 访问仓库"></a>4. 访问仓库</h1><ol>
<li>docker hub</li>
<li>私有仓库</li>
<li>私有仓库高级配置</li>
<li>nexus3</li>
</ol>
<h1 id="5-数据管理"><a href="#5-数据管理" class="headerlink" title="5. 数据管理"></a>5. 数据管理</h1><h2 id="5-1-数据卷"><a href="#5-1-数据卷" class="headerlink" title="5.1 数据卷"></a>5.1 数据卷</h2><p>对数据卷的使用有点像linux的mount，镜像中被挂载的目录文件会复制到宿主机的目录上，独立于容器</p>
<ol>
<li>创建一个数据卷</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker volume create my-vol  创建一个数据卷  
docker volume ls  列举数据卷  
docker volume inspect my_vol 查看某一个数据卷  </code></pre>

<ol start="2">
<li>启动一个挂在了数据卷的容器</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker run -d -P \
    --name web \
    # -v my-vol:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \
    --mount source&#x3D;my-vol,target&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \
    nginx:alpine
&#x2F;&#x2F;使用my_vol数据卷，映射到&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</code></pre>

<ol start="3">
<li>查看数据卷具体信息</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker inspect web &#x2F;&#x2F;数据卷信息在Mounts key下
....
&quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;my-vol&#x2F;_data&quot; &#x2F;&#x2F;默认位置</code></pre>

<p>4.删除一个数据卷</p>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker volume rm my-vol
docker volume prune &#x2F;&#x2F;删除无主的数据卷</code></pre>

<ul>
<li>数据卷可以在容器间共用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷默认会一直存在，即使容器被输出</li>
</ul>
<h2 id="5-2-挂载主机目录"><a href="#5-2-挂载主机目录" class="headerlink" title="5.2 挂载主机目录"></a>5.2 挂载主机目录</h2><ol>
<li>挂载目录到容器目录</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">$ docker run -d -P \
    --name web \
    # -v &#x2F;src&#x2F;webapp:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \
    --mount type&#x3D;bind,source&#x3D;&#x2F;src&#x2F;webapp,target&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html, readonly \
    nginx:alpine</code></pre>

<p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p>
<ul>
<li>目录与容器目录绑定，容器写进文件，就会落盘到宿主机上  </li>
<li>目前如果source不存在就会报错  </li>
<li>宿主机目录也可以指定readonly</li>
</ul>
<ol start="2">
<li>挂载宿主机文件到容器文件中<br>source&#x3D;  ,target&#x3D; 关键字处直接替换成文件</li>
</ol>
<h1 id="6-网络"><a href="#6-网络" class="headerlink" title="6. 网络"></a>6. 网络</h1><h2 id="6-1-端口映射"><a href="#6-1-端口映射" class="headerlink" title="6.1 端口映射"></a>6.1 端口映射</h2><p>-P 会随即映射<br>-p 特定端口映,可使用多次指定多个端口</p>
<ul>
<li><code>$ docker run -d -p 80:80 nginx:alpine</code> hostport:containerport  </li>
<li><code>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</code> 指定地址绑定，容器有自己的网络和地址</li>
<li><code>$ docker run -d -p 127.0.0.1::80/udp nginx:alpine</code> 容器80端口随机映射到主机,并指定传输协议</li>
</ul>
<h2 id="6-2-容器互联"><a href="#6-2-容器互联" class="headerlink" title="6.2 容器互联"></a>6.2 容器互联</h2><ol>
<li>新建网络</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker network create -d bridge my-net</code></pre>

<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href="/docker_practice/swarm_mode">Swarm mode</a>，在本小节中你可以忽略它<br>2. 容器互联</p>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker run -it --rm --name busybox1 --network my-net busybox sh
docker run -it --rm --name busybox2 --network my-net busybox sh
</code></pre>

<p>可以直接ping另外的容器</p>
<ul>
<li>Docker Compose 可以考虑使用</li>
</ul>
<h2 id="6-3-配置DNS"><a href="#6-3-配置DNS" class="headerlink" title="6.3. 配置DNS"></a>6.3. 配置DNS</h2><p>TBC</p>
<h1 id="7-高级网络配置"><a href="#7-高级网络配置" class="headerlink" title="7. 高级网络配置"></a>7. 高级网络配置</h1><h1 id="8-Docker-Buildx"><a href="#8-Docker-Buildx" class="headerlink" title="8. Docker Buildx"></a>8. Docker Buildx</h1><h1 id="9-Docker-Compose"><a href="#9-Docker-Compose" class="headerlink" title="9. Docker Compose"></a>9. Docker Compose</h1><p>结合实战操纵理解</p>
<h2 id="9-1-搭建一个web应用"><a href="#9-1-搭建一个web应用" class="headerlink" title="9.1 搭建一个web应用"></a>9.1 搭建一个web应用</h2><ul>
<li>服务：运行多个相同镜像的实例</li>
<li>项目：一组应用容器组成的一个完整单元<br><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">docker compose</a></li>
</ul>
<h1 id="10-安全"><a href="#10-安全" class="headerlink" title="10. 安全"></a>10. 安全</h1><h1 id="11-底层实现"><a href="#11-底层实现" class="headerlink" title="11. 底层实现"></a>11. 底层实现</h1><h1 id="12-Kubernetes"><a href="#12-Kubernetes" class="headerlink" title="12. Kubernetes"></a>12. Kubernetes</h1><h1 id="13-实战案例-CI-x2F-CD"><a href="#13-实战案例-CI-x2F-CD" class="headerlink" title="13. 实战案例 - CI&#x2F;CD"></a>13. 实战案例 - CI&#x2F;CD</h1>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/%E5%A5%94%E8%B7%91%E5%90%A7ansible/"
                            aria-label=": 奔跑吧ansible"
                        >
                            奔跑吧ansible
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T20:45:28+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/CICD/">CICD</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="3-第三章-inventory-描述你的服务器"><a href="#3-第三章-inventory-描述你的服务器" class="headerlink" title="3. 第三章 inventory:描述你的服务器"></a>3. 第三章 inventory:描述你的服务器</h1><p>ansible管理的多台主机文件叫inventory</p>
<h2 id="3-1-inventory基本参数含义"><a href="#3-1-inventory基本参数含义" class="headerlink" title="3.1 inventory基本参数含义"></a>3.1 inventory基本参数含义</h2><p>inventory文件通常是.ini格式的，常用inventory参数如下</p>
<pre class="language-txt" data-language="txt"><code class="language-txt">ansible_ssh_host     #用于指定被管理的主机的真实IP和将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.
ansible_ssh_port     #用于指定连接到被管理主机的ssh端口号，默认是22，如果不是默认的端口号,通过此变量设置.
ansible_ssh_user     #ssh连接时默认使用的用户名
ansible_ssh_pass     #ssh连接时的密码，(这种方式并不安全,我们强烈建议使用 --ask-pass（交互密码）或 SSH 密钥)
ansible_sudo_pass     #使用sudo连接用户时的密码，(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)
ansible_sudo_exec     #如果sudo命令不在默认路径，需要指定sudo命令路径(适用于1.8及以上版本)
ansible_ssh_private_key_file     #秘钥文件路径，秘钥文件如果不想使用ssh-agent管理时可以使用此选项
ansible_shell_type     #目标系统的shell的类型，默认sh，可设置为 'csh' 或 'fish'.
ansible_connection     #SSH 连接的类型： local , ssh , paramiko，在 ansible 1.2 之前默认是 paramiko ，后来智能选择，优先使用基于 ControlPersist 的 ssh （支持的前提）
ansible_python_interpreter     #用来指定python解释器的路径，默认为/usr/bin/python 同样可以指定ruby 、perl 的路径
ansible_*_interpreter     #其他解释器路径，用法与ansible_python_interpreter类似，这里"*"可以是ruby或才perl等其他语言
以上是2.0版本之前的参数，2.0之后有更换，但是向下兼容</code></pre>

<h3 id="3-1-1-主机别名和群组"><a href="#3-1-1-主机别名和群组" class="headerlink" title="3.1.1 主机别名和群组"></a>3.1.1 主机别名和群组</h3><p>inventory支持群组,类似于下面</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml">[webservers]
testserver ansible_port&#x3D;2202

&#x2F;&#x2F;群组变量
[webservers:vars] 
ansible_user &#x3D; vagrant
ansible_host &#x3D; 127.0.0.1
ansible_private_key_file &#x3D; .vagrant&#x2F;machines&#x2F;default&#x2F;virtualbox&#x2F;private_key

[web]
web[1:20].example.com
</code></pre>

<h3 id="3-1-2-主机和群组变量，在inventory各自文件中"><a href="#3-1-2-主机和群组变量，在inventory各自文件中" class="headerlink" title="3.1.2 主机和群组变量，在inventory各自文件中"></a>3.1.2 主机和群组变量，在inventory各自文件中</h3><p>在inventory目录下我们根据环境，将不同阶段的变量放进文件，<code>group_vars</code>文件夹下文件名要与<code>hosts</code>文件中的群组保持一致</p>
<pre class="language-text" data-language="text"><code class="language-text">group_vars
|----production
|      |- db_primary_host: rhodeisland.example.com
|      |- db_replica_host: virginia.example.com
|      |- db_name: widget_production
|      |- db_user: widgetuser
|      |- db_password: pFmMxcyD;Fc6)6
|      |- rabbitmq_host: pennsylvania.example.com
|----preprod
|      |- db_primary_host: chicago.example.com
|      |- db_replica_host: amsterdam.example.com
|      |- db_name: widget_staging
|      |- db_user: widgetuser
|      |- db_password: L@4Ryz8cRUXedj
|      |- rabbitmq_host: chicago.example.com</code></pre>

<h3 id="3-1-3-动态inventory脚本接口"><a href="#3-1-3-动态inventory脚本接口" class="headerlink" title="3.1.3 动态inventory脚本接口"></a>3.1.3 动态inventory脚本接口</h3><p>对于用何种语言实现脚本，没有要求，但必须支持传<code>--list</code>和<code>--host=&lt;hostname&gt;</code>参数,同时<code>--list</code>输出的json字符串也有要求。有群组和主机键值对，<code>_meta</code>要保存主机变量</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">.&#x2F;dynamic.py  --list</code></pre>

<p>output</p>
<pre class="language-json" data-language="json"><code class="language-json">
&#123;
    &quot;group1&quot;: &#123;
        &quot;hosts&quot;: [
            &quot;192.168.28.71&quot;,
            &quot;192.168.28.72&quot;
        ],
        &quot;vars&quot;: &#123;
            &quot;ansible_ssh_user&quot;: &quot;johndoe&quot;,
            &quot;ansible_ssh_private_key_file&quot;: &quot;~&#x2F;.ssh&#x2F;mykey&quot;,
            &quot;example_variable&quot;: &quot;value&quot;
        &#125;,
        &quot;children&quot;:[&#39;group2&#39;]
    &#125;,
    &quot;_meta&quot;: &#123;
        &quot;hostvars&quot;: &#123;
            &quot;192.168.28.71&quot;: &#123;
                &quot;host_specific_var&quot;: &quot;bar&quot;
            &#125;,
            &quot;192.168.28.72&quot;: &#123;
                &quot;host_specific_var&quot;: &quot;foo&quot;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">.&#x2F;dynamic.py  --host&#x3D;192.168.28.71</code></pre>

<p>output</p>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
    &quot;host_specific_var&quot;: &quot;foo&quot;
&#125;</code></pre>

<p>ansible支持将动态inventory和动态的inventory放在同一文件夹下(名为inventory的文件夹)通过ansible.cfg的hostfile进行控制，也可以使用<code>-i</code>参数进行控制</p>
<h3 id="3-1-4-add-host模块和group-by模块"><a href="#3-1-4-add-host模块和group-by模块" class="headerlink" title="3.1.4 add_host模块和group_by模块"></a>3.1.4 add_host模块和group_by模块</h3><p><code>add_host</code><br>playbook运行时，主机被创建是无法追加新主机的。使用<code>add_host</code>模块就可以添加新主机并在此次playbook中生效<br><code>group_by</code><br>书上使用group_by 实现了按照OS系统类型进行分组执行(像if语句)，yml中具体参数不知道什么意思.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/%E5%A5%94%E8%B7%91%E5%90%A7ansible/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/page/5/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/page/7/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 6 of 7</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/nil" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                nil
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-oejgoqwxqxfpwex5ev6ukctltwog5vlqaetakgrj0ys9pwba1gtnkqh5ga78.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
