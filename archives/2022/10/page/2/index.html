
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Eden">
    <title>Archives: 2022/10 - Eden</title>
    <meta name="author" content="kirkzhang">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Eden">
<meta property="og:url" content="https://simonteo58.github.io/archives/2022/10/page/2/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@nil">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/nil"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Eden
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/nil" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/nil" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Google +"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/16/mysql/mysql_manual/"
                            aria-label=": mysql manual"
                        >
                            mysql manual
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-16T21:54:25+08:00">
	
		    Oct 16, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/mysql/">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p> install mysql on ubuntu <a target="_blank" rel="noopener" href="https://hevodata.com/learn/installing-mysql-on-ubuntu-20-04/">https://hevodata.com/learn/installing-mysql-on-ubuntu-20-04/</a></p>
</blockquote>
<ol>
<li><p>创建数据库</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token string">'newdatabase'</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>设置创建用户并设置密码</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- # Host: %表示支持任意连接，localhost表示只允许本地连接</span>
 <span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'newuser'</span><span class="token variable">@'localhost'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'newpassword'</span><span class="token punctuation">;</span>
 <span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'newuser'</span>@ <span class="token string">'%'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'newpassword'</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li><p>授权</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 如果需要给用户创建数据库的权限，则可以这样设置</span>
<span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">to</span> my_user<span class="token variable">@'%'</span><span class="token punctuation">;</span> <span class="token comment">-- 这里的my_user 跟第五步是相同的</span>

<span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> newdatabase<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'newuser'</span><span class="token variable">@'localhost'</span><span class="token punctuation">;</span>
FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>重新登陆</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">mysql <span class="token operator">-</span>u kirkzhang <span class="token operator">-</span>p</code></pre></li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/16/mysql/mysql_manual/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/16/archive/install_mysql_on_ubuntu/"
                            aria-label=": install_mysql_on_ubuntu(Debian sys)"
                        >
                            install_mysql_on_ubuntu(Debian sys)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-16T16:23:49+08:00">
	
		    Oct 16, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/archive/">archive</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>我自己电脑都是使用<code>apt</code>命令  </p>
<p>安装mysql</p>
<ol>
<li>sudo apt update</li>
<li>sudo apt upgrade</li>
<li>sudo apt install mysql-server</li>
<li>启动mysql<ol>
<li>WSL2 <code>sudo /etc/init.d/mysql start</code>,<code>sudo /etc/init.d/mysql stop</code></li>
<li>ubuntu系统</li>
</ol>
</li>
<li>配置mysql<ol>
<li><code>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code> 在最后一行添加<code>skip-grant-tables</code></li>
<li><code>sudo service mysql restart</code></li>
</ol>
</li>
</ol>
<p>All configuration files (like my.cnf) are under &#x2F;etc&#x2F;mysql</p>
<p>All binaries, libraries, headers, etc., are under &#x2F;usr&#x2F;bin and &#x2F;usr&#x2F;sbin</p>
<p>The data directory is under &#x2F;var&#x2F;lib&#x2F;mysql</p>
<p>卸载mysql<br>安装的过程难免会出错，这时候就可能需要卸载掉软件。下面记录下如何完全卸载掉mysql，便于之后重新安装。</p>
<ol>
<li>自动卸载mysql*相关的软件<br><code>sudo apt-get autoremove --purge mysql*</code></li>
<li>删除掉卸载不完全留下的文件目录<br><code>sudo rm -rf /etc/mysql /var/lib/mysql</code></li>
<li>自动卸载无用的程序<br><code>sudo apt-get autoremove</code></li>
<li>自动清理卸载后的残留信息<br><code>sudo apt-get autoclean</code></li>
<li>这样就mysql就完全卸载好了，之后遵循上面的安装步骤进行安装即可。</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/16/archive/install_mysql_on_ubuntu/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/11/oracle/Real_World_SQL_and_PLSQL/"
                            aria-label=": Real_World_SQL_and_PLSQL"
                        >
                            Real_World_SQL_and_PLSQL
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-11T14:57:52+08:00">
	
		    Oct 11, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/oracle/">oracle</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="chapter-5-Edtion-Baseed-Redefinition"><a href="#chapter-5-Edtion-Baseed-Redefinition" class="headerlink" title="chapter 5 Edtion_Baseed Redefinition"></a>chapter 5 Edtion_Baseed Redefinition</h1><p>升级数据库应用程序总是需要停机；根本不可能替换正在使用的PL&#x2F;SQL对象。</p>
<h2 id="5-1-Planned-Downtime"><a href="#5-1-Planned-Downtime" class="headerlink" title="5.1 Planned Downtime"></a>5.1 Planned Downtime</h2><p>unplaned downtime是很难预料的，可以通过使用备机来减少downtime，但是完全消除downtime是不可能的<br>硬件故障可以切换到物理或者逻辑备用数据库继续提供服务，一直以来，没有办法在运行时替换PL&#x2F;SQL而不影响服务的运行。<br>某一PL&#x2F;SQL object只能有一个版本。当你替换object时候，整个object是被锁住的。<br>planed downtime : 贵公司计划的downtime时间</p>
<p>With edition-based redefinition, you can create PL&#x2F;SQL changes in the privacy of an edition. Then, when the custom application is updated, it can be released to the users. Newly connecting users will use the new application objects, while the users who were using the application during the upgrade can continue to work as if nothing happened. When the last of the users has disconnected from the pre-upgraded application, that application can be retired and only the post-upgraded application will be available for use.</p>
<h2 id="5-2-Terminology-Used（专业术语）"><a href="#5-2-Terminology-Used（专业术语）" class="headerlink" title="5.2 Terminology Used（专业术语）"></a>5.2 Terminology Used（专业术语）</h2><p>patch : 当程序没有实现需求所规定的内容时，需要应用补丁来纠正，实现程序和需求一致。补丁应该使程序符合需求所规定的。<br>upgrade : 当需求在程序创建后发生变化。（跟patch的区分不是太清晰，当文本中提到 “升级 “时，也可理解为一个补丁，反之亦然）。</p>
<h2 id="5-3-The-Concept"><a href="#5-3-The-Concept" class="headerlink" title="5.3 The Concept"></a>5.3 The Concept</h2><p>EBR解决的三个挑战</p>
<ol>
<li>首先，当有人在使用一个应用程序时，你怎么能对其进行修改？对一个应用程序进行修改通常涉及许多对象的修改，但你不能一个接一个地修改它们。这将使应用程序处于invalid的状态 ,有可能用升级前的数据库应用程序对数据库进行完整的复制，并进行必要的修改以达到升级后的状态，这就解决了第一个问题。另一个选择是复制数据库schema，并在这个schema中进行修改。</li>
<li>随之而来的第二个问题，如何在两个应用程序（升级前的应用程序和升级后的应用程序）之间保持数据的同步？你可以想象，这不是一件容易做到的事情。原来的数据库对象仍然在使用，数据继续导入和改变。必须有一种机制，允许数据变化在升级前和升级后的应用程序之间传播。</li>
<li>表结构的升级。</li>
</ol>
<p>EBR三个优点<br>Changes are made in the privacy of a new edition.<br>相同表的不同版本（pre,post）是通过使用编辑视图实现的.<br>在热更新期间，跨版本的触发器将使不同版本之间的数据变化保持同步.</p>
<p>high risk</p>
<pre class="language-none"><code class="language-none">Implementing edition-based redefinition is not as trivial as flipping a switch. 
The preparation phase of edition-based redefinition is very important and might 
require changing the existing database design and database source code</code></pre>

<pre class="language-txt" data-language="txt"><code class="language-txt">If, for whatever reason, the edition-based redefinition exercise fails 
and the edition must be removed, the edition can be dropped by a single 
statement.Keep in mind, though, that changes to the table are not reversed 
when an edition is dropped from the database. Also, changes to the data 
are not reversed and should be removed as well to return to the pre-upgraded version.</code></pre>

<h2 id="5-4-Preparation-Enable-Editions"><a href="#5-4-Preparation-Enable-Editions" class="headerlink" title="5.4 Preparation: Enable Editions"></a>5.4 Preparation: Enable Editions</h2><ol>
<li>启动EBR<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">user</span> scott <span class="token keyword">enable</span> editions</code></pre></li>
<li>不能disable这个操作<br>12.1之前是enable整个schema的object为editionable,12.1之后可以指定aditionable为non-editionable.</li>
</ol>
<h2 id="5-4-1-NE-non-editionable-on-E-editionable-Prohibition"><a href="#5-4-1-NE-non-editionable-on-E-editionable-Prohibition" class="headerlink" title="5.4.1 NE(non-editionable) on E(editionable) Prohibition"></a>5.4.1 NE(non-editionable) on E(editionable) Prohibition</h2><p>这句话怎么翻译比较贴切？— It is not possible for noneditionable objects to depend on editionable objects. This is called the NE on E prohibition.<br>user-defined type : 可能就是复合数据类型，由基础数据类型组成</p>
<p>在Oracle数据库12.1之前，当你想对一个schema启用编辑时，你必须解决NE on E的问题。例如，当你有一个user-defined type被用于表的定义时，你就违反了NE on E prohibition。一个用户定义的类型是可编辑的，而一个表永远不能被编辑。当你需要遵守12.1版本之前的zero downtime要求时，不可避免地需要改变你的模式设计。</p>
<p>从Oracle数据库12.1开始，可以通过明确地将某些对象设置为不可编辑来定义对象。这只能在edition-enable之前实现。一旦一个object被设置为不可编辑，并且edition enabled，其状态就会被固定，不能被改变。试图这样做将导致以下异常。</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">ORA<span class="token operator">-</span><span class="token number">38825</span>: The EDITIONABLB property <span class="token keyword">of</span> an editioned object cannot be altered<span class="token punctuation">.</span></code></pre>

<p>演示对某一个用户(账号)启动EBR,分析NE on E prohibition具体例子，<br>创建一个新用户</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">user</span> neone identified <span class="token keyword">by</span> neone
<span class="token operator">/</span>
<span class="token keyword">grant</span> <span class="token keyword">connect</span><span class="token punctuation">,</span><span class="token keyword">create</span> <span class="token keyword">table</span><span class="token punctuation">,</span><span class="token keyword">create</span> <span class="token keyword">type</span> <span class="token keyword">to</span> neone
<span class="token operator">/</span>
<span class="token keyword">alter</span> <span class="token keyword">user</span> neone quota unlimited <span class="token keyword">on</span> users
<span class="token operator">/</span></code></pre>

<p>接着用该账号创建user-defined type</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">type</span> phone_number_ot <span class="token keyword">as</span> object<span class="token punctuation">(</span>
   type_name varchar2 <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span>  phone_number varchar2<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token operator">/</span>
</code></pre>

<p>基于上面的type object创建数据库的表</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">type</span> phone_numbers_tt <span class="token keyword">as</span> <span class="token keyword">table</span> <span class="token keyword">of</span> phone_number_ot
<span class="token operator">/</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> emps<span class="token punctuation">(</span> 
   empno number
<span class="token punctuation">,</span>  phone_numbers phone_numbers_tt
<span class="token punctuation">)</span>
nested <span class="token keyword">table</span> phone_numbers store <span class="token keyword">as</span> phone_numbers_nt
</code></pre>

<p>这时候尝试启动EBR,就会碰到如下问题</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">user</span> neone <span class="token keyword">enable</span> editions
<span class="token operator">/</span>
ERRORat line l:
ORA<span class="token operator">-</span><span class="token number">38819</span>: <span class="token keyword">user</span> NEONE owns one <span class="token operator">or</span> more objects whose <span class="token keyword">type</span> <span class="token operator">is</span> editionableand that have noneditioned dependent objects
</code></pre>
<p>这是因为你的type类型是editionable的，table类型是non-aditionable的，EBR不允许有这样的依赖关系，这样是12.1版本之前必须要该schema的table和source code的设计，12.1之后我们可以实现将NE编程E从而解决这个问题。通过如下可以解决NE on E问题</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
<span class="token keyword">alter</span> <span class="token keyword">type</span> phone_numbers_tt noneditionable
<span class="token operator">/</span>
<span class="token keyword">alter</span> <span class="token keyword">type</span> phone_number_ot noneditionable
<span class="token operator">/</span>
</code></pre>

<p>另外，上面相同的例子，还有有第二种情况，如果是已经启动EBR，然后基于user-defined type创建表就会报错</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
<span class="token keyword">create</span> <span class="token keyword">table</span> emps<span class="token operator">*</span>
ERROR at line <span class="token number">1</span>:
ORA<span class="token operator">-</span><span class="token number">38818</span>: illegal reference <span class="token keyword">to</span> editioned object neone<span class="token punctuation">.</span>PHONE_NUMBBR_OT
</code></pre>
<p>因为第二种情况下neone已经启动了EBR,这时候你也无法把将edtionable的type类型改变为non-aditionable</p>
<p>如果测试，生产环境中真碰到了这个问题，我们该如何的解决这个问题呢?<br>需要我们重新创建type类型，这样才能保证我们成功创建基于type类型的table</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">type</span> phone_numbers_tt
<span class="token operator">/</span>
<span class="token keyword">Type</span> dropped<span class="token punctuation">.</span>
<span class="token keyword">drop</span> <span class="token keyword">type</span> phone_number_ot
<span class="token operator">/</span>
<span class="token keyword">Type</span> dropped<span class="token punctuation">.</span>

<span class="token keyword">create</span> <span class="token operator">or</span> <span class="token keyword">replace</span> noneditionable <span class="token keyword">type</span> phone_number_ot <span class="token keyword">as</span> object
<span class="token punctuation">(</span> type_name varchar2 <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> phone_number varchar2 <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token operator">/</span>
<span class="token keyword">Type</span> created

<span class="token keyword">create</span> <span class="token operator">or</span> <span class="token keyword">replace</span> noneditionable <span class="token keyword">type</span> phone_numbers_tt <span class="token keyword">as</span> <span class="token keyword">table</span> <span class="token keyword">of</span> phone_number_ot
<span class="token operator">/</span>
<span class="token keyword">Type</span> created<span class="token punctuation">.</span>

<span class="token keyword">create</span> <span class="token keyword">table</span> emps<span class="token punctuation">(</span>
   empno number
<span class="token punctuation">,</span>  phone_numbers phone_numbers_tt
<span class="token punctuation">)</span>
nested <span class="token keyword">table</span> phone_numbers store <span class="token keyword">as</span> phone_numbers_nt
<span class="token operator">/</span>

<span class="token keyword">Table</span> created
</code></pre>

<p>现在总结如下:</p>
<ol>
<li>如果数据库中存在NE on E的情况，在12.1之前是启动不了EBR，需要改设计</li>
<li>在12.1之前版本启动了EBR,那么在之后的表设计当中就要避开NE on E的问题</li>
<li>如果真出了NE on E的问题，可以通过重新创建type,然后重新创建表来解决</li>
</ol>
<p>遗留问题尚待解决:</p>
<ol>
<li>如果你的架构中使用ogg，data guard，RAC等等oracle系的组件，<br>要如何保证他们不停机维护，也要把他们考虑进去</li>
</ol>
<h2 id="5-4-2-Create-a-new-edition"><a href="#5-4-2-Create-a-new-edition" class="headerlink" title="5.4.2 Create a new edition"></a>5.4.2 Create a new edition</h2><p>因为用户SCOTT启用了edition，所以我们可以创建一个额外的edition。版本之间有一个层次关系，其中一个edition总是有一个父edition这里唯一的例外是ORA$BASE，或者当这个edition最终被删除时，是层次结构中的下一个版本——根edition。<br>为了创建一个新版本，需要系统权限<code>create ANY edition</code>:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">create</span> <span class="token keyword">any</span> edition <span class="token keyword">on</span> scott</code></pre>

<p>在创建版本之前，还需要将用作父版本的版本上的USE特权。一个版本总是作为另一个版本的子版本创建。创建版本时，会自动授予USE对象特权。USE权限也可以单独授予，如下面的代码示例所示:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">use</span> <span class="token keyword">on</span> edition <span class="token operator">&lt;</span>edition_name<span class="token operator">></span> <span class="token keyword">to</span> <span class="token operator">&lt;</span><span class="token keyword">user</span><span class="token operator">></span></code></pre>

<p>这里，<code>&lt;edition_name&gt;</code>和<code>&lt;user&gt;</code>需要用edition的名称和你想授予权限的用户来代替。<br>为了删除根edition或leaf edition，需要有<code>DROP ANY EDITION</code>系统权限。</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">drop</span> <span class="token keyword">any</span> edition <span class="token keyword">to</span> scott</code></pre>

<p>当你连接到一个数据库时，可以通过使用ALTER语句来改变版本，比如在下一个例子中，其中<code>&lt;edition_name&gt;</code>是指应该改成你想改成的版本。</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">session</span> <span class="token keyword">set</span> edition <span class="token operator">=</span><span class="token operator">&lt;</span>edition_name<span class="token operator">></span></code></pre>
<p>请记住，如果application有未完成的事务，这时候是不用change你的edition,否则你将会碰到如下error。</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">session</span> <span class="token keyword">set</span> edition <span class="token operator">=</span>r2
error:
ora<span class="token operator">-</span><span class="token number">38814</span>:<span class="token keyword">alter</span> <span class="token keyword">session</span> <span class="token keyword">set</span> edition must be <span class="token keyword">first</span> statement <span class="token keyword">of</span> <span class="token keyword">transaction</span>
</code></pre>

<h2 id="5-5-Complexity-levels"><a href="#5-5-Complexity-levels" class="headerlink" title="5.5 Complexity levels"></a>5.5 Complexity levels</h2><p>使用EBR包括了多层复杂因素<br>first level : PLSQL object结构change,有哪些在edition之间<br>second level : table struct change among edition<br>在同一时间不需要维护多个版本的edition因为在将来所有的user都会使用post-upgrade edition<br>third level : complex level is where you do have table structure changes and the users need to access multiple editions at the same time ,thus keeping data in sync between multiple editions.</p>
<h3 id="5-5-1-replace-PLSQL-code"><a href="#5-5-1-replace-PLSQL-code" class="headerlink" title="5.5.1 replace PLSQL code"></a>5.5.1 replace PLSQL code</h3><p>接下来阐述了在不同edition之间，不同的functionality可以有相同的名字<br>下面sql可以查看当前edition名字</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> sys_context<span class="token punctuation">(</span><span class="token string">'userenv'</span><span class="token punctuation">,</span>
                   <span class="token string">'current_edition_name'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token string">"current_edition"</span><span class="token keyword">from</span> dual<span class="token punctuation">;</span></code></pre>
<p>也可以通过<code>show edition</code>来查询当前edition.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/11/oracle/Real_World_SQL_and_PLSQL/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/11/oracle/Oracle_EBR/"
                            aria-label=": Edition-Based Redefinition Technical Deep Dive"
                        >
                            Edition-Based Redefinition Technical Deep Dive
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-11T12:13:46+08:00">
	
		    Oct 11, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/oracle/">oracle</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>当应用程序的数据库组件在应用程序升级过程中被更新时，大型的关键的应用程序可能会经历几十个小时，甚至更长的停机时间。app的数据库组件在应用程序升级期间进行更新。Oracle数据库推出了基于版本的重新定义（EBR），这是一项革命性的功能，可以在不间断的情况下在线升级应用程序。革命性的功能，它允许在线应用升级，并保证应用的不间断可用性。</p>
<p>EBR的功能是同时维护两个版本的应用程序。当升级的安装完成后。<br>升级前(pre-upgrade application)的应用程序和升级后(post-upgrade application)<br>的应用程序可以同时使用。因此，一个现有的会话可以 继续使用升级前的应用程序，直到<br>其用户决定结束它；而所有新的会话可以使用升级后的应用程序。在所有会话与它断开连接后，<br>升级前的应用程序就可以退役了。换句话说，该 应用程序作为一个整体享有从升级前版本到<br>升级后版本的热迁移。</p>
<p>为了利用这种能力，应用程序的数据库后端必须通过一些一次性的schema改变来启用EBR。<br>另外，<strong>执行应用程序升级的脚本必须以使用EBR功能的方式来编写</strong>。因此，EBR的采用和后续使用是开发车的事情。</p>
<p>为了实现在线应用升级2，必须满足以下条件。</p>
<ul>
<li><p>改变后的数据库对象的安装不能影响到升级前应用程序的实时用户。</p>
</li>
<li><p>升级前应用程序的用户所做的交易必须反映在升级后的应用程序中。</p>
</li>
<li><p>升级后应用程序的用户进行的交易必须反映在升级前的应用程序中。</p>
</li>
</ul>
<p>Oracle数据库通过一种称为基于版本的重新定义（EBR）的革命性功能实现了这一点。</p>
<p>Using EBR:</p>
<ul>
<li><p>代码修改是在新版本的隐私中安装的。</p>
</li>
<li><p>数据的改变是通过只写入新的列或新的表来实现的，而旧版本是看不到的。这是<br>这是通过一个编辑视图来实现的，该视图将一个表的不同投影暴露在每个版本中，因此每个版本只看到自己的列。<br>看到自己的列。</p>
</li>
<li><p>跨版本触发器将旧版本的数据变化传播到新版本的公共列中，或者（在hot-rollover）反之亦然。</p>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/11/oracle/Oracle_EBR/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"
                            aria-label=": go语言圣经"
                        >
                            go语言圣经
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-08T14:02:11+08:00">
	
		    Oct 08, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#1-%E5%85%A5%E9%97%A8">1. 入门</a></li>
<li><a href="#2-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84">2. 程序结构</a><ul>
<li><a href="#21-%E5%91%BD%E5%90%8D">2.1 命名</a></li>
<li><a href="#22-%E5%A3%B0%E6%98%8E">2.2 声明</a></li>
<li><a href="#23-%E5%8F%98%E9%87%8F">2.3 变量</a><ul>
<li><a href="#231-%E7%AE%80%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">2.3.1 简短变量声明</a></li>
<li><a href="#232-%E6%8C%87%E9%92%88">2.3.2 指针</a></li>
<li><a href="#233-new%E5%87%BD%E6%95%B0">2.3.3 new函数</a></li>
<li><a href="#234-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">2.3.4. 变量的生命周期</a></li>
</ul>
</li>
<li><a href="#24-%E8%B5%8B%E5%80%BC">2.4 赋值</a><ul>
<li><a href="#241-%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC">2.4.1 元组赋值</a></li>
</ul>
</li>
<li><a href="#25-%E7%B1%BB%E5%9E%8B">2.5 类型</a></li>
<li><a href="#26-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6">2.6 包和文件</a></li>
<li><a href="#27-%E4%BD%9C%E7%94%A8%E5%9F%9F">2.7. 作用域</a></li>
</ul>
</li>
<li><a href="#3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">3.基础数据类型</a><ul>
<li><a href="#31-%E6%95%B4%E5%9E%8B">3.1 整型</a></li>
<li><a href="#32-%E6%B5%AE%E7%82%B9%E6%95%B0">3.2 浮点数</a></li>
<li><a href="#33-%E5%A4%8D%E6%95%B0">3.3 复数</a></li>
<li><a href="#34-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">3.4 布尔类型</a></li>
<li><a href="#35-%E5%AD%97%E7%AC%A6%E4%B8%B2">3.5 字符串</a></li>
</ul>
</li>
<li><a href="#4-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4. 复合数据类型</a><ul>
<li><a href="#41-%E6%95%B0%E7%BB%84">4.1 数组</a></li>
<li><a href="#42-slice">4.2 slice</a><ul>
<li><a href="#421-append%E5%87%BD%E6%95%B0">4.2.1 append函数</a></li>
</ul>
</li>
<li><a href="#43-map">4.3 Map</a></li>
<li><a href="#44-%E7%BB%93%E6%9E%84%E4%BD%93">4.4 结构体</a><ul>
<li><a href="#441-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E5%80%BC">4.4.1 结构体字面值</a></li>
<li><a href="#442-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%AF%94%E8%BE%83">4.4.2 结构体的比较</a></li>
<li><a href="#443-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98">4.4.3 结构体嵌入和匿名成员</a></li>
</ul>
</li>
<li><a href="#45-json%E5%AD%97%E7%AC%A6%E4%B8%B2">4.5 json字符串</a></li>
<li><a href="#46-%E6%96%87%E6%9C%AC%E5%92%8Chtml%E6%A8%A1%E6%9D%BF">4.6 文本和HTML模板</a></li>
</ul>
</li>
<li><a href="#5-%E5%87%BD%E6%95%B0">5. 函数</a><ul>
<li><a href="#51-%E9%94%99%E8%AF%AF">5.1 错误</a></li>
<li><a href="#52-%E5%87%BD%E6%95%B0%E5%80%BC">5.2 函数值</a></li>
<li><a href="#53-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">5.3 匿名函数</a></li>
<li><a href="#54-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">5.4 可变参数</a></li>
<li><a href="#55-defer%E5%87%BD%E6%95%B0">5.5 defer函数</a></li>
<li><a href="#56-panic%E5%BC%82%E5%B8%B8">5.6 panic异常</a></li>
<li><a href="#57-recovery%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">5.7 Recovery捕获异常</a></li>
</ul>
</li>
<li><a href="#6-%E6%96%B9%E6%B3%95">6. 方法</a><ul>
<li><a href="#61-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E">6.1 方法声明</a></li>
<li><a href="#62-%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">6.2 基于指针对象的方法</a></li>
<li><a href="#63-%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B">6.3. 通过嵌入结构体来扩展类型</a></li>
<li><a href="#64-%E5%B0%81%E8%A3%85">6.4 封装</a></li>
</ul>
</li>
<li><a href="#7-%E6%8E%A5%E5%8F%A3">7. 接口</a><ul>
<li><a href="#71-%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A">7.1. 接口约定</a></li>
<li><a href="#72-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B">7.2 接口类型</a></li>
<li><a href="#73-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6">7.3 实现接口的条件</a></li>
<li><a href="#74-flagvalue%E6%8E%A5%E5%8F%A3">7.4 flag.Value接口</a></li>
<li><a href="#75-%E6%8E%A5%E5%8F%A3%E5%80%BC">7.5 接口值</a><ul>
<li><a href="#751-%E8%AD%A6%E5%91%8A%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AFnil%E6%8E%A5%E5%8F%A3">7.5.1. 警告:一个包含nil指针的接口不是nil接口</a></li>
</ul>
</li>
<li><a href="#76-sortinterface%E6%8E%A5%E5%8F%A3">7.6. sort.Interface接口</a></li>
<li><a href="#77-httphandler%E6%8E%A5%E5%8F%A3">7.7. http.Handler接口</a></li>
<li><a href="#78-error%E6%8E%A5%E5%8F%A3">7.8. error接口</a></li>
<li><a href="#79-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">7.9. 类型断言</a></li>
<li><a href="#710-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">7.10. 基于类型断言区别错误类型</a></li>
<li><a href="#711-any%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%B3%9B%E5%9E%8B">7.11. any关键字与泛型</a></li>
</ul>
</li>
<li><a href="#8-goroutines%E5%92%8Cchannels">8. Goroutines和Channels</a><ul>
<li><a href="#81-goroutine">8.1 goroutine</a></li>
<li><a href="#82-channel">8.2 channel</a></li>
<li><a href="#83-%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">8.3 基于select的多路复用</a></li>
<li><a href="#84-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%80%E5%87%BA">8.4. 并发的退出</a></li>
</ul>
</li>
<li><a href="#9-%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91">9. 基于共享变量的并发</a><ul>
<li><a href="#91-syncmutex%E4%B8%8Esyncrmutex%E4%BA%92%E6%96%A5%E9%94%81">9.1 sync.Mutex与sync.RMutex互斥锁</a></li>
<li><a href="#92-synconce%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96">9.2 sync.Once惰性初始化</a></li>
<li><a href="#93-synccond%E7%9A%84%E4%BD%BF%E7%94%A8">9.3 sync.Cond的使用</a></li>
<li><a href="#94-goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B">9.4. Goroutines和线程</a></li>
</ul>
</li>
<li><a href="#10-%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7">10. 包和工具</a></li>
<li><a href="#11-%E6%B5%8B%E8%AF%95">11. 测试</a><ul>
<li><a href="#111-go-test">11.1 go test</a></li>
<li><a href="#112-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87">11.2 测试覆盖率</a></li>
<li><a href="#113-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">11.3 基准测试</a></li>
<li><a href="#114-%E5%88%A8%E6%9E%90">11.4 刨析</a></li>
<li><a href="#115-%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0">11.5 示例函数</a></li>
</ul>
</li>
<li><a href="#12-appendindex">12. appendIndex</a></li>
</ul>
<h1 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h1><h1 id="2-程序结构"><a href="#2-程序结构" class="headerlink" title="2. 程序结构"></a>2. 程序结构</h1><h2 id="2-1-命名"><a href="#2-1-命名" class="headerlink" title="2.1 命名"></a>2.1 命名</h2><table>
<thead>
<tr>
<th>功能性关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>退出循环</td>
</tr>
<tr>
<td>case</td>
<td>switch case, select case</td>
</tr>
<tr>
<td>chan</td>
<td></td>
</tr>
<tr>
<td>const</td>
<td></td>
</tr>
<tr>
<td>continue</td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
</tr>
<tr>
<td>defer</td>
<td></td>
</tr>
<tr>
<td>else</td>
<td></td>
</tr>
<tr>
<td>fallthrough</td>
<td></td>
</tr>
<tr>
<td>for</td>
<td></td>
</tr>
<tr>
<td>func</td>
<td></td>
</tr>
<tr>
<td>go</td>
<td></td>
</tr>
<tr>
<td>if</td>
<td></td>
</tr>
<tr>
<td>import</td>
<td></td>
</tr>
<tr>
<td>interface</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td></td>
</tr>
<tr>
<td>package</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td></td>
</tr>
<tr>
<td>return</td>
<td></td>
</tr>
<tr>
<td>select</td>
<td></td>
</tr>
<tr>
<td>struct</td>
<td></td>
</tr>
<tr>
<td>switch</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td></td>
</tr>
<tr>
<td>var</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内建常量</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td></td>
</tr>
<tr>
<td>iota</td>
<td></td>
</tr>
<tr>
<td>nil</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内建类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td></td>
</tr>
<tr>
<td>int8</td>
<td></td>
</tr>
<tr>
<td>int16</td>
<td></td>
</tr>
<tr>
<td>int32</td>
<td></td>
</tr>
<tr>
<td>int64</td>
<td></td>
</tr>
<tr>
<td>uint</td>
<td></td>
</tr>
<tr>
<td>uint8</td>
<td></td>
</tr>
<tr>
<td>uint16</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td></td>
</tr>
<tr>
<td>uint64</td>
<td></td>
</tr>
<tr>
<td>uintptr</td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td></td>
</tr>
<tr>
<td>float64</td>
<td></td>
</tr>
<tr>
<td>complex128</td>
<td></td>
</tr>
<tr>
<td>complex64</td>
<td></td>
</tr>
<tr>
<td>bool</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>rune</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td></td>
</tr>
<tr>
<td>error</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>make</td>
<td></td>
</tr>
<tr>
<td>len</td>
<td></td>
</tr>
<tr>
<td>cap</td>
<td></td>
</tr>
<tr>
<td>new</td>
<td></td>
</tr>
<tr>
<td>append</td>
<td></td>
</tr>
<tr>
<td>copy</td>
<td></td>
</tr>
<tr>
<td>close</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td></td>
</tr>
<tr>
<td>complex</td>
<td></td>
</tr>
<tr>
<td>real</td>
<td></td>
</tr>
<tr>
<td>imag</td>
<td></td>
</tr>
<tr>
<td>panic</td>
<td></td>
</tr>
<tr>
<td>recover</td>
<td></td>
</tr>
</tbody></table>
<p>Go推荐使用<code>驼峰式</code>命名:</p>
<ul>
<li>一个名字必须以一个字母（Unicode字母）或下划线开头,下划线开头可能表示<code>私有的</code></li>
<li>后面可以跟任意数量的字母、数字或下划线。</li>
<li>名字的开头字母的大小写决定了名字在包外的可见性.如果一个名字是大写字母开头的(译注必须是 在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将是导出的,也就是说可以被外部的包访问,例如<code>fmt.Printf</code>,就可以在包外访问</li>
</ul>
<h2 id="2-2-声明"><a href="#2-2-声明" class="headerlink" title="2.2 声明"></a>2.2 声明</h2><p>Go语言主要有四种类型的声明语句:</p>
<ul>
<li>var</li>
<li>const</li>
<li>type</li>
<li>func</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

const boilingF &#x3D; 212.0
const var a &#x3D; 0

func main() &#123;
    var f &#x3D; boilingF
    var c &#x3D; (f - 32) * 5 &#x2F; 9
    fmt.Printf(&quot;boiling point &#x3D; %g°F or %g°C\n&quot;, f, c)
    &#x2F;&#x2F; Output:
    &#x2F;&#x2F; boiling point &#x3D; 212°F or 100°C
&#125;</code></pre>

<p><code>boilingF</code>是包一级的变量在包内可以访问。如果函数没有返回值，那么返回值列表是省略的。函数顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者</p>
<h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><p>常规声明变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var 变量名字 类型 &#x3D; 表达式</code></pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">var i ,j , k int &#x2F;&#x2F; 都是int类型
var b,f,s &#x3D;true , 2.3 ,&quot;four&quot; &#x2F;&#x2F;bool , float 64,string
var f, err &#x3D; os.Open(name) &#x2F;&#x2F; os.Open returns a file and an error</code></pre>

<ul>
<li>在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。</li>
<li><code>类型</code>和<code>表达式</code>都可以缺省,如果是<code>类型</code>缺省那么就可以通过<code>表达式</code>进行推断,如果是表达式缺省那么就会赋类型的<code>零</code>值,如果是自定义类型或者是引用类型就是内部各个字段都是<code>零</code>值.Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态</li>
</ul>
<h3 id="2-3-1-简短变量声明"><a href="#2-3-1-简短变量声明" class="headerlink" title="2.3.1 简短变量声明"></a>2.3.1 简短变量声明</h3>  <pre class="language-golang" data-language="golang"><code class="language-golang">anim :&#x3D; gif.GIF&#123;LoopCount: nframes&#125; &#x2F;&#x2F;聚合类型,引用类型
freq :&#x3D; rand.Float64() * 3.0 &#x2F;&#x2F; float
t :&#x3D; 0.0  &#x2F;&#x2F;float
f, err :&#x3D; os.Open(name) &#x2F;&#x2F;通过函数进行声明，并初始化
if err !&#x3D; nil &#123;
    return err
&#125;</code></pre>

<ul>
<li>例子1中声明的err是重复,第二个简短声明符的err就是赋值操作，注意该操作是在变量相同作用例子2中这种情况编译不通过,至少有一个是新声明的.[ 实际工程中尽量不要出现例子2 ]</li>
</ul>
  <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;例子1
in, err :&#x3D; os.Open(infile)
&#x2F;&#x2F; ...
out, err :&#x3D; os.Create(outfile)
&#x2F;&#x2F;例子2
f, err :&#x3D; os.Open(infile)
&#x2F;&#x2F; ...
f, err :&#x3D; os.Create(outfile) &#x2F;&#x2F; compile error: no new variables</code></pre>


<h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><ul>
<li><p><code>任何类型</code>的指针的<code>零值</code>都是<code>nil</code>。如果p指向某个有效变量，那么<code>p != nil</code>测试为<code>真</code>。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>
</li>
<li><p>返回局部变量地址也是安全的。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func incr(p *int) int &#123;
    *p++ &#x2F;&#x2F; 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
    return *p
&#125;
v :&#x3D; 1
incr(&amp;v)              &#x2F;&#x2F; side effect: v is now 2
fmt.Println(incr(&amp;v)) &#x2F;&#x2F; &quot;3&quot; (and v is 3)</code></pre>
</li>
<li><p>在flag包中,应用到了<code>指针</code>技术</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main
import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;strings&quot;
)
var n &#x3D; flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)
var sep &#x3D; flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)

func main() &#123;
    flag.Parse() &#x2F;&#x2F;解析标志性参数位
    fmt.Print(strings.Join(flag.Args(), *sep)) &#x2F;&#x2F;flag.Args() 解析非标志参数位
    if !*n &#123;
        fmt.Println()
    &#125;
&#125;</code></pre>
<ul>
<li>在此代码例子中使用<code>flag.Args()</code>解析非标志参数位,<code>flag.Parse()</code>解析标志性参数位,to be continue</li>
</ul>
</li>
</ul>
<h3 id="2-3-3-new函数"><a href="#2-3-3-new函数" class="headerlink" title="2.3.3 new函数"></a>2.3.3 new函数</h3><p>  表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T(返回的是指针)</p>
<ul>
<li>每次new()返回新的变量地址,比如new(int)</li>
</ul>
<h3 id="2-3-4-变量的生命周期"><a href="#2-3-4-变量的生命周期" class="headerlink" title="2.3.4. 变量的生命周期"></a>2.3.4. 变量的生命周期</h3><ul>
<li>包一级的声明会伴随程序整个声明周期,但是函数内部则是动态,会被GC回收</li>
<li>函数的<code>参数变量</code>(参数列表)和<code>返回值变量</code>都是<code>局部变量</code>。它们在函数每次被调用的时候创建,下面循环的<code>变量t</code>就是动态创建,用完就扔  <pre class="language-golang" data-language="golang"><code class="language-golang">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;
  x :&#x3D; math.Sin(t)
  y :&#x3D; math.Sin(t*freq + phase)
  img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
      blackIndex)
&#125;</code></pre></li>
</ul>
<p>  下面也是合法的</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;
  x :&#x3D; math.Sin(t)
  y :&#x3D; math.Sin(t*freq + phase)
  img.SetColorIndex(
      size+int(x*size+0.5), size+int(y*size+0.5),
      blackIndex, &#x2F;&#x2F; 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
  )               &#x2F;&#x2F; 小括弧另起一行缩进，和大括弧的风格保存一致
&#125;</code></pre>

<ul>
<li><code>局部变量逃逸</code>.因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。<code>编译器</code>会自动选择在<code>栈</code>上还是在<code>堆</code>上分配局部变量的存储空间,代码如下,<code>f</code>函数里的<code>x变量</code>必须在<code>堆</code>上分配,因为它在函数退出后依然可以通过包一级的<code>global变量</code>找到,<code>g</code>函数在栈上分配<code>*y</code>内存空间  <pre class="language-golang" data-language="golang"><code class="language-golang">var global *int

func f() &#123;
    var x int
    x &#x3D; 1
    global &#x3D; &amp;x
&#125;

func g() &#123;
    y :&#x3D; new(int)
    *y &#x3D; 1
&#125;
</code></pre></li>
<li>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期,比如,如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。</li>
</ul>
<h2 id="2-4-赋值"><a href="#2-4-赋值" class="headerlink" title="2.4 赋值"></a>2.4 赋值</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">x &#x3D; 1                       &#x2F;&#x2F; 命名变量的赋值
*p &#x3D; true                   &#x2F;&#x2F; 通过指针间接赋值
person.name &#x3D; &quot;bob&quot;         &#x2F;&#x2F; 结构体字段赋值
count[x] &#x3D; count[x] * scale &#x2F;&#x2F; 数组、slice或map的元素赋值
</code></pre>

<h3 id="2-4-1-元组赋值"><a href="#2-4-1-元组赋值" class="headerlink" title="2.4.1 元组赋值"></a>2.4.1 元组赋值</h3>  <pre class="language-golang" data-language="golang"><code class="language-golang">x,y &#x3D; y,x; &#x2F;&#x2F;不限制数量
a[i], a[j] &#x3D; a[j], a[i];
&#x2F;&#x2F;额外的布尔类型表达某种错误类型
v, ok &#x3D; m[key]             &#x2F;&#x2F; map lookup
v, ok &#x3D; x.(T)              &#x2F;&#x2F; type assertion
v, ok &#x3D; &lt;-ch               &#x2F;&#x2F; channel receive
&#x2F;&#x2F;只做检查
v &#x3D; m[key]                &#x2F;&#x2F; map查找，失败时返回零值
v &#x3D; x.(T)                 &#x2F;&#x2F; type断言，失败时panic异常
v &#x3D; &lt;-ch                  &#x2F;&#x2F; 管道接收，失败时返回零值（阻塞不算是失败）

_, ok &#x3D; m[key]            &#x2F;&#x2F; map返回2个值
_, ok &#x3D; mm[&quot;&quot;], false     &#x2F;&#x2F; map返回1个值
_ &#x3D; mm[&quot;&quot;]                &#x2F;&#x2F; map返回1个值
&#x2F;&#x2F;复合类型隐式赋值
medals :&#x3D; []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125;
&#x2F;&#x2F;等价写法
medals[0] &#x3D; &quot;gold&quot;
medals[1] &#x3D; &quot;silver&quot;
medals[2] &#x3D; &quot;bronze&quot;</code></pre>
<ul>
<li>对于两个值是否可以用&#x3D;&#x3D;或!&#x3D;进行相等比较的能力也和可赋值能力有关系</li>
</ul>
<h2 id="2-5-类型"><a href="#2-5-类型" class="headerlink" title="2.5 类型"></a>2.5 类型</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">package tempconv

import &quot;fmt&quot;

type Celsius float64    &#x2F;&#x2F; 摄氏温度
type Fahrenheit float64 &#x2F;&#x2F; 华氏温度

const (
    AbsoluteZeroC Celsius &#x3D; -273.15 &#x2F;&#x2F; 绝对零度
    FreezingC     Celsius &#x3D; 0       &#x2F;&#x2F; 结冰点温度
    BoilingC      Celsius &#x3D; 100     &#x2F;&#x2F; 沸水温度
)

func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9&#x2F;5 + 32) &#125;

func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 &#x2F; 9) &#125;
</code></pre>

<ul>
<li>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用</li>
<li><code>Celsius</code>和<code>Fahrenheit</code>是两种不同类型,<code>Celsius(t)</code>或<code>Fahrenheit(t)</code>形式的显式转型,<code>整数</code>-&gt;<code>小数</code>回省略小数部分(CPP在这部分有很详细的讨论)</li>
<li>如果两个值有着不同的类型，则不能直接进行比较</li>
<li>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集后面详细讨论</li>
</ul>
<h2 id="2-6-包和文件"><a href="#2-6-包和文件" class="headerlink" title="2.6 包和文件"></a>2.6 包和文件</h2><ul>
<li><p><code>名字空间</code>每个包都对应一个独立的名字空间,例如，在image包中的Decode函数和在unicode&#x2F;utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问</p>
</li>
<li><p><code>包的导入</code>Go语言的规范并没有定义这些源代码的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。</p>
</li>
<li><p><code>包的初始化</code>。包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的。例如<code>func init() &#123; /* ... */ &#125;</code>,<code>init</code>不能被调用，也不能被声明。包会按照声明的顺序初始化。</p>
</li>
<li><p><code>包的初始化顺序</code>。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了</p>
<p>复杂初始化可以用以下方式</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;可以使用匿名函数处理
var pc [256]byte &#x3D; func() (pc [256]byte) &#123;
  for i :&#x3D; range pc &#123;
      pc[i] &#x3D; pc[i&#x2F;2] + byte(i&amp;1)
  &#125;
  return
&#125;()
</code></pre></li>
</ul>
<h2 id="2-7-作用域"><a href="#2-7-作用域" class="headerlink" title="2.7. 作用域"></a>2.7. 作用域</h2><ul>
<li>不要将作用域和生命周期混为一谈，作用域是指文本域，而生命周期是指运行有效时段</li>
<li>任何在<code>函数</code>外部（也就是包级语法域）声明的名字可以在同一个<code>包</code>的任何源文件中访问的</li>
<li>对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包</li>
<li>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是<br>函数级的作用域</li>
</ul>
<p>几种常见作用域例子</p>
<ul>
<li><p>正常情况下作用域例子</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func f() &#123;&#125;

var g &#x3D; &quot;g&quot;

func main() &#123;
    f :&#x3D; &quot;f&quot;
    fmt.Println(f) &#x2F;&#x2F; &quot;f&quot;; local var f shadows package-level func f
    fmt.Println(g) &#x2F;&#x2F; &quot;g&quot;; package-level var
    fmt.Println(h) &#x2F;&#x2F; compile error: undefined: h
&#125;</code></pre></li>
<li><p>作用域嵌套,函数中可以进行词法域嵌套</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
  x :&#x3D; &quot;hello!&quot;
  for i :&#x3D; 0; i &lt; len(x); i++ &#123;
      x :&#x3D; x[i]
      if x !&#x3D; &#39;!&#39; &#123;
          x :&#x3D; x + &#39;A&#39; - &#39;a&#39;
          fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;上述代码&#96;x[]&#96;和&#96;x + &#39;A&#39; - &#39;a&#39;&#96;都是引用了外部作用域声明的x变量。
&#x2F;&#x2F;再比如下面的例子,有三个不同的x变量，</code></pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化
&#x2F;&#x2F;词法域，一个在for循环体词法域；只有两个块是显式创建的：
func main() &#123;
  x :&#x3D; &quot;hello&quot;
  for _, x :&#x3D; range x &#123;
      x :&#x3D; x + &#39;A&#39; - &#39;a&#39;
      fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)
  &#125;
&#125;</code></pre></li>
<li><p>建隐式词法域,隐式作用域<br>  if和switch语句也会在条件部分创建隐式词法域，代码例子如下.第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if x :&#x3D; f(); x &#x3D;&#x3D; 0 &#123;
  fmt.Println(x)
&#125; else if y :&#x3D; g(x); x &#x3D;&#x3D; y &#123;
    fmt.Println(x, y)
&#125; else &#123;
    fmt.Println(x, y)
&#125;
fmt.Println(x, y) &#x2F;&#x2F; compile error: x and y are not visible here</code></pre>
<p>如果不想提前声明变量还可以选择如下方式，但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if f, err :&#x3D; os.Open(fname); err !&#x3D; nil &#123;
  return err
&#125; else &#123;
    &#x2F;&#x2F; f and err are visible here too
    f.ReadByte()
    f.Close()
&#125;</code></pre></li>
<li><p>屏蔽其他作用域变暗亮<br>cwd在外部已经声明的包级变量，但是:&#x3D;语句还是将cwd和err重新声明为新的局部变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var cwd string

func init() &#123;
    cwd, err :&#x3D; os.Getwd() &#x2F;&#x2F; compile error: unused: cwd
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
&#125;</code></pre>
<p>可以用赋值运算符，就不会屏蔽<code>cwd</code>变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var cwd string

func init() &#123;
    var err error &#x2F;&#x2F;因为是赋值运算符所以需要定义error变量
    cwd, err &#x3D; os.Getwd()
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
&#125;</code></pre></li>
</ul>
<h1 id="3-基础数据类型"><a href="#3-基础数据类型" class="headerlink" title="3.基础数据类型"></a>3.基础数据类型</h1><ul>
<li><p>整型格式控制符</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>整型以二进制方式显示</td>
</tr>
<tr>
<td>%o</td>
<td>整型以八进制方式显示</td>
</tr>
<tr>
<td>%d</td>
<td>整型以十进制方式显示,以锁为例子mutex&#x3D;&amp;((1 0) 0 0 -1073741824 0)</td>
</tr>
<tr>
<td>%x</td>
<td>整型以十六进制方式显示</td>
</tr>
<tr>
<td>%X</td>
<td>整型以十六进制、字母大写方式显示</td>
</tr>
<tr>
<td>%c</td>
<td>相应Unicode码点所表示的字符</td>
</tr>
<tr>
<td>%U</td>
<td>Unicode 字符, Unicode格式：123，等同于 “U+007B”</td>
</tr>
</tbody></table>
</li>
<li><p>浮点数格式控制</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%e</td>
<td>科学计数法,例如 -1234.456e+78</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法,例如 -1234.456E+78</td>
</tr>
<tr>
<td>%f</td>
<td>有小数点而无指数,例如 123.456</td>
</tr>
<tr>
<td>%g</td>
<td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
<tr>
<td>%G</td>
<td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
</tbody></table>
</li>
<li><p>字符串格式化</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串或切片的无解译字节</td>
</tr>
<tr>
<td>%q</td>
<td>双引号围绕的字符串，由Go语法安全地转义</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制，小写字母，每字节两个字符</td>
</tr>
<tr>
<td>%X</td>
<td>十六进制，大写字母，每字节两个字符</td>
</tr>
</tbody></table>
</li>
<li><p>指针格式化</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%p</td>
<td>十六进制表示，前缀 0x</td>
</tr>
</tbody></table>
</li>
<li><p>通用的占位符</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%v</td>
<td>值的默认格式。只输出字段的值，没有字段名字,eg: requestVote RPC&#x3D;{1,1,0,0}</td>
</tr>
<tr>
<td>%+v</td>
<td>类似%v，但输出结构体时会添加字段名,以RWMutex为例子, &amp;{w:{state:1 sema:0} writerSem:0 readerSem:0 readerCount:-1073741824 readerWait:0}</td>
</tr>
<tr>
<td>%#v</td>
<td>相应值的Go语法表示,比如地址用十六进制表示,以RWMutex为例子, &amp;sync.RWMutex{w:sync.Mutex{state:1, sema:0x0}, writerSem:0x0, readerSem:0x0, readerCount:-1073741824, readerWait:0}</td>
</tr>
<tr>
<td>%T</td>
<td>相应值的类型的Go语法表示,比如以RWMutex为例子,rf.mu&#x3D;*sync.RWMutex</td>
</tr>
<tr>
<td>%%</td>
<td>百分号,字面上的%,非占位符含义</td>
</tr>
</tbody></table>
</li>
<li><p>控制宽度<br>  宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐</p>
<ul>
<li>字符串控制  <pre class="language-golang" data-language="golang"><code class="language-golang">fmt.Printf(&quot;|%s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 不设置宽度
fmt.Printf(&quot;|%5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度,  默认+， 右对齐
fmt.Printf(&quot;|%-5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度, 左对齐
fmt.Printf(&quot;|%05s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; |000aa|</code></pre></li>
<li>浮点控制  <pre class="language-golang" data-language="golang"><code class="language-golang">a :&#x3D; 54.123456
fmt.Printf(&quot;|%f|&quot;, a)  &#x2F;&#x2F; |54.123456|
fmt.Printf(&quot;|%5.1f|&quot;, a)  &#x2F;&#x2F; | 54.1|
fmt.Printf(&quot;|%-5.1f|&quot;, a) &#x2F;&#x2F; |54.1 |
fmt.Printf(&quot;|%05.1f|&quot;, a) &#x2F;&#x2F; |054.1|</code></pre></li>
</ul>
</li>
</ul>
<h2 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a>3.1 整型</h2><ol>
<li>因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节</li>
<li>Unicode和rune类型是个<code>int32</code>等价的类型,通常用于表示一个Unicode码点</li>
<li>同样byte也是<code>uint8</code>类型的等价类型</li>
<li>还有一种无符号的整数类型<code>uintptr</code>，没有指定具体的bit大小但是足以容纳指针。<code>uintptr</code>类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方</li>
<li><code>int</code>、<code>uint</code>和<code>uintptr</code>是不同类型的兄弟类型。其中<code>int</code>和<code>int32</code>也是不同的类型，即使<code>int</code>的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然</li>
<li>位元素符号</li>
<li><code>int32</code>和<code>int64</code>无法直接四则运算</li>
<li><code>fmt.Printf(&quot;%d %[1]o %#[1]o\n&quot;, o) // &quot;438 666 0666&quot;</code>中的<code>fmt</code>两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀</li>
</ol>
<h2 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2 浮点数"></a>3.2 浮点数</h2><ol>
<li>一个<code>float32</code>类型的浮点数可以提供大约<code>6</code>个十进制数的精度，而<code>float64</code>则可以提供约<code>15</code>个十进制数的精度；通常应该优先使用<code>float64</code>类型，因为<code>float32</code>类型的累计计算误差很容易扩散，并且<code>float32</code>能精确表示的正整数并不是很大</li>
<li>浮点数字面量可以直接书写</li>
<li>很大或者很小的数都可以用科学计数法来书写</li>
<li><code>fmt.Printf(&quot;x = %d e^x = %8.3f\n&quot;, x, math.Exp(float64(x)))</code>8.3是指三个小数精度，8个字符宽度,<code>%g %e %f</code>.</li>
</ol>
<h2 id="3-3-复数"><a href="#3-3-复数" class="headerlink" title="3.3 复数"></a>3.3 复数</h2><p>复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var x complex128 &#x3D; complex(1, 2) &#x2F;&#x2F; 1+2i
var y complex128 &#x3D; complex(3, 4) &#x2F;&#x2F; 3+4i
fmt.Println(x*y)                 &#x2F;&#x2F; &quot;(-5+10i)&quot;
fmt.Println(real(x*y))           &#x2F;&#x2F; &quot;-5&quot;
fmt.Println(imag(x*y))           &#x2F;&#x2F; &quot;10&quot;
</code></pre>

<h2 id="3-4-布尔类型"><a href="#3-4-布尔类型" class="headerlink" title="3.4 布尔类型"></a>3.4 布尔类型</h2><p>布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">i :&#x3D; 0
if b &#123;
    i &#x3D; 1
&#125;</code></pre>

<h2 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a>3.5 字符串</h2><ul>
<li><p>字符串可以用&#x3D;&#x3D;和&lt;进行比较；比较通过逐个字节比较完成的</p>
</li>
<li><p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故<code>s[0] = &#39;L&#39; // compile error: cannot assign to s[0]</code></p>
<ul>
<li>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中</li>
<li>可在字符串面值中写<code>十六进制</code>和<code>八进制</code>数字进行码点转义</li>
<li>原生字面值用反引号(&#96;)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.</li>
<li>通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思</li>
<li>UTF-8 [to be continue]</li>
<li><code>bytes</code>、<code>strings</code>、<code>strconv</code>和<code>unicode</code>包,四个包对字符串处理尤为重要,<code>strings</code>包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能</li>
<li>字符串和数字的转换,<code>strconv</code>包提供这类转换功能</li>
</ul>
</li>
</ul>
<h1 id="4-复合数据类型"><a href="#4-复合数据类型" class="headerlink" title="4. 复合数据类型"></a>4. 复合数据类型</h1><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>数组代码示例</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var a [3]int             &#x2F;&#x2F; array of 3 integers
fmt.Println(a[0])        &#x2F;&#x2F; print the first element
fmt.Println(a[len(a)-1]) &#x2F;&#x2F; print the last element, a[2]

&#x2F;&#x2F; Print the indices and elements.
for i, v :&#x3D; range a &#123;
    fmt.Printf(&quot;%d %d\n&quot;, i, v)
&#125;

&#x2F;&#x2F; Print the elements only.
for _, v :&#x3D; range a &#123;
    fmt.Printf(&quot;%d\n&quot;, v)
&#125;</code></pre>

<p>如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">q :&#x3D; [...]int&#123;1, 2, 3&#125;
fmt.Printf(&quot;%T\n&quot;, q) &#x2F;&#x2F; &quot;[3]int&quot;</code></pre>
<p>上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Currency int

const (
    USD Currency &#x3D; iota &#x2F;&#x2F; 美元
    EUR                 &#x2F;&#x2F; 欧元
    GBP                 &#x2F;&#x2F; 英镑
    RMB                 &#x2F;&#x2F; 人民币
)

symbol :&#x3D; [...]string&#123;USD: &quot;$&quot;, EUR: &quot;€&quot;, GBP: &quot;￡&quot;, RMB: &quot;￥&quot;&#125;

fmt.Println(RMB, symbol[RMB]) &#x2F;&#x2F; &quot;3 ￥&quot;</code></pre>
<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">r :&#x3D; [...]int&#123;99: -1&#125;</code></pre>
<p>数组进行比较是比较所有元素是否相等</p>
<h2 id="4-2-slice"><a href="#4-2-slice" class="headerlink" title="4.2 slice"></a>4.2 slice</h2><p>创建slice变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">v_len :&#x3D; make([]T, len)
v_len_cap :&#x3D; make([]T, len, cap) &#x2F;&#x2F; same as make([]T, cap)[:len]
s :&#x3D; []int&#123;0, 1, 2, 3, 4, 5&#125;</code></pre>
<p><code>slice</code>和<code>数组</code>典型的不同就是<code>slice</code>不指定长度<br><code>bytes.Equal</code>函数来判断两个字节型slice是否相等（[]byte)</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func equal(x, y []string) bool &#123;
    if len(x) !&#x3D; len(y) &#123;
        return false
    &#125;
    for i :&#x3D; range x &#123;
        if x[i] !&#x3D; y[i] &#123;
            return false
        &#125;
    &#125;
    return true
&#125;</code></pre>

<p>slice的nil值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var s []int    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; nil        &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; []int(nil) &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; []int&#123;&#125;    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s !&#x3D; nil</code></pre>

<h3 id="4-2-1-append函数"><a href="#4-2-1-append函数" class="headerlink" title="4.2.1 append函数"></a>4.2.1 append函数</h3><p>(留着放些API东西)</p>
<h2 id="4-3-Map"><a href="#4-3-Map" class="headerlink" title="4.3 Map"></a>4.3 Map</h2><p>其中K对应的key必须是支持&#x3D;&#x3D;比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在<br>创建map</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">ages :&#x3D; make(map[string]int) &#x2F;&#x2F; mapping from strings to ints
ages :&#x3D; map[string]int&#123;
    &quot;alice&quot;:   31,
    &quot;charlie&quot;: 34,
&#125;
&#x2F;&#x2F;访问map数据，也是put操作
ages[&quot;alice&quot;] &#x3D; 32
&#x2F;&#x2F;删除元素
delete(ages, &quot;alice&quot;) &#x2F;&#x2F; remove element ages[&quot;alice&quot;]
&#x2F;&#x2F;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：
_ &#x3D; &amp;ages[&quot;bob&quot;] &#x2F;&#x2F; compile error: cannot take address of map element
</code></pre>
<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import &quot;sort&quot;

var names []string
for name :&#x3D; range ages &#123;
    names &#x3D; append(names, name)
&#125;
sort.Strings(names)
for _, name :&#x3D; range names &#123;
    fmt.Printf(&quot;%s\t%d\n&quot;, name, ages[name])
&#125;</code></pre>

<p>map返回两个值，第一个值是bool类型,false则说明不存在这个key。<br>map的key要求必须是可比较类型，那么如果想用slice作为key就需要写小改动</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var m &#x3D; make(map[string]int)

func k(list []string) string &#123; return fmt.Sprintf(&quot;%q&quot;, list) &#125;

func Add(list []string)       &#123; m[k(list)]++ &#125;
func Count(list []string) int &#123; return m[k(list)] &#125;</code></pre>

<h2 id="4-4-结构体"><a href="#4-4-结构体" class="headerlink" title="4.4 结构体"></a>4.4 结构体</h2><pre class="language-golang" data-language="golang"><code class="language-golang">seen :&#x3D; make(map[string]struct&#123;&#125;) &#x2F;&#x2F; set of strings
&#x2F;&#x2F; ...
if _, ok :&#x3D; seen[s]; !ok &#123;
    seen[s] &#x3D; struct&#123;&#125;&#123;&#125;
    &#x2F;&#x2F; ...first time seeing s...
&#125;</code></pre>

<h3 id="4-4-1-结构体字面值"><a href="#4-4-1-结构体字面值" class="headerlink" title="4.4.1 结构体字面值"></a>4.4.1 结构体字面值</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Point struct&#123; X, Y int &#125;
&#x2F;&#x2F;第一种类型初始化方式
p :&#x3D; Point&#123;1, 2&#125;
&#x2F;&#x2F;第二种初始化方式,如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要
p :&#x3D;Point&#123;x:1,y:2&#125;</code></pre>

<p>非导出结构体或者字段，不能在其他包中进行赋值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package p
type T struct&#123; a, b int &#125; &#x2F;&#x2F; a and b are not exported

package q
import &quot;p&quot;
var _ &#x3D; p.T&#123;a: 1, b: 2&#125; &#x2F;&#x2F; compile error: can&#39;t reference a, b
var _ &#x3D; p.T&#123;1, 2&#125;       &#x2F;&#x2F; compile error: can&#39;t reference a, b</code></pre>

<p>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
func Bonus(e *Employee, percent int) int &#123;
    return e.Salary * percent &#x2F; 100
&#125;</code></pre>

<p>可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">pp :&#x3D; &amp;Point&#123;1, 2&#125;</code></pre>

<p>它和下面的语句是等价的</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">pp :&#x3D; new(Point)
*pp &#x3D; Point&#123;1, 2&#125;</code></pre>

<h3 id="4-4-2-结构体的比较"><a href="#4-4-2-结构体的比较" class="headerlink" title="4.4.2 结构体的比较"></a>4.4.2 结构体的比较</h3><p>首先结构体是可比较类型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
type Point struct&#123; X, Y int &#125;

p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;2, 1&#125;
fmt.Println(p.X &#x3D;&#x3D; q.X &amp;&amp; p.Y &#x3D;&#x3D; q.Y) &#x2F;&#x2F; &quot;false&quot;
fmt.Println(p &#x3D;&#x3D; q)                   &#x2F;&#x2F; &quot;false&quot;
</code></pre>

<h3 id="4-4-3-结构体嵌入和匿名成员"><a href="#4-4-3-结构体嵌入和匿名成员" class="headerlink" title="4.4.3 结构体嵌入和匿名成员"></a>4.4.3 结构体嵌入和匿名成员</h3><pre class="language-golang" data-language="golang"><code class="language-golang">
type Point struct &#123;
    X, Y int
&#125;

type Circle struct &#123;
    Center Point
    Radius int
&#125;

type Wheel struct &#123;
    Circle Circle
    Spokes int
&#125;

var w Wheel
w.Circle.Center.X &#x3D; 8
w.Circle.Center.Y &#x3D; 8
w.Circle.Radius &#x3D; 5
w.Spokes &#x3D; 20</code></pre>

<p>匿名成员，说白了就是只写类型不写名字.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Circle struct &#123;
    Point
    Radius int
&#125;

type Wheel struct &#123;
    Circle
    Spokes int
&#125;

var w Wheel
w.X &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.X &#x3D; 8
w.Y &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.Y &#x3D; 8
w.Radius &#x3D; 5       &#x2F;&#x2F; equivalent to w.Circle.Radius &#x3D; 5
w.Spokes &#x3D; 20
&#x2F;&#x2F;以下初始化是错误的
w &#x3D; Wheel&#123;8, 8, 5, 20&#125;                       &#x2F;&#x2F; compile error: unknown fields
w &#x3D; Wheel&#123;X: 8, Y: 8, Radius: 5, Spokes: 20&#125; &#x2F;&#x2F; compile error: unknown fields</code></pre>

<p>所以我们只能用下面两种方式进行初始化</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
w &#x3D; Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;

w &#x3D; Wheel&#123;
    Circle: Circle&#123;
        Point:  Point&#123;X: 8, Y: 8&#125;,
        Radius: 5,
    &#125;,
    Spokes: 20, &#x2F;&#x2F; NOTE: trailing comma necessary here (and at Radius)
&#125;

fmt.Printf(&quot;%#v\n&quot;, w)
&#x2F;&#x2F; Output:
&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;

w.X &#x3D; 42

fmt.Printf(&quot;%#v\n&quot;, w)
&#x2F;&#x2F; Output:
&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;
</code></pre>
<p>需要注意，但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</p>
<h2 id="4-5-json字符串"><a href="#4-5-json字符串" class="headerlink" title="4.5 json字符串"></a>4.5 json字符串</h2><p><code>json.Marshal</code>包<br>代码例子</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Movie struct &#123;
    Title  string
    Year   int  &#96;json:&quot;released&quot;&#96; &#x2F;&#x2F; 这个tag指定生成json名字
    Color  bool &#96;json:&quot;color,omitempty&quot;&#96;
    Actors []string
&#125;

var movies &#x3D; []Movie&#123;
    &#123;Title: &quot;Casablanca&quot;, Year: 1942, Color: false,
        Actors: []string&#123;&quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot;&#125;&#125;,
    &#123;Title: &quot;Cool Hand Luke&quot;, Year: 1967, Color: true,
        Actors: []string&#123;&quot;Paul Newman&quot;&#125;&#125;,
    &#123;Title: &quot;Bullitt&quot;, Year: 1968, Color: true,
        Actors: []string&#123;&quot;Steve McQueen&quot;, &quot;Jacqueline Bisset&quot;&#125;&#125;,
    &#x2F;&#x2F; ...
&#125;</code></pre>

<h2 id="4-6-文本和HTML模板"><a href="#4-6-文本和HTML模板" class="headerlink" title="4.6 文本和HTML模板"></a>4.6 文本和HTML模板</h2><p>(后面需要时候着重的看)<br><code>text/template和html/template</code>,们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。模板语言支持流程控制语句<br>模板语言demo</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const templ &#x3D; &#96;&#123;&#123;.TotalCount&#125;&#125; issues:
&#123;&#123;range .Items&#125;&#125;----------------------------------------
Number: &#123;&#123;.Number&#125;&#125;
User:   &#123;&#123;.User.Login&#125;&#125;
Title:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;
Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days
&#123;&#123;end&#125;&#125;&#96;</code></pre>

<p><code>|</code> 操作符表示将前一个表达式的结果作为后一个函数的输入.<br>生成模板的输出需要两个处理步骤</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var report &#x3D; template.Must(template.New(&quot;issuelist&quot;).
    Funcs(template.FuncMap&#123;&quot;daysAgo&quot;: daysAgo&#125;).
    Parse(templ))

func main() &#123;
    result, err :&#x3D; github.SearchIssues(os.Args[1:])
    if err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
    if err :&#x3D; report.Execute(os.Stdout, result); err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
&#125;</code></pre>
<p>如果想转化为html则需要编写如下代码</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
import &quot;html&#x2F;template&quot;

var issueList &#x3D; template.Must(template.New(&quot;issuelist&quot;).Parse(&#96;
&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;&#x2F;h1&gt;
&lt;table&gt;
&lt;tr style&#x3D;&#39;text-align: left&#39;&gt;
  &lt;th&gt;#&lt;&#x2F;th&gt;
  &lt;th&gt;State&lt;&#x2F;th&gt;
  &lt;th&gt;User&lt;&#x2F;th&gt;
  &lt;th&gt;Title&lt;&#x2F;th&gt;
&lt;&#x2F;tr&gt;
&#123;&#123;range .Items&#125;&#125;
&lt;tr&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Number&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;&#x2F;td&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.User.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Title&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
&lt;&#x2F;tr&gt;
&#123;&#123;end&#125;&#125;
&lt;&#x2F;table&gt;
&#96;))</code></pre>
<p>注意，html&#x2F;template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text&#x2F;template包的话，这2个issue将会产生错误，其中“&lt;”四个字符将会被当作小于字符“&lt;”处理，同时“<link>”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。</p>
<h1 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h1><p>声明和定义</p>
<ul>
<li><p>switch 控制语句</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">switch cond&#123;
  case a :
      fmt.Printf()
  case b :
      fmt.Printf()
  case c :
      fmt.Printf()
&#125;</code></pre></li>
</ul>
<h2 id="5-1-错误"><a href="#5-1-错误" class="headerlink" title="5.1 错误"></a>5.1 错误</h2><p>通常，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</p>
<p>我们有几种处理错误的策略</p>
<ol>
<li>发生错误时的解析器</li>
</ol>
<p>  发生解析错误后,findLinks 函数构造了一个新的异常信息,既包含了自定义的，也包含了底层解析出错的信息</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">doc, err :&#x3D; html.Parse(resp.Body)
resp.Body.Close()
if err !&#x3D; nil &#123;
    return nil, fmt.Errorf(&quot;parsing %s as HTML: %v&quot;, url,err)
&#125;</code></pre>

<p>  参考宇航局事故调查<br>2. 重试<br>  我们需要限制重试的时间间隔或重试的次数，防止无限制的重试.<br>3. 输出错误信息并结束程序<br>  输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行,对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序<br>  <pre class="language-golang" data-language="golang"><code class="language-golang">if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;
  log.Fatalf(&quot;Site is down: %v\n&quot;, err)
&#125;</code></pre><br>  <code>log.Fatalf</code>代码更简洁，并输出自定义格式信息</p>
<ol start="4">
<li>只是输出错误信息就可以</li>
</ol>
  <pre class="language-golang" data-language="golang"><code class="language-golang">if err :&#x3D; Ping(); err !&#x3D; nil &#123;
  log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)
&#125;
&#x2F;&#x2F;或者标准错误流输出错误信息。

if err :&#x3D; Ping(); err !&#x3D; nil &#123;
    fmt.Fprintf(os.Stderr, &quot;ping failed: %v; networking disabled\n&quot;, err)
&#125;</code></pre>

<ol start="5">
<li>直接忽略掉错误</li>
</ol>
  <pre class="language-golang" data-language="golang"><code class="language-golang">dir, err :&#x3D; ioutil.TempDir(&quot;&quot;, &quot;scratch&quot;)
if err !&#x3D; nil &#123;
    return fmt.Errorf(&quot;failed to create temp dir: %v&quot;,err)
&#125;
&#x2F;&#x2F; ...use temp dir…
os.RemoveAll(dir) &#x2F;&#x2F; ignore errors; $TMPDIR is cleaned periodically</code></pre>
<p>  尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响</p>
<ol start="6">
<li>文件结尾错误</li>
</ol>
<p>io包保证任何由文件结束引起的读取失败都返</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package io

import &quot;errors&quot;

&#x2F;&#x2F; EOF is the error returned by Read when no more input is available.
var EOF &#x3D; errors.New(&quot;EOF&quot;)

in :&#x3D; bufio.NewReader(os.Stdin)
for &#123;
    r, _, err :&#x3D; in.ReadRune()
    if err &#x3D;&#x3D; io.EOF &#123;
        break &#x2F;&#x2F; finished reading
    &#125;
    if err !&#x3D; nil &#123;
        return fmt.Errorf(&quot;read failed:%v&quot;, err)
    &#125;
    &#x2F;&#x2F; ...use r…
&#125;</code></pre>

<h2 id="5-2-函数值"><a href="#5-2-函数值" class="headerlink" title="5.2 函数值"></a>5.2 函数值</h2><ul>
<li><p>函数在golang中也是一种类型，可以被复制给其他变量。  </p>
</li>
<li><p>很熟类型的<code>零</code>值是<code>nil</code>,调用值为nil会引起<code>panic</code>错误  </p>
</li>
<li><p>函数值之间是不可以比较的,也不能用函数值作为map的key</p>
</li>
<li><p>strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func add1(r rune) rune &#123; return r + 1 &#125;

fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) &#x2F;&#x2F; &quot;IBM.:111&quot;
fmt.Println(strings.Map(add1, &quot;VMS&quot;))      &#x2F;&#x2F; &quot;WNT&quot;
fmt.Println(strings.Map(add1, &quot;Admix&quot;))    &#x2F;&#x2F; &quot;Benjy&quot;</code></pre></li>
</ul>
<p>demo示例</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;值得学习
&#x2F;&#x2F; forEachNode针对每个结点x，都会调用pre(x)和post(x)。
&#x2F;&#x2F; pre和post都是可选的。
&#x2F;&#x2F; 遍历孩子结点之前，pre被调用
&#x2F;&#x2F; 遍历孩子结点之后，post被调用
func forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123;
    if pre !&#x3D; nil &#123;
        pre(n)
    &#125;
    for c :&#x3D; n.FirstChild; c !&#x3D; nil; c &#x3D; c.NextSibling &#123;
        forEachNode(c, pre, post)
    &#125;
    if post !&#x3D; nil &#123;
        post(n)
    &#125;
&#125;</code></pre>

<h2 id="5-3-匿名函数"><a href="#5-3-匿名函数" class="headerlink" title="5.3 匿名函数"></a>5.3 匿名函数</h2><p>函数内部定义的函数可以访问整个词法环境，言外之意就是嵌套的函数可以访问外层函数的变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; squares返回一个匿名函数。
&#x2F;&#x2F; 该匿名函数每次被调用时都会返回下一个数的平方。
&#x2F;&#x2F;squares 函数每次都返回一个函数类型-func()int&#123;&#125;
func squares() func() int &#123;
    var x int
    return func() int &#123; &#x2F;&#x2F; 匿名函数
        x++
        return x * x
    &#125;
&#125;
func main() &#123;
    f :&#x3D; squares()
    fmt.Println(f()) &#x2F;&#x2F; &quot;1&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;4&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;9&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;16&quot;
&#125;
&#x2F;&#x2F;通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</code></pre>

<blockquote>
<p>网页抓取的核心问题就是如何遍历图</p>
</blockquote>
<p>警告:捕获迭代变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var rmdirs []func()
for _, d :&#x3D; range tempDirs() &#123;
    dir :&#x3D; d &#x2F;&#x2F; NOTE: necessary!
    os.MkdirAll(dir, 0755) &#x2F;&#x2F; creates parent directories too
    rmdirs &#x3D; append(rmdirs, func() &#123;
        os.RemoveAll(dir)
    &#125;)
&#125;
&#x2F;&#x2F; ...do some work…
for _, rmdir :&#x3D; range rmdirs &#123;
    rmdir() &#x2F;&#x2F; clean up
&#125;
&#x2F;&#x2F; 
var rmdirs []func()
for _, dir :&#x3D; range tempDirs() &#123;
    os.MkdirAll(dir, 0755)
    rmdirs &#x3D; append(rmdirs, func() &#123;
        os.RemoveAll(dir) &#x2F;&#x2F; NOTE: incorrect!
    &#125;)
&#125;
</code></pre>
<p>问题出在了循环变量的作用域,循环变量dir在这个词法块中被声明，每一次迭代都是会不断地更新这个值，被<code>range</code>语句，解决这个问题的办法就是引入同名变量来覆盖其作用域。</p>
<h2 id="5-4-可变参数"><a href="#5-4-可变参数" class="headerlink" title="5.4 可变参数"></a>5.4 可变参数</h2><p>简单的可变参数例子,其实<code>可变参数</code>就是个切片的值传递,<code>interface&#123;&#125;</code>表示函数的最后一个参数可以接收任意类型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func sum(vals ...int) int &#123;
    total :&#x3D; 0
    for _, val :&#x3D; range vals &#123;
        total +&#x3D; val
    &#125;
    return total
&#125;</code></pre>
<p>如果原参数就是切片该怎么传递？可以直接在<code>实参</code>后面加省略号</p>
<h2 id="5-5-defer函数"><a href="#5-5-defer函数" class="headerlink" title="5.5 defer函数"></a>5.5 defer函数</h2><p>在函数执行完成之后，不管是正常退出还是异常退出函数，最后都会被执行</p>
<h2 id="5-6-panic异常"><a href="#5-6-panic异常" class="headerlink" title="5.6 panic异常"></a>5.6 panic异常</h2><p>当panic发生时会在该goroutine上执行defer函数，打印对应的栈信息<br><code>regexp</code>包的使用<br>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
    defer printStack()
    f(3)
&#125;
func printStack() &#123;
    var buf [4096]byte
    n :&#x3D; runtime.Stack(buf[:], false)
    os.Stdout.Write(buf[:n])
&#125;
</code></pre>
<p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p>
<h2 id="5-7-Recovery捕获异常"><a href="#5-7-Recovery捕获异常" class="headerlink" title="5.7 Recovery捕获异常"></a>5.7 Recovery捕获异常</h2><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所</p>
<ul>
<li>语言解析器为例<br>说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">func Parse(input string) (s *Syntax, err error) &#123;
    defer func() &#123;
        if p :&#x3D; recover(); p !&#x3D; nil &#123;
            err &#x3D; fmt.Errorf(&quot;internal error: %v&quot;, p)
        &#125;
    &#125;()
    &#x2F;&#x2F; ...parser...
&#125;</code></pre>


<ul>
<li>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。  </li>
<li>有时我们很难完全遵循规范，举个例子，net&#x2F;http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; soleTitle returns the text of the first non-empty title element
&#x2F;&#x2F; in doc, and an error if there was not exactly one.
&#x2F;&#x2F;防御性panic代码
func soleTitle(doc *html.Node) (title string, err error) &#123;
    type bailout struct&#123;&#125;
    defer func() &#123;
        switch p :&#x3D; recover(); p &#123;
        case nil:       &#x2F;&#x2F; no panic
        case bailout&#123;&#125;: &#x2F;&#x2F; &quot;expected&quot; panic
            err &#x3D; fmt.Errorf(&quot;multiple title elements&quot;)
        default:
            panic(p) &#x2F;&#x2F; unexpected panic; carry on panicking
        &#125;
    &#125;()
    &#x2F;&#x2F; Bail out of recursion if we find more than one nonempty title.
    forEachNode(doc, func(n *html.Node) &#123;
        if n.Type &#x3D;&#x3D; html.ElementNode &amp;&amp; n.Data &#x3D;&#x3D; &quot;title&quot; &amp;&amp;
            n.FirstChild !&#x3D; nil &#123;
            if title !&#x3D; &quot;&quot; &#123;
                panic(bailout&#123;&#125;) &#x2F;&#x2F; multiple titleelements
            &#125;
            title &#x3D; n.FirstChild.Data
        &#125;
    &#125;, nil)
    if title &#x3D;&#x3D; &quot;&quot; &#123;
        return &quot;&quot;, fmt.Errorf(&quot;no title element&quot;)
    &#125;
    return title, nil
&#125;</code></pre>

<h1 id="6-方法"><a href="#6-方法" class="headerlink" title="6. 方法"></a>6. 方法</h1><h2 id="6-1-方法声明"><a href="#6-1-方法声明" class="headerlink" title="6.1 方法声明"></a>6.1 方法声明</h2><ul>
<li>普通函数与接收器方法<br><code>接收器</code>因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。对于一个给定的类型，其内部的方法都必须有唯一的方法名</li>
</ul>
<h2 id="6-2-基于指针对象的方法"><a href="#6-2-基于指针对象的方法" class="headerlink" title="6.2 基于指针对象的方法"></a>6.2 基于指针对象的方法</h2><ul>
<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。</li>
<li>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们下面例子里做的这样  <pre class="language-golang" data-language="golang"><code class="language-golang">func (list *IntList) Sum() int &#123;
if list &#x3D;&#x3D; nil &#123;
    return 0
&#125;
return list.Value + list.Tail.Sum()
&#125;</code></pre>
  如果此时结构体是<code>nil</code>调用对象可能会发生类似于空指针异常的错误</li>
</ul>
<h2 id="6-3-通过嵌入结构体来扩展类型"><a href="#6-3-通过嵌入结构体来扩展类型" class="headerlink" title="6.3. 通过嵌入结构体来扩展类型"></a>6.3. 通过嵌入结构体来扩展类型</h2><ul>
<li><p>方法值<br>  在go语言中，方法是第一公民，这一点在函数式编程中非常实用(maybe)</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;方法值demo
p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;4, 6&#125;

distanceFromP :&#x3D; p.Distance        &#x2F;&#x2F; method value,Distance是结构体方法
fmt.Println(distanceFromP(q))      &#x2F;&#x2F; &quot;5&quot;
var origin Point                   &#x2F;&#x2F; &#123;0, 0&#125;
fmt.Println(distanceFromP(origin)) &#x2F;&#x2F; &quot;2.23606797749979&quot;, sqrt(5)

scaleP :&#x3D; p.ScaleBy &#x2F;&#x2F; method value
scaleP(2)           &#x2F;&#x2F; p becomes (2, 4)
scaleP(3)           &#x2F;&#x2F;      then (6, 12)
scaleP(10)          &#x2F;&#x2F;      then (60, 120)</code></pre>
</li>
<li><p>方法表达式<br>  在面向对象中，当根据哪一个变量来决定调用哪个函数时候,方法表达式就很有用了.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;4, 6&#125;

distance :&#x3D; Point.Distance   &#x2F;&#x2F; method expression
fmt.Println(distance(p, q))  &#x2F;&#x2F; &quot;5&quot;
fmt.Printf(&quot;%T\n&quot;, distance) &#x2F;&#x2F; &quot;func(Point, Point) float64&quot;

scale :&#x3D; (*Point).ScaleBy
scale(&amp;p, 2)
fmt.Println(p)            &#x2F;&#x2F; &quot;&#123;2 4&#125;&quot;
fmt.Printf(&quot;%T\n&quot;, scale) &#x2F;&#x2F; &quot;func(*Point, float64)&quot;
</code></pre></li>
</ul>
<p>practice demo</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Point struct&#123; X, Y float64 &#125;

func (p Point) Add(q Point) Point &#123; return Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;
func (p Point) Sub(q Point) Point &#123; return Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) &#123;
    var op func(p, q Point) Point
    if add &#123;
        op &#x3D; Point.Add
    &#125; else &#123;
        op &#x3D; Point.Sub
    &#125;
    for i :&#x3D; range path &#123;
        &#x2F;&#x2F; Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] &#x3D; op(path[i], offset)
    &#125;
&#125;</code></pre>

<h2 id="6-4-封装"><a href="#6-4-封装" class="headerlink" title="6.4 封装"></a>6.4 封装</h2><p>封装提供了三方面的优点。</p>
<ol>
<li><p>首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可.</p>
</li>
<li><p>第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由</p>
</li>
<li><p>bytes.Buffer这个类型作为例子来考虑</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">
type Buffer struct &#123;
buf     []byte
initial [64]byte
&#x2F;* ... *&#x2F;
&#125;

&#x2F;&#x2F; Grow expands the buffer&#39;s capacity, if necessary,
&#x2F;&#x2F; to guarantee space for another n bytes. [...]
func (b *Buffer) Grow(n int) &#123;
    if b.buf &#x3D;&#x3D; nil &#123;
        b.buf &#x3D; b.initial[:0] &#x2F;&#x2F; use preallocated space initially
    &#125;
    if len(b.buf)+n &gt; cap(b.buf) &#123;
        buf :&#x3D; make([]byte, b.Len(), 2*cap(b.buf) + n)
        copy(buf, b.buf)
        b.buf &#x3D; buf
    &#125;
&#125;
&#x2F;&#x2F; Grow()函数式导出类型，但是stuct的字段不是到处类型</code></pre>
</li>
<li><p>只暴漏关键信息给外部使用者</p>
</li>
</ol>
<h1 id="7-接口"><a href="#7-接口" class="headerlink" title="7. 接口"></a>7. 接口</h1><p>很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用  </p>
<p>只要一个物体能像鸭子一样叫那我们就可以称它为鸭子；只要一个软件能存储和查询数据我们就可以称它为数据库；只要一台机器有洗衣服和甩干的功能我们就可以称它为洗衣机。  </p>
<p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型</p>
<h2 id="7-1-接口约定"><a href="#7-1-接口约定" class="headerlink" title="7.1. 接口约定"></a>7.1. 接口约定</h2><p>例如<code>fmt</code>包</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package fmt

func Fprintf(w io.Writer, format string, args ...interface&#123;&#125;) (int, error)
&#x2F;&#x2F;Printf 最后调用Fprintf 函数
func Printf(format string, args ...interface&#123;&#125;) (int, error) &#123;
    return Fprintf(os.Stdout, format, args...)
&#125;
&#x2F;&#x2F; Sprintf函数最后也是调用Fprintf
func Sprintf(format string, args ...interface&#123;&#125;) string &#123;
    var buf bytes.Buffer
    Fprintf(&amp;buf, format, args...)
    return buf.String()
&#125;</code></pre>

<p><code>Fprintf</code>函数的<code>F</code>说明了文件类型也说明了所有信息要被写入到文件当中，在<code>Printf</code>函数中的第一个参数<code>os.Stdout</code>是<code>*os.File</code>类型实现了<code>io.Writer</code>接口，在<code>Sprintf</code>函数中的第一个参数<code>&amp;buf</code>是一个指向可以写入字节的内存缓冲区也该类型也是实现了<code>io.Writer</code>接口,用户可以自定义一个函数并实现<code>io.Writer</code>接口。<br><strong>LSP里氏替换</strong> : <code>fmt.Fprintf</code>通过使用接口类型<code>io.Writer</code>使得只要调用者只要传入实现了该接口的类型就可以实现自由替换</p>
<details><summary>自定义bytecounter函数，实现计算int转byte长度</summary>

<pre class="language-golang" data-language="golang"><code class="language-golang">
package main

import (
	&quot;fmt&quot;
)

&#x2F;&#x2F;!+bytecounter

type ByteCounter int

func (c *ByteCounter) Write(p []byte) (int, error) &#123;
	*c +&#x3D; ByteCounter(len(p)) &#x2F;&#x2F; convert int to ByteCounter
	return len(p), nil
&#125;

&#x2F;&#x2F;!-bytecounter

func main() &#123;
	&#x2F;&#x2F;!+main
	var c ByteCounter
	c.Write([]byte(&quot;hello&quot;))
	fmt.Println(c) &#x2F;&#x2F; &quot;5&quot;, &#x3D; len(&quot;hello&quot;)

	c &#x3D; 0 &#x2F;&#x2F; reset the counter
	var name &#x3D; &quot;Dolly&quot;
	fmt.Fprintf(&amp;c, &quot;hello, %s&quot;, name)
	fmt.Println(c) &#x2F;&#x2F; &quot;12&quot;, &#x3D; len(&quot;hello, Dolly&quot;)
	&#x2F;&#x2F;!-main
&#125;</code></pre>

</details>

<p>因为它实现了<code>writer</code>接口就可以传入到<code>Fprintf</code>函数中.总结来说，接口约定了包使用者的行为，但是使用者想创建什么样的实例需要他自己去实现。</p>
<h2 id="7-2-接口类型"><a href="#7-2-接口类型" class="headerlink" title="7.2 接口类型"></a>7.2 接口类型</h2><p>通过组合定义接口</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package io
type Reader interface &#123;
    Read(p []byte) (n int, err error)
&#125;
type Closer interface &#123;
    Close() error
&#125;

type ReadWriter interface &#123;
    Reader
    Writer
&#125;
type ReadWriteCloser interface &#123;
    Reader
    Writer
    Closer
&#125;
&#x2F;&#x2F; 另一种命名风格
type ReadWriter interface &#123;
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
&#125;
&#x2F;&#x2F;或者甚至使用一种混合的风格：

type ReadWriter interface &#123;
    Read(p []byte) (n int, err error)
    Writer
&#125;</code></pre>

<h2 id="7-3-实现接口的条件"><a href="#7-3-实现接口的条件" class="headerlink" title="7.3 实现接口的条件"></a>7.3 实现接口的条件</h2><ul>
<li><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer
&#x2F;&#x2F;只实现了Write 方法
w &#x3D; os.Stdout           &#x2F;&#x2F; OK: *os.File has Write method
&#x2F;&#x2F;只实现了Write方法
w &#x3D; new(bytes.Buffer)   &#x2F;&#x2F; OK: *bytes.Buffer has Write method
&#x2F;&#x2F; time.Duration没有Write方法
w &#x3D; time.Second         &#x2F;&#x2F; compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc &#x3D; os.Stdout         &#x2F;&#x2F; OK: *os.File has Read, Write, Close methods
rwc &#x3D; new(bytes.Buffer) &#x2F;&#x2F; compile error: *bytes.Buffer lacks Close method
&#x2F;&#x2F; 这个规则甚至适用于等式右边本身也是一个接口类型
&#x2F;&#x2F; rwc io.ReadWriteCloser
w &#x3D; rwc                 &#x2F;&#x2F; OK: io.ReadWriteCloser has Write method
&#x2F;&#x2F; w 只有Write方法
rwc &#x3D; w                 &#x2F;&#x2F; compile error: io.Writer lacks Close method</code></pre>
</li>
<li></li>
</ul>
<h2 id="7-4-flag-Value接口"><a href="#7-4-flag-Value接口" class="headerlink" title="7.4 flag.Value接口"></a>7.4 flag.Value接口</h2><p>在linux程序中，你会发现很多程序都支持选项，通过带上参数，程序会有很多丰富的功能<br>比如下面demo就是简单的打印选项-period后面的值。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var period &#x3D; flag.Duration(&quot;period&quot;, 1*time.Second, &quot;sleep period&quot;)

func main() &#123;
    flag.Parse()
    fmt.Printf(&quot;Sleeping for %v...&quot;, *period)
    time.Sleep(*period)
    fmt.Println()
&#125;</code></pre>
<p>这里golang的flag包提供了这种功能，我们可以通过实现flag的接口自定义新的标记符号</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package flag

&#x2F;&#x2F; Value is the interface to the value stored in a flag.
type Value interface &#123;
    String() string
    Set(string) error
&#125;
</code></pre>
<p><code>string() string</code>方法格式化标记的值<br><code>Set(string) error</code> 解析它的字符串参数，并更新标记变量的值<br>让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的celsiusFlag类型。<br>注意celsiusFlag内嵌了一个Celsius类型，因此不用实现本身就已经有String方法了。为了实现flag.Value，我们只需要定义Set方法：<br>代码demo如下</p>
<ul>
<li><p>自定义新的标记符号</p>
  <details><summary>温度的转化</summary>

  <pre class="language-golang" data-language="golang"><code class="language-golang">package tempconv

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

type Celsius float64
type Fahrenheit float64

func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9.0&#x2F;5.0 + 32.0) &#125;
func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32.0) * 5.0 &#x2F; 9.0) &#125;

func (c Celsius) String() string &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125;

&#x2F;*
&#x2F;&#x2F;!+flagvalue
package flag

&#x2F;&#x2F; Value is the interface to the value stored in a flag.
type Value interface &#123;
    String() string
    Set(string) error
&#125;
&#x2F;&#x2F;!-flagvalue
*&#x2F;

&#x2F;&#x2F;!+celsiusFlag
&#x2F;&#x2F; *celsiusFlag satisfies the flag.Value interface.
type celsiusFlag struct&#123; Celsius &#125;

func (f *celsiusFlag) Set(s string) error &#123;
    var unit string
    var value float64
    fmt.Sscanf(s, &quot;%f%s&quot;, &amp;value, &amp;unit) &#x2F;&#x2F; no error check needed
    switch unit &#123;
    case &quot;C&quot;, &quot;°C&quot;:
        f.Celsius &#x3D; Celsius(value)
        return nil
    case &quot;F&quot;, &quot;°F&quot;:
        f.Celsius &#x3D; FToC(Fahrenheit(value))
        return nil
    &#125;
    return fmt.Errorf(&quot;invalid temperature %q&quot;, s)
&#125;

&#x2F;&#x2F;!-celsiusFlag

&#x2F;&#x2F;!+CelsiusFlag

&#x2F;&#x2F; CelsiusFlag defines a Celsius flag with the specified name,
&#x2F;&#x2F; default value, and usage, and returns the address of the flag variable.
&#x2F;&#x2F; The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.
func CelsiusFlag(name string, value Celsius, usage string) *Celsius &#123;
    f :&#x3D; celsiusFlag&#123;value&#125;
    flag.CommandLine.Var(&amp;f, name, usage)
    return &amp;f.Celsius
&#125;
&#x2F;&#x2F; main函数
var temp &#x3D; tempconv.CelsiusFlag(&quot;temp&quot;, 20.0, &quot;the temperature&quot;)

func main() &#123;
    flag.Parse()
    fmt.Println(*temp)
&#125;</code></pre>

  </details>

  <details><summary>url解析</summary>
  <pre class="language-golang" data-language="golang"><code class="language-golang">
package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;net&#x2F;url&quot;
)

type URLValue struct &#123;
    URL *url.URL
&#125;

func (v URLValue) String() string &#123;
    if v.URL !&#x3D; nil &#123;
        return v.URL.String()
    &#125;
    return &quot;&quot;
&#125;

func (v URLValue) Set(s string) error &#123;
    if u, err :&#x3D; url.Parse(s); err !&#x3D; nil &#123;
        return err
    &#125; else &#123;
        *v.URL &#x3D; *u
    &#125;
    return nil
&#125;

var u &#x3D; &amp;url.URL&#123;&#125;

func main() &#123;
    fs :&#x3D; flag.NewFlagSet(&quot;ExampleValue&quot;, flag.ExitOnError)
    fs.Var(&amp;URLValue&#123;u&#125;, &quot;url&quot;, &quot;URL to parse&quot;)

    fs.Parse([]string&#123;&quot;-url&quot;, &quot;https:&#x2F;&#x2F;golang.org&#x2F;pkg&#x2F;flag&#x2F;&quot;&#125;)
    fmt.Printf(\&#96;&#123;scheme: %q, host: %q, path: %q&#125;\&#96;, u.Scheme, u.Host, u.Path)

&#125;</code></pre>

  </details></li>
</ul>
<h2 id="7-5-接口值"><a href="#7-5-接口值" class="headerlink" title="7.5 接口值"></a>7.5 接口值</h2><p>概念上讲接口的值,由两部分组成,是其<code>类型(值)</code>和<code>具体类型的值</code>,他们的组合被称为接口的<code>动态类型</code>和<code>动态值</code>.<br>对于像Go语言这种静态类型的语言,类型是编译期的概念;因此一个类型不是一个值。在我们的概念模型中，<br>一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。<br>下面语句中，变量w得到了3个不同的值,他们三个的值都是相同的</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer &#x2F;&#x2F;接口type Write
w &#x3D; os.Stdout &#x2F;&#x2F; 最后返回的是*file类型,func (f *File) Write(b []byte) (n int, err error)
w &#x3D; new(bytes.Buffer) &#x2F;&#x2F; func (b *Buffer) Write(p []byte) (n int, err error)
w &#x3D; nil &#x2F;&#x2F; 动态类型和动态值都为空

var a *bytes.Buffer &#x2F;&#x2F;接口*bytes.Buffer
a &#x3D; nil               &#x2F;&#x2F; 动态类型不为空和动态值都为空
fmt.Printf(&quot;%T\n&quot;, a) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;</code></pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer</code></pre>
<p><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-01.png" alt="7.1"></p>
<p>在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil（图7.1）。</p>
<p>一个接口值基于它的动态类型被描述为<code>nil</code>或<code>!nil</code>，所以这是一个空的接口值。你可以通过使用<code>w==nil</code>或者<code>w!=nil</code>来判断接口值是否为空。调用一个空接口值上的任意方法都会产生<code>panic</code>:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; panic: nil pointer dereference</code></pre>

<text style="font-family:Courier New;color:red">
如果是接口类型定义的变量那么它的动态类型和动态值都是nil，赋nil之后动态类型和动态值也全都是nil值，
但是指针,基本类型和复合类型不会.

<p>类似于java一样，不能没有对象就调用方法，会报空指针异常,上面代码在第三行动态值写为nil<br>这里面有个细节要明白，定义语句var w io.Writer(接口类型),其实是动态类型和动态值都是nil,<br>进行布尔判断的时候才是为nil,w &#x3D; nil 是将动态类型和动态值都设置成nil</p>
</text>

<p>第二个语句将一个<code>*os.File</code>类型的值赋给变量<code>w</code>:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w &#x3D; os.Stdout</code></pre>
<p>这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用<code>io.Writer(os.Stdout)</code>是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为<code>*os.File</code>指针的类型描述符，它的动态值持有<code>os.Stdout</code>的拷贝;这是一个代表处理标准输出的<code>os.File</code>类型变量的指针7.2<br><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-02.png" alt="7.2"></p>
<text style="font-family:Courier New;color:red">
在第二行的赋值操作中,type已经变成`*os.file`类型,其实上面说的很啰嗦,直接就是os.Stdout是具
体的*file类型实现了io.Writer接口
</text>

<p>调用一个包含<code>*os.File</code>类型指针的接口值的<code>Write</code>方法，使得<code>(*os.File).Write</code>方法被调用。这个调用输出“hello”。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;</code></pre>

<p>通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法<code>Write</code>上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，<code>os.Stdout</code>。效果和下面这个直接调用一样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">os.Stdout.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;</code></pre>
<p>第三个语句给接口值赋了一个<code>*bytes.Buffer</code>类型的值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w &#x3D; new(bytes.Buffer)</code></pre>

<p>现在动态类型是<code>*bytes.Buffer</code>,并且动态值是一个指向新分配的缓冲区的指针<br><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-03.png" alt="7.3"><br><code>Write</code>方法的调用也使用了和之前一样的机制:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; writes &quot;hello&quot; to the bytes.Buffers</code></pre>

<p>这次类型描述符是<code>*bytes.Buffer</code>，所以调用了<code>(*bytes.Buffer).Write</code>方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。<br>最后，第四个语句将nil赋给了接口值:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w &#x3D; nil</code></pre>



<p>这个重置将它所有的部分都设为<code>nil</code>值,把变量<code>w</code>恢复到和它之前定义时相同的状态，在图7.1中可以看到。</p>
<p>一个接口值可以持有任意大的动态值。例如,表示时间实例的time.Time类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var x interface&#123;&#125; &#x3D; time.Now()</code></pre>

<text style="font-family:Courier New;color:red">
这里就是创建了一个接口类型的x值,然后可以引用任何类型值
</text>

<p>结果可能和图7.4相似。从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型;具体的实现可能会非常不同）</p>
<p><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-04.png" alt="7.4"></p>
<p>接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是<code>nil</code>值，或者它们的动态类型相同并且动态值也根据这个动态类型的<code>==</code>操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。</p>
<p>然而，如果两个接口值的<code>动态类型</code>相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>
<text style="font-family:Courier New;color:red">

<p>注意到原话’它们的动态类型相同并且动态值,就可以进行<code>==</code>操作’,要保证动态类型相等,动态值相等,则A&#x3D;&#x3D;A<br>那么基本类型相同,复杂类型地址相等</p>
</text>


<p>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型(如基本类型和指针)要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。  </p>
<p>当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用fmt包的%T动作:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
var w io.Writer
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;&lt;nil&gt;&quot;
w &#x3D; os.Stdout
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;*os.File&quot;
w &#x3D; new(bytes.Buffer)
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;
var buf *bytes.Buffer
fmt.Printf(&quot;%T\n&quot;, buf) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;
var x interface&#123;&#125;
fmt.Printf(&quot;%T\n&quot;, x) &#x2F;&#x2F; &quot;&lt;nil&gt;&quot;
&#x2F;&#x2F; 另一个接口值相等的case
w :&#x3D; new(bytes.Buffer)
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;
var buf *bytes.Buffer
fmt.Printf(&quot;%T\n&quot;, buf) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;
w &#x3D; &amp;bytes.Buffer&#123;&#125;
buf &#x3D; &amp;bytes.Buffer&#123;&#125;
w!&#x3D;buf
</code></pre>

<h3 id="7-5-1-警告-一个包含nil指针的接口不是nil接口"><a href="#7-5-1-警告-一个包含nil指针的接口不是nil接口" class="headerlink" title="7.5.1. 警告:一个包含nil指针的接口不是nil接口"></a>7.5.1. 警告:一个包含nil指针的接口不是nil接口</h3><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>
<p>思考下面的程序。当debug变量设置为true时，main函数会将<code>f函数</code>的输出收集到一个bytes.Buffer类型中。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const debug &#x3D; true

func main() &#123;
    var buf *bytes.Buffer
    if debug &#123;
        buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output
    &#125;
    f(buf) &#x2F;&#x2F; NOTE: subtly incorrect!
    if debug &#123;
        &#x2F;&#x2F; ...use buf...
    &#125;
&#125;

&#x2F;&#x2F; If out is non-nil, output will be written to it.
func f(out io.Writer) &#123;
    &#x2F;&#x2F; ...do something...
    if out !&#x3D; nil &#123;
        out.Write([]byte(&quot;done!\n&quot;))
    &#125;
&#125;
</code></pre>

<p>我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if out !&#x3D; nil &#123;
    out.Write([]byte(&quot;done!\n&quot;)) &#x2F;&#x2F; panic: nil pointer dereference
&#125;</code></pre>
<p>当main函数调用函数f时，它给<code>f函数</code>的out参数赋了一个<code>*bytes.Buffer</code>的空指针，所以out的动态值是nil。然而，它的动态类型是<code>*bytes.Buffer</code>，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!&#x3D;nil的结果依然是true。</p>
<p><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-05.png" alt="7.5"></p>
<p>动态分配机制依然决定<code>(*bytes.Buffer).Write</code>的方法会被调用，但是这次的接收者的值是nil。对于一些如<code>*os.File</code>的类型，nil是一个有效的接收者（§6.2.1），但是<code>*bytes.Buffer</code>类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</p>
<p>问题在于尽管一个nil的<code>*bytes.Buffer</code>指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了<code>(*bytes.Buffer).Write</code>方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为<code>io.Writer</code>，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var buf io.Writer &#x2F;&#x2F; 这时候是空指针，没有具体值(对象)
if debug &#123;
    buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output
&#125;
f(buf) &#x2F;&#x2F; OK


&#x2F;&#x2F; If out is non-nil, output will be written to it.
func f(out io.Writer) &#123;
    &#x2F;&#x2F; ...do something...
    if out !&#x3D; nil &#123; &#x2F;&#x2F; 此处判断out为nil
        out.Write([]byte(&quot;done!\n&quot;))
    &#125;
&#125;</code></pre>
<text style="font-family:Courier New;color:red">
总结一句话就是动态类型不为nil,动态值为nil,这个变量也是不要nil
</text>

<h2 id="7-6-sort-Interface接口"><a href="#7-6-sort-Interface接口" class="headerlink" title="7.6. sort.Interface接口"></a>7.6. sort.Interface接口</h2><p>golang提供了<code>sort</code>包帮助进行排序数据,实现排序需要自己实现对应的排序接口.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type byArtist []*Track
func (x byArtist) Len() int           &#123; return len(x) &#125;
func (x byArtist) Less(i, j int) bool &#123; return x[i].Artist &lt; x[j].Artist &#125;
func (x byArtist) Swap(i, j int)      &#123; x[i], x[j] &#x3D; x[j], x[i] &#125;</code></pre>

<p>对于自定义的排序，我们也需要实现排序函数.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;!+customcode
type customSort struct &#123;
	t    []*Track
	less func(x, y *Track) bool
&#125;

func (x customSort) Len() int           &#123; return len(x.t) &#125;
func (x customSort) Less(i, j int) bool &#123; return x.less(x.t[i], x.t[j]) &#125;
func (x customSort) Swap(i, j int)      &#123; x.t[i], x.t[j] &#x3D; x.t[j], x.t[i] &#125;

sort.Sort(customSort&#123;tracks, func(x, y *Track) bool &#123;
		if x.Title !&#x3D; y.Title &#123;
			return x.Title &lt; y.Title
		&#125;
		if x.Year !&#x3D; y.Year &#123;
			return x.Year &lt; y.Year
		&#125;
		if x.Length !&#x3D; y.Length &#123;
			return x.Length &lt; y.Length
		&#125;
		return false
	&#125;&#125;)</code></pre>

<p><code>IntsAreSorted(...interface&#123;&#125;)</code> reports whether the slice x is sorted in increasing order.</p>
<h2 id="7-7-http-Handler接口"><a href="#7-7-http-Handler接口" class="headerlink" title="7.7. http.Handler接口"></a>7.7. http.Handler接口</h2><p>http.Handler的实例</p>
<h2 id="7-8-error接口"><a href="#7-8-error接口" class="headerlink" title="7.8. error接口"></a>7.8. error接口</h2><pre class="language-golang" data-language="golang"><code class="language-golang">
package errors_demo

func New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125;

type errorString struct &#123; text string &#125;

func (e *errorString) Error() string &#123; return e.text &#125;</code></pre>
<p>调用<code>errors.New</code>函数是非常稀少的，因为有一个方便的封装函数<code>fmt.Errorf</code>它还会处理字符串格式化<br>另一个error demo实例</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package syscall

type Errno uintptr &#x2F;&#x2F; operating system error code

var errors &#x3D; [...]string&#123;
    1:   &quot;operation not permitted&quot;,   &#x2F;&#x2F; EPERM
    2:   &quot;no such file or directory&quot;, &#x2F;&#x2F; ENOENT
    3:   &quot;no such process&quot;,           &#x2F;&#x2F; ESRCH
    &#x2F;&#x2F; ...
&#125;

func (e Errno) Error() string &#123;
    if 0 &lt;&#x3D; int(e) &amp;&amp; int(e) &lt; len(errors) &#123;
        return errors[e]
    &#125;
    return fmt.Sprintf(&quot;errno %d&quot;, e)
&#125;

var err error &#x3D; syscall.Errno(2)
fmt.Println(err.Error()) &#x2F;&#x2F; &quot;no such file or directory&quot;
fmt.Println(err)         &#x2F;&#x2F; &quot;no such file or directory&quot;</code></pre>
<p>用有限几个进行描述，并且它满足标准错误接口</p>
<h2 id="7-9-类型断言"><a href="#7-9-类型断言" class="headerlink" title="7.9. 类型断言"></a>7.9. 类型断言</h2><p>语法上它看起来像<code>x.(T)</code>被称为断言类型，这里<code>x</code>表示一个接口的类型和T表示一个类型,详细解释，一个类型断言检查它操作对象的动态类型是否和断言的类型是否匹配,分两种情况</p>
<ul>
<li><p>(T传入的是具体类型，X是动态类型),然后类型断言检查<code>X</code>的动态类型是否和<code>T</code>相同.如果检查成功了类型断言的结果就是<code>X</code>的动态值</p>
</li>
<li><p>(T传入的是接口类型，X是动态类型),然后类型断言检查是否<code>x</code>的动态类型满足T,如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">
var w io.Writer
w &#x3D; os.Stdout   &#x2F;&#x2F;能赋值说明os.Stdout 实现了Write()方法
rw :&#x3D; w.(io.ReadWriter) &#x2F;&#x2F; success: *os.File has both Read and Write,断言w是否实现了接口(io.ReadWriter)的Read和Write接口
w &#x3D; new(ByteCounter)
rw &#x3D; w.(io.ReadWriter) &#x2F;&#x2F; panic: *ByteCounter has no Read method
&#x2F;&#x2F;如果对预期结果只是个判断就可以用第二个返回参数bool.
var w io.Writer &#x3D; os.Stdout
f, ok :&#x3D; w.(*os.File)      &#x2F;&#x2F; success:  ok, f &#x3D;&#x3D; os.Stdout
b, ok :&#x3D; w.(*bytes.Buffer) &#x2F;&#x2F; failure: !ok, b &#x3D;&#x3D; nil
&#x2F;&#x2F; if 后面的w变量不会覆盖外层的w
if w, ok :&#x3D; w.(*os.File); ok &#123;
&#x2F;&#x2F; ...use w...
&#125;</code></pre></li>
</ul>
<h2 id="7-10-基于类型断言区别错误类型"><a href="#7-10-基于类型断言区别错误类型" class="headerlink" title="7.10. 基于类型断言区别错误类型"></a>7.10. 基于类型断言区别错误类型</h2><p>对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。</p>
<p>一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">

package main

import (
	&quot;errors&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;syscall&quot;
)

type PathError struct &#123;
	Op   string
	Path string
	Err  error
&#125;

func (e *PathError) Error() string &#123;
	return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()
&#125;

var ErrNotExist &#x3D; errors.New(&quot;file does not exist&quot;)

&#x2F;&#x2F; IsNotExist returns a boolean indicating whether the error is known to
&#x2F;&#x2F; report that a file or directory does not exist. It is satisfied by
&#x2F;&#x2F; ErrNotExist as well as some syscall errors.
func IsNotExist(err error) bool &#123;
	if pe, ok :&#x3D; err.(*PathError); ok &#123;
		err &#x3D; pe.Err
	&#125;
	return err &#x3D;&#x3D; syscall.ENOENT || err &#x3D;&#x3D; ErrNotExist
&#125;

func main() &#123;
	_, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)
	fmt.Println(os.IsNotExist(err)) &#x2F;&#x2F; &quot;true&quot;
&#125;</code></pre>

<h2 id="7-11-any关键字与泛型"><a href="#7-11-any关键字与泛型" class="headerlink" title="7.11. any关键字与泛型"></a>7.11. any关键字与泛型</h2><p>类型定义时不限制<code>形参类型</code>，在函数调用的时候再指定<code>具体类型</code>.  <code>any</code>其实是<code>interface&#123;&#125;</code>的别名<br>泛型好处:  (1).在编译期间对类型进行检查以提高类型安全(2).通过指定类型消除强制类型转换(3).能够减少代码重复性，提供更通用的功能函数。</p>
<ul>
<li>类型泛型<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

type ListType[T int | int32 | int64 | string] []T

type MapType[K int | int32, V int64 | string] map[K]V

func main() &#123;
    var intList ListType[int]
    intList &#x3D; []int&#123;1, 2, 3&#125;
    fmt.Println(intList)
    strList :&#x3D; ListType[string]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;
    fmt.Println(strList)

    intMap :&#x3D; MapType[int, string]&#123;1: &quot;1&quot;, 2: &quot;2&quot;&#125;
    int32Map :&#x3D; MapType[int32, int64]&#123;1: 2, 3: 4&#125;
    fmt.Println(intMap)
    fmt.Println(int32Map)
&#125;</code></pre>
这里面的T,K,V都是占位符号,<code>ListType</code>只能在那三种类型中选择,同理<code>MapType</code>也是</li>
<li>接口泛型<pre class="language-golang" data-language="golang"><code class="language-golang">type GenericStackInterface[T any] interface &#123;
  Push(element T)
  Pop() T
&#125;</code></pre></li>
<li>泛型函数<pre class="language-golang" data-language="golang"><code class="language-golang">func minInt[T int | int8 | int16 | int32](a, b T) T &#123;
if a &lt; b &#123;
    return a
&#125;
    return b
&#125;

func maxInt[T int | int8 | int16 | int32](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
func Mix(a any) any &#123;

&#125;
&#x2F;&#x2F;还可以简化一下
type Numeric interface &#123;
    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64
&#125;
func min[T Numeric](a, b T) T &#123;
if a &lt; b &#123;
    return a
&#125;
    return b
&#125;

func max[T Numeric](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
&#x2F;&#x2F; go.18内置了数字类型的集合，故可以
import (
&quot;golang.org&#x2F;x&#x2F;exp&#x2F;constraints&quot;
)

func minType[T constraints.Ordered](a, b T) T &#123;
    if a &lt; b &#123;
        return a
    &#125;
    return b
&#125;

func maxType[T constraints.Ordered](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;</code></pre>
如果进入<code>constraints</code>源代码查看其具体代码的话，会发现在 Ordered 类型中也是有各种数字类型组合起来的。但是有一点奇怪的地方就是这里的类型集合中，各种类型前加了一个波浪线~, 表示衍生类型，即使用 type 自定义的类型也可以被识别到，只要底层类型一致即可。比如 ~int 可以包含 int 和 type MyInt int 等多种类型</li>
</ul>
<h1 id="8-Goroutines和Channels"><a href="#8-Goroutines和Channels" class="headerlink" title="8. Goroutines和Channels"></a>8. Goroutines和Channels</h1><p>(多看看本章代码)</p>
<h2 id="8-1-goroutine"><a href="#8-1-goroutine" class="headerlink" title="8.1 goroutine"></a>8.1 goroutine</h2><p>通过代码示例了解<code>goroutine</code>的使用</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
    go spinner(100 * time.Millisecond)
    const n &#x3D; 45
    fibN :&#x3D; fib(n) &#x2F;&#x2F; slow
    fmt.Printf(&quot;\rFibonacci(%d) &#x3D; %d\n&quot;, n, fibN)
&#125;

func spinner(delay time.Duration) &#123;
    for &#123;
        for _, r :&#x3D; range &#96;-\|&#x2F;&#96; &#123;
            fmt.Printf(&quot;\r%c&quot;, r)
            time.Sleep(delay)
        &#125;
    &#125;
&#125;

func fib(x int) int &#123;
    if x &lt; 2 &#123;
        return x
    &#125;
    return fib(x-1) + fib(x-2)
&#125;</code></pre>
<h2 id="8-2-channel"><a href="#8-2-channel" class="headerlink" title="8.2 channel"></a>8.2 channel</h2><p>这里应该还得看一下uber编码规范</p>
<ul>
<li><p>无缓冲channel</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">ch &lt;- x
x &#x3D; &lt;-chan &#x2F;&#x2F;取出元素
&lt;- ch &#x2F;&#x2F;取出，舍弃
close(ch) &#x2F;&#x2F; 关闭chan</code></pre>

<ul>
<li><p>串联channel</p>
</li>
<li><p>单方向channel</p>
</li>
</ul>
</li>
<li><p>缓冲channel</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">ch &#x3D; make(chan string, 3) &#x2F;&#x2F;channel容量为3</code></pre></li>
</ul>
<h2 id="8-3-基于select的多路复用"><a href="#8-3-基于select的多路复用" class="headerlink" title="8.3 基于select的多路复用"></a>8.3 基于select的多路复用</h2><details>
<summary>多路复用demo</summary>
<pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.
&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;

&#x2F;&#x2F; See page 246.

&#x2F;&#x2F; Countdown implements the countdown for a rocket launch.
package main

&#x2F;&#x2F; NOTE: the ticker goroutine never terminates if the launch is aborted.
&#x2F;&#x2F; This is a &quot;goroutine leak&quot;.

import (
        &quot;fmt&quot;
        &quot;os&quot;
        &quot;time&quot;
)

&#x2F;&#x2F;!+

func main() &#123;
        &#x2F;&#x2F; ...create abort channel...

        &#x2F;&#x2F;!-

        abort :&#x3D; make(chan struct&#123;&#125;)
        go func() &#123;
                os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte
                abort &lt;- struct&#123;&#125;&#123;&#125;
        &#125;()

        &#x2F;&#x2F;!+
        fmt.Println(&quot;Commencing countdown.  Press return to abort.&quot;)
        tick :&#x3D; time.Tick(1 * time.Second)
        for countdown :&#x3D; 10; countdown &gt; 0; countdown-- &#123;
                fmt.Println(countdown)
                select &#123;
                case &lt;-tick:
                        &#x2F;&#x2F; Do nothing.
                case &lt;-abort:
                        fmt.Println(&quot;Launch aborted!&quot;)
                        return
                &#125;
        &#125;
        launch()
&#125;
&#x2F;&#x2F;!-
func launch() &#123;
        fmt.Println(&quot;Lift off!&quot;)
&#125;</code></pre>

<p></pre></p>
</details>

<ul>
<li><p>goroutine泄露 : 当for语句执行完后，程序已经跳转到其他部分，但是<code>time.Tick(1 * time.Second)</code>仍然会继续的网channel里面发送数据，这就会导致gotourine泄露，以上面为例，那么就需要合适的地方调用<code>tick.stop()</code></p>
</li>
<li><p>channel的ready : 一定要等到channel准备完毕，开始接受或者发送消息</p>
</li>
<li><p>channel的轮询 : 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">select &#123;
  case &lt;-abort:
      fmt.Printf(&quot;Launch aborted!\n&quot;)
      return
  default:
      &#x2F;&#x2F; do nothing
&#125;</code></pre></li>
</ul>
<h2 id="8-4-并发的退出"><a href="#8-4-并发的退出" class="headerlink" title="8.4. 并发的退出"></a>8.4. 并发的退出</h2><p>这节主要讨论如何有效退出goroutines</p>
<details>
<summary>
<font size="3" color="orange">goroutines退出代码示例</font></summary>
<pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;gopl.io&#x2F;ch8&#x2F;du4
&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.
&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;

&#x2F;&#x2F; See page 251.

&#x2F;&#x2F; The du4 command computes the disk usage of the files in a directory.
package main

&#x2F;&#x2F; The du4 variant includes cancellation:
&#x2F;&#x2F; it terminates quickly when the user hits return.

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;path&#x2F;filepath&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

&#x2F;&#x2F;!+1
var done &#x3D; make(chan struct&#123;&#125;)

func cancelled() bool &#123;
	select &#123;
	case &lt;-done:
		return true
	default:
		return false
	&#125;
&#125;

&#x2F;&#x2F;!-1

func main() &#123;
	&#x2F;&#x2F; Determine the initial directories.
	roots :&#x3D; os.Args[1:]
	if len(roots) &#x3D;&#x3D; 0 &#123;
		roots &#x3D; []string&#123;&quot;.&quot;&#125;
	&#125;

	&#x2F;&#x2F;!+2
	&#x2F;&#x2F; Cancel traversal when input is detected.
	go func() &#123;
		os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte
		close(done)
	&#125;()
	&#x2F;&#x2F;!-2

	&#x2F;&#x2F; Traverse each root of the file tree in parallel.
	fileSizes :&#x3D; make(chan int64)
	var n sync.WaitGroup
	for _, root :&#x3D; range roots &#123;
		n.Add(1)
		go walkDir(root, &amp;n, fileSizes)
	&#125;
	go func() &#123;
		n.Wait()
		close(fileSizes)
	&#125;()

	&#x2F;&#x2F; Print the results periodically.
	tick :&#x3D; time.Tick(500 * time.Millisecond)
	var nfiles, nbytes int64
loop:
	&#x2F;&#x2F;!+3
	for &#123;
		select &#123;
		case &lt;-done:
			&#x2F;&#x2F; Drain fileSizes to allow existing goroutines to finish.
			for range fileSizes &#123;
				&#x2F;&#x2F; Do nothing.
			&#125;
			return
		case size, ok :&#x3D; &lt;-fileSizes:
			&#x2F;&#x2F; ...
			&#x2F;&#x2F;!-3
			if !ok &#123;
				break loop &#x2F;&#x2F; fileSizes was closed
			&#125;
			nfiles++
			nbytes +&#x3D; size
		case &lt;-tick:
			printDiskUsage(nfiles, nbytes)
		&#125;
	&#125;
	printDiskUsage(nfiles, nbytes) &#x2F;&#x2F; final totals
&#125;

func printDiskUsage(nfiles, nbytes int64) &#123;
	fmt.Printf(&quot;%d files  %.1f GB\n&quot;, nfiles, float64(nbytes)&#x2F;1e9)
&#125;

&#x2F;&#x2F; walkDir recursively walks the file tree rooted at dir
&#x2F;&#x2F; and sends the size of each found file on fileSizes.
&#x2F;&#x2F;!+4
func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) &#123;
	defer n.Done()
	if cancelled() &#123;
		return
	&#125;
	for _, entry :&#x3D; range dirents(dir) &#123;
		&#x2F;&#x2F; ...
		&#x2F;&#x2F;!-4
		if entry.IsDir() &#123;
			n.Add(1)
			subdir :&#x3D; filepath.Join(dir, entry.Name())
			go walkDir(subdir, n, fileSizes)
		&#125; else &#123;
			fileSizes &lt;- entry.Size()
		&#125;
		&#x2F;&#x2F;!+4
	&#125;
&#125;

&#x2F;&#x2F;!-4

var sema &#x3D; make(chan struct&#123;&#125;, 20) &#x2F;&#x2F; concurrency-limiting counting semaphore

&#x2F;&#x2F; dirents returns the entries of directory dir.
&#x2F;&#x2F;!+5
func dirents(dir string) []os.FileInfo &#123;
	select &#123;
	case sema &lt;- struct&#123;&#125;&#123;&#125;: &#x2F;&#x2F; acquire token
	case &lt;-done:
		return nil &#x2F;&#x2F; cancelled
	&#125;
	defer func() &#123; &lt;-sema &#125;() &#x2F;&#x2F; release token

	&#x2F;&#x2F; ...read directory...
	&#x2F;&#x2F;!-5

	f, err :&#x3D; os.Open(dir)
	if err !&#x3D; nil &#123;
		fmt.Fprintf(os.Stderr, &quot;du: %v\n&quot;, err)
		return nil
	&#125;
	defer f.Close()

	entries, err :&#x3D; f.Readdir(0) &#x2F;&#x2F; 0 &#x3D;&gt; no limit; read all entries
	if err !&#x3D; nil &#123;
		fmt.Fprintf(os.Stderr, &quot;du: %v\n&quot;, err)
		&#x2F;&#x2F; Don&#39;t return: Readdir may return partial results.
	&#125;
	return entries
&#125;</code></pre>

<p></pre></p>
</details>

<h1 id="9-基于共享变量的并发"><a href="#9-基于共享变量的并发" class="headerlink" title="9. 基于共享变量的并发"></a>9. 基于共享变量的并发</h1><p>(多看这章代码)<br>避免数据竞争的三个方法</p>
<ul>
<li><p>并发读数据不会有数据竞争问题</p>
</li>
<li><p>避免从多个goroutine中访问变量，使用独立变量</p>
</li>
<li><p>临界区控制</p>
</li>
<li><p>总结</p>
<ul>
<li>数据竞争: 程序在多个goroutine交叉执行操作时，导致数据不一致.  </li>
<li><code>包级别</code>的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。<br>  (多看看本章代码)</li>
</ul>
</li>
</ul>
<h2 id="9-1-sync-Mutex与sync-RMutex互斥锁"><a href="#9-1-sync-Mutex与sync-RMutex互斥锁" class="headerlink" title="9.1 sync.Mutex与sync.RMutex互斥锁"></a>9.1 sync.Mutex与sync.RMutex互斥锁</h2><p>比如银行存款查询余额的场景，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款(这句话很关键要没有)操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁</p>
<ul>
<li>总结<ul>
<li>避免临界区中的变量在中途被其他的goroutine修改</li>
<li>使用mutex包进行互斥goroutine</li>
<li>一个deferred Unlock即使在临界区发生<code>panic</code>时依然会执行</li>
<li>golang不支持重入锁</li>
<li>sync.RWMutex.RLock()持锁，sync.RWMutex.Lock()会阻塞，相同的RWMutex.Lock()持锁，sync.RWMutex.RLock()阻塞，但是sync.RWMutex.RLock()阻塞之间不阻塞</li>
</ul>
</li>
</ul>
<h2 id="9-2-sync-Once惰性初始化"><a href="#9-2-sync-Once惰性初始化" class="headerlink" title="9.2 sync.Once惰性初始化"></a>9.2 sync.Once惰性初始化</h2><p>如果初始化的成本太高，需要延迟的初始化对象。可考虑使用<code>sync.Once</code><br><detials></p>
<summary>sync.One的demo</summary>
<pre>

<p></pre></p>
</details>


<h2 id="9-3-sync-Cond的使用"><a href="#9-3-sync-Cond的使用" class="headerlink" title="9.3 sync.Cond的使用"></a>9.3 sync.Cond的使用</h2><ol>
<li><p>使用场景: <code>sync.Cond</code> 经常用在多个goroutine等待,一个goroutine通知,如果是一读一等待使用<code>sync.Mutx</code>和<code>chan</code>就可以</p>
</li>
<li><p><code>sync.Cond</code>的<a target="_blank" rel="noopener" href="https://pkg.go.dev/sync@go1.19#Cond">方法</a></p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
&#x2F;&#x2F; which must be held when changing the condition and
&#x2F;&#x2F; when calling the Wait method.
&#x2F;&#x2F; A Cond must not be copied after first use.
type Cond struct &#123;
        noCopy noCopy
        &#x2F;&#x2F; L is held while observing or changing the condition
        L Locker
        notify  notifyList
        checker copyChecker
&#125;
</code></pre>

<p> Cond 实例都会关联一个锁<code>L</code>(互斥锁 *Mutex，或读写锁 *RWMutex);当修改条件或者调用<code>Wait()</code>方法时,必须加锁</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Signal wakes one goroutine waiting on c, if there is any.
&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L
&#x2F;&#x2F; during the call.
&#x2F;&#x2F; Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护
func (c *Cond) Signal()
&#x2F;&#x2F; Broadcast wakes all goroutines waiting on c.
&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L
&#x2F;&#x2F; during the call.
func (c *Cond) Broadcast()

&#x2F;&#x2F; c.L.Unlock()
&#x2F;&#x2F; 挂起调用者所在的 goroutine,等待Broadcast或者Signal方法
func (c *Cond) Wait()
    &#x2F;&#x2F;代码片段
    c.L.Lock()
    for !condition() &#123;
        c.Wait()
    &#125;
    ... make use of condition ...
    c.L.Unlock()</code></pre>
<p> 调用<code>Wait</code>会自动释放锁 <code>c.L</code>,并挂起调用者所在的<code>goroutine</code>，因此当前协程会阻塞在<code>Wait</code>方法调用的地方。<br> 如果其他协程调用了<code>Signal</code>或<code>Broadcast</code>唤醒了该协程,那么<code>Wait</code>方法在结束阻塞时,会重新给<code>c.L</code>加锁，<br> 并且继续执行<code>Wait</code>后面的代码</p>
</li>
<li><p>Cond代码示例</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">var done &#x3D; false

func read(name string, c *sync.Cond) &#123;
    c.L.Lock()
    for !done &#123;
        c.Wait()
    &#125;
    log.Println(name, &quot;starts reading&quot;)
    c.L.Unlock()
&#125;

func write(name string, c *sync.Cond) &#123;
    log.Println(name, &quot;starts writing&quot;)
    time.Sleep(time.Second)
    c.L.Lock()
    done &#x3D; true
    c.L.Unlock()
    log.Println(name, &quot;wakes all&quot;)
    c.Broadcast()
&#125;

func main() &#123;
    cond :&#x3D; sync.NewCond(&amp;sync.Mutex&#123;&#125;)

    go read(&quot;reader1&quot;, cond)
    go read(&quot;reader2&quot;, cond)
    go read(&quot;reader3&quot;, cond)
    write(&quot;writer&quot;, cond)

    time.Sleep(time.Second * 3)
&#125;
</code></pre></li>
</ol>
<h2 id="9-4-Goroutines和线程"><a href="#9-4-Goroutines和线程" class="headerlink" title="9.4. Goroutines和线程"></a>9.4. Goroutines和线程</h2><ul>
<li><p>每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量</p>
</li>
<li><p>一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩</p>
</li>
<li><p>Go的<code>运行时</code>有自己的调度器，这个调度器比如m:n调度，n个操作系统线程调度m个gotoutine，例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。</p>
</li>
<li><p>GOMAXPROCS : 变量来决定会有多少个操作系统的线程同时执行Go的代码,其默认的值是运行机器上的CPU的核心数,<code>GOMAXPROCS</code>是前面说的m:n调度中的n.下面代码就可以简单的看出os线程调度代码的情况</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
for &#123;
    go fmt.Print(0)
    fmt.Print(1)
&#125;

$ GOMAXPROCS&#x3D;1 go run hacker-cliché.go
111111111111111111110000000000000000000011111...

$ GOMAXPROCS&#x3D;2 go run hacker-cliché.go
010101010101010101011001100101011010010100110...</code></pre>


</li>
<li><p>总结</p>
<ul>
<li>通过广播机制来取消goroutines</li>
<li>确保主函数退出，routines也随即退出</li>
</ul>
</li>
</ul>
<h1 id="10-包和工具"><a href="#10-包和工具" class="headerlink" title="10. 包和工具"></a>10. 包和工具</h1><p>互联网上已经发布了非常多的Go语言开源包，它们可以通过 <a target="_blank" rel="noopener" href="http://godoc.org/">http://godoc.org</a> 检索</p>
<ul>
<li>包的声明 ： 通过<code>package.struct</code>的形式访问我们的下载的<code>package</code>,但是也有同名的例如<code>math/rand</code>和<code>crypto/rand</code>，这种要重新指定包名，只影响当前文件，同时也解决了那些又臭又长的包名</li>
<li>文件开头以<code>_</code>和<code>.</code>的会被忽略</li>
<li>以<code>_test</code>结尾的通常是测试包</li>
<li>一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in&#x2F;yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml</li>
<li><code>包的匿名导入</code>:<ul>
<li>解决包的依赖顺序</li>
<li>初始化包级声明的变量</li>
<li>按顺序初始化包中每个文件里的 init 函数</li>
<li>每个文件中可以包含多个 init 函数，按顺序执行(所以你导和不导包差距很大，匿名导入只是表明你无法使用相应包内函数)</li>
<li>包名和成员名要尽量的短，并且能见名知意</li>
</ul>
</li>
<li>go的工具<ul>
<li>工作区结构 : 当需要切换工作区的时候，只需要更新下GOPATH环境变量即可<code>src</code>保存源代码,<code>pkg</code>子目录用于保存编译后的包的目标文件,<code>bin</code>子目录用于保存编译后的可执行程序</li>
<li>下载包 : <code>go get</code>命令，<code>go get -u</code>命令只是简单地保证每个下载最新版本，实际工作中要对包版本做精细的管理，需要vendor目录管理不同版本的包,<code>go help gopath</code>查看vendor帮助文档,而go get 相当于获取的是远程仓库源代码的整个库，还可以看到仓库的版本信息，go支持导入远程github仓库的代码，<code>go get</code>下载的包保存在哪里呢？一般他会保存在这个目录：<code>GOPATH/src</code><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrbug/p/11990418.html#:~:text=go%20get%20%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8C%85,%E7%9A%84go%20%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E3%80%82">goget详细介绍</a>，<code>go get</code>是对模块代码的更新</li>
<li>构建包 : 可以使用相对路径和绝对路径进行构建项目，<code>go run</code>其实也可以偷懒，直接<code>go run *.go</code>,<code>go build -i</code>命令将安装每个目标所依赖的包,<code>// +build linux darwin</code>,在包声明和包注释的前面，该构建注释参数告诉<code>go build</code>只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件,<code>// +build ignore</code>这个构建注释则表示不编译这个文件。<code>go doc go/build</code></li>
<li>包文档 : 专门用于保存包文档的源文件通常叫<code>doc.go</code>,例如 <code>go doc time</code> 某个具体成员结构<code>go doc time.Since</code>,或者具体函数<code>go doc time.Duration.Second</code> , 更简单的是<code>godoc -http :8000</code>包含了所有go包的索引，<code>-analysis=type</code>和<code>-analysis=pointer</code>命令行标志参数用于打开文档和代码中关于静态分析的结果</li>
<li>内部包 : 一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包</li>
<li>搜索包 : <code>go list</code>列出工作区相关包,还可以查看完整包的原信息,例如<code>hash</code>包<code>go list -json hash</code><ul>
<li>命令行参数-f则允许用户使用text&#x2F;template包（§4.6）的模板语言定义输出文本的格式<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;windows环境下注意
go list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...
  compress&#x2F;bzip2 -&gt; bufio io sort
  compress&#x2F;flate -&gt; bufio fmt io math sort strconv
  compress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io time
  compress&#x2F;lzw -&gt; bufio errors fmt io
  compress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="11-测试"><a href="#11-测试" class="headerlink" title="11. 测试"></a>11. 测试</h1><p>go test选项含义</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">
-args 传递参数到test binary<span class="token punctuation">(</span>到时候补一个demo<span class="token punctuation">)</span>
-c 编译test binary,但是不执行
-exec xprog  运行test binary ,原理如同 go run
-i 安装test binary的相关依赖
-json 将测试输出转化为json为了自动化处理
-c <span class="token function">file</span>   定义编译后的binary的文件名
</code></pre>


<h2 id="11-1-go-test"><a href="#11-1-go-test" class="headerlink" title="11.1 go test"></a>11.1 go test</h2><p>一个测试函数是以<code>Test</code>为函数名前缀的函数<br>一个基准测试函数是以<code>Benchmark</code>为函数名前缀的函数<br>一个示例函数是以<code>Example</code>为函数名前缀的函数，提供一个由编译器保证正确性的示例文档</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">- &#96;go test -v &#96;会打印每个函数的名字和运行时间
- &#96;go test -run&#x3D; &#96;会去匹配正则表达式，只有被匹配到的才会被执行
- &#96;go test -v .&#x2F;...&#96; 执行所有当前目录下测试cases
- &#96;go test -v foo&#x2F;...&#96; 执行foo目录下所有cases
- &#96;go test -v foo...&#96; 执行指定前缀的测试cases
- &#96;go test ...&#96; gopath下所有测试cases
- &#96;go test -v hello_test.go&#96; 执行某一文件下的测试cases,但是该文件中如果调用了其它文件中的模块会报错
- &#96;go test -v hello_test.go -test.run TestHello&#96; 测试单个函数</code></pre>
<ul>
<li><p>组织多个测试用例</p>
<p>即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息,可以使用<code>t.Fatal</code>或<code>t.Fatalf</code>停止当前测试函数</p>
  <details>
  <summary>组织多测试用例</summary>
  <pre>
  
  <pre class="language-golang" data-language="golang"><code class="language-golang">func TestIsPalindrome(t *testing.T) &#123;
var tests &#x3D; []struct &#123;
    input string
    want  bool
&#125;&#123;
        &#123;&quot;&quot;, true&#125;,
        &#123;&quot;a&quot;, true&#125;,
        &#123;&quot;aa&quot;, true&#125;,
        &#123;&quot;ab&quot;, false&#125;,
        &#123;&quot;kayak&quot;, true&#125;,
        &#123;&quot;detartrated&quot;, true&#125;,
        &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;,
        &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;,
        &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;,
        &#123;&quot;été&quot;, true&#125;,
        &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;,
        &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome
        &#123;&quot;desserts&quot;, false&#125;,   &#x2F;&#x2F; semi-palindrome
    &#125;
    for _, test :&#x3D; range tests &#123;
        if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123;
            t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got)
        &#125;
    &#125;
&#125;</code></pre>

<p>  </pre></p>
  </details>
</li>
<li><p>随机测试</p>
<ol>
<li>编写对照函数，效率低下</li>
<li>生成的随机输入的数据遵循特定的模式，然后就知道期望的输出</li>
</ol>
<pre class="language-golang" data-language="golang"><code class="language-golang">
import &quot;math&#x2F;rand&quot;

  &#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents
  &#x2F;&#x2F; are derived from the pseudo-random number generator rng.
  func randomPalindrome(rng *rand.Rand) string &#123;
      n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24
      runes :&#x3D; make([]rune, n)
      for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;
          r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\u0999&#39;
          runes[i] &#x3D; r
          runes[n-1-i] &#x3D; r
      &#125;
      return string(runes)
  &#125;

  func TestRandomPalindromes(t *testing.T) &#123;
      &#x2F;&#x2F; Initialize a pseudo-random number generator.
      seed :&#x3D; time.Now().UTC().UnixNano()
      t.Logf(&quot;Random seed: %d&quot;, seed)
      rng :&#x3D; rand.New(rand.NewSource(seed))

      for i :&#x3D; 0; i &lt; 1000; i++ &#123;
          p :&#x3D; randomPalindrome(rng)
          if !IsPalindrome(p) &#123;
              t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)
          &#125;
      &#125;
  &#125;
  &#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.
  &#x2F;&#x2F; Letter case is ignored, as are non-letters.
  func IsPalindrome(s string) bool &#123;
      var letters []rune
      for _, r :&#x3D; range s &#123;
          if unicode.IsLetter(r) &#123;
              letters &#x3D; append(letters, unicode.ToLower(r))
          &#125;
      &#125;
      for i :&#x3D; range letters &#123;
          if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;
              return false
          &#125;
      &#125;
      return true
  &#125;
</code></pre>
</li>
<li><p>测试一个命令(测试内部未导出函数)</p>
<p>要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。要注意的是在测试代码中并没有调用<code>log.Fatal</code>或<code>os.Exit</code>，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理,如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理.导出内部函数,</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; src&#x2F;bytes&#x2F;export_test.go
  package bytes
  &#x2F;&#x2F; Export func for testing
  var IndexBytePortable &#x3D; indexBytePortable &#x2F;&#x2F; 赋值给包级可导出变量</code></pre>

<p>然后通过外部包进行测试</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
&#x2F;&#x2F; src&#x2F;bytes&#x2F;bytes_test.go
  package bytes_test

  func TestIndexByte(t *testing.T) &#123;
      for _, tt :&#x3D; range indexTests &#123;
          ... 代码片段
          posp :&#x3D; IndexBytePortable(a, b) &#x2F;&#x2F; 导出的内部方法在这里被使用
          if posp !&#x3D; tt.i &#123;
              t.Errorf(&#96;indexBytePortable(%q, &#39;%c&#39;) &#x3D; %v&#96;, tt.a, b, posp)
          &#125;
      &#125;
  &#125;
</code></pre>
<p>还有种方式就是不导出，直接在包名下写测试函数，然后进行测试源代码</p>
</li>
<li><p>白盒测试</p>
<p>TBC,代码的内部实现对于测试人员来说是可见的，言外之意就是能看到内部实现,测试内部实现，这个实现可能是未导出的</p>
</li>
<li><p>外部测试包</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package pprint_test
  &#x2F;&#x2F;这时候就可以在
  import (
      &quot;gott&#x2F;hi&quot;
      &#x2F;&#x2F; 导入 要进行测试的 pprint 包本身
      &quot;gott&#x2F;pprint&quot;
      &quot;testing&quot;
  )

  func TestPPrint(t *testing.T) &#123;
      pprint.PPrint()
      hi.Say()
      t.Log(&quot;expect call PPrint&quot;)
  &#125;
  </code></pre>
<p>使用 Go 官方的代码风格：pprint_test.go 文件，因为pprint_test在 pprint 目录下，通过在 import 时，使用<code>.</code>选项，可以直接调用PPrint()方法</p>
</li>
<li><p>编写有效的测试</p>
<ol>
<li>一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息</li>
<li>一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律</li>
<li>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试</li>
</ol>
</li>
<li><p>避免脆弱的测试<br>TBC</p>
</li>
</ul>
<h2 id="11-2-测试覆盖率"><a href="#11-2-测试覆盖率" class="headerlink" title="11.2 测试覆盖率"></a>11.2 测试覆盖率</h2><p>对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化(应该是有)</p>
<ol>
<li>go test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;eval</li>
<li>go test -run&#x3D;Coverage -covermode&#x3D;count gopl.io&#x2F;ch7&#x2F;eval</li>
</ol>
<h2 id="11-3-基准测试"><a href="#11-3-基准测试" class="headerlink" title="11.3 基准测试"></a>11.3 基准测试</h2><ol>
<li><code>-bench</code>也是正则匹配,BenchmarkIsPalindrome-8,8表示的是GOMAXPROCS的值,<code>-benchmem</code>命令行标志参数将在报告中包含内存的分配数据统计</li>
<li>比较型的基准测试就是普通程序代码,它们通常是单参数的函数，由几个不同数量级的基准测试函数调用,通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。所有的测试cases都要保留，随着项目的发展，都需要做回归测试</li>
</ol>
<h2 id="11-4-刨析"><a href="#11-4-刨析" class="headerlink" title="11.4 刨析"></a>11.4 刨析</h2><p>TBC</p>
<h2 id="11-5-示例函数"><a href="#11-5-示例函数" class="headerlink" title="11.5 示例函数"></a>11.5 示例函数</h2><p>示例函数有三个用处。</p>
<ol>
<li>最主要的一个是作为文档，根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。</li>
<li>在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的&#x2F;&#x2F; Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配</li>
<li>提供一个真实的演练场，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数</li>
</ol>
<h1 id="12-appendIndex"><a href="#12-appendIndex" class="headerlink" title="12. appendIndex"></a>12. appendIndex</h1><ol>
<li>线程内再重启一个线程，然后就可以通过加锁，进行隔离开，但此时任然是两个线程的间的交替</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/08/golang/go%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3/"
                            aria-label=": go标准库阅读与解析"
                        >
                            go标准库阅读与解析
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-08T07:48:06+08:00">
	
		    Oct 08, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#1-package-tar">1. package tar</a><ul>
<li><a href="#11-constants">1.1. Constants</a></li>
<li><a href="#12-variables">1.2. Variables</a></li>
<li><a href="#13-type-format">1.3. type Format</a><ul>
<li><a href="#131-func-f-format-string-string">1.3.1. func (f Format) String() string</a></li>
</ul>
</li>
<li><a href="#14-type-header">1.4. type Header</a><ul>
<li><a href="#141-func-fileinfoheaderfi-fsfileinfo-link-string-header-error">1.4.1. func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)</a></li>
<li><a href="#142-func-hheader-fileinfo-fsfileinfo">1.4.2. func (h*Header) FileInfo() fs.FileInfo</a></li>
</ul>
</li>
<li><a href="#15-type-reader">1.5. type Reader</a><ul>
<li><a href="#151-func-newreaderr-ioreader-reader">1.5.1. func NewReader(r io.Reader) *Reader</a></li>
<li><a href="#152-func-trreader-next-header-error">1.5.2. func (tr*Reader) Next() (*Header, error)</a></li>
<li><a href="#153-func-trreader-readb-byte-int-error">1.5.3. func (tr*Reader) Read(b []byte) (int, error)</a></li>
</ul>
</li>
<li><a href="#16-type-writer">1.6. type Writer</a><ul>
<li><a href="#161-func-newwriterw-iowriter-writer">1.6.1. func NewWriter(w io.Writer) *Writer</a></li>
<li><a href="#162-func-twwriter-close-error">1.6.2. func (tw*Writer) Close() error</a></li>
<li><a href="#163-func-tw-writer-flush-error">1.6.3. func (tw *Writer) Flush() error</a></li>
<li><a href="#164-func-twwriter-writeb-byte-int-error">1.6.4. func (tw*Writer) Write(b []byte) (int, error)</a></li>
<li><a href="#165-func-tw-writer-writeheaderhdrheader-error">1.6.5. func (tw <em>Writer) WriteHeader(hdr</em>Header) error</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-zip-package">2. zip package</a><ul>
<li><a href="#21-constants">2.1. Constants</a></li>
<li><a href="#22-variables">2.2. Variables</a><ul>
<li><a href="#221-func-registercompressormethod-uint16-comp-compressor">2.2.1. func RegisterCompressor(method uint16, comp Compressor)</a></li>
<li><a href="#222-func-registerdecompressormethod-uint16-dcomp-decompressor">2.2.2. func RegisterDecompressor(method uint16, dcomp Decompressor)</a></li>
</ul>
</li>
<li><a href="#23-type-compressor">2.3. type Compressor</a></li>
<li><a href="#24-type-decompressor">2.4. type Decompressor</a></li>
<li><a href="#25-type-file">2.5. type File</a><ul>
<li><a href="#251-func-f-file-dataoffset-offset-int64-err-error">2.5.1. func (f *File) DataOffset() (offset int64, err error)</a></li>
<li><a href="#252-func-ffile-open-ioreadcloser-error">2.5.2. func (f*File) Open() (io.ReadCloser, error)</a></li>
<li><a href="#253-func-f-file-openraw-ioreader-error">2.5.3. func (f *File) OpenRaw() (io.Reader, error)</a></li>
</ul>
</li>
<li><a href="#26-type-fileheader">2.6. type FileHeader</a><ul>
<li><a href="#261-func-fileinfoheaderfi-fsfileinfo-fileheader-error">2.6.1. func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</a></li>
<li><a href="#262-func-h-fileheader-fileinfo-fsfileinfo">2.6.2. func (h *FileHeader) FileInfo() fs.FileInfo</a></li>
<li><a href="#263-func-hfileheader-modtime-timetimedeprecated">2.6.3. func (h*FileHeader) ModTime() time.TimeDEPRECATED</a></li>
<li><a href="#264-func-h-fileheader-mode-mode-fsfilemode">2.6.4. func (h *FileHeader) Mode() (mode fs.FileMode)</a></li>
<li><a href="#265-func-hfileheader-setmodtimet-timetimedeprecated">2.6.5. func (h*FileHeader) SetModTime(t time.Time)DEPRECATED</a></li>
<li><a href="#266-func-h-fileheader-setmodemode-fsfilemode">2.6.6. func (h *FileHeader) SetMode(mode fs.FileMode)</a></li>
</ul>
</li>
<li><a href="#27-type-readcloser">2.7. type ReadCloser</a><ul>
<li><a href="#271-func-openreadername-string-readcloser-error">2.7.1. func OpenReader(name string) (*ReadCloser, error)</a></li>
<li><a href="#272-func-rc-readcloser-close-error">2.7.2. func (rc *ReadCloser) Close() error</a></li>
</ul>
</li>
<li><a href="#28-type-reader">2.8. type Reader</a><ul>
<li><a href="#281-func-newreaderr-ioreaderat-size-int64-reader-error">2.8.1. func NewReader(r io.ReaderAt, size int64) (*Reader, error)</a></li>
<li><a href="#282-func-r-reader-openname-string-fsfile-error">2.8.2. func (r *Reader) Open(name string) (fs.File, error)</a></li>
<li><a href="#283-func-zreader-registerdecompressormethod-uint16-dcomp-decompressor">2.8.3. func (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</a></li>
</ul>
</li>
<li><a href="#29-type-writer">2.9. type Writer</a><ul>
<li><a href="#291-func-newwriterw-iowriter-writer">2.9.1. func NewWriter(w io.Writer) *Writer</a></li>
<li><a href="#292-func-wwriter-close-error">2.9.2. func (w*Writer) Close() error</a></li>
<li><a href="#293-func-w-writer-copyffile-error">2.9.3. func (w *Writer) Copy(f*File) error</a></li>
<li><a href="#294-func-w-writer-createname-string-iowriter-error">2.9.4. func (w *Writer) Create(name string) (io.Writer, error)</a></li>
<li><a href="#295-func-wwriter-createheaderfhfileheader-iowriter-error">2.9.5. func (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)</a></li>
<li><a href="#296-func-wwriter-createrawfhfileheader-iowriter-error">2.9.6. func (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)</a></li>
<li><a href="#297-func-wwriter-flush-error">2.9.7. func (w*Writer) Flush() error</a></li>
<li><a href="#298-func-w-writer-registercompressormethod-uint16-comp-compressor">2.9.8. func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</a></li>
<li><a href="#299-func-wwriter-setcommentcomment-string-error">2.9.9. func (w*Writer) SetComment(comment string) error</a></li>
<li><a href="#2910-func-w-writer-setoffsetn-int64">2.9.10. func (w *Writer) SetOffset(n int64)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-time-package">3. time package</a><ul>
<li><a href="#31-constants">3.1. Constants</a><ul>
<li><a href="#311-func-afterd-duration--chan-time">3.1.1. func After(d Duration) &lt;-chan Time</a></li>
<li><a href="#312-func-sleepd-duration">3.1.2. func Sleep(d Duration)</a></li>
<li><a href="#313-func-tickd-duration--chan-time">3.1.3. func Tick(d Duration) &lt;-chan Time</a></li>
</ul>
</li>
<li><a href="#32-type-duration">3.2. type Duration</a><ul>
<li><a href="#321-func-parsedurations-string-duration-error">3.2.1. func ParseDuration(s string) (Duration, error)</a></li>
<li><a href="#322-func-sincet-time-duration">3.2.2. func Since(t Time) Duration</a></li>
<li><a href="#323-func-untilt-time-duration">3.2.3. func Until(t Time) Duration</a></li>
<li><a href="#324-func-d-duration-abs-duration">3.2.4. func (d Duration) Abs() Duration</a></li>
<li><a href="#325-func-d-duration-hours-float64">3.2.5. func (d Duration) Hours() float64</a></li>
<li><a href="#326-func-d-duration-microseconds-int64">3.2.6. func (d Duration) Microseconds() int64</a></li>
<li><a href="#327-func-d-duration-milliseconds-int64">3.2.7. func (d Duration) Milliseconds() int64</a></li>
<li><a href="#328-func-d-duration-minutes-float64">3.2.8. func (d Duration) Minutes() float64</a></li>
<li><a href="#329-func-d-duration-nanoseconds-int64">3.2.9. func (d Duration) Nanoseconds() int64</a></li>
<li><a href="#3210-func-d-duration-roundm-duration-duration">3.2.10. func (d Duration) Round(m Duration) Duration</a></li>
<li><a href="#3211-func-d-duration-seconds-float64">3.2.11. func (d Duration) Seconds() float64</a></li>
<li><a href="#3212-func-d-duration-string-string">3.2.12. func (d Duration) String() string</a></li>
<li><a href="#3213-func-d-duration-truncatem-duration-duration">3.2.13. func (d Duration) Truncate(m Duration) Duration</a></li>
</ul>
</li>
<li><a href="#33-type-location">3.3. type Location</a><ul>
<li><a href="#331-func-fixedzonename-string-offset-int-location">3.3.1. func FixedZone(name string, offset int) *Location</a></li>
<li><a href="#332-func-loadlocationname-string-location-error">3.3.2. func LoadLocation(name string) (*Location, error)</a></li>
<li><a href="#333-func-loadlocationfromtzdataname-string-data-byte-location-error">3.3.3. func LoadLocationFromTZData(name string, data []byte) (*Location, error)</a></li>
<li><a href="#334-func-llocation-string-string">3.3.4. func (l*Location) String() string</a></li>
</ul>
</li>
<li><a href="#34-type-month">3.4. type Month</a><ul>
<li><a href="#341-func-m-month-string-string">3.4.1. func (m Month) String() string</a></li>
</ul>
</li>
<li><a href="#35-type-parseerror">3.5. type ParseError</a><ul>
<li><a href="#351-func-e-parseerror-error-string">3.5.1. func (e *ParseError) Error() string</a></li>
</ul>
</li>
<li><a href="#36-type-ticker">3.6. type Ticker</a><ul>
<li><a href="#361-func-newtickerd-duration-ticker">3.6.1. func NewTicker(d Duration) *Ticker</a></li>
<li><a href="#362-func-t-ticker-resetd-duration">3.6.2. func (t *Ticker) Reset(d Duration)</a></li>
<li><a href="#363-func-t-ticker-stop">3.6.3. func (t *Ticker) Stop()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sort">sort</a><ul>
<li><a href="#func-findn-int-cmp-funcint-int-i-int-found-bool">func Find(n int, cmp func(int) int) (i int, found bool)</a></li>
<li><a href="#func-float64sx-float64">func Float64s(x []float64)</a></li>
<li><a href="#func-float64saresortedx-float64-bool">func Float64sAreSorted(x []float64) bool</a></li>
<li><a href="#func-intsx-int">func Ints(x []int)</a></li>
<li><a href="#func-intsaresortedx-int-bool">func IntsAreSorted(x []int) bool</a></li>
<li><a href="#func-issorteddata-interface-bool">func IsSorted(data Interface) bool</a></li>
<li><a href="#func-searchn-int-f-funcint-bool-int">func Search(n int, f func(int) bool) int</a></li>
<li><a href="#func-searchfloat64sa-float64-x-float64-int">func SearchFloat64s(a []float64, x float64) int</a></li>
<li><a href="#func-searchintsa-int-x-int-int">func SearchInts(a []int, x int) int</a></li>
<li><a href="#func-searchstringsa-string-x-string-int">func SearchStrings(a []string, x string) int</a></li>
<li><a href="#func-slicex-any-less-funci-j-int-bool">func Slice(x any, less func(i, j int) bool)</a></li>
<li><a href="#func-sliceissortedx-any-less-funci-j-int-bool-bool">func SliceIsSorted(x any, less func(i, j int) bool) bool</a></li>
<li><a href="#func-slicestablex-any-less-funci-j-int-bool">func SliceStable(x any, less func(i, j int) bool)</a></li>
<li><a href="#func-sortdata-interface">func Sort(data Interface)</a></li>
<li><a href="#func-stabledata-interface">func Stable(data Interface)</a></li>
<li><a href="#func-stringsx-string">func Strings(x []string)</a></li>
<li><a href="#func-stringsaresortedx-string-bool">func StringsAreSorted(x []string) bool</a></li>
<li><a href="#type-float64slice">type Float64Slice</a><ul>
<li><a href="#func-x-float64slice-len-int">func (x Float64Slice) Len() int</a></li>
<li><a href="#func-x-float64slice-lessi-j-int-bool">func (x Float64Slice) Less(i, j int) bool</a></li>
<li><a href="#func-p-float64slice-searchx-float64-int">func (p Float64Slice) Search(x float64) int</a></li>
<li><a href="#func-x-float64slice-sort">func (x Float64Slice) Sort()</a></li>
<li><a href="#func-x-float64slice-swapi-j-int">func (x Float64Slice) Swap(i, j int)</a></li>
</ul>
</li>
<li><a href="#type-intslice">type IntSlice</a><ul>
<li><a href="#func-x-intslice-len-int">func (x IntSlice) Len() int</a></li>
<li><a href="#func-x-intslice-lessi-j-int-bool">func (x IntSlice) Less(i, j int) bool</a></li>
<li><a href="#func-p-intslice-searchx-int-int">func (p IntSlice) Search(x int) int</a></li>
<li><a href="#func-x-intslice-sort">func (x IntSlice) Sort()</a></li>
<li><a href="#func-x-intslice-swapi-j-int">func (x IntSlice) Swap(i, j int)</a></li>
</ul>
</li>
<li><a href="#type-interface">type Interface</a><ul>
<li><a href="#func-reversedata-interface-interface">func Reverse(data Interface) Interface</a></li>
</ul>
</li>
<li><a href="#type-stringslice">type StringSlice</a><ul>
<li><a href="#func-x-stringslice-len-int">func (x StringSlice) Len() int</a></li>
<li><a href="#func-x-stringslice-lessi-j-int-bool">func (x StringSlice) Less(i, j int) bool</a></li>
<li><a href="#func-p-stringslice-searchx-string-int">func (p StringSlice) Search(x string) int</a></li>
<li><a href="#func-x-stringslice-sort">func (x StringSlice) Sort()</a></li>
<li><a href="#func-x-stringslice-swapi-j-int">func (x StringSlice) Swap(i, j int)</a></li>
</ul>
</li>
<li><a href="#37-type-time">3.7. type Time</a><ul>
<li><a href="#371-func-dateyear-int-month-month-day-hour-min-sec-nsec-int-loc-location-time">3.7.1. func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</a></li>
<li><a href="#372-func-now-time">3.7.2. func Now() Time</a></li>
<li><a href="#373-func-parselayout-value-string-time-error">3.7.3. func Parse(layout, value string) (Time, error)</a></li>
<li><a href="#374-func-parseinlocationlayout-value-string-loc-location-time-error">3.7.4. func ParseInLocation(layout, value string, loc *Location) (Time, error)</a></li>
<li><a href="#375-func-unixsec-int64-nsec-int64-time">3.7.5. func Unix(sec int64, nsec int64) Time</a></li>
<li><a href="#376-func-unixmicrousec-int64-time">3.7.6. func UnixMicro(usec int64) Time</a></li>
<li><a href="#377-func-unixmillimsec-int64-time">3.7.7. func UnixMilli(msec int64) Time</a></li>
<li><a href="#378-func-t-time-addd-duration-time">3.7.8. func (t Time) Add(d Duration) Time</a></li>
<li><a href="#379-func-t-time-adddateyears-int-months-int-days-int-time">3.7.9. func (t Time) AddDate(years int, months int, days int) Time</a></li>
<li><a href="#3710-func-t-time-afteru-time-bool">3.7.10. func (t Time) After(u Time) bool</a></li>
<li><a href="#3711-func-t-time-appendformatb-byte-layout-string-byte">3.7.11. func (t Time) AppendFormat(b []byte, layout string) []byte</a></li>
<li><a href="#3712-func-t-time-beforeu-time-bool">3.7.12. func (t Time) Before(u Time) bool</a></li>
<li><a href="#3713-func-t-time-clock-hour-min-sec-int">3.7.13. func (t Time) Clock() (hour, min, sec int)</a></li>
<li><a href="#3714-func-t-time-date-year-int-month-month-day-int">3.7.14. func (t Time) Date() (year int, month Month, day int)</a></li>
<li><a href="#3715-func-t-time-day-int">3.7.15. func (t Time) Day() int</a></li>
<li><a href="#3716-func-t-time-equalu-time-bool">3.7.16. func (t Time) Equal(u Time) bool</a></li>
<li><a href="#3717-func-t-time-formatlayout-string-string">3.7.17. func (t Time) Format(layout string) string</a></li>
<li><a href="#3718-func-t-time-gostring-string">3.7.18. func (t Time) GoString() string</a></li>
<li><a href="#3719-func-t-time-gobdecodedata-byte-error">3.7.19. func (t *Time) GobDecode(data []byte) error</a></li>
<li><a href="#3720-func-t-time-gobencode-byte-error">3.7.20. func (t Time) GobEncode() ([]byte, error)</a></li>
<li><a href="#3721-func-t-time-hour-int">3.7.21. func (t Time) Hour() int</a></li>
<li><a href="#3722-func-t-time-isoweek-year-week-int">3.7.22. func (t Time) ISOWeek() (year, week int)</a></li>
<li><a href="#3723-func-t-time-inloclocation-time">3.7.23. func (t Time) In(loc*Location) Time</a></li>
<li><a href="#3724-func-t-time-isdst-bool">3.7.24. func (t Time) IsDST() bool</a></li>
<li><a href="#3725-func-t-time-iszero-bool">3.7.25. func (t Time) IsZero() bool</a></li>
<li><a href="#3726-func-t-time-local-time">3.7.26. func (t Time) Local() Time</a></li>
<li><a href="#3727-func-t-time-location-location">3.7.27. func (t Time) Location() *Location</a></li>
<li><a href="#3728-func-t-time-marshalbinary-byte-error">3.7.28. func (t Time) MarshalBinary() ([]byte, error)</a></li>
<li><a href="#3729-func-t-time-marshaljson-byte-error">3.7.29. func (t Time) MarshalJSON() ([]byte, error)</a></li>
<li><a href="#3730-func-t-time-marshaltext-byte-error">3.7.30. func (t Time) MarshalText() ([]byte, error)</a></li>
<li><a href="#3731-func-t-time-minute-int">3.7.31. func (t Time) Minute() int</a></li>
<li><a href="#3732-func-t-time-month-month">3.7.32. func (t Time) Month() Month</a></li>
<li><a href="#3733-func-t-time-nanosecond-int">3.7.33. func (t Time) Nanosecond() int</a></li>
<li><a href="#3734-func-t-time-roundd-duration-time">3.7.34. func (t Time) Round(d Duration) Time</a></li>
<li><a href="#3735-func-t-time-second-int">3.7.35. func (t Time) Second() int</a></li>
<li><a href="#3736-func-t-time-string-string">3.7.36. func (t Time) String() string</a></li>
<li><a href="#3737-func-t-time-subu-time-duration">3.7.37. func (t Time) Sub(u Time) Duration</a></li>
<li><a href="#3738-func-t-time-truncated-duration-time">3.7.38. func (t Time) Truncate(d Duration) Time</a></li>
<li><a href="#3739-func-t-time-utc-time">3.7.39. func (t Time) UTC() Time</a></li>
<li><a href="#3740-func-t-time-unix-int64">3.7.40. func (t Time) Unix() int64</a></li>
<li><a href="#3741-func-t-time-unixmicro-int64">3.7.41. func (t Time) UnixMicro() int64</a></li>
<li><a href="#3742-func-t-time-unixmilli-int64">3.7.42. func (t Time) UnixMilli() int64</a></li>
<li><a href="#3743-func-t-time-unixnano-int64">3.7.43. func (t Time) UnixNano() int64</a></li>
<li><a href="#3744-func-ttime-unmarshalbinarydata-byte-error">3.7.44. func (t*Time) UnmarshalBinary(data []byte) error</a></li>
<li><a href="#3745-func-t-time-unmarshaljsondata-byte-error">3.7.45. func (t *Time) UnmarshalJSON(data []byte) error</a></li>
<li><a href="#3746-func-ttime-unmarshaltextdata-byte-error">3.7.46. func (t*Time) UnmarshalText(data []byte) error</a></li>
<li><a href="#3747-func-t-time-weekday-weekday">3.7.47. func (t Time) Weekday() Weekday</a></li>
<li><a href="#3748-func-t-time-year-int">3.7.48. func (t Time) Year() int</a></li>
<li><a href="#3749-func-t-time-yearday-int">3.7.49. func (t Time) YearDay() int</a></li>
<li><a href="#3750-func-t-time-zone-name-string-offset-int">3.7.50. func (t Time) Zone() (name string, offset int)</a></li>
<li><a href="#3751-func-t-time-zonebounds-start-end-time">3.7.51. func (t Time) ZoneBounds() (start, end Time)</a></li>
<li><a href="#3752-type-timer">3.7.52. type Timer</a></li>
<li><a href="#3753-func-afterfuncd-duration-f-func-timer">3.7.53. func AfterFunc(d Duration, f func()) *Timer</a></li>
<li><a href="#3754-func-newtimerd-durationtimer">3.7.54. func NewTimer(d Duration)*Timer</a></li>
<li><a href="#3755-func-t-timer-resetd-duration-bool">3.7.55. func (t *Timer) Reset(d Duration) bool</a></li>
<li><a href="#3756-func-ttimer-stop-bool">3.7.56. func (t*Timer) Stop() bool</a></li>
</ul>
</li>
<li><a href="#38-type-weekday">3.8. type Weekday</a><ul>
<li><a href="#381-func-d-weekday-string-string">3.8.1. func (d Weekday) String() string</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-rand">4. rand</a><ul>
<li><a href="#41-function-not-method-of-rand">4.1. function not method of rand</a><ul>
<li><a href="#411-func-expfloat64-float64">4.1.1. func ExpFloat64() float64</a></li>
<li><a href="#412-func-float32-float32">4.1.2. func Float32() float32</a></li>
<li><a href="#413-func-float64-float64">4.1.3. func Float64() float64</a></li>
<li><a href="#414-func-int-int">4.1.4. func Int() int</a></li>
<li><a href="#415-func-int31-int32">4.1.5. func Int31() int32</a></li>
<li><a href="#416-func-int31nn-int32-int32">4.1.6. func Int31n(n int32) int32</a></li>
<li><a href="#417-func-int63-int64">4.1.7. func Int63() int64</a></li>
<li><a href="#418-func-int63nn-int64-int64">4.1.8. func Int63n(n int64) int64</a></li>
<li><a href="#419-func-intnn-int-int">4.1.9. func Intn(n int) int</a></li>
<li><a href="#4110-func-normfloat64-float64">4.1.10. func NormFloat64() float64</a></li>
<li><a href="#4111-func-permn-int-int">4.1.11. func Perm(n int) []int</a></li>
<li><a href="#4112-func-readp-byte-n-int-err-error">4.1.12. func Read(p []byte) (n int, err error)</a></li>
<li><a href="#4113-func-seedseed-int64">4.1.13. func Seed(seed int64)</a></li>
<li><a href="#4114-func-shufflen-int-swap-funci-j-int">4.1.14. func Shuffle(n int, swap func(i, j int))</a></li>
<li><a href="#4115-func-uint32-uint32">4.1.15. func Uint32() uint32</a></li>
<li><a href="#4116-func-uint64-uint64">4.1.16. func Uint64() uint64</a></li>
</ul>
</li>
<li><a href="#42-type-rand">4.2. type Rand</a><ul>
<li><a href="#421-func-newsrc-source-rand">4.2.1. func New(src Source) *Rand</a></li>
<li><a href="#422-func-rrand-expfloat64-float64">4.2.2. func (r*Rand) ExpFloat64() float64</a></li>
<li><a href="#423-func-r-rand-float32-float32">4.2.3. func (r *Rand) Float32() float32</a></li>
<li><a href="#424-func-rrand-float64-float64">4.2.4. func (r*Rand) Float64() float64</a></li>
<li><a href="#425-func-r-rand-int-int">4.2.5. func (r *Rand) Int() int</a></li>
<li><a href="#426-func-rrand-int31-int32">4.2.6. func (r*Rand) Int31() int32</a></li>
<li><a href="#427-func-r-rand-int31nn-int32-int32">4.2.7. func (r *Rand) Int31n(n int32) int32</a></li>
<li><a href="#428-func-rrand-int63-int64">4.2.8. func (r*Rand) Int63() int64</a></li>
<li><a href="#429-func-r-rand-int63nn-int64-int64">4.2.9. func (r *Rand) Int63n(n int64) int64</a></li>
<li><a href="#4210-func-rrand-intnn-int-int">4.2.10. func (r*Rand) Intn(n int) int</a></li>
<li><a href="#4211-func-r-rand-normfloat64-float64">4.2.11. func (r *Rand) NormFloat64() float64</a></li>
<li><a href="#4212-func-rrand-permn-int-int">4.2.12. func (r*Rand) Perm(n int) []int</a></li>
<li><a href="#4213-func-r-rand-readp-byte-n-int-err-error">4.2.13. func (r *Rand) Read(p []byte) (n int, err error)</a></li>
<li><a href="#4214-func-rrand-seedseed-int64">4.2.14. func (r*Rand) Seed(seed int64)</a></li>
<li><a href="#4215-func-r-rand-shufflen-int-swap-funci-j-int">4.2.15. func (r *Rand) Shuffle(n int, swap func(i, j int))</a></li>
<li><a href="#4216-func-rrand-uint32-uint32">4.2.16. func (r*Rand) Uint32() uint32</a></li>
<li><a href="#4217-func-r-rand-uint64-uint64">4.2.17. func (r *Rand) Uint64() uint64</a></li>
</ul>
</li>
<li><a href="#43-type-source">4.3. type Source</a><ul>
<li><a href="#431-func-newsourceseed-int64-source">4.3.1. func NewSource(seed int64) Source</a></li>
</ul>
</li>
<li><a href="#44-type-source64">4.4. type Source64</a></li>
<li><a href="#45-type-zipf">4.5. type Zipf</a><ul>
<li><a href="#451-func-newzipfr-rand-s-float64-v-float64-imax-uint64zipf">4.5.1. func NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipf</a></li>
<li><a href="#452-func-z-zipf-uint64-uint64">4.5.2. func (z *Zipf) Uint64() uint64</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-package-tar"><a href="#1-package-tar" class="headerlink" title="1. package tar"></a>1. package tar</h1><p>  Package tar implements access to tar archives.</p>
<p>  Tape(封装) archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.</p>
<h2 id="1-1-Constants"><a href="#1-1-Constants" class="headerlink" title="1.1. Constants"></a>1.1. Constants</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  &#x2F;&#x2F; Type &#39;0&#39; indicates a regular file.
  TypeReg  &#x3D; &#39;0&#39;
  TypeRegA &#x3D; &#39;\x00&#39; &#x2F;&#x2F; Deprecated: Use TypeReg instead.

  &#x2F;&#x2F; Type &#39;1&#39; to &#39;6&#39; are header-only flags and may not have a data body.
  TypeLink    &#x3D; &#39;1&#39; &#x2F;&#x2F; Hard link
  TypeSymlink &#x3D; &#39;2&#39; &#x2F;&#x2F; Symbolic link
  TypeChar    &#x3D; &#39;3&#39; &#x2F;&#x2F; Character device node
  TypeBlock   &#x3D; &#39;4&#39; &#x2F;&#x2F; Block device node
  TypeDir     &#x3D; &#39;5&#39; &#x2F;&#x2F; Directory
  TypeFifo    &#x3D; &#39;6&#39; &#x2F;&#x2F; FIFO node

  &#x2F;&#x2F; Type &#39;7&#39; is reserved.
  TypeCont &#x3D; &#39;7&#39;

  &#x2F;&#x2F; Type &#39;x&#39; is used by the PAX format to store key-value records that
  &#x2F;&#x2F; are only relevant to the next file.
  &#x2F;&#x2F; This package transparently handles these types.
  TypeXHeader &#x3D; &#39;x&#39;

  &#x2F;&#x2F; Type &#39;g&#39; is used by the PAX format to store key-value records that
  &#x2F;&#x2F; are relevant to all subsequent files.
  &#x2F;&#x2F; This package only supports parsing and composing such headers,
  &#x2F;&#x2F; but does not currently support persisting the global state across files.
  TypeXGlobalHeader &#x3D; &#39;g&#39;

  &#x2F;&#x2F; Type &#39;S&#39; indicates a sparse file in the GNU format.
  TypeGNUSparse &#x3D; &#39;S&#39;

  &#x2F;&#x2F; Types &#39;L&#39; and &#39;K&#39; are used by the GNU format for a meta file
  &#x2F;&#x2F; used to store the path or link name for the next file.
  &#x2F;&#x2F; This package transparently handles these types.
  TypeGNULongName &#x3D; &#39;L&#39;
  TypeGNULongLink &#x3D; &#39;K&#39;
)</code></pre>

<h2 id="1-2-Variables"><a href="#1-2-Variables" class="headerlink" title="1.2. Variables"></a>1.2. Variables</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">var (
  ErrHeader          &#x3D; errors.New(&quot;archive&#x2F;tar: invalid tar header&quot;)
  ErrWriteTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: write too long&quot;)
  ErrFieldTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: header field too long&quot;)
  ErrWriteAfterClose &#x3D; errors.New(&quot;archive&#x2F;tar: write after close&quot;)
)</code></pre>

<h2 id="1-3-type-Format"><a href="#1-3-type-Format" class="headerlink" title="1.3. type Format"></a>1.3. type Format</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">type Format int</code></pre>

<p>  Format represents the tar archive format.The original tar format was introduced in Unix V7. Since then, there have been multiple competing(相互竞争) formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the <strong>USTAR</strong>, <strong>PAX</strong>, and <strong>GNU</strong> formats, each with their own advantages and limitations.</p>
<p>  The following table captures the capabilities of each format:</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">                  <span class="token operator">|</span>  USTAR <span class="token operator">|</span>       PAX <span class="token operator">|</span>       GNU
------------------+--------+-----------+----------
Name              <span class="token operator">|</span>   256B <span class="token operator">|</span> unlimited <span class="token operator">|</span> unlimited
Linkname          <span class="token operator">|</span>   100B <span class="token operator">|</span> unlimited <span class="token operator">|</span> unlimited
Size              <span class="token operator">|</span> uint33 <span class="token operator">|</span> unlimited <span class="token operator">|</span>    uint89
Mode              <span class="token operator">|</span> uint21 <span class="token operator">|</span>    uint21 <span class="token operator">|</span>    uint57
Uid/Gid           <span class="token operator">|</span> uint21 <span class="token operator">|</span> unlimited <span class="token operator">|</span>    uint57
Uname/Gname       <span class="token operator">|</span>    32B <span class="token operator">|</span> unlimited <span class="token operator">|</span>       32B
ModTime           <span class="token operator">|</span> uint33 <span class="token operator">|</span> unlimited <span class="token operator">|</span>     int89
AccessTime        <span class="token operator">|</span>    n/a <span class="token operator">|</span> unlimited <span class="token operator">|</span>     int89
ChangeTime        <span class="token operator">|</span>    n/a <span class="token operator">|</span> unlimited <span class="token operator">|</span>     int89
Devmajor/Devminor <span class="token operator">|</span> uint21 <span class="token operator">|</span>    uint21 <span class="token operator">|</span>    uint57
------------------+--------+-----------+----------
string encoding   <span class="token operator">|</span>  ASCII <span class="token operator">|</span>     UTF-8 <span class="token operator">|</span>    binary
sub-second <span class="token builtin class-name">times</span>  <span class="token operator">|</span>     no <span class="token operator">|</span>       <span class="token function">yes</span> <span class="token operator">|</span>        no
sparse files      <span class="token operator">|</span>     no <span class="token operator">|</span>       <span class="token function">yes</span> <span class="token operator">|</span>       <span class="token function">yes</span></code></pre>

<p>  The table’s upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</p>
<p>  The table’s lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</p>
<p>  The Writer currently provides no support for sparse files.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">const (

&#x2F;&#x2F; FormatUnknown indicates that the format is unknown.
FormatUnknown Format
&#x2F;&#x2F; FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.
&#x2F;&#x2F;
&#x2F;&#x2F; While this format is compatible with most tar readers,
&#x2F;&#x2F; the format has several limitations making it unsuitable for some usages.
&#x2F;&#x2F; Most notably, it cannot support sparse files, files larger than 8GiB,
&#x2F;&#x2F; filenames larger than 256 characters, and non-ASCII filenames.
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;pax.html#tag_20_92_13_06
FormatUSTAR
&#x2F;&#x2F; FormatPAX represents the PAX header format defined in POSIX.1-2001.
&#x2F;&#x2F;
&#x2F;&#x2F; PAX extends USTAR by writing a special file with Typeflag TypeXHeader
&#x2F;&#x2F; preceding the original header. This file contains a set of key-value
&#x2F;&#x2F; records, which are used to overcome USTAR\&#39;s shortcomings, in addition to
&#x2F;&#x2F; providing the ability to have sub-second resolution for timestamps.
&#x2F;&#x2F;
&#x2F;&#x2F; Some newer formats add their own extensions to PAX by defining their
&#x2F;&#x2F; own keys and assigning certain semantic meaning to the associated values.
&#x2F;&#x2F; For example, sparse file support in PAX is implemented using keys
&#x2F;&#x2F; defined by the GNU manual (e.g., &quot;GNU.sparse.map&quot;).
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;utilities&#x2F;pax.html
FormatPAX
&#x2F;&#x2F; FormatGNU represents the GNU header format.
&#x2F;&#x2F;
&#x2F;&#x2F; The GNU header format is older than the USTAR and PAX standards and
&#x2F;&#x2F; is not compatible with them. The GNU format supports
&#x2F;&#x2F; arbitrary file sizes, filenames of arbitrary encoding and length,
&#x2F;&#x2F; sparse files, and other features.
&#x2F;&#x2F;
&#x2F;&#x2F; It is recommended that PAX be chosen over GNU unless the target
&#x2F;&#x2F; application can only parse GNU formatted archives.
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;tar&#x2F;manual&#x2F;html_node&#x2F;Standard.html
FormatGNU
)
</code></pre>

<h3 id="1-3-1-func-f-Format-String-string"><a href="#1-3-1-func-f-Format-String-string" class="headerlink" title="1.3.1. func (f Format) String() string"></a>1.3.1. func (f Format) String() string</h3><p>  打印tar的格式</p>
<h2 id="1-4-type-Header"><a href="#1-4-type-Header" class="headerlink" title="1.4. type Header"></a>1.4. type Header</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">  type Header struct &#123;
  &#x2F;&#x2F; Typeflag is the type of header entry.
  &#x2F;&#x2F; The zero value is automatically promoted to either TypeReg or TypeDir
  &#x2F;&#x2F; depending on the presence of a trailing slash in Name.
  Typeflag byte

  Name     string &#x2F;&#x2F; Name of file entry
  Linkname string &#x2F;&#x2F; Target name of link (valid for TypeLink or TypeSymlink)

  Size  int64  &#x2F;&#x2F; Logical file size in bytes
  Mode  int64  &#x2F;&#x2F; Permission and mode bits
  Uid   int    &#x2F;&#x2F; User ID of owner
  Gid   int    &#x2F;&#x2F; Group ID of owner
  Uname string &#x2F;&#x2F; User name of owner
  Gname string &#x2F;&#x2F; Group name of owner

  &#x2F;&#x2F; If the Format is unspecified, then Writer.WriteHeader rounds ModTime
  &#x2F;&#x2F; to the nearest second and ignores the AccessTime and ChangeTime fields.
  &#x2F;&#x2F;
  &#x2F;&#x2F; To use AccessTime or ChangeTime, specify the Format as PAX or GNU.
  &#x2F;&#x2F; To use sub-second resolution, specify the Format as PAX.
  ModTime    time.Time &#x2F;&#x2F; Modification time
  AccessTime time.Time &#x2F;&#x2F; Access time (requires either PAX or GNU support)
  ChangeTime time.Time &#x2F;&#x2F; Change time (requires either PAX or GNU support)

  Devmajor int64 &#x2F;&#x2F; Major device number (valid for TypeChar or TypeBlock)
  Devminor int64 &#x2F;&#x2F; Minor device number (valid for TypeChar or TypeBlock)

  &#x2F;&#x2F; Xattrs stores extended attributes as PAX records under the
  &#x2F;&#x2F; &quot;SCHILY.xattr.&quot; namespace.
  &#x2F;&#x2F;
  &#x2F;&#x2F; The following are semantically equivalent:
  &#x2F;&#x2F;  h.Xattrs[key] &#x3D; value
  &#x2F;&#x2F;  h.PAXRecords[&quot;SCHILY.xattr.&quot;+key] &#x3D; value
  &#x2F;&#x2F;
  &#x2F;&#x2F; When Writer.WriteHeader is called, the contents of Xattrs will take
  &#x2F;&#x2F; precedence over those in PAXRecords.
  &#x2F;&#x2F;
  &#x2F;&#x2F; Deprecated: Use PAXRecords instead.
  Xattrs map[string]string

  &#x2F;&#x2F; PAXRecords is a map of PAX extended header records.
  &#x2F;&#x2F;
  &#x2F;&#x2F; User-defined records should have keys of the following form:
  &#x2F;&#x2F;	VENDOR.keyword
  &#x2F;&#x2F; Where VENDOR is some namespace in all uppercase, and keyword may
  &#x2F;&#x2F; not contain the &#39;&#x3D;&#39; character (e.g., &quot;GOLANG.pkg.version&quot;).
  &#x2F;&#x2F; The key and value should be non-empty UTF-8 strings.
  &#x2F;&#x2F;
  &#x2F;&#x2F; When Writer.WriteHeader is called, PAX records derived from the
  &#x2F;&#x2F; other fields in Header take precedence over PAXRecords.
  PAXRecords map[string]string

  &#x2F;&#x2F; Format specifies the format of the tar header.
  &#x2F;&#x2F;
  &#x2F;&#x2F; This is set by Reader.Next as a best-effort guess at the format.
  &#x2F;&#x2F; Since the Reader liberally reads some non-compliant files,
  &#x2F;&#x2F; it is possible for this to be FormatUnknown.
  &#x2F;&#x2F;
  &#x2F;&#x2F; If the format is unspecified when Writer.WriteHeader is called,
  &#x2F;&#x2F; then it uses the first format (in the order of USTAR, PAX, GNU)
  &#x2F;&#x2F; capable of encoding this Header (see Format).
  Format Format
&#125;
</code></pre>

<h3 id="1-4-1-func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error"><a href="#1-4-1-func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error" class="headerlink" title="1.4.1. func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)"></a>1.4.1. func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)</h3><h3 id="1-4-2-func-h-Header-FileInfo-fs-FileInfo"><a href="#1-4-2-func-h-Header-FileInfo-fs-FileInfo" class="headerlink" title="1.4.2. func (h*Header) FileInfo() fs.FileInfo"></a>1.4.2. func (h*Header) FileInfo() fs.FileInfo</h3><h2 id="1-5-type-Reader"><a href="#1-5-type-Reader" class="headerlink" title="1.5. type Reader"></a>1.5. type Reader</h2><h3 id="1-5-1-func-NewReader-r-io-Reader-Reader"><a href="#1-5-1-func-NewReader-r-io-Reader-Reader" class="headerlink" title="1.5.1. func NewReader(r io.Reader) *Reader"></a>1.5.1. func NewReader(r io.Reader) *Reader</h3><h3 id="1-5-2-func-tr-Reader-Next-Header-error"><a href="#1-5-2-func-tr-Reader-Next-Header-error" class="headerlink" title="1.5.2. func (tr*Reader) Next() (*Header, error)"></a>1.5.2. func (tr*Reader) Next() (*Header, error)</h3><h3 id="1-5-3-func-tr-Reader-Read-b-byte-int-error"><a href="#1-5-3-func-tr-Reader-Read-b-byte-int-error" class="headerlink" title="1.5.3. func (tr*Reader) Read(b []byte) (int, error)"></a>1.5.3. func (tr*Reader) Read(b []byte) (int, error)</h3><h2 id="1-6-type-Writer"><a href="#1-6-type-Writer" class="headerlink" title="1.6. type Writer"></a>1.6. type Writer</h2><h3 id="1-6-1-func-NewWriter-w-io-Writer-Writer"><a href="#1-6-1-func-NewWriter-w-io-Writer-Writer" class="headerlink" title="1.6.1. func NewWriter(w io.Writer) *Writer"></a>1.6.1. func NewWriter(w io.Writer) *Writer</h3><h3 id="1-6-2-func-tw-Writer-Close-error"><a href="#1-6-2-func-tw-Writer-Close-error" class="headerlink" title="1.6.2. func (tw*Writer) Close() error"></a>1.6.2. func (tw*Writer) Close() error</h3><h3 id="1-6-3-func-tw-Writer-Flush-error"><a href="#1-6-3-func-tw-Writer-Flush-error" class="headerlink" title="1.6.3. func (tw *Writer) Flush() error"></a>1.6.3. func (tw *Writer) Flush() error</h3><h3 id="1-6-4-func-tw-Writer-Write-b-byte-int-error"><a href="#1-6-4-func-tw-Writer-Write-b-byte-int-error" class="headerlink" title="1.6.4. func (tw*Writer) Write(b []byte) (int, error)"></a>1.6.4. func (tw*Writer) Write(b []byte) (int, error)</h3><h3 id="1-6-5-func-tw-Writer-WriteHeader-hdrHeader-error"><a href="#1-6-5-func-tw-Writer-WriteHeader-hdrHeader-error" class="headerlink" title="1.6.5. func (tw Writer) WriteHeader(hdrHeader) error"></a>1.6.5. func (tw <em>Writer) WriteHeader(hdr</em>Header) error</h3><h1 id="2-zip-package"><a href="#2-zip-package" class="headerlink" title="2. zip package"></a>2. zip package</h1><h2 id="2-1-Constants"><a href="#2-1-Constants" class="headerlink" title="2.1. Constants"></a>2.1. Constants</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  Store   uint16 &#x3D; 0 &#x2F;&#x2F; no compression
  Deflate uint16 &#x3D; 8 &#x2F;&#x2F; DEFLATE compressed
)</code></pre>

<h2 id="2-2-Variables"><a href="#2-2-Variables" class="headerlink" title="2.2. Variables"></a>2.2. Variables</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">var (
  ErrFormat    &#x3D; errors.New(&quot;zip: not a valid zip file&quot;)
  ErrAlgorithm &#x3D; errors.New(&quot;zip: unsupported compression algorithm&quot;)
  ErrChecksum  &#x3D; errors.New(&quot;zip: checksum error&quot;)
)
</code></pre>

<h3 id="2-2-1-func-RegisterCompressor-method-uint16-comp-Compressor"><a href="#2-2-1-func-RegisterCompressor-method-uint16-comp-Compressor" class="headerlink" title="2.2.1. func RegisterCompressor(method uint16, comp Compressor)"></a>2.2.1. func RegisterCompressor(method uint16, comp Compressor)</h3><h3 id="2-2-2-func-RegisterDecompressor-method-uint16-dcomp-Decompressor"><a href="#2-2-2-func-RegisterDecompressor-method-uint16-dcomp-Decompressor" class="headerlink" title="2.2.2. func RegisterDecompressor(method uint16, dcomp Decompressor)"></a>2.2.2. func RegisterDecompressor(method uint16, dcomp Decompressor)</h3><h2 id="2-3-type-Compressor"><a href="#2-3-type-Compressor" class="headerlink" title="2.3. type Compressor"></a>2.3. type Compressor</h2><h2 id="2-4-type-Decompressor"><a href="#2-4-type-Decompressor" class="headerlink" title="2.4. type Decompressor"></a>2.4. type Decompressor</h2><h2 id="2-5-type-File"><a href="#2-5-type-File" class="headerlink" title="2.5. type File"></a>2.5. type File</h2><h3 id="2-5-1-func-f-File-DataOffset-offset-int64-err-error"><a href="#2-5-1-func-f-File-DataOffset-offset-int64-err-error" class="headerlink" title="2.5.1. func (f *File) DataOffset() (offset int64, err error)"></a>2.5.1. func (f *File) DataOffset() (offset int64, err error)</h3><h3 id="2-5-2-func-f-File-Open-io-ReadCloser-error"><a href="#2-5-2-func-f-File-Open-io-ReadCloser-error" class="headerlink" title="2.5.2. func (f*File) Open() (io.ReadCloser, error)"></a>2.5.2. func (f*File) Open() (io.ReadCloser, error)</h3><h3 id="2-5-3-func-f-File-OpenRaw-io-Reader-error"><a href="#2-5-3-func-f-File-OpenRaw-io-Reader-error" class="headerlink" title="2.5.3. func (f *File) OpenRaw() (io.Reader, error)"></a>2.5.3. func (f *File) OpenRaw() (io.Reader, error)</h3><h2 id="2-6-type-FileHeader"><a href="#2-6-type-FileHeader" class="headerlink" title="2.6. type FileHeader"></a>2.6. type FileHeader</h2><h3 id="2-6-1-func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error"><a href="#2-6-1-func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error" class="headerlink" title="2.6.1. func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)"></a>2.6.1. func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</h3><h3 id="2-6-2-func-h-FileHeader-FileInfo-fs-FileInfo"><a href="#2-6-2-func-h-FileHeader-FileInfo-fs-FileInfo" class="headerlink" title="2.6.2. func (h *FileHeader) FileInfo() fs.FileInfo"></a>2.6.2. func (h *FileHeader) FileInfo() fs.FileInfo</h3><h3 id="2-6-3-func-h-FileHeader-ModTime-time-TimeDEPRECATED"><a href="#2-6-3-func-h-FileHeader-ModTime-time-TimeDEPRECATED" class="headerlink" title="2.6.3. func (h*FileHeader) ModTime() time.TimeDEPRECATED"></a>2.6.3. func (h*FileHeader) ModTime() time.TimeDEPRECATED</h3><h3 id="2-6-4-func-h-FileHeader-Mode-mode-fs-FileMode"><a href="#2-6-4-func-h-FileHeader-Mode-mode-fs-FileMode" class="headerlink" title="2.6.4. func (h *FileHeader) Mode() (mode fs.FileMode)"></a>2.6.4. func (h *FileHeader) Mode() (mode fs.FileMode)</h3><h3 id="2-6-5-func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED"><a href="#2-6-5-func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED" class="headerlink" title="2.6.5. func (h*FileHeader) SetModTime(t time.Time)DEPRECATED"></a>2.6.5. func (h*FileHeader) SetModTime(t time.Time)DEPRECATED</h3><h3 id="2-6-6-func-h-FileHeader-SetMode-mode-fs-FileMode"><a href="#2-6-6-func-h-FileHeader-SetMode-mode-fs-FileMode" class="headerlink" title="2.6.6. func (h *FileHeader) SetMode(mode fs.FileMode)"></a>2.6.6. func (h *FileHeader) SetMode(mode fs.FileMode)</h3><h2 id="2-7-type-ReadCloser"><a href="#2-7-type-ReadCloser" class="headerlink" title="2.7. type ReadCloser"></a>2.7. type ReadCloser</h2><h3 id="2-7-1-func-OpenReader-name-string-ReadCloser-error"><a href="#2-7-1-func-OpenReader-name-string-ReadCloser-error" class="headerlink" title="2.7.1. func OpenReader(name string) (*ReadCloser, error)"></a>2.7.1. func OpenReader(name string) (*ReadCloser, error)</h3><h3 id="2-7-2-func-rc-ReadCloser-Close-error"><a href="#2-7-2-func-rc-ReadCloser-Close-error" class="headerlink" title="2.7.2. func (rc *ReadCloser) Close() error"></a>2.7.2. func (rc *ReadCloser) Close() error</h3><h2 id="2-8-type-Reader"><a href="#2-8-type-Reader" class="headerlink" title="2.8. type Reader"></a>2.8. type Reader</h2><h3 id="2-8-1-func-NewReader-r-io-ReaderAt-size-int64-Reader-error"><a href="#2-8-1-func-NewReader-r-io-ReaderAt-size-int64-Reader-error" class="headerlink" title="2.8.1. func NewReader(r io.ReaderAt, size int64) (*Reader, error)"></a>2.8.1. func NewReader(r io.ReaderAt, size int64) (*Reader, error)</h3><h3 id="2-8-2-func-r-Reader-Open-name-string-fs-File-error"><a href="#2-8-2-func-r-Reader-Open-name-string-fs-File-error" class="headerlink" title="2.8.2. func (r *Reader) Open(name string) (fs.File, error)"></a>2.8.2. func (r *Reader) Open(name string) (fs.File, error)</h3><h3 id="2-8-3-func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor"><a href="#2-8-3-func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor" class="headerlink" title="2.8.3. func (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)"></a>2.8.3. func (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</h3><h2 id="2-9-type-Writer"><a href="#2-9-type-Writer" class="headerlink" title="2.9. type Writer"></a>2.9. type Writer</h2><h3 id="2-9-1-func-NewWriter-w-io-Writer-Writer"><a href="#2-9-1-func-NewWriter-w-io-Writer-Writer" class="headerlink" title="2.9.1. func NewWriter(w io.Writer) *Writer"></a>2.9.1. func NewWriter(w io.Writer) *Writer</h3><h3 id="2-9-2-func-w-Writer-Close-error"><a href="#2-9-2-func-w-Writer-Close-error" class="headerlink" title="2.9.2. func (w*Writer) Close() error"></a>2.9.2. func (w*Writer) Close() error</h3><h3 id="2-9-3-func-w-Writer-Copy-f-File-error"><a href="#2-9-3-func-w-Writer-Copy-f-File-error" class="headerlink" title="2.9.3. func (w *Writer) Copy(f*File) error"></a>2.9.3. func (w *Writer) Copy(f*File) error</h3><h3 id="2-9-4-func-w-Writer-Create-name-string-io-Writer-error"><a href="#2-9-4-func-w-Writer-Create-name-string-io-Writer-error" class="headerlink" title="2.9.4. func (w *Writer) Create(name string) (io.Writer, error)"></a>2.9.4. func (w *Writer) Create(name string) (io.Writer, error)</h3><h3 id="2-9-5-func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error"><a href="#2-9-5-func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error" class="headerlink" title="2.9.5. func (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)"></a>2.9.5. func (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)</h3><h3 id="2-9-6-func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error"><a href="#2-9-6-func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error" class="headerlink" title="2.9.6. func (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)"></a>2.9.6. func (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)</h3><h3 id="2-9-7-func-w-Writer-Flush-error"><a href="#2-9-7-func-w-Writer-Flush-error" class="headerlink" title="2.9.7. func (w*Writer) Flush() error"></a>2.9.7. func (w*Writer) Flush() error</h3><h3 id="2-9-8-func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor"><a href="#2-9-8-func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor" class="headerlink" title="2.9.8. func (w *Writer) RegisterCompressor(method uint16, comp Compressor)"></a>2.9.8. func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</h3><h3 id="2-9-9-func-w-Writer-SetComment-comment-string-error"><a href="#2-9-9-func-w-Writer-SetComment-comment-string-error" class="headerlink" title="2.9.9. func (w*Writer) SetComment(comment string) error"></a>2.9.9. func (w*Writer) SetComment(comment string) error</h3><h3 id="2-9-10-func-w-Writer-SetOffset-n-int64"><a href="#2-9-10-func-w-Writer-SetOffset-n-int64" class="headerlink" title="2.9.10. func (w *Writer) SetOffset(n int64)"></a>2.9.10. func (w *Writer) SetOffset(n int64)</h3><h1 id="3-time-package"><a href="#3-time-package" class="headerlink" title="3. time package"></a>3. time package</h1><h2 id="3-1-Constants"><a href="#3-1-Constants" class="headerlink" title="3.1. Constants"></a>3.1. Constants</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  Layout      &#x3D; &quot;01&#x2F;02 03:04:05PM &#39;06 -0700&quot; &#x2F;&#x2F; The reference time, in numerical order.
  ANSIC       &#x3D; &quot;Mon Jan _2 15:04:05 2006&quot;
  UnixDate    &#x3D; &quot;Mon Jan _2 15:04:05 MST 2006&quot;
  RubyDate    &#x3D; &quot;Mon Jan 02 15:04:05 -0700 2006&quot;
  RFC822      &#x3D; &quot;02 Jan 06 15:04 MST&quot;
  RFC822Z     &#x3D; &quot;02 Jan 06 15:04 -0700&quot; &#x2F;&#x2F; RFC822 with numeric zone
  RFC850      &#x3D; &quot;Monday, 02-Jan-06 15:04:05 MST&quot;
  RFC1123     &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 MST&quot;
  RFC1123Z    &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 -0700&quot; &#x2F;&#x2F; RFC1123 with numeric zone
  RFC3339     &#x3D; &quot;2006-01-02T15:04:05Z07:00&quot;
  RFC3339Nano &#x3D; &quot;2006-01-02T15:04:05.999999999Z07:00&quot;
  Kitchen     &#x3D; &quot;3:04PM&quot;
  &#x2F;&#x2F; Handy time stamps.
  Stamp      &#x3D; &quot;Jan _2 15:04:05&quot;
  StampMilli &#x3D; &quot;Jan _2 15:04:05.000&quot;
  StampMicro &#x3D; &quot;Jan _2 15:04:05.000000&quot;
  StampNano  &#x3D; &quot;Jan _2 15:04:05.000000000&quot;
)</code></pre>

<h3 id="3-1-1-func-After-d-Duration-lt-chan-Time"><a href="#3-1-1-func-After-d-Duration-lt-chan-Time" class="headerlink" title="3.1.1. func After(d Duration) &lt;-chan Time"></a>3.1.1. func After(d Duration) &lt;-chan Time</h3><p>  After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.这里需要注意，这个After(d Duration)是指返回一次的时间戳，想要使用还要再次初始化</p>
<h3 id="3-1-2-func-Sleep-d-Duration"><a href="#3-1-2-func-Sleep-d-Duration" class="headerlink" title="3.1.2. func Sleep(d Duration)"></a>3.1.2. func Sleep(d Duration)</h3><h3 id="3-1-3-func-Tick-d-Duration-lt-chan-Time"><a href="#3-1-3-func-Tick-d-Duration-lt-chan-Time" class="headerlink" title="3.1.3. func Tick(d Duration) &lt;-chan Time"></a>3.1.3. func Tick(d Duration) &lt;-chan Time</h3><h2 id="3-2-type-Duration"><a href="#3-2-type-Duration" class="headerlink" title="3.2. type Duration"></a>3.2. type Duration</h2><h3 id="3-2-1-func-ParseDuration-s-string-Duration-error"><a href="#3-2-1-func-ParseDuration-s-string-Duration-error" class="headerlink" title="3.2.1. func ParseDuration(s string) (Duration, error)"></a>3.2.1. func ParseDuration(s string) (Duration, error)</h3><h3 id="3-2-2-func-Since-t-Time-Duration"><a href="#3-2-2-func-Since-t-Time-Duration" class="headerlink" title="3.2.2. func Since(t Time) Duration"></a>3.2.2. func Since(t Time) Duration</h3><h3 id="3-2-3-func-Until-t-Time-Duration"><a href="#3-2-3-func-Until-t-Time-Duration" class="headerlink" title="3.2.3. func Until(t Time) Duration"></a>3.2.3. func Until(t Time) Duration</h3><h3 id="3-2-4-func-d-Duration-Abs-Duration"><a href="#3-2-4-func-d-Duration-Abs-Duration" class="headerlink" title="3.2.4. func (d Duration) Abs() Duration"></a>3.2.4. func (d Duration) Abs() Duration</h3><h3 id="3-2-5-func-d-Duration-Hours-float64"><a href="#3-2-5-func-d-Duration-Hours-float64" class="headerlink" title="3.2.5. func (d Duration) Hours() float64"></a>3.2.5. func (d Duration) Hours() float64</h3><h3 id="3-2-6-func-d-Duration-Microseconds-int64"><a href="#3-2-6-func-d-Duration-Microseconds-int64" class="headerlink" title="3.2.6. func (d Duration) Microseconds() int64"></a>3.2.6. func (d Duration) Microseconds() int64</h3><h3 id="3-2-7-func-d-Duration-Milliseconds-int64"><a href="#3-2-7-func-d-Duration-Milliseconds-int64" class="headerlink" title="3.2.7. func (d Duration) Milliseconds() int64"></a>3.2.7. func (d Duration) Milliseconds() int64</h3><h3 id="3-2-8-func-d-Duration-Minutes-float64"><a href="#3-2-8-func-d-Duration-Minutes-float64" class="headerlink" title="3.2.8. func (d Duration) Minutes() float64"></a>3.2.8. func (d Duration) Minutes() float64</h3><h3 id="3-2-9-func-d-Duration-Nanoseconds-int64"><a href="#3-2-9-func-d-Duration-Nanoseconds-int64" class="headerlink" title="3.2.9. func (d Duration) Nanoseconds() int64"></a>3.2.9. func (d Duration) Nanoseconds() int64</h3><h3 id="3-2-10-func-d-Duration-Round-m-Duration-Duration"><a href="#3-2-10-func-d-Duration-Round-m-Duration-Duration" class="headerlink" title="3.2.10. func (d Duration) Round(m Duration) Duration"></a>3.2.10. func (d Duration) Round(m Duration) Duration</h3><h3 id="3-2-11-func-d-Duration-Seconds-float64"><a href="#3-2-11-func-d-Duration-Seconds-float64" class="headerlink" title="3.2.11. func (d Duration) Seconds() float64"></a>3.2.11. func (d Duration) Seconds() float64</h3><h3 id="3-2-12-func-d-Duration-String-string"><a href="#3-2-12-func-d-Duration-String-string" class="headerlink" title="3.2.12. func (d Duration) String() string"></a>3.2.12. func (d Duration) String() string</h3><h3 id="3-2-13-func-d-Duration-Truncate-m-Duration-Duration"><a href="#3-2-13-func-d-Duration-Truncate-m-Duration-Duration" class="headerlink" title="3.2.13. func (d Duration) Truncate(m Duration) Duration"></a>3.2.13. func (d Duration) Truncate(m Duration) Duration</h3><h2 id="3-3-type-Location"><a href="#3-3-type-Location" class="headerlink" title="3.3. type Location"></a>3.3. type Location</h2><h3 id="3-3-1-func-FixedZone-name-string-offset-int-Location"><a href="#3-3-1-func-FixedZone-name-string-offset-int-Location" class="headerlink" title="3.3.1. func FixedZone(name string, offset int) *Location"></a>3.3.1. func FixedZone(name string, offset int) *Location</h3><h3 id="3-3-2-func-LoadLocation-name-string-Location-error"><a href="#3-3-2-func-LoadLocation-name-string-Location-error" class="headerlink" title="3.3.2. func LoadLocation(name string) (*Location, error)"></a>3.3.2. func LoadLocation(name string) (*Location, error)</h3><h3 id="3-3-3-func-LoadLocationFromTZData-name-string-data-byte-Location-error"><a href="#3-3-3-func-LoadLocationFromTZData-name-string-data-byte-Location-error" class="headerlink" title="3.3.3. func LoadLocationFromTZData(name string, data []byte) (*Location, error)"></a>3.3.3. func LoadLocationFromTZData(name string, data []byte) (*Location, error)</h3><h3 id="3-3-4-func-l-Location-String-string"><a href="#3-3-4-func-l-Location-String-string" class="headerlink" title="3.3.4. func (l*Location) String() string"></a>3.3.4. func (l*Location) String() string</h3><h2 id="3-4-type-Month"><a href="#3-4-type-Month" class="headerlink" title="3.4. type Month"></a>3.4. type Month</h2><h3 id="3-4-1-func-m-Month-String-string"><a href="#3-4-1-func-m-Month-String-string" class="headerlink" title="3.4.1. func (m Month) String() string"></a>3.4.1. func (m Month) String() string</h3><h2 id="3-5-type-ParseError"><a href="#3-5-type-ParseError" class="headerlink" title="3.5. type ParseError"></a>3.5. type ParseError</h2><h3 id="3-5-1-func-e-ParseError-Error-string"><a href="#3-5-1-func-e-ParseError-Error-string" class="headerlink" title="3.5.1. func (e *ParseError) Error() string"></a>3.5.1. func (e *ParseError) Error() string</h3><h2 id="3-6-type-Ticker"><a href="#3-6-type-Ticker" class="headerlink" title="3.6. type Ticker"></a>3.6. type Ticker</h2><p>  A Ticker holds a channel that delivers “ticks” of a clock at <strong>intervals</strong>.</p>
<h3 id="3-6-1-func-NewTicker-d-Duration-Ticker"><a href="#3-6-1-func-NewTicker-d-Duration-Ticker" class="headerlink" title="3.6.1. func NewTicker(d Duration) *Ticker"></a>3.6.1. func NewTicker(d Duration) *Ticker</h3><p>  NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. <strong>The ticker will adjust the time interval or drop ticks to make up for slow receivers</strong>. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</p>
<h3 id="3-6-2-func-t-Ticker-Reset-d-Duration"><a href="#3-6-2-func-t-Ticker-Reset-d-Duration" class="headerlink" title="3.6.2. func (t *Ticker) Reset(d Duration)"></a>3.6.2. func (t *Ticker) Reset(d Duration)</h3><p>  Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic.</p>
<h3 id="3-6-3-func-t-Ticker-Stop"><a href="#3-6-3-func-t-Ticker-Stop" class="headerlink" title="3.6.3. func (t *Ticker) Stop()"></a>3.6.3. func (t *Ticker) Stop()</h3><p>  Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous “tick”.</p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><h3 id="func-Find-n-int-cmp-func-int-int-i-int-found-bool"><a href="#func-Find-n-int-cmp-func-int-int-i-int-found-bool" class="headerlink" title="func Find(n int, cmp func(int) int) (i int, found bool)"></a>func Find(n int, cmp func(int) int) (i int, found bool)</h3><h3 id="func-Float64s-x-float64"><a href="#func-Float64s-x-float64" class="headerlink" title="func Float64s(x []float64)"></a>func Float64s(x []float64)</h3><h3 id="func-Float64sAreSorted-x-float64-bool"><a href="#func-Float64sAreSorted-x-float64-bool" class="headerlink" title="func Float64sAreSorted(x []float64) bool"></a>func Float64sAreSorted(x []float64) bool</h3><h3 id="func-Ints-x-int"><a href="#func-Ints-x-int" class="headerlink" title="func Ints(x []int)"></a>func Ints(x []int)</h3><p>就是排序基础数据类型int的</p>
<h3 id="func-IntsAreSorted-x-int-bool"><a href="#func-IntsAreSorted-x-int-bool" class="headerlink" title="func IntsAreSorted(x []int) bool"></a>func IntsAreSorted(x []int) bool</h3><h3 id="func-IsSorted-data-Interface-bool"><a href="#func-IsSorted-data-Interface-bool" class="headerlink" title="func IsSorted(data Interface) bool"></a>func IsSorted(data Interface) bool</h3><h3 id="func-Search-n-int-f-func-int-bool-int"><a href="#func-Search-n-int-f-func-int-bool-int" class="headerlink" title="func Search(n int, f func(int) bool) int"></a>func Search(n int, f func(int) bool) int</h3><h3 id="func-SearchFloat64s-a-float64-x-float64-int"><a href="#func-SearchFloat64s-a-float64-x-float64-int" class="headerlink" title="func SearchFloat64s(a []float64, x float64) int"></a>func SearchFloat64s(a []float64, x float64) int</h3><h3 id="func-SearchInts-a-int-x-int-int"><a href="#func-SearchInts-a-int-x-int-int" class="headerlink" title="func SearchInts(a []int, x int) int"></a>func SearchInts(a []int, x int) int</h3><h3 id="func-SearchStrings-a-string-x-string-int"><a href="#func-SearchStrings-a-string-x-string-int" class="headerlink" title="func SearchStrings(a []string, x string) int"></a>func SearchStrings(a []string, x string) int</h3><h3 id="func-Slice-x-any-less-func-i-j-int-bool"><a href="#func-Slice-x-any-less-func-i-j-int-bool" class="headerlink" title="func Slice(x any, less func(i, j int) bool)"></a>func Slice(x any, less func(i, j int) bool)</h3><h3 id="func-SliceIsSorted-x-any-less-func-i-j-int-bool-bool"><a href="#func-SliceIsSorted-x-any-less-func-i-j-int-bool-bool" class="headerlink" title="func SliceIsSorted(x any, less func(i, j int) bool) bool"></a>func SliceIsSorted(x any, less func(i, j int) bool) bool</h3><h3 id="func-SliceStable-x-any-less-func-i-j-int-bool"><a href="#func-SliceStable-x-any-less-func-i-j-int-bool" class="headerlink" title="func SliceStable(x any, less func(i, j int) bool)"></a>func SliceStable(x any, less func(i, j int) bool)</h3><h3 id="func-Sort-data-Interface"><a href="#func-Sort-data-Interface" class="headerlink" title="func Sort(data Interface)"></a>func Sort(data Interface)</h3><h3 id="func-Stable-data-Interface"><a href="#func-Stable-data-Interface" class="headerlink" title="func Stable(data Interface)"></a>func Stable(data Interface)</h3><h3 id="func-Strings-x-string"><a href="#func-Strings-x-string" class="headerlink" title="func Strings(x []string)"></a>func Strings(x []string)</h3><h3 id="func-StringsAreSorted-x-string-bool"><a href="#func-StringsAreSorted-x-string-bool" class="headerlink" title="func StringsAreSorted(x []string) bool"></a>func StringsAreSorted(x []string) bool</h3><h2 id="type-Float64Slice"><a href="#type-Float64Slice" class="headerlink" title="type Float64Slice"></a>type Float64Slice</h2><h3 id="func-x-Float64Slice-Len-int"><a href="#func-x-Float64Slice-Len-int" class="headerlink" title="func (x Float64Slice) Len() int"></a>func (x Float64Slice) Len() int</h3><h3 id="func-x-Float64Slice-Less-i-j-int-bool"><a href="#func-x-Float64Slice-Less-i-j-int-bool" class="headerlink" title="func (x Float64Slice) Less(i, j int) bool"></a>func (x Float64Slice) Less(i, j int) bool</h3><h3 id="func-p-Float64Slice-Search-x-float64-int"><a href="#func-p-Float64Slice-Search-x-float64-int" class="headerlink" title="func (p Float64Slice) Search(x float64) int"></a>func (p Float64Slice) Search(x float64) int</h3><h3 id="func-x-Float64Slice-Sort"><a href="#func-x-Float64Slice-Sort" class="headerlink" title="func (x Float64Slice) Sort()"></a>func (x Float64Slice) Sort()</h3><h3 id="func-x-Float64Slice-Swap-i-j-int"><a href="#func-x-Float64Slice-Swap-i-j-int" class="headerlink" title="func (x Float64Slice) Swap(i, j int)"></a>func (x Float64Slice) Swap(i, j int)</h3><h2 id="type-IntSlice"><a href="#type-IntSlice" class="headerlink" title="type IntSlice"></a>type IntSlice</h2><h3 id="func-x-IntSlice-Len-int"><a href="#func-x-IntSlice-Len-int" class="headerlink" title="func (x IntSlice) Len() int"></a>func (x IntSlice) Len() int</h3><h3 id="func-x-IntSlice-Less-i-j-int-bool"><a href="#func-x-IntSlice-Less-i-j-int-bool" class="headerlink" title="func (x IntSlice) Less(i, j int) bool"></a>func (x IntSlice) Less(i, j int) bool</h3><h3 id="func-p-IntSlice-Search-x-int-int"><a href="#func-p-IntSlice-Search-x-int-int" class="headerlink" title="func (p IntSlice) Search(x int) int"></a>func (p IntSlice) Search(x int) int</h3><h3 id="func-x-IntSlice-Sort"><a href="#func-x-IntSlice-Sort" class="headerlink" title="func (x IntSlice) Sort()"></a>func (x IntSlice) Sort()</h3><h3 id="func-x-IntSlice-Swap-i-j-int"><a href="#func-x-IntSlice-Swap-i-j-int" class="headerlink" title="func (x IntSlice) Swap(i, j int)"></a>func (x IntSlice) Swap(i, j int)</h3><h2 id="type-Interface"><a href="#type-Interface" class="headerlink" title="type Interface"></a>type Interface</h2><h3 id="func-Reverse-data-Interface-Interface"><a href="#func-Reverse-data-Interface-Interface" class="headerlink" title="func Reverse(data Interface) Interface"></a>func Reverse(data Interface) Interface</h3><h2 id="type-StringSlice"><a href="#type-StringSlice" class="headerlink" title="type StringSlice"></a>type StringSlice</h2><h3 id="func-x-StringSlice-Len-int"><a href="#func-x-StringSlice-Len-int" class="headerlink" title="func (x StringSlice) Len() int"></a>func (x StringSlice) Len() int</h3><h3 id="func-x-StringSlice-Less-i-j-int-bool"><a href="#func-x-StringSlice-Less-i-j-int-bool" class="headerlink" title="func (x StringSlice) Less(i, j int) bool"></a>func (x StringSlice) Less(i, j int) bool</h3><h3 id="func-p-StringSlice-Search-x-string-int"><a href="#func-p-StringSlice-Search-x-string-int" class="headerlink" title="func (p StringSlice) Search(x string) int"></a>func (p StringSlice) Search(x string) int</h3><h3 id="func-x-StringSlice-Sort"><a href="#func-x-StringSlice-Sort" class="headerlink" title="func (x StringSlice) Sort()"></a>func (x StringSlice) Sort()</h3><h3 id="func-x-StringSlice-Swap-i-j-int"><a href="#func-x-StringSlice-Swap-i-j-int" class="headerlink" title="func (x StringSlice) Swap(i, j int)"></a>func (x StringSlice) Swap(i, j int)</h3><h2 id="3-7-type-Time"><a href="#3-7-type-Time" class="headerlink" title="3.7. type Time"></a>3.7. type Time</h2><h3 id="3-7-1-func-Date-year-int-month-Month-day-hour-min-sec-nsec-int-loc-Location-Time"><a href="#3-7-1-func-Date-year-int-month-Month-day-hour-min-sec-nsec-int-loc-Location-Time" class="headerlink" title="3.7.1. func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time"></a>3.7.1. func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</h3><h3 id="3-7-2-func-Now-Time"><a href="#3-7-2-func-Now-Time" class="headerlink" title="3.7.2. func Now() Time"></a>3.7.2. func Now() Time</h3><h3 id="3-7-3-func-Parse-layout-value-string-Time-error"><a href="#3-7-3-func-Parse-layout-value-string-Time-error" class="headerlink" title="3.7.3. func Parse(layout, value string) (Time, error)"></a>3.7.3. func Parse(layout, value string) (Time, error)</h3><h3 id="3-7-4-func-ParseInLocation-layout-value-string-loc-Location-Time-error"><a href="#3-7-4-func-ParseInLocation-layout-value-string-loc-Location-Time-error" class="headerlink" title="3.7.4. func ParseInLocation(layout, value string, loc *Location) (Time, error)"></a>3.7.4. func ParseInLocation(layout, value string, loc *Location) (Time, error)</h3><h3 id="3-7-5-func-Unix-sec-int64-nsec-int64-Time"><a href="#3-7-5-func-Unix-sec-int64-nsec-int64-Time" class="headerlink" title="3.7.5. func Unix(sec int64, nsec int64) Time"></a>3.7.5. func Unix(sec int64, nsec int64) Time</h3><h3 id="3-7-6-func-UnixMicro-usec-int64-Time"><a href="#3-7-6-func-UnixMicro-usec-int64-Time" class="headerlink" title="3.7.6. func UnixMicro(usec int64) Time"></a>3.7.6. func UnixMicro(usec int64) Time</h3><h3 id="3-7-7-func-UnixMilli-msec-int64-Time"><a href="#3-7-7-func-UnixMilli-msec-int64-Time" class="headerlink" title="3.7.7. func UnixMilli(msec int64) Time"></a>3.7.7. func UnixMilli(msec int64) Time</h3><h3 id="3-7-8-func-t-Time-Add-d-Duration-Time"><a href="#3-7-8-func-t-Time-Add-d-Duration-Time" class="headerlink" title="3.7.8. func (t Time) Add(d Duration) Time"></a>3.7.8. func (t Time) Add(d Duration) Time</h3><h3 id="3-7-9-func-t-Time-AddDate-years-int-months-int-days-int-Time"><a href="#3-7-9-func-t-Time-AddDate-years-int-months-int-days-int-Time" class="headerlink" title="3.7.9. func (t Time) AddDate(years int, months int, days int) Time"></a>3.7.9. func (t Time) AddDate(years int, months int, days int) Time</h3><h3 id="3-7-10-func-t-Time-After-u-Time-bool"><a href="#3-7-10-func-t-Time-After-u-Time-bool" class="headerlink" title="3.7.10. func (t Time) After(u Time) bool"></a>3.7.10. func (t Time) After(u Time) bool</h3><h3 id="3-7-11-func-t-Time-AppendFormat-b-byte-layout-string-byte"><a href="#3-7-11-func-t-Time-AppendFormat-b-byte-layout-string-byte" class="headerlink" title="3.7.11. func (t Time) AppendFormat(b []byte, layout string) []byte"></a>3.7.11. func (t Time) AppendFormat(b []byte, layout string) []byte</h3><h3 id="3-7-12-func-t-Time-Before-u-Time-bool"><a href="#3-7-12-func-t-Time-Before-u-Time-bool" class="headerlink" title="3.7.12. func (t Time) Before(u Time) bool"></a>3.7.12. func (t Time) Before(u Time) bool</h3><h3 id="3-7-13-func-t-Time-Clock-hour-min-sec-int"><a href="#3-7-13-func-t-Time-Clock-hour-min-sec-int" class="headerlink" title="3.7.13. func (t Time) Clock() (hour, min, sec int)"></a>3.7.13. func (t Time) Clock() (hour, min, sec int)</h3><h3 id="3-7-14-func-t-Time-Date-year-int-month-Month-day-int"><a href="#3-7-14-func-t-Time-Date-year-int-month-Month-day-int" class="headerlink" title="3.7.14. func (t Time) Date() (year int, month Month, day int)"></a>3.7.14. func (t Time) Date() (year int, month Month, day int)</h3><h3 id="3-7-15-func-t-Time-Day-int"><a href="#3-7-15-func-t-Time-Day-int" class="headerlink" title="3.7.15. func (t Time) Day() int"></a>3.7.15. func (t Time) Day() int</h3><h3 id="3-7-16-func-t-Time-Equal-u-Time-bool"><a href="#3-7-16-func-t-Time-Equal-u-Time-bool" class="headerlink" title="3.7.16. func (t Time) Equal(u Time) bool"></a>3.7.16. func (t Time) Equal(u Time) bool</h3><h3 id="3-7-17-func-t-Time-Format-layout-string-string"><a href="#3-7-17-func-t-Time-Format-layout-string-string" class="headerlink" title="3.7.17. func (t Time) Format(layout string) string"></a>3.7.17. func (t Time) Format(layout string) string</h3><h3 id="3-7-18-func-t-Time-GoString-string"><a href="#3-7-18-func-t-Time-GoString-string" class="headerlink" title="3.7.18. func (t Time) GoString() string"></a>3.7.18. func (t Time) GoString() string</h3><h3 id="3-7-19-func-t-Time-GobDecode-data-byte-error"><a href="#3-7-19-func-t-Time-GobDecode-data-byte-error" class="headerlink" title="3.7.19. func (t *Time) GobDecode(data []byte) error"></a>3.7.19. func (t *Time) GobDecode(data []byte) error</h3><h3 id="3-7-20-func-t-Time-GobEncode-byte-error"><a href="#3-7-20-func-t-Time-GobEncode-byte-error" class="headerlink" title="3.7.20. func (t Time) GobEncode() ([]byte, error)"></a>3.7.20. func (t Time) GobEncode() ([]byte, error)</h3><h3 id="3-7-21-func-t-Time-Hour-int"><a href="#3-7-21-func-t-Time-Hour-int" class="headerlink" title="3.7.21. func (t Time) Hour() int"></a>3.7.21. func (t Time) Hour() int</h3><h3 id="3-7-22-func-t-Time-ISOWeek-year-week-int"><a href="#3-7-22-func-t-Time-ISOWeek-year-week-int" class="headerlink" title="3.7.22. func (t Time) ISOWeek() (year, week int)"></a>3.7.22. func (t Time) ISOWeek() (year, week int)</h3><h3 id="3-7-23-func-t-Time-In-loc-Location-Time"><a href="#3-7-23-func-t-Time-In-loc-Location-Time" class="headerlink" title="3.7.23. func (t Time) In(loc*Location) Time"></a>3.7.23. func (t Time) In(loc*Location) Time</h3><h3 id="3-7-24-func-t-Time-IsDST-bool"><a href="#3-7-24-func-t-Time-IsDST-bool" class="headerlink" title="3.7.24. func (t Time) IsDST() bool"></a>3.7.24. func (t Time) IsDST() bool</h3><h3 id="3-7-25-func-t-Time-IsZero-bool"><a href="#3-7-25-func-t-Time-IsZero-bool" class="headerlink" title="3.7.25. func (t Time) IsZero() bool"></a>3.7.25. func (t Time) IsZero() bool</h3><h3 id="3-7-26-func-t-Time-Local-Time"><a href="#3-7-26-func-t-Time-Local-Time" class="headerlink" title="3.7.26. func (t Time) Local() Time"></a>3.7.26. func (t Time) Local() Time</h3><h3 id="3-7-27-func-t-Time-Location-Location"><a href="#3-7-27-func-t-Time-Location-Location" class="headerlink" title="3.7.27. func (t Time) Location() *Location"></a>3.7.27. func (t Time) Location() *Location</h3><h3 id="3-7-28-func-t-Time-MarshalBinary-byte-error"><a href="#3-7-28-func-t-Time-MarshalBinary-byte-error" class="headerlink" title="3.7.28. func (t Time) MarshalBinary() ([]byte, error)"></a>3.7.28. func (t Time) MarshalBinary() ([]byte, error)</h3><h3 id="3-7-29-func-t-Time-MarshalJSON-byte-error"><a href="#3-7-29-func-t-Time-MarshalJSON-byte-error" class="headerlink" title="3.7.29. func (t Time) MarshalJSON() ([]byte, error)"></a>3.7.29. func (t Time) MarshalJSON() ([]byte, error)</h3><h3 id="3-7-30-func-t-Time-MarshalText-byte-error"><a href="#3-7-30-func-t-Time-MarshalText-byte-error" class="headerlink" title="3.7.30. func (t Time) MarshalText() ([]byte, error)"></a>3.7.30. func (t Time) MarshalText() ([]byte, error)</h3><h3 id="3-7-31-func-t-Time-Minute-int"><a href="#3-7-31-func-t-Time-Minute-int" class="headerlink" title="3.7.31. func (t Time) Minute() int"></a>3.7.31. func (t Time) Minute() int</h3><h3 id="3-7-32-func-t-Time-Month-Month"><a href="#3-7-32-func-t-Time-Month-Month" class="headerlink" title="3.7.32. func (t Time) Month() Month"></a>3.7.32. func (t Time) Month() Month</h3><h3 id="3-7-33-func-t-Time-Nanosecond-int"><a href="#3-7-33-func-t-Time-Nanosecond-int" class="headerlink" title="3.7.33. func (t Time) Nanosecond() int"></a>3.7.33. func (t Time) Nanosecond() int</h3><h3 id="3-7-34-func-t-Time-Round-d-Duration-Time"><a href="#3-7-34-func-t-Time-Round-d-Duration-Time" class="headerlink" title="3.7.34. func (t Time) Round(d Duration) Time"></a>3.7.34. func (t Time) Round(d Duration) Time</h3><h3 id="3-7-35-func-t-Time-Second-int"><a href="#3-7-35-func-t-Time-Second-int" class="headerlink" title="3.7.35. func (t Time) Second() int"></a>3.7.35. func (t Time) Second() int</h3><h3 id="3-7-36-func-t-Time-String-string"><a href="#3-7-36-func-t-Time-String-string" class="headerlink" title="3.7.36. func (t Time) String() string"></a>3.7.36. func (t Time) String() string</h3><h3 id="3-7-37-func-t-Time-Sub-u-Time-Duration"><a href="#3-7-37-func-t-Time-Sub-u-Time-Duration" class="headerlink" title="3.7.37. func (t Time) Sub(u Time) Duration"></a>3.7.37. func (t Time) Sub(u Time) Duration</h3><h3 id="3-7-38-func-t-Time-Truncate-d-Duration-Time"><a href="#3-7-38-func-t-Time-Truncate-d-Duration-Time" class="headerlink" title="3.7.38. func (t Time) Truncate(d Duration) Time"></a>3.7.38. func (t Time) Truncate(d Duration) Time</h3><h3 id="3-7-39-func-t-Time-UTC-Time"><a href="#3-7-39-func-t-Time-UTC-Time" class="headerlink" title="3.7.39. func (t Time) UTC() Time"></a>3.7.39. func (t Time) UTC() Time</h3><h3 id="3-7-40-func-t-Time-Unix-int64"><a href="#3-7-40-func-t-Time-Unix-int64" class="headerlink" title="3.7.40. func (t Time) Unix() int64"></a>3.7.40. func (t Time) Unix() int64</h3><h3 id="3-7-41-func-t-Time-UnixMicro-int64"><a href="#3-7-41-func-t-Time-UnixMicro-int64" class="headerlink" title="3.7.41. func (t Time) UnixMicro() int64"></a>3.7.41. func (t Time) UnixMicro() int64</h3><h3 id="3-7-42-func-t-Time-UnixMilli-int64"><a href="#3-7-42-func-t-Time-UnixMilli-int64" class="headerlink" title="3.7.42. func (t Time) UnixMilli() int64"></a>3.7.42. func (t Time) UnixMilli() int64</h3><h3 id="3-7-43-func-t-Time-UnixNano-int64"><a href="#3-7-43-func-t-Time-UnixNano-int64" class="headerlink" title="3.7.43. func (t Time) UnixNano() int64"></a>3.7.43. func (t Time) UnixNano() int64</h3><h3 id="3-7-44-func-t-Time-UnmarshalBinary-data-byte-error"><a href="#3-7-44-func-t-Time-UnmarshalBinary-data-byte-error" class="headerlink" title="3.7.44. func (t*Time) UnmarshalBinary(data []byte) error"></a>3.7.44. func (t*Time) UnmarshalBinary(data []byte) error</h3><h3 id="3-7-45-func-t-Time-UnmarshalJSON-data-byte-error"><a href="#3-7-45-func-t-Time-UnmarshalJSON-data-byte-error" class="headerlink" title="3.7.45. func (t *Time) UnmarshalJSON(data []byte) error"></a>3.7.45. func (t *Time) UnmarshalJSON(data []byte) error</h3><h3 id="3-7-46-func-t-Time-UnmarshalText-data-byte-error"><a href="#3-7-46-func-t-Time-UnmarshalText-data-byte-error" class="headerlink" title="3.7.46. func (t*Time) UnmarshalText(data []byte) error"></a>3.7.46. func (t*Time) UnmarshalText(data []byte) error</h3><h3 id="3-7-47-func-t-Time-Weekday-Weekday"><a href="#3-7-47-func-t-Time-Weekday-Weekday" class="headerlink" title="3.7.47. func (t Time) Weekday() Weekday"></a>3.7.47. func (t Time) Weekday() Weekday</h3><h3 id="3-7-48-func-t-Time-Year-int"><a href="#3-7-48-func-t-Time-Year-int" class="headerlink" title="3.7.48. func (t Time) Year() int"></a>3.7.48. func (t Time) Year() int</h3><h3 id="3-7-49-func-t-Time-YearDay-int"><a href="#3-7-49-func-t-Time-YearDay-int" class="headerlink" title="3.7.49. func (t Time) YearDay() int"></a>3.7.49. func (t Time) YearDay() int</h3><h3 id="3-7-50-func-t-Time-Zone-name-string-offset-int"><a href="#3-7-50-func-t-Time-Zone-name-string-offset-int" class="headerlink" title="3.7.50. func (t Time) Zone() (name string, offset int)"></a>3.7.50. func (t Time) Zone() (name string, offset int)</h3><h3 id="3-7-51-func-t-Time-ZoneBounds-start-end-Time"><a href="#3-7-51-func-t-Time-ZoneBounds-start-end-Time" class="headerlink" title="3.7.51. func (t Time) ZoneBounds() (start, end Time)"></a>3.7.51. func (t Time) ZoneBounds() (start, end Time)</h3><h3 id="3-7-52-type-Timer"><a href="#3-7-52-type-Timer" class="headerlink" title="3.7.52. type Timer"></a>3.7.52. type Timer</h3>  <pre class="language-golang" data-language="golang"><code class="language-golang">type Timer struct &#123;
  C &lt;-chan Time
  &#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>

<p>  这里的C用于接收</p>
<h3 id="3-7-53-func-AfterFunc-d-Duration-f-func-Timer"><a href="#3-7-53-func-AfterFunc-d-Duration-f-func-Timer" class="headerlink" title="3.7.53. func AfterFunc(d Duration, f func()) *Timer"></a>3.7.53. func AfterFunc(d Duration, f func()) *Timer</h3><h3 id="3-7-54-func-NewTimer-d-Duration-Timer"><a href="#3-7-54-func-NewTimer-d-Duration-Timer" class="headerlink" title="3.7.54. func NewTimer(d Duration)*Timer"></a>3.7.54. func NewTimer(d Duration)*Timer</h3><h3 id="3-7-55-func-t-Timer-Reset-d-Duration-bool"><a href="#3-7-55-func-t-Timer-Reset-d-Duration-bool" class="headerlink" title="3.7.55. func (t *Timer) Reset(d Duration) bool"></a>3.7.55. func (t *Timer) Reset(d Duration) bool</h3><h3 id="3-7-56-func-t-Timer-Stop-bool"><a href="#3-7-56-func-t-Timer-Stop-bool" class="headerlink" title="3.7.56. func (t*Timer) Stop() bool"></a>3.7.56. func (t*Timer) Stop() bool</h3><h2 id="3-8-type-Weekday"><a href="#3-8-type-Weekday" class="headerlink" title="3.8. type Weekday"></a>3.8. type Weekday</h2><h3 id="3-8-1-func-d-Weekday-String-string"><a href="#3-8-1-func-d-Weekday-String-string" class="headerlink" title="3.8.1. func (d Weekday) String() string"></a>3.8.1. func (d Weekday) String() string</h3><h1 id="4-rand"><a href="#4-rand" class="headerlink" title="4. rand"></a>4. rand</h1><h2 id="4-1-function-not-method-of-rand"><a href="#4-1-function-not-method-of-rand" class="headerlink" title="4.1. function not method of rand"></a>4.1. function not method of rand</h2><h3 id="4-1-1-func-ExpFloat64-float64"><a href="#4-1-1-func-ExpFloat64-float64" class="headerlink" title="4.1.1. func ExpFloat64() float64"></a>4.1.1. func ExpFloat64() float64</h3><h3 id="4-1-2-func-Float32-float32"><a href="#4-1-2-func-Float32-float32" class="headerlink" title="4.1.2. func Float32() float32"></a>4.1.2. func Float32() float32</h3><h3 id="4-1-3-func-Float64-float64"><a href="#4-1-3-func-Float64-float64" class="headerlink" title="4.1.3. func Float64() float64"></a>4.1.3. func Float64() float64</h3><h3 id="4-1-4-func-Int-int"><a href="#4-1-4-func-Int-int" class="headerlink" title="4.1.4. func Int() int"></a>4.1.4. func Int() int</h3><h3 id="4-1-5-func-Int31-int32"><a href="#4-1-5-func-Int31-int32" class="headerlink" title="4.1.5. func Int31() int32"></a>4.1.5. func Int31() int32</h3><h3 id="4-1-6-func-Int31n-n-int32-int32"><a href="#4-1-6-func-Int31n-n-int32-int32" class="headerlink" title="4.1.6. func Int31n(n int32) int32"></a>4.1.6. func Int31n(n int32) int32</h3><h3 id="4-1-7-func-Int63-int64"><a href="#4-1-7-func-Int63-int64" class="headerlink" title="4.1.7. func Int63() int64"></a>4.1.7. func Int63() int64</h3><h3 id="4-1-8-func-Int63n-n-int64-int64"><a href="#4-1-8-func-Int63n-n-int64-int64" class="headerlink" title="4.1.8. func Int63n(n int64) int64"></a>4.1.8. func Int63n(n int64) int64</h3><h3 id="4-1-9-func-Intn-n-int-int"><a href="#4-1-9-func-Intn-n-int-int" class="headerlink" title="4.1.9. func Intn(n int) int"></a>4.1.9. func Intn(n int) int</h3><h3 id="4-1-10-func-NormFloat64-float64"><a href="#4-1-10-func-NormFloat64-float64" class="headerlink" title="4.1.10. func NormFloat64() float64"></a>4.1.10. func NormFloat64() float64</h3><h3 id="4-1-11-func-Perm-n-int-int"><a href="#4-1-11-func-Perm-n-int-int" class="headerlink" title="4.1.11. func Perm(n int) []int"></a>4.1.11. func Perm(n int) []int</h3><h3 id="4-1-12-func-Read-p-byte-n-int-err-error"><a href="#4-1-12-func-Read-p-byte-n-int-err-error" class="headerlink" title="4.1.12. func Read(p []byte) (n int, err error)"></a>4.1.12. func Read(p []byte) (n int, err error)</h3><h3 id="4-1-13-func-Seed-seed-int64"><a href="#4-1-13-func-Seed-seed-int64" class="headerlink" title="4.1.13. func Seed(seed int64)"></a>4.1.13. func Seed(seed int64)</h3><h3 id="4-1-14-func-Shuffle-n-int-swap-func-i-j-int"><a href="#4-1-14-func-Shuffle-n-int-swap-func-i-j-int" class="headerlink" title="4.1.14. func Shuffle(n int, swap func(i, j int))"></a>4.1.14. func Shuffle(n int, swap func(i, j int))</h3><h3 id="4-1-15-func-Uint32-uint32"><a href="#4-1-15-func-Uint32-uint32" class="headerlink" title="4.1.15. func Uint32() uint32"></a>4.1.15. func Uint32() uint32</h3><h3 id="4-1-16-func-Uint64-uint64"><a href="#4-1-16-func-Uint64-uint64" class="headerlink" title="4.1.16. func Uint64() uint64"></a>4.1.16. func Uint64() uint64</h3><h2 id="4-2-type-Rand"><a href="#4-2-type-Rand" class="headerlink" title="4.2. type Rand"></a>4.2. type Rand</h2><h3 id="4-2-1-func-New-src-Source-Rand"><a href="#4-2-1-func-New-src-Source-Rand" class="headerlink" title="4.2.1. func New(src Source) *Rand"></a>4.2.1. func New(src Source) *Rand</h3><h3 id="4-2-2-func-r-Rand-ExpFloat64-float64"><a href="#4-2-2-func-r-Rand-ExpFloat64-float64" class="headerlink" title="4.2.2. func (r*Rand) ExpFloat64() float64"></a>4.2.2. func (r*Rand) ExpFloat64() float64</h3><h3 id="4-2-3-func-r-Rand-Float32-float32"><a href="#4-2-3-func-r-Rand-Float32-float32" class="headerlink" title="4.2.3. func (r *Rand) Float32() float32"></a>4.2.3. func (r *Rand) Float32() float32</h3><h3 id="4-2-4-func-r-Rand-Float64-float64"><a href="#4-2-4-func-r-Rand-Float64-float64" class="headerlink" title="4.2.4. func (r*Rand) Float64() float64"></a>4.2.4. func (r*Rand) Float64() float64</h3><h3 id="4-2-5-func-r-Rand-Int-int"><a href="#4-2-5-func-r-Rand-Int-int" class="headerlink" title="4.2.5. func (r *Rand) Int() int"></a>4.2.5. func (r *Rand) Int() int</h3><h3 id="4-2-6-func-r-Rand-Int31-int32"><a href="#4-2-6-func-r-Rand-Int31-int32" class="headerlink" title="4.2.6. func (r*Rand) Int31() int32"></a>4.2.6. func (r*Rand) Int31() int32</h3><h3 id="4-2-7-func-r-Rand-Int31n-n-int32-int32"><a href="#4-2-7-func-r-Rand-Int31n-n-int32-int32" class="headerlink" title="4.2.7. func (r *Rand) Int31n(n int32) int32"></a>4.2.7. func (r *Rand) Int31n(n int32) int32</h3><h3 id="4-2-8-func-r-Rand-Int63-int64"><a href="#4-2-8-func-r-Rand-Int63-int64" class="headerlink" title="4.2.8. func (r*Rand) Int63() int64"></a>4.2.8. func (r*Rand) Int63() int64</h3><h3 id="4-2-9-func-r-Rand-Int63n-n-int64-int64"><a href="#4-2-9-func-r-Rand-Int63n-n-int64-int64" class="headerlink" title="4.2.9. func (r *Rand) Int63n(n int64) int64"></a>4.2.9. func (r *Rand) Int63n(n int64) int64</h3><h3 id="4-2-10-func-r-Rand-Intn-n-int-int"><a href="#4-2-10-func-r-Rand-Intn-n-int-int" class="headerlink" title="4.2.10. func (r*Rand) Intn(n int) int"></a>4.2.10. func (r*Rand) Intn(n int) int</h3><h3 id="4-2-11-func-r-Rand-NormFloat64-float64"><a href="#4-2-11-func-r-Rand-NormFloat64-float64" class="headerlink" title="4.2.11. func (r *Rand) NormFloat64() float64"></a>4.2.11. func (r *Rand) NormFloat64() float64</h3><h3 id="4-2-12-func-r-Rand-Perm-n-int-int"><a href="#4-2-12-func-r-Rand-Perm-n-int-int" class="headerlink" title="4.2.12. func (r*Rand) Perm(n int) []int"></a>4.2.12. func (r*Rand) Perm(n int) []int</h3><h3 id="4-2-13-func-r-Rand-Read-p-byte-n-int-err-error"><a href="#4-2-13-func-r-Rand-Read-p-byte-n-int-err-error" class="headerlink" title="4.2.13. func (r *Rand) Read(p []byte) (n int, err error)"></a>4.2.13. func (r *Rand) Read(p []byte) (n int, err error)</h3><h3 id="4-2-14-func-r-Rand-Seed-seed-int64"><a href="#4-2-14-func-r-Rand-Seed-seed-int64" class="headerlink" title="4.2.14. func (r*Rand) Seed(seed int64)"></a>4.2.14. func (r*Rand) Seed(seed int64)</h3><p>  Seed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。</p>
<h3 id="4-2-15-func-r-Rand-Shuffle-n-int-swap-func-i-j-int"><a href="#4-2-15-func-r-Rand-Shuffle-n-int-swap-func-i-j-int" class="headerlink" title="4.2.15. func (r *Rand) Shuffle(n int, swap func(i, j int))"></a>4.2.15. func (r *Rand) Shuffle(n int, swap func(i, j int))</h3><h3 id="4-2-16-func-r-Rand-Uint32-uint32"><a href="#4-2-16-func-r-Rand-Uint32-uint32" class="headerlink" title="4.2.16. func (r*Rand) Uint32() uint32"></a>4.2.16. func (r*Rand) Uint32() uint32</h3><h3 id="4-2-17-func-r-Rand-Uint64-uint64"><a href="#4-2-17-func-r-Rand-Uint64-uint64" class="headerlink" title="4.2.17. func (r *Rand) Uint64() uint64"></a>4.2.17. func (r *Rand) Uint64() uint64</h3><h2 id="4-3-type-Source"><a href="#4-3-type-Source" class="headerlink" title="4.3. type Source"></a>4.3. type Source</h2><h3 id="4-3-1-func-NewSource-seed-int64-Source"><a href="#4-3-1-func-NewSource-seed-int64-Source" class="headerlink" title="4.3.1. func NewSource(seed int64) Source"></a>4.3.1. func NewSource(seed int64) Source</h3><p>  NewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">randomSource :&#x3D; NewSource(time.Now().UnixNano())
randSeed :&#x3D; New(randomSource) &#x2F;&#x2F;这时候就可以使用rand的method
randomInt :&#x3D; randSeed.Intn(300)&#x2F;&#x2F;[0,300)的整数
</code></pre>

<h2 id="4-4-type-Source64"><a href="#4-4-type-Source64" class="headerlink" title="4.4. type Source64"></a>4.4. type Source64</h2><p>  Source64是一个也可以直接生成[0, 1&lt;&lt;64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。<br>  Source64的结构</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">type Source64 interface &#123;
    Source
    Uint64() uint64
&#125;</code></pre>

<h2 id="4-5-type-Zipf"><a href="#4-5-type-Zipf" class="headerlink" title="4.5. type Zipf"></a>4.5. type Zipf</h2><h3 id="4-5-1-func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf"><a href="#4-5-1-func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf" class="headerlink" title="4.5.1. func NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipf"></a>4.5.1. func NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipf</h3><h3 id="4-5-2-func-z-Zipf-Uint64-uint64"><a href="#4-5-2-func-z-Zipf-Uint64-uint64" class="headerlink" title="4.5.2. func (z *Zipf) Uint64() uint64"></a>4.5.2. func (z *Zipf) Uint64() uint64</h3>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/08/golang/go%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/07/archive/compact_wsl2/"
                            aria-label=": 压缩wsl2的磁盘"
                        >
                            压缩wsl2的磁盘
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-07T15:33:59+08:00">
	
		    Oct 07, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/archive/">archive</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><p>shuwdown wsl</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">wsl --shutdown</code></pre>
</li>
<li><p>find out wsl file location<br>一般情况下wsl文件位于：C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\ext4.vhdx</p>
</li>
<li><p>备份wsl</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">wsl --export name target_file
</code></pre>
<p>name可以通过<code>wsl -l</code>命令进行查看</p>
</li>
<li><p>运行diskpart</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">select</span> vdisk <span class="token assign-left variable">file</span><span class="token operator">=</span><span class="token string">"your location"</span>
compact vdisk
</code></pre></li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/07/archive/compact_wsl2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/07/MIT6.824/lab2b/lab2_raft_struct_guide/"
                            aria-label=": MIT6.824之lab2_raft_structure_guide"
                        >
                            MIT6.824之lab2_raft_structure_guide
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-07T08:40:25+08:00">
	
		    Oct 07, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>, <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824/">MIT6.824</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Raft Structure Advice</p>
<p>A Raft instance has to deal with the arrival of external events<br>(Start() calls, AppendEntries and RequestVote RPCs, and RPC replies),<br>and it has to execute periodic tasks (elections and heart-beats).<br>There are many ways to structure your Raft code to manage these<br>activities; this document outlines a few ideas.</p>
<p>Each Raft instance has a bunch of state (the log, the current index,<br>&amp;c) which must be updated in response to events arising in concurrent<br>goroutines. The Go documentation points out that the goroutines can<br>perform the updates directly using shared data structures and locks,<br>or by passing messages on channels. Experience suggests that for Raft<br>it is most straightforward to use shared data and locks.</p>
<p>A Raft instance has two time-driven activities: the leader must send<br>heart-beats, and others must start an election if too much time has<br>passed since hearing from the leader. <strong>It’s probably best to drive each<br>of these activities with a dedicated long-running goroutine</strong>, rather<br>than combining multiple activities into a single goroutine.</p>
<text style="font-family:Courier New;color:red">
It's probably best to drive each of these activities
with a dedicated long-running goroutine
</text>

<p>The management of the election timeout is a common source of<br>headaches. Perhaps the simplest plan is to maintain a variable in the<br>Raft struct containing the last time at which the peer heard from the<br>leader, and to have the election timeout goroutine periodically check<br>to see whether the time since then is greater than the timeout period.<br>It’s easiest to use time.Sleep() with a small constant argument to<br>drive the periodic checks. Don’t use time.Ticker and time.Timer;<br>they are tricky to use correctly.</p>
<text style="font-family:Courier New;color:red">
using hashicorp struct
</text>

<p>You’ll want to have a separate long-running goroutine that sends<br>committed log entries in order on the applyCh. It must be separate,<br>since sending on the applyCh can block; and it must be a single<br>goroutine, since otherwise it may be hard to ensure that you send log<br>entries in log order. The code that advances commitIndex will need to<br>kick the apply goroutine; it’s probably easiest to use a condition<br>variable (Go’s sync.Cond) for this.</p>
<text style="font-family:Courier New;color:red">
using a seperate applier channel
</text>

<p>Each RPC should probably be sent (and its reply processed) in its own<br>goroutine, for two reasons: so that unreachable peers don’t delay the<br>collection of a majority of replies, and so that the heartbeat and<br>election timers can continue to tick at all times. It’s easiest to do<br>the RPC reply processing in the same goroutine, rather than sending<br>reply information over a channel.</p>
<text style="font-family:Courier New;color:red">
easy to unstand , using two different channels to send and process
reply of RPC
</text>

<p>Keep in mind that the network can delay RPCs and RPC replies, and when<br>you send concurrent RPCs, the network can re-order requests and<br>replies. Figure 2 is pretty good about pointing out places where RPC<br>handlers have to be careful about this (e.g. an RPC handler should<br>ignore RPCs with old terms). Figure 2 is not always explicit about RPC<br>reply processing. The leader has to be careful when processing<br>replies; it must check that the term hasn’t changed since sending the<br>RPC, and must account for the possibility that replies from concurrent<br>RPCs to the same follower have changed the leader’s state (e.g.<br>nextIndex).</p>
<text style="font-family:'Courier new'; color:red ">

<p>this part we should put eyes on checking reply of concurrent RPC, like<br>election and heartbeat</p>
</text>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/07/MIT6.824/lab2b/lab2_raft_struct_guide/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/05/MIT6.824/lab2b/lab2_lock_advice/"
                            aria-label=": MIT6.824之lab2_raft_lock_advice"
                        >
                            MIT6.824之lab2_raft_lock_advice
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-05T22:32:54+08:00">
	
		    Oct 05, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>, <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824/">MIT6.824</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="rule-1"><a href="#rule-1" class="headerlink" title="rule 1"></a>rule 1</h1><p>whenever you have one more goroutine gonna modify data , you should use lock to prevent data and<br>avoid multip-goroutine change data ,go race is a good tool , that is enable to detect data race ,<br>but without any helpful on below rules</p>
<h1 id="rule-2"><a href="#rule-2" class="headerlink" title="rule 2"></a>rule 2</h1><p>whenever your code make a sequence of modification on shared code.if they looked at the<br>data midway through the sequence,other goroutines might malfunction, you should use lock<br>to pretect code block which gonna be change and other routine read data midway, for example</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">rf.mu.Lock()
rf.currentTerm +&#x3D; 1
rf.state &#x3D; Candidate
rf.mu.Unlock()</code></pre>


<p>one more goroutine could not read any of above temp updates, so A goroutine should hold locking over the critical section.<br>on the other hand , if B goroutine using r.currenTerm or r.state, ,who must hold locking when access r.currenTerm at somewhere</p>
<h1 id="rule-3"><a href="#rule-3" class="headerlink" title="rule 3"></a>rule 3</h1><p>Whenever code does a sequence of reads of shared data (or<br>reads and writes), and would malfunction if another goroutine modified<br>the data midway through the sequence, you should use a lock around the<br>whole sequence.</p>
<p>please must take care and review the multi-goroutine change data at the same time.and must aware if another goroutine modified<br>the data midway through the sequence, you should use a lock around the whole sequence.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
rf.mu.Lock()
  if args.Term &gt; rf.currentTerm &#123;
   rf.currentTerm &#x3D; args.Term
  &#125;
  rf.mu.Unlock()
</code></pre>

<h1 id="rule-4"><a href="#rule-4" class="headerlink" title="rule 4"></a>rule 4</h1><p>this rule just only apply to lab2, it announces that It’s usually a bad idea to hold a lock while doing anything that might wait: reading a Go channel, sending on a channel, waiting for a timer, calling time.Sleep(), or sending an RPC (and waiting for the<br>reply).</p>
<h1 id="rule-5"><a href="#rule-5" class="headerlink" title="rule 5"></a>rule 5</h1><p>this rule is also apply for lab2 specifical case.<br>Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held.</p>
<p>Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held. For example, this code to send vote RPCs is incorrect:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">rf.mu.Lock()
rf.currentTerm +&#x3D; 1
rf.state &#x3D; Candidate
for &lt;each peer&gt; &#123;
  go func() &#123;
    rf.mu.Lock()
    args.Term &#x3D; rf.currentTerm
    rf.mu.Unlock()
    Call(&quot;Raft.RequestVote&quot;, &amp;args, ...)
    &#x2F;&#x2F; handle the reply...
  &#125; ()
&#125;
rf.mu.Unlock()</code></pre>

<p>The code sends each RPC in a separate goroutine. It’s incorrect<br>because args.Term may not be the same as the rf.currentTerm at which<br>the surrounding code decided to become a Candidate. Lots of time may<br>pass between when the surrounding code creates the goroutine and when<br>the goroutine reads rf.currentTerm; for example, multiple terms may<br>come and go, and the peer may no longer be a candidate. One way to fix<br>this is for the created goroutine to use a copy of rf.currentTerm made<br>while the outer code holds the lock. Similarly, reply-handling code<br>after the Call() must re-check all relevant assumptions after<br>re-acquiring the lock; for example, it should check that<br>rf.currentTerm hasn’t changed since the decision to become a<br>candidate.</p>
<p>It can be difficult to interpret and apply these rules. Perhaps most<br>puzzling is the notion in Rules 2 and 3 of code sequences that<br>shouldn’t be interleaved with other goroutines’ reads or writes. How<br>can one recognize such sequences? How should one decide where a<br>sequence ought to start and end?</p>
<p>One approach is to start with code that has no locks, and think<br>carefully about where one needs to add locks to attain correctness.<br>This approach can be difficult since it requires reasoning about the<br>correctness of concurrent code.</p>
<p>一个更务实的方法是从观察开始的，如果没有<br>没有并发性（没有同时执行的goroutine），你就根本不需要锁。<br>就根本不需要锁了。但是，当RPC系统创建goroutines来执行RPC时，你的并发性被强加于你<br>当RPC系统创建goroutines来执行RPC处理程序时，你的并发性是被迫的，并且<br>因为你需要在不同的goroutine中发送RPC以避免等待。<br>你可以有效地消除这种并发，方法是确定所有<br>的地方（RPC处理程序、你在Make()中创建的后台goroutine<br>中创建的后台goroutines，等等），在每个goroutine的开始时获取锁，并且只释放锁。<br>锁，并且只有在该程序完全结束并返回时才释放锁。<br>完全结束并返回时才释放锁。这个锁协议确保<br>没有任何重要的东西是并行执行的；锁保证了<br>每个goroutine在任何其他goroutine被允许启动之前执行完毕。<br>允许启动。由于没有并行执行，所以很难违反<br>规则1、2、3或5。如果每个goroutine的代码在孤立情况下是正确的<br>(当单独执行时，没有并发的goroutine)，那么当你使用锁时，它很可能<br>当你使用锁来抑制并发性时，它仍然是正确的。所以你<br>可以避免对正确性进行明确的推理，或者明确的<br>识别关键部分。</p>
<blockquote>
<p>通过<a target="_blank" rel="noopener" href="http://www.deepl.com/Translator%EF%BC%88%E5%85%8D%E8%B4%B9%E7%89%88%EF%BC%89%E7%BF%BB%E8%AF%91">www.DeepL.com/Translator（免费版）翻译</a></p>
</blockquote>
<p>However, Rule 4 is likely to be a problem. So the next step is to find<br>places where the code waits, and to add lock releases and re-acquires<br>(and&#x2F;or goroutine creation) as needed, being careful to re-establish<br>assumptions after each re-acquire. You may find this process easier to<br>get right than directly identifying sequences that must be locked for<br>correctness.</p>
<p>(As an aside, what this approach sacrifices is any opportunity for<br>better performance via parallel execution on multiple cores: your code<br>is likely to hold locks when it doesn’t need to, and may thus<br>unnecessarily prohibit parallel execution of goroutines. On the other<br>hand, there is not much opportunity for CPU parallelism within a<br>single Raft peer.)</p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><details>
<summary>原文</summary>
<pre>
Raft Locking Advice

<p>If you are wondering how to use locks in the 6.824 Raft labs, here are<br>some rules and ways of thinking that might be helpful.</p>
<p>Rule 1: Whenever you have data that more than one goroutine uses, and<br>at least one goroutine might modify the data, the goroutines should<br>use locks to prevent simultaneous use of the data. The Go race<br>detector is pretty good at detecting violations of this rule (though<br>it won’t help with any of the rules below).</p>
<p>Rule 2: Whenever code makes a sequence of modifications to shared<br>data, and other goroutines might malfunction if they looked at the<br>data midway through the sequence, you should use a lock around the<br>whole sequence.</p>
<p>An example:</p>
<p>  rf.mu.Lock()<br>  rf.currentTerm +&#x3D; 1<br>  rf.state &#x3D; Candidate<br>  rf.mu.Unlock()</p>
<p>It would be a mistake for another goroutine to see either of these<br>updates alone (i.e. the old state with the new term, or the new term<br>with the old state). So we need to hold the lock continuously over the<br>whole sequence of updates. All other code that uses rf.currentTerm or<br>rf.state must also hold the lock, in order to ensure exclusive access<br>for all uses.</p>
<p>The code between Lock() and Unlock() is often called a “critical<br>section.” The locking rules a programmer chooses (e.g. “a goroutine<br>must hold rf.mu when using rf.currentTerm or rf.state”) are often<br>called a “locking protocol”.</p>
<p>Rule 3: Whenever code does a sequence of reads of shared data (or<br>reads and writes), and would malfunction if another goroutine modified<br>the data midway through the sequence, you should use a lock around the<br>whole sequence.</p>
<p>An example that could occur in a Raft RPC handler:</p>
<p>  rf.mu.Lock()<br>  if args.Term &gt; rf.currentTerm {<br>   rf.currentTerm &#x3D; args.Term<br>  }<br>  rf.mu.Unlock()</p>
<p>This code needs to hold the lock continuously for the whole sequence.<br>Raft requires that currentTerm only increases, and never decreases.<br>Another RPC handler could be executing in a separate goroutine; if it<br>were allowed to modify rf.currentTerm between the if statement and the<br>update to rf.currentTerm, this code might end up decreasing<br>rf.currentTerm. Hence the lock must be held continuously over the<br>whole sequence. In addition, every other use of currentTerm must hold<br>the lock, to ensure that no other goroutine modifies currentTerm<br>during our critical section.</p>
<p>Real Raft code would need to use longer critical sections than these<br>examples; for example, a Raft RPC handler should probably hold the<br>lock for the entire handler.</p>
<p>Rule 4: It’s usually a bad idea to hold a lock while doing anything<br>that might wait: reading a Go channel, sending on a channel, waiting<br>for a timer, calling time.Sleep(), or sending an RPC (and waiting for the<br>reply). One reason is that you probably want other goroutines to make<br>progress during the wait. Another reason is deadlock avoidance. Imagine<br>two peers sending each other RPCs while holding locks; both RPC<br>handlers need the receiving peer’s lock; neither RPC handler can ever<br>complete because it needs the lock held by the waiting RPC call.</p>
<p>Code that waits should first release locks. If that’s not convenient,<br>sometimes it’s useful to create a separate goroutine to do the wait.</p>
<p>Rule 5: Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held. For example, this code to send vote RPCs is incorrect:</p>
<p>  rf.mu.Lock()<br>  rf.currentTerm +&#x3D; 1<br>  rf.state &#x3D; Candidate<br>  for <each peer> {<br>    go func() {<br>      rf.mu.Lock()<br>      args.Term &#x3D; rf.currentTerm<br>      rf.mu.Unlock()<br>      Call(“Raft.RequestVote”, &amp;args, …)<br>      &#x2F;&#x2F; handle the reply…<br>    } ()<br>  }<br>  rf.mu.Unlock()</p>
<p>The code sends each RPC in a separate goroutine. It’s incorrect<br>because args.Term may not be the same as the rf.currentTerm at which<br>the surrounding code decided to become a Candidate. Lots of time may<br>pass between when the surrounding code creates the goroutine and when<br>the goroutine reads rf.currentTerm; for example, multiple terms may<br>come and go, and the peer may no longer be a candidate. One way to fix<br>this is for the created goroutine to use a copy of rf.currentTerm made<br>while the outer code holds the lock. Similarly, reply-handling code<br>after the Call() must re-check all relevant assumptions after<br>re-acquiring the lock; for example, it should check that<br>rf.currentTerm hasn’t changed since the decision to become a<br>candidate.</p>
<p>It can be difficult to interpret and apply these rules. Perhaps most<br>puzzling is the notion in Rules 2 and 3 of code sequences that<br>shouldn’t be interleaved with other goroutines’ reads or writes. How<br>can one recognize such sequences? How should one decide where a<br>sequence ought to start and end?</p>
<p>One approach is to start with code that has no locks, and think<br>carefully about where one needs to add locks to attain correctness.<br>This approach can be difficult since it requires reasoning about the<br>correctness of concurrent code.</p>
<p>A more pragmatic approach starts with the observation that if there<br>were no concurrency (no simultaneously executing goroutines), you<br>would not need locks at all. But you have concurrency forced on you<br>when the RPC system creates goroutines to execute RPC handlers, and<br>because you need to send RPCs in separate goroutines to avoid waiting.<br>You can effectively eliminate this concurrency by identifying all<br>places where goroutines start (RPC handlers, background goroutines you<br>create in Make(), &amp;c), acquiring the lock at the very start of each<br>goroutine, and only releasing the lock when that goroutine has<br>completely finished and returns. This locking protocol ensures that<br>nothing significant ever executes in parallel; the locks ensure that<br>each goroutine executes to completion before any other goroutine is<br>allowed to start. With no parallel execution, it’s hard to violate<br>Rules 1, 2, 3, or 5. If each goroutine’s code is correct in isolation<br>(when executed alone, with no concurrent goroutines), it’s likely to<br>still be correct when you use locks to suppress concurrency. So you<br>can avoid explicit reasoning about correctness, or explicitly<br>identifying critical sections.</p>
<p>However, Rule 4 is likely to be a problem. So the next step is to find<br>places where the code waits, and to add lock releases and re-acquires<br>(and&#x2F;or goroutine creation) as needed, being careful to re-establish<br>assumptions after each re-acquire. You may find this process easier to<br>get right than directly identifying sequences that must be locked for<br>correctness.</p>
<p>(As an aside, what this approach sacrifices is any opportunity for<br>better performance via parallel execution on multiple cores: your code<br>is likely to hold locks when it doesn’t need to, and may thus<br>unnecessarily prohibit parallel execution of goroutines. On the other<br>hand, there is not much opportunity for CPU parallelism within a<br>single Raft peer.)<br></pre></p>
</details>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/05/MIT6.824/lab2b/lab2_lock_advice/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/05/MIT6.824/lab2b/lab2_raft_students_guide/"
                            aria-label=": MIT6.824之lab2_raft_students_guide"
                        >
                            MIT6.824之lab2_raft_students_guide
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-05T20:21:56+08:00">
	
		    Oct 05, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>, <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824/">MIT6.824</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#%E4%BA%8Cstudents-guide-to-raf%E6%96%87%E6%A1%A3">二.Students’ Guide to Raf文档</a><ul>
<li><a href="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0raft">实现raft</a><ul>
<li><a href="#%E9%87%8D%E8%A6%81%E7%9A%84%E7%BB%86%E8%8A%82">重要的细节</a></li>
</ul>
</li>
<li><a href="#debugging-raft">Debugging Raft</a><ul>
<li><a href="#%E6%B4%BB%E9%94%81">活锁</a></li>
<li><a href="#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84rpc">不正确的RPC</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E8%AE%BA%E6%96%87%E7%9A%84%E7%90%86%E8%AE%BA%E5%AE%9E%E7%8E%B0raft">没有按照论文的理论实现raft</a></li>
<li><a href="#term%E6%B7%B7%E4%B9%B1term%E4%B8%8D%E7%A8%B3%E5%AE%9A">term混乱(term不稳定)</a></li>
<li><a href="#%E4%BC%98%E5%8C%96">优化</a></li>
</ul>
</li>
<li><a href="#applications-on-top-of-raft">Applications on top of Raft</a></li>
<li><a href="#appendindex">AppendIndex</a></li>
</ul>
</li>
</ul>
<h1 id="二-Students’-Guide-to-Raf文档"><a href="#二-Students’-Guide-to-Raf文档" class="headerlink" title="二.Students’ Guide to Raf文档"></a>二.Students’ Guide to Raf文档</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">https://thesquareplanet.com/blog/students-guide-to-raft/</a> 原文链接</p>
</blockquote>
<p>在过去几个月里，我成为了MIT6.824的一名助教.以往这门课程的实验都是基于paxos实现一致性算法,然后今年(2016),我们决定使用raft,raft的设计理念是”理解门槛低”，并且我们也希望这项决定使同学们的生活更简单[在过去的几个月里，我一直是麻省理工学院6.824分布式系统课的教学助理。这门课传统上有一些建立在Paxos共识算法上的实验，但今年，我们决定改用Raft。Raft是 “设计成易于理解的”，我们希望这一改变能使学生的生活更轻松]</p>
<p>这篇实验指南,对应着”教师教学指南”，印证着我们实验室与raft的journey，也希望对学生更好的理解raft内部运行机制，实现raft分布式协议起到帮助,如果你正在寻找Raft和Paxos的对比，或者raft的教学(pedagogical)分析,请前去阅读《教师教学指南》.文章底部包含一些学生提问的关于raft的共性问题的问题列表。如果你遇到的问题不在那些问题之内，请前去检查Q&amp;A系统，这篇文章非常的长,但是它提出的所有点，都是现实中学生(助教)碰到过的问题，这是一篇值得阅读的文章。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开始深入研究raft之前,一些前情提要或许是有用的，6.824过去有一些基于用golang实现的Paxos实验，之所以选择go是因为它易于理解和学习的，它非常适合实现高并发，分布式应用(goroutine是特别便利的)，通过这门课程的四门实验课程，学生构建一个容错的，共享key-value存储系统，第一个实验让你构建一个基于log的一致性算法库,第二门实验在一致性算法库上添加了key-value的存储，第三们实验课是实验构建共享的key-value容错集群,使用共享master节点解决集群成员变更，同时第四们实验,学生不得不实现失败和恢复机制，包括磁盘完整和磁盘不完整的情况这个实现曾作为学生默认的最后实验</p>
<p>这些年我们决定使用raft重写所有mit6.824的实验，前三个实验跟以前是相同的,但是删除了第四个已经在raft中实现了关于失败与持久化的实验,这篇文章主要讨论了我们第一个实验的经验，一个直接跟raft相关的的实验，虽然我们也会接触到构建raft之上的应用层,(第二门实验)。</p>
<p>如果想了解raft的简单的运行逻辑，这个<a target="_blank" rel="noopener" href="https://raft.github.io/">web site</a>网站演示的raft协议是最好的文字材料.</p>
<p>raft是一种被设计为容易理解的一致性算法,在容错,性能方面等价于paxos算法,他们的不同点是raft将问题解耦为相对独立的问题,它也在实际的系统中清晰的解决了很多实际问题.我们也希望跟多的读者实现raft,以及构建更多的基于raft一致性系统</p>
<p>这个网站的可视化raft协议提供了很好的主要组件的概括,论文提供了更直观的说明为什么需要这些组件,如果你还没有阅读raft extend 论文,请有限阅读那篇论文然后再阅读这份&lt;&lt;raft指南&gt;&gt;,由于我假设你对raft有了个大致的了解(ps:这段要翻译成”你对raft有一定程度的熟悉”).</p>
<p>正如其他的分布式一致性协议一样,协议细节有很多的”坑”,在稳定的状态下,没有节点失效,raft协议就很好理解,可以很直观的理解,可以从上面的可视化网站了解其运行机制,假设没有节点失效,一个leader会最终被选出来,客户端所有发给raft的请求都会最终发送给follower,但是当网络出现通信延迟,网络分区,节点宕机等等假设发生,但是在特定情况下,我们看到有很多bugs一次次的重复出现,由于直接的错误理解和疏忽,当阅读论文的时候,这不是raft独有的,而是所有提出正确复杂分布式系统都存在的问题</p>
<h2 id="实现raft"><a href="#实现raft" class="headerlink" title="实现raft"></a>实现raft</h2><p>raft论文的figure2是最好的guide，figure2指定每个RPC的工作的方式，当你读完figure2就可以着手实现raft，但是问题也就接踵而至。实际上，figure2是极其严格的，论文中有些叙述是must而不是should，举个例子，你也会有理由重置election timer, 无论什么时候收到 Request vote and Append entry RPC,这两个RPC说明，其他的server其中一个是leader，另一个是candidate在尝试成为leader，这不允许人为干预或者推理。</p>
<blockquote>
<p>If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate.</p>
</blockquote>
<p>他们之间是有很大区别的，之前的实现可能有某些特定场景下有严重的活性问题</p>
<h3 id="重要的细节"><a href="#重要的细节" class="headerlink" title="重要的细节"></a>重要的细节</h3><p>raft会把没有entry的appendEntry的RPC视为hearbeat,很多同学假设AppendEntry RPC是某种特殊的RPC,尤其是很多人是指简单的reset计时器，然后返回success，而不进行任何的冲突检测，接受accept就承认follower承认没有冲突，leader根据返回的response来提交logEntry,另外一个问题就是，follower根据收到冲突的prevLogIndex，就会删掉那个点的log，然后吧entries直接进行复制。</p>
<blockquote>
<p>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</p>
</blockquote>
<p>这里的if很关键。如果跟随者拥有领导者发送的所有条目，跟随者必须不截断其日志。任何跟随领导者发送的条目的元素都必须被保留。这是因为我们可能从领导者那里收到了一个过时的AppendEntries RPC，而截断日志将意味着 “收回”我们可能已经告诉领导者我们的日志中的条目。</p>
<h2 id="Debugging-Raft"><a href="#Debugging-Raft" class="headerlink" title="Debugging Raft"></a>Debugging Raft</h2><p>第一版的实现肯定是问题百出,我们需要慢慢的迭代实现,问题大致有如下几点，通常有如下四种主要的bugs<code>活锁</code>，<code>不正确或者不完整的RPC</code>,<code>fail_follow_rule</code>,<code>term confusion</code>,还有<code>死锁</code></p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>当你的系统活锁时，你系统中的每个节点都在做一些事情，但你的节点集体处于这样一种状态，没有任何进展。这种情况在Raft中很容易发生，尤其是当你没有虔诚地遵循图2时。有一种活锁情况特别经常出现；没有选举领导人，或者一旦选举了领导人，其他节点又开始选举，迫使最近当选的领导人立即退位。  </p>
<p>出现这种情况的原因有很多，但有几个错误是我们看到无数学生犯的。</p>
<ul>
<li>确保你在图2说的时候准确地重置你的选举计时器。具体来说，你只应该在以下情况下重启你的选举计时器：a）你从当前的领导者那里得到一个AppendEntries RPC（即，如果AppendEntries参数中的term已经过时，你不应该重启你的计时器）；b）你正在开始一个选举；或者c）你授予另一个candidate(requestVote RPC)一个投票。最后一种情况在不可靠的网络中尤其重要，因为在这种网络中，跟随者很可能有不同的日志；在这些情况下，你最终往往只有少数服务器，而大多数服务器都愿意为其投票。如果你每当有人要求你为他投票时就重置选举计时器，这就使得一个有过时日志的服务器和一个有较长日志的服务器同样有可能站出来。事实上，由于具有足够最新的日志的服务器太少，这些服务器很不可能在正常的情况下举行选举而当选。如果按照图2的规则，拥有较多最新日志的服务器不会被过时的服务器的选举打断，因此更有可能完成选举，成为领导者。</li>
<li>按照图2的指示，你应该何时开始选举。特别要注意的是，如果你是一个候选人（即，你目前正在进行选举），但选举计时器启动了，你应该开始另一次选举。这一点很重要，可以避免系统因RPC的延迟或放弃而停滞。</li>
<li>在处理传入的RPC之前，请确保你遵循 “服务器规则 “中的第二条规则。第二条规则指出。</li>
</ul>
<blockquote>
<p>If RPC request or response contains term T &gt; currentTerm: set currentTerm &#x3D; T, convert to follower (§5.1)  </p>
</blockquote>
<p>例如，如果你已经在当前任期内投票，而传入的RequestVote RPC的任期比你高，你应该首先下台，采用他们的任期（从而重新设置 votedFor），然后处理RPC，这将导致你授予投票权</p>
<h3 id="不正确的RPC"><a href="#不正确的RPC" class="headerlink" title="不正确的RPC"></a>不正确的RPC</h3><p>尽管图2清楚地说明了每个RPC处理程序应该做什么，但一些细微之处仍然容易被忽略。以下是我们反复看到的一些情况，你应该在你的实现中注意这些情况.  </p>
<ul>
<li>发现不对逻辑的RPC就尽快返回false</li>
<li>发现follower比leader日志少了，follower就返回false，然后将最新index更新给leader的nextIndex</li>
<li>leader即使没有发送entry，也要检查prevLogIndex</li>
<li>AppendEntries的最后一步（#5）中的min是必要的，它需要用最后一个新条目的索引来计算。仅仅让应用lastApplied和commitIndex之间的日志内容的函数在到达日志的末尾时停止，是不够的。这因为你的日志中可能会有与领导者的日志不同的条目，在领导者发给你的条目之后（这些条目都与你的日志中的条目一致）。因为 #3 决定了你只在有冲突的条目时才截断你的日志，那些条目不会被除，如果 leaderCommit 超出了领导者发给你的条目，你可能会应用不正确的条目。发送高leader commit index和空的entry的RPC就会导致apply出现问题</li>
<li>要完全按照第5.4节中描述的方式实现 “最新日志”检查。老老实实的实现，不要只只检查长度!</li>
</ul>
<h3 id="没有按照论文的理论实现raft"><a href="#没有按照论文的理论实现raft" class="headerlink" title="没有按照论文的理论实现raft"></a>没有按照论文的理论实现raft</h3><p>虽然Raft论文对如何实现每个RPC处理程序非常明确，但它也没有对一些规则和不变因素的实现进行说明。这些都列在图2右侧的 “服务器规则 “部分。虽然其中一些规则是不言自明的，但也有一些需要非常仔细地设计你的应用程序，使其不违反规则.</p>
<ul>
<li>在任何阶段<code>commitIndex&gt;lastApplied</code>你都可以直接<code>apply</code>log到上层状态机,提交日志的时候不持有锁或者设置数据保护区，保证其他程序不apply日志</li>
<li>将<code>commitIndex&gt;lastApplied</code>解耦,每次sentout心跳的时候检查<code>commitIndex</code>你必须要等<code>appendlog</code>动作完成</li>
<li><code>AppendEntries</code>RPC并不是因为log不一致被reject,应该立刻降级为follower,不要更新<code>nextIndex</code>，如果这个时候立刻选举你可能会面对数据竞争的问题</li>
<li><code>commitIndex</code>不能设置为旧的term，你一定要checklog[N].Term &#x3D;&#x3D;currentTerm.这是因为leader不知道follower是否在当前任期提交了日志,Figure 8会详细阐述这个问题</li>
</ul>
<p>一个常见的混淆是<code>nextIndex</code>和<code>matchIndex</code>之间的区别。特别是，你可能会观察到<code>matchIndex</code> &#x3D; <code>nextIndex</code> - 1，而干脆不实现<code>matchIndex</code>。这是不安全的。虽然nextIndex和matchIndex通常在同一时间被更新为类似的值（具体来说，nextIndex &#x3D; matchIndex + 1），但两者的作用完全不同。它通常是乐观的（我们分享一切），并且只在消极的反应中向后移动。例如，当一个领导者刚刚当选时，<code>nextIndex</code>被设置为日志末尾的索引指数。在某种程度上，<code>nextIndex</code>是用于性能的–你只需要将这些东西发送给这个peer。  </p>
<p><code>matchIndex</code>是用于安全的。<code>matchIndex</code>不能被设置为一个太高的值，因为这可能会导致<code>commitIndex</code>被向前移动得太远。这就是为什么<code>matchIndex</code>被初始化为-1（也就是说，我们不同意任何前缀），并且只在跟随者肯定地确认AppendEntries RPC时才更新。  </p>
<h3 id="term混乱-term不稳定"><a href="#term混乱-term不稳定" class="headerlink" title="term混乱(term不稳定)"></a>term混乱(term不稳定)</h3><p>因为网络导致的RPC过期问题，term混淆是指服务器被来自旧term的RPC所迷惑。一般来说，在收到RPC时，因为图2中的规则确切地说明了当你看到一个旧term时你应该做什么。然而，图2一般没有讨论当你收到旧的RPC回复时你应该做什么。根据经验，我们发现，到目前为止，最简单的做法是首先记录回复中的term(它可能比你当前的term高),然后将当前term与你在原始RPC中发送的term进行比较。如果两者不同，就放弃回复并返回。只有当这两个术term相同时，你才应该继续处理回复。也许你可以通过一些巧妙的协议推理在这里做进一步的优化，但这种方法似乎很有效。而不这样做会导致一条漫长而曲折的血汗、泪水和绝望的道路。<br>NOTE:A节点无论是RV还是AE的RPC,在回复中都要进行与A节点的currenTerm进行比对,如果发现不对，就立即放弃回复并返回。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>Raft论文包括几个感兴趣的可选功能。在6.824中，我们要求学生实现其中的两个：日志压缩（第7节）和加速日志回溯（第8页的左上方）。前者对于避免日志无限制地增长是必要的，而后者对于使落后的追随者快速更新是有用的。  </p>
<p>这些功能不是 “核心Raft “的一部分，因此在论文中没有得到像主要共识协议那样的关注。日志压缩的内容相当全面（在图13中），但遗漏了一些设计细节，如果你太随意地阅读，可能会错过。  </p>
<ul>
<li>当快照应用程序状态时，你需要确保应用程序状态与Raft日志中某个已知索引之后的状态相对应，这意味着应用程序要么需要向Raft传达快照所对应的索引，要么Raft需要推迟应用额外的日志条目，直到快照完成。</li>
<li>该文本没有讨论当服务器崩溃并重新启动时的恢复协议，因为现在涉及到快照。特别是，如果Raft状态和快照是分开提交的，服务器可能会在坚持快照和坚持更新的Raft状态之间崩溃。这是一个问题，因为图13中的第7步决定了快照所覆盖的Raft日志必须被丢弃。如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是在Raft中引入一个持久化状态，记录Raft持久化日志中的第一个条目所对应的 “真实 “索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定在日志的头部有哪些元素需要丢弃.  </li>
<li>如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是给Raft引入一个持久化状态，记录Raft持久化日志中的第一个条目对应的 “真实 “索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定要丢弃日志头部的哪些元素。</li>
</ul>
<p>加速日志回溯的优化是非常不明确的，可能是因为作者认为这对大多数部署来说是不必要的。文本中并没有明确说明领导者应该如何使用从客户端发回的冲突索引和术语来决定使用哪一个NextIndex。我们认为作者可能希望你遵循的协议是。</p>
<ul>
<li>如果一个跟随者的日志中没有prevLogIndex，它应该以conflictIndex &#x3D; len(log)和conflictTerm &#x3D; None返回。</li>
<li>如果一个跟随者在其日志中确实有prevLogIndex，但是术语不匹配，它应该返回conflictTerm &#x3D; log[prevLogIndex].Term，然后在其日志中搜索其条目中术语等于conflictTerm的第一个索引。</li>
<li>在收到冲突响应时，领导者应该首先搜索其日志中的conflictTerm。如果它在日志中找到一个具有该term的条目，它应该将nextIndex设置为其日志中该term的最后一个条目的索引之外的那个索引。</li>
<li>如果它没有找到该术语的条目，它应该设置 nextIndex &#x3D; conflictIndex。一个半途而废的解决方案是只使用conflictIndex（而忽略conflictTerm），这简化了实现，但这样一来，领导者有时会向跟随者发送更多的日志条目，而不是严格意义上所需要的，以使他们达到最新状态。</li>
</ul>
<h2 id="Applications-on-top-of-Raft"><a href="#Applications-on-top-of-Raft" class="headerlink" title="Applications on top of Raft"></a>Applications on top of Raft</h2><h2 id="AppendIndex"><a href="#AppendIndex" class="headerlink" title="AppendIndex"></a>AppendIndex</h2><ul>
<li>2022&#x2F;08&#x2F;21<br>  etcd的raft模块难得不只是一点点，看来不能直接看它和etcd的整合，尝试着理解那个example开始。一个玩具的raftkv.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/05/MIT6.824/lab2b/lab2_raft_students_guide/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/2022/10/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 2 of 2</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/nil" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                nil
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
