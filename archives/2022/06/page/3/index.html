
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Eden">
    <title>Archives: 2022/6 - Eden</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://simonteo58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Eden">
<meta property="og:url" content="https://simonteo58.github.io/archives/2022/06/page/3/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/cover.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-jtle2hiadqi6creqze7vuhnn9ct7bmrwzzyznr4cpumzvckdy7pw9sbtrdse.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Eden
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/cover.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/cover.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="Google +"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/nil"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB/"
                            aria-label=": 如何阅读-TED"
                        >
                            如何阅读-TED
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T22:05:35+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/TED/">TED</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>TED<br>1.做笔记</p>
</blockquote>
<p>2.费曼学习法</p>
<p>​ 写下假设找出知识上的差距。<br>3.存档你的笔记</p>
<p>​ 理清框架，并起一个标题</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/API_design%E5%8E%9F%E5%88%99/"
                            aria-label=": API Design Patterns"
                        >
                            API Design Patterns
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T21:55:02+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/WEB-API/">WEB-API</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <!-- ## 1. API介绍
定义一组与系统交互的界面,是的用户有相对较小的权限操作系统

 -->
<h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1. API介绍"></a>1. API介绍</h2><h3 id="1-1-什么是API"><a href="#1-1-什么是API" class="headerlink" title="1.1 什么是API"></a>1.1 什么是API</h3><p>定义一组与系统交互的界面,是的用户有相对较小的权限操作系统</p>
<h3 id="1-2-为什么API重要"><a href="#1-2-为什么API重要" class="headerlink" title="1.2 为什么API重要"></a>1.2 为什么API重要</h3><p>不需要像GUI那样很”cosmetic”</p>
<h3 id="1-3-什么是面向资源API"><a href="#1-3-什么是面向资源API" class="headerlink" title="1.3 什么是面向资源API"></a>1.3 什么是面向资源API</h3><ul>
<li>RPC-API<br>RPC APIs are often designed in terms of interfaces and methods. As more and more of these are added over time, the end result can be an overwhelming and confusing API surface due to the fact that developers must learn each method individually. Obviously this is both time consuming and error-prone.<br>RPC的命名没有严格的要求，无状态的，随着RPC的接口增加，接口管理就会面临混乱结果</li>
<li>HTTP-API<br>The architectural style of REST was introduced, primarily designed to work well with HTTP&#x2F;1.1, but also to help tackle this problem. Its core principle is to define named resources that can be manipulated using a small number of methods. The resources and methods are known as nouns and verbs of APIs. With the HTTP protocol, the resource names naturally map to URLs, and methods naturally map to HTTP methods POST, GET, PUT, PATCH, and DELETE. This results in much fewer things to learn, since developers can focus on the resources and their relationship, and assume that they have the same small number of standard methods.<br>通常url就是资源的映射，对资源的CRUD就是对应HTTP的PATCH,POST,GET DELETE</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cloud.google.com/apis/design/resources">https://cloud.google.com/apis/design/resources</a></p>
</blockquote>
<h3 id="1-4-什么是”good”API"><a href="#1-4-什么是”good”API" class="headerlink" title="1.4 什么是”good”API"></a>1.4 什么是”good”API</h3><ul>
<li>Operational<br>你的API必须得work,高效。</li>
<li>Expressive<br>你的method必须是具有描述意义的，告诉用户你能做什么</li>
<li>Simple<br>Another common position on simplicity takes the old saying about the “common<br>case” (“Make the common case fast”) but focuses instead on usability while leaving<br>room for edge cases. This restatement is to “make the common case awesome and the<br>advanced case possible.” This means that whenever you add something that might<br>complicate an API for the benefit of an advanced user, it’s best to keep this complication sufficiently hidden from a typical user only interested in the common case. This<br>keeps the more frequent scenarios simple and easy, while still enabling more<br>advanced features for those who want them</li>
<li>Predictable<br>方法和参数需要见名知意<br>APIs built using well-known, well-defined, clear</li>
</ul>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><ul>
<li>Interfaces are contracts that define how two systems should interact with one another.</li>
<li>APIs are special types of interfaces that define how two computer systems interact with one another, coming in many forms, such as downloadable libraries and web APIs.</li>
<li>Web APIs are special because they expose functionality over a network, hiding the specific implementation or computational requirements needed for that functionality.</li>
<li>Resource-oriented APIs are a way of designing APIs to reduce complexity byrelying on a standard set of actions, called methods, across a limited set of things, called resources.</li>
<li>What makes APIs “good” is a bit ambiguous, but generally good APIs are operational, expressive, simple, and predictable.</li>
<li>对数据和系统的抽象会决定你的API – 李沐</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/API_design%E5%8E%9F%E5%88%99/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%88%87shell%E8%85%B3%E6%9C%AC%E7%B7%A8%E7%A8%8B%E5%A4%A7%E5%85%A8/"
                            aria-label=": Linux命令行与shell腳本編程大全"
                        >
                            Linux命令行与shell腳本編程大全
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T21:53:01+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/linux/">linux</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <!-- toc -->
<ul>
<li><a href="#1-linux%E5%85%A5%E9%97%A8">1. linux入门</a></li>
<li><a href="#2-%E8%B5%B0%E8%BF%9Bshell">2. 走进shell</a></li>
<li><a href="#3-%E5%9F%BA%E6%9C%ACshell%E5%91%BD%E4%BB%A4">3. 基本shell命令</a><ul>
<li><a href="#31-%E5%90%AF%E5%8A%A8shell">3.1 启动shell</a></li>
<li><a href="#32-bash-%E6%89%8B%E5%86%8C">3.2 bash 手册</a></li>
<li><a href="#34-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">3.4 文件系统</a></li>
</ul>
</li>
<li><a href="#4-%E5%85%B6%E4%BB%96shell%E5%91%BD%E4%BB%A4">4. 其他shell命令</a><ul>
<li><a href="#41-%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F">4.1 监控程序</a><ul>
<li><a href="#411-ps%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">4.1.1 ps查看进程</a></li>
<li><a href="#412-top%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7">4.1.2 top实时监控</a></li>
<li><a href="#413-kill%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B">4.1.3 kill结束进程</a></li>
<li><a href="#414-%E7%B3%BB%E7%BB%9Fperformance%E7%9B%91%E6%8E%A7">4.1.4 系统performance监控</a></li>
</ul>
</li>
<li><a href="#42-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9B%91%E6%8E%A7">4.2 磁盘空间监控</a><ul>
<li><a href="#421-mount%E6%8C%82%E5%9C%A8%E5%AD%98%E5%82%A8%E5%AA%92%E4%BD%93">4.2.1 mount挂在存储媒体</a></li>
<li><a href="#422-unmount-%E5%8D%B8%E8%BD%BD%E8%AE%BE%E5%A4%87">4.2.2 unmount 卸载设备</a></li>
<li><a href="#423-df-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5">4.2.3 df 查看磁盘使用情况</a></li>
<li><a href="#424-du-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4">4.2.4 du 磁盘空间</a></li>
</ul>
</li>
<li><a href="#43-%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6">4.3 处理文件</a><ul>
<li><a href="#431-sort---%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F">4.3.1 sort - 文件排序</a></li>
<li><a href="#432-grep---%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6">4.3.2 grep - 搜索文件</a></li>
<li><a href="#433-zip--gzipgz-compressz-bzip2bz2-%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE">4.3.3 zip , gzip:gz, compress:Z, bzip2:bz2 压缩数据</a></li>
<li><a href="#434-tar-%E5%BD%92%E6%A1%A3%E6%95%B0%E6%8D%AE">4.3.4 tar 归档数据</a></li>
<li><a href="#435-find-%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4">4.3.5 find 搜索命令</a></li>
<li><a href="#436-uname-%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E4%BF%A1%E6%81%AF">4.3.6 uname 显示系统内核信息</a></li>
</ul>
</li>
<li><a href="#44-date%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6%E6%A0%BC%E5%BC%8F%E5%8C%96">4.4 date命令及其格式化</a></li>
</ul>
</li>
<li><a href="#5-%E7%90%86%E8%A7%A3shell">5. 理解shell</a><ul>
<li><a href="#51-shell%E7%9A%84%E7%B1%BB%E5%9E%8B">5.1 shell的类型</a></li>
<li><a href="#52-shell%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB">5.2 shell的父子关系</a><ul>
<li><a href="#521-%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8">5.2.1 进程列表</a></li>
<li><a href="#522-%E5%AD%90shell%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95">5.2.2 子shell的其他用法</a></li>
</ul>
</li>
<li><a href="#53-%E7%90%86%E8%A7%A3shell%E7%9A%84%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4">5.3 理解shell的内建命令</a><ul>
<li><a href="#531-%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4">5.3.1 外部命令</a></li>
<li><a href="#532-%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4">5.3.2 内部命令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">6. 环境变量</a></li>
<li><a href="#7-linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">7. linux文件权限</a><ul>
<li><a href="#71-linux%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7">7.1 linux的安全性</a><ul>
<li><a href="#711-%E6%B7%BB%E5%8A%A0linux%E7%94%A8%E6%88%B7">7.1.1 添加linux用户</a></li>
<li><a href="#712-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7">7.1.2 删除用户</a></li>
<li><a href="#712-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7">7.1.2 修改用户</a></li>
</ul>
</li>
<li><a href="#72-%E4%BD%BF%E7%94%A8linux%E7%BB%84">7.2 使用linux组</a></li>
<li><a href="#73-%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">7.3 理解文件权限</a></li>
<li><a href="#74-%E6%94%B9%E5%8F%98%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E7%BD%AE">7.4 改变安全性设置</a></li>
<li><a href="#75-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6">7.5 共享文件</a></li>
</ul>
</li>
<li><a href="#9-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F">9. 安装软件程序</a><ul>
<li><a href="#91-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">9.1 包管理工具</a></li>
<li><a href="#92-%E5%9F%BA%E4%BA%8Edebian%E7%9A%84%E7%B3%BB%E7%BB%9F">9.2 基于Debian的系统</a><ul>
<li><a href="#921-%E7%94%A8aptitude-%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85">9.2.1 用aptitude 管理软件包</a></li>
</ul>
</li>
<li><a href="#93-%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85">9.3 基于源码安装</a></li>
</ul>
</li>
<li><a href="#10-%E4%BD%BF%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8">10. 使用编辑器</a><ul>
<li><a href="#101-vim-%E7%BC%96%E8%BE%91%E5%99%A8">10.1 vim 编辑器</a></li>
</ul>
</li>
<li><a href="#11%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC">11.基本脚本</a></li>
<li><a href="#12-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4">12. 使用结构化命令</a></li>
<li><a href="#13-for-%E5%BE%AA%E7%8E%AF">13. for 循环</a><ul>
<li><a href="#131-for%E5%91%BD%E4%BB%A4">13.1 for命令</a></li>
<li><a href="#132-c%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC">13.2 C语言风格</a></li>
<li><a href="#133-while%E8%AF%AD%E5%8F%A5">13.3 while语句</a></li>
<li><a href="#134-until%E5%91%BD%E4%BB%A4">13.4 until命令</a></li>
<li><a href="#135-%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BB%A5%E7%89%B9%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6%E5%88%86%E5%89%B2%E6%95%B0%E6%8D%AE">13.5 循环处理数据并以特定分隔符分割数据</a></li>
</ul>
</li>
<li><a href="#14-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">14. 处理用户输入</a><ul>
<li><a href="#141-%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E8%84%9A%E6%9C%AC%E5%90%8D%E5%92%8C%E6%B5%8B%E8%AF%95%E5%8F%82%E6%95%B0">14.1 读取参数，脚本名和测试参数</a></li>
<li><a href="#142-%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9">14.2 处理选项</a></li>
<li><a href="#143-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">14.3 获取用户输入</a></li>
</ul>
</li>
<li><a href="#15-%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE">15. 呈现数据</a><ul>
<li><a href="#151-%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">15.1 理解输入和输出</a><ul>
<li><a href="#1511-%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.1.1 标准文件描述符</a></li>
<li><a href="#1512-%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF">15.1.2 重定向错误</a></li>
</ul>
</li>
<li><a href="#152-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA">15.2 在脚本中重定向输出</a><ul>
<li><a href="#1521-%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91">15.2.1 临时重定向</a></li>
<li><a href="#1522-%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91">15.2.2 永久重定向</a></li>
</ul>
</li>
<li><a href="#153-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5">15.3 在脚本中重定向输入</a></li>
<li><a href="#154-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91">15.4 创建自己的重定向</a><ul>
<li><a href="#1541-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.1 创建输出文件描述符</a></li>
<li><a href="#1542-%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.2 重定向文件描述符</a></li>
<li><a href="#1543-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.3 创建输入文件描述符</a></li>
<li><a href="#1544-%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.4 创建读写文件描述符</a></li>
<li><a href="#1545-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.4.5 关闭文件描述符</a></li>
</ul>
</li>
<li><a href="#155-%E5%88%97%E5%87%BA%E6%9C%AA%E5%85%B3%E9%97%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">15.5 列出未关闭的文件描述符</a></li>
<li><a href="#156-%E7%BB%84%E7%BB%87%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA">15.6 组织命令输出</a></li>
<li><a href="#157-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">15.7 创建临时文件</a><ul>
<li><a href="#1571-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">15.7.1 创建本地临时文件</a></li>
<li><a href="#1572-%E5%9C%A8temp%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">15.7.2 在&#x2F;temp&#x2F;创建临时文件</a></li>
<li><a href="#1573-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95">15.7.3 创建临时目录</a></li>
</ul>
</li>
<li><a href="#158-%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF">15.8 记录消息</a></li>
<li><a href="#159-%E5%AE%9E%E6%88%98">15.9 实战</a></li>
</ul>
</li>
<li><a href="#16-%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC">16. 控制脚本</a><ul>
<li><a href="#161-%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7">16.1 处理信号</a><ul>
<li><a href="#1611-%E9%87%8D%E6%B8%A9linux%E4%BF%A1%E5%8F%B7">16.1.1 重温linux信号</a></li>
<li><a href="#1612-%E7%94%9F%E6%88%90%E4%BF%A1%E5%8F%B7">16.1.2 生成信号</a></li>
<li><a href="#1613-%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7">16.1.3 捕获信号</a></li>
<li><a href="#1614-%E6%8D%95%E8%8E%B7%E8%84%9A%E6%9C%AC%E9%80%80%E5%87%BA">16.1.4 捕获脚本退出</a></li>
<li><a href="#1615-%E4%BF%AE%E6%94%B9%E6%88%96%E7%A7%BB%E9%99%A4%E6%8D%95%E8%8E%B7">16.1.5 修改或移除捕获</a></li>
</ul>
</li>
<li><a href="#162-%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">16.2 以后台模式运行脚本</a><ul>
<li><a href="#1621-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">16.2.1 后台运行脚本</a></li>
<li><a href="#1622-%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%90%8E%E5%8F%B0%E4%BD%9C%E4%B8%9A">16.2.2 运行多个后台作业</a></li>
<li><a href="#1623-%E5%9C%A8%E9%9D%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">16.2.3 在非控制台下运行程序</a></li>
</ul>
</li>
<li><a href="#164-%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6">16.4 作业控制</a><ul>
<li><a href="#1641-%E6%9F%A5%E7%9C%8B%E4%BD%9C%E4%B8%9A">16.4.1 查看作业</a></li>
<li><a href="#1642-%E9%87%8D%E5%90%AF%E5%81%9C%E6%AD%A2%E7%9A%84%E4%BD%9C%E4%B8%9A">16.4.2 重启停止的作业</a></li>
</ul>
</li>
<li><a href="#165-%E8%B0%83%E6%95%B4%E8%B0%A6%E8%AE%A9%E5%BA%A6">16.5 调整谦让度</a><ul>
<li><a href="#1651-nice-%E5%91%BD%E4%BB%A4">16.5.1 nice 命令</a></li>
<li><a href="#1652-renice-%E5%91%BD%E4%BB%A4">16.5.2 renice 命令</a></li>
</ul>
</li>
<li><a href="#166-%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A">16.6 定时运行作业</a><ul>
<li><a href="#1661-%E7%94%A8at%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%AE%A1%E5%88%92%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A">16.6.1 用at命令来计划执行作业</a></li>
<li><a href="#1662-%E5%AE%89%E6%8E%92%E9%9C%80%E8%A6%81%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC">16.6.2 安排需要定期执行的脚本</a></li>
<li><a href="#1663-%E4%BD%BF%E7%94%A8%E6%96%B0shell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC">16.6.3 使用新shell启动脚本</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#17-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">17. 创建函数</a><ul>
<li><a href="#171-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0">17.1 基本的脚本函数</a><ul>
<li><a href="#1711-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">17.1.1 创建函数</a></li>
<li><a href="#1712-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0">17.1.2 使用函数</a></li>
</ul>
</li>
<li><a href="#172-%E8%BF%94%E5%9B%9E%E5%80%BC">17.2 返回值</a><ul>
<li><a href="#1721-%E9%BB%98%E8%AE%A4%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81">17.2.1 默认退出状态码</a></li>
<li><a href="#1722-%E4%BD%BF%E7%94%A8return%E5%91%BD%E4%BB%A4">17.2.2 使用return命令</a></li>
<li><a href="#1723-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA">17.2.3 使用函数输出</a></li>
</ul>
</li>
<li><a href="#173-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">17.3 在函数中使用变量</a><ul>
<li><a href="#1731-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">17.3.1 向函数传递参数</a></li>
<li><a href="#1732-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F">17.3.2 在函数中处理变量</a></li>
</ul>
</li>
<li><a href="#174-%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0">17.4 数组变量和函数</a><ul>
<li><a href="#1742-%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84">17.4.2 从函数中返回数组</a></li>
</ul>
</li>
<li><a href="#175-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92">17.5 函数递归</a></li>
<li><a href="#176-%E5%88%9B%E5%BB%BA%E5%BA%93">17.6 创建库</a></li>
<li><a href="#177-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0">17.7 在命令行上使用函数</a><ul>
<li><a href="#1771-%E5%9C%A8%E5%91%BD%E4%BB%A4%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">17.7.1 在命令上创建函数</a></li>
<li><a href="#1772-%E5%9C%A8bashrc-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">17.7.2 在.bashrc 文件中定义函数</a></li>
</ul>
</li>
<li><a href="#178-%E5%AE%9E%E4%BE%8B">17.8 实例</a><ul>
<li><a href="#1781-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93">17.8.1 下载安装第三方库</a></li>
<li><a href="#1782-%E6%9E%84%E5%BB%BA%E5%BA%93">17.8.2 构建库</a></li>
<li><a href="#1783-shtool%E5%BA%93%E5%87%BD%E6%95%B0">17.8.3 shtool库函数</a></li>
<li><a href="#1784-%E4%BD%BF%E7%94%A8%E5%BA%93">17.8.4 使用库</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#18-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E4%B8%AD%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B">18. 图形化界面中脚本编程</a></li>
<li><a href="#19%E5%88%9D%E8%AF%86sed%E5%92%8Cgawk">19.初识sed和gawk</a><ul>
<li><a href="#191-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86">19.1 文本处理</a><ul>
<li><a href="#1911-sed%E7%BC%96%E8%BE%91%E5%99%A8">19.1.1 sed编辑器</a></li>
<li><a href="#1912-gawk%E7%A8%8B%E5%BA%8F">19.1.2 gawk程序</a></li>
</ul>
</li>
<li><a href="#192-sed-%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80">19.2 sed 编辑器基础</a><ul>
<li><a href="#1921-%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%9B%BF%E6%8D%A2%E9%80%89%E9%A1%B9">19.2.1 更多的替换选项</a></li>
<li><a href="#1922-%E4%BD%BF%E7%94%A8%E5%9C%B0%E5%9D%80">19.2.2 使用地址</a></li>
<li><a href="#1923-%E5%88%A0%E9%99%A4%E8%A1%8C">19.2.3 删除行</a></li>
<li><a href="#1924-%E6%8F%92%E5%85%A5%E5%92%8C%E9%99%84%E5%8A%A0%E6%96%87%E6%9C%AC">19.2.4 插入和附加文本</a></li>
<li><a href="#1925-%E4%BF%AE%E6%94%B9%E8%A1%8C">19.2.5 修改行</a></li>
<li><a href="#1926-%E8%BD%AC%E6%8D%A2%E5%91%BD%E4%BB%A4">19.2.6 转换命令</a></li>
<li><a href="#1927-%E5%9B%9E%E9%A1%BE%E6%89%93%E5%8D%B0">19.2.7 回顾打印</a></li>
<li><a href="#1928-%E4%BD%BF-%E7%94%A8-sed-%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6">19.2.8 使 用 sed 处理文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">20.正则表达式</a><ul>
<li><a href="#201-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">20.1 什么是正则表达式</a></li>
<li><a href="#202-%E5%AE%9A%E4%B9%89bre%E6%A8%A1%E5%BC%8F">20.2 定义BRE模式</a><ul>
<li><a href="#2021-%E7%BA%AF%E6%96%87%E6%9C%AC">20.2.1. 纯文本</a></li>
<li><a href="#2022-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">20.2.2 特殊字符</a></li>
<li><a href="#2023-%E9%94%9A%E5%AE%9A%E5%AD%97%E7%AC%A6">20.2.3 锚定字符</a></li>
<li><a href="#2024-%E7%82%B9%E5%AD%97%E7%AC%A6">20.2.4 点字符</a></li>
<li><a href="#2025-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">20.2.5 字符数组</a></li>
<li><a href="#2026-%E6%8E%92%E9%99%A4%E5%9E%8B%E5%AD%97%E7%AC%A6">20.2.6 排除型字符</a></li>
<li><a href="#2027-%E5%8C%BA%E9%97%B4">20.2.7 区间</a></li>
<li><a href="#2028-%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">20.2.8 特殊的字符数组</a></li>
<li><a href="#2029-%E6%98%9F%E5%8F%B7">20.2.9 星号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendindex">AppendIndex</a><!-- toc --></li>
</ul>
                    
                        <a
                            href="/2022/06/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%88%87shell%E8%85%B3%E6%9C%AC%E7%B7%A8%E7%A8%8B%E5%A4%A7%E5%85%A8/"
                            class="postShorten-excerpt_link link"
                            aria-label=": Linux命令行与shell腳本編程大全"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%BB%E7%A0%94%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/"
                            aria-label=": 如何在读研的道路上快速失败"
                        >
                            如何在读研的道路上快速失败
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T21:14:38+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>原创:陈怡然 陈老师有话说</p>
<ol>
<li>为自己找出一堆把其他个人兴趣爱好或者其他事情放在学习之上的理由：比如人活着就是为了享受生活，要事业家庭平衡之类（说真的，这是人生观问题。也许一开始你就根本不需要&#x2F;不应该读研）；</li>
<li>认为很多必须要做的事情或者要解决的问题拖到最后会不了了之、奇迹般迎刃而解、或者导师会忘(这怎么可能)</li>
<li>为导师不经常找自己而沾沾自喜(其实大部分时候那只是因为他觉得不值得在你身上瞎耽误功夫)</li>
<li>花很多时间计算到底怎么做才能快速达到最低毕业要求赶紧毕业（易经：取法乎上，仅得其中；取法乎中，仅得其下)</li>
<li>每次都指望从师兄师姐那里临时榨点什么以混过和导师的1-on-1（以为导师和师兄师姐傻啊？）；</li>
<li>总觉得别人做的东西简单容易上手好发文章，不断在不同的题目中跳来跳去（世上那有什么容易的东西，只有你看不到的努力)</li>
<li>对导师和同学的建议与帮助出于本能的拒绝并试图证明别人是错的(自尊&#x2F;自信&#x2F;自负&#x2F;自卑大多数时候其实我们自己不是那么容易分的清楚，但别人的善心只会offer一次)</li>
<li>总觉得自己比别人聪明，研究做不出来或者文章总不中只是一时粗心或者运气不好(不断重复发生的事情其实就是规律)</li>
<li>在每次觉得做不出来、或者做不完的时候玩消失，或者对更大、更复杂的任务说No（盖章：此人难当大任)</li>
<li>每次都刚刚做到最低要求，把剩余的工作扔给导师或者合作的同学，并为自己节省下的时间和努力沾沾自喜(你可能还没认识到别人对你的支持永远和你自己的付出成正比这一事实)</li>
<li>觉得自己很努力了，但是却怎么也达不到目标或者导师要求(如果确实不是你还有没有挤出来的时间，而你也不愿意承认自己确实不行，那么就多花点时间观察别人学习的方法和效率吧)</li>
<li>开始承认自己确实不行，并把全部精力放在劝说老师降低标准放自己毕业上(你可能没理解这件事情的难度在于你要求他降低的是对所有人的标准，而不单单是对你自己的)</li>
<li>觉得导师是个傻X(这个其实也不是没有可能。强扭的瓜不甜，我支持你用脚投票。或许到时双方都会大大的松了一口气，多年以后江湖再见还能把酒言欢).</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%BB%E7%A0%94%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E4%BB%8E0%E5%88%B01_%E5%BC%80%E5%90%AF%E5%95%86%E4%B8%9A%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%98%E5%AF%86/"
                            aria-label=": 从0到1:开启商业与未来的秘密"
                        >
                            从0到1:开启商业与未来的秘密
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T20:51:26+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/">非技术类</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="第八章-秘密"><a href="#第八章-秘密" class="headerlink" title="第八章:秘密"></a>第八章:秘密</h2><p>还记得我们的反主流问题吗：在什么重要问题上你与其他人有不同看法？如果我们今天对自然的了解已经达到未来才能达到的程度，如果今天所有的真理已被领悟，如果再无秘密可探索，那么这个问题就寻不到好答案。除非世界上还有秘密有待发现，否则与众不同的想法就毫无意义。 如果世界上还有很多秘密，那就还可能出现很多有望改变世界的企业.</p>
<pre class="language-text" data-language="text"><code class="language-text">作者提出一个模型。 尝试（不是秘密） 困难（有秘密要探索）不可能（验证弦理论），
人们可以完成困难的事情，但是不能完成不可能的事情</code></pre>

<h2 id="8-1-为什么人们不探索发现秘密"><a href="#8-1-为什么人们不探索发现秘密" class="headerlink" title="8.1 为什么人们不探索发现秘密"></a>8.1 为什么人们不探索发现秘密</h2><p>因为人类都愿意悲观的思考问题。四种社会趋势使人们不愿相信秘密</p>
<ol>
<li>渐进主义：从小被教育只要学习考试规定的内容就可以了。不要做“出格”的事情</li>
<li>风险规避： 人之常情，探索秘密就会经历错误的选择。会花费时间思考和纠正。经受制度带来的压力。</li>
<li>自满：既然能享受现有成果，为什么还要探索秘密？</li>
<li>地球的扁平化：人们认为世界是平的，是高度一至的。如果发现新事物，难道世界其他地方的人就没发现吗？鉴于此想法，导致人不愿意去探索</li>
</ol>
<p>我们可以用一种乐观的方式来描述以上这些趋势带来的结果：创立任何狂热教派在今天看来都异想天开。而在40年前，人们更加认同这样一个观点——并不是所有知识都是众所周知的。从共产党到印度教克利须纳派，大多数人认为他们可以加入先锋觉醒组织，以得到一条指引自己前进的道路。如今极少有人对非正统观念持严肃认真的态度，主流认为这是进步的标志。现在，疯狂的异端教派越来越少，我们应该为之感到高兴，但是为了这一收获，我们付出了沉重的代价：丧失了对等待被挖掘的秘密的好奇之心。</p>
<blockquote>
<p>上面内容更像是作者对非主流思想的一种趋向，因为人们认为主流思想才是进步思想，二而对于非正统思想持一种抵触。这样的好处是，疯狂的异教徒少了，但也丢了挖掘秘密的好奇心</p>
</blockquote>
<h2 id="8-2-恪守常规的世界"><a href="#8-2-恪守常规的世界" class="headerlink" title="8.2 恪守常规的世界"></a>8.2 恪守常规的世界</h2><p>不去发现秘密让人们的思想，认识，得不到良序的发展，没有人权，没有更多的自由。世界在发展，还有很多秘密仍需要发展。</p>
<p>例如：在经济学上，因为人们过度相信市场经济，认为市场经济可以调控一切经济活动。但是2008年的经济危机。说明过度相信市场经济，市场泡沫会在某个阶段爆发出来。<br>当一个公司不思进取就会慢慢像惠普一样，慢慢的被时代，环境，对手淘汰掉。</p>
<h2 id="8-3-相信秘密"><a href="#8-3-相信秘密" class="headerlink" title="8.3 相信秘密"></a>8.3 相信秘密</h2><p>事实上还是有很多秘密存在，人们相信秘密的存在。因为这个世界还有很多问题存在，因为问题的存在，以及人们追求高效，简单，快捷处理问题的速求，以及这背后带来的巨大财富，促使人们去寻找解决问题的出路，并坚定的选择去探索秘密。<br>在工程，科学还有很多事情要去做，商业也是如此，它建立在这个世界的开放未知的秘密之上，这个秘密关乎世界如何运作，也是因为相信秘密的存在促成很多大公司的建立，以及源源不断的新公司的成立</p>
<h2 id="8-4-发现秘密"><a href="#8-4-发现秘密" class="headerlink" title="8.4 发现秘密"></a>8.4 发现秘密</h2><ul>
<li>自然的密码</li>
<li>人的秘密</li>
</ul>
<p>当你要创建公司的时候要问自己两个秘密，哪些自然秘密还是未知的，哪些人的秘密是未知的。作者举了个物理学博士面试工程师的故事来说明，不要以为自己理解专业知识丰富而忽略了人的因素.</p>
<pre class="language-text" data-language="text"><code class="language-text">不记得在哪里看到过一句话，做成事情，要满足明面的规则，也要满足潜规则。硬性技能和软技能，都要把握住。</code></pre>

<h2 id="8-5-秘密的作用"><a href="#8-5-秘密的作用" class="headerlink" title="8.5 秘密的作用"></a>8.5 秘密的作用</h2><p>所有伟大的公司都是都是基于鲜为人知的秘密创立的。当你与人分享你的秘密的时候就会招来竞争者</p>
<pre class="language-text" data-language="text"><code class="language-text">当你想阐述的答案与大众价值观相左，就不要人人皆知，和不告诉别人之间有个平衡点，这个平衡点会将帮助你达成目标------ 发现秘密</code></pre>

<p>秘密能将你引向鲜花和掌声，以及带来荣誉，将你带向耀眼月亮。选择那条崎岖，隐晦的路吧。</p>
<h2 id="第九章-基础决定命运"><a href="#第九章-基础决定命运" class="headerlink" title="第九章:基础决定命运"></a>第九章:基础决定命运</h2><p>最近有个想法一直浮现在脑海中“在世界上的所有知识当中，抑或是自己选择的道路所需要的知识，都应该是有个‘根’知识，这个‘根’知识很重要，它是学习其他知识的基础，影响着你吸取其他知识”。一开始就要打好基础，一个一个的过，不要有侥幸心理，在开始做的时候就要做到尽善尽美</p>
<h2 id="9-1-初创时的“联姻”"><a href="#9-1-初创时的“联姻”" class="headerlink" title="9.1 初创时的“联姻”"></a>9.1 初创时的“联姻”</h2><p>如果个人能力不行，就需要与其他人合作，这话说起来简单，但有诸多细节需要探讨，比如这个人的脾气，性格等等。随时都可能导致某人与团队不和，进而使工作无法推荐所以作者在投资一家公司时候会看领导层的硬实力，也就是专业技能，和他们之间的默契程度，他们要有深厚交情.</p>
<h2 id="9-2-所有权，股权，控制权"><a href="#9-2-所有权，股权，控制权" class="headerlink" title="9.2 所有权，股权，控制权"></a>9.2 所有权，股权，控制权</h2><p>要做好这三个权力的分配。如果想控制公司，要保证董事会人数尽可能的少</p>
<h2 id="9-3-要么上车，要么下车"><a href="#9-3-要么上车，要么下车" class="headerlink" title="9.3 要么上车，要么下车"></a>9.3 要么上车，要么下车</h2><p>作者的这个观点我不太认同，那跨国公司，不同国家间不同人群的协同工作，有些公司也可做的很好</p>
<h2 id="9-4-现金奖励不是王道"><a href="#9-4-现金奖励不是王道" class="headerlink" title="9.4 现金奖励不是王道"></a>9.4 现金奖励不是王道</h2><p>这点作者的意思在初创时候，不要给太多的现金来捆绑住员工的忠诚度。因为给的钱多，很可能会将公司掏空.</p>
<h2 id="9-5-股票激励才能使员工全力以赴"><a href="#9-5-股票激励才能使员工全力以赴" class="headerlink" title="9.5 股票激励才能使员工全力以赴"></a>9.5 股票激励才能使员工全力以赴</h2><p>股票流通差，站在员工角度其实就是在赌这个公司的运气，因为公司破产股票就一文不值。站在老板角度就是在让员工与公司共成长。进而也减少现金开销</p>
<h2 id="9-6-让创业延续"><a href="#9-6-让创业延续" class="headerlink" title="9.6 让创业延续"></a>9.6 让创业延续</h2><p>最有价值的公司始终鼓励发明创造，之前度过相关的文章是说微创新，在企业内部创业。如果每次创业实际恰当，使公司向着创新道路发展。进而无限创业下去。  </p>
<blockquote>
<p>居家办公或者在办公室办公也好。大家都会产生些许许摩擦，如何团结团队凝聚力这也是个关键问题，就像是实际工作中，如果把team给你管理，你是否可以推动工作前进呢？需要后面学习别人如何处理团队人事相关问题。别指望少付出还能持续创收，管理会碰到麻烦，但不应害怕，专注解决人，和工作上的问题</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E4%BB%8E0%E5%88%B01_%E5%BC%80%E5%90%AF%E5%95%86%E4%B8%9A%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%98%E5%AF%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"
                            aria-label=": docker从入门到实践"
                        >
                            docker从入门到实践
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T20:47:28+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/CICD/">CICD</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AFdocker">1. 什么是docker</a></li>
<li><a href="#2docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">2.docker镜像基本概念与基本命令</a><ul>
<li><a href="#21-%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">2.1 镜像基本命令</a></li>
<li><a href="#22-%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F">2.2 定制镜像</a><ul>
<li><a href="#221-%E4%BD%BF%E7%94%A8dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F">2.2.1 使用Dockerfile定制镜像</a></li>
<li><a href="#222-%E7%9B%B4%E6%8E%A5%E7%94%A8-git-repo%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">2.2.2 直接用 Git repo构建镜像</a></li>
<li><a href="#223-%E7%94%A8%E7%BD%91%E7%BB%9C%E4%BD%8D%E7%BD%AE%E4%B8%8Atar%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">2.2.3 用网络位置上tar构建镜像</a></li>
<li><a href="#224-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AE%9A%E5%88%B6">2.2.4 从标准输入输出定制</a></li>
<li><a href="#225-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA">2.2.5 从标准输入中读取上下文压缩包进行构建</a></li>
</ul>
</li>
<li><a href="#23-dockerfile%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3">2.3 Dockerfile构建命令详解</a><ul>
<li><a href="#231-copy%E5%A4%8D%E5%88%B6">2.3.1 COPY复制</a></li>
<li><a href="#232-add%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4">2.3.2 ADD更高级的复制命令</a></li>
<li><a href="#233-cmd%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4">2.3.3 CMD容器启动命令</a></li>
<li><a href="#234-entrypoint-%E5%85%A5%E5%8F%A3%E7%82%B9">2.3.4 ENTRYPOINT 入口点</a></li>
<li><a href="#235-env-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">2.3.5 ENV 设置环境变量</a></li>
<li><a href="#236-arg-%E6%9E%84%E5%BB%BA%E6%8C%87%E4%BB%A4">2.3.6 ARG 构建指令</a></li>
<li><a href="#237-volume-%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%8D%B7">2.3.7 VOLUME 定义匿名卷</a></li>
<li><a href="#238-expose-%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3">2.3.8 EXPOSE 暴露端口</a></li>
<li><a href="#239-workdir-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95">2.3.9 WORKDIR 指定工作目录</a></li>
<li><a href="#2310-user%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7">2.3.10 USER指定当前用户</a></li>
<li><a href="#2311-healthcheck-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5healthcheck-%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%97%E9%80%89%E9%A1%B9">2.3.11 HEALTHCHECK 健康检查<code>HEALTHCHECK</code> 支持下列选项</a></li>
<li><a href="#2312-onbuild-%E4%B8%BA%E4%BB%96%E4%BA%BA%E4%BD%9C%E5%AB%81%E8%A1%A3%E8%A3%B3">2.3.12 ONBUILD 为他人作嫁衣裳</a></li>
<li><a href="#2313-label-%E4%B8%BA%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE">2.3.13 LABEL 为镜像添加元数据</a></li>
<li><a href="#2314-shell%E6%8C%87%E4%BB%A4">2.3.14 shell指令</a></li>
<li><a href="#2315-%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">2.3.15 参考文档</a></li>
</ul>
</li>
<li><a href="#24-dockerfile-%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">2.4 Dockerfile 多阶段构建</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">实战多阶段构建镜像</a></li>
<li><a href="#25-%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81%E7%9A%84docker%E9%95%9C%E5%83%8F">2.5 构建多种系统架构支持的docker镜像</a></li>
<li><a href="#26-%E5%85%B6%E5%AE%83%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%9A%84%E6%96%B9%E5%BC%8F">2.6 其它制作镜像的方式</a></li>
</ul>
</li>
<li><a href="#3-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8">3. 操作容器</a><ul>
<li><a href="#31-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">3.1 容器基本操作</a></li>
</ul>
</li>
<li><a href="#4-%E8%AE%BF%E9%97%AE%E4%BB%93%E5%BA%93">4. 访问仓库</a></li>
<li><a href="#5-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86">5. 数据管理</a><ul>
<li><a href="#51-%E6%95%B0%E6%8D%AE%E5%8D%B7">5.1 数据卷</a></li>
<li><a href="#52-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95">5.2 挂载主机目录</a></li>
</ul>
</li>
<li><a href="#6-%E7%BD%91%E7%BB%9C">6. 网络</a><ul>
<li><a href="#61-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84">6.1 端口映射</a></li>
<li><a href="#62-%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94">6.2 容器互联</a></li>
<li><a href="#63-%E9%85%8D%E7%BD%AEdns">6.3. 配置DNS</a></li>
</ul>
</li>
<li><a href="#7-%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">7. 高级网络配置</a></li>
<li><a href="#8-docker-buildx">8. Docker Buildx</a></li>
<li><a href="#9-docker-compose">9. Docker Compose</a><ul>
<li><a href="#91-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAweb%E5%BA%94%E7%94%A8">9.1 搭建一个web应用</a></li>
</ul>
</li>
<li><a href="#10-%E5%AE%89%E5%85%A8">10. 安全</a></li>
<li><a href="#11-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">11. 底层实现</a></li>
<li><a href="#12-kubernetes">12. Kubernetes</a></li>
<li><a href="#13-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B---cicd">13. 实战案例 - CI&#x2F;CD</a></li>
</ul>
<h1 id="1-什么是docker"><a href="#1-什么是docker" class="headerlink" title="1. 什么是docker"></a>1. 什么是docker</h1><p>Docker是云技术的一次革新，2013年以Apache协议开源，基于linux内核的<strong>cgroup</strong>,<strong>namespace</strong>以及OverlayFS的<strong>UnionFS</strong>实现，对进程进行封装，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主机因此称为容器</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b5d51fa80b2435386d16496375409c2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f40405bc364cd295076c36c9d354e5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>镜像<br>操作系统分为<code>内核</code>和<code>用户空间</code>，而docker的镜像就是一种特殊的文件系统，除了提供容器运行所需的程序，库，资源，配置等文件外，还包括为运行时准备的的一些配置参数</p>
</li>
<li><p>分层存储<br>Docker 设计时，就充分利用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
</li>
<li><p>容器<br>容器跟镜像的关系就像是面向对象中类和实例的概念，容器的实质是进程，与宿主机的进程不同，容器拥有自己独立的命空间，因此拥有自己的root文件系统，自己的网络配置，自己的进程空间，自己的用户id空间。进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。<br>一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong><br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失（后面建议挂载volume）</p>
</li>
<li><p>仓库<br><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/basic_concept/repository">仓库</a></p>
</li>
</ul>
<h1 id="2-docker镜像基本概念与基本命令"><a href="#2-docker镜像基本概念与基本命令" class="headerlink" title="2.docker镜像基本概念与基本命令"></a>2.docker镜像基本概念与基本命令</h1><h2 id="2-1-镜像基本命令"><a href="#2-1-镜像基本命令" class="headerlink" title="2.1 镜像基本命令"></a>2.1 镜像基本命令</h2><p>拉取镜像:</p>
<ul>
<li>docker pull [OPTION] NAME</li>
</ul>
<pre class="language-text" data-language="text"><code class="language-text">&lt;域名/IP>[:端口号]</code></pre>

<p>运行镜像：</p>
<ul>
<li>docker run -it –rm 镜像 [命令 &#x2F;bin&#x2F;bash]  参数<br>列举镜像：</li>
<li>docker image ls</li>
<li>docker images</li>
<li>docker image ls -f since&#x3D;mongo:3.2 &#x2F;&#x2F;查看某个镜像之前创建的镜像，同理也有查看某个镜像之后的镜像</li>
<li>docker ps &#x3D; docker container ls &#x2F;&#x2F;现实运行中的容器<br>查看镜像体积</li>
<li>docker system df<br>虚悬镜像<br>仓库名和版本号都是none，这是因为新版本的镜像跟旧镜像冲突，，删除虚悬镜像</li>
<li>docker image prune</li>
<li>docker image ls -f dangling&#x3D;true &#x2F;&#x2F;列举虚悬镜像</li>
<li>docker image ls -a &#x2F;&#x2F;有些none镜像不是虚悬镜像是中间镜像<br>以特定格式显示</li>
<li>docker image ls -q</li>
<li><code>docker image ls --format &quot;&#123;&#123; .ID &#125;&#125;:&#123;&#123; .Repository &#125;&#125;&quot; </code> &#x2F;&#x2F;支持go模板用法,方便其他程序调用</li>
<li><code>docker image ls --format &quot;table &#123;&#123; .ID &#125;&#125; \t &#123;&#123; .Repository &#125;&#125; \t &#123;&#123; .Tag &#125;&#125;&quot;</code> &#x2F;&#x2F; 会显示title<br>删除镜像</li>
<li>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</li>
<li>docker image rm $(docker image ls -q redis)  &#x2F;&#x2F;使用docker image ls命令配合使用</li>
</ul>
<p>untageged和删除  </p>
<ul>
<li>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因</li>
</ul>
<p>利用commit来持久化容器变化到镜像(黑箱镜)</p>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">docker commit \
--author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \
--message &quot;修改了默认网页&quot; \
webserver \
nginx:v2</code></pre>

<ul>
<li><code>docker history</code> 具体查看镜像内的历史记录</li>
</ul>
<h2 id="2-2-定制镜像"><a href="#2-2-定制镜像" class="headerlink" title="2.2 定制镜像"></a>2.2 定制镜像</h2><h3 id="2-2-1-使用Dockerfile定制镜像"><a href="#2-2-1-使用Dockerfile定制镜像" class="headerlink" title="2.2.1 使用Dockerfile定制镜像"></a>2.2.1 使用Dockerfile定制镜像</h3><p><strong>From</strong> 关键字指定基础镜像<br><em><strong>RUN</strong></em> 执行命令,在撰写 Dockerfile 的时候,要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建，使用docker build 构建编写的Dockerfile  </p>
<blockquote>
<p><code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能,当服务端需要本地文件时候该怎么获得</p>
</blockquote>
<p><em><strong>COPY</strong></em>  复制 <strong>上下文（context）</strong> 目录下的源文件</p>
<blockquote>
<p>COPY .&#x2F;package.json &#x2F;app&#x2F;</p>
</blockquote>
<p>复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>,<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像</p>
<ul>
<li>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile</li>
<li>如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的</li>
<li>实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code></li>
</ul>
<h3 id="2-2-2-直接用-Git-repo构建镜像"><a href="#2-2-2-直接用-Git-repo构建镜像" class="headerlink" title="2.2.2 直接用 Git repo构建镜像"></a>2.2.2 直接用 Git repo构建镜像</h3><pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile"># $env:DOCKER_BUILDKIT&#x3D;0
# export DOCKER_BUILDKIT&#x3D;0
$ docker build -t hello-world https:&#x2F;&#x2F;github.com&#x2F;docker-library&#x2F;hello-world.git#master:amd64&#x2F;hello-world
Step 1&#x2F;3 : FROM scratch
---&gt;
Step 2&#x2F;3 : COPY hello &#x2F;
---&gt; ac779757d46e
Step 3&#x2F;3 : CMD [&quot;&#x2F;hello&quot;]
---&gt; Running in d2a513a760ed
Removing intermediate container d2a513a760ed
---&gt; 038ad4142d2b
Successfully built 038ad4142d2b</code></pre>

<h3 id="2-2-3-用网络位置上tar构建镜像"><a href="#2-2-3-用网络位置上tar构建镜像" class="headerlink" title="2.2.3 用网络位置上tar构建镜像"></a>2.2.3 用网络位置上tar构建镜像</h3><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建.  </p>
<h3 id="2-2-4-从标准输入输出定制"><a href="#2-2-4-从标准输入输出定制" class="headerlink" title="2.2.4 从标准输入输出定制"></a>2.2.4 从标准输入输出定制</h3><p>docker build - &lt; Dockerfile<br>cat Dockerfile | docker build -<br>因为没有上下文，所以Dockerfile里面不可以使用<code>copy</code>  </p>
<h3 id="2-2-5-从标准输入中读取上下文压缩包进行构建"><a href="#2-2-5-从标准输入中读取上下文压缩包进行构建" class="headerlink" title="2.2.5 从标准输入中读取上下文压缩包进行构建"></a>2.2.5 从标准输入中读取上下文压缩包进行构建</h3><p>docker build - &lt; context.tar.gz<br>说白了就是解压后进行构建</p>
<h2 id="2-3-Dockerfile构建命令详解"><a href="#2-3-Dockerfile构建命令详解" class="headerlink" title="2.3 Dockerfile构建命令详解"></a>2.3 Dockerfile构建命令详解</h2><h3 id="2-3-1-COPY复制"><a href="#2-3-1-COPY复制" class="headerlink" title="2.3.1 COPY复制"></a>2.3.1 COPY复制</h3><ul>
<li>将上下文目录的文件复制到容器中的对应的目录下</li>
<li>支持通配符</li>
<li>源路径是相对路径，目标路径支持绝对路径</li>
<li><code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候</li>
<li>example</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">COPY requirements.txt &#x2F;code  &#x2F;&#x2F;copy 文件到容器中的&#x2F;code目录下</code></pre>

<h3 id="2-3-2-ADD更高级的复制命令"><a href="#2-3-2-ADD更高级的复制命令" class="headerlink" title="2.3.2 ADD更高级的复制命令"></a>2.3.2 ADD更高级的复制命令</h3><ul>
<li>源路径是tar包会在目标路径下解压(非常实用)</li>
<li><code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</li>
<li><code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组</li>
</ul>
<pre class="language-none"><code class="language-none">ADD --chown&#x3D;55:mygroup files* &#x2F;mydir&#x2F;
ADD --chown&#x3D;bin files* &#x2F;mydir&#x2F;
ADD --chown&#x3D;1 files* &#x2F;mydir&#x2F;
ADD --chown&#x3D;10:11 files* &#x2F;mydir&#x2F;</code></pre>

<h3 id="2-3-3-CMD容器启动命令"><a href="#2-3-3-CMD容器启动命令" class="headerlink" title="2.3.3 CMD容器启动命令"></a>2.3.3 CMD容器启动命令</h3><p>容器既然是进程，那么启动时就需要指定运行参数  </p>
<ul>
<li>example<br><code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM ubuntu:18.04
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*
CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]</code></pre>

<p>这个时候运行容器，docker run myip 就会打印ip相关信息，但是如果你想加参数<code>-i</code>，以如下方式<br><code>docker run myip -i</code> 就会报错，因为myip后面传入的参数会被认为是命令，而正确是的方式是<br><code>docker run myip curl -s http://myip.ipip.net -i</code>，显然这不是一个好的方案。可以使用2.3.4的参数来设计</p>
<h3 id="2-3-4-ENTRYPOINT-入口点"><a href="#2-3-4-ENTRYPOINT-入口点" class="headerlink" title="2.3.4 ENTRYPOINT 入口点"></a>2.3.4 ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数,例子如下</p>
<ul>
<li>场景一:让镜像像命令一样使用<code>ENTRYPOINT</code></li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM ubuntu:18.04
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*
ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]
&#x2F;&#x2F;再次尝试跑 docker run myip -i，就会将-i作为参数传给curl命令</code></pre>

<ul>
<li>场景二: 应用运行前的准备工作<br>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM alpine:3.4
RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis
ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]
EXPOSE 6379
CMD [ &quot;redis-server&quot; ]
&#x2F;&#x2F;redis服务创建了redis用户，并在最后ENTRYPOINT指定了entrypoint.sh的脚本,该脚本的内容就是根据CMD的内容
&#x2F;&#x2F;来判断，如果是redis-server的话，则切换到redis用户身份启动服务器，否则依旧使用root身份执行。比如：</code></pre>

<h3 id="2-3-5-ENV-设置环境变量"><a href="#2-3-5-ENV-设置环境变量" class="headerlink" title="2.3.5 ENV 设置环境变量"></a>2.3.5 ENV 设置环境变量</h3><p>可以为后面的RUN命令提供环境变量，是以键值对的形式存在，如果value部分有空格，需要使用双引号括起来</p>
<h3 id="2-3-6-ARG-构建指令"><a href="#2-3-6-ARG-构建指令" class="headerlink" title="2.3.6 ARG 构建指令"></a>2.3.6 ARG 构建指令</h3><p>ARG指令有生效范围，如果在FROM之前指定的，那么只能用于<code>FROM</code>指令中</p>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">ARG DOCKER_USERNAME&#x3D;library
FROM $&#123;DOCKER_USERNAME&#125;&#x2F;alpine
RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</code></pre>

<p><code>RUN</code>拿不到变量值，要想使用只能是在<code>FROM</code>命令后面重新指定<code>ARG</code>,多阶段构建需要指定各个阶段的<code>ARG</code></p>
<h3 id="2-3-7-VOLUME-定义匿名卷"><a href="#2-3-7-VOLUME-定义匿名卷" class="headerlink" title="2.3.7 VOLUME 定义匿名卷"></a>2.3.7 VOLUME 定义匿名卷</h3><p><code>VOLUME /data</code> 挂在匿名卷,向容器&#x2F;data写入的数据最终会落入host磁盘<br><code>$ docker run -d -v mydata:/data xxxx</code><br>就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置</p>
<h3 id="2-3-8-EXPOSE-暴露端口"><a href="#2-3-8-EXPOSE-暴露端口" class="headerlink" title="2.3.8 EXPOSE 暴露端口"></a>2.3.8 EXPOSE 暴露端口</h3><p>与-p &lt;宿主端口&gt;:&lt;容器端口&gt;, 映射端口不通，EXPOSE是暴漏容器端口给其他容器</p>
<h3 id="2-3-9-WORKDIR-指定工作目录"><a href="#2-3-9-WORKDIR-指定工作目录" class="headerlink" title="2.3.9 WORKDIR 指定工作目录"></a>2.3.9 WORKDIR 指定工作目录</h3><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录</p>
<h3 id="2-3-10-USER指定当前用户"><a href="#2-3-10-USER指定当前用户" class="headerlink" title="2.3.10 USER指定当前用户"></a>2.3.10 USER指定当前用户</h3><p><code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h3 id="2-3-11-HEALTHCHECK-健康检查HEALTHCHECK-支持下列选项"><a href="#2-3-11-HEALTHCHECK-健康检查HEALTHCHECK-支持下列选项" class="headerlink" title="2.3.11 HEALTHCHECK 健康检查HEALTHCHECK 支持下列选项"></a>2.3.11 HEALTHCHECK 健康检查<code>HEALTHCHECK</code> 支持下列选项</h3><ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM nginx
RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*
HEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \
CMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1

&#x2F;&#x2F;这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），
&#x2F;&#x2F;如果健康检查命令超过 3 &#x2F;&#x2F;秒没响应就视为失败，并且使用 &#96;curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1&#96;
&#x2F;&#x2F;作为健康检查命令。</code></pre>

<h3 id="2-3-12-ONBUILD-为他人作嫁衣裳"><a href="#2-3-12-ONBUILD-为他人作嫁衣裳" class="headerlink" title="2.3.12 ONBUILD 为他人作嫁衣裳"></a>2.3.12 ONBUILD 为他人作嫁衣裳</h3><h3 id="2-3-13-LABEL-为镜像添加元数据"><a href="#2-3-13-LABEL-为镜像添加元数据" class="headerlink" title="2.3.13 LABEL 为镜像添加元数据"></a>2.3.13 LABEL 为镜像添加元数据</h3><p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">LABEL org.opencontainers.image.authors&#x3D;&quot;yeasy&quot;
LABEL org.opencontainers.image.documentation&#x3D;&quot;https:&#x2F;&#x2F;yeasy.gitbooks.io&quot;</code></pre>

<h3 id="2-3-14-shell指令"><a href="#2-3-14-shell指令" class="headerlink" title="2.3.14 shell指令"></a>2.3.14 shell指令</h3><p><code>SHELL</code> 指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell程序，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code></p>
<h3 id="2-3-15-参考文档"><a href="#2-3-15-参考文档" class="headerlink" title="2.3.15 参考文档"></a>2.3.15 参考文档</h3><ul>
<li><p><code>Dockerfie</code> 官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
</li>
<li><p><code>Dockerfile</code> 最佳实践文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p>
</li>
<li><p><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a target="_blank" rel="noopener" href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></p>
</li>
</ul>
<h2 id="2-4-Dockerfile-多阶段构建"><a href="#2-4-Dockerfile-多阶段构建" class="headerlink" title="2.4 Dockerfile 多阶段构建"></a>2.4 Dockerfile 多阶段构建</h2><ul>
<li>以前是全部放到一个Dockerfile里面，将编译，测试，打包放在一起，可能导致镜像层次过多，源代码泄露风险</li>
<li>分多个Dockerfile编写，然后指定文件逐个构建</li>
<li>使用多阶段构建</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM golang:alpine as builder
RUN apk --no-cache add git
WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;
RUN go get -d -v github.com&#x2F;go-sql-driver&#x2F;mysql
COPY app.go .
RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .
FROM alpine:latest as prod
RUN apk --no-cache add ca-certificates
WORKDIR &#x2F;root&#x2F;
COPY --from&#x3D;0 &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;app .
CMD [&quot;.&#x2F;app&quot;]
&#x2F;&#x2F; 构建镜像  docker build -t go&#x2F;helloworld:3 .</code></pre>

<pre><code>- 我们可以使用 `as` 来为某一阶段命名，例如`FROM golang:alpine as builder`
- 例如当我们只想构建 `builder` 阶段的镜像时，增加 `--target=builder` 参数即可 `$ docker build --target builder -t username/imagename:tag .`
</code></pre>
<ul>
<li>构建时从其他镜像复制文件<br>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件<br><code>$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code></li>
</ul>
<h2 id="实战多阶段构建镜像"><a href="#实战多阶段构建镜像" class="headerlink" title="实战多阶段构建镜像"></a>实战多阶段构建镜像</h2><p><a target="_blank" rel="noopener" href="https://github.com/nigelpoulton/dotnet-docker-samples.git">实战地址</a>  </p>
<ul>
<li><p>生产环境多阶段构建需要保持镜像精简，可以通过&amp;&amp;精简镜像层</p>
</li>
<li><p>run指令执行完会残留构建镜像完后的文件，直接上生产及其不妥，docker提供了多种方式解决这个问题，重瞳方式叫<code>建造者模式</code></p>
<ol>
<li>构建<code>Dockerfile.dev</code>文件</li>
<li>在此基础之上构建新一层镜像</li>
<li>编写Dockerfile.prod，把上一步容器的相关代码和文件复制过来</li>
</ol>
</li>
<li><p>多阶段构建方式<br>分析Dockerfile文件</p>
</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM mcr.microsoft.com&#x2F;dotnet&#x2F;sdk:6.0 AS build
WORKDIR &#x2F;source

# copy csproj and restore as distinct layers
COPY *.sln .
COPY aspnetapp&#x2F;*.csproj .&#x2F;aspnetapp&#x2F;
RUN dotnet restore

# copy everything else and build app
COPY aspnetapp&#x2F;. .&#x2F;aspnetapp&#x2F;
WORKDIR &#x2F;source&#x2F;aspnetapp
RUN dotnet publish -c release -o &#x2F;app --no-restore

# final stage&#x2F;image
FROM mcr.microsoft.com&#x2F;dotnet&#x2F;aspnet:6.0
WORKDIR &#x2F;app
COPY --from&#x3D;build &#x2F;app .&#x2F;
ENTRYPOINT [&quot;dotnet&quot;, &quot;aspnetapp.dll&quot;]</code></pre>

<p>首先注意到，<code>Dockerfile</code>有三个<code>FROM</code>指令。每一个<code>FROM</code>指令构成一个单独的<strong>构建阶段</strong>  </p>
<ol>
<li><p>阶段<code>0</code>：<code>build-env</code><br> <code>build-env</code>阶段拉取了<code>aspnetcore-build:2.0</code>作为基础镜像，然后设置了工作目录，复制一些应用代码，接着执行两个<code>RUN</code>指令，生成<code>1</code>个镜像层并显著得到一个比原镜像大得多的镜像，包含许多构建工具和应用代码</p>
</li>
<li><p>阶段<code>1</code>：<code>microsoft/aspnetcore:2.0</code><br> <code>aspnetcore:2.0</code>阶段拉取了<code>aspnetcore:2.0</code>作为基础镜像，设置工作目录，然后执行<code>COPY --from</code>指令从<code>build-env</code>阶段生成的镜像中复制一些应用代码过来，最后执行<code>ENTRYPOINT</code>指令指定容器的默认应用程序</p>
</li>
</ol>
<p>上述构建过程的重点在于<code>COPY --from</code>指令<strong>表示从之前的构建阶段复制生产环境相关的应用代码，而不会复制生产环境不需要的构件</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7053651f6091402c9c8ff10c99d1ae34~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-5-构建多种系统架构支持的docker镜像"><a href="#2-5-构建多种系统架构支持的docker镜像" class="headerlink" title="2.5 构建多种系统架构支持的docker镜像"></a>2.5 构建多种系统架构支持的docker镜像</h2><p><code>$ docker manifest inspect golang:alpine</code><br>查看manifest列表</p>
<ul>
<li>创建manifest 列表</li>
<li>设置manifest列表</li>
<li>查看manifest列表</li>
<li>推送manifest列表</li>
<li>测试</li>
<li><a target="_blank" rel="noopener" href="https://www.docker.com/blog/multi-arch-all-the-things/">官方博客</a></li>
</ul>
<h2 id="2-6-其它制作镜像的方式"><a href="#2-6-其它制作镜像的方式" class="headerlink" title="2.6 其它制作镜像的方式"></a>2.6 其它制作镜像的方式</h2><ul>
<li>从 rootfs 压缩包导入</li>
</ul>
<pre class="language-docker" data-language="docker"><code class="language-docker">$ docker import \
    http:&#x2F;&#x2F;download.openvz.org&#x2F;template&#x2F;precreated&#x2F;ubuntu-16.04-x86_64.tar.gz \
    openvz&#x2F;ubuntu:16.04

Downloading from http:&#x2F;&#x2F;download.openvz.org&#x2F;template&#x2F;precreated&#x2F;ubuntu-16.04-x86_64.tar.gz
sha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213
&#x2F;&#x2F; 从web远程下载ubuntu然后制作镜像</code></pre>

<ul>
<li>Docker 镜像的导入和导出 <code>docker save</code> 和 <code>docker load</code> ，目前已经不推荐</li>
</ul>
<h1 id="3-操作容器"><a href="#3-操作容器" class="headerlink" title="3. 操作容器"></a>3. 操作容器</h1><h2 id="3-1-容器基本操作"><a href="#3-1-容器基本操作" class="headerlink" title="3.1 容器基本操作"></a>3.1 容器基本操作</h2><p>两种启动容器方式，从镜像到容器，启动停止的容器</p>
<ul>
<li>新建容器</li>
</ul>
<pre class="language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">$ docker run -dit --name new_name ubuntu:18.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;
Hello world</code></pre>

<p>-itd 意思是指容器绑定标准输入输出，然后绑定个伪终端，然后以守护态运行<br>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令</p>
<ul>
<li>stop&#x2F;restart 容器<br>docker container ls &#x2F;&#x2F;查看容器<br>docker container restart<br>docker container stop&#x2F;start</li>
<li>进入容器<br><code>docker attach</code> 进入容器<br><code>docker exec -it</code> 进入容器</li>
<li>导出&#x2F;导入容器<br><code>docker export 7691a814370e &gt; ubuntu.tar</code><br><code>docker import - test/ubuntu:v1.0</code><br><code>docker import url</code></li>
<li>删除容器<br><code>docker container rm trusting_newton</code><br><code>docker container prune</code> 清理所有种植状态的容器</li>
</ul>
<h1 id="4-访问仓库"><a href="#4-访问仓库" class="headerlink" title="4. 访问仓库"></a>4. 访问仓库</h1><ol>
<li>docker hub</li>
<li>私有仓库</li>
<li>私有仓库高级配置</li>
<li>nexus3</li>
</ol>
<h1 id="5-数据管理"><a href="#5-数据管理" class="headerlink" title="5. 数据管理"></a>5. 数据管理</h1><h2 id="5-1-数据卷"><a href="#5-1-数据卷" class="headerlink" title="5.1 数据卷"></a>5.1 数据卷</h2><p>对数据卷的使用有点像linux的mount，镜像中被挂载的目录文件会复制到宿主机的目录上，独立于容器</p>
<ol>
<li>创建一个数据卷</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker volume create my-vol  创建一个数据卷  
docker volume ls  列举数据卷  
docker volume inspect my_vol 查看某一个数据卷  </code></pre>

<ol start="2">
<li>启动一个挂在了数据卷的容器</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker run -d -P \
    --name web \
    # -v my-vol:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \
    --mount source&#x3D;my-vol,target&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \
    nginx:alpine
&#x2F;&#x2F;使用my_vol数据卷，映射到&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</code></pre>

<ol start="3">
<li>查看数据卷具体信息</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker inspect web &#x2F;&#x2F;数据卷信息在Mounts key下
....
&quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;my-vol&#x2F;_data&quot; &#x2F;&#x2F;默认位置</code></pre>

<p>4.删除一个数据卷</p>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker volume rm my-vol
docker volume prune &#x2F;&#x2F;删除无主的数据卷</code></pre>

<ul>
<li>数据卷可以在容器间共用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷默认会一直存在，即使容器被输出</li>
</ul>
<h2 id="5-2-挂载主机目录"><a href="#5-2-挂载主机目录" class="headerlink" title="5.2 挂载主机目录"></a>5.2 挂载主机目录</h2><ol>
<li>挂载目录到容器目录</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">$ docker run -d -P \
    --name web \
    # -v &#x2F;src&#x2F;webapp:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \
    --mount type&#x3D;bind,source&#x3D;&#x2F;src&#x2F;webapp,target&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html, readonly \
    nginx:alpine</code></pre>

<p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p>
<ul>
<li>目录与容器目录绑定，容器写进文件，就会落盘到宿主机上  </li>
<li>目前如果source不存在就会报错  </li>
<li>宿主机目录也可以指定readonly</li>
</ul>
<ol start="2">
<li>挂载宿主机文件到容器文件中<br>source&#x3D;  ,target&#x3D; 关键字处直接替换成文件</li>
</ol>
<h1 id="6-网络"><a href="#6-网络" class="headerlink" title="6. 网络"></a>6. 网络</h1><h2 id="6-1-端口映射"><a href="#6-1-端口映射" class="headerlink" title="6.1 端口映射"></a>6.1 端口映射</h2><p>-P 会随即映射<br>-p 特定端口映,可使用多次指定多个端口</p>
<ul>
<li><code>$ docker run -d -p 80:80 nginx:alpine</code> hostport:containerport  </li>
<li><code>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</code> 指定地址绑定，容器有自己的网络和地址</li>
<li><code>$ docker run -d -p 127.0.0.1::80/udp nginx:alpine</code> 容器80端口随机映射到主机,并指定传输协议</li>
</ul>
<h2 id="6-2-容器互联"><a href="#6-2-容器互联" class="headerlink" title="6.2 容器互联"></a>6.2 容器互联</h2><ol>
<li>新建网络</li>
</ol>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker network create -d bridge my-net</code></pre>

<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href="/docker_practice/swarm_mode">Swarm mode</a>，在本小节中你可以忽略它<br>2. 容器互联</p>
<pre class="language-docker" data-language="docker"><code class="language-docker">docker run -it --rm --name busybox1 --network my-net busybox sh
docker run -it --rm --name busybox2 --network my-net busybox sh
</code></pre>

<p>可以直接ping另外的容器</p>
<ul>
<li>Docker Compose 可以考虑使用</li>
</ul>
<h2 id="6-3-配置DNS"><a href="#6-3-配置DNS" class="headerlink" title="6.3. 配置DNS"></a>6.3. 配置DNS</h2><p>TBC</p>
<h1 id="7-高级网络配置"><a href="#7-高级网络配置" class="headerlink" title="7. 高级网络配置"></a>7. 高级网络配置</h1><h1 id="8-Docker-Buildx"><a href="#8-Docker-Buildx" class="headerlink" title="8. Docker Buildx"></a>8. Docker Buildx</h1><h1 id="9-Docker-Compose"><a href="#9-Docker-Compose" class="headerlink" title="9. Docker Compose"></a>9. Docker Compose</h1><p>结合实战操纵理解</p>
<h2 id="9-1-搭建一个web应用"><a href="#9-1-搭建一个web应用" class="headerlink" title="9.1 搭建一个web应用"></a>9.1 搭建一个web应用</h2><ul>
<li>服务：运行多个相同镜像的实例</li>
<li>项目：一组应用容器组成的一个完整单元<br><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">docker compose</a></li>
</ul>
<h1 id="10-安全"><a href="#10-安全" class="headerlink" title="10. 安全"></a>10. 安全</h1><h1 id="11-底层实现"><a href="#11-底层实现" class="headerlink" title="11. 底层实现"></a>11. 底层实现</h1><h1 id="12-Kubernetes"><a href="#12-Kubernetes" class="headerlink" title="12. Kubernetes"></a>12. Kubernetes</h1><h1 id="13-实战案例-CI-x2F-CD"><a href="#13-实战案例-CI-x2F-CD" class="headerlink" title="13. 实战案例 - CI&#x2F;CD"></a>13. 实战案例 - CI&#x2F;CD</h1>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/%E5%A5%94%E8%B7%91%E5%90%A7ansible/"
                            aria-label=": 奔跑吧ansible"
                        >
                            奔跑吧ansible
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T20:45:28+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/CICD/">CICD</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <!-- # 3. 第三章 inventory:描述你的服务器
ansible管理的多台主机文件叫inventory

 -->

<h1 id="3-第三章-inventory-描述你的服务器"><a href="#3-第三章-inventory-描述你的服务器" class="headerlink" title="3. 第三章 inventory:描述你的服务器"></a>3. 第三章 inventory:描述你的服务器</h1><p>ansible管理的多台主机文件叫inventory</p>
<h2 id="3-1-inventory基本参数含义"><a href="#3-1-inventory基本参数含义" class="headerlink" title="3.1 inventory基本参数含义"></a>3.1 inventory基本参数含义</h2><p>inventory文件通常是.ini格式的，常用inventory参数如下</p>
<pre class="language-txt" data-language="txt"><code class="language-txt">ansible_ssh_host     #用于指定被管理的主机的真实IP和将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.
ansible_ssh_port     #用于指定连接到被管理主机的ssh端口号，默认是22，如果不是默认的端口号,通过此变量设置.
ansible_ssh_user     #ssh连接时默认使用的用户名
ansible_ssh_pass     #ssh连接时的密码，(这种方式并不安全,我们强烈建议使用 --ask-pass（交互密码）或 SSH 密钥)
ansible_sudo_pass     #使用sudo连接用户时的密码，(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)
ansible_sudo_exec     #如果sudo命令不在默认路径，需要指定sudo命令路径(适用于1.8及以上版本)
ansible_ssh_private_key_file     #秘钥文件路径，秘钥文件如果不想使用ssh-agent管理时可以使用此选项
ansible_shell_type     #目标系统的shell的类型，默认sh，可设置为 'csh' 或 'fish'.
ansible_connection     #SSH 连接的类型： local , ssh , paramiko，在 ansible 1.2 之前默认是 paramiko ，后来智能选择，优先使用基于 ControlPersist 的 ssh （支持的前提）
ansible_python_interpreter     #用来指定python解释器的路径，默认为/usr/bin/python 同样可以指定ruby 、perl 的路径
ansible_*_interpreter     #其他解释器路径，用法与ansible_python_interpreter类似，这里"*"可以是ruby或才perl等其他语言
以上是2.0版本之前的参数，2.0之后有更换，但是向下兼容</code></pre>

<h3 id="3-1-1-主机别名和群组"><a href="#3-1-1-主机别名和群组" class="headerlink" title="3.1.1 主机别名和群组"></a>3.1.1 主机别名和群组</h3><p>inventory支持群组,类似于下面</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml">[webservers]
testserver ansible_port&#x3D;2202

&#x2F;&#x2F;群组变量
[webservers:vars] 
ansible_user &#x3D; vagrant
ansible_host &#x3D; 127.0.0.1
ansible_private_key_file &#x3D; .vagrant&#x2F;machines&#x2F;default&#x2F;virtualbox&#x2F;private_key

[web]
web[1:20].example.com
</code></pre>

<h3 id="3-1-2-主机和群组变量，在inventory各自文件中"><a href="#3-1-2-主机和群组变量，在inventory各自文件中" class="headerlink" title="3.1.2 主机和群组变量，在inventory各自文件中"></a>3.1.2 主机和群组变量，在inventory各自文件中</h3><p>在inventory目录下我们根据环境，将不同阶段的变量放进文件，<code>group_vars</code>文件夹下文件名要与<code>hosts</code>文件中的群组保持一致</p>
<pre class="language-text" data-language="text"><code class="language-text">group_vars
|----production
|      |- db_primary_host: rhodeisland.example.com
|      |- db_replica_host: virginia.example.com
|      |- db_name: widget_production
|      |- db_user: widgetuser
|      |- db_password: pFmMxcyD;Fc6)6
|      |- rabbitmq_host: pennsylvania.example.com
|----preprod
|      |- db_primary_host: chicago.example.com
|      |- db_replica_host: amsterdam.example.com
|      |- db_name: widget_staging
|      |- db_user: widgetuser
|      |- db_password: L@4Ryz8cRUXedj
|      |- rabbitmq_host: chicago.example.com</code></pre>

<h3 id="3-1-3-动态inventory脚本接口"><a href="#3-1-3-动态inventory脚本接口" class="headerlink" title="3.1.3 动态inventory脚本接口"></a>3.1.3 动态inventory脚本接口</h3><p>对于用何种语言实现脚本，没有要求，但必须支持传<code>--list</code>和<code>--host=&lt;hostname&gt;</code>参数,同时<code>--list</code>输出的json字符串也有要求。有群组和主机键值对，<code>_meta</code>要保存主机变量</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">.&#x2F;dynamic.py  --list</code></pre>

<p>output</p>
<pre class="language-json" data-language="json"><code class="language-json">
&#123;
    &quot;group1&quot;: &#123;
        &quot;hosts&quot;: [
            &quot;192.168.28.71&quot;,
            &quot;192.168.28.72&quot;
        ],
        &quot;vars&quot;: &#123;
            &quot;ansible_ssh_user&quot;: &quot;johndoe&quot;,
            &quot;ansible_ssh_private_key_file&quot;: &quot;~&#x2F;.ssh&#x2F;mykey&quot;,
            &quot;example_variable&quot;: &quot;value&quot;
        &#125;,
        &quot;children&quot;:[&#39;group2&#39;]
    &#125;,
    &quot;_meta&quot;: &#123;
        &quot;hostvars&quot;: &#123;
            &quot;192.168.28.71&quot;: &#123;
                &quot;host_specific_var&quot;: &quot;bar&quot;
            &#125;,
            &quot;192.168.28.72&quot;: &#123;
                &quot;host_specific_var&quot;: &quot;foo&quot;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">.&#x2F;dynamic.py  --host&#x3D;192.168.28.71</code></pre>

<p>output</p>
<pre class="language-json" data-language="json"><code class="language-json">&#123;
    &quot;host_specific_var&quot;: &quot;foo&quot;
&#125;</code></pre>

<p>ansible支持将动态inventory和动态的inventory放在同一文件夹下(名为inventory的文件夹)通过ansible.cfg的hostfile进行控制，也可以使用<code>-i</code>参数进行控制</p>
<h3 id="3-1-4-add-host模块和group-by模块"><a href="#3-1-4-add-host模块和group-by模块" class="headerlink" title="3.1.4 add_host模块和group_by模块"></a>3.1.4 add_host模块和group_by模块</h3><p><code>add_host</code><br>playbook运行时，主机被创建是无法追加新主机的。使用<code>add_host</code>模块就可以添加新主机并在此次playbook中生效<br><code>group_by</code><br>书上使用group_by 实现了按照OS系统类型进行分组执行(像if语句)，yml中具体参数不知道什么意思.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/%E5%A5%94%E8%B7%91%E5%90%A7ansible/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/06/22/C++_Primer/"
                            aria-label=": C++ Primer Plus"
                        >
                            C++ Primer Plus
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-06-22T01:01:03+08:00">
	
		    Jun 22, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/CPP/">CPP</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#1-%E5%8F%98%E9%87%8F%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">1. 变量及基本类型</a><ul>
<li><a href="#11-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">1.1 基本内置类型</a><ul>
<li><a href="#111-%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B">1.1.1 算术类型</a></li>
<li><a href="#112-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">1.1.2 类型转换</a></li>
<li><a href="#113-%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F">1.1.3 字面常量</a></li>
</ul>
</li>
<li><a href="#12-%E5%8F%98%E9%87%8F">1.2. 变量</a><ul>
<li><a href="#121-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89">1.2.1 变量定义</a></li>
<li><a href="#122-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB">1.2.2 变量声明和定义的关系</a></li>
<li><a href="#123-%E5%90%8D%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">1.2.3 名字的作用域</a></li>
</ul>
</li>
<li><a href="#13-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B">1.3. 复合类型</a></li>
<li><a href="#14-cpp%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8Cconst%E9%99%90%E5%AE%9A%E7%AC%A6">1.4. CPP修饰符和const限定符</a></li>
<li><a href="#15-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B">1.5. 处理类型</a></li>
<li><a href="#16-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.6. 自定义数据结构</a></li>
<li><a href="#17-cpp%E5%AD%98%E5%82%A8%E7%B1%BB%E5%BE%85%E9%87%8D%E6%96%B0%E6%8B%9F%E9%A2%98">1.7 CPP存储类[待重新拟题]</a></li>
</ul>
</li>
<li><a href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E6%95%B0%E7%BB%84">2. 字符串，向量，数组</a><ul>
<li><a href="#21-using%E5%85%B3%E9%94%AE%E5%AD%97">2.1. using关键字</a></li>
<li><a href="#22-string-%E7%B1%BB%E5%9E%8B">2.2. string 类型</a></li>
<li><a href="#23-vector%E7%B1%BB%E5%9E%8B">2.3. vector类型</a></li>
<li><a href="#24-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D">2.4. 迭代器的介绍</a></li>
<li><a href="#25-%E6%95%B0%E7%BB%84">2.5 数组</a><ul>
<li><a href="#251-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84">2.5.1 定义和初始化内置数组</a></li>
<li><a href="#252-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0">2.5.2 访问数组元素</a></li>
<li><a href="#253-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">2.5.3 指针和数组</a></li>
<li><a href="#254-c%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2">2.5.4 C风格字符串</a></li>
<li><a href="#255-%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%85%BC%E5%AE%B9c%E4%BB%A3%E7%A0%81">2.5.5 与旧代码的接口,兼容C代码</a></li>
</ul>
</li>
<li><a href="#26-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">2.6 多维数组</a><ul>
<li><a href="#261-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96">2.6.1 多维数组初始化</a></li>
<li><a href="#262-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8">2.6.2 多维数组的下标引用</a></li>
<li><a href="#263-%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">2.6.3 使用范围for语句处理多维数组</a></li>
<li><a href="#264-%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">2.6.4 指针和多维数组</a></li>
<li><a href="#265-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88">2.6.5 类型别名简化多维数组的指针</a></li>
<li><a href="#266-%E6%9C%AF%E8%AF%AD%E8%A1%A8">2.6.6 术语表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-cpp%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">3. CPP流程控制</a></li>
<li><a href="#4-%E5%87%BD%E6%95%B0">4. 函数</a><ul>
<li><a href="#41-struct%E6%9E%84%E9%80%A0%E5%88%9D%E5%A7%8B%E5%8C%96">4.1. struct构造初始化</a></li>
</ul>
</li>
<li><a href="#5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">5. 面向对象编程</a><ul>
<li><a href="#51-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E7%BB%A7%E6%89%BF">5.1. 继承与多继承</a></li>
<li><a href="#53-%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">5.3. 函数，运算符重载</a></li>
<li><a href="#54-%E5%A4%9A%E6%80%81">5.4. 多态</a></li>
<li><a href="#55-cpp%E6%8E%A5%E5%8F%A3">5.5. CPP接口</a></li>
</ul>
</li>
</ul>
<!-- golang圣经
    将源代码cpp文件编程成二进制程序,并支持C++11

 -->



<h1 id="1-变量及基本类型"><a href="#1-变量及基本类型" class="headerlink" title="1. 变量及基本类型"></a>1. 变量及基本类型</h1><ol>
<li><p><code>g++ -o hello_world  -std=c++11  hello_world.cpp</code><br>将源代码cpp文件编程成二进制程序,并支持C++11</p>
</li>
<li><p>CPP保留字</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>asm</td>
<td>else</td>
<td>new</td>
<td>this &#x2F; 自身地址</td>
</tr>
<tr>
<td>auto</td>
<td>enum</td>
<td>operator</td>
<td>throw</td>
</tr>
<tr>
<td>bool</td>
<td>explicit</td>
<td>private</td>
<td>true &#x2F; 真 &#x2F; 0</td>
</tr>
<tr>
<td>break</td>
<td>export</td>
<td>protected</td>
<td>try</td>
</tr>
<tr>
<td>case</td>
<td>extern</td>
<td>public</td>
<td>typedef &#x2F; 别名定义</td>
</tr>
<tr>
<td>catch</td>
<td>false</td>
<td>register</td>
<td>typeid</td>
</tr>
<tr>
<td>char</td>
<td>float &#x2F;单精度</td>
<td>reinterpret_cast</td>
<td>typename</td>
</tr>
<tr>
<td>class</td>
<td>for</td>
<td>return</td>
<td>union</td>
</tr>
<tr>
<td>const</td>
<td>friend</td>
<td>short</td>
<td>unsigned &#x2F; 无符号</td>
</tr>
<tr>
<td>const_cast</td>
<td>goto</td>
<td>signed &#x2F; 有符号</td>
<td>using &#x2F; 使用命名空间</td>
</tr>
<tr>
<td>continue</td>
<td>if</td>
<td>sizeof</td>
<td>virtual</td>
</tr>
<tr>
<td>default</td>
<td>inline</td>
<td>static</td>
<td>void &#x2F; 空类型</td>
</tr>
<tr>
<td>delete</td>
<td>int</td>
<td>static_cast</td>
<td>volatile</td>
</tr>
<tr>
<td>do</td>
<td>long</td>
<td>struct</td>
<td>wchar_t</td>
</tr>
<tr>
<td>double</td>
<td>mutable</td>
<td>switch &#x2F;</td>
<td>while &#x2F; 循环</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>namespace</td>
<td>template</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>typedef声明</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">typedef short int s_int;
typedef int feet;
feet distance &#x2F;&#x2F;合法声明</code></pre>
</li>
<li><p>枚举类型<br>所谓”枚举”是指将变量的值一一列举出来，变量赋值时候只能是特定的变量才能赋值</p>
<details><summary>枚举类型demo</summary>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">
enum 枚举名&#123; 
    标识符[&#x3D;整型常数], 
    标识符[&#x3D;整型常数], 
... 
    标识符[&#x3D;整型常数]
&#125; 枚举变量;
&#x2F;&#x2F;举例子
enum  color&#123; red , yellow ,blue&#125; c
c &#x3D; blue 
&#x2F;&#x2F;默认情况下，是从0开始初始化
</code></pre>

</details>
</li>
<li><p>三字符组</p>
<p>以前为了表示键盘上没有的字符</p>
<table>
<thead>
<tr>
<th>字符串</th>
<th>转义后的含义</th>
</tr>
</thead>
<tbody><tr>
<td>??&#x3D;</td>
<td>#</td>
</tr>
<tr>
<td>??(</td>
<td>[</td>
</tr>
<tr>
<td>??)</td>
<td>]</td>
</tr>
<tr>
<td>??&#x2F;</td>
<td>\</td>
</tr>
<tr>
<td>??&lt;</td>
<td>{</td>
</tr>
<tr>
<td>??&gt;</td>
<td>}</td>
</tr>
<tr>
<td>??’</td>
<td>^</td>
</tr>
<tr>
<td>??!</td>
<td>|</td>
</tr>
<tr>
<td>??-</td>
<td>～</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="1-1-基本内置类型"><a href="#1-1-基本内置类型" class="headerlink" title="1.1 基本内置类型"></a>1.1 基本内置类型</h2><h3 id="1-1-1-算术类型"><a href="#1-1-1-算术类型" class="headerlink" title="1.1.1 算术类型"></a>1.1.1 算术类型</h3><p><code>整形（布尔/字符）</code>和<code>浮点型</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔类型</td>
<td>4bit</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8bit</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符</td>
<td>16bit</td>
</tr>
<tr>
<td>char16_t</td>
<td>Unicode16</td>
<td>16bit</td>
</tr>
<tr>
<td>char32_t</td>
<td>Unicode32</td>
<td>32bit</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>2个字节,16bit</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4个字节,32bit</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>32bit</td>
</tr>
<tr>
<td>long long</td>
<td>长整型</td>
<td>64bit,8字节</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>32bit,6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>64bit,10位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度</td>
<td>128bit,10位有效数字</td>
</tr>
</tbody></table>
<ol>
<li>一个char应可以存机器基本字符集中任意字符对应的数字值,其他字符集可以用<code>wchar_t</code>-可以扩展字符集任意字符,<code>char16_t</code>,<code>char32_t</code>-他俩则是扩展Unicode字符标准</li>
<li>8比特等于一个字节，四个字节等于一个字符</li>
<li>内置类型的机器实现之address地址,就是一串数字,跟着其存储(8比特)内容</li>
<li>带符号类型和无符号类型<br><code>short</code>,<code>int</code>,<code>long</code> ,<code>long long</code> 都有<code>unsigned</code>类型。<code>char</code>,<code>signed char</code>和<code>unsigned char</code>,虽然表现是三种，但是只有两种，<code>char</code>具体表现为哪种，要看编译器</li>
</ol>
<ul>
<li>如何选择类型<ol>
<li>数值不可能为负时，用无符号类型</li>
<li>超过了int范围，选用long long</li>
<li>因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的。所以如果你需要使用一个不大的整数，应指定是使用unsigned char 还是signed char</li>
<li>float 和double在计算上没差别，但是long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视</li>
</ol>
</li>
</ul>
<h3 id="1-1-2-类型转换"><a href="#1-1-2-类型转换" class="headerlink" title="1.1.2 类型转换"></a>1.1.2 类型转换</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">bool b &#x3D; 42;
int i &#x3D; b; &#x2F;&#x2F; i的值为1
i&#x3D; 3.14 ; &#x2F;&#x2F;i的值为3
double pi &#x3D; i ;&#x2F;&#x2F;pi的值为3.0
unsigned char c &#x3D;-1; &#x2F;&#x2F;假设char占8比特,c的值在255,被转换
signed char c2 &#x3D; 256; &#x2F;&#x2F; 假设char占8比特，c2的值是未定义</code></pre>

<ol>
<li>int -&gt; bool &#x2F;&#x2F; 0是假，1是真  </li>
<li>bool -&gt; int &#x2F;&#x2F; false是0，真是1  </li>
<li>float -&gt; int &#x2F;&#x2F; 只保留整数位  </li>
<li>int -&gt; float &#x2F;&#x2F; 小数位填0  </li>
<li>signed -&gt; unsigned &#x2F;&#x2F;符号位当成数值位转换为十进制<code>1000 0001</code>，反码为<code>1111 1110</code>，补码为<code>1111 1111(signed char)</code>,然后转换为unsigned char  <code>1111 1111</code>,十进制是<code>255</code>，或者<code>-1 + 256 mod 256 = 255</code>,如第六行代码.</li>
<li>当我们赋给<code>符号类型</code>一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据<blockquote>
<p>建议：避免无法预知和依赖于实现环境的行为</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>含有无符号类型的表达式  </p>
<p>  例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样:</p>
  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">unsigned u &#x3D; 10;
int i  &#x3D;-42;
cout&lt;&lt; i + i &lt;&lt; endl ; &#x2F;&#x2F;-84
cout &lt;&lt; u + i &lt;&lt; endl; &#x2F;&#x2F; 输出结果4294967264</code></pre>

  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">for (int i &#x3D; 10 ; i &gt;&#x3D; 0 ; --i )&#123;
    cout&lt;&lt;i &lt;&lt; endl;
&#125;
for (unsigned  i &#x3D; 10 ; i &gt;&#x3D; 0 ; --i )&#123;
    cout&lt;&lt;i &lt;&lt; endl;
&#125;
&#x2F;&#x2F; 永远不会退出循环,其实是没设计好这个for statement,unsigned同样道理</code></pre>

<p>  可以用下面语句带题</p>
  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">unsigned u &#x3D;11;
while (u&gt;0)&#123;
    --u;
    std::cout&lt;&lt; u &lt;&lt; std::endl;
&#125;</code></pre>

<blockquote>
<p>提示:避免<code>signed</code>与<code>unsigned</code>混合运算，会将<code>signed</code>转换为<code>unsigned</code>类型</p>
</blockquote>
</li>
</ul>
<h3 id="1-1-3-字面常量"><a href="#1-1-3-字面常量" class="headerlink" title="1.1.3 字面常量"></a>1.1.3 字面常量</h3><p>例如<code>42</code>就是字面值常量,整型,浮点,字符,字符串字面值</p>
<ul>
<li><p>以0开头的整数代表八进制数  </p>
</li>
<li><p>以0x或0X开头的代表十六进制数  </p>
<table>
<thead>
<tr>
<th>字面值</th>
<th>类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>20</td>
<td>&#x2F;&#x2F; decimal十进制</td>
</tr>
<tr>
<td>024</td>
<td>&#x2F;&#x2F;octal八进制</td>
</tr>
<tr>
<td>0X14</td>
<td>&#x2F;&#x2F; hexadecimal 十六进制</td>
</tr>
<tr>
<td>128u ,128U</td>
<td>&#x2F;&#x2F; unsigned 十进制</td>
</tr>
<tr>
<td>1024UL or 8LU</td>
<td>&#x2F;&#x2F; unsigned long</td>
</tr>
<tr>
<td>1024ULL or 8LLU</td>
<td>&#x2F;&#x2F; unsigned long long</td>
</tr>
<tr>
<td>1L</td>
<td>&#x2F;&#x2F; long 长整形</td>
</tr>
</tbody></table>
</li>
<li><p>如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误  </p>
</li>
<li><p>3.14159,3.14159E0,0.,0e0,.001  </p>
<table>
<thead>
<tr>
<th>字面值</th>
<th>类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>3.14159F &#x3D; 3.14159E0F</td>
<td>&#x2F;&#x2F; float ,科学计数</td>
</tr>
<tr>
<td>.001f &#x3D; 1E-3F</td>
<td>&#x2F;&#x2F; float,科学计数</td>
</tr>
<tr>
<td>12.345L &#x3D; 1.2345E1L</td>
<td>&#x2F;&#x2F; long double 扩展精度 ,科学计数</td>
</tr>
<tr>
<td>0. &#x3D; 0e0</td>
<td>&#x2F;&#x2F; double ,科学计数</td>
</tr>
</tbody></table>
</li>
<li><p>‘a’,’Hello World!’, 字符字面值,字符串字面值</p>
<table>
<thead>
<tr>
<th>字面值</th>
<th>类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>‘a’</td>
<td>&#x2F;&#x2F; char 字符</td>
</tr>
<tr>
<td>L’a’</td>
<td>&#x2F;&#x2F; wchar_t 宽字符</td>
</tr>
<tr>
<td>u’a’</td>
<td>&#x2F;&#x2F; char16_t 宽字符</td>
</tr>
<tr>
<td>U’a’</td>
<td>&#x2F;&#x2F; char32_t 宽字符</td>
</tr>
<tr>
<td>u8”hi!”</td>
<td>&#x2F;&#x2F;utf-8字符串类型,只支持字符串</td>
</tr>
<tr>
<td>nullptr</td>
<td>&#x2F;&#x2F;指针字面值</td>
</tr>
<tr>
<td>‘A’</td>
<td>&#x2F;&#x2F;表示单个字符A</td>
</tr>
<tr>
<td>“A”</td>
<td>&#x2F;&#x2F;表示字符A和空字符两个字符的字符串</td>
</tr>
</tbody></table>
</li>
<li><p>转义序列</p>
<table>
<thead>
<tr>
<th>语义</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表</td>
</tr>
<tr>
<td>\|反斜线</td>
<td></td>
</tr>
<tr>
<td>\r</td>
<td>回车符号</td>
</tr>
<tr>
<td>\t</td>
<td>横向指标符号</td>
</tr>
<tr>
<td>\b</td>
<td>退表符号</td>
</tr>
<tr>
<td>?</td>
<td>问号</td>
</tr>
<tr>
<td>\a</td>
<td>报警符号</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
</tbody></table>
</li>
<li><p>泛化的转义序列  </p>
<ul>
<li>(有需要再重点看)</li>
<li>斜线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。例如，”\1234”表示2个字符，即八进制数123对应的字符以及字符4</li>
<li>\x要用到后面跟着的所有数字，例如，”\x1234”表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定</li>
</ul>
</li>
<li><p>指定字面值的类型<br>给字面值添加前后缀，可以改变其默认类型  </p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>16字符</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>32字符</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8</td>
<td>char,仅适用于字符串</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td>u or U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l or L</td>
<td>long</td>
</tr>
<tr>
<td>ll or LL</td>
<td>long long</td>
</tr>
<tr>
<td>f or F</td>
<td>float</td>
</tr>
<tr>
<td>l or L</td>
<td>long double</td>
</tr>
</tbody></table>
</li>
<li><p>布尔字面值<br><code>bool test = false</code></p>
</li>
</ul>
<h2 id="1-2-变量"><a href="#1-2-变量" class="headerlink" title="1.2. 变量"></a>1.2. 变量</h2><h3 id="1-2-1-变量定义"><a href="#1-2-1-变量定义" class="headerlink" title="1.2.1 变量定义"></a>1.2.1 变量定义</h3><p><code>::</code> : 命名空间符号  </p>
<ul>
<li><p>默认值,初始值,和列表初始化 :  </p>
  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">int units_sold &#x3D; &#123;0&#125;;&#x2F;&#x2F;列表初始化
int units_sold&#123;0&#125;; &#x2F;&#x2F; 列表初始化
int units_sold(0); &#x2F;&#x2F;直接初始化 </code></pre>
</li>
<li><p>全局变量默认值 : 在定义变量阶段如不指定会被指定默认值  </p>
</li>
<li><p>定义在函数体内部的<code>内置类型</code>变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的,如果试图拷贝或以其他形式访问此类值将引发错误.类自行决定初始化方式.绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值.如果一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误</p>
</li>
</ul>
<h3 id="1-2-2-变量声明和定义的关系"><a href="#1-2-2-变量声明和定义的关系" class="headerlink" title="1.2.2 变量声明和定义的关系"></a>1.2.2 变量声明和定义的关系</h3><ul>
<li>CPP支持分离式编译，也就是定义和声明分开  </li>
<li>extern语句如果包含初始值就不再是声明，而变成定义了  </li>
<li>变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明</li>
</ul>
<h3 id="1-2-3-名字的作用域"><a href="#1-2-3-名字的作用域" class="headerlink" title="1.2.3 名字的作用域"></a>1.2.3 名字的作用域</h3><ol>
<li>局部变量，顾名思义，生命周期作用范围只在函数内,局部变量不会对变量进行初始化，全局变量才会初始化  </li>
<li>全局变量，存活于程序整个生命周期,extern允许你在任意地方的声明一个变量或者函数，然后允许再任何地方进行定义。</li>
<li>嵌套的作用域 <details>
 <summary>嵌套的作用域代码demo</summary>

 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;

&#x2F;&#x2F; Program for illustration purposes only: It is bad style for a function
&#x2F;&#x2F; to use a global variable and also define a local variable with the same name

int reused &#x3D; 42;  &#x2F;&#x2F; reused has global scope

int main()
&#123;
    int unique &#x3D; 0; &#x2F;&#x2F; unique has block scope

    &#x2F;&#x2F; output #1: uses global reused; prints 42 0
    std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;   

    int reused &#x3D; 0; &#x2F;&#x2F; new, local object named reused hides global reused

    &#x2F;&#x2F; output #2: uses local reused; prints 0 0
    std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt;  unique &lt;&lt; std::endl;  

    &#x2F;&#x2F; output #3: explicitly requests the global reused; prints 42 0
    std::cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt;  unique &lt;&lt; std::endl;  

        return 0;
&#125;</code></pre>

 </details>  

 output #3则是访问全局<code>reused</code>变量</li>
</ol>
<h2 id="1-3-复合类型"><a href="#1-3-复合类型" class="headerlink" title="1.3. 复合类型"></a>1.3. 复合类型</h2><p> 引用: 及别名</p>
<ol>
<li><code>int &amp;reference2</code> 报错，因为没有初始化，引用必须在定义时初始化.  </li>
<li><code>int &amp;reference3 = reference</code>引用创建引用,reference是对象类型  </li>
<li>将引用赋值给变量就是把引用的对象作为初始值</li>
</ol>
<p> 指针  </p>
<ol>
<li><p>块级作用域指针不被初始化也会拥有不确定值  </p>
</li>
<li><p><code>double *dp, *dp2</code>定义指针,访问无效指针后果无法预计</p>
</li>
<li><p><code>*dp = 0.0</code> 利用指针给对象赋值<br>建议<br>初始化所有定义的指针，切莫将变量直接赋值给指针,而是通过取地址符号,但是0可以直接赋值</p>
</li>
<li><p><code>void *</code>指针,其他任意指针都可以指向空指针,我们无法直接操作空指针</p>
</li>
<li><p>同时定义多个变量<code>int i=1024 , *p=&amp;i, &amp;q = i</code> , <code>int* p</code>合法容易但是产生误导</p>
</li>
<li><p>指向指针的指针,<code>int ival=400,int *p=&amp;ival, **pp=&amp;p</code>,同时,访问对象值,也需要解两次引用  </p>
</li>
<li><p>指向指针的引用  </p>
  <details>
  <summary>指向指针的引用demo</summary>

   <pre class="language-cpp" data-language="cpp"><code class="language-cpp">int i &#x3D; 42;  
int *p;  
int *&amp;r&#x3D;p;  
r&#x3D; &amp;i &#x2F;&#x2F;取i地址，让r指向i,同时p也指向了i  
*r&#x3D;0 &#x2F;&#x2F;给指针引用赋值，p指向的值也变了  </code></pre>

   </details>
</li>
<li><p>指针的类型必须与其所指对象的类型一致，但是有两个例外  </p>
<ul>
<li>第一种例外情况是允许令一个指向常量的指针指向一个非常量对象    <details>
  <summary>
  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">      const double pi &#x3D; 3.14 ;
      double *ptr &#x3D; &amp;pi ; &#x2F;&#x2F; 不可以，不能将变量指针绑定到常量指针

const double*cptr &#x3D; &amp;pi ; &#x2F;&#x2F;合法
      *cptr &#x3D; 42 ; &#x2F;&#x2F; 错误，不能给指向常量的指针赋值
      double dval &#x3D; 3.14 ; &#x2F;&#x2F;
      cptr &#x3D; &amp;dval ; &#x2F;&#x2F; 正确，指针常量不能绑定到普通变量</code></pre>
  </summary>
  </details></li>
</ul>
</li>
</ol>
<h2 id="1-4-CPP修饰符和const限定符"><a href="#1-4-CPP修饰符和const限定符" class="headerlink" title="1.4. CPP修饰符和const限定符"></a>1.4. CPP修饰符和const限定符</h2><ul>
<li><p><code>signed</code>,<code>unsigned</code>, <code>long</code> 和 <code>short</code> 修饰整型和浮点型</p>
  <details>
  <summary>修饰符demo</summary>

  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt; 
using namespace std; 
&#x2F;* * 这个程序演示了有符号整数和无符号整数之间的差别 *&#x2F; 
int main() &#123; short int i; 
    &#x2F;&#x2F; 有符号短整数 
    short unsigned int j;
    &#x2F;&#x2F; 无符号短整数 
    j &#x3D; 50000; i &#x3D; j; 
    cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j; 
    return 0; 
&#125;</code></pre>

  </details>
</li>
<li><p>类型限定符提供了变量的额外信息。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>const</td>
<td><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td>
</tr>
<tr>
<td>volatile</td>
<td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>
</tr>
<tr>
<td>restrict</td>
<td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict.</td>
</tr>
</tbody></table>
<ol>
<li><p>const对象创建之后就不能修改发，所有创建时必须初始化</p>
</li>
<li><p>默认情况下const对象尽在文件内有效，多文件间共享需要使用extern关键字</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;file.cc
extern const int bufsize &#x3D; fn();
&#x2F;&#x2F;file.h
extern const int bufsize;</code></pre>
</li>
<li><p>const的引用<br>常量引用可以绑定对象，但是不能修改被绑定对象的内容<br>也不能用变量绑定常量引用  </p>
</li>
<li><p>指向常量的指针</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">const double pi &#x3D; 3.14;
const double *cptr &#x3D; &amp;pi;  &#x2F;&#x2F;指向常量的指针，指针的值不能变，但是指向的值却是可以变的</code></pre>
</li>
<li><p>常量指针<br>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型，例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">int *const  curErr &#x3D; &amp;errNumb; &#x2F;&#x2F;常量指针
const double pi &#x3D; 3.14;  
const double *const pip &#x3D; &amp;pi;</code></pre>
</li>
<li><p>顶层const和<br> 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响</p>
</li>
<li><p>constexpr和常量表达式<br> <strong>TBC</strong></p>
</li>
</ol>
<h2 id="1-5-处理类型"><a href="#1-5-处理类型" class="headerlink" title="1.5. 处理类型"></a>1.5. 处理类型</h2><ol>
<li><p>typedef意为同义词，新标准中可以使用<code>using SI = Sales_items</code>  </p>
</li>
<li><p>typedef的指针常量，指向常量的指针  </p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">typedef  char *pstring;
const pstring cstr &#x3D; 0; &#x2F;&#x2F;指向常量的指针常量
const pstring *ps ; &#x2F;&#x2F;指针常量</code></pre>
</li>
<li><p><code>auto</code>自动判断类型类型</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">const int ci &#x3D; i , &amp;cr &#x3D; ci;
auto d &#x3D; &amp;i &#x2F;&#x2F;整形指针
auto e &#x3D; &amp;ci; &#x2F;&#x2F; e是指向整型常量的指针
const auto j &#x3D; 0  &#x2F;&#x2F;auto如果想推导出顶层const，需要明确写出  
auto &amp;h&#x3D;42  &#x2F;&#x2F;错误，因为非常量引用无法绑定字面值
const auto &amp;j&#x3D;42  &#x2F;&#x2F;错误，因为非常量引用无法绑定字面值</code></pre>
</li>
<li><p>decltype类型提示符<br> decltype只推断类型，但不使用其值</p>
<ul>
<li>decltype和引用，和const</li>
</ul>
 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">const int ci &#x3D; 0,&amp;cj &#x3D; ci;
decltype(ci) x &#x3D; 0;
decltype(cj) y &#x3D; x ;
decltype(cj) z ; &#x2F;&#x2F;错误，z是一个引用类型，必须初始化
int i &#x3D;42,*p&#x3D;&amp;i,&amp;r &#x3D; i;
decltype(*p) c; &#x2F;&#x2F;错误。必须初始化
decltype((i)) d; &#x2F;&#x2F;错误，双层括号是引用类型，必须初始化
decltype(i) e ; &#x2F;&#x2F;正确，e是一个未初始化的int</code></pre></li>
</ol>
<h2 id="1-6-自定义数据结构"><a href="#1-6-自定义数据结构" class="headerlink" title="1.6. 自定义数据结构"></a>1.6. 自定义数据结构</h2><ol>
<li><p>strcut 关键字</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct Sales_data &#123;&#x2F;* .....  *&#x2F;&#125;;就可以用来定义数据结构
</code></pre>
</li>
<li><p>预处理器概述<br> #define指令把一个名字设定为预处理变量<br> #ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真  </p>
 <details><summary>demo</summary>

  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">#ifndef SALES_DATA_H
#define SALES_DATA_H

#include &lt;string&gt;

struct Sales_data &#123;
        std::string bookNo;
        unsigned units_sold &#x3D; 0;
        double revenue &#x3D; 0.0;
&#125;;
#endif</code></pre>

 </details></li>
</ol>
<h2 id="1-7-CPP存储类-待重新拟题"><a href="#1-7-CPP存储类-待重新拟题" class="headerlink" title="1.7 CPP存储类[待重新拟题]"></a>1.7 CPP存储类[待重新拟题]</h2><ul>
<li>auto<br>CPP17 弃用</li>
<li>register<br>定义 ‘register’存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小, 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中.</li>
<li>static 存储类<br><code>static</code> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</li>
<li>extern<br>扩展全局变量作用域</li>
<li>nutable 存储类</li>
<li>thread_local 存储类<br>变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本</li>
</ul>
<h1 id="2-字符串，向量，数组"><a href="#2-字符串，向量，数组" class="headerlink" title="2. 字符串，向量，数组"></a>2. 字符串，向量，数组</h1><h2 id="2-1-using关键字"><a href="#2-1-using关键字" class="headerlink" title="2.1. using关键字"></a>2.1. using关键字</h2><p>   1.切记不要在header文件中使用using namespace std<br>   2. 每个名字都需要独立的using声明  </p>
<h2 id="2-2-string-类型"><a href="#2-2-string-类型" class="headerlink" title="2.2. string 类型"></a>2.2. string 类型</h2>   <pre class="language-cpp" data-language="cpp"><code class="language-cpp">string s1 &#x3D; &quot;hi ya&quot;; &#x2F;&#x2F;拷贝初始化
string s2(&quot;hi ya&quot;); &#x2F;&#x2F; 直接初始化
string s3(10,&#39;C&#39;); &#x2F;&#x2F;拷贝十个C
std::cin &gt;&gt; s3 &gt;&gt;std::endl;
while (getline(cin,line)) &#x2F;&#x2F;从输入控制设备读入整行</code></pre>

<ul>
<li><p><code>string</code> 对象操作  </p>
 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">
os&lt;&lt;s &#x2F;&#x2F;将s写道os中，并返回os 
is&gt;&gt;s &#x2F;&#x2F;从is中读取字符串赋值给s,字符串以空白分隔，返回is
getline(is,s); &#x2F;&#x2F;
s.empty(); &#x2F;&#x2F;s为空返回true，否则返回false
s.size(); &#x2F;&#x2F;返回s中字符个数,函数返回的是一个无符号整型数
s[n] &#x2F;&#x2F;返回数字索引储存的值
s1+s2 &#x2F;&#x2F;拼接字符串
s1&#x3D;&#x3D;s2;判断字符串是否相等
s1 [&lt;&gt;&#x3D;] s2 &#x2F;&#x2F;按照asic码进行比较</code></pre>

 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;
using std::cout; using std::endl;

#include &lt;string&gt;
using std::string;

int main() 
&#123;

        string s1  &#x3D; &quot;hello, &quot;, s2 &#x3D; &quot;world\n&quot;;
        string s3 &#x3D; s1 + s2;   &#x2F;&#x2F; s3 is hello, world\n
        cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3 &lt;&lt; endl;

        s1 +&#x3D; s2;   &#x2F;&#x2F; equivalent to s1 &#x3D; s1 + s2
        cout &lt;&lt; s1;

        string s4 &#x3D; &quot;hello&quot;, s5 &#x3D; &quot;world&quot;;  &#x2F;&#x2F; no punctuation in s4 or s2
        string s6 &#x3D; s4 + &quot;, &quot; + s5 + &#39;\n&#39;;
        string s7 &#x3D; &quot;hello&quot; + &quot;, &quot; + s5 + &#39;\n&#39;;  &#x2F;&#x2F;不合法
        string s8 &#x3D; &quot;ABC&quot; + &quot;EFG&quot; + &#39;\n&#39;; &#x2F;&#x2F; 不合法操作
        cout &lt;&lt; s4 &lt;&lt; s5 &lt;&lt; &quot;\n&quot; &lt;&lt; s6 &lt;&lt; endl;

        return 0;
&#125;</code></pre>
</li>
<li><p>处理<code>string</code>对象中的字符</p>
 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;用for处理字符
string str(&quot;ABCDEFG&quot;);
for (auto c : str)&#123;
&#x2F;&#x2F;这里的c其实是str中字符的拷贝
    cout&lt;&lt; c &lt;&lt; endl;
&#125;

&#x2F;&#x2F;改变str中的字符值
for (auto &amp;c : str)&#123;
    cout&lt;&lt; c &lt;&lt; endl;
&#125;
&#x2F;&#x2F;下标运算符,返回字符串中的值
if (!s.empty())&#123;
    cout&lt;&lt; s[0] &lt;&lt; endl;
&#125;</code></pre></li>
</ul>
<h2 id="2-3-vector类型"><a href="#2-3-vector类型" class="headerlink" title="2.3. vector类型"></a>2.3. vector类型</h2>  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; ivec; &#x2F;&#x2F;保存int类型
vector&lt;Sales_item&gt; Sales_vec; &#x2F;&#x2F;保存Sales_item变量
vector&lt;vector&lt;string&gt;&gt; file  ; &#x2F;&#x2F;vector存vector类型
&#x2F;&#x2F; 初始化
vector&lt;T&gt; v1
vector&lt;T&gt; v2(v1);&#x2F;&#x2F;v2中包含v1中所有副本
vector&lt;T&gt; v2 &#x3D; v1 &#x2F;&#x2F;等价于 vector&lt;T&gt; v2(v1)
vector&lt;T&gt; v3(n,val);&#x2F;&#x2F;v3包含了n个val元素
vector&lt;T&gt; v4(n)&#x2F;&#x2F;包含了n个执行值初始化的对象
vector&lt;T&gt; v5&#123;a,b,c ...&#125; &#x2F;&#x2F;v5包含了初始值个数的元素，每个元素被赋予相应的初始值，这里还有一点要注意，就是可能会放不同类型的值，但
vector&lt;T&gt; v5&#x3D;&#123;a,b,c ...&#125; &#x2F;&#x2F;等价于vector&lt;T&gt; v5&#123;a,b,c ...&#125;
&#x2F;&#x2F; vector的CRUD
v.empty();&#x2F;&#x2F; 是否为空
v.size(); &#x2F;&#x2F;返回容量，类型std::size_type
v.push_back(t); &#x2F;&#x2F; 添加值
v[n]; &#x2F;&#x2F;访问下标存储的数据
v2&#x3D;v1 ;&#x2F;&#x2F;v1拷贝到v2
v1 &#x3D;&#123;a,b,c.....&#125; &#x2F;&#x2F;重新赋值
v1 &#x3D;&#x3D; v2 ;&#x2F;&#x2F;时候绝对的相等，长度和内容
&lt;&gt;&#x3D; &#x2F;&#x2F;顾名思义按照字典序进行比较
v1!&#x3D;v2;</code></pre>

<ul>
<li>无法访问索引外数据，编译期无法发现，但是运行期就会报错</li>
</ul>
<h2 id="2-4-迭代器的介绍"><a href="#2-4-迭代器的介绍" class="headerlink" title="2.4. 迭代器的介绍"></a>2.4. 迭代器的介绍</h2><p>除了vector之外，标准库还定义了其他容器，string也可以使用迭代器</p>
<p>v.begin()返回第一位元素的指针,v.end()返回最后一个元素，注意end()返回的是空引用</p>
<ul>
<li><p>迭代器运算符包括  </p>
<table>
<thead>
<tr>
<th>符号类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*iter</td>
<td><code>(*it).empty()</code>,返回迭代器所指元素的引用,解引用未定义迭代器都是未定义的行为，可以修改引用真实数据</td>
</tr>
<tr>
<td>item</td>
<td>解引用iter并获取该元素的名为mem的成员变量，等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter &#x2F; –iter &#x2F;[+-] n</td>
<td>进行加减运算</td>
</tr>
<tr>
<td>iter&#x3D;&#x3D;iter2</td>
<td>判断两个迭代器</td>
</tr>
<tr>
<td>iter1 !&#x3D; iter2</td>
<td>判断两个迭代器不等</td>
</tr>
<tr>
<td>&lt;&#x3D; ,&gt;&#x3D;</td>
<td>要求迭代器必须指向同一个容器</td>
</tr>
</tbody></table>
  <details><summary>将字符串小写符转化为大写示例</summary>

  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">string s(&quot;some string&quot;);
if (s.begin() !&#x3D; s.end())&#123;
    auto it &#x3D; s.begin();
    *it &#x3D; toUpper(*it);
&#125;</code></pre>

  </details>

<ol>
<li>迭代器类型支持了以上操作</li>
<li>如果元素是常数则返回const_iterator,不是常数则返回iterator类型</li>
<li>it-&gt;mem和(＊it).mem表达的意思相同</li>
<li>不能在范围for循环中向容器添加元素。<strong>另外一个</strong>限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该 vector对象的迭代器失效</li>
</ol>
</li>
<li><p>将迭代器的移动</p>
  <details><summary>迭代器移动示例</summary>

  <pre class="language-cpp" data-language="cpp"><code class="language-cpp">for (auto it &#x3D; s.begin() ; it !&#x3D; it.end()&amp;&amp; !isUpper(*it); ++it)&#123;
    *it &#x3D; toUpper(*it);
&#125;</code></pre>
</li>
<li><p>泛型编程<br>  泛型编程更像一种高度抽象数据结构的能力</p>
</li>
<li><p>begin()和end()函数<br>  如果元素是常数则返回const_iterator,不是常数则返回iterator类型</p>
  </details></li>
</ul>
<h2 id="2-5-数组"><a href="#2-5-数组" class="headerlink" title="2.5 数组"></a>2.5 数组</h2><p>如果不清楚元素的确切个数,请使用vector,数组的大小确定不变,不能随意向数组中增加元素.因为数组的大小固定,因此对某些特殊的应用来说程序的运行时性能较好,但是相应地也损失了一些灵活性.</p>
<h3 id="2-5-1-定义和初始化内置数组"><a href="#2-5-1-定义和初始化内置数组" class="headerlink" title="2.5.1 定义和初始化内置数组"></a>2.5.1 定义和初始化内置数组</h3><ol>
<li><p>显示初始化数组</p>
 <details>
 <summary>数组初始化示例</summary>
 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">const unsigned sz&#x3D;3; 定义常量
int ia1 &#x3D; &#123;0,1，2&#125;;
int a2[] &#x3D; &#123;0,1,2&#125;;
int a3[5]&#x3D; &#123;0,1,2&#125;;
string a4[] &#x3D; &#123;&quot;hi&quot;,&quot;byte&quot;&#125;;
int a5[2] &#x3D; &#123;0,1,2&#125;  &#x2F;&#x2F;错误，超出容量</code></pre>

 </details></li>
<li><p>字符数组的特殊性</p>
<details>
<summary>字符数组特殊性初始化示例</summary>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">char a1[] &#x3D; &#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;&#125;;
char a2[] &#x3D; &#123;&#39;c&#39;,&#39;+&#39;,&#39;+&#39;,&#39;\0&#39;&#125;; &#x2F;&#x2F;显示胡世华空字符
char a3[] &#x3D; &quot;C++&quot;; &#x2F;&#x2F;自动初始化空字符
const a4[6]  &#x3D; &quot;Daneil&quot;  &#x2F;&#x2F;错误没有空间存放空字符
</code></pre>

</details></li>
<li><p>不允许拷贝赋值</p>
 <details>
 <summary>不允许拷贝赋值示例</summary>

 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">int a[] &#x3D; &#123;0,1,2&#125; &#x2F;&#x2F;含有三个元素的数组
int a2[] &#x3D; a1; &#x2F;&#x2F; 错误: 不允许使用一个数组给另一个数组进行初始化
    a2 &#x3D; a1 &#x2F;&#x2F;错误: 不允许两个数组之间直接赋值计算
 </code></pre>

 </details>
</li>
<li><p>复杂数组声明</p>
 <details>
 <summary>复杂数组声明示例</summary>

 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">int *ptrs[10]  &#x2F;&#x2F; 指向含有10个整型指针的数组
int &amp;refs[10] &#x3D;&#x2F;*?*&#x2F; &#x2F;&#x2F;不存在引用的数组
int (*Parrary)[10] &#x3D; &amp;arr; &#x2F;&#x2F; 指向一个含有是个个整数的数组
int (&amp;arrRef)[10] &#x3D; arr ; &#x2F;&#x2F;arrRef 引用指向一个含有是个整数的数组
int *(&amp;arry)[10] &#x3D; ptrs ; &#x2F;&#x2F; 首先知道arry是一个引用，然后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用</code></pre>

 </details></li>
</ol>
<h3 id="2-5-2-访问数组元素"><a href="#2-5-2-访问数组元素" class="headerlink" title="2.5.2 访问数组元素"></a>2.5.2 访问数组元素</h3><ol>
<li>在使用数组下标的时候，通常将其定义为size_t类型</li>
<li>检查下标的值, CPP要检查数组下标</li>
</ol>
<h3 id="2-5-3-指针和数组"><a href="#2-5-3-指针和数组" class="headerlink" title="2.5.3 指针和数组"></a>2.5.3 指针和数组</h3><ol>
<li><p>通过取地址符号获取地址</p>
 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">string nums &#x3D; &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;&#125;;
string *p &#x3D; &amp;nums[0];  &#x2F;&#x2F;  等价于    string *p2&#x3D;nums;</code></pre>

<p> 其中一层意思就是当使用数组作为<code>auto</code>变量初始值的时候，推断出的是指针而非数组，显然是<code>auto ia2(&amp;ia[0])</code>;但是使用decltype(ia)返回的类型是由10个整数构成的数组</p>
 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">decltype(ia) ia3 &#x3D; &#123;0,1,2,3,4&#125; ;
 ia3 &#x3D;p ;&#x2F;&#x2F;错误:不能把整型指针给数组赋值， 
 ia3[4] &#x3D; i;&#x2F;&#x2F;正确: 把整数i赋值给ia3的一个元素</code></pre>
</li>
<li><p>指针也是迭代器,可以进行整型运算<br> 获取数组的指针后就可以通过<code>加/减</code>计算指针的值,获取指针的最后一个元素地址 <code>&amp;arr[n]</code> ,这个表示arr的长度。针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。两个指针相减的结果的类型是一种名为<code>ptrdiff_t</code>的标准库类型，和<code>size_t</code>一样，<code>ptrdiff_t</code>也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型,两指针不指向头一个对象而进行<code>加/减</code>没有意义</p>
</li>
<li><p>标准库函数begin()和end()</p>
 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">int arr[] &#x3D;&#123;0,1,2,3,4,5&#125;;
int *head &#x3D; begin(arr);
int *tail &#x3D; end(arr);
</code></pre>
</li>
<li><p>指针解引用的运算</p>
 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">int arr[] &#x3D; &#123;0,1,2,3&#125;;
int last &#x3D;*(arr + 3);
last &#x3D; *last + 4; &#x2F;&#x2F;是解引用last然后加4
int k &#x3D; p[-2] &#x2F;&#x2F; 数组下标运算可以处理负值
vector&lt;T&gt; &#x2F;&#x2F;下标运算不能为负值，是无符号类型</code></pre></li>
</ol>
<h3 id="2-5-4-C风格字符串"><a href="#2-5-4-C风格字符串" class="headerlink" title="2.5.4 C风格字符串"></a>2.5.4 C风格字符串</h3><ul>
<li>支持C风格运算函数，比较字符串时候,比较第一个不相同字符的ASCII码值</li>
<li>如果是两个字符串字面量可以用<code>+</code>进行拼接，但是如果是两个指针就需要用函数进行拼接<br>  <code>strcpy(str,ca1)</code> &#x2F;&#x2F;把ca1复制给str,一定要注意str的容量<br>  <code>strcat(str,&quot;&quot;)</code> &#x2F;&#x2F;str是字符串数组<br>  <code>strcat(str,ca2)</code> &#x2F;&#x2F; 将ca2和str继续拼接v</li>
</ul>
<h3 id="2-5-5-与旧代码的接口-兼容C代码"><a href="#2-5-5-与旧代码的接口-兼容C代码" class="headerlink" title="2.5.5 与旧代码的接口,兼容C代码"></a>2.5.5 与旧代码的接口,兼容C代码</h3><ol>
<li>混合string对象和C风格字符串<br> <code>string s(&quot;hello world&quot;);</code>&#x2F;&#x2F;也允许空字符串初始化string字符串，在string对象的加法运算中允许使用以空字符结束的<code>字符数组</code>作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象.<br> 无法用<code>string</code>对象初始化字符数组，除非使用<code>s.c_str()</code>函数<code>const char *str = s.c_str();</code></li>
<li>使用数组初始化vector对象</li>
</ol>
<ul>
<li>不允许使用一个<code>数组</code>给另一个<code>内置类型数组</code>初始化  </li>
<li><code>vector</code>允许给<code>数组</code>初始化  </li>
<li>但是<code>数组</code>却可以给vector 进行初始化,可以是相等元素数量进行赋值，也可以是部分元素数量给<code>vector</code>赋值</li>
</ul>
<p>建议：尽量使用标准库类型而非数组,应该尽量使用string，避免使用C风格的基于数组的字符串</p>
<h2 id="2-6-多维数组"><a href="#2-6-多维数组" class="headerlink" title="2.6 多维数组"></a>2.6 多维数组</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">int ia[10][10] ; &#x2F;&#x2F;多维数组
int ia[10][10] &#x3D; &#123;0&#125; ;&#x2F;&#x2F;将所有元素都初始化为0
&#x2F;&#x2F; 从左往右理解，定义了一个十个元素的数组，每个元素里面又能容纳一个是元素的数组。</code></pre>

<h3 id="2-6-1-多维数组初始化"><a href="#2-6-1-多维数组初始化" class="headerlink" title="2.6.1 多维数组初始化"></a>2.6.1 多维数组初始化</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*----1-----*&#x2F;
&#x2F;&#x2F;二维数组分别初始化
int ia[3][4] &#x3D; &#123;
    &#123;1,2,3,0&#125;,
    &#123;4,5,6,0&#125;,
    &#123;7,8,9,0&#125;
&#125;;

&#x2F;*----2----*&#x2F;
int ia[3][4] &#x3D; &#123;0,1,2,3,4,5,6&#125;;&#x2F;&#x2F;这种初始化方式是等价的，但是并不会把所有元素都初始化

&#x2F;*----3----*&#x2F;
&#x2F;&#x2F;显示缺省
int ia[3][4] &#x3D; &#123;
    &#123;1&#125;,
    &#123;4&#125;,
    &#123;7&#125;
&#125;;
&#x2F;*----4----*&#x2F;
&#x2F;&#x2F; 只是初始化第一行
int ia[3][4] &#x3D; &#123;
  0,1,2,3
&#125;;</code></pre>

<h3 id="2-6-2-多维数组的下标引用"><a href="#2-6-2-多维数组的下标引用" class="headerlink" title="2.6.2 多维数组的下标引用"></a>2.6.2 多维数组的下标引用</h3><p>说白了就是可以通过下标运算符进行取值，如果是三维数组，而用了两个下标运算符那么就会取出<strong>数组</strong></p>
<h3 id="2-6-3-使用范围for语句处理多维数组"><a href="#2-6-3-使用范围for语句处理多维数组" class="headerlink" title="2.6.3 使用范围for语句处理多维数组"></a>2.6.3 使用范围for语句处理多维数组</h3><p>看如下例子,因为程序要改变数组中的值，所以要使用<code>引用</code>进行赋值。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">size_t &#x3D; 0;
for (auto &amp;row : ia)&#123;  &#x2F;&#x2F; row其实是数组的引用
    for(auto &amp;col :row)&#123; &#x2F;&#x2F; col其实是整数的引用
                col &#x3D; cnt;
            ++cnt;
    &#125;
&#125;</code></pre>

<p>而如下例子代码是错的,编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）<br>,转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">for (auto row : ia)&#123; 
    for (auto col :row)&#123;

    &#125;
&#125;</code></pre>

<h3 id="2-6-4-指针和多维数组"><a href="#2-6-4-指针和多维数组" class="headerlink" title="2.6.4 指针和多维数组"></a>2.6.4 指针和多维数组</h3><p>定义数组的时候千万别忘了这是数组的数组,所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针,例如  </p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">int ia[3][4];
int (*p)[4] &#x3D; ia; &#x2F;&#x2F;p 是指向四个整数的数组
int *p[4] ;&#x2F;&#x2F;整形指针数组
p &#x3D; &amp;ia[2] ;&#x2F;&#x2F;p指向ia的尾元素
</code></pre>

<p>在C++11标准中使用<code>auto</code>和<code>decltype</code>就能避免在数组前面加一个指针类型，例子如下  </p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">for (auto p &#x3D; ia ;p!&#x3D;ia+3; ++p)&#123;
    for (auto q &#x3D; *p; q!&#x3D; *p +4 ; ++q)&#123;
        cout &lt;&lt; *q &lt;&lt; &#39;&#39; ;
    &#125;
    cout &lt;&lt; endl;
&#125;
</code></pre>

<p>它首先令指针q指向p当前所在行的第一个元素,然后再一次<code>解引用</code>指向内层的数组的首元素，然后终止条件为<code>+4</code>,当然也可以使用标准函数<code>begin()</code>和<code>end()</code>实现相同的效果</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">for (auto p &#x3D; begin(ia) ; p!&#x3D;end(ia);++ia )&#123;
    for (auto q &#x3D; begin(*p); q!&#x3D;end(*p);++q)&#123;
        cout&lt;&lt; *q &lt;&lt; &#39;&#39; ;
    &#125;
    cout&lt;&lt; endl; 
&#125;
</code></pre>

<h3 id="2-6-5-类型别名简化多维数组的指针"><a href="#2-6-5-类型别名简化多维数组的指针" class="headerlink" title="2.6.5 类型别名简化多维数组的指针"></a>2.6.5 类型别名简化多维数组的指针</h3><p>使用<code>类型别名</code>可以简化工作  </p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">using int_array  &#x3D; int[3]; &#x2F;&#x2F;新标准下的写法
typedef int int[4] ;&#x2F;&#x2F;等价的typedef声明
for (int_array *p &#x3D; ia ; p!&#x3D; ia +3 ; ++p)&#123;
    for( int *q &#x3D; *p ; q!&#x3D; *p +3 ; ++q)&#123;
        cout&lt;&lt; *q &lt;&lt; &#39;&#39; ; 
    &#125;
    cout &lt;&lt; endl ; 
&#125;
</code></pre>
<p>程序将类型“四个整数组成的数组”命名为int_array,用类型名int_array定义外层循环<code>控制变量</code>更加简洁</p>
<h3 id="2-6-6-术语表"><a href="#2-6-6-术语表" class="headerlink" title="2.6.6 术语表"></a>2.6.6 术语表</h3><table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>begin</td>
<td>是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。</td>
</tr>
<tr>
<td>缓冲区溢出（buffer overflow）</td>
<td>一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等</td>
</tr>
<tr>
<td>C风格字符串（C-style string）</td>
<td>以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错</td>
</tr>
<tr>
<td>类模板（class template）</td>
<td>用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个vector对象需要指定元素的类型：<code>vector&lt;int&gt;</code>包含int类型的元素。</td>
</tr>
<tr>
<td>编译器扩展（compiler extension）</td>
<td>某个特定的编译器为C++语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上</td>
</tr>
<tr>
<td>容器（container）</td>
<td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。</td>
</tr>
<tr>
<td>容器（container）</td>
<td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。</td>
</tr>
<tr>
<td>difference_type</td>
<td>由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。</td>
</tr>
<tr>
<td>直接初始化（direct initialization）</td>
<td>不使用赋值号（&#x3D;）的初始化形式</td>
</tr>
<tr>
<td>empty()</td>
<td>是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假。</td>
</tr>
<tr>
<td>end()</td>
<td>是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针。</td>
</tr>
<tr>
<td>getline</td>
<td>在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留。</td>
</tr>
<tr>
<td>索引（index）</td>
<td>是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置。</td>
</tr>
<tr>
<td>实例化（instantiation）</td>
<td>编译器生成一个指定的模板类或函数的过程。</td>
</tr>
<tr>
<td>迭代器（iterator）</td>
<td>是一种类型，用于访问容器中的元素或者在元素之间移动。</td>
</tr>
<tr>
<td>迭代器运算（iterator arithmetic）</td>
<td>是string或vector的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置。</td>
</tr>
<tr>
<td>以空字符结束的字符串（null-terminated string）</td>
<td>是一个字符串，它的最后一个字符后面还跟着一个空字符（’\0’）。</td>
</tr>
<tr>
<td>prtdiff_t</td>
<td>是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。</td>
</tr>
<tr>
<td>push_back</td>
<td>是vector的成员，向vector对象的末尾添加元素。</td>
</tr>
<tr>
<td>范围for语句（range for）</td>
<td>一种控制语句，可以在值的一个特定集合内迭代。</td>
</tr>
<tr>
<td>size</td>
<td>是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type。</td>
</tr>
<tr>
<td>size_t</td>
<td>是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小。</td>
</tr>
<tr>
<td>size_type</td>
<td>是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型。</td>
</tr>
<tr>
<td>string</td>
<td>是一种标准库类型，表示字符的序列。</td>
</tr>
<tr>
<td>using声明（using declaration）</td>
<td>令命名空间中的某个名字可被程序直接使用。using 命名空间 ：： 名字；上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分命名空间：：。</td>
</tr>
<tr>
<td>值初始化（value initialization）</td>
<td>是一种初始化过程。内置类型初始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值</td>
</tr>
<tr>
<td>vector</td>
<td>是一种标准库类型，容纳某指定类型的一组元素。</td>
</tr>
<tr>
<td>++运算符（++ operator）</td>
<td>是迭代器和指针定义的递增运算符。执行“加1”操作使得迭代器指向下一个元素。</td>
</tr>
<tr>
<td>[ ]运算符（[ ] operator）</td>
<td>下标运算符。obj[j]得到容器对象obj中位置j的那个元素。索引从0开始，第一个元素的索引是0，尾元素的索引是obj.size（）-1。下标运算符的返回值是一个对象。如果p是指针、n是整数，则p[n]与＊（p+n）等价。</td>
</tr>
<tr>
<td>-&gt;运算符（-&gt;operator）</td>
<td>箭头运算符，该运算符综合了解引用操作和点操作。a-&gt;b等价于（＊a）.b。</td>
</tr>
<tr>
<td>&lt;&lt;运算符<code>（&lt;&lt;operator）</code></td>
<td>标准库类型string定义的输出运算符，负责输出string对象中的字符。</td>
</tr>
<tr>
<td>&gt;&gt;运算符<code>（&gt;&gt;operator）</code></td>
<td>标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个string对象。</td>
</tr>
<tr>
<td>！运算符（！ operator）</td>
<td>逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假。</td>
</tr>
<tr>
<td>&amp;&amp;运算符（&amp;&amp;operator）</td>
<td>逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="3-CPP流程控制"><a href="#3-CPP流程控制" class="headerlink" title="3. CPP流程控制"></a>3. CPP流程控制</h1><ul>
<li>如果标准输入输出作为<code>if</code>,<code>while</code>条件，读到文件结束符判断假，或者是无效输入</li>
</ul>
<ol>
<li>windows : Ctrl+Z (文件结束符)</li>
<li>linux : Ctrl+D (文件结束符)</li>
</ol>
<h1 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h1><ul>
<li><p>函数的调用</p>
<ul>
<li>传值</li>
<li>传引用</li>
</ul>
</li>
<li><p>参数默认值</p>
</li>
<li><p>Lambda表达式</p>
</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">[](int x, int y) -&gt; int &#123; int z &#x3D; x + y; return z + x; &#125;</code></pre>

<pre class="language-none"><code class="language-none">[]      &#x2F;&#x2F; 沒有定义任何变量。使用未定义变量会引发错误。
[x, &amp;y] &#x2F;&#x2F; x以传值方式传入（默认），y以引用方式传入。
[&amp;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以引用方式加以引用。
[&#x3D;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&amp;, x]  &#x2F;&#x2F; x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[&#x3D;, &amp;z] &#x2F;&#x2F; z显式地以引用方式加以引用。其余变量以传值方式加以引用。</code></pre>

<ul>
<li>引用<br>实际上是已知变量的另一个名字。</li>
</ul>
<pre class="language-none"><code class="language-none">int&amp;  r &#x3D; i;</code></pre>

<ul>
<li>标准IO<br>通过(std::)方式调用标准函数库，或者在函数头写<code>using namespace std</code></li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;
 
int main( )
&#123;
   char name[50];
 
   cout &lt;&lt; &quot;请输入您的名称： &quot;;
   cin &gt;&gt; name;
   cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;
   cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;
   clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;
&#125;</code></pre>

<h2 id="4-1-struct构造初始化"><a href="#4-1-struct构造初始化" class="headerlink" title="4.1. struct构造初始化"></a>4.1. struct构造初始化</h2><ul>
<li>利用自带默认构造函数</li>
<li>参数构造</li>
<li>自定义void init(…..){ … this-&gt;  …}<br>在建立结构体数组时,如果只写了带参数的构造函数将会出现数组无法初始化的错误！！！各位同学要牢记呀！！！</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">
struct node&#123;
 int data;
 string str;
 char x;
 &#x2F;&#x2F;自己写的初始化函数
 void init(int a, string b, char c)&#123;
  this-&gt;data &#x3D; a;
  this-&gt;str &#x3D; b;
  this-&gt;x &#x3D; c;
 &#125;
 node() :x(), str(), data()&#123;&#125;
 node(int a, string b, char c) :x(c), str(b), data(a)&#123;&#125;
&#125;N[10];</code></pre>

<h1 id="5-面向对象编程"><a href="#5-面向对象编程" class="headerlink" title="5. 面向对象编程"></a>5. 面向对象编程</h1><ul>
<li>#include指令使用（&lt;&gt;）导入标准库函数，非标准库用双引号（” “）。</li>
</ul>
<details>
<summary>类示例demo</summary>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;
#include &quot;Books&quot;
using namespace std;
 
class Box
&#123;
   private:
   
   protected:
   
   public:
      char  title[50];
      char  author[50];
      char  subject[100];
      int   book_id;
      double length;   &#x2F;&#x2F; 长度
      double breadth;  &#x2F;&#x2F; 宽度
      double height;   &#x2F;&#x2F; 高度
      &#x2F;&#x2F; 成员函数声明，但是没有实现
      double get(void);
      void set( double len, double bre, double hei );
      
&#125;;
&#x2F;&#x2F; 成员函数定义
double Box::get(void)
&#123;
    return length * breadth * height;
&#125;
 
void Box::set( double len, double bre, double hei)
&#123;
    length &#x3D; len;
    breadth &#x3D; bre;
    height &#x3D; hei;
&#125;
int main( )
&#123;
   Box Box1;        &#x2F;&#x2F; 声明 Box1，类型为 Box
   Box Box2;        &#x2F;&#x2F; 声明 Box2，类型为 Box
   Box Box3;        &#x2F;&#x2F; 声明 Box3，类型为 Box
   double volume &#x3D; 0.0;     &#x2F;&#x2F; 用于存储体积
 
   &#x2F;&#x2F; box 1 详述
   Box1.height &#x3D; 5.0; 
   Box1.length &#x3D; 6.0; 
   Box1.breadth &#x3D; 7.0;
 
   &#x2F;&#x2F; box 2 详述
   Box2.height &#x3D; 10.0;
   Box2.length &#x3D; 12.0;
   Box2.breadth &#x3D; 13.0;
 
   &#x2F;&#x2F; box 1 的体积
   volume &#x3D; Box1.height * Box1.length * Box1.breadth;
   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
 
   &#x2F;&#x2F; box 2 的体积
   volume &#x3D; Box2.height * Box2.length * Box2.breadth;
   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
 
 
   &#x2F;&#x2F; box 3 详述
   Box3.set(16.0, 8.0, 12.0); 
   volume &#x3D; Box3.get(); 
   cout &lt;&lt; &quot;Box3 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
   return 0;
&#125;</code></pre>

</details>

<ul>
<li>CPP支持文件重定向<code>$ addItems &lt;infile &gt;outfile</code> 可直接从文件读数据然后计算</li>
</ul>
<details>
  <summary>文件重定向Sales_item代码</summary>
 <blockcode>

 <pre class="language-cpp" data-language="cpp"><code class="language-cpp">  &#x2F;*
 * This file contains code from &quot;C++ Primer, Fifth Edition&quot;, by Stanley B.
 * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the
 * copyright and warranty notices given in that book:
 * 
 * &quot;Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.&quot;
 * 
 * 
 * &quot;The authors and publisher have taken care in the preparation of this book,
 * but make no expressed or implied warranty of any kind and assume no
 * responsibility for errors or omissions. No liability is assumed for
 * incidental or consequential damages in connection with or arising out of the
 * use of the information or programs contained herein.&quot;
 * 
 * Permission is granted for this code to be used for educational purposes in
 * association with the book, given proper citation if and when posted or
 * reproduced.Any commercial use of this code requires the explicit written
 * permission of the publisher, Addison-Wesley Professional, a division of
 * Pearson Education, Inc. Send your request for permission, stating clearly
 * what code you would like to use, and in what specific way, to the following
 * address: 
 * 
 *     Pearson Education, Inc.
 *     Rights and Permissions Department
 *     One Lake Street
 *     Upper Saddle River, NJ  07458
 *     Fax: (201) 236-3290
*&#x2F; 

&#x2F;* This file defines the Sales_item class used in chapter 1.
 * The code used in this file will be explained in
 * Chapter 7 (Classes) and Chapter 14 (Overloaded Operators)
 * Readers shouldn&#39;t try to understand the code in this file
 * until they have read those chapters.
*&#x2F;

#ifndef SALESITEM_H
&#x2F;&#x2F; we&#39;re here only if SALESITEM_H has not yet been defined 
#define SALESITEM_H

&#x2F;&#x2F; Definition of Sales_item class and related functions goes here
#include &lt;iostream&gt;
#include &lt;string&gt;

class Sales_item &#123;
&#x2F;&#x2F; these declarations are explained section 7.2.1, p. 270 
&#x2F;&#x2F; and in chapter 14, pages 557, 558, 561
friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, Sales_item&amp;);
friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Sales_item&amp;);
friend bool operator&lt;(const Sales_item&amp;, const Sales_item&amp;);
friend bool 
operator&#x3D;&#x3D;(const Sales_item&amp;, const Sales_item&amp;);
public:
    &#x2F;&#x2F; constructors are explained in section 7.1.4, pages 262 - 265
    &#x2F;&#x2F; default constructor needed to initialize members of built-in type
    Sales_item() &#x3D; default;
    Sales_item(const std::string &amp;book): bookNo(book) &#123; &#125;
    Sales_item(std::istream &amp;is) &#123; is &gt;&gt; *this; &#125;
public:
    &#x2F;&#x2F; operations on Sales_item objects
    &#x2F;&#x2F; member binary operator: left-hand operand bound to implicit this pointer
    Sales_item&amp; operator+&#x3D;(const Sales_item&amp;);
    
    &#x2F;&#x2F; operations on Sales_item objects
    std::string isbn() const &#123; return bookNo; &#125;
    double avg_price() const;
&#x2F;&#x2F; private members as before
private:
    std::string bookNo;      &#x2F;&#x2F; implicitly initialized to the empty string
    unsigned units_sold &#x3D; 0; &#x2F;&#x2F; explicitly initialized
    double revenue &#x3D; 0.0;
&#125;;

&#x2F;&#x2F; used in chapter 10
inline
bool compareIsbn(const Sales_item &amp;lhs, const Sales_item &amp;rhs) 
&#123; return lhs.isbn() &#x3D;&#x3D; rhs.isbn(); &#125;

&#x2F;&#x2F; nonmember binary operator: must declare a parameter for each operand
Sales_item operator+(const Sales_item&amp;, const Sales_item&amp;);

inline bool 
operator&#x3D;&#x3D;(const Sales_item &amp;lhs, const Sales_item &amp;rhs)
&#123;
    &#x2F;&#x2F; must be made a friend of Sales_item
    return lhs.units_sold &#x3D;&#x3D; rhs.units_sold &amp;&amp;
           lhs.revenue &#x3D;&#x3D; rhs.revenue &amp;&amp;
           lhs.isbn() &#x3D;&#x3D; rhs.isbn();
&#125;

inline bool 
operator!&#x3D;(const Sales_item &amp;lhs, const Sales_item &amp;rhs)
&#123;
    return !(lhs &#x3D;&#x3D; rhs); &#x2F;&#x2F; !&#x3D; defined in terms of operator&#x3D;&#x3D;
&#125;

&#x2F;&#x2F; assumes that both objects refer to the same ISBN
Sales_item&amp; Sales_item::operator+&#x3D;(const Sales_item&amp; rhs) 
&#123;
    units_sold +&#x3D; rhs.units_sold; 
    revenue +&#x3D; rhs.revenue; 
    return *this;
&#125;

&#x2F;&#x2F; assumes that both objects refer to the same ISBN
Sales_item 
operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs) 
&#123;
    Sales_item ret(lhs);  &#x2F;&#x2F; copy (|lhs|) into a local object that we&#39;ll return
    ret +&#x3D; rhs;           &#x2F;&#x2F; add in the contents of (|rhs|) 
    return ret;           &#x2F;&#x2F; return (|ret|) by value
&#125;

std::istream&amp; 
operator&gt;&gt;(std::istream&amp; in, Sales_item&amp; s)
&#123;
    double price;
    in &gt;&gt; s.bookNo &gt;&gt; s.units_sold &gt;&gt; price;
    &#x2F;&#x2F; check that the inputs succeeded
    if (in)
        s.revenue &#x3D; s.units_sold * price;
    else 
        s &#x3D; Sales_item();  &#x2F;&#x2F; input failed: reset object to default state
    return in;
&#125;

std::ostream&amp; 
operator&lt;&lt;(std::ostream&amp; out, const Sales_item&amp; s)
&#123;
    out &lt;&lt; s.isbn() &lt;&lt; &quot; &quot; &lt;&lt; s.units_sold &lt;&lt; &quot; &quot;
        &lt;&lt; s.revenue &lt;&lt; &quot; &quot; &lt;&lt; s.avg_price();
    return out;
&#125;

double Sales_item::avg_price() const
&#123;
    if (units_sold) 
        return revenue&#x2F;units_sold; 
    else 
        return 0;
&#125;
#endif</code></pre>

 </blockcode>
</details>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;
#include &quot;Sales_item.cc&quot;

 
using namespace std;
int main() 
&#123;
    Sales_item item1, item2;

    std::cin &gt;&gt; item1 &gt;&gt; item2;   &#x2F;&#x2F;read a pair of transactions
    std::cout &lt;&lt; item1 + item2 &lt;&lt; std::endl; &#x2F;&#x2F;print their sum

    return 0;
&#125;</code></pre>

<h2 id="5-1-继承与多继承"><a href="#5-1-继承与多继承" class="headerlink" title="5.1. 继承与多继承"></a>5.1. 继承与多继承</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;
 
&#x2F;&#x2F; 基类
class Shape 
&#123;
   public:
      void setWidth(int w)
      &#123;
         width &#x3D; w;
      &#125;
      void setHeight(int h)
      &#123;
         height &#x3D; h;
      &#125;
   protected:
      int width;
      int height;
&#125;;
 
&#x2F;&#x2F; 派生类, 多继承就是写成 class Rectangle: public Shape, public square &#123; ... &#125;
class Rectangle: public Shape
&#123;
   public:
      int getArea()
      &#123; 
         return (width * height); 
      &#125;
&#125;;
 
int main(void)
&#123;
   Rectangle Rect;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
 
   &#x2F;&#x2F; 输出对象的面积
   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;
 
   return 0;
&#125;</code></pre>

<table>
<thead>
<tr>
<th>访问</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>派生类</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>外部的类</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><strong>公有继承（public）：</strong> 当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong>  当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong> 当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ul>
<h2 id="5-3-函数，运算符重载"><a href="#5-3-函数，运算符重载" class="headerlink" title="5.3. 函数，运算符重载"></a>5.3. 函数，运算符重载</h2><ul>
<li>函数签名不同的叫函数重载</li>
<li>运算符重载</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">类成员函数
Box operator+(const Box&amp;);</code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">类的非成员函数
Box operator+(const Box&amp;, const Box&amp;);
</code></pre>

<h2 id="5-4-多态"><a href="#5-4-多态" class="headerlink" title="5.4. 多态"></a>5.4. 多态</h2><p>如果对象具有继承关系，那么CPP会更具具体的对象类型调用具体的成员函数长度</p>
<h2 id="5-5-CPP接口"><a href="#5-5-CPP接口" class="headerlink" title="5.5. CPP接口"></a>5.5. CPP接口</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Box
&#123;
   public:
      &#x2F;&#x2F; 纯虚函数
      virtual double getVolume() &#x3D; 0;
   private:
      double length;      &#x2F;&#x2F; 长度
      double breadth;     &#x2F;&#x2F; 宽度
      double height;      &#x2F;&#x2F; 高度
&#125;;</code></pre>

<p>实现类必须要实现抽象安徽念书(虚函数)</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/06/22/C++_Primer/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/2022/06/page/2/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 3 of 3</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/cover.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                nil
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-oejgoqwxqxfpwex5ev6ukctltwog5vlqaetakgrj0ys9pwba1gtnkqh5ga78.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
