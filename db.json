{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"source/picture/微信图片_20220926005909.jpg","path":"picture/微信图片_20220926005909.jpg","modified":1,"renderable":0},{"_id":"source/picture/linux_命令行与shell脚本/linux_default_variables_1.png","path":"picture/linux_命令行与shell脚本/linux_default_variables_1.png","modified":1,"renderable":0},{"_id":"source/picture/linux_命令行与shell脚本/linux_default_variables.png","path":"picture/linux_命令行与shell脚本/linux_default_variables.png","modified":1,"renderable":0},{"_id":"source/picture/mit6.824/raft_figure_2.png","path":"picture/mit6.824/raft_figure_2.png","modified":1,"renderable":0},{"_id":"source/picture/mit6.824/raft_figure_3.png","path":"picture/mit6.824/raft_figure_3.png","modified":1,"renderable":0},{"_id":"source/picture/mit6.824/raft_figure_1.png","path":"picture/mit6.824/raft_figure_1.png","modified":1,"renderable":0},{"_id":"source/picture/mit6.824/raft_figure_4_5.png","path":"picture/mit6.824/raft_figure_4_5.png","modified":1,"renderable":0},{"_id":"source/picture/mit6.824/raft_figure_6.png","path":"picture/mit6.824/raft_figure_6.png","modified":1,"renderable":0},{"_id":"themes/3-hexo/source/about/index.md","path":"about/index.md","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/gov.png","path":"img/gov.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/titleTip.js","path":"js/titleTip.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","path":"css/fonts/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1}],"Cache":[{"_id":"source/picture/微信图片_20220926005909.jpg","hash":"1196a90dfd2a824f87e1edd40c9665b7b1aae0af","modified":1664122044337},{"_id":"source/_posts/API_design原则.md","hash":"50c2d7baa5de604ee73124626162ab8a0431a3e9","modified":1655906322521},{"_id":"source/_posts/C++_Primer.md","hash":"43abb9b40d35993b345f7fc4e2ba4d8684627d86","modified":1662463422379},{"_id":"source/_posts/SAF_mechanism.md","hash":"4c86c4ba144c74566156db0366017ea3cd2bd0f9","modified":1658843904837},{"_id":"source/_posts/docker从入门到实践.md","hash":"01318e4c2a0999c0e765057a6baf43093e8a0f01","modified":1662463481589},{"_id":"source/_posts/pro_git.md","hash":"ad865b8eea4aa794288d5c928a107d75679ebfa4","modified":1662698471843},{"_id":"source/_posts/奔跑吧ansible.md","hash":"4ce89f95198ec26d128eb4e1b7018dfb16a33c29","modified":1663607888674},{"_id":"source/_posts/数据结构讲义.md","hash":"c522af9da58afa02ab3a6f40538de856bfc97053","modified":1657639737257},{"_id":"source/_posts/算法导论.md","hash":"3319925f5df7805a1dc61e5b959a19817954296b","modified":1655907474871},{"_id":"source/picture/mit6.824/raft_figure_1.png","hash":"8ec107d2a322f4ceaa6a9f252d2778bc61c4f570","modified":1660492969889},{"_id":"source/_posts/MIT6.824/lab2_lock_advice.md","hash":"b38c91bb9f453c6d335890661c3f2353bc297aec","modified":1665103160001},{"_id":"source/_posts/MIT6.824/lab2_raft_paper.md","hash":"f861a4ddb891d18b0a82189a9699ea525db4fea2","modified":1665105949721},{"_id":"source/_posts/MIT6.824/lab2_raft_struct_guide.md","hash":"3026eb575e8efd3cfd60517a4c56684affebbe4e","modified":1665105947401},{"_id":"source/_posts/MIT6.824/lab2_raft_students_guide.md","hash":"b51de35497ea1a7b1ca39966af503ef6697b6aaa","modified":1665105912291},{"_id":"source/_posts/TED/如何提高专注力.md","hash":"08993a04d572fd47e6d6df2ce2097ce0565922d1","modified":1662790678004},{"_id":"source/_posts/TED/如何阅读.md","hash":"b1b9356a38a35d2e2d213b7d268c62560fd2f3fd","modified":1655909784221},{"_id":"source/_posts/archive/Api数据自动入库.md","hash":"40129ff04d9347b4dbcf48dbd7edc6a25c81003b","modified":1661589579759},{"_id":"source/_posts/archive/archive.md","hash":"59a81bf0dc1a2167285f856c7401f4a054f460c5","modified":1663518785321},{"_id":"source/_posts/archive/compact_wsl2.md","hash":"571f6de86b07f9898cb2655711d7dbeba02e6c4d","modified":1665130441218},{"_id":"source/_posts/archive/golang_concurrency_map.md","hash":"fb561979bff5e287f468362f6cb6dc142297c086","modified":1662790737744},{"_id":"source/_posts/archive/remote_github.md","hash":"4e4229c31a919366c1bd94907f3ad264554d8d03","modified":1662721649563},{"_id":"source/_posts/archive/内存高效golang.md","hash":"0442e75cb899755f49511202175991b3d41e608c","modified":1661571759439},{"_id":"source/_posts/archive/费曼:任何伟大的科学成就都源于思想自由.md","hash":"2ff89037bf27d59257d752ad7c8b42cad1dccd71","modified":1664125957265},{"_id":"source/_posts/golang/go标准文档.md","hash":"abce8acbe96ac49b0a6924c739af42bb382cffc3","modified":1665208693173},{"_id":"source/_posts/leetcode/13.罗马数字转整数.md","hash":"3aedc4b832b6f0d311ef5963e61625ee4dc50b70","modified":1656027747365},{"_id":"source/_posts/leetcode/14.最长公共前缀.md","hash":"3b5dcf97319572971fd84d0cee283707e369462f","modified":1656027747365},{"_id":"source/_posts/leetcode/20.有效的括号.md","hash":"966fb897e2a267af4ce258b3d1a6f5003723080a","modified":1656027747365},{"_id":"source/_posts/leetcode/21.合并两个有序链表.md","hash":"f370668e57143ce3a62b91f47788ef6280c2ec48","modified":1656027747365},{"_id":"source/_posts/leetcode/27.移除元素.md","hash":"ab8931c22718dc2cceaee6670db683915cd57b7b","modified":1656027747365},{"_id":"source/_posts/leetcode/28.实现-str-str.md","hash":"368fedce8092425ac9e6b4d486e8c377b84137c6","modified":1656027747365},{"_id":"source/_posts/leetcode/35.搜索插入位置.md","hash":"aecd47c18a10444738a9703a02f16c502f61e025","modified":1656027747365},{"_id":"source/_posts/leetcode/53.最大子数组和.md","hash":"d7f028d04819ccb52db8b3e6af8cdd6dac727c22","modified":1656027747365},{"_id":"source/_posts/leetcode/58.最后一个单词的长度.md","hash":"8e691bf401a0366fe26df2bcc20189df95500ecd","modified":1656027747365},{"_id":"source/_posts/leetcode/66.加一.md","hash":"6887e2d3d6dcee6ffab403f81b1d0dd397b56311","modified":1656027642935},{"_id":"source/_posts/leetcode/67.二进制求和.md","hash":"66ca594aa18973a60c75505f567222ed71bc7ddb","modified":1656027637845},{"_id":"source/_posts/leetcode/69.x-的平方根.md","hash":"e50ac4d1fa4bb5f27a71ff6ede93009bfb9116d6","modified":1656027630075},{"_id":"source/_posts/leetcode/70.爬楼梯.md","hash":"c7a47234eb5f5aff7de771740e5a3065d2715e24","modified":1656027624265},{"_id":"source/_posts/leetcode/83.删除排序链表中的重复元素.md","hash":"2ae2081a04ce4c0111e96347d9d62af5f1374bd8","modified":1656027619925},{"_id":"source/_posts/leetcode/88.合并两个有序数组.md","hash":"03a263ffdade66939955551eb8aff04eb57a3a41","modified":1656027614565},{"_id":"source/_posts/leetcode/9.回文数.md","hash":"e802b578f13f5bcd7cee379f6e1cab7302c38ac1","modified":1656027735585},{"_id":"source/_posts/leetcode/94.二叉树的中序遍历.md","hash":"78ce4b49cf53afd1359d306c88a00b9c5ff869a8","modified":1656027609185},{"_id":"source/_posts/oracle/深入浅出_Oracle_DBA_入门_进阶与诊断案例.md","hash":"1d582104942201e7f413d8af29e132e674adbee2","modified":1661939090597},{"_id":"source/_posts/随笔/从0到1_开启商业与未来的秘密.md","hash":"f84c468b0883078cd85a3fefc60b8fbb4d3aa1f0","modified":1655906232891},{"_id":"source/_posts/随笔/多巴胺戒断.md","hash":"de6350c99b66d7f2f127a6c68936ec0150282234","modified":1659626366058},{"_id":"source/_posts/随笔/如何在读研的道路上快速失败.md","hash":"c5672b588186cb4179218afc9732b21fd251bff3","modified":1655906806861},{"_id":"source/_posts/随笔/禅与摩托车维修艺术.md","hash":"cf24e81f190fae5e27ad330b3fac85830978ce7e","modified":1659626119218},{"_id":"source/_posts/Linux命令行與shell腳本編程大全.md","hash":"faa86426a9905784aae223858c9784263bcd4f69","modified":1665151801308},{"_id":"source/picture/mit6.824/raft_figure_3.png","hash":"be0436ed0b288efbdf4a988712faa05b2739ab7e","modified":1661618951245},{"_id":"source/picture/mit6.824/raft_figure_4_5.png","hash":"6ab8d8c47bafb20783e3c9fdea6007029c8539ee","modified":1662200958679},{"_id":"source/picture/mit6.824/raft_figure_6.png","hash":"495397e6ba5704a650cbbcfed5e0f7720c4ff07d","modified":1661071172797},{"_id":"source/_posts/golang/go语言圣经/go语言圣经.md","hash":"b168a85b4abf97524ef692a71483c9ca63f5f255","modified":1665209125693},{"_id":"themes/3-hexo/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1655825785904},{"_id":"themes/3-hexo/.gitignore","hash":"86a50fa08e69cab561892aa5edef24f9081bbde1","modified":1655825785904},{"_id":"themes/3-hexo/LICENSE","hash":"b04140c5f682db2b300428f97bb164fd7f5f18bd","modified":1655825785904},{"_id":"themes/3-hexo/README.md","hash":"d2c42534ceabcb7cd2e58ed994bf7d6f734d1f3b","modified":1655825785904},{"_id":"themes/3-hexo/_config.yml","hash":"066b663a6871b4868c1af746d5153bcf4e4b5f47","modified":1656005334885},{"_id":"themes/3-hexo/languages/en.yml","hash":"53ae29ae1237fc7822df85a6d2f8da6f0078625e","modified":1655825785904},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"d2c6d86fe2ff03e6ee9bbc16dff8efe5b47ac297","modified":1655825785904},{"_id":"themes/3-hexo/layout/index.ejs","hash":"27ea3dac053d501b79bbef5117b4f3aff063d8cd","modified":1655825785904},{"_id":"themes/3-hexo/layout/indexs.md","hash":"c5dfdebcfb2d9d65fd86b53f27eb5acdfe44a4ba","modified":1662791194374},{"_id":"themes/3-hexo/layout/pdf.ejs","hash":"3746b5cef9c65bdc80d0c14d9b8ae1be42844f29","modified":1657125484306},{"_id":"themes/3-hexo/layout/post.ejs","hash":"4abd16c0f5e3f51103d23b73710d695dc7fdc5d2","modified":1655825785904},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"516844c4a0e13d6773f6029849f51c59613b6f69","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"0ebb17d001cb7bb7606c616c380049a2e7124496","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"f66939a8c9d5258948b47842b8b4495e6ec45988","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"bc94eee27701b67d238f328737b578e8270989eb","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"ed479aa9affee3b02a76da06de45a7c40a97a706","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"d11092791e5c140ff81f2aefa0d1b051f403239d","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"a734c26d86da6697003ed27672c1b9b82b216c82","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"d0b84370ca81c3baa02a05613ff040003acd2985","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"8a9e93f9cbe80763264018290da0b14b4bbe8ac5","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"0e7de3e614ca49fe1c7420f233bea22e02641272","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"295f5d00a69c434d63db6e4576535ac5b4c26eac","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"3cf8ba0c6112dfa8089603b8df3e31f70a272715","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1655825785904},{"_id":"themes/3-hexo/source/about/index.md","hash":"95ac7e398ead6ae6acf39094efa4b1fe5efff6f9","modified":1655886641851},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1655825785904},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"59a4abd36cc8ff2107f1fcb3c0fe48d0492c9030","modified":1655825785904},{"_id":"themes/3-hexo/source/css/style.styl","hash":"7090b81f34e26172670c68da6a366ca186523779","modified":1655825785904},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1655825785904},{"_id":"themes/3-hexo/source/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1655825785904},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1655825785904},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1655825785914},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1655825785914},{"_id":"themes/3-hexo/source/js/script.js","hash":"f261fb46d822e9b89296c454a965ff34e4b244f9","modified":1655825785914},{"_id":"themes/3-hexo/source/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1655825785914},{"_id":"themes/3-hexo/source/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1655825785914},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"fa6675230f8c313236604e26926b142f4f418bdd","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fbd3c7d72c8354d700918390c6cbfc0a11408277","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f16442568b43d034faaa8e3507f5ae8da34c7b72","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/comments/livere.ejs","hash":"e820aa16b5ed4e024616b5e2d424925820d43e56","modified":1655825785904},{"_id":"themes/3-hexo/layout/_partial/comments/utteranc.ejs","hash":"c76773b96860940083baf16470b7b80ac098e645","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"2a9b5ffb759be85545a89f6d1194579a800f51a5","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c68d6942ed62f9cce8a9042f5a59055a0ee5441c","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0143711c1221cb4e70a3db866754d79c8a81d253","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"0f80414f4c663c5250c8ff41d01ce6c68450ee33","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"44bdb1fe3e75996f24f2656770d6a376330e898d","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1655825785904},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"0dd8d208081b92e05d6db3361743c520a2816828","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1655825785904},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"553987211d3323a7dfc0b08786b183a3435978c9","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1655825785904},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1655825785904},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"45a6a164e088d70491630bf65628832dbfbb3179","modified":1655878461251},{"_id":"source/picture/linux_命令行与shell脚本/linux_default_variables_1.png","hash":"6996d7f81a98e5c7aed6b843bf8a3e9835887c6c","modified":1662275537573},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1655825785914},{"_id":"source/picture/linux_命令行与shell脚本/linux_default_variables.png","hash":"3dc5d0d1a7b028b7b54217878c2519c44d22ee66","modified":1662275390403},{"_id":"source/picture/mit6.824/raft_figure_2.png","hash":"127945ad5699a0a2cbe514005ffd33322685b4ec","modified":1661618141031},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"26ba4841dcb4b178f730f53a8d1f4a7c89442b4f","modified":1655825785914},{"_id":"public/2022/10/08/golang/go语言圣经/go语言圣经/index.html","hash":"612da702dcaeb91bee12563e439b0583c4b0ad02","modified":1665209132637},{"_id":"public/2022/10/08/golang/go标准文档/index.html","hash":"800a1c5fce2e1c1821b08e5ff0994c2a79ba27b6","modified":1665209132637},{"_id":"public/2022/10/07/archive/compact_wsl2/index.html","hash":"f3848fa0b01a856986fde743a0155c54e26f7d85","modified":1665209132637},{"_id":"public/2022/10/05/MIT6.824/lab2_raft_students_guide/index.html","hash":"436aac18795037d6b47d0d1c0594d02da0a59199","modified":1665209132637},{"_id":"public/2022/10/07/MIT6.824/lab2_raft_struct_guide/index.html","hash":"c8de372771bde1b72fd80328950b1e27641de51d","modified":1665209132637},{"_id":"public/2022/10/05/MIT6.824/lab2_lock_advice/index.html","hash":"2409a71792a6d0580f1a7d0da9b32506734e130d","modified":1665209132637},{"_id":"public/2022/09/26/archive/费曼:任何伟大的科学成就都源于思想自由/index.html","hash":"9c811055088a4ffb542a59d2298bd14e9eade477","modified":1665209132637},{"_id":"public/2022/09/09/archive/golang_concurrency_map/index.html","hash":"13c8b3d7d30aacec5acda788c62469e8ef9e2adc","modified":1665209132637},{"_id":"public/2022/09/09/pro_git/index.html","hash":"2eb67acba7a0c9e44564516a0f1f26a2244fd901","modified":1665209132637},{"_id":"public/2022/08/31/oracle/深入浅出_Oracle_DBA_入门_进阶与诊断案例/index.html","hash":"03c6fb1728d019422bfbfec35df48e02938a95d9","modified":1665209132637},{"_id":"public/2022/08/27/archive/Api数据自动入库/index.html","hash":"699098ebe688b9a3e1105fdb4cb5820df4ff1ef1","modified":1665209132637},{"_id":"public/2022/08/26/archive/内存高效golang/index.html","hash":"b5fc73654dd87309a6b64e4631d3a9b5409559c6","modified":1665209132637},{"_id":"public/2022/08/26/archive/remote_github/index.html","hash":"81075fb558770927135a59349bcd6fa1121ad0ff","modified":1665209132637},{"_id":"public/2022/08/12/MIT6.824/lab2_raft_paper/index.html","hash":"3125c38d91032deef1160599f60b9f646ff45a75","modified":1665209132637},{"_id":"public/2022/08/04/随笔/多巴胺戒断/index.html","hash":"d0b0bbfa9b35d2afdfe5820a9a9b51def3aeadac","modified":1665209132637},{"_id":"public/2022/07/26/SAF_mechanism/index.html","hash":"4b7970184a7afd49c9776ea7e0a63e5417035e8a","modified":1665209132637},{"_id":"public/2022/07/14/随笔/禅与摩托车维修艺术/index.html","hash":"5b3ba3e940d7163804b8f570b35e42a5e3783022","modified":1665209132637},{"_id":"public/2022/07/12/数据结构讲义/index.html","hash":"43ed1efec754784cfe9d62c9ca8b309bf406ae80","modified":1665209132637},{"_id":"public/2022/06/24/archive/archive/index.html","hash":"1ba134698859430609942a21ececcf1c48e8cb0e","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/13.罗马数字转整数/index.html","hash":"d8d536d691feb1cb2c28e2ca89fc326458977e6c","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/14.最长公共前缀/index.html","hash":"7ac94047d88937a7d8c12026746be7a8b28914a1","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/20.有效的括号/index.html","hash":"479420f481097202f079e4bd3c13a29986bdc9a2","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/21.合并两个有序链表/index.html","hash":"07d17d9331104b444d3e2e14b1820bf16735cbbd","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/27.移除元素/index.html","hash":"abf081b9c419359f5348c21db4fdfba6dece3016","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/28.实现-str-str/index.html","hash":"3e749d14bcd2d0e78a4644b5bf77d2a7bd6d6de3","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/35.搜索插入位置/index.html","hash":"4ecb0e44fc8f8b3e2bc48762349a63649ab3a65e","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/53.最大子数组和/index.html","hash":"bf0381fb519009e7c633cfb8b79043876d44a877","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/58.最后一个单词的长度/index.html","hash":"c4a329df53f4c9779dd801676dab97c90ebcd2e9","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/66.加一/index.html","hash":"dd5e605dcc6bed835e33b58771a0e354ae751e9d","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/67.二进制求和/index.html","hash":"f1f819c64fd957b8a5b97465345697c8890c9490","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/69.x-的平方根/index.html","hash":"8e435d493c10e8e202449dccff71c80f11bb0bbc","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/70.爬楼梯/index.html","hash":"dabdf4183c3258735e0f247b916e5e75e4d65d82","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/83.删除排序链表中的重复元素/index.html","hash":"79feb8f27ede225d9714b23da529a4d3719804c4","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/88.合并两个有序数组/index.html","hash":"7507005af329664d4cb53198ebaa52984b65beb1","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/9.回文数/index.html","hash":"7332fef19a5d544b469607fdd8748b0a5c72bf20","modified":1665209132637},{"_id":"public/2022/06/23/leetcode/94.二叉树的中序遍历/index.html","hash":"7c24bca2e33043ded3721499c097484e4f462c52","modified":1665209132637},{"_id":"public/2022/06/22/TED/如何提高专注力/index.html","hash":"d2c0be818548ab0b7af5f543f6e47778d77ef1d5","modified":1665209132637},{"_id":"public/2022/06/22/算法导论/index.html","hash":"e55233217777ba51db257d6a312740503dc8cc05","modified":1665209132637},{"_id":"public/2022/06/22/TED/如何阅读/index.html","hash":"1de5a08d360577862b4cfe5eeedf955c1a4884be","modified":1665209132637},{"_id":"public/2022/06/22/API_design原则/index.html","hash":"739723d469fb8e44c803c5453029e9ed7154fe58","modified":1665209132637},{"_id":"public/2022/06/22/Linux命令行與shell腳本編程大全/index.html","hash":"c876401d393b0f38f5b159cae0a5e21e0e16e558","modified":1665209132637},{"_id":"public/2022/06/22/随笔/如何在读研的道路上快速失败/index.html","hash":"c530e915f9106795ec1e0d0bfe9fa0ca0b4d77aa","modified":1665209132637},{"_id":"public/2022/06/22/随笔/从0到1_开启商业与未来的秘密/index.html","hash":"3cf7c3add718b5c85ed38d6af48f8d0c10098a69","modified":1665209132637},{"_id":"public/2022/06/22/docker从入门到实践/index.html","hash":"cfdfc6d730db7b211c9913e5996f85f1a1a46ed0","modified":1665209132637},{"_id":"public/2022/06/22/奔跑吧ansible/index.html","hash":"63e4de7cdb54cbf599aab7b7980dd876b2f8a572","modified":1665209132637},{"_id":"public/2022/06/22/C++_Primer/index.html","hash":"d595f6a669cd32678b92c58a65924155b3cb5cab","modified":1665209132637},{"_id":"public/archives/index.html","hash":"e0537683fcf576179a6cba36c91d078b2ae8bb59","modified":1665209132637},{"_id":"public/archives/page/2/index.html","hash":"b711d59b616149779efb50dc78de056765bbf594","modified":1665209132637},{"_id":"public/archives/page/3/index.html","hash":"6079ca352f1d6fcaf0a3485d2ecdbb08804e2cc4","modified":1665209132637},{"_id":"public/archives/page/4/index.html","hash":"4988fe5e5babbdeecc1ba57fe571da1da76876c2","modified":1665209132637},{"_id":"public/archives/page/5/index.html","hash":"9f575b7c20af4c4d629aaa27021e349af2811c02","modified":1665209132637},{"_id":"public/archives/2022/index.html","hash":"208e71f5f0e4dd784c19d333a231743e18aa3356","modified":1665209132637},{"_id":"public/archives/2022/page/2/index.html","hash":"e58b4a4f753464a5c9a6d347cce3cf24e350aaa9","modified":1665209132637},{"_id":"public/archives/2022/page/3/index.html","hash":"c31bbb45a317cb90a130c6e5ce258b0d797b077a","modified":1665209132637},{"_id":"public/archives/2022/page/4/index.html","hash":"b6f2343483e36aebc721ead600b21f7ac785b64d","modified":1665209132637},{"_id":"public/archives/2022/page/5/index.html","hash":"e48ccafeb91d543912f3bd74e680c549215dac41","modified":1665209132637},{"_id":"public/archives/2022/06/index.html","hash":"59c9ed2a720c77a12cdb197de7da2af638947f63","modified":1665209132637},{"_id":"public/archives/2022/06/page/2/index.html","hash":"96b55e3fb89809292cd6dd43059e89ccfed6cb13","modified":1665209132637},{"_id":"public/archives/2022/06/page/3/index.html","hash":"d471d9585cc2e4d9616caad96448dced06b37f0c","modified":1665209132637},{"_id":"public/archives/2022/07/index.html","hash":"b490c87619140d75b718e6956eac9f0fe0e665ed","modified":1665209132637},{"_id":"public/archives/2022/08/index.html","hash":"fa68b6d8b7b1b795cc49c1d2e3c56226d27bf816","modified":1665209132637},{"_id":"public/archives/2022/09/index.html","hash":"8ab434ecd2541ed054f4b53b7e7284b14f3a923f","modified":1665209132637},{"_id":"public/archives/2022/10/index.html","hash":"b8b704bf9161f5b5e19d2d51cb8ee7e025876b89","modified":1665209132637},{"_id":"public/categories/WEB-API/index.html","hash":"b7b46c965330550d79be68f4424725f170b18d5b","modified":1665209132637},{"_id":"public/categories/CPP/index.html","hash":"0ef218759d6cb02c0df93185462a8bc283a92ddf","modified":1665209132637},{"_id":"public/categories/分布式/index.html","hash":"989a24f4f54a3299d64918087e74e8525760a739","modified":1665209132637},{"_id":"public/categories/linux/index.html","hash":"e680121bdf152b0330634163683facd1c0f0c3e1","modified":1665209132637},{"_id":"public/categories/CICD/index.html","hash":"c8b79a9c185fd02cfec385fd898cab644d2285a4","modified":1665209132637},{"_id":"public/categories/数据结构/index.html","hash":"a0c7b397b2886e93e3a9597eb13fca295c474cc8","modified":1665209132637},{"_id":"public/categories/算法/index.html","hash":"8213584b4ccd2fa3baa138908b7f61b2608d936b","modified":1665209132637},{"_id":"public/categories/分布式/MIT6-824/index.html","hash":"091b2d7c8790b2ba5ef6eb15f69281c77dfb9df5","modified":1665209132637},{"_id":"public/categories/TED/index.html","hash":"3c17ad72d97a1f21cfa1dc2aed5402a6ecf510cc","modified":1665209132637},{"_id":"public/categories/archive/index.html","hash":"d682f711623230bd733d8a6317ceca0c2daba9d9","modified":1665209132637},{"_id":"public/categories/golang/index.html","hash":"7c25ae83b4efc05287ebf7ac41c5eb67820372aa","modified":1665209132637},{"_id":"public/categories/leetcode/index.html","hash":"c2e355e84cb572273635311750a7da61d4d031b1","modified":1665209132637},{"_id":"public/categories/leetcode/page/2/index.html","hash":"ad6dd3bb956bd37fdac4e8704b6bb2217a45c40b","modified":1665209132637},{"_id":"public/categories/archive/golang/index.html","hash":"bcab45f8152104c84dd449b6586211f79e754e4a","modified":1665209132637},{"_id":"public/categories/Oracle/index.html","hash":"ca8719d52c5a7e5ba4632e747f3d50f3cf2f1719","modified":1665209132637},{"_id":"public/categories/非技术类/index.html","hash":"3f90a7b5658b0f2df0ca618e9a44c632bc3bc007","modified":1665209132637},{"_id":"public/categories/archive/非技术类/index.html","hash":"55123de840b3ec1dc10a9e4d53dac2fec0a409b2","modified":1665209132637},{"_id":"public/categories/leetcode/leetcode题解/index.html","hash":"b4857d3218dd80ff95481e1c5c90f81a62dd0afe","modified":1665209132637},{"_id":"public/categories/leetcode/leetcode题解/page/2/index.html","hash":"b092923308eba986a4ee470e7382d82fc92de396","modified":1665209132637},{"_id":"public/index.html","hash":"a8bb2a6c1b777fff1c62a0f21f30c70fbd80e0c8","modified":1665209132637},{"_id":"public/page/2/index.html","hash":"3e8f922f8cc87bff1fe65a0e81e1e420c355e26d","modified":1665209132637},{"_id":"public/page/3/index.html","hash":"2746b6aa3e29b4ff49c9c3656d87a3a32be73daa","modified":1665209132637},{"_id":"public/page/4/index.html","hash":"0fbbb782e125309987fe862ec87e68ca625821f7","modified":1665209132637},{"_id":"public/page/5/index.html","hash":"dc4089e26e06059ca4309157f676447e7500ae11","modified":1665209132637},{"_id":"public/tags/Docker/index.html","hash":"4a6703cf8e39a2018cb016ae5dd186523198d443","modified":1665209132637},{"_id":"public/tags/ansible/index.html","hash":"ba6bdbcfac18cd53ca9cfc2c26d1f41bdf3c6c6d","modified":1665209132637},{"_id":"public/tags/golang/index.html","hash":"1caa6f1c9fb88584ec35b22efae07e79fefe344d","modified":1665209132637},{"_id":"public/tags/Oracle/index.html","hash":"b1711281cee91070fc7552578a302a84053d9f10","modified":1665209132637},{"_id":"public/tags/非技术类/index.html","hash":"3ebda8aa1b08451786db006b2180185472eff10e","modified":1665209132637},{"_id":"public/picture/微信图片_20220926005909.jpg","hash":"1196a90dfd2a824f87e1edd40c9665b7b1aae0af","modified":1665209132637},{"_id":"public/picture/mit6.824/raft_figure_1.png","hash":"8ec107d2a322f4ceaa6a9f252d2778bc61c4f570","modified":1665209132637},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1665209132637},{"_id":"public/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1665209132637},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1665209132637},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1665209132637},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1665209132637},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1665209132637},{"_id":"public/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1665209132637},{"_id":"public/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1665209132637},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1665209132637},{"_id":"public/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1665209132637},{"_id":"public/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1665209132637},{"_id":"public/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1665209132637},{"_id":"public/picture/mit6.824/raft_figure_3.png","hash":"be0436ed0b288efbdf4a988712faa05b2739ab7e","modified":1665209132637},{"_id":"public/picture/mit6.824/raft_figure_4_5.png","hash":"6ab8d8c47bafb20783e3c9fdea6007029c8539ee","modified":1665209132637},{"_id":"public/picture/mit6.824/raft_figure_6.png","hash":"495397e6ba5704a650cbbcfed5e0f7720c4ff07d","modified":1665209132637},{"_id":"public/img/avatar.jpg","hash":"45a6a164e088d70491630bf65628832dbfbb3179","modified":1665209132637},{"_id":"public/about/index.html","hash":"b63d1559d7aa3bb0582ef88fa87fa75e516a9269","modified":1665209132637},{"_id":"public/css/mobile.css","hash":"5998f6fc27998596beb1e40e4bc3c43be2ed764c","modified":1665209132637},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1665209132637},{"_id":"public/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1665209132637},{"_id":"public/css/hl_theme/atom-light.css","hash":"d31edb9816dae6b01410028bceb91757a962f780","modified":1665209132637},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1665209132637},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1665209132637},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1665209132637},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1665209132637},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1665209132637},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1665209132637},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1665209132637},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1665209132637},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1665209132637},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1665209132637},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1665209132637},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1665209132637},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1665209132637},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1665209132637},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1665209132637},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1665209132637},{"_id":"public/css/style.css","hash":"39c55a665a57cef5d2363ee1358bd713f4fe3288","modified":1665209132637},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1665209132637},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1665209132637},{"_id":"public/js/script.js","hash":"f261fb46d822e9b89296c454a965ff34e4b244f9","modified":1665209132637},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1665209132637},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1665209132637},{"_id":"public/js/gitalk.js","hash":"26ba4841dcb4b178f730f53a8d1f4a7c89442b4f","modified":1665209132637},{"_id":"public/picture/linux_命令行与shell脚本/linux_default_variables_1.png","hash":"6996d7f81a98e5c7aed6b843bf8a3e9835887c6c","modified":1665209132637},{"_id":"public/picture/linux_命令行与shell脚本/linux_default_variables.png","hash":"3dc5d0d1a7b028b7b54217878c2519c44d22ee66","modified":1665209132637},{"_id":"public/picture/mit6.824/raft_figure_2.png","hash":"127945ad5699a0a2cbe514005ffd33322685b4ec","modified":1665209132637}],"Category":[{"name":"WEB API","_id":"cl8ziiu5d0002l1dbholzdfc9"},{"name":"CPP","_id":"cl8ziiu5g0006l1db66ci7e20"},{"name":"分布式","_id":"cl8ziiu5i000bl1db7npccavp"},{"name":"linux","_id":"cl8ziiu5k000gl1dbe6kjehpc"},{"name":"CICD","_id":"cl8ziiu5l000ll1db7t1p3sk2"},{"name":"数据结构","_id":"cl8ziiu5o000ul1dbhhpxa06n"},{"name":"算法","_id":"cl8ziiu5p000zl1dbej7w2tzx"},{"name":"MIT6.824","parent":"cl8ziiu5i000bl1db7npccavp","_id":"cl8ziiu5q0013l1dbcdt295uv"},{"name":"TED","_id":"cl8ziiu5v001ml1db5zuahsic"},{"name":"archive","_id":"cl8ziiu5x001xl1db6ev1bj8d"},{"name":"golang","_id":"cl8ziiu66002ql1db5e4leuva"},{"name":"leetcode","_id":"cl8ziiu67002tl1db9hx30i04"},{"name":"golang","parent":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu6f003fl1db1n288xoj"},{"name":"Oracle","_id":"cl8ziiu6f003gl1db42r76nom"},{"name":"非技术类","_id":"cl8ziiu6f003il1dbflv9bjmj"},{"name":"非技术类","parent":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu6h003sl1db2zht1yxw"},{"name":"leetcode题解","parent":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6h003wl1dbh6cjhvgk"}],"Data":[],"Page":[],"Post":[{"title":"API Design Patterns","_content":"\n## 1. API介绍\n\n### 1.1 什么是API\n\n定义一组与系统交互的界面,是的用户有相对较小的权限操作系统\n\n### 1.2 为什么API重要\n\n不需要像GUI那样很\"cosmetic\"\n\n### 1.3 什么是面向资源API\n\n- RPC-API\nRPC APIs are often designed in terms of interfaces and methods. As more and more of these are added over time, the end result can be an overwhelming and confusing API surface due to the fact that developers must learn each method individually. Obviously this is both time consuming and error-prone.\nRPC的命名没有严格的要求，无状态的，随着RPC的接口增加，接口管理就会面临混乱结果\n- HTTP-API\nThe architectural style of REST was introduced, primarily designed to work well with HTTP/1.1, but also to help tackle this problem. Its core principle is to define named resources that can be manipulated using a small number of methods. The resources and methods are known as nouns and verbs of APIs. With the HTTP protocol, the resource names naturally map to URLs, and methods naturally map to HTTP methods POST, GET, PUT, PATCH, and DELETE. This results in much fewer things to learn, since developers can focus on the resources and their relationship, and assume that they have the same small number of standard methods.\n通常url就是资源的映射，对资源的CRUD就是对应HTTP的PATCH,POST,GET DELETE\n\n> <https://cloud.google.com/apis/design/resources>\n\n### 1.4 什么是\"good\"API\n\n- Operational\n你的API必须得work,高效。\n- Expressive\n你的method必须是具有描述意义的，告诉用户你能做什么\n- Simple\nAnother common position on simplicity takes the old saying about the “common\ncase” (“Make the common case fast”) but focuses instead on usability while leaving\nroom for edge cases. This restatement is to “make the common case awesome and the\nadvanced case possible.” This means that whenever you add something that might\ncomplicate an API for the benefit of an advanced user, it’s best to keep this complica\u0002tion sufficiently hidden from a typical user only interested in the common case. This\nkeeps the more frequent scenarios simple and easy, while still enabling more\nadvanced features for those who want them\n- Predictable\n方法和参数需要见名知意\nAPIs built using well-known, well-defined, clear\n\n### summary\n\n- Interfaces are contracts that define how two systems should interact with one another.\n- APIs are special types of interfaces that define how two computer systems inter\u0002act with one another, coming in many forms, such as downloadable libraries and web APIs.\n- Web APIs are special because they expose functionality over a network, hiding the specific implementation or computational requirements needed for that functionality.\n- Resource-oriented APIs are a way of designing APIs to reduce complexity byrelying on a standard set of actions, called methods, across a limited set of things, called resources.\n- What makes APIs “good” is a bit ambiguous, but generally good APIs are opera\u0002tional, expressive, simple, and predictable.\n- 对数据和系统的抽象会决定你的API -- 李沐\n","source":"_posts/API_design原则.md","raw":"---\ntitle: API Design Patterns\ncategories:\n- WEB API\n\n---\n\n## 1. API介绍\n\n### 1.1 什么是API\n\n定义一组与系统交互的界面,是的用户有相对较小的权限操作系统\n\n### 1.2 为什么API重要\n\n不需要像GUI那样很\"cosmetic\"\n\n### 1.3 什么是面向资源API\n\n- RPC-API\nRPC APIs are often designed in terms of interfaces and methods. As more and more of these are added over time, the end result can be an overwhelming and confusing API surface due to the fact that developers must learn each method individually. Obviously this is both time consuming and error-prone.\nRPC的命名没有严格的要求，无状态的，随着RPC的接口增加，接口管理就会面临混乱结果\n- HTTP-API\nThe architectural style of REST was introduced, primarily designed to work well with HTTP/1.1, but also to help tackle this problem. Its core principle is to define named resources that can be manipulated using a small number of methods. The resources and methods are known as nouns and verbs of APIs. With the HTTP protocol, the resource names naturally map to URLs, and methods naturally map to HTTP methods POST, GET, PUT, PATCH, and DELETE. This results in much fewer things to learn, since developers can focus on the resources and their relationship, and assume that they have the same small number of standard methods.\n通常url就是资源的映射，对资源的CRUD就是对应HTTP的PATCH,POST,GET DELETE\n\n> <https://cloud.google.com/apis/design/resources>\n\n### 1.4 什么是\"good\"API\n\n- Operational\n你的API必须得work,高效。\n- Expressive\n你的method必须是具有描述意义的，告诉用户你能做什么\n- Simple\nAnother common position on simplicity takes the old saying about the “common\ncase” (“Make the common case fast”) but focuses instead on usability while leaving\nroom for edge cases. This restatement is to “make the common case awesome and the\nadvanced case possible.” This means that whenever you add something that might\ncomplicate an API for the benefit of an advanced user, it’s best to keep this complica\u0002tion sufficiently hidden from a typical user only interested in the common case. This\nkeeps the more frequent scenarios simple and easy, while still enabling more\nadvanced features for those who want them\n- Predictable\n方法和参数需要见名知意\nAPIs built using well-known, well-defined, clear\n\n### summary\n\n- Interfaces are contracts that define how two systems should interact with one another.\n- APIs are special types of interfaces that define how two computer systems inter\u0002act with one another, coming in many forms, such as downloadable libraries and web APIs.\n- Web APIs are special because they expose functionality over a network, hiding the specific implementation or computational requirements needed for that functionality.\n- Resource-oriented APIs are a way of designing APIs to reduce complexity byrelying on a standard set of actions, called methods, across a limited set of things, called resources.\n- What makes APIs “good” is a bit ambiguous, but generally good APIs are opera\u0002tional, expressive, simple, and predictable.\n- 对数据和系统的抽象会决定你的API -- 李沐\n","slug":"API_design原则","published":1,"date":"2022-06-22T13:55:02.261Z","updated":"2022-06-22T13:58:42.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu580000l1db0x645daz","content":"<h2 id=\"1-API介绍\"><a href=\"#1-API介绍\" class=\"headerlink\" title=\"1. API介绍\"></a>1. API介绍</h2><h3 id=\"1-1-什么是API\"><a href=\"#1-1-什么是API\" class=\"headerlink\" title=\"1.1 什么是API\"></a>1.1 什么是API</h3><p>定义一组与系统交互的界面,是的用户有相对较小的权限操作系统</p>\n<h3 id=\"1-2-为什么API重要\"><a href=\"#1-2-为什么API重要\" class=\"headerlink\" title=\"1.2 为什么API重要\"></a>1.2 为什么API重要</h3><p>不需要像GUI那样很”cosmetic”</p>\n<h3 id=\"1-3-什么是面向资源API\"><a href=\"#1-3-什么是面向资源API\" class=\"headerlink\" title=\"1.3 什么是面向资源API\"></a>1.3 什么是面向资源API</h3><ul>\n<li>RPC-API<br>RPC APIs are often designed in terms of interfaces and methods. As more and more of these are added over time, the end result can be an overwhelming and confusing API surface due to the fact that developers must learn each method individually. Obviously this is both time consuming and error-prone.<br>RPC的命名没有严格的要求，无状态的，随着RPC的接口增加，接口管理就会面临混乱结果</li>\n<li>HTTP-API<br>The architectural style of REST was introduced, primarily designed to work well with HTTP&#x2F;1.1, but also to help tackle this problem. Its core principle is to define named resources that can be manipulated using a small number of methods. The resources and methods are known as nouns and verbs of APIs. With the HTTP protocol, the resource names naturally map to URLs, and methods naturally map to HTTP methods POST, GET, PUT, PATCH, and DELETE. This results in much fewer things to learn, since developers can focus on the resources and their relationship, and assume that they have the same small number of standard methods.<br>通常url就是资源的映射，对资源的CRUD就是对应HTTP的PATCH,POST,GET DELETE</li>\n</ul>\n<blockquote>\n<p><a href=\"https://cloud.google.com/apis/design/resources\">https://cloud.google.com/apis/design/resources</a></p>\n</blockquote>\n<h3 id=\"1-4-什么是”good”API\"><a href=\"#1-4-什么是”good”API\" class=\"headerlink\" title=\"1.4 什么是”good”API\"></a>1.4 什么是”good”API</h3><ul>\n<li>Operational<br>你的API必须得work,高效。</li>\n<li>Expressive<br>你的method必须是具有描述意义的，告诉用户你能做什么</li>\n<li>Simple<br>Another common position on simplicity takes the old saying about the “common<br>case” (“Make the common case fast”) but focuses instead on usability while leaving<br>room for edge cases. This restatement is to “make the common case awesome and the<br>advanced case possible.” This means that whenever you add something that might<br>complicate an API for the benefit of an advanced user, it’s best to keep this complica\u0002tion sufficiently hidden from a typical user only interested in the common case. This<br>keeps the more frequent scenarios simple and easy, while still enabling more<br>advanced features for those who want them</li>\n<li>Predictable<br>方法和参数需要见名知意<br>APIs built using well-known, well-defined, clear</li>\n</ul>\n<h3 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h3><ul>\n<li>Interfaces are contracts that define how two systems should interact with one another.</li>\n<li>APIs are special types of interfaces that define how two computer systems inter\u0002act with one another, coming in many forms, such as downloadable libraries and web APIs.</li>\n<li>Web APIs are special because they expose functionality over a network, hiding the specific implementation or computational requirements needed for that functionality.</li>\n<li>Resource-oriented APIs are a way of designing APIs to reduce complexity byrelying on a standard set of actions, called methods, across a limited set of things, called resources.</li>\n<li>What makes APIs “good” is a bit ambiguous, but generally good APIs are opera\u0002tional, expressive, simple, and predictable.</li>\n<li>对数据和系统的抽象会决定你的API – 李沐</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-API介绍\"><a href=\"#1-API介绍\" class=\"headerlink\" title=\"1. API介绍\"></a>1. API介绍</h2><h3 id=\"1-1-什么是API\"><a href=\"#1-1-什么是API\" class=\"headerlink\" title=\"1.1 什么是API\"></a>1.1 什么是API</h3><p>定义一组与系统交互的界面,是的用户有相对较小的权限操作系统</p>\n<h3 id=\"1-2-为什么API重要\"><a href=\"#1-2-为什么API重要\" class=\"headerlink\" title=\"1.2 为什么API重要\"></a>1.2 为什么API重要</h3><p>不需要像GUI那样很”cosmetic”</p>\n<h3 id=\"1-3-什么是面向资源API\"><a href=\"#1-3-什么是面向资源API\" class=\"headerlink\" title=\"1.3 什么是面向资源API\"></a>1.3 什么是面向资源API</h3><ul>\n<li>RPC-API<br>RPC APIs are often designed in terms of interfaces and methods. As more and more of these are added over time, the end result can be an overwhelming and confusing API surface due to the fact that developers must learn each method individually. Obviously this is both time consuming and error-prone.<br>RPC的命名没有严格的要求，无状态的，随着RPC的接口增加，接口管理就会面临混乱结果</li>\n<li>HTTP-API<br>The architectural style of REST was introduced, primarily designed to work well with HTTP&#x2F;1.1, but also to help tackle this problem. Its core principle is to define named resources that can be manipulated using a small number of methods. The resources and methods are known as nouns and verbs of APIs. With the HTTP protocol, the resource names naturally map to URLs, and methods naturally map to HTTP methods POST, GET, PUT, PATCH, and DELETE. This results in much fewer things to learn, since developers can focus on the resources and their relationship, and assume that they have the same small number of standard methods.<br>通常url就是资源的映射，对资源的CRUD就是对应HTTP的PATCH,POST,GET DELETE</li>\n</ul>\n<blockquote>\n<p><a href=\"https://cloud.google.com/apis/design/resources\">https://cloud.google.com/apis/design/resources</a></p>\n</blockquote>\n<h3 id=\"1-4-什么是”good”API\"><a href=\"#1-4-什么是”good”API\" class=\"headerlink\" title=\"1.4 什么是”good”API\"></a>1.4 什么是”good”API</h3><ul>\n<li>Operational<br>你的API必须得work,高效。</li>\n<li>Expressive<br>你的method必须是具有描述意义的，告诉用户你能做什么</li>\n<li>Simple<br>Another common position on simplicity takes the old saying about the “common<br>case” (“Make the common case fast”) but focuses instead on usability while leaving<br>room for edge cases. This restatement is to “make the common case awesome and the<br>advanced case possible.” This means that whenever you add something that might<br>complicate an API for the benefit of an advanced user, it’s best to keep this complica\u0002tion sufficiently hidden from a typical user only interested in the common case. This<br>keeps the more frequent scenarios simple and easy, while still enabling more<br>advanced features for those who want them</li>\n<li>Predictable<br>方法和参数需要见名知意<br>APIs built using well-known, well-defined, clear</li>\n</ul>\n<h3 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h3><ul>\n<li>Interfaces are contracts that define how two systems should interact with one another.</li>\n<li>APIs are special types of interfaces that define how two computer systems inter\u0002act with one another, coming in many forms, such as downloadable libraries and web APIs.</li>\n<li>Web APIs are special because they expose functionality over a network, hiding the specific implementation or computational requirements needed for that functionality.</li>\n<li>Resource-oriented APIs are a way of designing APIs to reduce complexity byrelying on a standard set of actions, called methods, across a limited set of things, called resources.</li>\n<li>What makes APIs “good” is a bit ambiguous, but generally good APIs are opera\u0002tional, expressive, simple, and predictable.</li>\n<li>对数据和系统的抽象会决定你的API – 李沐</li>\n</ul>\n"},{"highlight":"monokai","theme":"juejin","title":"C++ Primer Plus","_content":"\n- [1. 变量及基本类型](#1-变量及基本类型)\n  - [1.1 基本内置类型](#11-基本内置类型)\n    - [1.1.1 算术类型](#111-算术类型)\n    - [1.1.2 类型转换](#112-类型转换)\n    - [1.1.3 字面常量](#113-字面常量)\n  - [1.2. 变量](#12-变量)\n    - [1.2.1 变量定义](#121-变量定义)\n    - [1.2.2 变量声明和定义的关系](#122-变量声明和定义的关系)\n    - [1.2.3 名字的作用域](#123-名字的作用域)\n  - [1.3. 复合类型](#13-复合类型)\n  - [1.4. CPP修饰符和const限定符](#14-cpp修饰符和const限定符)\n  - [1.5. 处理类型](#15-处理类型)\n  - [1.6. 自定义数据结构](#16-自定义数据结构)\n  - [1.7 CPP存储类[待重新拟题]](#17-cpp存储类待重新拟题)\n- [2. 字符串，向量，数组](#2-字符串向量数组)\n  - [2.1. using关键字](#21-using关键字)\n  - [2.2. string 类型](#22-string-类型)\n  - [2.3. vector类型](#23-vector类型)\n  - [2.4. 迭代器的介绍](#24-迭代器的介绍)\n  - [2.5 数组](#25-数组)\n    - [2.5.1 定义和初始化内置数组](#251-定义和初始化内置数组)\n    - [2.5.2 访问数组元素](#252-访问数组元素)\n    - [2.5.3 指针和数组](#253-指针和数组)\n    - [2.5.4 C风格字符串](#254-c风格字符串)\n    - [2.5.5 与旧代码的接口,兼容C代码](#255-与旧代码的接口兼容c代码)\n  - [2.6 多维数组](#26-多维数组)\n    - [2.6.1 多维数组初始化](#261-多维数组初始化)\n    - [2.6.2 多维数组的下标引用](#262-多维数组的下标引用)\n    - [2.6.3 使用范围for语句处理多维数组](#263-使用范围for语句处理多维数组)\n    - [2.6.4 指针和多维数组](#264-指针和多维数组)\n    - [2.6.5 类型别名简化多维数组的指针](#265-类型别名简化多维数组的指针)\n    - [2.6.6 术语表](#266-术语表)\n- [3. CPP流程控制](#3-cpp流程控制)\n- [4. 函数](#4-函数)\n  - [4.1. struct构造初始化](#41-struct构造初始化)\n- [5. 面向对象编程](#5-面向对象编程)\n  - [5.1. 继承与多继承](#51-继承与多继承)\n  - [5.3. 函数，运算符重载](#53-函数运算符重载)\n  - [5.4. 多态](#54-多态)\n  - [5.5. CPP接口](#55-cpp接口)\n\n# 1. 变量及基本类型\n\n 1. `g++ -o hello_world  -std=c++11  hello_world.cpp`  \n    将源代码cpp文件编程成二进制程序,并支持C++11\n 2. CPP保留字\n\n    |1|2|3|4|\n    | ------------ | --------- | ---------------- | -------- |\n    |asm          | else      | new              | this / 自身地址     |\n    | auto         | enum      | operator         | throw    |\n    | bool         | explicit  | private          | true / 真 / 0     |\n    | break        | export    | protected        | try      |\n    | case         | extern    | public           | typedef / 别名定义  |\n    | catch        | false     | register         | typeid   |\n    | char         | float /单精度    | reinterpret_cast | typename |\n    | class        | for       | return           | union    |\n    | const        | friend    | short            | unsigned / 无符号 |\n    | const_cast   | goto      | signed / 有符号          | using / 使用命名空间   |\n    | continue     | if        | sizeof           | virtual  |\n    | default      | inline    | static           | void / 空类型    |\n    | delete       | int       | static_cast      | volatile |\n    | do           | long      | struct           | wchar_t  |\n    | double       | mutable   | switch /           | while / 循环   |\n    | dynamic_cast | namespace | template||\n 3. typedef声明\n\n    ```cpp\n    typedef short int s_int;\n    typedef int feet;\n    feet distance //合法声明\n    ```\n\n 4. 枚举类型\n    所谓\"枚举\"是指将变量的值一一列举出来，变量赋值时候只能是特定的变量才能赋值\n\n    <details><summary>枚举类型demo</summary>\n\n    ```cpp\n\n    enum 枚举名{ \n        标识符[=整型常数], \n        标识符[=整型常数], \n    ... \n        标识符[=整型常数]\n    } 枚举变量;\n    //举例子\n    enum  color{ red , yellow ,blue} c\n    c = blue \n    //默认情况下，是从0开始初始化\n\n    ```\n\n    </details>\n\n 5. 三字符组\n\n    以前为了表示键盘上没有的字符\n    |字符串| 转义后的含义 |\n    | ----------- | -------------- |\n    | ??=         |  #             |\n    | ??(         |\\[              |\n    | ??)         | ]              |\n    | ??/         | \\              |\n    | ??<         | {              |\n    | ??>         | }              |\n    | ??'         | ^              |\n    | ??!         | \\|             |\n    | ??-         | ～             |\n\n## 1.1 基本内置类型\n\n### 1.1.1 算术类型\n\n`整形（布尔/字符）`和`浮点型`\n\n|类型|含义|最小尺寸|\n|---|---|---|\n|bool|布尔类型|4bit|\n|char|字符|8bit|\n|wchar_t|宽字符|16bit|\n|char16_t|Unicode16|16bit|\n|char32_t|Unicode32|32bit|\n|short|短整型|2个字节,16bit|\n|int|整型|4个字节,32bit|\n|long|长整型|32bit|\n|long long|长整型|64bit,8字节|\n|float|单精度|32bit,6位有效数字|\n|double|双精度|64bit,10位有效数字|\n|long double|扩展精度|128bit,10位有效数字|\n\n\n1. 一个char应可以存机器基本字符集中任意字符对应的数字值,其他字符集可以用`wchar_t`-可以扩展字符集任意字符,`char16_t`,`char32_t`-他俩则是扩展Unicode字符标准\n2. 8比特等于一个字节，四个字节等于一个字符\n3. 内置类型的机器实现之address地址,就是一串数字,跟着其存储(8比特)内容\n4. 带符号类型和无符号类型\n`short`,`int`,`long` ,`long long` 都有`unsigned`类型。`char`,`signed char`和`unsigned char`,虽然表现是三种，但是只有两种，`char`具体表现为哪种，要看编译器\n\n- 如何选择类型\n    1. 数值不可能为负时，用无符号类型\n    2. 超过了int范围，选用long long\n    3. 因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的。所以如果你需要使用一个不大的整数，应指定是使用unsigned char 还是signed char\n    4. float 和double在计算上没差别，但是long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视\n\n### 1.1.2 类型转换\n\n```cpp\nbool b = 42;\nint i = b; // i的值为1\ni= 3.14 ; //i的值为3\ndouble pi = i ;//pi的值为3.0\nunsigned char c =-1; //假设char占8比特,c的值在255,被转换\nsigned char c2 = 256; // 假设char占8比特，c2的值是未定义\n```\n\n1. int -> bool // 0是假，1是真  \n2. bool -> int // false是0，真是1  \n3. float -> int // 只保留整数位  \n4. int -> float // 小数位填0  \n5. signed -> unsigned //符号位当成数值位转换为十进制`1000 0001`，反码为`1111 1110`，补码为`1111 1111(signed char)`,然后转换为unsigned char  `1111 1111`,十进制是`255`，或者`-1 + 256 mod 256 = 255`,如第六行代码.\n6. 当我们赋给`符号类型`一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据\n    > 建议：避免无法预知和依赖于实现环境的行为\n\n- 含有无符号类型的表达式  \n\n    例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样:\n\n    ```cpp\n    unsigned u = 10;\n    int i  =-42;\n    cout<< i + i << endl ; //-84\n    cout << u + i << endl; // 输出结果4294967264\n    ```\n\n    ```cpp\n    for (int i = 10 ; i >= 0 ; --i ){\n        cout<<i << endl;\n    }\n    for (unsigned  i = 10 ; i >= 0 ; --i ){\n        cout<<i << endl;\n    }\n    // 永远不会退出循环,其实是没设计好这个for statement,unsigned同样道理\n    ```\n\n    可以用下面语句带题\n\n    ```cpp\n    unsigned u =11;\n    while (u>0){\n        --u;\n        std::cout<< u << std::endl;\n    }\n    ```\n\n    > 提示:避免`signed`与`unsigned`混合运算，会将`signed`转换为`unsigned`类型\n\n### 1.1.3 字面常量\n\n例如`42`就是字面值常量,整型,浮点,字符,字符串字面值\n    \n  - 以0开头的整数代表八进制数  \n\n  - 以0x或0X开头的代表十六进制数  \n\n    |字面值|类型说明|\n    |---|---|\n    |20|  // decimal十进制|\n    |024        |  //octal八进制|\n    |0X14       |  // hexadecimal 十六进制|\n    |128u ,128U |  // unsigned 十进制|\n    |1024UL or 8LU  | // unsigned long|\n    |1024ULL or 8LLU     |// unsigned long long|\n    |1L         | // long 长整形|\n\n  - 如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误  \n\n  - 3.14159,3.14159E0,0.,0e0,.001  \n\n    |字面值|类型说明|\n    |---|---|\n    |3.14159F = 3.14159E0F  |// float ,科学计数|\n    |.001f = 1E-3F | // float,科学计数|\n    |12.345L = 1.2345E1L|// long double 扩展精度 ,科学计数|\n    |0. = 0e0 |// double ,科学计数|\n\n  - 'a','Hello World!', 字符字面值,字符串字面值\n\n    |字面值|类型说明|\n    |---|---|\n    |'a'| // char 字符|\n    |L'a' |// wchar_t 宽字符 |\n    |u'a' |// char16_t 宽字符 |\n    |U'a' |// char32_t 宽字符 |\n    |u8\"hi!\"|//utf-8字符串类型,只支持字符串|\n    |nullptr|//指针字面值|\n    |'A'|//表示单个字符A |\n    |\"A\"|//表示字符A和空字符两个字符的字符串|\n  - 转义序列\n\n    | 语义 | 实现 |\n    | --- | --- |\n    | \\n | 换行 |\n    |\\v|纵向制表|\n    |\\\\\\|反斜线|\n    |\\r|回车符号|\n    |\\t|横向指标符号|\n    |\\b|退表符号|\n    |\\?|问号|\n    |\\a|报警符号|\n    |\\\\\"|双引号|\n    |\\\\'|单引号|  \n\n  - 泛化的转义序列  \n    - (有需要再重点看)\n    - 斜线\\后面跟着的八进制数字超过3个，只有前3个数字与\\构成转义序列。例如，\"\\1234\"表示2个字符，即八进制数123对应的字符以及字符4\n    - \\x要用到后面跟着的所有数字，例如，\"\\x1234\"表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定\n  - 指定字面值的类型\n    给字面值添加前后缀，可以改变其默认类型  \n    |前缀|含义|类型|\n    |---|---|---|\n    |u|16字符|char16_t|\n    |U|32字符|char32_t|\n    |L|宽字符|wchar_t|\n    |u8|UTF-8|char,仅适用于字符串|\n\n    |后缀|最小匹配类型|\n    |---|---|\n    |u or U|unsigned|\n    |l or L |long|\n    |ll or LL|long long|\n    |f or F|float|\n    |l or L |long double|\n  - 布尔字面值\n        `bool test = false`\n\n## 1.2. 变量\n\n### 1.2.1 变量定义\n`::` : 命名空间符号  \n\n\n- 默认值,初始值,和列表初始化 :  \n\n    ```cpp\n    int units_sold = {0};//列表初始化\n    int units_sold{0}; // 列表初始化\n    int units_sold(0); //直接初始化 \n    ```\n\n- 全局变量默认值 : 在定义变量阶段如不指定会被指定默认值  \n- 定义在函数体内部的`内置类型`变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的,如果试图拷贝或以其他形式访问此类值将引发错误.类自行决定初始化方式.绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值.如果一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误\n\n### 1.2.2 变量声明和定义的关系\n\n- CPP支持分离式编译，也就是定义和声明分开  \n- extern语句如果包含初始值就不再是声明，而变成定义了  \n- 变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明  \n\n### 1.2.3 名字的作用域\n\n1. 局部变量，顾名思义，生命周期作用范围只在函数内,局部变量不会对变量进行初始化，全局变量才会初始化  \n2. 全局变量，存活于程序整个生命周期,extern允许你在任意地方的声明一个变量或者函数，然后允许再任何地方进行定义。\n3. 嵌套的作用域\n    <details>\n    <summary>嵌套的作用域代码demo</summary>\n\n    ```cpp\n    #include <iostream>\n\n    // Program for illustration purposes only: It is bad style for a function\n    // to use a global variable and also define a local variable with the same name\n\n    int reused = 42;  // reused has global scope\n\n    int main()\n    {\n        int unique = 0; // unique has block scope\n\n        // output #1: uses global reused; prints 42 0\n        std::cout << reused << \" \" << unique << std::endl;   \n\n        int reused = 0; // new, local object named reused hides global reused\n\n        // output #2: uses local reused; prints 0 0\n        std::cout << reused << \" \" <<  unique << std::endl;  \n\n        // output #3: explicitly requests the global reused; prints 42 0\n        std::cout << ::reused << \" \" <<  unique << std::endl;  \n\n            return 0;\n    }\n    ```\n\n    </details>  \n\n    output #3则是访问全局`reused`变量  \n\n\n\n## 1.3. 复合类型\n\n 引用: 及别名\n\n 1. `int &reference2` 报错，因为没有初始化，引用必须在定义时初始化.  \n 2. `int &reference3 = reference`引用创建引用,reference是对象类型  \n 3. 将引用赋值给变量就是把引用的对象作为初始值  \n\n 指针  \n\n 1. 块级作用域指针不被初始化也会拥有不确定值  \n 2. `double *dp, *dp2`定义指针,访问无效指针后果无法预计\n 3. `*dp = 0.0` 利用指针给对象赋值  \n    建议\n    初始化所有定义的指针，切莫将变量直接赋值给指针,而是通过取地址符号,但是0可以直接赋值\n 4. `void *`指针,其他任意指针都可以指向空指针,我们无法直接操作空指针\n 5. 同时定义多个变量`int i=1024 , *p=&i, &q = i` , `int* p`合法容易但是产生误导\n 6. 指向指针的指针,`int ival=400,int *p=&ival, **pp=&p`,同时,访问对象值,也需要解两次引用  \n 7. 指向指针的引用  \n\n      <details>\n      <summary>指向指针的引用demo</summary>\n\n       ```cpp  \n           int i = 42;  \n           int *p;  \n           int *&r=p;  \n           r= &i //取i地址，让r指向i,同时p也指向了i  \n           *r=0 //给指针引用赋值，p指向的值也变了  \n       ```\n\n       </details>\n\n 8. 指针的类型必须与其所指对象的类型一致，但是有两个例外  \n      - 第一种例外情况是允许令一个指向常量的指针指向一个非常量对象  \n      <details>\n      <summary>\n      ```cpp\n      const double pi = 3.14 ;\n      double *ptr = &pi ; // 不可以，不能将变量指针绑定到常量指针\n\nconst double*cptr = &pi ; //合法\n      *cptr = 42 ; // 错误，不能给指向常量的指针赋值\n      double dval = 3.14 ; //\n      cptr = &dval ; // 正确，指针常量不能绑定到普通变量\n      ```\n      </summary>\n      </details>\n\n## 1.4. CPP修饰符和const限定符  \n\n- `signed`,`unsigned`, `long` 和 `short` 修饰整型和浮点型\n    <details>\n    <summary>修饰符demo</summary>\n\n    ```cpp\n     #include <iostream> \n     using namespace std; \n     /* * 这个程序演示了有符号整数和无符号整数之间的差别 */ \n     int main() { short int i; \n         // 有符号短整数 \n         short unsigned int j;\n         // 无符号短整数 \n         j = 50000; i = j; \n         cout << i << \" \" << j; \n         return 0; \n     }\n     ```\n\n    </details>\n\n- 类型限定符提供了变量的额外信息。\n\n| 限定符      | 含义                                                                                                 |\n| -------- | -------------------------------------------------------------------------------------------------- |\n| const    | **const** 类型的对象在程序执行期间不能被修改改变。                                                                     |\n| volatile | 修饰符 **volatile** 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 |\n| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict.  \n\n 1. const对象创建之后就不能修改发，所有创建时必须初始化\n 2. 默认情况下const对象尽在文件内有效，多文件间共享需要使用extern关键字\n\n    ```cpp\n    //file.cc\n    extern const int bufsize = fn();\n    //file.h\n    extern const int bufsize;\n    ```\n\n 3. const的引用  \n    常量引用可以绑定对象，但是不能修改被绑定对象的内容  \n    也不能用变量绑定常量引用  \n 4. 指向常量的指针\n\n    ```cpp\n    const double pi = 3.14;\n    const double *cptr = &pi;  //指向常量的指针，指针的值不能变，但是指向的值却是可以变的\n    ```\n\n 5. 常量指针  \n    指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型，例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变\n\n    ```cpp\n    int *const  curErr = &errNumb; //常量指针\n    const double pi = 3.14;  \n    const double *const pip = &pi;\n    ```\n\n 6. 顶层const和  \n     当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响\n 7. constexpr和常量表达式  \n     **TBC**\n\n## 1.5. 处理类型\n\n 1. typedef意为同义词，新标准中可以使用`using SI = Sales_items`  \n 2. typedef的指针常量，指向常量的指针  \n\n    ```cpp\n    typedef  char *pstring;\n    const pstring cstr = 0; //指向常量的指针常量\n    const pstring *ps ; //指针常量\n    ```\n\n 3. `auto`自动判断类型类型\n\n    ```cpp\n     const int ci = i , &cr = ci;\n     auto d = &i //整形指针\n     auto e = &ci; // e是指向整型常量的指针\n     const auto j = 0  //auto如果想推导出顶层const，需要明确写出  \n     auto &h=42  //错误，因为非常量引用无法绑定字面值\n     const auto &j=42  //错误，因为非常量引用无法绑定字面值\n    ```\n\n 4. decltype类型提示符  \n     decltype只推断类型，但不使用其值\n     - decltype和引用，和const\n\n     ```cpp\n     const int ci = 0,&cj = ci;\n     decltype(ci) x = 0;\n     decltype(cj) y = x ;\n     decltype(cj) z ; //错误，z是一个引用类型，必须初始化\n     int i =42,*p=&i,&r = i;\n     decltype(*p) c; //错误。必须初始化\n     decltype((i)) d; //错误，双层括号是引用类型，必须初始化\n     decltype(i) e ; //正确，e是一个未初始化的int\n     ```\n\n## 1.6. 自定义数据结构  \n\n   1. strcut 关键字\n\n      ```cpp\n            struct Sales_data {/* .....  */};就可以用来定义数据结构\n\n      ```\n\n   2. 预处理器概述  \n       #define指令把一个名字设定为预处理变量  \n       #ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真  \n\n       <details><summary>demo</summary>\n\n        ```cpp\n        #ifndef SALES_DATA_H\n        #define SALES_DATA_H\n\n        #include <string>\n\n        struct Sales_data {\n                std::string bookNo;\n                unsigned units_sold = 0;\n                double revenue = 0.0;\n        };\n        #endif\n      ```\n\n       </details>\n\n## 1.7 CPP存储类[待重新拟题]\n\n- auto\nCPP17 弃用\n- register\n定义 'register'存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小, 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中.\n- static 存储类\n`static` 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值\n- extern\n扩展全局变量作用域\n- nutable 存储类\n- thread_local 存储类\n变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本\n\n# 2. 字符串，向量，数组\n\n## 2.1. using关键字\n\n   1.切记不要在header文件中使用using namespace std  \n   2. 每个名字都需要独立的using声明  \n\n## 2.2. string 类型\n\n   ```cpp\n    string s1 = \"hi ya\"; //拷贝初始化\n    string s2(\"hi ya\"); // 直接初始化\n    string s3(10,'C'); //拷贝十个C\n    std::cin >> s3 >>std::endl;\n    while (getline(cin,line)) //从输入控制设备读入整行\n   ```\n\n- `string` 对象操作  \n\n   ```cpp\n   \n   os<<s //将s写道os中，并返回os \n   is>>s //从is中读取字符串赋值给s,字符串以空白分隔，返回is\n   getline(is,s); //\n   s.empty(); //s为空返回true，否则返回false\n   s.size(); //返回s中字符个数,函数返回的是一个无符号整型数\n   s[n] //返回数字索引储存的值\n   s1+s2 //拼接字符串\n   s1==s2;判断字符串是否相等\n   s1 [<>=] s2 //按照asic码进行比较\n   ```\n\n   ```cpp\n    #include <iostream>\n    using std::cout; using std::endl;\n\n    #include <string>\n    using std::string;\n\n    int main() \n    {\n\n            string s1  = \"hello, \", s2 = \"world\\n\";\n            string s3 = s1 + s2;   // s3 is hello, world\\n\n            cout << s1 << s2 << s3 << endl;\n\n            s1 += s2;   // equivalent to s1 = s1 + s2\n            cout << s1;\n\n            string s4 = \"hello\", s5 = \"world\";  // no punctuation in s4 or s2\n            string s6 = s4 + \", \" + s5 + '\\n';\n            string s7 = \"hello\" + \", \" + s5 + '\\n';  //不合法\n            string s8 = \"ABC\" + \"EFG\" + '\\n'; // 不合法操作\n            cout << s4 << s5 << \"\\n\" << s6 << endl;\n\n            return 0;\n    }\n   ```\n\n- 处理`string`对象中的字符\n\n   ```cpp\n   //用for处理字符\n   string str(\"ABCDEFG\");\n   for (auto c : str){\n   //这里的c其实是str中字符的拷贝\n       cout<< c << endl;\n   }\n   \n   //改变str中的字符值\n   for (auto &c : str){\n       cout<< c << endl;\n   }\n   //下标运算符,返回字符串中的值\n   if (!s.empty()){\n       cout<< s[0] << endl;\n   }\n   ```\n\n## 2.3. vector类型\n\n  ```cpp\n  vector<int> ivec; //保存int类型\n  vector<Sales_item> Sales_vec; //保存Sales_item变量\n  vector<vector<string>> file  ; //vector存vector类型\n  // 初始化\n  vector<T> v1\n  vector<T> v2(v1);//v2中包含v1中所有副本\n  vector<T> v2 = v1 //等价于 vector<T> v2(v1)\n  vector<T> v3(n,val);//v3包含了n个val元素\n  vector<T> v4(n)//包含了n个执行值初始化的对象\n  vector<T> v5{a,b,c ...} //v5包含了初始值个数的元素，每个元素被赋予相应的初始值，这里还有一点要注意，就是可能会放不同类型的值，但\n  vector<T> v5={a,b,c ...} //等价于vector<T> v5{a,b,c ...}\n  // vector的CRUD\n  v.empty();// 是否为空\n  v.size(); //返回容量，类型std::size_type\n  v.push_back(t); // 添加值\n  v[n]; //访问下标存储的数据\n  v2=v1 ;//v1拷贝到v2\n  v1 ={a,b,c.....} //重新赋值\n  v1 == v2 ;//时候绝对的相等，长度和内容\n  <>= //顾名思义按照字典序进行比较\n  v1!=v2;\n  ```\n\n- 无法访问索引外数据，编译期无法发现，但是运行期就会报错\n\n## 2.4. 迭代器的介绍\n\n除了vector之外，标准库还定义了其他容器，string也可以使用迭代器\n\n\nv.begin()返回第一位元素的指针,v.end()返回最后一个元素，注意end()返回的是空引用\n\n- 迭代器运算符包括  \n    |符号类型            |说明                               |\n    |------             |------                             |\n    |  *iter            | `(*it).empty()`,返回迭代器所指元素的引用,解引用未定义迭代器都是未定义的行为，可以修改引用真实数据|\n    |  item             |解引用iter并获取该元素的名为mem的成员变量，等价于(*iter).mem|\n    |  ++iter / --iter /[+-] n  |进行加减运算                |\n    |  iter==iter2      |判断两个迭代器                       |\n    |  iter1 != iter2   | 判断两个迭代器不等                  |\n    | <= ,>=            | 要求迭代器必须指向同一个容器          |\n\n    <details><summary>将字符串小写符转化为大写示例</summary>\n\n    ```cpp\n    string s(\"some string\");\n    if (s.begin() != s.end()){\n        auto it = s.begin();\n        *it = toUpper(*it);\n    }\n    ```\n\n    </details>\n\n    1. 迭代器类型支持了以上操作\n    2. 如果元素是常数则返回const_iterator,不是常数则返回iterator类型\n    3. it->mem和(＊it).mem表达的意思相同\n    4. 不能在范围for循环中向容器添加元素。**另外一个**限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该 vector对象的迭代器失效\n\n- 将迭代器的移动\n    <details><summary>迭代器移动示例</summary>\n\n    ```cpp\n    for (auto it = s.begin() ; it != it.end()&& !isUpper(*it); ++it){\n        *it = toUpper(*it);\n    }\n    ```\n\n- 泛型编程  \n    泛型编程更像一种高度抽象数据结构的能力\n\n- begin()和end()函数  \n    如果元素是常数则返回const_iterator,不是常数则返回iterator类型\n\n\n    </details>\n\n## 2.5 数组\n如果不清楚元素的确切个数,请使用vector,数组的大小确定不变,不能随意向数组中增加元素.因为数组的大小固定,因此对某些特殊的应用来说程序的运行时性能较好,但是相应地也损失了一些灵活性.\n\n### 2.5.1 定义和初始化内置数组\n\n1. 显示初始化数组\n    <details>\n    <summary>数组初始化示例</summary>\n    ```cpp\n    const unsigned sz=3; 定义常量\n    int ia1 = {0,1，2};\n    int a2[] = {0,1,2};\n    int a3[5]= {0,1,2};\n    string a4[] = {\"hi\",\"byte\"};\n    int a5[2] = {0,1,2}  //错误，超出容量\n    ```\n\n    </details>\n2.  字符数组的特殊性\n\n    <details>\n    <summary>字符数组特殊性初始化示例</summary>\n\n    ```cpp\n    char a1[] = {'c','+','+'};\n    char a2[] = {'c','+','+','\\0'}; //显示胡世华空字符\n    char a3[] = \"C++\"; //自动初始化空字符\n    const a4[6]  = \"Daneil\"  //错误没有空间存放空字符\n\n    ```\n\n    </details>\n3. 不允许拷贝赋值\n\n    <details>\n    <summary>不允许拷贝赋值示例</summary>\n\n    ```cpp\n    int a[] = {0,1,2} //含有三个元素的数组\n    int a2[] = a1; // 错误: 不允许使用一个数组给另一个数组进行初始化\n        a2 = a1 //错误: 不允许两个数组之间直接赋值计算\n \n    ```\n\n    </details>\n\n4. 复杂数组声明\n    <details>\n    <summary>复杂数组声明示例</summary>\n\n    ```cpp\n    int *ptrs[10]  // 指向含有10个整型指针的数组\n    int &refs[10] =/*?*/ //不存在引用的数组\n    int (*Parrary)[10] = &arr; // 指向一个含有是个个整数的数组\n    int (&arrRef)[10] = arr ; //arrRef 引用指向一个含有是个整数的数组\n    int *(&arry)[10] = ptrs ; // 首先知道arry是一个引用，然后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用\n    ```\n\n    </details>\n\n### 2.5.2 访问数组元素\n\n1. 在使用数组下标的时候，通常将其定义为size_t类型\n2. 检查下标的值, CPP要检查数组下标\n\n### 2.5.3 指针和数组\n\n1. 通过取地址符号获取地址\n\n    ```cpp\n    string nums = {\"one\",\"two\",\"three\"};\n    string *p = &nums[0];  //  等价于    string *p2=nums;\n    ```\n\n    其中一层意思就是当使用数组作为`auto`变量初始值的时候，推断出的是指针而非数组，显然是`auto ia2(&ia[0])`;但是使用decltype(ia)返回的类型是由10个整数构成的数组\n\n    ```cpp\n    decltype(ia) ia3 = {0,1,2,3,4} ;\n     ia3 =p ;//错误:不能把整型指针给数组赋值， \n     ia3[4] = i;//正确: 把整数i赋值给ia3的一个元素\n    ```\n\n2. 指针也是迭代器,可以进行整型运算\n    获取数组的指针后就可以通过`加/减`计算指针的值,获取指针的最后一个元素地址 `&arr[n]` ,这个表示arr的长度。针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。两个指针相减的结果的类型是一种名为`ptrdiff_t`的标准库类型，和`size_t`一样，`ptrdiff_t`也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型,两指针不指向头一个对象而进行`加/减`没有意义\n3. 标准库函数begin()和end()\n\n    ```cpp\n    int arr[] ={0,1,2,3,4,5};\n    int *head = begin(arr);\n    int *tail = end(arr);\n\n    ```\n\n4. 指针解引用的运算\n\n    ```cpp\n    int arr[] = {0,1,2,3};\n    int last =*(arr + 3);\n    last = *last + 4; //是解引用last然后加4\n    int k = p[-2] // 数组下标运算可以处理负值\n    vector<T> //下标运算不能为负值，是无符号类型\n    ```\n\n### 2.5.4 C风格字符串  \n\n- 支持C风格运算函数，比较字符串时候,比较第一个不相同字符的ASCII码值\n- 如果是两个字符串字面量可以用`+`进行拼接，但是如果是两个指针就需要用函数进行拼接\n    `strcpy(str,ca1)` //把ca1复制给str,一定要注意str的容量  \n    `strcat(str,\"\")` //str是字符串数组  \n    `strcat(str,ca2)` // 将ca2和str继续拼接v  \n\n### 2.5.5 与旧代码的接口,兼容C代码\n\n1. 混合string对象和C风格字符串\n    `string s(\"hello world\");`//也允许空字符串初始化string字符串，在string对象的加法运算中允许使用以空字符结束的`字符数组`作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象.\n    无法用`string`对象初始化字符数组，除非使用`s.c_str()`函数`const char *str = s.c_str();`\n2. 使用数组初始化vector对象\n\n- 不允许使用一个`数组`给另一个`内置类型数组`初始化  \n- `vector`允许给`数组`初始化  \n- 但是`数组`却可以给vector 进行初始化,可以是相等元素数量进行赋值，也可以是部分元素数量给`vector`赋值\n\n建议：尽量使用标准库类型而非数组,应该尽量使用string，避免使用C风格的基于数组的字符串\n\n## 2.6 多维数组\n\n```cpp\nint ia[10][10] ; //多维数组\nint ia[10][10] = {0} ;//将所有元素都初始化为0\n// 从左往右理解，定义了一个十个元素的数组，每个元素里面又能容纳一个是元素的数组。\n```\n\n### 2.6.1 多维数组初始化\n\n```cpp\n/*----1-----*/\n//二维数组分别初始化\nint ia[3][4] = {\n    {1,2,3,0},\n    {4,5,6,0},\n    {7,8,9,0}\n};\n\n/*----2----*/\nint ia[3][4] = {0,1,2,3,4,5,6};//这种初始化方式是等价的，但是并不会把所有元素都初始化\n\n/*----3----*/\n//显示缺省\nint ia[3][4] = {\n    {1},\n    {4},\n    {7}\n};\n/*----4----*/\n// 只是初始化第一行\nint ia[3][4] = {\n  0,1,2,3\n};\n```\n\n### 2.6.2 多维数组的下标引用\n\n说白了就是可以通过下标运算符进行取值，如果是三维数组，而用了两个下标运算符那么就会取出**数组**\n\n### 2.6.3 使用范围for语句处理多维数组\n\n看如下例子,因为程序要改变数组中的值，所以要使用`引用`进行赋值。\n```cpp\nsize_t = 0;\nfor (auto &row : ia){  // row其实是数组的引用\n    for(auto &col :row){ // col其实是整数的引用\n                col = cnt;\n            ++cnt;\n    }\n}\n```\n\n而如下例子代码是错的,编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）\n,转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊\n\n```cpp\nfor (auto row : ia){ \n    for (auto col :row){\n\n    }\n}\n```\n\n### 2.6.4 指针和多维数组\n\n定义数组的时候千万别忘了这是数组的数组,所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针,例如  \n\n```cpp\nint ia[3][4];\nint (*p)[4] = ia; //p 是指向四个整数的数组\nint *p[4] ;//整形指针数组\np = &ia[2] ;//p指向ia的尾元素\n\n```\n\n在C++11标准中使用`auto`和`decltype`就能避免在数组前面加一个指针类型，例子如下  \n \n```cpp\n    for (auto p = ia ;p!=ia+3; ++p){\n        for (auto q = *p; q!= *p +4 ; ++q){\n            cout << *q << '' ;\n        }\n        cout << endl;\n    }\n\n```\n\n它首先令指针q指向p当前所在行的第一个元素,然后再一次`解引用`指向内层的数组的首元素，然后终止条件为`+4`,当然也可以使用标准函数`begin()`和`end()`实现相同的效果\n\n```cpp\n    for (auto p = begin(ia) ; p!=end(ia);++ia ){\n        for (auto q = begin(*p); q!=end(*p);++q){\n            cout<< *q << '' ;\n        }\n        cout<< endl; \n    }\n\n```\n\n### 2.6.5 类型别名简化多维数组的指针\n\n使用`类型别名`可以简化工作  \n```cpp\nusing int_array  = int[3]; //新标准下的写法\ntypedef int int[4] ;//等价的typedef声明\nfor (int_array *p = ia ; p!= ia +3 ; ++p){\n    for( int *q = *p ; q!= *p +3 ; ++q){\n        cout<< *q << '' ; \n    }\n    cout << endl ; \n}\n\n```\n程序将类型“四个整数组成的数组”命名为int_array,用类型名int_array定义外层循环`控制变量`更加简洁\n\n### 2.6.6 术语表\n\n|术语|解释|\n|---|---|\n|begin |是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。|\n|缓冲区溢出（buffer overflow）|一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等|\n|C风格字符串（C-style string）|以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错|\n|类模板（class template）|用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个vector对象需要指定元素的类型：`vector<int>`包含int类型的元素。|\n|编译器扩展（compiler extension）|某个特定的编译器为C++语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上|\n|容器（container） |是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。|\n|容器（container） |是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。|\n|difference_type | 由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。|\n|直接初始化（direct initialization）| 不使用赋值号（=）的初始化形式|\n|empty() | 是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假。|\n|end() |是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针。|\n|getline | 在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留。|\n|索引（index） | 是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置。|\n|实例化（instantiation） | 编译器生成一个指定的模板类或函数的过程。|\n|迭代器（iterator）| 是一种类型，用于访问容器中的元素或者在元素之间移动。|\n|迭代器运算（iterator arithmetic） | 是string或vector的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置。|\n|以空字符结束的字符串（null-terminated string）|  是一个字符串，它的最后一个字符后面还跟着一个空字符（'\\0'）。|\n|prtdiff_t |是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。|\n|push_back |是vector的成员，向vector对象的末尾添加元素。|\n| 范围for语句（range for）|  一种控制语句，可以在值的一个特定集合内迭代。|\n|size | 是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type。| \n|size_t |是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小。|\n|size_type |是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型。|\n|string |是一种标准库类型，表示字符的序列。|\n|using声明（using declaration）| 令命名空间中的某个名字可被程序直接使用。using 命名空间 ：： 名字；上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分命名空间：：。|\n|值初始化（value initialization） |是一种初始化过程。内置类型初始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值|\n|vector |是一种标准库类型，容纳某指定类型的一组元素。|\n|++运算符（++ operator）| 是迭代器和指针定义的递增运算符。执行“加1”操作使得迭代器指向下一个元素。|\n|[ ]运算符（[ ] operator）|下标运算符。obj[j]得到容器对象obj中位置j的那个元素。索引从0开始，第一个元素的索引是0，尾元素的索引是obj.size（）-1。下标运算符的返回值是一个对象。如果p是指针、n是整数，则p[n]与＊（p+n）等价。|\n|->运算符（->operator）| 箭头运算符，该运算符综合了解引用操作和点操作。a->b等价于（＊a）.b。|\n<<运算符`（<<operator）`|标准库类型string定义的输出运算符，负责输出string对象中的字符。|\n|>>运算符`（>>operator）`|标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个string对象。|\n|！运算符（！ operator）|逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假。|\n|&&运算符（&&operator）| 逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象。|\n| ||运算符（|| operator）| 逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象。|\n\n\n# 3. CPP流程控制\n\n- 如果标准输入输出作为`if`,`while`条件，读到文件结束符判断假，或者是无效输入\n\n1. windows : Ctrl+Z (文件结束符)\n2. linux : Ctrl+D (文件结束符)\n\n# 4. 函数\n\n- 函数的调用\n  - 传值\n  - 传引用\n\n- 参数默认值\n- Lambda表达式\n\n```cpp\n[](int x, int y) -> int { int z = x + y; return z + x; }\n```\n\n```\n[]      // 沒有定义任何变量。使用未定义变量会引发错误。\n[x, &y] // x以传值方式传入（默认），y以引用方式传入。\n[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。\n[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。\n[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n```\n\n- 引用\n实际上是已知变量的另一个名字。\n\n```\nint&  r = i;\n```\n\n- 标准IO\n通过(std::)方式调用标准函数库，或者在函数头写`using namespace std`\n\n```cpp\n#include <iostream>\n \nusing namespace std;\n \nint main( )\n{\n   char name[50];\n \n   cout << \"请输入您的名称： \";\n   cin >> name;\n   cout << \"您的名称是： \" << name << endl;\n   cerr << \"Error message : \" << str << endl;\n   clog << \"Error message : \" << str << endl;\n}\n```\n\n## 4.1. struct构造初始化\n\n- 利用自带默认构造函数\n- 参数构造\n- 自定义void init(.....){ ... this->  ...}\n在建立结构体数组时,如果只写了带参数的构造函数将会出现数组无法初始化的错误！！！各位同学要牢记呀！！！\n\n```cpp\n\nstruct node{\n int data;\n string str;\n char x;\n //自己写的初始化函数\n void init(int a, string b, char c){\n  this->data = a;\n  this->str = b;\n  this->x = c;\n }\n node() :x(), str(), data(){}\n node(int a, string b, char c) :x(c), str(b), data(a){}\n}N[10];\n```\n\n# 5. 面向对象编程\n\n- #include指令使用（<>）导入标准库函数，非标准库用双引号（\" \"）。\n\n<details>\n<summary>类示例demo</summary>\n\n```cpp\n#include <iostream>\n#include \"Books\"\nusing namespace std;\n \nclass Box\n{\n   private:\n   \n   protected:\n   \n   public:\n      char  title[50];\n      char  author[50];\n      char  subject[100];\n      int   book_id;\n      double length;   // 长度\n      double breadth;  // 宽度\n      double height;   // 高度\n      // 成员函数声明，但是没有实现\n      double get(void);\n      void set( double len, double bre, double hei );\n      \n};\n// 成员函数定义\ndouble Box::get(void)\n{\n    return length * breadth * height;\n}\n \nvoid Box::set( double len, double bre, double hei)\n{\n    length = len;\n    breadth = bre;\n    height = hei;\n}\nint main( )\n{\n   Box Box1;        // 声明 Box1，类型为 Box\n   Box Box2;        // 声明 Box2，类型为 Box\n   Box Box3;        // 声明 Box3，类型为 Box\n   double volume = 0.0;     // 用于存储体积\n \n   // box 1 详述\n   Box1.height = 5.0; \n   Box1.length = 6.0; \n   Box1.breadth = 7.0;\n \n   // box 2 详述\n   Box2.height = 10.0;\n   Box2.length = 12.0;\n   Box2.breadth = 13.0;\n \n   // box 1 的体积\n   volume = Box1.height * Box1.length * Box1.breadth;\n   cout << \"Box1 的体积：\" << volume <<endl;\n \n   // box 2 的体积\n   volume = Box2.height * Box2.length * Box2.breadth;\n   cout << \"Box2 的体积：\" << volume <<endl;\n \n \n   // box 3 详述\n   Box3.set(16.0, 8.0, 12.0); \n   volume = Box3.get(); \n   cout << \"Box3 的体积：\" << volume <<endl;\n   return 0;\n}\n```\n\n</details>\n\n- CPP支持文件重定向`$ addItems <infile >outfile` 可直接从文件读数据然后计算\n\n<details>\n  <summary>文件重定向Sales_item代码</summary>\n <blockcode>\n\n ```cpp\n  /*\n * This file contains code from \"C++ Primer, Fifth Edition\", by Stanley B.\n * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the\n * copyright and warranty notices given in that book:\n * \n * \"Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.\"\n * \n * \n * \"The authors and publisher have taken care in the preparation of this book,\n * but make no expressed or implied warranty of any kind and assume no\n * responsibility for errors or omissions. No liability is assumed for\n * incidental or consequential damages in connection with or arising out of the\n * use of the information or programs contained herein.\"\n * \n * Permission is granted for this code to be used for educational purposes in\n * association with the book, given proper citation if and when posted or\n * reproduced.Any commercial use of this code requires the explicit written\n * permission of the publisher, Addison-Wesley Professional, a division of\n * Pearson Education, Inc. Send your request for permission, stating clearly\n * what code you would like to use, and in what specific way, to the following\n * address: \n * \n *     Pearson Education, Inc.\n *     Rights and Permissions Department\n *     One Lake Street\n *     Upper Saddle River, NJ  07458\n *     Fax: (201) 236-3290\n*/ \n\n/* This file defines the Sales_item class used in chapter 1.\n * The code used in this file will be explained in\n * Chapter 7 (Classes) and Chapter 14 (Overloaded Operators)\n * Readers shouldn't try to understand the code in this file\n * until they have read those chapters.\n*/\n\n#ifndef SALESITEM_H\n// we're here only if SALESITEM_H has not yet been defined \n#define SALESITEM_H\n\n// Definition of Sales_item class and related functions goes here\n#include <iostream>\n#include <string>\n\nclass Sales_item {\n// these declarations are explained section 7.2.1, p. 270 \n// and in chapter 14, pages 557, 558, 561\nfriend std::istream& operator>>(std::istream&, Sales_item&);\nfriend std::ostream& operator<<(std::ostream&, const Sales_item&);\nfriend bool operator<(const Sales_item&, const Sales_item&);\nfriend bool \noperator==(const Sales_item&, const Sales_item&);\npublic:\n    // constructors are explained in section 7.1.4, pages 262 - 265\n    // default constructor needed to initialize members of built-in type\n    Sales_item() = default;\n    Sales_item(const std::string &book): bookNo(book) { }\n    Sales_item(std::istream &is) { is >> *this; }\npublic:\n    // operations on Sales_item objects\n    // member binary operator: left-hand operand bound to implicit this pointer\n    Sales_item& operator+=(const Sales_item&);\n    \n    // operations on Sales_item objects\n    std::string isbn() const { return bookNo; }\n    double avg_price() const;\n// private members as before\nprivate:\n    std::string bookNo;      // implicitly initialized to the empty string\n    unsigned units_sold = 0; // explicitly initialized\n    double revenue = 0.0;\n};\n\n// used in chapter 10\ninline\nbool compareIsbn(const Sales_item &lhs, const Sales_item &rhs) \n{ return lhs.isbn() == rhs.isbn(); }\n\n// nonmember binary operator: must declare a parameter for each operand\nSales_item operator+(const Sales_item&, const Sales_item&);\n\ninline bool \noperator==(const Sales_item &lhs, const Sales_item &rhs)\n{\n    // must be made a friend of Sales_item\n    return lhs.units_sold == rhs.units_sold &&\n           lhs.revenue == rhs.revenue &&\n           lhs.isbn() == rhs.isbn();\n}\n\ninline bool \noperator!=(const Sales_item &lhs, const Sales_item &rhs)\n{\n    return !(lhs == rhs); // != defined in terms of operator==\n}\n\n// assumes that both objects refer to the same ISBN\nSales_item& Sales_item::operator+=(const Sales_item& rhs) \n{\n    units_sold += rhs.units_sold; \n    revenue += rhs.revenue; \n    return *this;\n}\n\n// assumes that both objects refer to the same ISBN\nSales_item \noperator+(const Sales_item& lhs, const Sales_item& rhs) \n{\n    Sales_item ret(lhs);  // copy (|lhs|) into a local object that we'll return\n    ret += rhs;           // add in the contents of (|rhs|) \n    return ret;           // return (|ret|) by value\n}\n\nstd::istream& \noperator>>(std::istream& in, Sales_item& s)\n{\n    double price;\n    in >> s.bookNo >> s.units_sold >> price;\n    // check that the inputs succeeded\n    if (in)\n        s.revenue = s.units_sold * price;\n    else \n        s = Sales_item();  // input failed: reset object to default state\n    return in;\n}\n\nstd::ostream& \noperator<<(std::ostream& out, const Sales_item& s)\n{\n    out << s.isbn() << \" \" << s.units_sold << \" \"\n        << s.revenue << \" \" << s.avg_price();\n    return out;\n}\n\ndouble Sales_item::avg_price() const\n{\n    if (units_sold) \n        return revenue/units_sold; \n    else \n        return 0;\n}\n#endif\n```\n\n </blockcode>\n</details>\n\n```cpp\n#include <iostream>\n#include \"Sales_item.cc\"\n\n \nusing namespace std;\nint main() \n{\n    Sales_item item1, item2;\n\n    std::cin >> item1 >> item2;   //read a pair of transactions\n    std::cout << item1 + item2 << std::endl; //print their sum\n\n    return 0;\n}\n```\n\n## 5.1. 继承与多继承\n\n```cpp\n#include <iostream>\n \nusing namespace std;\n \n// 基类\nclass Shape \n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n \n// 派生类, 多继承就是写成 class Rectangle: public Shape, public square { ... }\nclass Rectangle: public Shape\n{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }\n};\n \nint main(void)\n{\n   Rectangle Rect;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n \n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n \n   return 0;\n}\n```\n\n访问   | public | protected | private |\n| ---- | ------ | --------- | ------- |\n| 同一个类 | yes    | yes   | yes |\n| 派生类  | yes    | yes    | no  |\n| 外部的类 | yes    | no    | no |\n\n一个派生类继承了所有的基类方法，但下列情况除外：\n\n- 基类的构造函数、析构函数和拷贝构造函数。\n- 基类的重载运算符。\n- 基类的友元函数。\n\n我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：\n\n- **公有继承（public）：** 当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。\n- **保护继承（protected）：**  当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。\n- **私有继承（private）：** 当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。\n\n## 5.3. 函数，运算符重载\n\n- 函数签名不同的叫函数重载\n- 运算符重载\n\n```cpp\n类成员函数\nBox operator+(const Box&);\n```\n\n```cpp\n类的非成员函数\nBox operator+(const Box&, const Box&);\n\n```\n\n## 5.4. 多态\n\n如果对象具有继承关系，那么CPP会更具具体的对象类型调用具体的成员函数长度\n\n## 5.5. CPP接口\n\n```cpp\nclass Box\n{\n   public:\n      // 纯虚函数\n      virtual double getVolume() = 0;\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度\n};\n```\n\n实现类必须要实现抽象安徽念书(虚函数)\n","source":"_posts/C++_Primer.md","raw":"---\nhighlight: monokai\ntheme: juejin\ntitle: C++ Primer Plus\ncategories:\n- CPP\n---\n\n- [1. 变量及基本类型](#1-变量及基本类型)\n  - [1.1 基本内置类型](#11-基本内置类型)\n    - [1.1.1 算术类型](#111-算术类型)\n    - [1.1.2 类型转换](#112-类型转换)\n    - [1.1.3 字面常量](#113-字面常量)\n  - [1.2. 变量](#12-变量)\n    - [1.2.1 变量定义](#121-变量定义)\n    - [1.2.2 变量声明和定义的关系](#122-变量声明和定义的关系)\n    - [1.2.3 名字的作用域](#123-名字的作用域)\n  - [1.3. 复合类型](#13-复合类型)\n  - [1.4. CPP修饰符和const限定符](#14-cpp修饰符和const限定符)\n  - [1.5. 处理类型](#15-处理类型)\n  - [1.6. 自定义数据结构](#16-自定义数据结构)\n  - [1.7 CPP存储类[待重新拟题]](#17-cpp存储类待重新拟题)\n- [2. 字符串，向量，数组](#2-字符串向量数组)\n  - [2.1. using关键字](#21-using关键字)\n  - [2.2. string 类型](#22-string-类型)\n  - [2.3. vector类型](#23-vector类型)\n  - [2.4. 迭代器的介绍](#24-迭代器的介绍)\n  - [2.5 数组](#25-数组)\n    - [2.5.1 定义和初始化内置数组](#251-定义和初始化内置数组)\n    - [2.5.2 访问数组元素](#252-访问数组元素)\n    - [2.5.3 指针和数组](#253-指针和数组)\n    - [2.5.4 C风格字符串](#254-c风格字符串)\n    - [2.5.5 与旧代码的接口,兼容C代码](#255-与旧代码的接口兼容c代码)\n  - [2.6 多维数组](#26-多维数组)\n    - [2.6.1 多维数组初始化](#261-多维数组初始化)\n    - [2.6.2 多维数组的下标引用](#262-多维数组的下标引用)\n    - [2.6.3 使用范围for语句处理多维数组](#263-使用范围for语句处理多维数组)\n    - [2.6.4 指针和多维数组](#264-指针和多维数组)\n    - [2.6.5 类型别名简化多维数组的指针](#265-类型别名简化多维数组的指针)\n    - [2.6.6 术语表](#266-术语表)\n- [3. CPP流程控制](#3-cpp流程控制)\n- [4. 函数](#4-函数)\n  - [4.1. struct构造初始化](#41-struct构造初始化)\n- [5. 面向对象编程](#5-面向对象编程)\n  - [5.1. 继承与多继承](#51-继承与多继承)\n  - [5.3. 函数，运算符重载](#53-函数运算符重载)\n  - [5.4. 多态](#54-多态)\n  - [5.5. CPP接口](#55-cpp接口)\n\n# 1. 变量及基本类型\n\n 1. `g++ -o hello_world  -std=c++11  hello_world.cpp`  \n    将源代码cpp文件编程成二进制程序,并支持C++11\n 2. CPP保留字\n\n    |1|2|3|4|\n    | ------------ | --------- | ---------------- | -------- |\n    |asm          | else      | new              | this / 自身地址     |\n    | auto         | enum      | operator         | throw    |\n    | bool         | explicit  | private          | true / 真 / 0     |\n    | break        | export    | protected        | try      |\n    | case         | extern    | public           | typedef / 别名定义  |\n    | catch        | false     | register         | typeid   |\n    | char         | float /单精度    | reinterpret_cast | typename |\n    | class        | for       | return           | union    |\n    | const        | friend    | short            | unsigned / 无符号 |\n    | const_cast   | goto      | signed / 有符号          | using / 使用命名空间   |\n    | continue     | if        | sizeof           | virtual  |\n    | default      | inline    | static           | void / 空类型    |\n    | delete       | int       | static_cast      | volatile |\n    | do           | long      | struct           | wchar_t  |\n    | double       | mutable   | switch /           | while / 循环   |\n    | dynamic_cast | namespace | template||\n 3. typedef声明\n\n    ```cpp\n    typedef short int s_int;\n    typedef int feet;\n    feet distance //合法声明\n    ```\n\n 4. 枚举类型\n    所谓\"枚举\"是指将变量的值一一列举出来，变量赋值时候只能是特定的变量才能赋值\n\n    <details><summary>枚举类型demo</summary>\n\n    ```cpp\n\n    enum 枚举名{ \n        标识符[=整型常数], \n        标识符[=整型常数], \n    ... \n        标识符[=整型常数]\n    } 枚举变量;\n    //举例子\n    enum  color{ red , yellow ,blue} c\n    c = blue \n    //默认情况下，是从0开始初始化\n\n    ```\n\n    </details>\n\n 5. 三字符组\n\n    以前为了表示键盘上没有的字符\n    |字符串| 转义后的含义 |\n    | ----------- | -------------- |\n    | ??=         |  #             |\n    | ??(         |\\[              |\n    | ??)         | ]              |\n    | ??/         | \\              |\n    | ??<         | {              |\n    | ??>         | }              |\n    | ??'         | ^              |\n    | ??!         | \\|             |\n    | ??-         | ～             |\n\n## 1.1 基本内置类型\n\n### 1.1.1 算术类型\n\n`整形（布尔/字符）`和`浮点型`\n\n|类型|含义|最小尺寸|\n|---|---|---|\n|bool|布尔类型|4bit|\n|char|字符|8bit|\n|wchar_t|宽字符|16bit|\n|char16_t|Unicode16|16bit|\n|char32_t|Unicode32|32bit|\n|short|短整型|2个字节,16bit|\n|int|整型|4个字节,32bit|\n|long|长整型|32bit|\n|long long|长整型|64bit,8字节|\n|float|单精度|32bit,6位有效数字|\n|double|双精度|64bit,10位有效数字|\n|long double|扩展精度|128bit,10位有效数字|\n\n\n1. 一个char应可以存机器基本字符集中任意字符对应的数字值,其他字符集可以用`wchar_t`-可以扩展字符集任意字符,`char16_t`,`char32_t`-他俩则是扩展Unicode字符标准\n2. 8比特等于一个字节，四个字节等于一个字符\n3. 内置类型的机器实现之address地址,就是一串数字,跟着其存储(8比特)内容\n4. 带符号类型和无符号类型\n`short`,`int`,`long` ,`long long` 都有`unsigned`类型。`char`,`signed char`和`unsigned char`,虽然表现是三种，但是只有两种，`char`具体表现为哪种，要看编译器\n\n- 如何选择类型\n    1. 数值不可能为负时，用无符号类型\n    2. 超过了int范围，选用long long\n    3. 因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的。所以如果你需要使用一个不大的整数，应指定是使用unsigned char 还是signed char\n    4. float 和double在计算上没差别，但是long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视\n\n### 1.1.2 类型转换\n\n```cpp\nbool b = 42;\nint i = b; // i的值为1\ni= 3.14 ; //i的值为3\ndouble pi = i ;//pi的值为3.0\nunsigned char c =-1; //假设char占8比特,c的值在255,被转换\nsigned char c2 = 256; // 假设char占8比特，c2的值是未定义\n```\n\n1. int -> bool // 0是假，1是真  \n2. bool -> int // false是0，真是1  \n3. float -> int // 只保留整数位  \n4. int -> float // 小数位填0  \n5. signed -> unsigned //符号位当成数值位转换为十进制`1000 0001`，反码为`1111 1110`，补码为`1111 1111(signed char)`,然后转换为unsigned char  `1111 1111`,十进制是`255`，或者`-1 + 256 mod 256 = 255`,如第六行代码.\n6. 当我们赋给`符号类型`一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据\n    > 建议：避免无法预知和依赖于实现环境的行为\n\n- 含有无符号类型的表达式  \n\n    例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样:\n\n    ```cpp\n    unsigned u = 10;\n    int i  =-42;\n    cout<< i + i << endl ; //-84\n    cout << u + i << endl; // 输出结果4294967264\n    ```\n\n    ```cpp\n    for (int i = 10 ; i >= 0 ; --i ){\n        cout<<i << endl;\n    }\n    for (unsigned  i = 10 ; i >= 0 ; --i ){\n        cout<<i << endl;\n    }\n    // 永远不会退出循环,其实是没设计好这个for statement,unsigned同样道理\n    ```\n\n    可以用下面语句带题\n\n    ```cpp\n    unsigned u =11;\n    while (u>0){\n        --u;\n        std::cout<< u << std::endl;\n    }\n    ```\n\n    > 提示:避免`signed`与`unsigned`混合运算，会将`signed`转换为`unsigned`类型\n\n### 1.1.3 字面常量\n\n例如`42`就是字面值常量,整型,浮点,字符,字符串字面值\n    \n  - 以0开头的整数代表八进制数  \n\n  - 以0x或0X开头的代表十六进制数  \n\n    |字面值|类型说明|\n    |---|---|\n    |20|  // decimal十进制|\n    |024        |  //octal八进制|\n    |0X14       |  // hexadecimal 十六进制|\n    |128u ,128U |  // unsigned 十进制|\n    |1024UL or 8LU  | // unsigned long|\n    |1024ULL or 8LLU     |// unsigned long long|\n    |1L         | // long 长整形|\n\n  - 如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误  \n\n  - 3.14159,3.14159E0,0.,0e0,.001  \n\n    |字面值|类型说明|\n    |---|---|\n    |3.14159F = 3.14159E0F  |// float ,科学计数|\n    |.001f = 1E-3F | // float,科学计数|\n    |12.345L = 1.2345E1L|// long double 扩展精度 ,科学计数|\n    |0. = 0e0 |// double ,科学计数|\n\n  - 'a','Hello World!', 字符字面值,字符串字面值\n\n    |字面值|类型说明|\n    |---|---|\n    |'a'| // char 字符|\n    |L'a' |// wchar_t 宽字符 |\n    |u'a' |// char16_t 宽字符 |\n    |U'a' |// char32_t 宽字符 |\n    |u8\"hi!\"|//utf-8字符串类型,只支持字符串|\n    |nullptr|//指针字面值|\n    |'A'|//表示单个字符A |\n    |\"A\"|//表示字符A和空字符两个字符的字符串|\n  - 转义序列\n\n    | 语义 | 实现 |\n    | --- | --- |\n    | \\n | 换行 |\n    |\\v|纵向制表|\n    |\\\\\\|反斜线|\n    |\\r|回车符号|\n    |\\t|横向指标符号|\n    |\\b|退表符号|\n    |\\?|问号|\n    |\\a|报警符号|\n    |\\\\\"|双引号|\n    |\\\\'|单引号|  \n\n  - 泛化的转义序列  \n    - (有需要再重点看)\n    - 斜线\\后面跟着的八进制数字超过3个，只有前3个数字与\\构成转义序列。例如，\"\\1234\"表示2个字符，即八进制数123对应的字符以及字符4\n    - \\x要用到后面跟着的所有数字，例如，\"\\x1234\"表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定\n  - 指定字面值的类型\n    给字面值添加前后缀，可以改变其默认类型  \n    |前缀|含义|类型|\n    |---|---|---|\n    |u|16字符|char16_t|\n    |U|32字符|char32_t|\n    |L|宽字符|wchar_t|\n    |u8|UTF-8|char,仅适用于字符串|\n\n    |后缀|最小匹配类型|\n    |---|---|\n    |u or U|unsigned|\n    |l or L |long|\n    |ll or LL|long long|\n    |f or F|float|\n    |l or L |long double|\n  - 布尔字面值\n        `bool test = false`\n\n## 1.2. 变量\n\n### 1.2.1 变量定义\n`::` : 命名空间符号  \n\n\n- 默认值,初始值,和列表初始化 :  \n\n    ```cpp\n    int units_sold = {0};//列表初始化\n    int units_sold{0}; // 列表初始化\n    int units_sold(0); //直接初始化 \n    ```\n\n- 全局变量默认值 : 在定义变量阶段如不指定会被指定默认值  \n- 定义在函数体内部的`内置类型`变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的,如果试图拷贝或以其他形式访问此类值将引发错误.类自行决定初始化方式.绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值.如果一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误\n\n### 1.2.2 变量声明和定义的关系\n\n- CPP支持分离式编译，也就是定义和声明分开  \n- extern语句如果包含初始值就不再是声明，而变成定义了  \n- 变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明  \n\n### 1.2.3 名字的作用域\n\n1. 局部变量，顾名思义，生命周期作用范围只在函数内,局部变量不会对变量进行初始化，全局变量才会初始化  \n2. 全局变量，存活于程序整个生命周期,extern允许你在任意地方的声明一个变量或者函数，然后允许再任何地方进行定义。\n3. 嵌套的作用域\n    <details>\n    <summary>嵌套的作用域代码demo</summary>\n\n    ```cpp\n    #include <iostream>\n\n    // Program for illustration purposes only: It is bad style for a function\n    // to use a global variable and also define a local variable with the same name\n\n    int reused = 42;  // reused has global scope\n\n    int main()\n    {\n        int unique = 0; // unique has block scope\n\n        // output #1: uses global reused; prints 42 0\n        std::cout << reused << \" \" << unique << std::endl;   \n\n        int reused = 0; // new, local object named reused hides global reused\n\n        // output #2: uses local reused; prints 0 0\n        std::cout << reused << \" \" <<  unique << std::endl;  \n\n        // output #3: explicitly requests the global reused; prints 42 0\n        std::cout << ::reused << \" \" <<  unique << std::endl;  \n\n            return 0;\n    }\n    ```\n\n    </details>  \n\n    output #3则是访问全局`reused`变量  \n\n\n\n## 1.3. 复合类型\n\n 引用: 及别名\n\n 1. `int &reference2` 报错，因为没有初始化，引用必须在定义时初始化.  \n 2. `int &reference3 = reference`引用创建引用,reference是对象类型  \n 3. 将引用赋值给变量就是把引用的对象作为初始值  \n\n 指针  \n\n 1. 块级作用域指针不被初始化也会拥有不确定值  \n 2. `double *dp, *dp2`定义指针,访问无效指针后果无法预计\n 3. `*dp = 0.0` 利用指针给对象赋值  \n    建议\n    初始化所有定义的指针，切莫将变量直接赋值给指针,而是通过取地址符号,但是0可以直接赋值\n 4. `void *`指针,其他任意指针都可以指向空指针,我们无法直接操作空指针\n 5. 同时定义多个变量`int i=1024 , *p=&i, &q = i` , `int* p`合法容易但是产生误导\n 6. 指向指针的指针,`int ival=400,int *p=&ival, **pp=&p`,同时,访问对象值,也需要解两次引用  \n 7. 指向指针的引用  \n\n      <details>\n      <summary>指向指针的引用demo</summary>\n\n       ```cpp  \n           int i = 42;  \n           int *p;  \n           int *&r=p;  \n           r= &i //取i地址，让r指向i,同时p也指向了i  \n           *r=0 //给指针引用赋值，p指向的值也变了  \n       ```\n\n       </details>\n\n 8. 指针的类型必须与其所指对象的类型一致，但是有两个例外  \n      - 第一种例外情况是允许令一个指向常量的指针指向一个非常量对象  \n      <details>\n      <summary>\n      ```cpp\n      const double pi = 3.14 ;\n      double *ptr = &pi ; // 不可以，不能将变量指针绑定到常量指针\n\nconst double*cptr = &pi ; //合法\n      *cptr = 42 ; // 错误，不能给指向常量的指针赋值\n      double dval = 3.14 ; //\n      cptr = &dval ; // 正确，指针常量不能绑定到普通变量\n      ```\n      </summary>\n      </details>\n\n## 1.4. CPP修饰符和const限定符  \n\n- `signed`,`unsigned`, `long` 和 `short` 修饰整型和浮点型\n    <details>\n    <summary>修饰符demo</summary>\n\n    ```cpp\n     #include <iostream> \n     using namespace std; \n     /* * 这个程序演示了有符号整数和无符号整数之间的差别 */ \n     int main() { short int i; \n         // 有符号短整数 \n         short unsigned int j;\n         // 无符号短整数 \n         j = 50000; i = j; \n         cout << i << \" \" << j; \n         return 0; \n     }\n     ```\n\n    </details>\n\n- 类型限定符提供了变量的额外信息。\n\n| 限定符      | 含义                                                                                                 |\n| -------- | -------------------------------------------------------------------------------------------------- |\n| const    | **const** 类型的对象在程序执行期间不能被修改改变。                                                                     |\n| volatile | 修饰符 **volatile** 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 |\n| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict.  \n\n 1. const对象创建之后就不能修改发，所有创建时必须初始化\n 2. 默认情况下const对象尽在文件内有效，多文件间共享需要使用extern关键字\n\n    ```cpp\n    //file.cc\n    extern const int bufsize = fn();\n    //file.h\n    extern const int bufsize;\n    ```\n\n 3. const的引用  \n    常量引用可以绑定对象，但是不能修改被绑定对象的内容  \n    也不能用变量绑定常量引用  \n 4. 指向常量的指针\n\n    ```cpp\n    const double pi = 3.14;\n    const double *cptr = &pi;  //指向常量的指针，指针的值不能变，但是指向的值却是可以变的\n    ```\n\n 5. 常量指针  \n    指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型，例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变\n\n    ```cpp\n    int *const  curErr = &errNumb; //常量指针\n    const double pi = 3.14;  \n    const double *const pip = &pi;\n    ```\n\n 6. 顶层const和  \n     当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响\n 7. constexpr和常量表达式  \n     **TBC**\n\n## 1.5. 处理类型\n\n 1. typedef意为同义词，新标准中可以使用`using SI = Sales_items`  \n 2. typedef的指针常量，指向常量的指针  \n\n    ```cpp\n    typedef  char *pstring;\n    const pstring cstr = 0; //指向常量的指针常量\n    const pstring *ps ; //指针常量\n    ```\n\n 3. `auto`自动判断类型类型\n\n    ```cpp\n     const int ci = i , &cr = ci;\n     auto d = &i //整形指针\n     auto e = &ci; // e是指向整型常量的指针\n     const auto j = 0  //auto如果想推导出顶层const，需要明确写出  \n     auto &h=42  //错误，因为非常量引用无法绑定字面值\n     const auto &j=42  //错误，因为非常量引用无法绑定字面值\n    ```\n\n 4. decltype类型提示符  \n     decltype只推断类型，但不使用其值\n     - decltype和引用，和const\n\n     ```cpp\n     const int ci = 0,&cj = ci;\n     decltype(ci) x = 0;\n     decltype(cj) y = x ;\n     decltype(cj) z ; //错误，z是一个引用类型，必须初始化\n     int i =42,*p=&i,&r = i;\n     decltype(*p) c; //错误。必须初始化\n     decltype((i)) d; //错误，双层括号是引用类型，必须初始化\n     decltype(i) e ; //正确，e是一个未初始化的int\n     ```\n\n## 1.6. 自定义数据结构  \n\n   1. strcut 关键字\n\n      ```cpp\n            struct Sales_data {/* .....  */};就可以用来定义数据结构\n\n      ```\n\n   2. 预处理器概述  \n       #define指令把一个名字设定为预处理变量  \n       #ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真  \n\n       <details><summary>demo</summary>\n\n        ```cpp\n        #ifndef SALES_DATA_H\n        #define SALES_DATA_H\n\n        #include <string>\n\n        struct Sales_data {\n                std::string bookNo;\n                unsigned units_sold = 0;\n                double revenue = 0.0;\n        };\n        #endif\n      ```\n\n       </details>\n\n## 1.7 CPP存储类[待重新拟题]\n\n- auto\nCPP17 弃用\n- register\n定义 'register'存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小, 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中.\n- static 存储类\n`static` 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值\n- extern\n扩展全局变量作用域\n- nutable 存储类\n- thread_local 存储类\n变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本\n\n# 2. 字符串，向量，数组\n\n## 2.1. using关键字\n\n   1.切记不要在header文件中使用using namespace std  \n   2. 每个名字都需要独立的using声明  \n\n## 2.2. string 类型\n\n   ```cpp\n    string s1 = \"hi ya\"; //拷贝初始化\n    string s2(\"hi ya\"); // 直接初始化\n    string s3(10,'C'); //拷贝十个C\n    std::cin >> s3 >>std::endl;\n    while (getline(cin,line)) //从输入控制设备读入整行\n   ```\n\n- `string` 对象操作  \n\n   ```cpp\n   \n   os<<s //将s写道os中，并返回os \n   is>>s //从is中读取字符串赋值给s,字符串以空白分隔，返回is\n   getline(is,s); //\n   s.empty(); //s为空返回true，否则返回false\n   s.size(); //返回s中字符个数,函数返回的是一个无符号整型数\n   s[n] //返回数字索引储存的值\n   s1+s2 //拼接字符串\n   s1==s2;判断字符串是否相等\n   s1 [<>=] s2 //按照asic码进行比较\n   ```\n\n   ```cpp\n    #include <iostream>\n    using std::cout; using std::endl;\n\n    #include <string>\n    using std::string;\n\n    int main() \n    {\n\n            string s1  = \"hello, \", s2 = \"world\\n\";\n            string s3 = s1 + s2;   // s3 is hello, world\\n\n            cout << s1 << s2 << s3 << endl;\n\n            s1 += s2;   // equivalent to s1 = s1 + s2\n            cout << s1;\n\n            string s4 = \"hello\", s5 = \"world\";  // no punctuation in s4 or s2\n            string s6 = s4 + \", \" + s5 + '\\n';\n            string s7 = \"hello\" + \", \" + s5 + '\\n';  //不合法\n            string s8 = \"ABC\" + \"EFG\" + '\\n'; // 不合法操作\n            cout << s4 << s5 << \"\\n\" << s6 << endl;\n\n            return 0;\n    }\n   ```\n\n- 处理`string`对象中的字符\n\n   ```cpp\n   //用for处理字符\n   string str(\"ABCDEFG\");\n   for (auto c : str){\n   //这里的c其实是str中字符的拷贝\n       cout<< c << endl;\n   }\n   \n   //改变str中的字符值\n   for (auto &c : str){\n       cout<< c << endl;\n   }\n   //下标运算符,返回字符串中的值\n   if (!s.empty()){\n       cout<< s[0] << endl;\n   }\n   ```\n\n## 2.3. vector类型\n\n  ```cpp\n  vector<int> ivec; //保存int类型\n  vector<Sales_item> Sales_vec; //保存Sales_item变量\n  vector<vector<string>> file  ; //vector存vector类型\n  // 初始化\n  vector<T> v1\n  vector<T> v2(v1);//v2中包含v1中所有副本\n  vector<T> v2 = v1 //等价于 vector<T> v2(v1)\n  vector<T> v3(n,val);//v3包含了n个val元素\n  vector<T> v4(n)//包含了n个执行值初始化的对象\n  vector<T> v5{a,b,c ...} //v5包含了初始值个数的元素，每个元素被赋予相应的初始值，这里还有一点要注意，就是可能会放不同类型的值，但\n  vector<T> v5={a,b,c ...} //等价于vector<T> v5{a,b,c ...}\n  // vector的CRUD\n  v.empty();// 是否为空\n  v.size(); //返回容量，类型std::size_type\n  v.push_back(t); // 添加值\n  v[n]; //访问下标存储的数据\n  v2=v1 ;//v1拷贝到v2\n  v1 ={a,b,c.....} //重新赋值\n  v1 == v2 ;//时候绝对的相等，长度和内容\n  <>= //顾名思义按照字典序进行比较\n  v1!=v2;\n  ```\n\n- 无法访问索引外数据，编译期无法发现，但是运行期就会报错\n\n## 2.4. 迭代器的介绍\n\n除了vector之外，标准库还定义了其他容器，string也可以使用迭代器\n\n\nv.begin()返回第一位元素的指针,v.end()返回最后一个元素，注意end()返回的是空引用\n\n- 迭代器运算符包括  \n    |符号类型            |说明                               |\n    |------             |------                             |\n    |  *iter            | `(*it).empty()`,返回迭代器所指元素的引用,解引用未定义迭代器都是未定义的行为，可以修改引用真实数据|\n    |  item             |解引用iter并获取该元素的名为mem的成员变量，等价于(*iter).mem|\n    |  ++iter / --iter /[+-] n  |进行加减运算                |\n    |  iter==iter2      |判断两个迭代器                       |\n    |  iter1 != iter2   | 判断两个迭代器不等                  |\n    | <= ,>=            | 要求迭代器必须指向同一个容器          |\n\n    <details><summary>将字符串小写符转化为大写示例</summary>\n\n    ```cpp\n    string s(\"some string\");\n    if (s.begin() != s.end()){\n        auto it = s.begin();\n        *it = toUpper(*it);\n    }\n    ```\n\n    </details>\n\n    1. 迭代器类型支持了以上操作\n    2. 如果元素是常数则返回const_iterator,不是常数则返回iterator类型\n    3. it->mem和(＊it).mem表达的意思相同\n    4. 不能在范围for循环中向容器添加元素。**另外一个**限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该 vector对象的迭代器失效\n\n- 将迭代器的移动\n    <details><summary>迭代器移动示例</summary>\n\n    ```cpp\n    for (auto it = s.begin() ; it != it.end()&& !isUpper(*it); ++it){\n        *it = toUpper(*it);\n    }\n    ```\n\n- 泛型编程  \n    泛型编程更像一种高度抽象数据结构的能力\n\n- begin()和end()函数  \n    如果元素是常数则返回const_iterator,不是常数则返回iterator类型\n\n\n    </details>\n\n## 2.5 数组\n如果不清楚元素的确切个数,请使用vector,数组的大小确定不变,不能随意向数组中增加元素.因为数组的大小固定,因此对某些特殊的应用来说程序的运行时性能较好,但是相应地也损失了一些灵活性.\n\n### 2.5.1 定义和初始化内置数组\n\n1. 显示初始化数组\n    <details>\n    <summary>数组初始化示例</summary>\n    ```cpp\n    const unsigned sz=3; 定义常量\n    int ia1 = {0,1，2};\n    int a2[] = {0,1,2};\n    int a3[5]= {0,1,2};\n    string a4[] = {\"hi\",\"byte\"};\n    int a5[2] = {0,1,2}  //错误，超出容量\n    ```\n\n    </details>\n2.  字符数组的特殊性\n\n    <details>\n    <summary>字符数组特殊性初始化示例</summary>\n\n    ```cpp\n    char a1[] = {'c','+','+'};\n    char a2[] = {'c','+','+','\\0'}; //显示胡世华空字符\n    char a3[] = \"C++\"; //自动初始化空字符\n    const a4[6]  = \"Daneil\"  //错误没有空间存放空字符\n\n    ```\n\n    </details>\n3. 不允许拷贝赋值\n\n    <details>\n    <summary>不允许拷贝赋值示例</summary>\n\n    ```cpp\n    int a[] = {0,1,2} //含有三个元素的数组\n    int a2[] = a1; // 错误: 不允许使用一个数组给另一个数组进行初始化\n        a2 = a1 //错误: 不允许两个数组之间直接赋值计算\n \n    ```\n\n    </details>\n\n4. 复杂数组声明\n    <details>\n    <summary>复杂数组声明示例</summary>\n\n    ```cpp\n    int *ptrs[10]  // 指向含有10个整型指针的数组\n    int &refs[10] =/*?*/ //不存在引用的数组\n    int (*Parrary)[10] = &arr; // 指向一个含有是个个整数的数组\n    int (&arrRef)[10] = arr ; //arrRef 引用指向一个含有是个整数的数组\n    int *(&arry)[10] = ptrs ; // 首先知道arry是一个引用，然后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用\n    ```\n\n    </details>\n\n### 2.5.2 访问数组元素\n\n1. 在使用数组下标的时候，通常将其定义为size_t类型\n2. 检查下标的值, CPP要检查数组下标\n\n### 2.5.3 指针和数组\n\n1. 通过取地址符号获取地址\n\n    ```cpp\n    string nums = {\"one\",\"two\",\"three\"};\n    string *p = &nums[0];  //  等价于    string *p2=nums;\n    ```\n\n    其中一层意思就是当使用数组作为`auto`变量初始值的时候，推断出的是指针而非数组，显然是`auto ia2(&ia[0])`;但是使用decltype(ia)返回的类型是由10个整数构成的数组\n\n    ```cpp\n    decltype(ia) ia3 = {0,1,2,3,4} ;\n     ia3 =p ;//错误:不能把整型指针给数组赋值， \n     ia3[4] = i;//正确: 把整数i赋值给ia3的一个元素\n    ```\n\n2. 指针也是迭代器,可以进行整型运算\n    获取数组的指针后就可以通过`加/减`计算指针的值,获取指针的最后一个元素地址 `&arr[n]` ,这个表示arr的长度。针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。两个指针相减的结果的类型是一种名为`ptrdiff_t`的标准库类型，和`size_t`一样，`ptrdiff_t`也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型,两指针不指向头一个对象而进行`加/减`没有意义\n3. 标准库函数begin()和end()\n\n    ```cpp\n    int arr[] ={0,1,2,3,4,5};\n    int *head = begin(arr);\n    int *tail = end(arr);\n\n    ```\n\n4. 指针解引用的运算\n\n    ```cpp\n    int arr[] = {0,1,2,3};\n    int last =*(arr + 3);\n    last = *last + 4; //是解引用last然后加4\n    int k = p[-2] // 数组下标运算可以处理负值\n    vector<T> //下标运算不能为负值，是无符号类型\n    ```\n\n### 2.5.4 C风格字符串  \n\n- 支持C风格运算函数，比较字符串时候,比较第一个不相同字符的ASCII码值\n- 如果是两个字符串字面量可以用`+`进行拼接，但是如果是两个指针就需要用函数进行拼接\n    `strcpy(str,ca1)` //把ca1复制给str,一定要注意str的容量  \n    `strcat(str,\"\")` //str是字符串数组  \n    `strcat(str,ca2)` // 将ca2和str继续拼接v  \n\n### 2.5.5 与旧代码的接口,兼容C代码\n\n1. 混合string对象和C风格字符串\n    `string s(\"hello world\");`//也允许空字符串初始化string字符串，在string对象的加法运算中允许使用以空字符结束的`字符数组`作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象.\n    无法用`string`对象初始化字符数组，除非使用`s.c_str()`函数`const char *str = s.c_str();`\n2. 使用数组初始化vector对象\n\n- 不允许使用一个`数组`给另一个`内置类型数组`初始化  \n- `vector`允许给`数组`初始化  \n- 但是`数组`却可以给vector 进行初始化,可以是相等元素数量进行赋值，也可以是部分元素数量给`vector`赋值\n\n建议：尽量使用标准库类型而非数组,应该尽量使用string，避免使用C风格的基于数组的字符串\n\n## 2.6 多维数组\n\n```cpp\nint ia[10][10] ; //多维数组\nint ia[10][10] = {0} ;//将所有元素都初始化为0\n// 从左往右理解，定义了一个十个元素的数组，每个元素里面又能容纳一个是元素的数组。\n```\n\n### 2.6.1 多维数组初始化\n\n```cpp\n/*----1-----*/\n//二维数组分别初始化\nint ia[3][4] = {\n    {1,2,3,0},\n    {4,5,6,0},\n    {7,8,9,0}\n};\n\n/*----2----*/\nint ia[3][4] = {0,1,2,3,4,5,6};//这种初始化方式是等价的，但是并不会把所有元素都初始化\n\n/*----3----*/\n//显示缺省\nint ia[3][4] = {\n    {1},\n    {4},\n    {7}\n};\n/*----4----*/\n// 只是初始化第一行\nint ia[3][4] = {\n  0,1,2,3\n};\n```\n\n### 2.6.2 多维数组的下标引用\n\n说白了就是可以通过下标运算符进行取值，如果是三维数组，而用了两个下标运算符那么就会取出**数组**\n\n### 2.6.3 使用范围for语句处理多维数组\n\n看如下例子,因为程序要改变数组中的值，所以要使用`引用`进行赋值。\n```cpp\nsize_t = 0;\nfor (auto &row : ia){  // row其实是数组的引用\n    for(auto &col :row){ // col其实是整数的引用\n                col = cnt;\n            ++cnt;\n    }\n}\n```\n\n而如下例子代码是错的,编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）\n,转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊\n\n```cpp\nfor (auto row : ia){ \n    for (auto col :row){\n\n    }\n}\n```\n\n### 2.6.4 指针和多维数组\n\n定义数组的时候千万别忘了这是数组的数组,所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针,例如  \n\n```cpp\nint ia[3][4];\nint (*p)[4] = ia; //p 是指向四个整数的数组\nint *p[4] ;//整形指针数组\np = &ia[2] ;//p指向ia的尾元素\n\n```\n\n在C++11标准中使用`auto`和`decltype`就能避免在数组前面加一个指针类型，例子如下  \n \n```cpp\n    for (auto p = ia ;p!=ia+3; ++p){\n        for (auto q = *p; q!= *p +4 ; ++q){\n            cout << *q << '' ;\n        }\n        cout << endl;\n    }\n\n```\n\n它首先令指针q指向p当前所在行的第一个元素,然后再一次`解引用`指向内层的数组的首元素，然后终止条件为`+4`,当然也可以使用标准函数`begin()`和`end()`实现相同的效果\n\n```cpp\n    for (auto p = begin(ia) ; p!=end(ia);++ia ){\n        for (auto q = begin(*p); q!=end(*p);++q){\n            cout<< *q << '' ;\n        }\n        cout<< endl; \n    }\n\n```\n\n### 2.6.5 类型别名简化多维数组的指针\n\n使用`类型别名`可以简化工作  \n```cpp\nusing int_array  = int[3]; //新标准下的写法\ntypedef int int[4] ;//等价的typedef声明\nfor (int_array *p = ia ; p!= ia +3 ; ++p){\n    for( int *q = *p ; q!= *p +3 ; ++q){\n        cout<< *q << '' ; \n    }\n    cout << endl ; \n}\n\n```\n程序将类型“四个整数组成的数组”命名为int_array,用类型名int_array定义外层循环`控制变量`更加简洁\n\n### 2.6.6 术语表\n\n|术语|解释|\n|---|---|\n|begin |是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。|\n|缓冲区溢出（buffer overflow）|一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等|\n|C风格字符串（C-style string）|以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错|\n|类模板（class template）|用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个vector对象需要指定元素的类型：`vector<int>`包含int类型的元素。|\n|编译器扩展（compiler extension）|某个特定的编译器为C++语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上|\n|容器（container） |是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。|\n|容器（container） |是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。|\n|difference_type | 由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。|\n|直接初始化（direct initialization）| 不使用赋值号（=）的初始化形式|\n|empty() | 是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假。|\n|end() |是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针。|\n|getline | 在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留。|\n|索引（index） | 是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置。|\n|实例化（instantiation） | 编译器生成一个指定的模板类或函数的过程。|\n|迭代器（iterator）| 是一种类型，用于访问容器中的元素或者在元素之间移动。|\n|迭代器运算（iterator arithmetic） | 是string或vector的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置。|\n|以空字符结束的字符串（null-terminated string）|  是一个字符串，它的最后一个字符后面还跟着一个空字符（'\\0'）。|\n|prtdiff_t |是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。|\n|push_back |是vector的成员，向vector对象的末尾添加元素。|\n| 范围for语句（range for）|  一种控制语句，可以在值的一个特定集合内迭代。|\n|size | 是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type。| \n|size_t |是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小。|\n|size_type |是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型。|\n|string |是一种标准库类型，表示字符的序列。|\n|using声明（using declaration）| 令命名空间中的某个名字可被程序直接使用。using 命名空间 ：： 名字；上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分命名空间：：。|\n|值初始化（value initialization） |是一种初始化过程。内置类型初始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值|\n|vector |是一种标准库类型，容纳某指定类型的一组元素。|\n|++运算符（++ operator）| 是迭代器和指针定义的递增运算符。执行“加1”操作使得迭代器指向下一个元素。|\n|[ ]运算符（[ ] operator）|下标运算符。obj[j]得到容器对象obj中位置j的那个元素。索引从0开始，第一个元素的索引是0，尾元素的索引是obj.size（）-1。下标运算符的返回值是一个对象。如果p是指针、n是整数，则p[n]与＊（p+n）等价。|\n|->运算符（->operator）| 箭头运算符，该运算符综合了解引用操作和点操作。a->b等价于（＊a）.b。|\n<<运算符`（<<operator）`|标准库类型string定义的输出运算符，负责输出string对象中的字符。|\n|>>运算符`（>>operator）`|标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个string对象。|\n|！运算符（！ operator）|逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假。|\n|&&运算符（&&operator）| 逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象。|\n| ||运算符（|| operator）| 逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象。|\n\n\n# 3. CPP流程控制\n\n- 如果标准输入输出作为`if`,`while`条件，读到文件结束符判断假，或者是无效输入\n\n1. windows : Ctrl+Z (文件结束符)\n2. linux : Ctrl+D (文件结束符)\n\n# 4. 函数\n\n- 函数的调用\n  - 传值\n  - 传引用\n\n- 参数默认值\n- Lambda表达式\n\n```cpp\n[](int x, int y) -> int { int z = x + y; return z + x; }\n```\n\n```\n[]      // 沒有定义任何变量。使用未定义变量会引发错误。\n[x, &y] // x以传值方式传入（默认），y以引用方式传入。\n[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。\n[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。\n[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n```\n\n- 引用\n实际上是已知变量的另一个名字。\n\n```\nint&  r = i;\n```\n\n- 标准IO\n通过(std::)方式调用标准函数库，或者在函数头写`using namespace std`\n\n```cpp\n#include <iostream>\n \nusing namespace std;\n \nint main( )\n{\n   char name[50];\n \n   cout << \"请输入您的名称： \";\n   cin >> name;\n   cout << \"您的名称是： \" << name << endl;\n   cerr << \"Error message : \" << str << endl;\n   clog << \"Error message : \" << str << endl;\n}\n```\n\n## 4.1. struct构造初始化\n\n- 利用自带默认构造函数\n- 参数构造\n- 自定义void init(.....){ ... this->  ...}\n在建立结构体数组时,如果只写了带参数的构造函数将会出现数组无法初始化的错误！！！各位同学要牢记呀！！！\n\n```cpp\n\nstruct node{\n int data;\n string str;\n char x;\n //自己写的初始化函数\n void init(int a, string b, char c){\n  this->data = a;\n  this->str = b;\n  this->x = c;\n }\n node() :x(), str(), data(){}\n node(int a, string b, char c) :x(c), str(b), data(a){}\n}N[10];\n```\n\n# 5. 面向对象编程\n\n- #include指令使用（<>）导入标准库函数，非标准库用双引号（\" \"）。\n\n<details>\n<summary>类示例demo</summary>\n\n```cpp\n#include <iostream>\n#include \"Books\"\nusing namespace std;\n \nclass Box\n{\n   private:\n   \n   protected:\n   \n   public:\n      char  title[50];\n      char  author[50];\n      char  subject[100];\n      int   book_id;\n      double length;   // 长度\n      double breadth;  // 宽度\n      double height;   // 高度\n      // 成员函数声明，但是没有实现\n      double get(void);\n      void set( double len, double bre, double hei );\n      \n};\n// 成员函数定义\ndouble Box::get(void)\n{\n    return length * breadth * height;\n}\n \nvoid Box::set( double len, double bre, double hei)\n{\n    length = len;\n    breadth = bre;\n    height = hei;\n}\nint main( )\n{\n   Box Box1;        // 声明 Box1，类型为 Box\n   Box Box2;        // 声明 Box2，类型为 Box\n   Box Box3;        // 声明 Box3，类型为 Box\n   double volume = 0.0;     // 用于存储体积\n \n   // box 1 详述\n   Box1.height = 5.0; \n   Box1.length = 6.0; \n   Box1.breadth = 7.0;\n \n   // box 2 详述\n   Box2.height = 10.0;\n   Box2.length = 12.0;\n   Box2.breadth = 13.0;\n \n   // box 1 的体积\n   volume = Box1.height * Box1.length * Box1.breadth;\n   cout << \"Box1 的体积：\" << volume <<endl;\n \n   // box 2 的体积\n   volume = Box2.height * Box2.length * Box2.breadth;\n   cout << \"Box2 的体积：\" << volume <<endl;\n \n \n   // box 3 详述\n   Box3.set(16.0, 8.0, 12.0); \n   volume = Box3.get(); \n   cout << \"Box3 的体积：\" << volume <<endl;\n   return 0;\n}\n```\n\n</details>\n\n- CPP支持文件重定向`$ addItems <infile >outfile` 可直接从文件读数据然后计算\n\n<details>\n  <summary>文件重定向Sales_item代码</summary>\n <blockcode>\n\n ```cpp\n  /*\n * This file contains code from \"C++ Primer, Fifth Edition\", by Stanley B.\n * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the\n * copyright and warranty notices given in that book:\n * \n * \"Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.\"\n * \n * \n * \"The authors and publisher have taken care in the preparation of this book,\n * but make no expressed or implied warranty of any kind and assume no\n * responsibility for errors or omissions. No liability is assumed for\n * incidental or consequential damages in connection with or arising out of the\n * use of the information or programs contained herein.\"\n * \n * Permission is granted for this code to be used for educational purposes in\n * association with the book, given proper citation if and when posted or\n * reproduced.Any commercial use of this code requires the explicit written\n * permission of the publisher, Addison-Wesley Professional, a division of\n * Pearson Education, Inc. Send your request for permission, stating clearly\n * what code you would like to use, and in what specific way, to the following\n * address: \n * \n *     Pearson Education, Inc.\n *     Rights and Permissions Department\n *     One Lake Street\n *     Upper Saddle River, NJ  07458\n *     Fax: (201) 236-3290\n*/ \n\n/* This file defines the Sales_item class used in chapter 1.\n * The code used in this file will be explained in\n * Chapter 7 (Classes) and Chapter 14 (Overloaded Operators)\n * Readers shouldn't try to understand the code in this file\n * until they have read those chapters.\n*/\n\n#ifndef SALESITEM_H\n// we're here only if SALESITEM_H has not yet been defined \n#define SALESITEM_H\n\n// Definition of Sales_item class and related functions goes here\n#include <iostream>\n#include <string>\n\nclass Sales_item {\n// these declarations are explained section 7.2.1, p. 270 \n// and in chapter 14, pages 557, 558, 561\nfriend std::istream& operator>>(std::istream&, Sales_item&);\nfriend std::ostream& operator<<(std::ostream&, const Sales_item&);\nfriend bool operator<(const Sales_item&, const Sales_item&);\nfriend bool \noperator==(const Sales_item&, const Sales_item&);\npublic:\n    // constructors are explained in section 7.1.4, pages 262 - 265\n    // default constructor needed to initialize members of built-in type\n    Sales_item() = default;\n    Sales_item(const std::string &book): bookNo(book) { }\n    Sales_item(std::istream &is) { is >> *this; }\npublic:\n    // operations on Sales_item objects\n    // member binary operator: left-hand operand bound to implicit this pointer\n    Sales_item& operator+=(const Sales_item&);\n    \n    // operations on Sales_item objects\n    std::string isbn() const { return bookNo; }\n    double avg_price() const;\n// private members as before\nprivate:\n    std::string bookNo;      // implicitly initialized to the empty string\n    unsigned units_sold = 0; // explicitly initialized\n    double revenue = 0.0;\n};\n\n// used in chapter 10\ninline\nbool compareIsbn(const Sales_item &lhs, const Sales_item &rhs) \n{ return lhs.isbn() == rhs.isbn(); }\n\n// nonmember binary operator: must declare a parameter for each operand\nSales_item operator+(const Sales_item&, const Sales_item&);\n\ninline bool \noperator==(const Sales_item &lhs, const Sales_item &rhs)\n{\n    // must be made a friend of Sales_item\n    return lhs.units_sold == rhs.units_sold &&\n           lhs.revenue == rhs.revenue &&\n           lhs.isbn() == rhs.isbn();\n}\n\ninline bool \noperator!=(const Sales_item &lhs, const Sales_item &rhs)\n{\n    return !(lhs == rhs); // != defined in terms of operator==\n}\n\n// assumes that both objects refer to the same ISBN\nSales_item& Sales_item::operator+=(const Sales_item& rhs) \n{\n    units_sold += rhs.units_sold; \n    revenue += rhs.revenue; \n    return *this;\n}\n\n// assumes that both objects refer to the same ISBN\nSales_item \noperator+(const Sales_item& lhs, const Sales_item& rhs) \n{\n    Sales_item ret(lhs);  // copy (|lhs|) into a local object that we'll return\n    ret += rhs;           // add in the contents of (|rhs|) \n    return ret;           // return (|ret|) by value\n}\n\nstd::istream& \noperator>>(std::istream& in, Sales_item& s)\n{\n    double price;\n    in >> s.bookNo >> s.units_sold >> price;\n    // check that the inputs succeeded\n    if (in)\n        s.revenue = s.units_sold * price;\n    else \n        s = Sales_item();  // input failed: reset object to default state\n    return in;\n}\n\nstd::ostream& \noperator<<(std::ostream& out, const Sales_item& s)\n{\n    out << s.isbn() << \" \" << s.units_sold << \" \"\n        << s.revenue << \" \" << s.avg_price();\n    return out;\n}\n\ndouble Sales_item::avg_price() const\n{\n    if (units_sold) \n        return revenue/units_sold; \n    else \n        return 0;\n}\n#endif\n```\n\n </blockcode>\n</details>\n\n```cpp\n#include <iostream>\n#include \"Sales_item.cc\"\n\n \nusing namespace std;\nint main() \n{\n    Sales_item item1, item2;\n\n    std::cin >> item1 >> item2;   //read a pair of transactions\n    std::cout << item1 + item2 << std::endl; //print their sum\n\n    return 0;\n}\n```\n\n## 5.1. 继承与多继承\n\n```cpp\n#include <iostream>\n \nusing namespace std;\n \n// 基类\nclass Shape \n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n \n// 派生类, 多继承就是写成 class Rectangle: public Shape, public square { ... }\nclass Rectangle: public Shape\n{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }\n};\n \nint main(void)\n{\n   Rectangle Rect;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n \n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n \n   return 0;\n}\n```\n\n访问   | public | protected | private |\n| ---- | ------ | --------- | ------- |\n| 同一个类 | yes    | yes   | yes |\n| 派生类  | yes    | yes    | no  |\n| 外部的类 | yes    | no    | no |\n\n一个派生类继承了所有的基类方法，但下列情况除外：\n\n- 基类的构造函数、析构函数和拷贝构造函数。\n- 基类的重载运算符。\n- 基类的友元函数。\n\n我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：\n\n- **公有继承（public）：** 当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。\n- **保护继承（protected）：**  当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。\n- **私有继承（private）：** 当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。\n\n## 5.3. 函数，运算符重载\n\n- 函数签名不同的叫函数重载\n- 运算符重载\n\n```cpp\n类成员函数\nBox operator+(const Box&);\n```\n\n```cpp\n类的非成员函数\nBox operator+(const Box&, const Box&);\n\n```\n\n## 5.4. 多态\n\n如果对象具有继承关系，那么CPP会更具具体的对象类型调用具体的成员函数长度\n\n## 5.5. CPP接口\n\n```cpp\nclass Box\n{\n   public:\n      // 纯虚函数\n      virtual double getVolume() = 0;\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度\n};\n```\n\n实现类必须要实现抽象安徽念书(虚函数)\n","slug":"C++_Primer","published":1,"date":"2022-06-21T17:01:03.344Z","updated":"2022-09-06T11:23:42.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5c0001l1db8w7g62tt","content":"<ul>\n<li><a href=\"#1-%E5%8F%98%E9%87%8F%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\">1. 变量及基本类型</a><ul>\n<li><a href=\"#11-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B\">1.1 基本内置类型</a><ul>\n<li><a href=\"#111-%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B\">1.1.1 算术类型</a></li>\n<li><a href=\"#112-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\">1.1.2 类型转换</a></li>\n<li><a href=\"#113-%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F\">1.1.3 字面常量</a></li>\n</ul>\n</li>\n<li><a href=\"#12-%E5%8F%98%E9%87%8F\">1.2. 变量</a><ul>\n<li><a href=\"#121-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89\">1.2.1 变量定义</a></li>\n<li><a href=\"#122-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB\">1.2.2 变量声明和定义的关系</a></li>\n<li><a href=\"#123-%E5%90%8D%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">1.2.3 名字的作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#13-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B\">1.3. 复合类型</a></li>\n<li><a href=\"#14-cpp%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8Cconst%E9%99%90%E5%AE%9A%E7%AC%A6\">1.4. CPP修饰符和const限定符</a></li>\n<li><a href=\"#15-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B\">1.5. 处理类型</a></li>\n<li><a href=\"#16-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">1.6. 自定义数据结构</a></li>\n<li><a href=\"#17-cpp%E5%AD%98%E5%82%A8%E7%B1%BB%E5%BE%85%E9%87%8D%E6%96%B0%E6%8B%9F%E9%A2%98\">1.7 CPP存储类[待重新拟题]</a></li>\n</ul>\n</li>\n<li><a href=\"#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E6%95%B0%E7%BB%84\">2. 字符串，向量，数组</a><ul>\n<li><a href=\"#21-using%E5%85%B3%E9%94%AE%E5%AD%97\">2.1. using关键字</a></li>\n<li><a href=\"#22-string-%E7%B1%BB%E5%9E%8B\">2.2. string 类型</a></li>\n<li><a href=\"#23-vector%E7%B1%BB%E5%9E%8B\">2.3. vector类型</a></li>\n<li><a href=\"#24-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D\">2.4. 迭代器的介绍</a></li>\n<li><a href=\"#25-%E6%95%B0%E7%BB%84\">2.5 数组</a><ul>\n<li><a href=\"#251-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84\">2.5.1 定义和初始化内置数组</a></li>\n<li><a href=\"#252-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0\">2.5.2 访问数组元素</a></li>\n<li><a href=\"#253-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84\">2.5.3 指针和数组</a></li>\n<li><a href=\"#254-c%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2\">2.5.4 C风格字符串</a></li>\n<li><a href=\"#255-%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%85%BC%E5%AE%B9c%E4%BB%A3%E7%A0%81\">2.5.5 与旧代码的接口,兼容C代码</a></li>\n</ul>\n</li>\n<li><a href=\"#26-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">2.6 多维数组</a><ul>\n<li><a href=\"#261-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96\">2.6.1 多维数组初始化</a></li>\n<li><a href=\"#262-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8\">2.6.2 多维数组的下标引用</a></li>\n<li><a href=\"#263-%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">2.6.3 使用范围for语句处理多维数组</a></li>\n<li><a href=\"#264-%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">2.6.4 指针和多维数组</a></li>\n<li><a href=\"#265-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88\">2.6.5 类型别名简化多维数组的指针</a></li>\n<li><a href=\"#266-%E6%9C%AF%E8%AF%AD%E8%A1%A8\">2.6.6 术语表</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#3-cpp%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6\">3. CPP流程控制</a></li>\n<li><a href=\"#4-%E5%87%BD%E6%95%B0\">4. 函数</a><ul>\n<li><a href=\"#41-struct%E6%9E%84%E9%80%A0%E5%88%9D%E5%A7%8B%E5%8C%96\">4.1. struct构造初始化</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\">5. 面向对象编程</a><ul>\n<li><a href=\"#51-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E7%BB%A7%E6%89%BF\">5.1. 继承与多继承</a></li>\n<li><a href=\"#53-%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">5.3. 函数，运算符重载</a></li>\n<li><a href=\"#54-%E5%A4%9A%E6%80%81\">5.4. 多态</a></li>\n<li><a href=\"#55-cpp%E6%8E%A5%E5%8F%A3\">5.5. CPP接口</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"1-变量及基本类型\"><a href=\"#1-变量及基本类型\" class=\"headerlink\" title=\"1. 变量及基本类型\"></a>1. 变量及基本类型</h1><ol>\n<li><p><code>g++ -o hello_world  -std=c++11  hello_world.cpp</code><br>将源代码cpp文件编程成二进制程序,并支持C++11</p>\n</li>\n<li><p>CPP保留字</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>asm</td>\n<td>else</td>\n<td>new</td>\n<td>this &#x2F; 自身地址</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>enum</td>\n<td>operator</td>\n<td>throw</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>explicit</td>\n<td>private</td>\n<td>true &#x2F; 真 &#x2F; 0</td>\n</tr>\n<tr>\n<td>break</td>\n<td>export</td>\n<td>protected</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>extern</td>\n<td>public</td>\n<td>typedef &#x2F; 别名定义</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>false</td>\n<td>register</td>\n<td>typeid</td>\n</tr>\n<tr>\n<td>char</td>\n<td>float &#x2F;单精度</td>\n<td>reinterpret_cast</td>\n<td>typename</td>\n</tr>\n<tr>\n<td>class</td>\n<td>for</td>\n<td>return</td>\n<td>union</td>\n</tr>\n<tr>\n<td>const</td>\n<td>friend</td>\n<td>short</td>\n<td>unsigned &#x2F; 无符号</td>\n</tr>\n<tr>\n<td>const_cast</td>\n<td>goto</td>\n<td>signed &#x2F; 有符号</td>\n<td>using &#x2F; 使用命名空间</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>if</td>\n<td>sizeof</td>\n<td>virtual</td>\n</tr>\n<tr>\n<td>default</td>\n<td>inline</td>\n<td>static</td>\n<td>void &#x2F; 空类型</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>int</td>\n<td>static_cast</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>do</td>\n<td>long</td>\n<td>struct</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>double</td>\n<td>mutable</td>\n<td>switch &#x2F;</td>\n<td>while &#x2F; 循环</td>\n</tr>\n<tr>\n<td>dynamic_cast</td>\n<td>namespace</td>\n<td>template</td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>typedef声明</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">short</span> <span class=\"token keyword\">int</span> s_int<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> feet<span class=\"token punctuation\">;</span>\nfeet distance <span class=\"token comment\">//合法声明</span></code></pre>\n</li>\n<li><p>枚举类型<br>所谓”枚举”是指将变量的值一一列举出来，变量赋值时候只能是特定的变量才能赋值</p>\n<details><summary>枚举类型demo</summary>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">\n<span class=\"token keyword\">enum</span> 枚举名<span class=\"token punctuation\">&#123;</span> \n    标识符<span class=\"token punctuation\">[</span><span class=\"token operator\">=</span>整型常数<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> \n    标识符<span class=\"token punctuation\">[</span><span class=\"token operator\">=</span>整型常数<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> \n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n    标识符<span class=\"token punctuation\">[</span><span class=\"token operator\">=</span>整型常数<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span> 枚举变量<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//举例子</span>\n<span class=\"token keyword\">enum</span>  <span class=\"token class-name\">color</span><span class=\"token punctuation\">&#123;</span> red <span class=\"token punctuation\">,</span> yellow <span class=\"token punctuation\">,</span>blue<span class=\"token punctuation\">&#125;</span> c\nc <span class=\"token operator\">=</span> blue \n<span class=\"token comment\">//默认情况下，是从0开始初始化</span>\n</code></pre>\n\n</details>\n</li>\n<li><p>三字符组</p>\n<p>以前为了表示键盘上没有的字符</p>\n<table>\n<thead>\n<tr>\n<th>字符串</th>\n<th>转义后的含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>??&#x3D;</td>\n<td>#</td>\n</tr>\n<tr>\n<td>??(</td>\n<td>[</td>\n</tr>\n<tr>\n<td>??)</td>\n<td>]</td>\n</tr>\n<tr>\n<td>??&#x2F;</td>\n<td>\\</td>\n</tr>\n<tr>\n<td>??&lt;</td>\n<td>{</td>\n</tr>\n<tr>\n<td>??&gt;</td>\n<td>}</td>\n</tr>\n<tr>\n<td>??’</td>\n<td>^</td>\n</tr>\n<tr>\n<td>??!</td>\n<td>|</td>\n</tr>\n<tr>\n<td>??-</td>\n<td>～</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h2 id=\"1-1-基本内置类型\"><a href=\"#1-1-基本内置类型\" class=\"headerlink\" title=\"1.1 基本内置类型\"></a>1.1 基本内置类型</h2><h3 id=\"1-1-1-算术类型\"><a href=\"#1-1-1-算术类型\" class=\"headerlink\" title=\"1.1.1 算术类型\"></a>1.1.1 算术类型</h3><p><code>整形（布尔/字符）</code>和<code>浮点型</code></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n<th>最小尺寸</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bool</td>\n<td>布尔类型</td>\n<td>4bit</td>\n</tr>\n<tr>\n<td>char</td>\n<td>字符</td>\n<td>8bit</td>\n</tr>\n<tr>\n<td>wchar_t</td>\n<td>宽字符</td>\n<td>16bit</td>\n</tr>\n<tr>\n<td>char16_t</td>\n<td>Unicode16</td>\n<td>16bit</td>\n</tr>\n<tr>\n<td>char32_t</td>\n<td>Unicode32</td>\n<td>32bit</td>\n</tr>\n<tr>\n<td>short</td>\n<td>短整型</td>\n<td>2个字节,16bit</td>\n</tr>\n<tr>\n<td>int</td>\n<td>整型</td>\n<td>4个字节,32bit</td>\n</tr>\n<tr>\n<td>long</td>\n<td>长整型</td>\n<td>32bit</td>\n</tr>\n<tr>\n<td>long long</td>\n<td>长整型</td>\n<td>64bit,8字节</td>\n</tr>\n<tr>\n<td>float</td>\n<td>单精度</td>\n<td>32bit,6位有效数字</td>\n</tr>\n<tr>\n<td>double</td>\n<td>双精度</td>\n<td>64bit,10位有效数字</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>扩展精度</td>\n<td>128bit,10位有效数字</td>\n</tr>\n</tbody></table>\n<ol>\n<li>一个char应可以存机器基本字符集中任意字符对应的数字值,其他字符集可以用<code>wchar_t</code>-可以扩展字符集任意字符,<code>char16_t</code>,<code>char32_t</code>-他俩则是扩展Unicode字符标准</li>\n<li>8比特等于一个字节，四个字节等于一个字符</li>\n<li>内置类型的机器实现之address地址,就是一串数字,跟着其存储(8比特)内容</li>\n<li>带符号类型和无符号类型<br><code>short</code>,<code>int</code>,<code>long</code> ,<code>long long</code> 都有<code>unsigned</code>类型。<code>char</code>,<code>signed char</code>和<code>unsigned char</code>,虽然表现是三种，但是只有两种，<code>char</code>具体表现为哪种，要看编译器</li>\n</ol>\n<ul>\n<li>如何选择类型<ol>\n<li>数值不可能为负时，用无符号类型</li>\n<li>超过了int范围，选用long long</li>\n<li>因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的。所以如果你需要使用一个不大的整数，应指定是使用unsigned char 还是signed char</li>\n<li>float 和double在计算上没差别，但是long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"1-1-2-类型转换\"><a href=\"#1-1-2-类型转换\" class=\"headerlink\" title=\"1.1.2 类型转换\"></a>1.1.2 类型转换</h3><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> b <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// i的值为1</span>\ni<span class=\"token operator\">=</span> <span class=\"token number\">3.14</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">//i的值为3</span>\n<span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> i <span class=\"token punctuation\">;</span><span class=\"token comment\">//pi的值为3.0</span>\n<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> c <span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//假设char占8比特,c的值在255,被转换</span>\n<span class=\"token keyword\">signed</span> <span class=\"token keyword\">char</span> c2 <span class=\"token operator\">=</span> <span class=\"token number\">256</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 假设char占8比特，c2的值是未定义</span></code></pre>\n\n<ol>\n<li>int -&gt; bool &#x2F;&#x2F; 0是假，1是真  </li>\n<li>bool -&gt; int &#x2F;&#x2F; false是0，真是1  </li>\n<li>float -&gt; int &#x2F;&#x2F; 只保留整数位  </li>\n<li>int -&gt; float &#x2F;&#x2F; 小数位填0  </li>\n<li>signed -&gt; unsigned &#x2F;&#x2F;符号位当成数值位转换为十进制<code>1000 0001</code>，反码为<code>1111 1110</code>，补码为<code>1111 1111(signed char)</code>,然后转换为unsigned char  <code>1111 1111</code>,十进制是<code>255</code>，或者<code>-1 + 256 mod 256 = 255</code>,如第六行代码.</li>\n<li>当我们赋给<code>符号类型</code>一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据<blockquote>\n<p>建议：避免无法预知和依赖于实现环境的行为</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><p>含有无符号类型的表达式  </p>\n<p>  例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样:</p>\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">unsigned</span> u <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i  <span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\ncout<span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">+</span> i <span class=\"token operator\">&lt;&lt;</span> endl <span class=\"token punctuation\">;</span> <span class=\"token comment\">//-84</span>\ncout <span class=\"token operator\">&lt;&lt;</span> u <span class=\"token operator\">+</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出结果4294967264</span></code></pre>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span>i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span>  i <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span>i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// 永远不会退出循环,其实是没设计好这个for statement,unsigned同样道理</span></code></pre>\n\n<p>  可以用下面语句带题</p>\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">unsigned</span> u <span class=\"token operator\">=</span><span class=\"token number\">11</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>u<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">--</span>u<span class=\"token punctuation\">;</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout<span class=\"token operator\">&lt;&lt;</span> u <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<blockquote>\n<p>提示:避免<code>signed</code>与<code>unsigned</code>混合运算，会将<code>signed</code>转换为<code>unsigned</code>类型</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"1-1-3-字面常量\"><a href=\"#1-1-3-字面常量\" class=\"headerlink\" title=\"1.1.3 字面常量\"></a>1.1.3 字面常量</h3><p>例如<code>42</code>就是字面值常量,整型,浮点,字符,字符串字面值</p>\n<ul>\n<li><p>以0开头的整数代表八进制数  </p>\n</li>\n<li><p>以0x或0X开头的代表十六进制数  </p>\n<table>\n<thead>\n<tr>\n<th>字面值</th>\n<th>类型说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>20</td>\n<td>&#x2F;&#x2F; decimal十进制</td>\n</tr>\n<tr>\n<td>024</td>\n<td>&#x2F;&#x2F;octal八进制</td>\n</tr>\n<tr>\n<td>0X14</td>\n<td>&#x2F;&#x2F; hexadecimal 十六进制</td>\n</tr>\n<tr>\n<td>128u ,128U</td>\n<td>&#x2F;&#x2F; unsigned 十进制</td>\n</tr>\n<tr>\n<td>1024UL or 8LU</td>\n<td>&#x2F;&#x2F; unsigned long</td>\n</tr>\n<tr>\n<td>1024ULL or 8LLU</td>\n<td>&#x2F;&#x2F; unsigned long long</td>\n</tr>\n<tr>\n<td>1L</td>\n<td>&#x2F;&#x2F; long 长整形</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误  </p>\n</li>\n<li><p>3.14159,3.14159E0,0.,0e0,.001  </p>\n<table>\n<thead>\n<tr>\n<th>字面值</th>\n<th>类型说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3.14159F &#x3D; 3.14159E0F</td>\n<td>&#x2F;&#x2F; float ,科学计数</td>\n</tr>\n<tr>\n<td>.001f &#x3D; 1E-3F</td>\n<td>&#x2F;&#x2F; float,科学计数</td>\n</tr>\n<tr>\n<td>12.345L &#x3D; 1.2345E1L</td>\n<td>&#x2F;&#x2F; long double 扩展精度 ,科学计数</td>\n</tr>\n<tr>\n<td>0. &#x3D; 0e0</td>\n<td>&#x2F;&#x2F; double ,科学计数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>‘a’,’Hello World!’, 字符字面值,字符串字面值</p>\n<table>\n<thead>\n<tr>\n<th>字面值</th>\n<th>类型说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>‘a’</td>\n<td>&#x2F;&#x2F; char 字符</td>\n</tr>\n<tr>\n<td>L’a’</td>\n<td>&#x2F;&#x2F; wchar_t 宽字符</td>\n</tr>\n<tr>\n<td>u’a’</td>\n<td>&#x2F;&#x2F; char16_t 宽字符</td>\n</tr>\n<tr>\n<td>U’a’</td>\n<td>&#x2F;&#x2F; char32_t 宽字符</td>\n</tr>\n<tr>\n<td>u8”hi!”</td>\n<td>&#x2F;&#x2F;utf-8字符串类型,只支持字符串</td>\n</tr>\n<tr>\n<td>nullptr</td>\n<td>&#x2F;&#x2F;指针字面值</td>\n</tr>\n<tr>\n<td>‘A’</td>\n<td>&#x2F;&#x2F;表示单个字符A</td>\n</tr>\n<tr>\n<td>“A”</td>\n<td>&#x2F;&#x2F;表示字符A和空字符两个字符的字符串</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>转义序列</p>\n<table>\n<thead>\n<tr>\n<th>语义</th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\n</td>\n<td>换行</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>纵向制表</td>\n</tr>\n<tr>\n<td>\\|反斜线</td>\n<td></td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车符号</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>横向指标符号</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退表符号</td>\n</tr>\n<tr>\n<td>?</td>\n<td>问号</td>\n</tr>\n<tr>\n<td>\\a</td>\n<td>报警符号</td>\n</tr>\n<tr>\n<td>\\“</td>\n<td>双引号</td>\n</tr>\n<tr>\n<td>\\‘</td>\n<td>单引号</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>泛化的转义序列  </p>\n<ul>\n<li>(有需要再重点看)</li>\n<li>斜线\\后面跟着的八进制数字超过3个，只有前3个数字与\\构成转义序列。例如，”\\1234”表示2个字符，即八进制数123对应的字符以及字符4</li>\n<li>\\x要用到后面跟着的所有数字，例如，”\\x1234”表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定</li>\n</ul>\n</li>\n<li><p>指定字面值的类型<br>给字面值添加前后缀，可以改变其默认类型  </p>\n<table>\n<thead>\n<tr>\n<th>前缀</th>\n<th>含义</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u</td>\n<td>16字符</td>\n<td>char16_t</td>\n</tr>\n<tr>\n<td>U</td>\n<td>32字符</td>\n<td>char32_t</td>\n</tr>\n<tr>\n<td>L</td>\n<td>宽字符</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>u8</td>\n<td>UTF-8</td>\n<td>char,仅适用于字符串</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>最小匹配类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u or U</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>l or L</td>\n<td>long</td>\n</tr>\n<tr>\n<td>ll or LL</td>\n<td>long long</td>\n</tr>\n<tr>\n<td>f or F</td>\n<td>float</td>\n</tr>\n<tr>\n<td>l or L</td>\n<td>long double</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>布尔字面值<br><code>bool test = false</code></p>\n</li>\n</ul>\n<h2 id=\"1-2-变量\"><a href=\"#1-2-变量\" class=\"headerlink\" title=\"1.2. 变量\"></a>1.2. 变量</h2><h3 id=\"1-2-1-变量定义\"><a href=\"#1-2-1-变量定义\" class=\"headerlink\" title=\"1.2.1 变量定义\"></a>1.2.1 变量定义</h3><p><code>::</code> : 命名空间符号  </p>\n<ul>\n<li><p>默认值,初始值,和列表初始化 :  </p>\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> units_sold <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//列表初始化</span>\n<span class=\"token keyword\">int</span> units_sold<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 列表初始化</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">units_sold</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//直接初始化 </span></code></pre>\n</li>\n<li><p>全局变量默认值 : 在定义变量阶段如不指定会被指定默认值  </p>\n</li>\n<li><p>定义在函数体内部的<code>内置类型</code>变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的,如果试图拷贝或以其他形式访问此类值将引发错误.类自行决定初始化方式.绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值.如果一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误</p>\n</li>\n</ul>\n<h3 id=\"1-2-2-变量声明和定义的关系\"><a href=\"#1-2-2-变量声明和定义的关系\" class=\"headerlink\" title=\"1.2.2 变量声明和定义的关系\"></a>1.2.2 变量声明和定义的关系</h3><ul>\n<li>CPP支持分离式编译，也就是定义和声明分开  </li>\n<li>extern语句如果包含初始值就不再是声明，而变成定义了  </li>\n<li>变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明</li>\n</ul>\n<h3 id=\"1-2-3-名字的作用域\"><a href=\"#1-2-3-名字的作用域\" class=\"headerlink\" title=\"1.2.3 名字的作用域\"></a>1.2.3 名字的作用域</h3><ol>\n<li>局部变量，顾名思义，生命周期作用范围只在函数内,局部变量不会对变量进行初始化，全局变量才会初始化  </li>\n<li>全局变量，存活于程序整个生命周期,extern允许你在任意地方的声明一个变量或者函数，然后允许再任何地方进行定义。</li>\n<li>嵌套的作用域 <details>\n <summary>嵌套的作用域代码demo</summary>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token comment\">// Program for illustration purposes only: It is bad style for a function</span>\n<span class=\"token comment\">// to use a global variable and also define a local variable with the same name</span>\n\n<span class=\"token keyword\">int</span> reused <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// reused has global scope</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> unique <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// unique has block scope</span>\n\n    <span class=\"token comment\">// output #1: uses global reused; prints 42 0</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> reused <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> unique <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>   \n\n    <span class=\"token keyword\">int</span> reused <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// new, local object named reused hides global reused</span>\n\n    <span class=\"token comment\">// output #2: uses local reused; prints 0 0</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> reused <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span>  unique <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>  \n\n    <span class=\"token comment\">// output #3: explicitly requests the global reused; prints 42 0</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token double-colon punctuation\">::</span>reused <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span>  unique <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>  \n\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n </details>  \n\n output #3则是访问全局<code>reused</code>变量</li>\n</ol>\n<h2 id=\"1-3-复合类型\"><a href=\"#1-3-复合类型\" class=\"headerlink\" title=\"1.3. 复合类型\"></a>1.3. 复合类型</h2><p> 引用: 及别名</p>\n<ol>\n<li><code>int &amp;reference2</code> 报错，因为没有初始化，引用必须在定义时初始化.  </li>\n<li><code>int &amp;reference3 = reference</code>引用创建引用,reference是对象类型  </li>\n<li>将引用赋值给变量就是把引用的对象作为初始值</li>\n</ol>\n<p> 指针  </p>\n<ol>\n<li><p>块级作用域指针不被初始化也会拥有不确定值  </p>\n</li>\n<li><p><code>double *dp, *dp2</code>定义指针,访问无效指针后果无法预计</p>\n</li>\n<li><p><code>*dp = 0.0</code> 利用指针给对象赋值<br>建议<br>初始化所有定义的指针，切莫将变量直接赋值给指针,而是通过取地址符号,但是0可以直接赋值</p>\n</li>\n<li><p><code>void *</code>指针,其他任意指针都可以指向空指针,我们无法直接操作空指针</p>\n</li>\n<li><p>同时定义多个变量<code>int i=1024 , *p=&amp;i, &amp;q = i</code> , <code>int* p</code>合法容易但是产生误导</p>\n</li>\n<li><p>指向指针的指针,<code>int ival=400,int *p=&amp;ival, **pp=&amp;p</code>,同时,访问对象值,也需要解两次引用  </p>\n</li>\n<li><p>指向指针的引用  </p>\n  <details>\n  <summary>指向指针的引用demo</summary>\n\n   <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">&amp;</span>r<span class=\"token operator\">=</span>p<span class=\"token punctuation\">;</span>  \nr<span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>i <span class=\"token comment\">//取i地址，让r指向i,同时p也指向了i  </span>\n<span class=\"token operator\">*</span>r<span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token comment\">//给指针引用赋值，p指向的值也变了  </span></code></pre>\n\n   </details>\n</li>\n<li><p>指针的类型必须与其所指对象的类型一致，但是有两个例外  </p>\n<ul>\n<li>第一种例外情况是允许令一个指向常量的指针指向一个非常量对象    <details>\n  <summary>\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">      <span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span> <span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">double</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pi <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不可以，不能将变量指针绑定到常量指针</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span><span class=\"token operator\">*</span>cptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pi <span class=\"token punctuation\">;</span> <span class=\"token comment\">//合法</span>\n      <span class=\"token operator\">*</span>cptr <span class=\"token operator\">=</span> <span class=\"token number\">42</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 错误，不能给指向常量的指针赋值</span>\n      <span class=\"token keyword\">double</span> dval <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">//</span>\n      cptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>dval <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 正确，指针常量不能绑定到普通变量</span></code></pre>\n  </summary>\n  </details></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-4-CPP修饰符和const限定符\"><a href=\"#1-4-CPP修饰符和const限定符\" class=\"headerlink\" title=\"1.4. CPP修饰符和const限定符\"></a>1.4. CPP修饰符和const限定符</h2><ul>\n<li><p><code>signed</code>,<code>unsigned</code>, <code>long</code> 和 <code>short</code> 修饰整型和浮点型</p>\n  <details>\n  <summary>修饰符demo</summary>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span> </span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span> \n<span class=\"token comment\">/* * 这个程序演示了有符号整数和无符号整数之间的差别 */</span> \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">short</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> \n    <span class=\"token comment\">// 有符号短整数 </span>\n    <span class=\"token keyword\">short</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 无符号短整数 </span>\n    j <span class=\"token operator\">=</span> <span class=\"token number\">50000</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> \n    cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> j<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n  </details>\n</li>\n<li><p>类型限定符提供了变量的额外信息。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>const</td>\n<td><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td>\n</tr>\n<tr>\n<td>volatile</td>\n<td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>\n</tr>\n<tr>\n<td>restrict</td>\n<td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict.</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>const对象创建之后就不能修改发，所有创建时必须初始化</p>\n</li>\n<li><p>默认情况下const对象尽在文件内有效，多文件间共享需要使用extern关键字</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">//file.cc</span>\n<span class=\"token keyword\">extern</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> bufsize <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//file.h</span>\n<span class=\"token keyword\">extern</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> bufsize<span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>const的引用<br>常量引用可以绑定对象，但是不能修改被绑定对象的内容<br>也不能用变量绑定常量引用  </p>\n</li>\n<li><p>指向常量的指针</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> <span class=\"token operator\">*</span>cptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pi<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//指向常量的指针，指针的值不能变，但是指向的值却是可以变的</span></code></pre>\n</li>\n<li><p>常量指针<br>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型，例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span>  curErr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>errNumb<span class=\"token punctuation\">;</span> <span class=\"token comment\">//常量指针</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> pip <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pi<span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>顶层const和<br> 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响</p>\n</li>\n<li><p>constexpr和常量表达式<br> <strong>TBC</strong></p>\n</li>\n</ol>\n<h2 id=\"1-5-处理类型\"><a href=\"#1-5-处理类型\" class=\"headerlink\" title=\"1.5. 处理类型\"></a>1.5. 处理类型</h2><ol>\n<li><p>typedef意为同义词，新标准中可以使用<code>using SI = Sales_items</code>  </p>\n</li>\n<li><p>typedef的指针常量，指向常量的指针  </p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">typedef</span>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pstring<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> pstring cstr <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//指向常量的指针常量</span>\n<span class=\"token keyword\">const</span> pstring <span class=\"token operator\">*</span>ps <span class=\"token punctuation\">;</span> <span class=\"token comment\">//指针常量</span></code></pre>\n</li>\n<li><p><code>auto</code>自动判断类型类型</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> ci <span class=\"token operator\">=</span> i <span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>cr <span class=\"token operator\">=</span> ci<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> d <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>i <span class=\"token comment\">//整形指针</span>\n<span class=\"token keyword\">auto</span> e <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>ci<span class=\"token punctuation\">;</span> <span class=\"token comment\">// e是指向整型常量的指针</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\">//auto如果想推导出顶层const，需要明确写出  </span>\n<span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>h<span class=\"token operator\">=</span><span class=\"token number\">42</span>  <span class=\"token comment\">//错误，因为非常量引用无法绑定字面值</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>j<span class=\"token operator\">=</span><span class=\"token number\">42</span>  <span class=\"token comment\">//错误，因为非常量引用无法绑定字面值</span></code></pre>\n</li>\n<li><p>decltype类型提示符<br> decltype只推断类型，但不使用其值</p>\n<ul>\n<li>decltype和引用，和const</li>\n</ul>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> ci <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>cj <span class=\"token operator\">=</span> ci<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>ci<span class=\"token punctuation\">)</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>cj<span class=\"token punctuation\">)</span> y <span class=\"token operator\">=</span> x <span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>cj<span class=\"token punctuation\">)</span> z <span class=\"token punctuation\">;</span> <span class=\"token comment\">//错误，z是一个引用类型，必须初始化</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span><span class=\"token operator\">*</span>p<span class=\"token operator\">=</span><span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>r <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">//错误。必须初始化</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> d<span class=\"token punctuation\">;</span> <span class=\"token comment\">//错误，双层括号是引用类型，必须初始化</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> e <span class=\"token punctuation\">;</span> <span class=\"token comment\">//正确，e是一个未初始化的int</span></code></pre></li>\n</ol>\n<h2 id=\"1-6-自定义数据结构\"><a href=\"#1-6-自定义数据结构\" class=\"headerlink\" title=\"1.6. 自定义数据结构\"></a>1.6. 自定义数据结构</h2><ol>\n<li><p>strcut 关键字</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Sales_data</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">/* .....  */</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>就可以用来定义数据结构\n</code></pre>\n</li>\n<li><p>预处理器概述<br> #define指令把一个名字设定为预处理变量<br> #ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真  </p>\n <details><summary>demo</summary>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">SALES_DATA_H</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SALES_DATA_H</span></span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Sales_data</span> <span class=\"token punctuation\">&#123;</span>\n        std<span class=\"token double-colon punctuation\">::</span>string bookNo<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">unsigned</span> units_sold <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">double</span> revenue <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></code></pre>\n\n </details></li>\n</ol>\n<h2 id=\"1-7-CPP存储类-待重新拟题\"><a href=\"#1-7-CPP存储类-待重新拟题\" class=\"headerlink\" title=\"1.7 CPP存储类[待重新拟题]\"></a>1.7 CPP存储类[待重新拟题]</h2><ul>\n<li>auto<br>CPP17 弃用</li>\n<li>register<br>定义 ‘register’存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小, 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中.</li>\n<li>static 存储类<br><code>static</code> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</li>\n<li>extern<br>扩展全局变量作用域</li>\n<li>nutable 存储类</li>\n<li>thread_local 存储类<br>变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本</li>\n</ul>\n<h1 id=\"2-字符串，向量，数组\"><a href=\"#2-字符串，向量，数组\" class=\"headerlink\" title=\"2. 字符串，向量，数组\"></a>2. 字符串，向量，数组</h1><h2 id=\"2-1-using关键字\"><a href=\"#2-1-using关键字\" class=\"headerlink\" title=\"2.1. using关键字\"></a>2.1. using关键字</h2><p>   1.切记不要在header文件中使用using namespace std<br>   2. 每个名字都需要独立的using声明  </p>\n<h2 id=\"2-2-string-类型\"><a href=\"#2-2-string-类型\" class=\"headerlink\" title=\"2.2. string 类型\"></a>2.2. string 类型</h2>   <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"hi ya\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//拷贝初始化</span>\nstring <span class=\"token function\">s2</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi ya\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 直接初始化</span>\nstring <span class=\"token function\">s3</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token char\">'C'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//拷贝十个C</span>\nstd<span class=\"token double-colon punctuation\">::</span>cin <span class=\"token operator\">>></span> s3 <span class=\"token operator\">>></span>std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">,</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//从输入控制设备读入整行</span></code></pre>\n\n<ul>\n<li><p><code>string</code> 对象操作  </p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">\nos<span class=\"token operator\">&lt;&lt;</span>s <span class=\"token comment\">//将s写道os中，并返回os </span>\nis<span class=\"token operator\">>></span>s <span class=\"token comment\">//从is中读取字符串赋值给s,字符串以空白分隔，返回is</span>\n<span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>is<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//</span>\ns<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//s为空返回true，否则返回false</span>\ns<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//返回s中字符个数,函数返回的是一个无符号整型数</span>\ns<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token comment\">//返回数字索引储存的值</span>\ns1<span class=\"token operator\">+</span>s2 <span class=\"token comment\">//拼接字符串</span>\ns1<span class=\"token operator\">==</span>s2<span class=\"token punctuation\">;</span>判断字符串是否相等\ns1 <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">>=</span><span class=\"token punctuation\">]</span> s2 <span class=\"token comment\">//按照asic码进行比较</span></code></pre>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>cout<span class=\"token punctuation\">;</span> <span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n<span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n\n        string s1  <span class=\"token operator\">=</span> <span class=\"token string\">\"hello, \"</span><span class=\"token punctuation\">,</span> s2 <span class=\"token operator\">=</span> <span class=\"token string\">\"world\\n\"</span><span class=\"token punctuation\">;</span>\n        string s3 <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// s3 is hello, world\\n</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s1 <span class=\"token operator\">&lt;&lt;</span> s2 <span class=\"token operator\">&lt;&lt;</span> s3 <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\n        s1 <span class=\"token operator\">+=</span> s2<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// equivalent to s1 = s1 + s2</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s1<span class=\"token punctuation\">;</span>\n\n        string s4 <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> s5 <span class=\"token operator\">=</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// no punctuation in s4 or s2</span>\n        string s6 <span class=\"token operator\">=</span> s4 <span class=\"token operator\">+</span> <span class=\"token string\">\", \"</span> <span class=\"token operator\">+</span> s5 <span class=\"token operator\">+</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>\n        string s7 <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\", \"</span> <span class=\"token operator\">+</span> s5 <span class=\"token operator\">+</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//不合法</span>\n        string s8 <span class=\"token operator\">=</span> <span class=\"token string\">\"ABC\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"EFG\"</span> <span class=\"token operator\">+</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不合法操作</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s4 <span class=\"token operator\">&lt;&lt;</span> s5 <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span> <span class=\"token operator\">&lt;&lt;</span> s6 <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n</li>\n<li><p>处理<code>string</code>对象中的字符</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">//用for处理字符</span>\nstring <span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ABCDEFG\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> c <span class=\"token operator\">:</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">//这里的c其实是str中字符的拷贝</span>\n    cout<span class=\"token operator\">&lt;&lt;</span> c <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//改变str中的字符值</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>c <span class=\"token operator\">:</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span> c <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//下标运算符,返回字符串中的值</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre></li>\n</ul>\n<h2 id=\"2-3-vector类型\"><a href=\"#2-3-vector类型\" class=\"headerlink\" title=\"2.3. vector类型\"></a>2.3. vector类型</h2>  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> ivec<span class=\"token punctuation\">;</span> <span class=\"token comment\">//保存int类型</span>\nvector<span class=\"token operator\">&lt;</span>Sales_item<span class=\"token operator\">></span> Sales_vec<span class=\"token punctuation\">;</span> <span class=\"token comment\">//保存Sales_item变量</span>\nvector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> file  <span class=\"token punctuation\">;</span> <span class=\"token comment\">//vector存vector类型</span>\n<span class=\"token comment\">// 初始化</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v1\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">v2</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//v2中包含v1中所有副本</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v2 <span class=\"token operator\">=</span> v1 <span class=\"token comment\">//等价于 vector&lt;T> v2(v1)</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">v3</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//v3包含了n个val元素</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">v4</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token comment\">//包含了n个执行值初始化的对象</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v5<span class=\"token punctuation\">&#123;</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//v5包含了初始值个数的元素，每个元素被赋予相应的初始值，这里还有一点要注意，就是可能会放不同类型的值，但</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v5<span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//等价于vector&lt;T> v5&#123;a,b,c ...&#125;</span>\n<span class=\"token comment\">// vector的CRUD</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 是否为空</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//返回容量，类型std::size_type</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 添加值</span>\nv<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//访问下标存储的数据</span>\nv2<span class=\"token operator\">=</span>v1 <span class=\"token punctuation\">;</span><span class=\"token comment\">//v1拷贝到v2</span>\nv1 <span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//重新赋值</span>\nv1 <span class=\"token operator\">==</span> v2 <span class=\"token punctuation\">;</span><span class=\"token comment\">//时候绝对的相等，长度和内容</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">>=</span> <span class=\"token comment\">//顾名思义按照字典序进行比较</span>\nv1<span class=\"token operator\">!=</span>v2<span class=\"token punctuation\">;</span></code></pre>\n\n<ul>\n<li>无法访问索引外数据，编译期无法发现，但是运行期就会报错</li>\n</ul>\n<h2 id=\"2-4-迭代器的介绍\"><a href=\"#2-4-迭代器的介绍\" class=\"headerlink\" title=\"2.4. 迭代器的介绍\"></a>2.4. 迭代器的介绍</h2><p>除了vector之外，标准库还定义了其他容器，string也可以使用迭代器</p>\n<p>v.begin()返回第一位元素的指针,v.end()返回最后一个元素，注意end()返回的是空引用</p>\n<ul>\n<li><p>迭代器运算符包括  </p>\n<table>\n<thead>\n<tr>\n<th>符号类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*iter</td>\n<td><code>(*it).empty()</code>,返回迭代器所指元素的引用,解引用未定义迭代器都是未定义的行为，可以修改引用真实数据</td>\n</tr>\n<tr>\n<td>item</td>\n<td>解引用iter并获取该元素的名为mem的成员变量，等价于(*iter).mem</td>\n</tr>\n<tr>\n<td>++iter &#x2F; –iter &#x2F;[+-] n</td>\n<td>进行加减运算</td>\n</tr>\n<tr>\n<td>iter&#x3D;&#x3D;iter2</td>\n<td>判断两个迭代器</td>\n</tr>\n<tr>\n<td>iter1 !&#x3D; iter2</td>\n<td>判断两个迭代器不等</td>\n</tr>\n<tr>\n<td>&lt;&#x3D; ,&gt;&#x3D;</td>\n<td>要求迭代器必须指向同一个容器</td>\n</tr>\n</tbody></table>\n  <details><summary>将字符串小写符转化为大写示例</summary>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string <span class=\"token function\">s</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"some string\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">*</span>it <span class=\"token operator\">=</span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n  </details>\n\n<ol>\n<li>迭代器类型支持了以上操作</li>\n<li>如果元素是常数则返回const_iterator,不是常数则返回iterator类型</li>\n<li>it-&gt;mem和(＊it).mem表达的意思相同</li>\n<li>不能在范围for循环中向容器添加元素。<strong>另外一个</strong>限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该 vector对象的迭代器失效</li>\n</ol>\n</li>\n<li><p>将迭代器的移动</p>\n  <details><summary>迭代器移动示例</summary>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> it <span class=\"token operator\">!=</span> it<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">isUpper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">*</span>it <span class=\"token operator\">=</span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n</li>\n<li><p>泛型编程<br>  泛型编程更像一种高度抽象数据结构的能力</p>\n</li>\n<li><p>begin()和end()函数<br>  如果元素是常数则返回const_iterator,不是常数则返回iterator类型</p>\n  </details></li>\n</ul>\n<h2 id=\"2-5-数组\"><a href=\"#2-5-数组\" class=\"headerlink\" title=\"2.5 数组\"></a>2.5 数组</h2><p>如果不清楚元素的确切个数,请使用vector,数组的大小确定不变,不能随意向数组中增加元素.因为数组的大小固定,因此对某些特殊的应用来说程序的运行时性能较好,但是相应地也损失了一些灵活性.</p>\n<h3 id=\"2-5-1-定义和初始化内置数组\"><a href=\"#2-5-1-定义和初始化内置数组\" class=\"headerlink\" title=\"2.5.1 定义和初始化内置数组\"></a>2.5.1 定义和初始化内置数组</h3><ol>\n<li><p>显示初始化数组</p>\n <details>\n <summary>数组初始化示例</summary>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">unsigned</span> sz<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> 定义常量\n<span class=\"token keyword\">int</span> ia1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span>，<span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a3<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\nstring a4<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"byte\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a5<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span>  <span class=\"token comment\">//错误，超出容量</span></code></pre>\n\n </details></li>\n<li><p>字符数组的特殊性</p>\n<details>\n<summary>字符数组特殊性初始化示例</summary>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">char</span> a1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'c'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> a2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'c'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'\\0'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//显示胡世华空字符</span>\n<span class=\"token keyword\">char</span> a3<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"C++\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//自动初始化空字符</span>\n<span class=\"token keyword\">const</span> a4<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">\"Daneil\"</span>  <span class=\"token comment\">//错误没有空间存放空字符</span>\n</code></pre>\n\n</details></li>\n<li><p>不允许拷贝赋值</p>\n <details>\n <summary>不允许拷贝赋值示例</summary>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//含有三个元素的数组</span>\n<span class=\"token keyword\">int</span> a2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 错误: 不允许使用一个数组给另一个数组进行初始化</span>\n    a2 <span class=\"token operator\">=</span> a1 <span class=\"token comment\">//错误: 不允许两个数组之间直接赋值计算</span>\n </code></pre>\n\n </details>\n</li>\n<li><p>复杂数组声明</p>\n <details>\n <summary>复杂数组声明示例</summary>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptrs<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\">// 指向含有10个整型指针的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>refs<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span><span class=\"token comment\">/*?*/</span> <span class=\"token comment\">//不存在引用的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>Parrary<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 指向一个含有是个个整数的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>arrRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr <span class=\"token punctuation\">;</span> <span class=\"token comment\">//arrRef 引用指向一个含有是个整数的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>arry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ptrs <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 首先知道arry是一个引用，然后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用</span></code></pre>\n\n </details></li>\n</ol>\n<h3 id=\"2-5-2-访问数组元素\"><a href=\"#2-5-2-访问数组元素\" class=\"headerlink\" title=\"2.5.2 访问数组元素\"></a>2.5.2 访问数组元素</h3><ol>\n<li>在使用数组下标的时候，通常将其定义为size_t类型</li>\n<li>检查下标的值, CPP要检查数组下标</li>\n</ol>\n<h3 id=\"2-5-3-指针和数组\"><a href=\"#2-5-3-指针和数组\" class=\"headerlink\" title=\"2.5.3 指针和数组\"></a>2.5.3 指针和数组</h3><ol>\n<li><p>通过取地址符号获取地址</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string nums <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"one\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"two\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"three\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\nstring <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//  等价于    string *p2=nums;</span></code></pre>\n\n<p> 其中一层意思就是当使用数组作为<code>auto</code>变量初始值的时候，推断出的是指针而非数组，显然是<code>auto ia2(&amp;ia[0])</code>;但是使用decltype(ia)返回的类型是由10个整数构成的数组</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>ia<span class=\"token punctuation\">)</span> ia3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">;</span>\n ia3 <span class=\"token operator\">=</span>p <span class=\"token punctuation\">;</span><span class=\"token comment\">//错误:不能把整型指针给数组赋值， </span>\n ia3<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span><span class=\"token comment\">//正确: 把整数i赋值给ia3的一个元素</span></code></pre>\n</li>\n<li><p>指针也是迭代器,可以进行整型运算<br> 获取数组的指针后就可以通过<code>加/减</code>计算指针的值,获取指针的最后一个元素地址 <code>&amp;arr[n]</code> ,这个表示arr的长度。针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。两个指针相减的结果的类型是一种名为<code>ptrdiff_t</code>的标准库类型，和<code>size_t</code>一样，<code>ptrdiff_t</code>也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型,两指针不指向头一个对象而进行<code>加/减</code>没有意义</p>\n</li>\n<li><p>标准库函数begin()和end()</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>head <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>tail <span class=\"token operator\">=</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n<li><p>指针解引用的运算</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> last <span class=\"token operator\">=</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>arr <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlast <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>last <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//是解引用last然后加4</span>\n<span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> p<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 数组下标运算可以处理负值</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token comment\">//下标运算不能为负值，是无符号类型</span></code></pre></li>\n</ol>\n<h3 id=\"2-5-4-C风格字符串\"><a href=\"#2-5-4-C风格字符串\" class=\"headerlink\" title=\"2.5.4 C风格字符串\"></a>2.5.4 C风格字符串</h3><ul>\n<li>支持C风格运算函数，比较字符串时候,比较第一个不相同字符的ASCII码值</li>\n<li>如果是两个字符串字面量可以用<code>+</code>进行拼接，但是如果是两个指针就需要用函数进行拼接<br>  <code>strcpy(str,ca1)</code> &#x2F;&#x2F;把ca1复制给str,一定要注意str的容量<br>  <code>strcat(str,&quot;&quot;)</code> &#x2F;&#x2F;str是字符串数组<br>  <code>strcat(str,ca2)</code> &#x2F;&#x2F; 将ca2和str继续拼接v</li>\n</ul>\n<h3 id=\"2-5-5-与旧代码的接口-兼容C代码\"><a href=\"#2-5-5-与旧代码的接口-兼容C代码\" class=\"headerlink\" title=\"2.5.5 与旧代码的接口,兼容C代码\"></a>2.5.5 与旧代码的接口,兼容C代码</h3><ol>\n<li>混合string对象和C风格字符串<br> <code>string s(&quot;hello world&quot;);</code>&#x2F;&#x2F;也允许空字符串初始化string字符串，在string对象的加法运算中允许使用以空字符结束的<code>字符数组</code>作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象.<br> 无法用<code>string</code>对象初始化字符数组，除非使用<code>s.c_str()</code>函数<code>const char *str = s.c_str();</code></li>\n<li>使用数组初始化vector对象</li>\n</ol>\n<ul>\n<li>不允许使用一个<code>数组</code>给另一个<code>内置类型数组</code>初始化  </li>\n<li><code>vector</code>允许给<code>数组</code>初始化  </li>\n<li>但是<code>数组</code>却可以给vector 进行初始化,可以是相等元素数量进行赋值，也可以是部分元素数量给<code>vector</code>赋值</li>\n</ul>\n<p>建议：尽量使用标准库类型而非数组,应该尽量使用string，避免使用C风格的基于数组的字符串</p>\n<h2 id=\"2-6-多维数组\"><a href=\"#2-6-多维数组\" class=\"headerlink\" title=\"2.6 多维数组\"></a>2.6 多维数组</h2><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">//多维数组</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">;</span><span class=\"token comment\">//将所有元素都初始化为0</span>\n<span class=\"token comment\">// 从左往右理解，定义了一个十个元素的数组，每个元素里面又能容纳一个是元素的数组。</span></code></pre>\n\n<h3 id=\"2-6-1-多维数组初始化\"><a href=\"#2-6-1-多维数组初始化\" class=\"headerlink\" title=\"2.6.1 多维数组初始化\"></a>2.6.1 多维数组初始化</h3><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/*----1-----*/</span>\n<span class=\"token comment\">//二维数组分别初始化</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*----2----*/</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这种初始化方式是等价的，但是并不会把所有元素都初始化</span>\n\n<span class=\"token comment\">/*----3----*/</span>\n<span class=\"token comment\">//显示缺省</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">7</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/*----4----*/</span>\n<span class=\"token comment\">// 只是初始化第一行</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></code></pre>\n\n<h3 id=\"2-6-2-多维数组的下标引用\"><a href=\"#2-6-2-多维数组的下标引用\" class=\"headerlink\" title=\"2.6.2 多维数组的下标引用\"></a>2.6.2 多维数组的下标引用</h3><p>说白了就是可以通过下标运算符进行取值，如果是三维数组，而用了两个下标运算符那么就会取出<strong>数组</strong></p>\n<h3 id=\"2-6-3-使用范围for语句处理多维数组\"><a href=\"#2-6-3-使用范围for语句处理多维数组\" class=\"headerlink\" title=\"2.6.3 使用范围for语句处理多维数组\"></a>2.6.3 使用范围for语句处理多维数组</h3><p>看如下例子,因为程序要改变数组中的值，所以要使用<code>引用</code>进行赋值。</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">size_t <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>row <span class=\"token operator\">:</span> ia<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">// row其实是数组的引用</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>col <span class=\"token operator\">:</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// col其实是整数的引用</span>\n                col <span class=\"token operator\">=</span> cnt<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">++</span>cnt<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>而如下例子代码是错的,编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）<br>,转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> row <span class=\"token operator\">:</span> ia<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> col <span class=\"token operator\">:</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h3 id=\"2-6-4-指针和多维数组\"><a href=\"#2-6-4-指针和多维数组\" class=\"headerlink\" title=\"2.6.4 指针和多维数组\"></a>2.6.4 指针和多维数组</h3><p>定义数组的时候千万别忘了这是数组的数组,所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针,例如  </p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ia<span class=\"token punctuation\">;</span> <span class=\"token comment\">//p 是指向四个整数的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span class=\"token comment\">//整形指针数组</span>\np <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>ia<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span class=\"token comment\">//p指向ia的尾元素</span>\n</code></pre>\n\n<p>在C++11标准中使用<code>auto</code>和<code>decltype</code>就能避免在数组前面加一个指针类型，例子如下  </p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> p <span class=\"token operator\">=</span> ia <span class=\"token punctuation\">;</span>p<span class=\"token operator\">!=</span>ia<span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> q <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> q<span class=\"token operator\">!=</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">+</span><span class=\"token number\">4</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">&lt;&lt;</span> <span class=\"token char\">''</span> <span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n</code></pre>\n\n<p>它首先令指针q指向p当前所在行的第一个元素,然后再一次<code>解引用</code>指向内层的数组的首元素，然后终止条件为<code>+4</code>,当然也可以使用标准函数<code>begin()</code>和<code>end()</code>实现相同的效果</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> p <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>ia<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> p<span class=\"token operator\">!=</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span>ia<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>ia <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> q <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> q<span class=\"token operator\">!=</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        cout<span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">&lt;&lt;</span> <span class=\"token char\">''</span> <span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span>\n</code></pre>\n\n<h3 id=\"2-6-5-类型别名简化多维数组的指针\"><a href=\"#2-6-5-类型别名简化多维数组的指针\" class=\"headerlink\" title=\"2.6.5 类型别名简化多维数组的指针\"></a>2.6.5 类型别名简化多维数组的指针</h3><p>使用<code>类型别名</code>可以简化工作  </p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">using</span> int_array  <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//新标准下的写法</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span class=\"token comment\">//等价的typedef声明</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>int_array <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> ia <span class=\"token punctuation\">;</span> p<span class=\"token operator\">!=</span> ia <span class=\"token operator\">+</span><span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>p <span class=\"token punctuation\">;</span> q<span class=\"token operator\">!=</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">+</span><span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        cout<span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">&lt;&lt;</span> <span class=\"token char\">''</span> <span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">&#125;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> endl <span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span>\n</code></pre>\n<p>程序将类型“四个整数组成的数组”命名为int_array,用类型名int_array定义外层循环<code>控制变量</code>更加简洁</p>\n<h3 id=\"2-6-6-术语表\"><a href=\"#2-6-6-术语表\" class=\"headerlink\" title=\"2.6.6 术语表\"></a>2.6.6 术语表</h3><table>\n<thead>\n<tr>\n<th>术语</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>begin</td>\n<td>是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。</td>\n</tr>\n<tr>\n<td>缓冲区溢出（buffer overflow）</td>\n<td>一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等</td>\n</tr>\n<tr>\n<td>C风格字符串（C-style string）</td>\n<td>以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错</td>\n</tr>\n<tr>\n<td>类模板（class template）</td>\n<td>用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个vector对象需要指定元素的类型：<code>vector&lt;int&gt;</code>包含int类型的元素。</td>\n</tr>\n<tr>\n<td>编译器扩展（compiler extension）</td>\n<td>某个特定的编译器为C++语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上</td>\n</tr>\n<tr>\n<td>容器（container）</td>\n<td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。</td>\n</tr>\n<tr>\n<td>容器（container）</td>\n<td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。</td>\n</tr>\n<tr>\n<td>difference_type</td>\n<td>由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。</td>\n</tr>\n<tr>\n<td>直接初始化（direct initialization）</td>\n<td>不使用赋值号（&#x3D;）的初始化形式</td>\n</tr>\n<tr>\n<td>empty()</td>\n<td>是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假。</td>\n</tr>\n<tr>\n<td>end()</td>\n<td>是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针。</td>\n</tr>\n<tr>\n<td>getline</td>\n<td>在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留。</td>\n</tr>\n<tr>\n<td>索引（index）</td>\n<td>是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置。</td>\n</tr>\n<tr>\n<td>实例化（instantiation）</td>\n<td>编译器生成一个指定的模板类或函数的过程。</td>\n</tr>\n<tr>\n<td>迭代器（iterator）</td>\n<td>是一种类型，用于访问容器中的元素或者在元素之间移动。</td>\n</tr>\n<tr>\n<td>迭代器运算（iterator arithmetic）</td>\n<td>是string或vector的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置。</td>\n</tr>\n<tr>\n<td>以空字符结束的字符串（null-terminated string）</td>\n<td>是一个字符串，它的最后一个字符后面还跟着一个空字符（’\\0’）。</td>\n</tr>\n<tr>\n<td>prtdiff_t</td>\n<td>是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。</td>\n</tr>\n<tr>\n<td>push_back</td>\n<td>是vector的成员，向vector对象的末尾添加元素。</td>\n</tr>\n<tr>\n<td>范围for语句（range for）</td>\n<td>一种控制语句，可以在值的一个特定集合内迭代。</td>\n</tr>\n<tr>\n<td>size</td>\n<td>是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type。</td>\n</tr>\n<tr>\n<td>size_t</td>\n<td>是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小。</td>\n</tr>\n<tr>\n<td>size_type</td>\n<td>是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型。</td>\n</tr>\n<tr>\n<td>string</td>\n<td>是一种标准库类型，表示字符的序列。</td>\n</tr>\n<tr>\n<td>using声明（using declaration）</td>\n<td>令命名空间中的某个名字可被程序直接使用。using 命名空间 ：： 名字；上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分命名空间：：。</td>\n</tr>\n<tr>\n<td>值初始化（value initialization）</td>\n<td>是一种初始化过程。内置类型初始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值</td>\n</tr>\n<tr>\n<td>vector</td>\n<td>是一种标准库类型，容纳某指定类型的一组元素。</td>\n</tr>\n<tr>\n<td>++运算符（++ operator）</td>\n<td>是迭代器和指针定义的递增运算符。执行“加1”操作使得迭代器指向下一个元素。</td>\n</tr>\n<tr>\n<td>[ ]运算符（[ ] operator）</td>\n<td>下标运算符。obj[j]得到容器对象obj中位置j的那个元素。索引从0开始，第一个元素的索引是0，尾元素的索引是obj.size（）-1。下标运算符的返回值是一个对象。如果p是指针、n是整数，则p[n]与＊（p+n）等价。</td>\n</tr>\n<tr>\n<td>-&gt;运算符（-&gt;operator）</td>\n<td>箭头运算符，该运算符综合了解引用操作和点操作。a-&gt;b等价于（＊a）.b。</td>\n</tr>\n<tr>\n<td>&lt;&lt;运算符<code>（&lt;&lt;operator）</code></td>\n<td>标准库类型string定义的输出运算符，负责输出string对象中的字符。</td>\n</tr>\n<tr>\n<td>&gt;&gt;运算符<code>（&gt;&gt;operator）</code></td>\n<td>标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个string对象。</td>\n</tr>\n<tr>\n<td>！运算符（！ operator）</td>\n<td>逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假。</td>\n</tr>\n<tr>\n<td>&amp;&amp;运算符（&amp;&amp;operator）</td>\n<td>逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"3-CPP流程控制\"><a href=\"#3-CPP流程控制\" class=\"headerlink\" title=\"3. CPP流程控制\"></a>3. CPP流程控制</h1><ul>\n<li>如果标准输入输出作为<code>if</code>,<code>while</code>条件，读到文件结束符判断假，或者是无效输入</li>\n</ul>\n<ol>\n<li>windows : Ctrl+Z (文件结束符)</li>\n<li>linux : Ctrl+D (文件结束符)</li>\n</ol>\n<h1 id=\"4-函数\"><a href=\"#4-函数\" class=\"headerlink\" title=\"4. 函数\"></a>4. 函数</h1><ul>\n<li><p>函数的调用</p>\n<ul>\n<li>传值</li>\n<li>传引用</li>\n</ul>\n</li>\n<li><p>参数默认值</p>\n</li>\n<li><p>Lambda表达式</p>\n</li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">int</span> z <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> z <span class=\"token operator\">+</span> x<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></code></pre>\n\n<pre class=\"language-none\"><code class=\"language-none\">[]      &#x2F;&#x2F; 沒有定义任何变量。使用未定义变量会引发错误。\n[x, &amp;y] &#x2F;&#x2F; x以传值方式传入（默认），y以引用方式传入。\n[&amp;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以引用方式加以引用。\n[&#x3D;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以传值方式加以引用。\n[&amp;, x]  &#x2F;&#x2F; x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n[&#x3D;, &amp;z] &#x2F;&#x2F; z显式地以引用方式加以引用。其余变量以传值方式加以引用。</code></pre>\n\n<ul>\n<li>引用<br>实际上是已知变量的另一个名字。</li>\n</ul>\n<pre class=\"language-none\"><code class=\"language-none\">int&amp;  r &#x3D; i;</code></pre>\n\n<ul>\n<li>标准IO<br>通过(std::)方式调用标准函数库，或者在函数头写<code>using namespace std</code></li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n \n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n \n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"请输入您的名称： \"</span><span class=\"token punctuation\">;</span>\n   cin <span class=\"token operator\">>></span> name<span class=\"token punctuation\">;</span>\n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"您的名称是： \"</span> <span class=\"token operator\">&lt;&lt;</span> name <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n   cerr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Error message : \"</span> <span class=\"token operator\">&lt;&lt;</span> str <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n   clog <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Error message : \"</span> <span class=\"token operator\">&lt;&lt;</span> str <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h2 id=\"4-1-struct构造初始化\"><a href=\"#4-1-struct构造初始化\" class=\"headerlink\" title=\"4.1. struct构造初始化\"></a>4.1. struct构造初始化</h2><ul>\n<li>利用自带默认构造函数</li>\n<li>参数构造</li>\n<li>自定义void init(…..){ … this-&gt;  …}<br>在建立结构体数组时,如果只写了带参数的构造函数将会出现数组无法初始化的错误！！！各位同学要牢记呀！！！</li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">int</span> data<span class=\"token punctuation\">;</span>\n string str<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">char</span> x<span class=\"token punctuation\">;</span>\n <span class=\"token comment\">//自己写的初始化函数</span>\n <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> string b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>str <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>x <span class=\"token operator\">=</span> c<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n <span class=\"token function\">node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span><span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n <span class=\"token function\">node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> string b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span><span class=\"token function\">x</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">str</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">data</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>N<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre>\n\n<h1 id=\"5-面向对象编程\"><a href=\"#5-面向对象编程\" class=\"headerlink\" title=\"5. 面向对象编程\"></a>5. 面向对象编程</h1><ul>\n<li>#include指令使用（&lt;&gt;）导入标准库函数，非标准库用双引号（” “）。</li>\n</ul>\n<details>\n<summary>类示例demo</summary>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"Books\"</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Box</span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n   \n   <span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n   \n   <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">char</span>  title<span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">char</span>  author<span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">char</span>  subject<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span>   book_id<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">double</span> length<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 长度</span>\n      <span class=\"token keyword\">double</span> breadth<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 宽度</span>\n      <span class=\"token keyword\">double</span> height<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 高度</span>\n      <span class=\"token comment\">// 成员函数声明，但是没有实现</span>\n      <span class=\"token keyword\">double</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">double</span> len<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> bre<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> hei <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 成员函数定义</span>\n<span class=\"token keyword\">double</span> <span class=\"token class-name\">Box</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> length <span class=\"token operator\">*</span> breadth <span class=\"token operator\">*</span> height<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n \n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Box</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">double</span> len<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> bre<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> hei<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    length <span class=\"token operator\">=</span> len<span class=\"token punctuation\">;</span>\n    breadth <span class=\"token operator\">=</span> bre<span class=\"token punctuation\">;</span>\n    height <span class=\"token operator\">=</span> hei<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n   Box Box1<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 声明 Box1，类型为 Box</span>\n   Box Box2<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 声明 Box2，类型为 Box</span>\n   Box Box3<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 声明 Box3，类型为 Box</span>\n   <span class=\"token keyword\">double</span> volume <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 用于存储体积</span>\n \n   <span class=\"token comment\">// box 1 详述</span>\n   Box1<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> <span class=\"token number\">5.0</span><span class=\"token punctuation\">;</span> \n   Box1<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">6.0</span><span class=\"token punctuation\">;</span> \n   Box1<span class=\"token punctuation\">.</span>breadth <span class=\"token operator\">=</span> <span class=\"token number\">7.0</span><span class=\"token punctuation\">;</span>\n \n   <span class=\"token comment\">// box 2 详述</span>\n   Box2<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> <span class=\"token number\">10.0</span><span class=\"token punctuation\">;</span>\n   Box2<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">12.0</span><span class=\"token punctuation\">;</span>\n   Box2<span class=\"token punctuation\">.</span>breadth <span class=\"token operator\">=</span> <span class=\"token number\">13.0</span><span class=\"token punctuation\">;</span>\n \n   <span class=\"token comment\">// box 1 的体积</span>\n   volume <span class=\"token operator\">=</span> Box1<span class=\"token punctuation\">.</span>height <span class=\"token operator\">*</span> Box1<span class=\"token punctuation\">.</span>length <span class=\"token operator\">*</span> Box1<span class=\"token punctuation\">.</span>breadth<span class=\"token punctuation\">;</span>\n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Box1 的体积：\"</span> <span class=\"token operator\">&lt;&lt;</span> volume <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n \n   <span class=\"token comment\">// box 2 的体积</span>\n   volume <span class=\"token operator\">=</span> Box2<span class=\"token punctuation\">.</span>height <span class=\"token operator\">*</span> Box2<span class=\"token punctuation\">.</span>length <span class=\"token operator\">*</span> Box2<span class=\"token punctuation\">.</span>breadth<span class=\"token punctuation\">;</span>\n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Box2 的体积：\"</span> <span class=\"token operator\">&lt;&lt;</span> volume <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n \n \n   <span class=\"token comment\">// box 3 详述</span>\n   Box3<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">16.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   volume <span class=\"token operator\">=</span> Box3<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Box3 的体积：\"</span> <span class=\"token operator\">&lt;&lt;</span> volume <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n</details>\n\n<ul>\n<li>CPP支持文件重定向<code>$ addItems &lt;infile &gt;outfile</code> 可直接从文件读数据然后计算</li>\n</ul>\n<details>\n  <summary>文件重定向Sales_item代码</summary>\n <blockcode>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">  <span class=\"token comment\">/*\n * This file contains code from \"C++ Primer, Fifth Edition\", by Stanley B.\n * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the\n * copyright and warranty notices given in that book:\n * \n * \"Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.\"\n * \n * \n * \"The authors and publisher have taken care in the preparation of this book,\n * but make no expressed or implied warranty of any kind and assume no\n * responsibility for errors or omissions. No liability is assumed for\n * incidental or consequential damages in connection with or arising out of the\n * use of the information or programs contained herein.\"\n * \n * Permission is granted for this code to be used for educational purposes in\n * association with the book, given proper citation if and when posted or\n * reproduced.Any commercial use of this code requires the explicit written\n * permission of the publisher, Addison-Wesley Professional, a division of\n * Pearson Education, Inc. Send your request for permission, stating clearly\n * what code you would like to use, and in what specific way, to the following\n * address: \n * \n *     Pearson Education, Inc.\n *     Rights and Permissions Department\n *     One Lake Street\n *     Upper Saddle River, NJ  07458\n *     Fax: (201) 236-3290\n*/</span> \n\n<span class=\"token comment\">/* This file defines the Sales_item class used in chapter 1.\n * The code used in this file will be explained in\n * Chapter 7 (Classes) and Chapter 14 (Overloaded Operators)\n * Readers shouldn't try to understand the code in this file\n * until they have read those chapters.\n*/</span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">SALESITEM_H</span></span>\n<span class=\"token comment\">// we're here only if SALESITEM_H has not yet been defined </span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SALESITEM_H</span></span>\n\n<span class=\"token comment\">// Definition of Sales_item class and related functions goes here</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Sales_item</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">// these declarations are explained section 7.2.1, p. 270 </span>\n<span class=\"token comment\">// and in chapter 14, pages 557, 558, 561</span>\n<span class=\"token keyword\">friend</span> std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">friend</span> std<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">friend</span> <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">friend</span> <span class=\"token keyword\">bool</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">==</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\">// constructors are explained in section 7.1.4, pages 262 - 265</span>\n    <span class=\"token comment\">// default constructor needed to initialize members of built-in type</span>\n    <span class=\"token function\">Sales_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Sales_item</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token operator\">&amp;</span>book<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token function\">bookNo</span><span class=\"token punctuation\">(</span>book<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">Sales_item</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream <span class=\"token operator\">&amp;</span>is<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> is <span class=\"token operator\">>></span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\">// operations on Sales_item objects</span>\n    <span class=\"token comment\">// member binary operator: left-hand operand bound to implicit this pointer</span>\n    Sales_item<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">+=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// operations on Sales_item objects</span>\n    std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> bookNo<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">double</span> <span class=\"token function\">avg_price</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// private members as before</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    std<span class=\"token double-colon punctuation\">::</span>string bookNo<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// implicitly initialized to the empty string</span>\n    <span class=\"token keyword\">unsigned</span> units_sold <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// explicitly initialized</span>\n    <span class=\"token keyword\">double</span> revenue <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// used in chapter 10</span>\n<span class=\"token keyword\">inline</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">compareIsbn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> lhs<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// nonmember binary operator: must declare a parameter for each operand</span>\nSales_item <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">bool</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">==</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// must be made a friend of Sales_item</span>\n    <span class=\"token keyword\">return</span> lhs<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">&amp;&amp;</span>\n           lhs<span class=\"token punctuation\">.</span>revenue <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span>revenue <span class=\"token operator\">&amp;&amp;</span>\n           lhs<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">bool</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">!=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>lhs <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// != defined in terms of operator==</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// assumes that both objects refer to the same ISBN</span>\nSales_item<span class=\"token operator\">&amp;</span> Sales_item<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span><span class=\"token operator\">+=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n    units_sold <span class=\"token operator\">+=</span> rhs<span class=\"token punctuation\">.</span>units_sold<span class=\"token punctuation\">;</span> \n    revenue <span class=\"token operator\">+=</span> rhs<span class=\"token punctuation\">.</span>revenue<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// assumes that both objects refer to the same ISBN</span>\nSales_item \n<span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span> lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n    Sales_item <span class=\"token function\">ret</span><span class=\"token punctuation\">(</span>lhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// copy (|lhs|) into a local object that we'll return</span>\n    ret <span class=\"token operator\">+=</span> rhs<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// add in the contents of (|rhs|) </span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// return (|ret|) by value</span>\n<span class=\"token punctuation\">&#125;</span>\n\nstd<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> in<span class=\"token punctuation\">,</span> Sales_item<span class=\"token operator\">&amp;</span> s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">double</span> price<span class=\"token punctuation\">;</span>\n    in <span class=\"token operator\">>></span> s<span class=\"token punctuation\">.</span>bookNo <span class=\"token operator\">>></span> s<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">>></span> price<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// check that the inputs succeeded</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span>\n        s<span class=\"token punctuation\">.</span>revenue <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">*</span> price<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> \n        s <span class=\"token operator\">=</span> <span class=\"token function\">Sales_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// input failed: reset object to default state</span>\n    <span class=\"token keyword\">return</span> in<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\nstd<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span> out<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span> s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    out <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span>\n        <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span>revenue <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">avg_price</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> out<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">double</span> <span class=\"token class-name\">Sales_item</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">avg_price</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>units_sold<span class=\"token punctuation\">)</span> \n        <span class=\"token keyword\">return</span> revenue<span class=\"token operator\">/</span>units_sold<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">else</span> \n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></code></pre>\n\n </blockcode>\n</details>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"Sales_item.cc\"</span></span>\n\n \n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n    Sales_item item1<span class=\"token punctuation\">,</span> item2<span class=\"token punctuation\">;</span>\n\n    std<span class=\"token double-colon punctuation\">::</span>cin <span class=\"token operator\">>></span> item1 <span class=\"token operator\">>></span> item2<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//read a pair of transactions</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> item1 <span class=\"token operator\">+</span> item2 <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//print their sum</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h2 id=\"5-1-继承与多继承\"><a href=\"#5-1-继承与多继承\" class=\"headerlink\" title=\"5.1. 继承与多继承\"></a>5.1. 继承与多继承</h2><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n \n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">// 基类</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Shape</span> \n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">void</span> <span class=\"token function\">setWidth</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> w<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">&#123;</span>\n         width <span class=\"token operator\">=</span> w<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token keyword\">void</span> <span class=\"token function\">setHeight</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">&#123;</span>\n         height <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">int</span> width<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">// 派生类, 多继承就是写成 class Rectangle: public Shape, public square &#123; ... &#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Rectangle</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Shape</span></span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">int</span> <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">&#123;</span> \n         <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>width <span class=\"token operator\">*</span> height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n      <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n   Rectangle Rect<span class=\"token punctuation\">;</span>\n \n   Rect<span class=\"token punctuation\">.</span><span class=\"token function\">setWidth</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   Rect<span class=\"token punctuation\">.</span><span class=\"token function\">setHeight</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n   <span class=\"token comment\">// 输出对象的面积</span>\n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Total area: \"</span> <span class=\"token operator\">&lt;&lt;</span> Rect<span class=\"token punctuation\">.</span><span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n \n   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<table>\n<thead>\n<tr>\n<th>访问</th>\n<th>public</th>\n<th>protected</th>\n<th>private</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>同一个类</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>派生类</td>\n<td>yes</td>\n<td>yes</td>\n<td>no</td>\n</tr>\n<tr>\n<td>外部的类</td>\n<td>yes</td>\n<td>no</td>\n<td>no</td>\n</tr>\n</tbody></table>\n<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n<ul>\n<li>基类的构造函数、析构函数和拷贝构造函数。</li>\n<li>基类的重载运算符。</li>\n<li>基类的友元函数。</li>\n</ul>\n<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>\n<ul>\n<li><strong>公有继承（public）：</strong> 当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>\n<li><strong>保护继承（protected）：</strong>  当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>\n<li><strong>私有继承（private）：</strong> 当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>\n</ul>\n<h2 id=\"5-3-函数，运算符重载\"><a href=\"#5-3-函数，运算符重载\" class=\"headerlink\" title=\"5.3. 函数，运算符重载\"></a>5.3. 函数，运算符重载</h2><ul>\n<li>函数签名不同的叫函数重载</li>\n<li>运算符重载</li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">类成员函数\nBox <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Box<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">类的非成员函数\nBox <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Box<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Box<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n\n<h2 id=\"5-4-多态\"><a href=\"#5-4-多态\" class=\"headerlink\" title=\"5.4. 多态\"></a>5.4. 多态</h2><p>如果对象具有继承关系，那么CPP会更具具体的对象类型调用具体的成员函数长度</p>\n<h2 id=\"5-5-CPP接口\"><a href=\"#5-5-CPP接口\" class=\"headerlink\" title=\"5.5. CPP接口\"></a>5.5. CPP接口</h2><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Box</span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n      <span class=\"token comment\">// 纯虚函数</span>\n      <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getVolume</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">double</span> length<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 长度</span>\n      <span class=\"token keyword\">double</span> breadth<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 宽度</span>\n      <span class=\"token keyword\">double</span> height<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 高度</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></code></pre>\n\n<p>实现类必须要实现抽象安徽念书(虚函数)</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"#1-%E5%8F%98%E9%87%8F%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\">1. 变量及基本类型</a><ul>\n<li><a href=\"#11-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B\">1.1 基本内置类型</a><ul>\n<li><a href=\"#111-%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B\">1.1.1 算术类型</a></li>\n<li><a href=\"#112-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\">1.1.2 类型转换</a></li>\n<li><a href=\"#113-%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F\">1.1.3 字面常量</a></li>\n</ul>\n</li>\n<li><a href=\"#12-%E5%8F%98%E9%87%8F\">1.2. 变量</a><ul>\n<li><a href=\"#121-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89\">1.2.1 变量定义</a></li>\n<li><a href=\"#122-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB\">1.2.2 变量声明和定义的关系</a></li>\n<li><a href=\"#123-%E5%90%8D%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">1.2.3 名字的作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#13-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B\">1.3. 复合类型</a></li>\n<li><a href=\"#14-cpp%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8Cconst%E9%99%90%E5%AE%9A%E7%AC%A6\">1.4. CPP修饰符和const限定符</a></li>\n<li><a href=\"#15-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B\">1.5. 处理类型</a></li>\n<li><a href=\"#16-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">1.6. 自定义数据结构</a></li>\n<li><a href=\"#17-cpp%E5%AD%98%E5%82%A8%E7%B1%BB%E5%BE%85%E9%87%8D%E6%96%B0%E6%8B%9F%E9%A2%98\">1.7 CPP存储类[待重新拟题]</a></li>\n</ul>\n</li>\n<li><a href=\"#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E6%95%B0%E7%BB%84\">2. 字符串，向量，数组</a><ul>\n<li><a href=\"#21-using%E5%85%B3%E9%94%AE%E5%AD%97\">2.1. using关键字</a></li>\n<li><a href=\"#22-string-%E7%B1%BB%E5%9E%8B\">2.2. string 类型</a></li>\n<li><a href=\"#23-vector%E7%B1%BB%E5%9E%8B\">2.3. vector类型</a></li>\n<li><a href=\"#24-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D\">2.4. 迭代器的介绍</a></li>\n<li><a href=\"#25-%E6%95%B0%E7%BB%84\">2.5 数组</a><ul>\n<li><a href=\"#251-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84\">2.5.1 定义和初始化内置数组</a></li>\n<li><a href=\"#252-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0\">2.5.2 访问数组元素</a></li>\n<li><a href=\"#253-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84\">2.5.3 指针和数组</a></li>\n<li><a href=\"#254-c%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2\">2.5.4 C风格字符串</a></li>\n<li><a href=\"#255-%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%85%BC%E5%AE%B9c%E4%BB%A3%E7%A0%81\">2.5.5 与旧代码的接口,兼容C代码</a></li>\n</ul>\n</li>\n<li><a href=\"#26-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">2.6 多维数组</a><ul>\n<li><a href=\"#261-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96\">2.6.1 多维数组初始化</a></li>\n<li><a href=\"#262-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8\">2.6.2 多维数组的下标引用</a></li>\n<li><a href=\"#263-%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">2.6.3 使用范围for语句处理多维数组</a></li>\n<li><a href=\"#264-%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">2.6.4 指针和多维数组</a></li>\n<li><a href=\"#265-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88\">2.6.5 类型别名简化多维数组的指针</a></li>\n<li><a href=\"#266-%E6%9C%AF%E8%AF%AD%E8%A1%A8\">2.6.6 术语表</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#3-cpp%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6\">3. CPP流程控制</a></li>\n<li><a href=\"#4-%E5%87%BD%E6%95%B0\">4. 函数</a><ul>\n<li><a href=\"#41-struct%E6%9E%84%E9%80%A0%E5%88%9D%E5%A7%8B%E5%8C%96\">4.1. struct构造初始化</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\">5. 面向对象编程</a><ul>\n<li><a href=\"#51-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E7%BB%A7%E6%89%BF\">5.1. 继承与多继承</a></li>\n<li><a href=\"#53-%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">5.3. 函数，运算符重载</a></li>\n<li><a href=\"#54-%E5%A4%9A%E6%80%81\">5.4. 多态</a></li>\n<li><a href=\"#55-cpp%E6%8E%A5%E5%8F%A3\">5.5. CPP接口</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"1-变量及基本类型\"><a href=\"#1-变量及基本类型\" class=\"headerlink\" title=\"1. 变量及基本类型\"></a>1. 变量及基本类型</h1><ol>\n<li><p><code>g++ -o hello_world  -std=c++11  hello_world.cpp</code><br>将源代码cpp文件编程成二进制程序,并支持C++11</p>\n</li>\n<li><p>CPP保留字</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>asm</td>\n<td>else</td>\n<td>new</td>\n<td>this &#x2F; 自身地址</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>enum</td>\n<td>operator</td>\n<td>throw</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>explicit</td>\n<td>private</td>\n<td>true &#x2F; 真 &#x2F; 0</td>\n</tr>\n<tr>\n<td>break</td>\n<td>export</td>\n<td>protected</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>extern</td>\n<td>public</td>\n<td>typedef &#x2F; 别名定义</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>false</td>\n<td>register</td>\n<td>typeid</td>\n</tr>\n<tr>\n<td>char</td>\n<td>float &#x2F;单精度</td>\n<td>reinterpret_cast</td>\n<td>typename</td>\n</tr>\n<tr>\n<td>class</td>\n<td>for</td>\n<td>return</td>\n<td>union</td>\n</tr>\n<tr>\n<td>const</td>\n<td>friend</td>\n<td>short</td>\n<td>unsigned &#x2F; 无符号</td>\n</tr>\n<tr>\n<td>const_cast</td>\n<td>goto</td>\n<td>signed &#x2F; 有符号</td>\n<td>using &#x2F; 使用命名空间</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>if</td>\n<td>sizeof</td>\n<td>virtual</td>\n</tr>\n<tr>\n<td>default</td>\n<td>inline</td>\n<td>static</td>\n<td>void &#x2F; 空类型</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>int</td>\n<td>static_cast</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>do</td>\n<td>long</td>\n<td>struct</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>double</td>\n<td>mutable</td>\n<td>switch &#x2F;</td>\n<td>while &#x2F; 循环</td>\n</tr>\n<tr>\n<td>dynamic_cast</td>\n<td>namespace</td>\n<td>template</td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>typedef声明</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">short</span> <span class=\"token keyword\">int</span> s_int<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> feet<span class=\"token punctuation\">;</span>\nfeet distance <span class=\"token comment\">//合法声明</span></code></pre>\n</li>\n<li><p>枚举类型<br>所谓”枚举”是指将变量的值一一列举出来，变量赋值时候只能是特定的变量才能赋值</p>\n<details><summary>枚举类型demo</summary>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">\n<span class=\"token keyword\">enum</span> 枚举名<span class=\"token punctuation\">&#123;</span> \n    标识符<span class=\"token punctuation\">[</span><span class=\"token operator\">=</span>整型常数<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> \n    标识符<span class=\"token punctuation\">[</span><span class=\"token operator\">=</span>整型常数<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> \n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n    标识符<span class=\"token punctuation\">[</span><span class=\"token operator\">=</span>整型常数<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span> 枚举变量<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//举例子</span>\n<span class=\"token keyword\">enum</span>  <span class=\"token class-name\">color</span><span class=\"token punctuation\">&#123;</span> red <span class=\"token punctuation\">,</span> yellow <span class=\"token punctuation\">,</span>blue<span class=\"token punctuation\">&#125;</span> c\nc <span class=\"token operator\">=</span> blue \n<span class=\"token comment\">//默认情况下，是从0开始初始化</span>\n</code></pre>\n\n</details>\n</li>\n<li><p>三字符组</p>\n<p>以前为了表示键盘上没有的字符</p>\n<table>\n<thead>\n<tr>\n<th>字符串</th>\n<th>转义后的含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>??&#x3D;</td>\n<td>#</td>\n</tr>\n<tr>\n<td>??(</td>\n<td>[</td>\n</tr>\n<tr>\n<td>??)</td>\n<td>]</td>\n</tr>\n<tr>\n<td>??&#x2F;</td>\n<td>\\</td>\n</tr>\n<tr>\n<td>??&lt;</td>\n<td>{</td>\n</tr>\n<tr>\n<td>??&gt;</td>\n<td>}</td>\n</tr>\n<tr>\n<td>??’</td>\n<td>^</td>\n</tr>\n<tr>\n<td>??!</td>\n<td>|</td>\n</tr>\n<tr>\n<td>??-</td>\n<td>～</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h2 id=\"1-1-基本内置类型\"><a href=\"#1-1-基本内置类型\" class=\"headerlink\" title=\"1.1 基本内置类型\"></a>1.1 基本内置类型</h2><h3 id=\"1-1-1-算术类型\"><a href=\"#1-1-1-算术类型\" class=\"headerlink\" title=\"1.1.1 算术类型\"></a>1.1.1 算术类型</h3><p><code>整形（布尔/字符）</code>和<code>浮点型</code></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n<th>最小尺寸</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bool</td>\n<td>布尔类型</td>\n<td>4bit</td>\n</tr>\n<tr>\n<td>char</td>\n<td>字符</td>\n<td>8bit</td>\n</tr>\n<tr>\n<td>wchar_t</td>\n<td>宽字符</td>\n<td>16bit</td>\n</tr>\n<tr>\n<td>char16_t</td>\n<td>Unicode16</td>\n<td>16bit</td>\n</tr>\n<tr>\n<td>char32_t</td>\n<td>Unicode32</td>\n<td>32bit</td>\n</tr>\n<tr>\n<td>short</td>\n<td>短整型</td>\n<td>2个字节,16bit</td>\n</tr>\n<tr>\n<td>int</td>\n<td>整型</td>\n<td>4个字节,32bit</td>\n</tr>\n<tr>\n<td>long</td>\n<td>长整型</td>\n<td>32bit</td>\n</tr>\n<tr>\n<td>long long</td>\n<td>长整型</td>\n<td>64bit,8字节</td>\n</tr>\n<tr>\n<td>float</td>\n<td>单精度</td>\n<td>32bit,6位有效数字</td>\n</tr>\n<tr>\n<td>double</td>\n<td>双精度</td>\n<td>64bit,10位有效数字</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>扩展精度</td>\n<td>128bit,10位有效数字</td>\n</tr>\n</tbody></table>\n<ol>\n<li>一个char应可以存机器基本字符集中任意字符对应的数字值,其他字符集可以用<code>wchar_t</code>-可以扩展字符集任意字符,<code>char16_t</code>,<code>char32_t</code>-他俩则是扩展Unicode字符标准</li>\n<li>8比特等于一个字节，四个字节等于一个字符</li>\n<li>内置类型的机器实现之address地址,就是一串数字,跟着其存储(8比特)内容</li>\n<li>带符号类型和无符号类型<br><code>short</code>,<code>int</code>,<code>long</code> ,<code>long long</code> 都有<code>unsigned</code>类型。<code>char</code>,<code>signed char</code>和<code>unsigned char</code>,虽然表现是三种，但是只有两种，<code>char</code>具体表现为哪种，要看编译器</li>\n</ol>\n<ul>\n<li>如何选择类型<ol>\n<li>数值不可能为负时，用无符号类型</li>\n<li>超过了int范围，选用long long</li>\n<li>因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的。所以如果你需要使用一个不大的整数，应指定是使用unsigned char 还是signed char</li>\n<li>float 和double在计算上没差别，但是long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"1-1-2-类型转换\"><a href=\"#1-1-2-类型转换\" class=\"headerlink\" title=\"1.1.2 类型转换\"></a>1.1.2 类型转换</h3><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> b <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// i的值为1</span>\ni<span class=\"token operator\">=</span> <span class=\"token number\">3.14</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">//i的值为3</span>\n<span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> i <span class=\"token punctuation\">;</span><span class=\"token comment\">//pi的值为3.0</span>\n<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> c <span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//假设char占8比特,c的值在255,被转换</span>\n<span class=\"token keyword\">signed</span> <span class=\"token keyword\">char</span> c2 <span class=\"token operator\">=</span> <span class=\"token number\">256</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 假设char占8比特，c2的值是未定义</span></code></pre>\n\n<ol>\n<li>int -&gt; bool &#x2F;&#x2F; 0是假，1是真  </li>\n<li>bool -&gt; int &#x2F;&#x2F; false是0，真是1  </li>\n<li>float -&gt; int &#x2F;&#x2F; 只保留整数位  </li>\n<li>int -&gt; float &#x2F;&#x2F; 小数位填0  </li>\n<li>signed -&gt; unsigned &#x2F;&#x2F;符号位当成数值位转换为十进制<code>1000 0001</code>，反码为<code>1111 1110</code>，补码为<code>1111 1111(signed char)</code>,然后转换为unsigned char  <code>1111 1111</code>,十进制是<code>255</code>，或者<code>-1 + 256 mod 256 = 255</code>,如第六行代码.</li>\n<li>当我们赋给<code>符号类型</code>一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据<blockquote>\n<p>建议：避免无法预知和依赖于实现环境的行为</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><p>含有无符号类型的表达式  </p>\n<p>  例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样:</p>\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">unsigned</span> u <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i  <span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\ncout<span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">+</span> i <span class=\"token operator\">&lt;&lt;</span> endl <span class=\"token punctuation\">;</span> <span class=\"token comment\">//-84</span>\ncout <span class=\"token operator\">&lt;&lt;</span> u <span class=\"token operator\">+</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出结果4294967264</span></code></pre>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span>i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span>  i <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span>i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// 永远不会退出循环,其实是没设计好这个for statement,unsigned同样道理</span></code></pre>\n\n<p>  可以用下面语句带题</p>\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">unsigned</span> u <span class=\"token operator\">=</span><span class=\"token number\">11</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>u<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">--</span>u<span class=\"token punctuation\">;</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout<span class=\"token operator\">&lt;&lt;</span> u <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<blockquote>\n<p>提示:避免<code>signed</code>与<code>unsigned</code>混合运算，会将<code>signed</code>转换为<code>unsigned</code>类型</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"1-1-3-字面常量\"><a href=\"#1-1-3-字面常量\" class=\"headerlink\" title=\"1.1.3 字面常量\"></a>1.1.3 字面常量</h3><p>例如<code>42</code>就是字面值常量,整型,浮点,字符,字符串字面值</p>\n<ul>\n<li><p>以0开头的整数代表八进制数  </p>\n</li>\n<li><p>以0x或0X开头的代表十六进制数  </p>\n<table>\n<thead>\n<tr>\n<th>字面值</th>\n<th>类型说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>20</td>\n<td>&#x2F;&#x2F; decimal十进制</td>\n</tr>\n<tr>\n<td>024</td>\n<td>&#x2F;&#x2F;octal八进制</td>\n</tr>\n<tr>\n<td>0X14</td>\n<td>&#x2F;&#x2F; hexadecimal 十六进制</td>\n</tr>\n<tr>\n<td>128u ,128U</td>\n<td>&#x2F;&#x2F; unsigned 十进制</td>\n</tr>\n<tr>\n<td>1024UL or 8LU</td>\n<td>&#x2F;&#x2F; unsigned long</td>\n</tr>\n<tr>\n<td>1024ULL or 8LLU</td>\n<td>&#x2F;&#x2F; unsigned long long</td>\n</tr>\n<tr>\n<td>1L</td>\n<td>&#x2F;&#x2F; long 长整形</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误  </p>\n</li>\n<li><p>3.14159,3.14159E0,0.,0e0,.001  </p>\n<table>\n<thead>\n<tr>\n<th>字面值</th>\n<th>类型说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3.14159F &#x3D; 3.14159E0F</td>\n<td>&#x2F;&#x2F; float ,科学计数</td>\n</tr>\n<tr>\n<td>.001f &#x3D; 1E-3F</td>\n<td>&#x2F;&#x2F; float,科学计数</td>\n</tr>\n<tr>\n<td>12.345L &#x3D; 1.2345E1L</td>\n<td>&#x2F;&#x2F; long double 扩展精度 ,科学计数</td>\n</tr>\n<tr>\n<td>0. &#x3D; 0e0</td>\n<td>&#x2F;&#x2F; double ,科学计数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>‘a’,’Hello World!’, 字符字面值,字符串字面值</p>\n<table>\n<thead>\n<tr>\n<th>字面值</th>\n<th>类型说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>‘a’</td>\n<td>&#x2F;&#x2F; char 字符</td>\n</tr>\n<tr>\n<td>L’a’</td>\n<td>&#x2F;&#x2F; wchar_t 宽字符</td>\n</tr>\n<tr>\n<td>u’a’</td>\n<td>&#x2F;&#x2F; char16_t 宽字符</td>\n</tr>\n<tr>\n<td>U’a’</td>\n<td>&#x2F;&#x2F; char32_t 宽字符</td>\n</tr>\n<tr>\n<td>u8”hi!”</td>\n<td>&#x2F;&#x2F;utf-8字符串类型,只支持字符串</td>\n</tr>\n<tr>\n<td>nullptr</td>\n<td>&#x2F;&#x2F;指针字面值</td>\n</tr>\n<tr>\n<td>‘A’</td>\n<td>&#x2F;&#x2F;表示单个字符A</td>\n</tr>\n<tr>\n<td>“A”</td>\n<td>&#x2F;&#x2F;表示字符A和空字符两个字符的字符串</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>转义序列</p>\n<table>\n<thead>\n<tr>\n<th>语义</th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\n</td>\n<td>换行</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>纵向制表</td>\n</tr>\n<tr>\n<td>\\|反斜线</td>\n<td></td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车符号</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>横向指标符号</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退表符号</td>\n</tr>\n<tr>\n<td>?</td>\n<td>问号</td>\n</tr>\n<tr>\n<td>\\a</td>\n<td>报警符号</td>\n</tr>\n<tr>\n<td>\\“</td>\n<td>双引号</td>\n</tr>\n<tr>\n<td>\\‘</td>\n<td>单引号</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>泛化的转义序列  </p>\n<ul>\n<li>(有需要再重点看)</li>\n<li>斜线\\后面跟着的八进制数字超过3个，只有前3个数字与\\构成转义序列。例如，”\\1234”表示2个字符，即八进制数123对应的字符以及字符4</li>\n<li>\\x要用到后面跟着的所有数字，例如，”\\x1234”表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定</li>\n</ul>\n</li>\n<li><p>指定字面值的类型<br>给字面值添加前后缀，可以改变其默认类型  </p>\n<table>\n<thead>\n<tr>\n<th>前缀</th>\n<th>含义</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u</td>\n<td>16字符</td>\n<td>char16_t</td>\n</tr>\n<tr>\n<td>U</td>\n<td>32字符</td>\n<td>char32_t</td>\n</tr>\n<tr>\n<td>L</td>\n<td>宽字符</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>u8</td>\n<td>UTF-8</td>\n<td>char,仅适用于字符串</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>最小匹配类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u or U</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>l or L</td>\n<td>long</td>\n</tr>\n<tr>\n<td>ll or LL</td>\n<td>long long</td>\n</tr>\n<tr>\n<td>f or F</td>\n<td>float</td>\n</tr>\n<tr>\n<td>l or L</td>\n<td>long double</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>布尔字面值<br><code>bool test = false</code></p>\n</li>\n</ul>\n<h2 id=\"1-2-变量\"><a href=\"#1-2-变量\" class=\"headerlink\" title=\"1.2. 变量\"></a>1.2. 变量</h2><h3 id=\"1-2-1-变量定义\"><a href=\"#1-2-1-变量定义\" class=\"headerlink\" title=\"1.2.1 变量定义\"></a>1.2.1 变量定义</h3><p><code>::</code> : 命名空间符号  </p>\n<ul>\n<li><p>默认值,初始值,和列表初始化 :  </p>\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> units_sold <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//列表初始化</span>\n<span class=\"token keyword\">int</span> units_sold<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 列表初始化</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">units_sold</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//直接初始化 </span></code></pre>\n</li>\n<li><p>全局变量默认值 : 在定义变量阶段如不指定会被指定默认值  </p>\n</li>\n<li><p>定义在函数体内部的<code>内置类型</code>变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的,如果试图拷贝或以其他形式访问此类值将引发错误.类自行决定初始化方式.绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值.如果一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误</p>\n</li>\n</ul>\n<h3 id=\"1-2-2-变量声明和定义的关系\"><a href=\"#1-2-2-变量声明和定义的关系\" class=\"headerlink\" title=\"1.2.2 变量声明和定义的关系\"></a>1.2.2 变量声明和定义的关系</h3><ul>\n<li>CPP支持分离式编译，也就是定义和声明分开  </li>\n<li>extern语句如果包含初始值就不再是声明，而变成定义了  </li>\n<li>变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明</li>\n</ul>\n<h3 id=\"1-2-3-名字的作用域\"><a href=\"#1-2-3-名字的作用域\" class=\"headerlink\" title=\"1.2.3 名字的作用域\"></a>1.2.3 名字的作用域</h3><ol>\n<li>局部变量，顾名思义，生命周期作用范围只在函数内,局部变量不会对变量进行初始化，全局变量才会初始化  </li>\n<li>全局变量，存活于程序整个生命周期,extern允许你在任意地方的声明一个变量或者函数，然后允许再任何地方进行定义。</li>\n<li>嵌套的作用域 <details>\n <summary>嵌套的作用域代码demo</summary>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n\n<span class=\"token comment\">// Program for illustration purposes only: It is bad style for a function</span>\n<span class=\"token comment\">// to use a global variable and also define a local variable with the same name</span>\n\n<span class=\"token keyword\">int</span> reused <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// reused has global scope</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> unique <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// unique has block scope</span>\n\n    <span class=\"token comment\">// output #1: uses global reused; prints 42 0</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> reused <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> unique <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>   \n\n    <span class=\"token keyword\">int</span> reused <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// new, local object named reused hides global reused</span>\n\n    <span class=\"token comment\">// output #2: uses local reused; prints 0 0</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> reused <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span>  unique <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>  \n\n    <span class=\"token comment\">// output #3: explicitly requests the global reused; prints 42 0</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token double-colon punctuation\">::</span>reused <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span>  unique <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>  \n\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n </details>  \n\n output #3则是访问全局<code>reused</code>变量</li>\n</ol>\n<h2 id=\"1-3-复合类型\"><a href=\"#1-3-复合类型\" class=\"headerlink\" title=\"1.3. 复合类型\"></a>1.3. 复合类型</h2><p> 引用: 及别名</p>\n<ol>\n<li><code>int &amp;reference2</code> 报错，因为没有初始化，引用必须在定义时初始化.  </li>\n<li><code>int &amp;reference3 = reference</code>引用创建引用,reference是对象类型  </li>\n<li>将引用赋值给变量就是把引用的对象作为初始值</li>\n</ol>\n<p> 指针  </p>\n<ol>\n<li><p>块级作用域指针不被初始化也会拥有不确定值  </p>\n</li>\n<li><p><code>double *dp, *dp2</code>定义指针,访问无效指针后果无法预计</p>\n</li>\n<li><p><code>*dp = 0.0</code> 利用指针给对象赋值<br>建议<br>初始化所有定义的指针，切莫将变量直接赋值给指针,而是通过取地址符号,但是0可以直接赋值</p>\n</li>\n<li><p><code>void *</code>指针,其他任意指针都可以指向空指针,我们无法直接操作空指针</p>\n</li>\n<li><p>同时定义多个变量<code>int i=1024 , *p=&amp;i, &amp;q = i</code> , <code>int* p</code>合法容易但是产生误导</p>\n</li>\n<li><p>指向指针的指针,<code>int ival=400,int *p=&amp;ival, **pp=&amp;p</code>,同时,访问对象值,也需要解两次引用  </p>\n</li>\n<li><p>指向指针的引用  </p>\n  <details>\n  <summary>指向指针的引用demo</summary>\n\n   <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">&amp;</span>r<span class=\"token operator\">=</span>p<span class=\"token punctuation\">;</span>  \nr<span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>i <span class=\"token comment\">//取i地址，让r指向i,同时p也指向了i  </span>\n<span class=\"token operator\">*</span>r<span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token comment\">//给指针引用赋值，p指向的值也变了  </span></code></pre>\n\n   </details>\n</li>\n<li><p>指针的类型必须与其所指对象的类型一致，但是有两个例外  </p>\n<ul>\n<li>第一种例外情况是允许令一个指向常量的指针指向一个非常量对象    <details>\n  <summary>\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">      <span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span> <span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">double</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pi <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不可以，不能将变量指针绑定到常量指针</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span><span class=\"token operator\">*</span>cptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pi <span class=\"token punctuation\">;</span> <span class=\"token comment\">//合法</span>\n      <span class=\"token operator\">*</span>cptr <span class=\"token operator\">=</span> <span class=\"token number\">42</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 错误，不能给指向常量的指针赋值</span>\n      <span class=\"token keyword\">double</span> dval <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">//</span>\n      cptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>dval <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 正确，指针常量不能绑定到普通变量</span></code></pre>\n  </summary>\n  </details></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-4-CPP修饰符和const限定符\"><a href=\"#1-4-CPP修饰符和const限定符\" class=\"headerlink\" title=\"1.4. CPP修饰符和const限定符\"></a>1.4. CPP修饰符和const限定符</h2><ul>\n<li><p><code>signed</code>,<code>unsigned</code>, <code>long</code> 和 <code>short</code> 修饰整型和浮点型</p>\n  <details>\n  <summary>修饰符demo</summary>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span> </span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span> \n<span class=\"token comment\">/* * 这个程序演示了有符号整数和无符号整数之间的差别 */</span> \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">short</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> \n    <span class=\"token comment\">// 有符号短整数 </span>\n    <span class=\"token keyword\">short</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 无符号短整数 </span>\n    j <span class=\"token operator\">=</span> <span class=\"token number\">50000</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> \n    cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> j<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n  </details>\n</li>\n<li><p>类型限定符提供了变量的额外信息。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>const</td>\n<td><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td>\n</tr>\n<tr>\n<td>volatile</td>\n<td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>\n</tr>\n<tr>\n<td>restrict</td>\n<td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict.</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>const对象创建之后就不能修改发，所有创建时必须初始化</p>\n</li>\n<li><p>默认情况下const对象尽在文件内有效，多文件间共享需要使用extern关键字</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">//file.cc</span>\n<span class=\"token keyword\">extern</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> bufsize <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//file.h</span>\n<span class=\"token keyword\">extern</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> bufsize<span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>const的引用<br>常量引用可以绑定对象，但是不能修改被绑定对象的内容<br>也不能用变量绑定常量引用  </p>\n</li>\n<li><p>指向常量的指针</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> <span class=\"token operator\">*</span>cptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pi<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//指向常量的指针，指针的值不能变，但是指向的值却是可以变的</span></code></pre>\n</li>\n<li><p>常量指针<br>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型，例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span>  curErr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>errNumb<span class=\"token punctuation\">;</span> <span class=\"token comment\">//常量指针</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> pip <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pi<span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>顶层const和<br> 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响</p>\n</li>\n<li><p>constexpr和常量表达式<br> <strong>TBC</strong></p>\n</li>\n</ol>\n<h2 id=\"1-5-处理类型\"><a href=\"#1-5-处理类型\" class=\"headerlink\" title=\"1.5. 处理类型\"></a>1.5. 处理类型</h2><ol>\n<li><p>typedef意为同义词，新标准中可以使用<code>using SI = Sales_items</code>  </p>\n</li>\n<li><p>typedef的指针常量，指向常量的指针  </p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">typedef</span>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pstring<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> pstring cstr <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//指向常量的指针常量</span>\n<span class=\"token keyword\">const</span> pstring <span class=\"token operator\">*</span>ps <span class=\"token punctuation\">;</span> <span class=\"token comment\">//指针常量</span></code></pre>\n</li>\n<li><p><code>auto</code>自动判断类型类型</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> ci <span class=\"token operator\">=</span> i <span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>cr <span class=\"token operator\">=</span> ci<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> d <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>i <span class=\"token comment\">//整形指针</span>\n<span class=\"token keyword\">auto</span> e <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>ci<span class=\"token punctuation\">;</span> <span class=\"token comment\">// e是指向整型常量的指针</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\">//auto如果想推导出顶层const，需要明确写出  </span>\n<span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>h<span class=\"token operator\">=</span><span class=\"token number\">42</span>  <span class=\"token comment\">//错误，因为非常量引用无法绑定字面值</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>j<span class=\"token operator\">=</span><span class=\"token number\">42</span>  <span class=\"token comment\">//错误，因为非常量引用无法绑定字面值</span></code></pre>\n</li>\n<li><p>decltype类型提示符<br> decltype只推断类型，但不使用其值</p>\n<ul>\n<li>decltype和引用，和const</li>\n</ul>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> ci <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>cj <span class=\"token operator\">=</span> ci<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>ci<span class=\"token punctuation\">)</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>cj<span class=\"token punctuation\">)</span> y <span class=\"token operator\">=</span> x <span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>cj<span class=\"token punctuation\">)</span> z <span class=\"token punctuation\">;</span> <span class=\"token comment\">//错误，z是一个引用类型，必须初始化</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span><span class=\"token operator\">*</span>p<span class=\"token operator\">=</span><span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>r <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">//错误。必须初始化</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> d<span class=\"token punctuation\">;</span> <span class=\"token comment\">//错误，双层括号是引用类型，必须初始化</span>\n<span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> e <span class=\"token punctuation\">;</span> <span class=\"token comment\">//正确，e是一个未初始化的int</span></code></pre></li>\n</ol>\n<h2 id=\"1-6-自定义数据结构\"><a href=\"#1-6-自定义数据结构\" class=\"headerlink\" title=\"1.6. 自定义数据结构\"></a>1.6. 自定义数据结构</h2><ol>\n<li><p>strcut 关键字</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Sales_data</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">/* .....  */</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>就可以用来定义数据结构\n</code></pre>\n</li>\n<li><p>预处理器概述<br> #define指令把一个名字设定为预处理变量<br> #ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真  </p>\n <details><summary>demo</summary>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">SALES_DATA_H</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SALES_DATA_H</span></span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Sales_data</span> <span class=\"token punctuation\">&#123;</span>\n        std<span class=\"token double-colon punctuation\">::</span>string bookNo<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">unsigned</span> units_sold <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">double</span> revenue <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></code></pre>\n\n </details></li>\n</ol>\n<h2 id=\"1-7-CPP存储类-待重新拟题\"><a href=\"#1-7-CPP存储类-待重新拟题\" class=\"headerlink\" title=\"1.7 CPP存储类[待重新拟题]\"></a>1.7 CPP存储类[待重新拟题]</h2><ul>\n<li>auto<br>CPP17 弃用</li>\n<li>register<br>定义 ‘register’存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小, 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中.</li>\n<li>static 存储类<br><code>static</code> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</li>\n<li>extern<br>扩展全局变量作用域</li>\n<li>nutable 存储类</li>\n<li>thread_local 存储类<br>变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本</li>\n</ul>\n<h1 id=\"2-字符串，向量，数组\"><a href=\"#2-字符串，向量，数组\" class=\"headerlink\" title=\"2. 字符串，向量，数组\"></a>2. 字符串，向量，数组</h1><h2 id=\"2-1-using关键字\"><a href=\"#2-1-using关键字\" class=\"headerlink\" title=\"2.1. using关键字\"></a>2.1. using关键字</h2><p>   1.切记不要在header文件中使用using namespace std<br>   2. 每个名字都需要独立的using声明  </p>\n<h2 id=\"2-2-string-类型\"><a href=\"#2-2-string-类型\" class=\"headerlink\" title=\"2.2. string 类型\"></a>2.2. string 类型</h2>   <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"hi ya\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//拷贝初始化</span>\nstring <span class=\"token function\">s2</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi ya\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 直接初始化</span>\nstring <span class=\"token function\">s3</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token char\">'C'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//拷贝十个C</span>\nstd<span class=\"token double-colon punctuation\">::</span>cin <span class=\"token operator\">>></span> s3 <span class=\"token operator\">>></span>std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">,</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//从输入控制设备读入整行</span></code></pre>\n\n<ul>\n<li><p><code>string</code> 对象操作  </p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">\nos<span class=\"token operator\">&lt;&lt;</span>s <span class=\"token comment\">//将s写道os中，并返回os </span>\nis<span class=\"token operator\">>></span>s <span class=\"token comment\">//从is中读取字符串赋值给s,字符串以空白分隔，返回is</span>\n<span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>is<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//</span>\ns<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//s为空返回true，否则返回false</span>\ns<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//返回s中字符个数,函数返回的是一个无符号整型数</span>\ns<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token comment\">//返回数字索引储存的值</span>\ns1<span class=\"token operator\">+</span>s2 <span class=\"token comment\">//拼接字符串</span>\ns1<span class=\"token operator\">==</span>s2<span class=\"token punctuation\">;</span>判断字符串是否相等\ns1 <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">>=</span><span class=\"token punctuation\">]</span> s2 <span class=\"token comment\">//按照asic码进行比较</span></code></pre>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>cout<span class=\"token punctuation\">;</span> <span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n<span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n\n        string s1  <span class=\"token operator\">=</span> <span class=\"token string\">\"hello, \"</span><span class=\"token punctuation\">,</span> s2 <span class=\"token operator\">=</span> <span class=\"token string\">\"world\\n\"</span><span class=\"token punctuation\">;</span>\n        string s3 <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// s3 is hello, world\\n</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s1 <span class=\"token operator\">&lt;&lt;</span> s2 <span class=\"token operator\">&lt;&lt;</span> s3 <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\n        s1 <span class=\"token operator\">+=</span> s2<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// equivalent to s1 = s1 + s2</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s1<span class=\"token punctuation\">;</span>\n\n        string s4 <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> s5 <span class=\"token operator\">=</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// no punctuation in s4 or s2</span>\n        string s6 <span class=\"token operator\">=</span> s4 <span class=\"token operator\">+</span> <span class=\"token string\">\", \"</span> <span class=\"token operator\">+</span> s5 <span class=\"token operator\">+</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>\n        string s7 <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\", \"</span> <span class=\"token operator\">+</span> s5 <span class=\"token operator\">+</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//不合法</span>\n        string s8 <span class=\"token operator\">=</span> <span class=\"token string\">\"ABC\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"EFG\"</span> <span class=\"token operator\">+</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不合法操作</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s4 <span class=\"token operator\">&lt;&lt;</span> s5 <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span> <span class=\"token operator\">&lt;&lt;</span> s6 <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n</li>\n<li><p>处理<code>string</code>对象中的字符</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">//用for处理字符</span>\nstring <span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ABCDEFG\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> c <span class=\"token operator\">:</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">//这里的c其实是str中字符的拷贝</span>\n    cout<span class=\"token operator\">&lt;&lt;</span> c <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//改变str中的字符值</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>c <span class=\"token operator\">:</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span> c <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//下标运算符,返回字符串中的值</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre></li>\n</ul>\n<h2 id=\"2-3-vector类型\"><a href=\"#2-3-vector类型\" class=\"headerlink\" title=\"2.3. vector类型\"></a>2.3. vector类型</h2>  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> ivec<span class=\"token punctuation\">;</span> <span class=\"token comment\">//保存int类型</span>\nvector<span class=\"token operator\">&lt;</span>Sales_item<span class=\"token operator\">></span> Sales_vec<span class=\"token punctuation\">;</span> <span class=\"token comment\">//保存Sales_item变量</span>\nvector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> file  <span class=\"token punctuation\">;</span> <span class=\"token comment\">//vector存vector类型</span>\n<span class=\"token comment\">// 初始化</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v1\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">v2</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//v2中包含v1中所有副本</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v2 <span class=\"token operator\">=</span> v1 <span class=\"token comment\">//等价于 vector&lt;T> v2(v1)</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">v3</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//v3包含了n个val元素</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">v4</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token comment\">//包含了n个执行值初始化的对象</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v5<span class=\"token punctuation\">&#123;</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//v5包含了初始值个数的元素，每个元素被赋予相应的初始值，这里还有一点要注意，就是可能会放不同类型的值，但</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v5<span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//等价于vector&lt;T> v5&#123;a,b,c ...&#125;</span>\n<span class=\"token comment\">// vector的CRUD</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 是否为空</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//返回容量，类型std::size_type</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 添加值</span>\nv<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//访问下标存储的数据</span>\nv2<span class=\"token operator\">=</span>v1 <span class=\"token punctuation\">;</span><span class=\"token comment\">//v1拷贝到v2</span>\nv1 <span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//重新赋值</span>\nv1 <span class=\"token operator\">==</span> v2 <span class=\"token punctuation\">;</span><span class=\"token comment\">//时候绝对的相等，长度和内容</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">>=</span> <span class=\"token comment\">//顾名思义按照字典序进行比较</span>\nv1<span class=\"token operator\">!=</span>v2<span class=\"token punctuation\">;</span></code></pre>\n\n<ul>\n<li>无法访问索引外数据，编译期无法发现，但是运行期就会报错</li>\n</ul>\n<h2 id=\"2-4-迭代器的介绍\"><a href=\"#2-4-迭代器的介绍\" class=\"headerlink\" title=\"2.4. 迭代器的介绍\"></a>2.4. 迭代器的介绍</h2><p>除了vector之外，标准库还定义了其他容器，string也可以使用迭代器</p>\n<p>v.begin()返回第一位元素的指针,v.end()返回最后一个元素，注意end()返回的是空引用</p>\n<ul>\n<li><p>迭代器运算符包括  </p>\n<table>\n<thead>\n<tr>\n<th>符号类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*iter</td>\n<td><code>(*it).empty()</code>,返回迭代器所指元素的引用,解引用未定义迭代器都是未定义的行为，可以修改引用真实数据</td>\n</tr>\n<tr>\n<td>item</td>\n<td>解引用iter并获取该元素的名为mem的成员变量，等价于(*iter).mem</td>\n</tr>\n<tr>\n<td>++iter &#x2F; –iter &#x2F;[+-] n</td>\n<td>进行加减运算</td>\n</tr>\n<tr>\n<td>iter&#x3D;&#x3D;iter2</td>\n<td>判断两个迭代器</td>\n</tr>\n<tr>\n<td>iter1 !&#x3D; iter2</td>\n<td>判断两个迭代器不等</td>\n</tr>\n<tr>\n<td>&lt;&#x3D; ,&gt;&#x3D;</td>\n<td>要求迭代器必须指向同一个容器</td>\n</tr>\n</tbody></table>\n  <details><summary>将字符串小写符转化为大写示例</summary>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string <span class=\"token function\">s</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"some string\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">*</span>it <span class=\"token operator\">=</span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n  </details>\n\n<ol>\n<li>迭代器类型支持了以上操作</li>\n<li>如果元素是常数则返回const_iterator,不是常数则返回iterator类型</li>\n<li>it-&gt;mem和(＊it).mem表达的意思相同</li>\n<li>不能在范围for循环中向容器添加元素。<strong>另外一个</strong>限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该 vector对象的迭代器失效</li>\n</ol>\n</li>\n<li><p>将迭代器的移动</p>\n  <details><summary>迭代器移动示例</summary>\n\n  <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> it <span class=\"token operator\">!=</span> it<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">isUpper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">*</span>it <span class=\"token operator\">=</span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n</li>\n<li><p>泛型编程<br>  泛型编程更像一种高度抽象数据结构的能力</p>\n</li>\n<li><p>begin()和end()函数<br>  如果元素是常数则返回const_iterator,不是常数则返回iterator类型</p>\n  </details></li>\n</ul>\n<h2 id=\"2-5-数组\"><a href=\"#2-5-数组\" class=\"headerlink\" title=\"2.5 数组\"></a>2.5 数组</h2><p>如果不清楚元素的确切个数,请使用vector,数组的大小确定不变,不能随意向数组中增加元素.因为数组的大小固定,因此对某些特殊的应用来说程序的运行时性能较好,但是相应地也损失了一些灵活性.</p>\n<h3 id=\"2-5-1-定义和初始化内置数组\"><a href=\"#2-5-1-定义和初始化内置数组\" class=\"headerlink\" title=\"2.5.1 定义和初始化内置数组\"></a>2.5.1 定义和初始化内置数组</h3><ol>\n<li><p>显示初始化数组</p>\n <details>\n <summary>数组初始化示例</summary>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">unsigned</span> sz<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> 定义常量\n<span class=\"token keyword\">int</span> ia1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span>，<span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a3<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\nstring a4<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"byte\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a5<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span>  <span class=\"token comment\">//错误，超出容量</span></code></pre>\n\n </details></li>\n<li><p>字符数组的特殊性</p>\n<details>\n<summary>字符数组特殊性初始化示例</summary>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">char</span> a1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'c'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> a2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'c'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'+'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'\\0'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//显示胡世华空字符</span>\n<span class=\"token keyword\">char</span> a3<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"C++\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//自动初始化空字符</span>\n<span class=\"token keyword\">const</span> a4<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> <span class=\"token string\">\"Daneil\"</span>  <span class=\"token comment\">//错误没有空间存放空字符</span>\n</code></pre>\n\n</details></li>\n<li><p>不允许拷贝赋值</p>\n <details>\n <summary>不允许拷贝赋值示例</summary>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//含有三个元素的数组</span>\n<span class=\"token keyword\">int</span> a2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 错误: 不允许使用一个数组给另一个数组进行初始化</span>\n    a2 <span class=\"token operator\">=</span> a1 <span class=\"token comment\">//错误: 不允许两个数组之间直接赋值计算</span>\n </code></pre>\n\n </details>\n</li>\n<li><p>复杂数组声明</p>\n <details>\n <summary>复杂数组声明示例</summary>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptrs<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\">// 指向含有10个整型指针的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>refs<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span><span class=\"token comment\">/*?*/</span> <span class=\"token comment\">//不存在引用的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>Parrary<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 指向一个含有是个个整数的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>arrRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr <span class=\"token punctuation\">;</span> <span class=\"token comment\">//arrRef 引用指向一个含有是个整数的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>arry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ptrs <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 首先知道arry是一个引用，然后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用</span></code></pre>\n\n </details></li>\n</ol>\n<h3 id=\"2-5-2-访问数组元素\"><a href=\"#2-5-2-访问数组元素\" class=\"headerlink\" title=\"2.5.2 访问数组元素\"></a>2.5.2 访问数组元素</h3><ol>\n<li>在使用数组下标的时候，通常将其定义为size_t类型</li>\n<li>检查下标的值, CPP要检查数组下标</li>\n</ol>\n<h3 id=\"2-5-3-指针和数组\"><a href=\"#2-5-3-指针和数组\" class=\"headerlink\" title=\"2.5.3 指针和数组\"></a>2.5.3 指针和数组</h3><ol>\n<li><p>通过取地址符号获取地址</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string nums <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"one\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"two\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"three\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\nstring <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//  等价于    string *p2=nums;</span></code></pre>\n\n<p> 其中一层意思就是当使用数组作为<code>auto</code>变量初始值的时候，推断出的是指针而非数组，显然是<code>auto ia2(&amp;ia[0])</code>;但是使用decltype(ia)返回的类型是由10个整数构成的数组</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>ia<span class=\"token punctuation\">)</span> ia3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">;</span>\n ia3 <span class=\"token operator\">=</span>p <span class=\"token punctuation\">;</span><span class=\"token comment\">//错误:不能把整型指针给数组赋值， </span>\n ia3<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span><span class=\"token comment\">//正确: 把整数i赋值给ia3的一个元素</span></code></pre>\n</li>\n<li><p>指针也是迭代器,可以进行整型运算<br> 获取数组的指针后就可以通过<code>加/减</code>计算指针的值,获取指针的最后一个元素地址 <code>&amp;arr[n]</code> ,这个表示arr的长度。针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。两个指针相减的结果的类型是一种名为<code>ptrdiff_t</code>的标准库类型，和<code>size_t</code>一样，<code>ptrdiff_t</code>也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型,两指针不指向头一个对象而进行<code>加/减</code>没有意义</p>\n</li>\n<li><p>标准库函数begin()和end()</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>head <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>tail <span class=\"token operator\">=</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n<li><p>指针解引用的运算</p>\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> last <span class=\"token operator\">=</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>arr <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlast <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>last <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//是解引用last然后加4</span>\n<span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> p<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 数组下标运算可以处理负值</span>\nvector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token comment\">//下标运算不能为负值，是无符号类型</span></code></pre></li>\n</ol>\n<h3 id=\"2-5-4-C风格字符串\"><a href=\"#2-5-4-C风格字符串\" class=\"headerlink\" title=\"2.5.4 C风格字符串\"></a>2.5.4 C风格字符串</h3><ul>\n<li>支持C风格运算函数，比较字符串时候,比较第一个不相同字符的ASCII码值</li>\n<li>如果是两个字符串字面量可以用<code>+</code>进行拼接，但是如果是两个指针就需要用函数进行拼接<br>  <code>strcpy(str,ca1)</code> &#x2F;&#x2F;把ca1复制给str,一定要注意str的容量<br>  <code>strcat(str,&quot;&quot;)</code> &#x2F;&#x2F;str是字符串数组<br>  <code>strcat(str,ca2)</code> &#x2F;&#x2F; 将ca2和str继续拼接v</li>\n</ul>\n<h3 id=\"2-5-5-与旧代码的接口-兼容C代码\"><a href=\"#2-5-5-与旧代码的接口-兼容C代码\" class=\"headerlink\" title=\"2.5.5 与旧代码的接口,兼容C代码\"></a>2.5.5 与旧代码的接口,兼容C代码</h3><ol>\n<li>混合string对象和C风格字符串<br> <code>string s(&quot;hello world&quot;);</code>&#x2F;&#x2F;也允许空字符串初始化string字符串，在string对象的加法运算中允许使用以空字符结束的<code>字符数组</code>作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象.<br> 无法用<code>string</code>对象初始化字符数组，除非使用<code>s.c_str()</code>函数<code>const char *str = s.c_str();</code></li>\n<li>使用数组初始化vector对象</li>\n</ol>\n<ul>\n<li>不允许使用一个<code>数组</code>给另一个<code>内置类型数组</code>初始化  </li>\n<li><code>vector</code>允许给<code>数组</code>初始化  </li>\n<li>但是<code>数组</code>却可以给vector 进行初始化,可以是相等元素数量进行赋值，也可以是部分元素数量给<code>vector</code>赋值</li>\n</ul>\n<p>建议：尽量使用标准库类型而非数组,应该尽量使用string，避免使用C风格的基于数组的字符串</p>\n<h2 id=\"2-6-多维数组\"><a href=\"#2-6-多维数组\" class=\"headerlink\" title=\"2.6 多维数组\"></a>2.6 多维数组</h2><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">//多维数组</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">;</span><span class=\"token comment\">//将所有元素都初始化为0</span>\n<span class=\"token comment\">// 从左往右理解，定义了一个十个元素的数组，每个元素里面又能容纳一个是元素的数组。</span></code></pre>\n\n<h3 id=\"2-6-1-多维数组初始化\"><a href=\"#2-6-1-多维数组初始化\" class=\"headerlink\" title=\"2.6.1 多维数组初始化\"></a>2.6.1 多维数组初始化</h3><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/*----1-----*/</span>\n<span class=\"token comment\">//二维数组分别初始化</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*----2----*/</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这种初始化方式是等价的，但是并不会把所有元素都初始化</span>\n\n<span class=\"token comment\">/*----3----*/</span>\n<span class=\"token comment\">//显示缺省</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">7</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/*----4----*/</span>\n<span class=\"token comment\">// 只是初始化第一行</span>\n<span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></code></pre>\n\n<h3 id=\"2-6-2-多维数组的下标引用\"><a href=\"#2-6-2-多维数组的下标引用\" class=\"headerlink\" title=\"2.6.2 多维数组的下标引用\"></a>2.6.2 多维数组的下标引用</h3><p>说白了就是可以通过下标运算符进行取值，如果是三维数组，而用了两个下标运算符那么就会取出<strong>数组</strong></p>\n<h3 id=\"2-6-3-使用范围for语句处理多维数组\"><a href=\"#2-6-3-使用范围for语句处理多维数组\" class=\"headerlink\" title=\"2.6.3 使用范围for语句处理多维数组\"></a>2.6.3 使用范围for语句处理多维数组</h3><p>看如下例子,因为程序要改变数组中的值，所以要使用<code>引用</code>进行赋值。</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">size_t <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>row <span class=\"token operator\">:</span> ia<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">// row其实是数组的引用</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>col <span class=\"token operator\">:</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// col其实是整数的引用</span>\n                col <span class=\"token operator\">=</span> cnt<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">++</span>cnt<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>而如下例子代码是错的,编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）<br>,转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> row <span class=\"token operator\">:</span> ia<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> col <span class=\"token operator\">:</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h3 id=\"2-6-4-指针和多维数组\"><a href=\"#2-6-4-指针和多维数组\" class=\"headerlink\" title=\"2.6.4 指针和多维数组\"></a>2.6.4 指针和多维数组</h3><p>定义数组的时候千万别忘了这是数组的数组,所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针,例如  </p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> ia<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ia<span class=\"token punctuation\">;</span> <span class=\"token comment\">//p 是指向四个整数的数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span class=\"token comment\">//整形指针数组</span>\np <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>ia<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span class=\"token comment\">//p指向ia的尾元素</span>\n</code></pre>\n\n<p>在C++11标准中使用<code>auto</code>和<code>decltype</code>就能避免在数组前面加一个指针类型，例子如下  </p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> p <span class=\"token operator\">=</span> ia <span class=\"token punctuation\">;</span>p<span class=\"token operator\">!=</span>ia<span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> q <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> q<span class=\"token operator\">!=</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">+</span><span class=\"token number\">4</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">&lt;&lt;</span> <span class=\"token char\">''</span> <span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n</code></pre>\n\n<p>它首先令指针q指向p当前所在行的第一个元素,然后再一次<code>解引用</code>指向内层的数组的首元素，然后终止条件为<code>+4</code>,当然也可以使用标准函数<code>begin()</code>和<code>end()</code>实现相同的效果</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> p <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>ia<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> p<span class=\"token operator\">!=</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span>ia<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>ia <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> q <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> q<span class=\"token operator\">!=</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        cout<span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">&lt;&lt;</span> <span class=\"token char\">''</span> <span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span>\n</code></pre>\n\n<h3 id=\"2-6-5-类型别名简化多维数组的指针\"><a href=\"#2-6-5-类型别名简化多维数组的指针\" class=\"headerlink\" title=\"2.6.5 类型别名简化多维数组的指针\"></a>2.6.5 类型别名简化多维数组的指针</h3><p>使用<code>类型别名</code>可以简化工作  </p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">using</span> int_array  <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//新标准下的写法</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span class=\"token comment\">//等价的typedef声明</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>int_array <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> ia <span class=\"token punctuation\">;</span> p<span class=\"token operator\">!=</span> ia <span class=\"token operator\">+</span><span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>p <span class=\"token punctuation\">;</span> q<span class=\"token operator\">!=</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">+</span><span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        cout<span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>q <span class=\"token operator\">&lt;&lt;</span> <span class=\"token char\">''</span> <span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">&#125;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> endl <span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span>\n</code></pre>\n<p>程序将类型“四个整数组成的数组”命名为int_array,用类型名int_array定义外层循环<code>控制变量</code>更加简洁</p>\n<h3 id=\"2-6-6-术语表\"><a href=\"#2-6-6-术语表\" class=\"headerlink\" title=\"2.6.6 术语表\"></a>2.6.6 术语表</h3><table>\n<thead>\n<tr>\n<th>术语</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>begin</td>\n<td>是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。</td>\n</tr>\n<tr>\n<td>缓冲区溢出（buffer overflow）</td>\n<td>一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等</td>\n</tr>\n<tr>\n<td>C风格字符串（C-style string）</td>\n<td>以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错</td>\n</tr>\n<tr>\n<td>类模板（class template）</td>\n<td>用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个vector对象需要指定元素的类型：<code>vector&lt;int&gt;</code>包含int类型的元素。</td>\n</tr>\n<tr>\n<td>编译器扩展（compiler extension）</td>\n<td>某个特定的编译器为C++语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上</td>\n</tr>\n<tr>\n<td>容器（container）</td>\n<td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。</td>\n</tr>\n<tr>\n<td>容器（container）</td>\n<td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。</td>\n</tr>\n<tr>\n<td>difference_type</td>\n<td>由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。</td>\n</tr>\n<tr>\n<td>直接初始化（direct initialization）</td>\n<td>不使用赋值号（&#x3D;）的初始化形式</td>\n</tr>\n<tr>\n<td>empty()</td>\n<td>是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假。</td>\n</tr>\n<tr>\n<td>end()</td>\n<td>是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针。</td>\n</tr>\n<tr>\n<td>getline</td>\n<td>在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留。</td>\n</tr>\n<tr>\n<td>索引（index）</td>\n<td>是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置。</td>\n</tr>\n<tr>\n<td>实例化（instantiation）</td>\n<td>编译器生成一个指定的模板类或函数的过程。</td>\n</tr>\n<tr>\n<td>迭代器（iterator）</td>\n<td>是一种类型，用于访问容器中的元素或者在元素之间移动。</td>\n</tr>\n<tr>\n<td>迭代器运算（iterator arithmetic）</td>\n<td>是string或vector的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置。</td>\n</tr>\n<tr>\n<td>以空字符结束的字符串（null-terminated string）</td>\n<td>是一个字符串，它的最后一个字符后面还跟着一个空字符（’\\0’）。</td>\n</tr>\n<tr>\n<td>prtdiff_t</td>\n<td>是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。</td>\n</tr>\n<tr>\n<td>push_back</td>\n<td>是vector的成员，向vector对象的末尾添加元素。</td>\n</tr>\n<tr>\n<td>范围for语句（range for）</td>\n<td>一种控制语句，可以在值的一个特定集合内迭代。</td>\n</tr>\n<tr>\n<td>size</td>\n<td>是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type。</td>\n</tr>\n<tr>\n<td>size_t</td>\n<td>是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小。</td>\n</tr>\n<tr>\n<td>size_type</td>\n<td>是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型。</td>\n</tr>\n<tr>\n<td>string</td>\n<td>是一种标准库类型，表示字符的序列。</td>\n</tr>\n<tr>\n<td>using声明（using declaration）</td>\n<td>令命名空间中的某个名字可被程序直接使用。using 命名空间 ：： 名字；上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分命名空间：：。</td>\n</tr>\n<tr>\n<td>值初始化（value initialization）</td>\n<td>是一种初始化过程。内置类型初始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值</td>\n</tr>\n<tr>\n<td>vector</td>\n<td>是一种标准库类型，容纳某指定类型的一组元素。</td>\n</tr>\n<tr>\n<td>++运算符（++ operator）</td>\n<td>是迭代器和指针定义的递增运算符。执行“加1”操作使得迭代器指向下一个元素。</td>\n</tr>\n<tr>\n<td>[ ]运算符（[ ] operator）</td>\n<td>下标运算符。obj[j]得到容器对象obj中位置j的那个元素。索引从0开始，第一个元素的索引是0，尾元素的索引是obj.size（）-1。下标运算符的返回值是一个对象。如果p是指针、n是整数，则p[n]与＊（p+n）等价。</td>\n</tr>\n<tr>\n<td>-&gt;运算符（-&gt;operator）</td>\n<td>箭头运算符，该运算符综合了解引用操作和点操作。a-&gt;b等价于（＊a）.b。</td>\n</tr>\n<tr>\n<td>&lt;&lt;运算符<code>（&lt;&lt;operator）</code></td>\n<td>标准库类型string定义的输出运算符，负责输出string对象中的字符。</td>\n</tr>\n<tr>\n<td>&gt;&gt;运算符<code>（&gt;&gt;operator）</code></td>\n<td>标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个string对象。</td>\n</tr>\n<tr>\n<td>！运算符（！ operator）</td>\n<td>逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假。</td>\n</tr>\n<tr>\n<td>&amp;&amp;运算符（&amp;&amp;operator）</td>\n<td>逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"3-CPP流程控制\"><a href=\"#3-CPP流程控制\" class=\"headerlink\" title=\"3. CPP流程控制\"></a>3. CPP流程控制</h1><ul>\n<li>如果标准输入输出作为<code>if</code>,<code>while</code>条件，读到文件结束符判断假，或者是无效输入</li>\n</ul>\n<ol>\n<li>windows : Ctrl+Z (文件结束符)</li>\n<li>linux : Ctrl+D (文件结束符)</li>\n</ol>\n<h1 id=\"4-函数\"><a href=\"#4-函数\" class=\"headerlink\" title=\"4. 函数\"></a>4. 函数</h1><ul>\n<li><p>函数的调用</p>\n<ul>\n<li>传值</li>\n<li>传引用</li>\n</ul>\n</li>\n<li><p>参数默认值</p>\n</li>\n<li><p>Lambda表达式</p>\n</li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">int</span> z <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> z <span class=\"token operator\">+</span> x<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></code></pre>\n\n<pre class=\"language-none\"><code class=\"language-none\">[]      &#x2F;&#x2F; 沒有定义任何变量。使用未定义变量会引发错误。\n[x, &amp;y] &#x2F;&#x2F; x以传值方式传入（默认），y以引用方式传入。\n[&amp;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以引用方式加以引用。\n[&#x3D;]     &#x2F;&#x2F; 任何被使用到的外部变量都隐式地以传值方式加以引用。\n[&amp;, x]  &#x2F;&#x2F; x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n[&#x3D;, &amp;z] &#x2F;&#x2F; z显式地以引用方式加以引用。其余变量以传值方式加以引用。</code></pre>\n\n<ul>\n<li>引用<br>实际上是已知变量的另一个名字。</li>\n</ul>\n<pre class=\"language-none\"><code class=\"language-none\">int&amp;  r &#x3D; i;</code></pre>\n\n<ul>\n<li>标准IO<br>通过(std::)方式调用标准函数库，或者在函数头写<code>using namespace std</code></li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n \n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n \n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"请输入您的名称： \"</span><span class=\"token punctuation\">;</span>\n   cin <span class=\"token operator\">>></span> name<span class=\"token punctuation\">;</span>\n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"您的名称是： \"</span> <span class=\"token operator\">&lt;&lt;</span> name <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n   cerr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Error message : \"</span> <span class=\"token operator\">&lt;&lt;</span> str <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n   clog <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Error message : \"</span> <span class=\"token operator\">&lt;&lt;</span> str <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h2 id=\"4-1-struct构造初始化\"><a href=\"#4-1-struct构造初始化\" class=\"headerlink\" title=\"4.1. struct构造初始化\"></a>4.1. struct构造初始化</h2><ul>\n<li>利用自带默认构造函数</li>\n<li>参数构造</li>\n<li>自定义void init(…..){ … this-&gt;  …}<br>在建立结构体数组时,如果只写了带参数的构造函数将会出现数组无法初始化的错误！！！各位同学要牢记呀！！！</li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">int</span> data<span class=\"token punctuation\">;</span>\n string str<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">char</span> x<span class=\"token punctuation\">;</span>\n <span class=\"token comment\">//自己写的初始化函数</span>\n <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> string b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>str <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>x <span class=\"token operator\">=</span> c<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n <span class=\"token function\">node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span><span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n <span class=\"token function\">node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> string b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span><span class=\"token function\">x</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">str</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">data</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>N<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre>\n\n<h1 id=\"5-面向对象编程\"><a href=\"#5-面向对象编程\" class=\"headerlink\" title=\"5. 面向对象编程\"></a>5. 面向对象编程</h1><ul>\n<li>#include指令使用（&lt;&gt;）导入标准库函数，非标准库用双引号（” “）。</li>\n</ul>\n<details>\n<summary>类示例demo</summary>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"Books\"</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Box</span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n   \n   <span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n   \n   <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">char</span>  title<span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">char</span>  author<span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">char</span>  subject<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span>   book_id<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">double</span> length<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 长度</span>\n      <span class=\"token keyword\">double</span> breadth<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 宽度</span>\n      <span class=\"token keyword\">double</span> height<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 高度</span>\n      <span class=\"token comment\">// 成员函数声明，但是没有实现</span>\n      <span class=\"token keyword\">double</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">double</span> len<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> bre<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> hei <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 成员函数定义</span>\n<span class=\"token keyword\">double</span> <span class=\"token class-name\">Box</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> length <span class=\"token operator\">*</span> breadth <span class=\"token operator\">*</span> height<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n \n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Box</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">double</span> len<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> bre<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> hei<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    length <span class=\"token operator\">=</span> len<span class=\"token punctuation\">;</span>\n    breadth <span class=\"token operator\">=</span> bre<span class=\"token punctuation\">;</span>\n    height <span class=\"token operator\">=</span> hei<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n   Box Box1<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 声明 Box1，类型为 Box</span>\n   Box Box2<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 声明 Box2，类型为 Box</span>\n   Box Box3<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 声明 Box3，类型为 Box</span>\n   <span class=\"token keyword\">double</span> volume <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 用于存储体积</span>\n \n   <span class=\"token comment\">// box 1 详述</span>\n   Box1<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> <span class=\"token number\">5.0</span><span class=\"token punctuation\">;</span> \n   Box1<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">6.0</span><span class=\"token punctuation\">;</span> \n   Box1<span class=\"token punctuation\">.</span>breadth <span class=\"token operator\">=</span> <span class=\"token number\">7.0</span><span class=\"token punctuation\">;</span>\n \n   <span class=\"token comment\">// box 2 详述</span>\n   Box2<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> <span class=\"token number\">10.0</span><span class=\"token punctuation\">;</span>\n   Box2<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">12.0</span><span class=\"token punctuation\">;</span>\n   Box2<span class=\"token punctuation\">.</span>breadth <span class=\"token operator\">=</span> <span class=\"token number\">13.0</span><span class=\"token punctuation\">;</span>\n \n   <span class=\"token comment\">// box 1 的体积</span>\n   volume <span class=\"token operator\">=</span> Box1<span class=\"token punctuation\">.</span>height <span class=\"token operator\">*</span> Box1<span class=\"token punctuation\">.</span>length <span class=\"token operator\">*</span> Box1<span class=\"token punctuation\">.</span>breadth<span class=\"token punctuation\">;</span>\n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Box1 的体积：\"</span> <span class=\"token operator\">&lt;&lt;</span> volume <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n \n   <span class=\"token comment\">// box 2 的体积</span>\n   volume <span class=\"token operator\">=</span> Box2<span class=\"token punctuation\">.</span>height <span class=\"token operator\">*</span> Box2<span class=\"token punctuation\">.</span>length <span class=\"token operator\">*</span> Box2<span class=\"token punctuation\">.</span>breadth<span class=\"token punctuation\">;</span>\n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Box2 的体积：\"</span> <span class=\"token operator\">&lt;&lt;</span> volume <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n \n \n   <span class=\"token comment\">// box 3 详述</span>\n   Box3<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">16.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   volume <span class=\"token operator\">=</span> Box3<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Box3 的体积：\"</span> <span class=\"token operator\">&lt;&lt;</span> volume <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n</details>\n\n<ul>\n<li>CPP支持文件重定向<code>$ addItems &lt;infile &gt;outfile</code> 可直接从文件读数据然后计算</li>\n</ul>\n<details>\n  <summary>文件重定向Sales_item代码</summary>\n <blockcode>\n\n <pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">  <span class=\"token comment\">/*\n * This file contains code from \"C++ Primer, Fifth Edition\", by Stanley B.\n * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the\n * copyright and warranty notices given in that book:\n * \n * \"Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.\"\n * \n * \n * \"The authors and publisher have taken care in the preparation of this book,\n * but make no expressed or implied warranty of any kind and assume no\n * responsibility for errors or omissions. No liability is assumed for\n * incidental or consequential damages in connection with or arising out of the\n * use of the information or programs contained herein.\"\n * \n * Permission is granted for this code to be used for educational purposes in\n * association with the book, given proper citation if and when posted or\n * reproduced.Any commercial use of this code requires the explicit written\n * permission of the publisher, Addison-Wesley Professional, a division of\n * Pearson Education, Inc. Send your request for permission, stating clearly\n * what code you would like to use, and in what specific way, to the following\n * address: \n * \n *     Pearson Education, Inc.\n *     Rights and Permissions Department\n *     One Lake Street\n *     Upper Saddle River, NJ  07458\n *     Fax: (201) 236-3290\n*/</span> \n\n<span class=\"token comment\">/* This file defines the Sales_item class used in chapter 1.\n * The code used in this file will be explained in\n * Chapter 7 (Classes) and Chapter 14 (Overloaded Operators)\n * Readers shouldn't try to understand the code in this file\n * until they have read those chapters.\n*/</span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">SALESITEM_H</span></span>\n<span class=\"token comment\">// we're here only if SALESITEM_H has not yet been defined </span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SALESITEM_H</span></span>\n\n<span class=\"token comment\">// Definition of Sales_item class and related functions goes here</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Sales_item</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">// these declarations are explained section 7.2.1, p. 270 </span>\n<span class=\"token comment\">// and in chapter 14, pages 557, 558, 561</span>\n<span class=\"token keyword\">friend</span> std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">friend</span> std<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">friend</span> <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">friend</span> <span class=\"token keyword\">bool</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">==</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\">// constructors are explained in section 7.1.4, pages 262 - 265</span>\n    <span class=\"token comment\">// default constructor needed to initialize members of built-in type</span>\n    <span class=\"token function\">Sales_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Sales_item</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token operator\">&amp;</span>book<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token function\">bookNo</span><span class=\"token punctuation\">(</span>book<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">Sales_item</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream <span class=\"token operator\">&amp;</span>is<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> is <span class=\"token operator\">>></span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\">// operations on Sales_item objects</span>\n    <span class=\"token comment\">// member binary operator: left-hand operand bound to implicit this pointer</span>\n    Sales_item<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">+=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// operations on Sales_item objects</span>\n    std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> bookNo<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">double</span> <span class=\"token function\">avg_price</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// private members as before</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    std<span class=\"token double-colon punctuation\">::</span>string bookNo<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// implicitly initialized to the empty string</span>\n    <span class=\"token keyword\">unsigned</span> units_sold <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// explicitly initialized</span>\n    <span class=\"token keyword\">double</span> revenue <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// used in chapter 10</span>\n<span class=\"token keyword\">inline</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">compareIsbn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> lhs<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// nonmember binary operator: must declare a parameter for each operand</span>\nSales_item <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">bool</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">==</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// must be made a friend of Sales_item</span>\n    <span class=\"token keyword\">return</span> lhs<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">&amp;&amp;</span>\n           lhs<span class=\"token punctuation\">.</span>revenue <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span>revenue <span class=\"token operator\">&amp;&amp;</span>\n           lhs<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">bool</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">!=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>lhs <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// != defined in terms of operator==</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// assumes that both objects refer to the same ISBN</span>\nSales_item<span class=\"token operator\">&amp;</span> Sales_item<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span><span class=\"token operator\">+=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n    units_sold <span class=\"token operator\">+=</span> rhs<span class=\"token punctuation\">.</span>units_sold<span class=\"token punctuation\">;</span> \n    revenue <span class=\"token operator\">+=</span> rhs<span class=\"token punctuation\">.</span>revenue<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// assumes that both objects refer to the same ISBN</span>\nSales_item \n<span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span> lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n    Sales_item <span class=\"token function\">ret</span><span class=\"token punctuation\">(</span>lhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// copy (|lhs|) into a local object that we'll return</span>\n    ret <span class=\"token operator\">+=</span> rhs<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// add in the contents of (|rhs|) </span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// return (|ret|) by value</span>\n<span class=\"token punctuation\">&#125;</span>\n\nstd<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> in<span class=\"token punctuation\">,</span> Sales_item<span class=\"token operator\">&amp;</span> s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">double</span> price<span class=\"token punctuation\">;</span>\n    in <span class=\"token operator\">>></span> s<span class=\"token punctuation\">.</span>bookNo <span class=\"token operator\">>></span> s<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">>></span> price<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// check that the inputs succeeded</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span>\n        s<span class=\"token punctuation\">.</span>revenue <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">*</span> price<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> \n        s <span class=\"token operator\">=</span> <span class=\"token function\">Sales_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// input failed: reset object to default state</span>\n    <span class=\"token keyword\">return</span> in<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\nstd<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span> \n<span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span> out<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Sales_item<span class=\"token operator\">&amp;</span> s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    out <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">isbn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span>units_sold <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span>\n        <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span>revenue <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">avg_price</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> out<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">double</span> <span class=\"token class-name\">Sales_item</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">avg_price</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>units_sold<span class=\"token punctuation\">)</span> \n        <span class=\"token keyword\">return</span> revenue<span class=\"token operator\">/</span>units_sold<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">else</span> \n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></code></pre>\n\n </blockcode>\n</details>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"Sales_item.cc\"</span></span>\n\n \n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n    Sales_item item1<span class=\"token punctuation\">,</span> item2<span class=\"token punctuation\">;</span>\n\n    std<span class=\"token double-colon punctuation\">::</span>cin <span class=\"token operator\">>></span> item1 <span class=\"token operator\">>></span> item2<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//read a pair of transactions</span>\n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> item1 <span class=\"token operator\">+</span> item2 <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//print their sum</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h2 id=\"5-1-继承与多继承\"><a href=\"#5-1-继承与多继承\" class=\"headerlink\" title=\"5.1. 继承与多继承\"></a>5.1. 继承与多继承</h2><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n \n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">// 基类</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Shape</span> \n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">void</span> <span class=\"token function\">setWidth</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> w<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">&#123;</span>\n         width <span class=\"token operator\">=</span> w<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token keyword\">void</span> <span class=\"token function\">setHeight</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">&#123;</span>\n         height <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">int</span> width<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">// 派生类, 多继承就是写成 class Rectangle: public Shape, public square &#123; ... &#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Rectangle</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Shape</span></span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">int</span> <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">&#123;</span> \n         <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>width <span class=\"token operator\">*</span> height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n      <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n   Rectangle Rect<span class=\"token punctuation\">;</span>\n \n   Rect<span class=\"token punctuation\">.</span><span class=\"token function\">setWidth</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   Rect<span class=\"token punctuation\">.</span><span class=\"token function\">setHeight</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n   <span class=\"token comment\">// 输出对象的面积</span>\n   cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Total area: \"</span> <span class=\"token operator\">&lt;&lt;</span> Rect<span class=\"token punctuation\">.</span><span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n \n   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<table>\n<thead>\n<tr>\n<th>访问</th>\n<th>public</th>\n<th>protected</th>\n<th>private</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>同一个类</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>派生类</td>\n<td>yes</td>\n<td>yes</td>\n<td>no</td>\n</tr>\n<tr>\n<td>外部的类</td>\n<td>yes</td>\n<td>no</td>\n<td>no</td>\n</tr>\n</tbody></table>\n<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n<ul>\n<li>基类的构造函数、析构函数和拷贝构造函数。</li>\n<li>基类的重载运算符。</li>\n<li>基类的友元函数。</li>\n</ul>\n<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>\n<ul>\n<li><strong>公有继承（public）：</strong> 当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>\n<li><strong>保护继承（protected）：</strong>  当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>\n<li><strong>私有继承（private）：</strong> 当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>\n</ul>\n<h2 id=\"5-3-函数，运算符重载\"><a href=\"#5-3-函数，运算符重载\" class=\"headerlink\" title=\"5.3. 函数，运算符重载\"></a>5.3. 函数，运算符重载</h2><ul>\n<li>函数签名不同的叫函数重载</li>\n<li>运算符重载</li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">类成员函数\nBox <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Box<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">类的非成员函数\nBox <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Box<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Box<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n\n<h2 id=\"5-4-多态\"><a href=\"#5-4-多态\" class=\"headerlink\" title=\"5.4. 多态\"></a>5.4. 多态</h2><p>如果对象具有继承关系，那么CPP会更具具体的对象类型调用具体的成员函数长度</p>\n<h2 id=\"5-5-CPP接口\"><a href=\"#5-5-CPP接口\" class=\"headerlink\" title=\"5.5. CPP接口\"></a>5.5. CPP接口</h2><pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Box</span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n      <span class=\"token comment\">// 纯虚函数</span>\n      <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getVolume</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">double</span> length<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 长度</span>\n      <span class=\"token keyword\">double</span> breadth<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 宽度</span>\n      <span class=\"token keyword\">double</span> height<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 高度</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></code></pre>\n\n<p>实现类必须要实现抽象安徽念书(虚函数)</p>\n"},{"title":"SAF mechanism replication","_content":"","source":"_posts/SAF_mechanism.md","raw":"---\ntitle: SAF mechanism replication\ncategories: \n- 分布式\n---","slug":"SAF_mechanism","published":1,"date":"2022-07-26T09:00:17.944Z","updated":"2022-07-26T13:58:24.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5e0003l1dbgvrsb7zl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Linux命令行与shell腳本編程大全","_content":"\n- [1. linux入门](#1-linux入门)\n- [2. 走进shell](#2-走进shell)\n- [3. 基本shell命令](#3-基本shell命令)\n  - [3.1 启动shell](#31-启动shell)\n  - [3.2 bash 手册](#32-bash-手册)\n  - [3.4 文件系统](#34-文件系统)\n- [4. 其他shell命令](#4-其他shell命令)\n  - [4.1 监控程序](#41-监控程序)\n  - [4.2 磁盘空间监控](#42-磁盘空间监控)\n  - [4.3 处理文件](#43-处理文件)\n  - [4.4 date命令及其格式化](#44-date命令及其格式化)\n- [5. 理解shell](#5-理解shell)\n  - [5.1 shell的类型](#51-shell的类型)\n  - [5.2 shell的父子关系](#52-shell的父子关系)\n    - [5.2.1 进程列表](#521-进程列表)\n    - [5.2.2 子shell的其他用法](#522-子shell的其他用法)\n  - [5.3 理解shell的内建命令](#53-理解shell的内建命令)\n    - [5.3.1 外部命令](#531-外部命令)\n    - [5.3.2 内部命令](#532-内部命令)\n- [6. 环境变量](#6-环境变量)\n- [7. linux文件权限](#7-linux文件权限)\n  - [7.1 linux的安全性](#71-linux的安全性)\n    - [7.1.1 添加linux用户](#711-添加linux用户)\n    - [7.1.2 删除用户](#712-删除用户)\n    - [7.1.2 修改用户](#712-修改用户)\n  - [7.2 使用linux组](#72-使用linux组)\n  - [7.3 理解文件权限](#73-理解文件权限)\n  - [7.4 改变安全性设置](#74-改变安全性设置)\n  - [7.5 共享文件](#75-共享文件)\n- [9. 安装软件程序](#9-安装软件程序)\n  - [9.1 包管理工具](#91-包管理工具)\n  - [9.2 基于Debian的系统](#92-基于debian的系统)\n    - [9.2.1 用aptitude 管理软件包](#921-用aptitude-管理软件包)\n  - [9.3 基于源码安装](#93-基于源码安装)\n- [10. 使用编辑器](#10-使用编辑器)\n  - [10.1 vim 编辑器](#101-vim-编辑器)\n- [11.基本脚本](#11基本脚本)\n- [12. 使用结构化命令](#12-使用结构化命令)\n- [13. for 循环](#13-for-循环)\n  - [13.1 for命令](#131-for命令)\n  - [13.2 C语言风格](#132-c语言风格)\n  - [13.3 while语句](#133-while语句)\n  - [13.4 until命令](#134-until命令)\n  - [13.5 循环处理数据并以特定分隔符分割数据](#135-循环处理数据并以特定分隔符分割数据)\n- [14. 处理用户输入](#14-处理用户输入)\n  - [14.1 读取参数，脚本名和测试参数](#141-读取参数脚本名和测试参数)\n  - [14.2 处理选项](#142-处理选项)\n  - [14.3 获取用户输入](#143-获取用户输入)\n- [15. 呈现数据](#15-呈现数据)\n  - [15.1 理解输入和输出](#151-理解输入和输出)\n    - [15.1.1 标准文件描述符](#1511-标准文件描述符)\n    - [15.1.2 重定向错误](#1512-重定向错误)\n  - [15.2 在脚本中重定向输出](#152-在脚本中重定向输出)\n    - [15.2.1 临时重定向](#1521-临时重定向)\n    - [15.2.2 永久重定向](#1522-永久重定向)\n  - [15.3 在脚本中重定向输入](#153-在脚本中重定向输入)\n  - [15.4 创建自己的重定向](#154-创建自己的重定向)\n    - [15.4.1 创建输出文件描述符](#1541-创建输出文件描述符)\n    - [15.4.2 重定向文件描述符](#1542-重定向文件描述符)\n    - [15.4.3 创建输入文件描述符](#1543-创建输入文件描述符)\n    - [15.4.4 创建读写文件描述符](#1544-创建读写文件描述符)\n    - [15.4.5 关闭文件描述符](#1545-关闭文件描述符)\n  - [15.5 列出未关闭的文件描述符](#155-列出未关闭的文件描述符)\n  - [15.6 组织命令输出](#156-组织命令输出)\n  - [15.7 创建临时文件](#157-创建临时文件)\n    - [15.7.1 创建本地临时文件](#1571-创建本地临时文件)\n    - [15.7.2 在/temp/创建临时文件](#1572-在temp创建临时文件)\n    - [15.7.3 创建临时目录](#1573-创建临时目录)\n  - [15.8 记录消息](#158-记录消息)\n  - [15.9 实战](#159-实战)\n- [16. 控制脚本](#16-控制脚本)\n  - [16.1 处理信号](#161-处理信号)\n    - [16.1.1 重温linux信号](#1611-重温linux信号)\n    - [16.1.2 生成信号](#1612-生成信号)\n    - [16.1.3 捕获信号](#1613-捕获信号)\n    - [16.1.4 捕获脚本退出](#1614-捕获脚本退出)\n    - [16.1.5 修改或移除捕获](#1615-修改或移除捕获)\n  - [16.2 以后台模式运行脚本](#162-以后台模式运行脚本)\n    - [16.2.1 后台运行脚本](#1621-后台运行脚本)\n    - [16.2.2 运行多个后台作业](#1622-运行多个后台作业)\n    - [16.2.3 在非控制台下运行程序](#1623-在非控制台下运行程序)\n  - [16.4 作业控制](#164-作业控制)\n    - [16.4.1 查看作业](#1641-查看作业)\n    - [16.4.2 重启停止的作业](#1642-重启停止的作业)\n  - [16.5 调整谦让度](#165-调整谦让度)\n    - [16.5.1 nice 命令](#1651-nice-命令)\n    - [16.5.2 renice 命令](#1652-renice-命令)\n  - [16.6 定时运行作业](#166-定时运行作业)\n    - [16.6.1 用at命令来计划执行作业](#1661-用at命令来计划执行作业)\n    - [16.6.2 安排需要定期执行的脚本](#1662-安排需要定期执行的脚本)\n    - [16.6.3 使用新shell启动脚本](#1663-使用新shell启动脚本)\n- [17. 创建函数](#17-创建函数)\n  - [17.1 基本的脚本函数](#171-基本的脚本函数)\n    - [17.1.1 创建函数](#1711-创建函数)\n    - [17.1.2 使用函数](#1712-使用函数)\n  - [17.2 返回值](#172-返回值)\n    - [17.2.1 默认退出状态码](#1721-默认退出状态码)\n    - [17.2.2 使用return命令](#1722-使用return命令)\n    - [17.2.3 使用函数输出](#1723-使用函数输出)\n  - [17.3 在函数中使用变量](#173-在函数中使用变量)\n    - [17.3.1 向函数传递参数](#1731-向函数传递参数)\n    - [17.3.2 在函数中处理变量](#1732-在函数中处理变量)\n  - [17.4 数组变量和函数](#174-数组变量和函数)\n    - [17.4.2 从函数中返回数组](#1742-从函数中返回数组)\n  - [17.5 函数递归](#175-函数递归)\n  - [17.6 创建库](#176-创建库)\n  - [17.7 在命令行上使用函数](#177-在命令行上使用函数)\n    - [17.7.1 在命令上创建函数](#1771-在命令上创建函数)\n    - [17.7.2 在.bashrc 文件中定义函数](#1772-在bashrc-文件中定义函数)\n  - [17.8 实例](#178-实例)\n    - [17.8.1 下载安装第三方库](#1781-下载安装第三方库)\n    - [17.8.2 构建库](#1782-构建库)\n    - [17.8.3 shtool库函数](#1783-shtool库函数)\n    - [17.8.4 使用库](#1784-使用库)\n- [18. 图形化界面中脚本编程](#18-图形化界面中脚本编程)\n- [19.初识sed和gawk](#19初识sed和gawk)\n  - [19.1 文本处理](#191-文本处理)\n    - [19.1.1 sed编辑器](#1911-sed编辑器)\n  - [19.2 sed and gawk进阶](#192-sed-and-gawk进阶)\n- [20.正则表达式](#20正则表达式)\n  - [20.1 什么是正则表达式](#201-什么是正则表达式)\n  - [20.2 定义BRE模式](#202-定义bre模式)\n    - [20.2.1. 纯文本](#2021-纯文本)\n    - [20.2.2 特殊字符](#2022-特殊字符)\n    - [20.2.3 锚定字符](#2023-锚定字符)\n    - [20.2.4 点字符](#2024-点字符)\n    - [20.2.5 字符数组](#2025-字符数组)\n    - [20.2.6 排除型字符](#2026-排除型字符)\n    - [20.2.7 区间](#2027-区间)\n    - [20.2.8 特殊的字符数组](#2028-特殊的字符数组)\n    - [20.2.9 星号](#2029-星号)\n- [AppendIndex](#appendindex)\n\n# 1. linux入门\n\nlinux是一款开源操作系统统称，其有很多发行版本，像ubuntu..，它的核心是其`内核`，早期由linus torvalds开发\n\n![linus本人](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da5122af2d44d499197cd6eafe8fc02~tplv-k3u1fbpfcp-watermark.image?)\n\n内核主要负责以下四种功能:\n\n- 系统内存管理\n- 软件程序管理\n    linux管理所有运行程序的进程.内核启动时会将`init`进程加载到`虚拟内存`，一些发行版本在`/etc/inittab`位置进行管理自启动进程,ubuntu则是在`/etc/init.d`或者`/etc/rcX.d`,`/etc/rcX.d`，`X`是某一特定是某一特定类型的进程，如下`rc0.d/`,`rc1.d/`,`rc2.d/`,`rc3.d/`,`rc4.d/`,`rc5.d/`,`rc6.d/`,`rcS.d/`运行级为**1**时，只启动基本的系统进程以及一个控制台终端进程。称之为**单用户模式**。单用户模式通常用来在系统有问题时进行紧急的文件系统维护。在这种模式下，仅有一个人（通常是系统管理员）能登录到系统上操作数据（这块部分以后涉及再补充也来的急，别深究）\n- 硬件设备管理\n  两种方式将驱动程序插入到系统内核\n  1. 编译进内核的设备驱动代码\n     - 以前加入新的驱动要重新编译内核，效率低下\n  2. 可插入内核的设备驱动模块\n      可插拔式内核驱动，Linux系统将硬件设备当成特殊的文件，称为`设备文件`。设备文件有3种分类：\n      - 字符型设备文件\n      - 块设备文件\n      - 网络设备文件\n\n- 文件系统管理\n    linux自有的诸多文件系统外，Linux还支持从其他操作系统（比如Microsoft Windows）采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持\n\n# 2. 走进shell\n\n在图形化桌面出现之前，与Unix(linux是兼容unix操作系统)系统进行交互的唯一方式就是借助由shell所提供的`文本命令`行界面(command line interface，CLI),是一种同Linux系统交互的直接接口\n\n# 3. 基本shell命令\n\n## 3.1 启动shell\n\n- `/etc/passwd`包含用户的基本信息,如下输出\n\n```bash\nchristine: x :501:501:Christine Bresnahan:/home/christine:/bin/bash\n```\n\n位置以此类推是用户名,密码,UID,GID,用户文本描述,家目录,默认启动启动bash作为自己的shell命令(第七章将有详细描述),目前绝大多数linux发行版将密码放在`/etc/shadow`目录下,普通方式是无法直接看到的\n\n## 3.2 bash 手册\n\nlinux自带命令手册，方便用户查看相关命令的具体选项和参数。在手册左上角括号内的数字表明对应的内容区域。每个内容区域都分配了一个数字，\n\n|序号|解释|\n|---|---|\n|1|可执行程序或shell命令|\n|2|系统调用|\n|3|库调用|\n|4|特殊文件|\n|5|文件格式与约定|\n|6|游戏|\n|7|概览,约定及杂项|\n|8|超级用户和系统管理员命令|\n|9|内核例程|\n\n如果你忘了命令的关键字那么可以使用`man -k`的方式查找命令，比如`mkdir`,就可以使用`man -k mkdir`,就可以检索出与`mkdir`相关的命令.\n包括对系统主机名的概述。要想查看所需要的页面，输入`man section linux-CMD-sytax`。对手册页中的第1部分而言，就是输入`man 1 hostname`。对于手册页中的第7部分，就是输入`man 7 hostname`  \n手册页不是唯一的参考资料。还有另一种叫作info页面的信息。可以输入`info info`来了解info页面的相关内容。\n\n## 3.4 文件系统\n\n简单理解，linux文件系统跟windows的文件布局是不一样的。\n\n- linux 文件系统\n  |目录|描述|\n  |---|---|\n  |/bin |二进制目录，存放许多用户级的GNU工具|\n  |/boot |启动目录，存放启动文件|\n  |/dev |设备目录，Linux在这里创建设备节点|\n  |/etc |系统配置文件目录|\n  |/home |主目录，Linux在这里创建用户目录|\n  |/lib |库目录，存放系统和应用程序的库文件|\n  |/media| 媒体目录，可移动媒体设备的常用挂载点|\n  |/mnt |挂载目录，另一个可移动媒体设备的常用挂载点|\n  |/opt |可选目录，常用于存放第三方软件包和数据文件|\n  |/proc |进程目录，存放现有硬件及当前进程的相关信息|\n  |/root |root用户的主目录|\n  |/sbin |系统二进制目录，存放许多GNU管理员级工具|\n  |/run |运行目录，存放系统运作时的运行时数据|\n  |/srv |服务目录，存放本地服务的相关文件|\n  |/sys |系统目录，存放系统硬件信息的相关文件|\n  |/tmp |临时目录，可以在该目录中创建和删除临时工作文件|\n  |/usr |用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里|\n  |/var |可变目录，用以存放经常变化的文件，比如日志文件|\n\n- 遍历目录(cd命令)\n  需要你知道文件树状结构,这样才能知道你将访问文件的具体位置，无论是`相对路径`还是`绝对路径`\n  `cd`命令，这时要注意文件系统的相对路径和绝对路径问题，linux通过这两种方式确定目录位置，符号`/`是表示根目录\n  - 绝对路径  通过从root目录开始一层一层的进行访问，最终访问到目标文件或者目录,`/bin/bash`从根目录定位到bash\n  - 相对路径\n    - `./` 当前目录\n    - `../` 上层目录\n    - `~/` 表示当前用户home目录\n\n  ```bash\n  cd ~/   # 进到对应账号的home目录下\n  cd /home/kirkzhang  #使用绝对路径进入家目录\n  ```\n\n- 目录列表(ls命令)\n  `ls`按照字母序列,参数`-l` 显示长列表,更多参数查看ls手册\n  - 问号（?）代表一个字符\n  - 星号（*）代表零个或多个字符\n- 文件链接\n  - 软连接\n    当我们需要相同文件时,不必要在每个文件夹下都放一份文件夹，只需要使用软链接\n    ls -s /usr/local/mysql/bin/mysql /usr/bin\n  - 硬链接\n\n# 4. 其他shell命令\n\n\n\n## 4.1 监控程序\n\n- ps查看进程\n\n  ```bash\n  ps 选项\n  -A 显示所有进程 \n  -N 显示与指定参数不符的所有进程 \n  -a 显示除控制进程（session leader①）和无终端进程外的所有进程 \n  -d 显示除控制进程外的所有进程 \n  -e 显示所有进程 \n  -C cmdlist 显示包含在cmdlist列表中的进程 \n  -G grplist 显示组ID在grplist列表中的进程 \n  -U userlist 显示属主的用户ID在userlist列表中的进程 \n  -g grplist 显示会话或组ID在grplist列表中的进程② \n  -p pidlist 显示PID在pidlist列表中的进程\n  -f 完整格式输出\n  ```\n\n  命令输出关键词意义\n  |名词|解释|\n  |---|---|\n  |UID|启动这些进程的用户  |\n  |PID|进程的ID  |\n  |PPID|父进程的进程号（如果该进程是由另一个进程启动的）  |\n  |C|进程生命周期中的CPU利用率 |\n  |STIME|进程启动时的系统时间 |\n  |TTY|进程启动时的终端设  |\n  |TIME|运行进程需要的累计CPU时间  |\n  |CMD|启动的程序名称|\n\n- top实时监控\n  - 第一行：当前时间，系统运行时间，登录用户数，系统的平均负载(15分钟的参数越大且超过，说明有问题)  \n  - 第二行：进程状态  \n  - 第三行：CPU相关数值，使用率  \n\n  |名词|解释|\n  |---|---|\n  |PID：|进程的ID|  \n  |USER：|进程属主的名字  |\n  |PR：|进程的优先级  |\n  |NI：|进程的谦让度度|\n  |VIRT：|进程占用的虚拟内存总量|\n  |RES：|进程占用的物理内存总量  |\n  |SHR：|进程和其他进程共享的内存总量|\n  |S：|进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表 跟踪状态或停止状态，Z代表僵化状态) |\n  |%CPU：|进程使用的CPU时间比例  |\n  |%MEM：||进程使用的内存占可用内存的比例  |\n  |TIME+：|自进程启动到目前为止的CPU时间总量|\n  |COMMAND|：进程所对应的命令行名称，也就是启动的程序名  |\n- kill结束进程\n  | 信号 | 名称 |描述|\n  | --- | --- |---|\n  | 1 | HUP | 挂起 |\n  | 2 | INT | 中断 |\n  | 3 | QUIT | 退出 |\n  | 9 | KILL | 无条件终止 |\n  | 11 | SEGV | 段错误 |\n  | 15 | TERM | 尽可能终止 |\n  | 17 | STOP | 无条件终止 |\n  | 18 | TSTP | 停止或暂停，但在后台运行 |\n  | 19 | CONT | 在STOP或TSTP之后恢复执行 |\n- 系统performance监控\n  这个要下载`sysstat`程序。\n  - iostat - reports CPU statistics and input/output statistics for block devices and partitions.\n  - mpstat - Processors Statistics\n    - `mpstat -P ALl` 所有processor\n    - `mpstat -P ALL 2 5` 迭代五次间隔两秒\n  - pidstat - Process and Kernel Threads Statistics\n  - tapestat - reports statistics for tape drives connected to the system\n  - cifsiostat - reports CIFS statistics.\n\n## 4.2 磁盘空间监控\n\n- mount挂在存储媒体\n  `mount`提供如下信息`媒体设备名`,`挂载点`,`文件类型`,`访问方式`  \n\n  ```bash\n  #将A设备挂在到B目录上,type 参数指定了磁盘被格式化的文件系统类型,如`vfat`,`iso9660`,`ntfs`,例如`mount -t vfat /dev/sdb1 /media/  disk`\n  mount -t type  A  B  \n  ```\n\n- mount参数列表，详情见man手册，或者如下\n  |参 数|  描 述 |\n  |---|---|\n  |-a|挂载/etc/fstab文件中指定的所有文件系统|\n  |-f|使 mount 命令模拟挂载设备，但并不真的挂载|\n  |-F|和 -a 参数一起使用时，会同时挂载所有文件系统|\n  |-v|详细模式，将会说明挂载设备的每一步|\n  |-I|不启用任何/sbin/mount.filesystem下的文件系统帮助文件|\n  |-l|给ext2、ext3或XFS文件系统自动添加文件系统标签|\n  |-n| 挂载设备，但不注册到/etc/mtab已挂载设备文件中|\n  |-p| num进行加密挂载时，从文件描述符 num 中获得密码短语|\n  |-s| 忽略该文件系统不支持的挂载选项|\n  |-r| 将设备挂载为只读的|\n  |-w| 将设备挂载为可读写的（默认参数）|\n  |-L label|  将设备按指定的 label 挂载|\n  |-U uuid|  将设备按指定的 uuid 挂载|\n  |-O| 和 -a 参数一起使用，限制命令只作用到特定的一组文件系统上|\n  |-o| 给文件系统添加特定的选项|\n- `-o`参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。以下为常用的选项\n\n  ```bash\n  ro #只读挂载  \n  rw #读写挂载\n  user #允许普通用户挂在\n  loop #挂载一个文件\n  check=none #挂载时进行完整性校验\n  ```\n\n- unmount 卸载设备\n\n  ```bash\n  unmount [directory | device] # //卸载文件应在外侧目录完成,命令行提示符仍然在挂载设备的文件系统目录中，`umount` 命令无法卸载该镜像\n  ```\n\n- df 查看文件大小  \n\n  ```bash\n  df -h #以M,G描述问价大小\n  ```\n\n- du 查看文件大小\n\n  ```bash\n  -c #显示所有已列出文件总的大小(还是不宜读)\n  -h #按用户易读的格式输出大小，即用K替代千字节\n  -s #显示每个输出参数的总计\n  ```\n\n- find\n\n  ```bash\n  find 目录 -\n  ```\n  \n## 4.3 处理文件  \n\n- sort - 文件排序  \n\n  ```bash\n   -n  #sort命令会把数字当做字符来执行标准的字符排序,解决\n   -M  #按照月份排序\n   -k  #和`-t`参数在对按字段分隔的数据进行排序时非常有用`sort -t ':' -k 3 -n /etc/passwd`\n   -n  #按照数值排序du -hs * | sort -nr\n   -r  #反向排序 \n   ```\n\n- grep - 搜索文件  \n\n  ```bash\n  -v #输出不匹配的行\n  -n #输出行号\n  -c #计算匹配到的行数\n  -e #指定多个匹配模式\n  grep [tf] file1 #支持正则匹配\n  ```\n\n- egrep, fgrep 功能更强大  \n- 压缩数据 - zip , gzip:gz, compress:Z, bzip2:bz2\n\n  ```bash\n    gzip #压缩文件\n    gzcat #查看文件内容\n    gunzip #用来解压文件  \n  ```\n\n- 归档数据 - tar\n\n  ```bash\n  -c #~ create`创建一个新的tar文件\n  -r #追加文件到tar文件末尾\n  -x #~ extract`抽取tar文件\n  -v #显示文件列表\n  -z #将输出重定向给gzip命令\n  -f # file`输出文件结果到文化，`tar -cvf test.tar test/ test2/` 创建一个新文件\n  -t # list`列举tar内容\n  -C #指定具体目录\n  tar -xvf test.tar`令从tar文件test.tar中提取内容。如果tar文件是从一个目录结构创建的，那整个目录结构都会在当前目录下重新创建\n  ```\n\n## 4.4 date命令及其格式化\n\n- 格式化占位符\n\n  ```bash\n    %D – Display date as mm/dd/yy\n    %Y – Year (e.g., 2020)\n    %m – Month (01-12)\n    %B – Long month name (e.g., November)\n    %b – Short month name (e.g., Nov)\n    %d – Day of month (e.g., 01)\n    %j – Day of year (001-366)\n    %u – Day of week (1-7)\n    %A – Full weekday name (e.g., Friday)\n    %a – Short weekday name (e.g., Fri)\n    %H – Hour (00-23)\n    %I – Hour (01-12)\n    %M – Minute (00-59)\n    %S – Second (00-60)\n  ```\n\n- date时间加减\n\n  ```bash\n    echo  `date --date=\"-5 day\" +%Y%m%d`\n    echo  `date --date=\"-5 month\" +%Y%m%d`\n    echo  `date --date=\"-5 year\" +%Y%m%d`\n  ```\n\n- set和change系统时间\n\n  `date --set=\"20100513 05:30\"`谨慎使用\n\n- 展示某一日期文件的日期\n\n  `--file`选项打印出文件中每一行存在的日期字符串。\n\n  ```bash\n  date --file=\n  ```\n\n- 重写日期\n\n  ```bash\n  date -d 'TZ=\"Australia/Sydney\" 04:30 next Monday'\n  ```\n\n  下面命令可以列出`timezone`\n\n  ```bash\n  timedatectl list-timezones\n  ```\n\n- 与其他shell混用\n\n  ```bash\n  mysqldump  database_name > database_name-$(date +%Y%m%d).sql\n\n  ```\n\n- 使用Unix纪元时间（纪元转换）。\n\n  ```bash\n  date +%s # To show the number of seconds from the epoch to the current day, use the %s format control\n  date -d \"1984-04-08\" +\"%s\" # To see how many seconds passed from epoch to a specific date, enter\n  ```\n\n一个完整的带有详细时间的`date`命令是`date --date=\"-5 day\"  +\"%Y-%m-%d %H:%M:%S\"`\n\n# 5. 理解shell\n\n## 5.1 shell的类型\n\n不同Linux系统有很多种shell,`cat /etc/passwd`可以看到用户默认登录默认的shell\n\n- Debian的是dash\n- csh\n- sh(你经常会看到某些发行版使用软链接将默认的系统shell设置成bash shell，如本书所使用的CentOS发行版)\n\n## 5.2 shell的父子关系\n\n在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中的一些东西造成影响\n|参数|描述|\n|---|---|\n|-c string|从 string 中读取命令并进行处理|\n|-i|启动一个能够接收用户输入的交互shell|\n|-l |以登录shell的形式启动|\n|-r|启动一个受限shell，用户会被限制在默认目录中|\n|-s|从标准输入中读取命令|\n\n### 5.2.1 进程列表\n\n1. `(pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)`,括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令\n2. 语法为 `{ command; }` 。使用花括号进行命令分组,并不会像进程列表那样创建出子shell\n3. ( pwd ; (echo $BASH_SUBSHELL)) 创建子shell的子shell\n4. 在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢\n处理速度。在交互式的CLI shell会话中，子shell同样存在问题。它并非真正的多进程处理，因为\n终端控制着子shell的I/O\n\n### 5.2.2 子shell的其他用法\n\n1. 后台运行模式( & )\n2. 进程列表置于后台 (sleep 2 ; echo $BASH_SUBSHELL ; sleep 2) &\n3. 携程\n    - coproc My_Job { sleep 10; }, My_Job 是自定义名字，必须确保在第一个花括号（ { ）和命令名之间有一个空格\n    - 将`协程`与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,\n      然后把命令 `coproc` 放在前面就行了`coproc ( sleep 10; sleep 2 )`\n\n## 5.3 理解shell的内建命令\n\n### 5.3.1 外部命令\n\n当外部命令执行时，会创建出一个子进程。这种操作被称为`衍生`(forking),有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中\n\n- `which ps`\n- `type -a ps`\n- 当进程必须执行衍生操作时，它需要花费时间和精力来设置新子进程的环境。所以说，外部命令多少还是有代价的,就算衍生出子进程或是创建了子shell，你仍然可以通过发送信号与其沟通，这一点无论是\n在命令行还是在脚本编写中都是极其有用的\n\n### 5.3.2 内部命令\n\n1. 命令`type -a`显示出了每个命令的两种实现。注意， which 命令只显示出了外部命令文件\n2. `!数字`可以使用.bash_history文件的命令\n3. `alias -p`,有一个别名取代了标准命令 `ls`.它自动加入了`--color`选项，表明终端支持彩色模式的列表\n4. `alias li='ls -li'`,一个别名仅在它所被定义的shell进程中才有效\n\n# 6. 环境变量\n\n- login shell : 用户成功登陆后使用的是 Login shell。例如，当你通过终端、SSH 或使用 \"su -\" 命令来切换账号时都会使用的Login Shell\n- non-login shell : Non Login Shell 是指通过 login shell 开启的shell,Non-login shell执行`~/.bashrc`脚本来初始shell环境\n- 交互式shell ： 就是终端等待你输入命令的就是交互式shell\n- 非交互式shell : 非交互式模式，以shell script(非交互)方式执行。在这种模式 下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF，shell也就终止了\n\n如何快速辨别是login shell 还是non-login shell ,可通过`echo $0`如果是输出`-bash`说明是login shell,`bash`说明是non-login shell  \n\n- 全局环境变量对于所有shell都是可见的,对于子shell来说这是非常重要的,`printenv`or`env`命令查看全局命令\n- 局部变量，`set`返回全局变量，用户自定义变量,所以返回局部变量有点复杂，以字母序进行排序\n\n- 用户自定义变量\n\n  `echo $my_variable -> my_variable=Hello`可赋值,并且当你想要使用自定义变量时候要使用`${my_variable}`语法，大小写敏感\n\n- 设置全局环境变量\n  - `export my_variable`导出为全局变量，在子shell中修改该值，只会在子shell中生效\n  - `unset my_variable`删除环境变量,这条规则的一个例外就是使用 printenv 显示某个变量的值)\n  - 默认的环境变量，直接使用就好了\n\n    ![linux_default_variables](./../picture/linux_命令行与shell脚本/linux_default_variables.png)\n    ![linux_default_variables_1](./../picture/linux_命令行与shell脚本/linux_default_variables_1.png)\n  - 设置`path`环境变量,当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序.`PATH`环境变量定义了用于进行命令和程序查找的目录\n  - 定位环境变量\n    - 登录式shell  \n      在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作`启动文件`或`环境文件`。bash检查启动文件的方式取决于你启动bash的方式，启动bash shell有3种方式\n      - 登录时作为默认登录shell(login shell)\n        当你登录系统的时候，bash shell会作为登陆式shell进行启动，会在如下文件五个不同启动文件读取命令`/etc/profile`,`$HOME/.bash_profile`,`$HOME/.bash_login`,`$HOME/.profile`,`$HOME/.bashrc`\n        - `/etc/profile`  是系统默认的bash shell主启动文件，系统上每个用户登陆时候都会读取这个主启动文件，\n          两个发行版的`/etc/profile`文件都用到了同一个特性：for语句。它用来迭代`/etc/profile.d`目录，这为Linux系统提供了一个放置特定应用程序启动文件的地方，\n          当用户登录时，shell会执行这些文件。在本书所用的Ubuntu Linux系统中，\n          `/etc/profile.d`目录下包含以下文件  \n        - shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略,这里没提到`$HOME/.bashrc`文件，这个文件通常是通过其他文件运行  \n          - `$HOME/.bash_profile`\n          - `$HOME/.bash_login`\n          - `$HOME/.profile`\n\n        **NOTE** : 要留意的是有些Linux发行版使用了可拆卸式认证模块(Pluggable AuthenticationModules ，PAM)。在这种情况下，PAM文件会在bash shell启动之前处理，这些文件中可能会包含环境变量。PAM文件包括`/etc/environment`文 件 和`$HOME/.pam_environment`文件\n    - 交互式shell(non-login shell)  \n      如果你的shell不是登录系统时候启动的，那么你启动的shell就是交互式shell，它不会访问`/etc/profile`只会检查`.bashrc`文件，`.bashrc`文件有两个作用：一是查看/etc目录下通用的`bashrc`文件，二是为用户提供一个定制自己的命令别名(参见第5章)和私有脚本函数的地方(将在第17章中讲到)\n    - 非交互shell  \n      TBC\n    - 环境变量的持久化\n        对全局环境变量来说（Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修改过的变量设置放在`/etc/profile`文件中，但这可不是什么好主意。如果你升级了所用的发行版，这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。最好是在`/etc/profile.d`目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。在大多数发行版中，存储个人用户永久性bash shell变量的地方是`$HOME/.bashrc`文件。这一点适用于所有类型的shell进程。但如果设置了`BASH_ENV`变量，那么记住，除非它指向的是$HOME/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方\n- 环境变量数组\n    `mytest=(one two three four five)`定义了环境变量数组,`echo ${mytest[2]}`使用下标索引可以访问具体值,`echo ${mytest[*]}`可以访问所有的值,`unset mytest[2]`删除某个值,`unset mytest`删除全部\n- 总结\n    bash shell会在启动时执行几个启动文件。这些启动文件包含了环境变量的定义，可用于为每个bash会话设置标准环境变量。每次登录Linux系统，bash shell都会访问`/etc/profile`启动文件以及3个针对每个用户的本地启动文件：`$HOME/.bash_profile`、`$HOME/.bash_login`和`$HOME/.profile`。用户可以在这些文件中定制自己想要的环境变量和启动脚本。\n\n# 7. linux文件权限\n\n用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是`登录名`。登录名是用户用来登录系统的最长八字符的字符串（字符可以是数字或字母），同时会关联一个对应的密码\n\n## 7.1 linux的安全性\n\n- `/etc/passwd`包含用户的基本信息,所有在服务器后台运行都需要个`系统账户`运行\n\n  ```bash\n  1. 登录用户名\n  2. 用户密码\n  3. 用户账户的UID（数字形式）\n  4. 用户账户的组ID（GID）（数字形式）\n  5. 用户账户的文本描述（称为备注字段）\n  6. 用户HOME目录的位置\n  7. 用户的默认shell\n  ```\n\n  root固定分配UID是0，Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作`系统账户`，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个(application account)，如果全都是root权限登录系统就很危险，被攻陷就直接是root权限。\n- `/etc/shadow`真正存密码的文件,只允许root用户访问\n\n  ```bash\n  1. 与/etc/passwd文件中的登录名字段对应的登录名\n  2. 加密后的密码\n  3. 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）\n  4. 多少天后才能更改密码\n  5. 多少天后必须更改密码\n  6. 密码过期前提前多少天提醒用户更改密码\n  7. 密码过期后多少天禁用用户账户\n  8. 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）\n  9. 预留字段给将来使用\n  ```\n\n### 7.1.1 添加linux用户\n\n- `useradd`命令添加默认配置的用户,`/etc/default/useradd`可以加入`-D`选项查看默认参数如下(一些Linux发行版会把Linux用户和组工具放在/usr/sbin目录下，这个目录可能不在`PATH`环境变量里)\n  - 新用户会被添加到GID为100 的公共组；\n  - 新用户的HOME目录将会位于/home/loginname；\n  - 新用户账户密码在过期后不会被禁用；\n  - 新用户账户未被设置过期日期；\n  - 新用户账户将bash shell作为默认shell；\n  - 系统会将/etc/skel目录下的内容复制到用户的HOME目录下；\n  - 系统为该用户账户在mail目录下创建一个用于接收邮件的文件\n\n  `/etc/skel`下面它们是bash shell环境的标准启动文件,允许管理员把它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系统文件,`useradd`参数可以控制这些默认值,ubuntu系统在`/etc/skel`下，默认命令行参数\n\n  ```bash\n  -c comment 给新用户添加备注\n  -d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话）\n  -e expire_date 用YYYY-MM-DD格式指定一个账户过期的日期\n  -f inactive_days 指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示禁用这个功能\n  -g initial_group 指定用户登录组的GID或组名\n  -G group ... 指定用户除登录组之外所属的一个或多个附加组\n  -k 必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录\n  -m 创建用户的HOME目录\n  -M 不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项）\n  -n 创建一个与用户登录名同名的新组\n  -r 创建系统账户\n  -p passwd 为用户账户指定默认密码\n  -s shell 指定默认的登录shell \n  -u uid 为账户指定唯一的UID \n  ```\n\n  同时也可以更改默认值的参数\n\n  ```bash\n  -b default_home  更改默认的创建用户HOME目录的位置\n  -e expiration_date  更改默认的新账户的过期日期\n  -f inactive  更改默认的新用户从密码过期到账户被禁用的天数\n  -g group  更改默认的组名称或GID \n  -s shell  更改默认的登录shell \n  # 更改用户默认shell\n  useradd -D -s /bin/tsch\n  ```\n\n### 7.1.2 删除用户\n\nto_be_continue\n\n### 7.1.2 修改用户\n\nto_be_continue\n\n## 7.2 使用linux组\n\n- /etc/group 存储一个组的信息，低于500是系统的，高于500是用户组的\n  - 组名\n  - 组密码\n  - GID\n  - 属于该组的用户列表\n- 创建组\n- 修改组\n\n## 7.3 理解文件权限\n\n- 理解文件权限符号\n\n  ```bash\n  `-`代表文件\n  `d` 代表目录\n  `l` 代表链接\n  `c` 代表字符型设备\n  `b` 代表块设备\n  `n` 代表网络设备\n  `r` 可写\n  `w` 可写\n  `x` 可执行\n  文件owner,和对象组\n  ```\n\n- 设置默认文件权限\n  设置`umask`的值,默认文件权限等于文件最大权限，减去`umask`值，第一位代表了一项特别的安全特性，叫作粘着位（sticky bit）\n  rwx = 4 + 2 + 1 = 7, rw = 4 + 2 = 6, rx = 4 +1 = 5.\n\n## 7.4 改变安全性设置\n\n- chmod 改文件权限，如果使用的符号模式设置就是`u`代表用户，`g`代表组，`o`代表其他，`a`代表所有，`+`代表增加权限，`-`代表移除权限，`=`将权限设置成后面的值，额外的第三作用符号如下\n\n  ```bash\n  `X` ：如果对象是目录或者它已有执行权限，赋予执行权限。\n  `s` ：运行时重新设置UID或GID。\n  `t` ：保留文件或目录。\n  `u` ：将权限设置为跟属主一样。\n  `g` ：将权限设置为跟属组一样。\n  `o` ：将权限设置为跟其他用户一样\n  ```\n\n- chown 改文件所属\n  `chown option owner file[.group] file`\n  `chown owner.group file`直接改属主和组\n  `chown owner .` 属主和组都同名\n  `chgrp` 更改文件目录的默认属组\n\n## 7.5 共享文件\n\nLinux还为每个文件和目录存储了3个额外的信息位。\n\n- 设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。\n- 设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。\n- 粘着位：进程结束后文件还驻留（粘着）在内存中。\n如果你用的是八进制模式，你需要知道这些位的位置\n\n|二进制值|八进制值|描述|\n|---|---|---|\n|000|  0|所有位都清零|\n|001 | 1|粘着位置位|\n|010 | 2|SGID位置位|\n|011 | 3|SGID位和粘着位都置位|\n|100 | 4|SUID位置位|\n|101 | 5|SUID位和粘着位都置位|\n|110 | 6|SUID位和SGID位都置位|\n|111 | 7|所有位都置位|\n\n首先，用 `mkdir` 命令来创建希望共享的目录。然后通过 `chgrp` 命令将目录的默认属组改为包\n含所有需要共享文件的用户的组（你必须是该组的成员）。最后，将目录的SGID位置位，以保证\n目录中新建文件都用shared作为默认属组  \n\n```bash\n$ mkdir testdir\n$ ls -l\ndrwxrwxr-x 2 rich rich 4096 Sep 20 23:12 testdir/\n$ chgrp shared testdir\n$ chmod g+s testdir  // chmod 6770 testdir\n$ ls -l\ndrwxrwsr-x 2 rich shared 4096 Sep 20 23:12 testdir/\n$ umask 002\n$ cd testdir\n$ touch testfile\n$ ls -l\ntotal 0\n-rw-rw-r-- 1 rich shared 0 Sep 20 23:13 testfile\n\n```\n\n# 9. 安装软件程序\n\n## 9.1 包管理工具\n\n管理版本\n\n## 9.2 基于Debian的系统\n\n基于 Debian 的系统\n\n- dpkg 包管理工具\n- apt\n- apt-get\n- aptitude\n\n### 9.2.1 用aptitude 管理软件包\n\n`apt`,`dpkg`是包管理工具，`aptitude`是完整的软件包管理系统\n\n1. aptitude show wine  显示包wine的详细信息\n2. aptitude install package_name\n3. aptitude search package_name\n    如果看到一个 `i` ，说明这个包现在已经安装到了你的系统上了。如果看到一个 `p` 或 `v` ，说明这个包可用，但还没安装\n4. aptitude safe-upgrade\n5. aptitude remove/purge package_name\n6. `/etc/apt/sources.list`前面有deb说明是编译过的，deb-src是源代码，package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。你可以看到诸如main、restricted、universe和partner这样的值\n\ndpkg -L vim  显示vim的所有安装信息\ndpkg --search vim\n\n## 9.3 基于源码安装\n\nC++编译要使用CMake\n\n# 10. 使用编辑器\n\n## 10.1 vim 编辑器\n\n1. 移动光标\n\n   ```bash\n   文件很大,用方向键移动\n   gg 移动到最后一行\n   num G 移动到指定行数\n   G 移动到第一行\n   w file_name 将文件保存到另一个文件中\n   Pagedown + Pageup 翻页\n   w file_name 保存为另一个文件\n\n  ```\n\n2. 编辑数据\n   ```\n\n   x 删除光标当前所在字符(剪切)\n   dd 是切除当前行, p 是粘贴(剪切)\n   dw 删除光标当前所在当前字符(剪切)\n   yw 复制一个单词  y$复制整个行\n   u 撤销\n   a 在文件尾追加数据\n   A 在当前行尾追加数据\n   r char 用char 替换当前光标位置字符\n   R char 用text文本替换当前文本字符\n\n  ```\n3. 替换数据\n  ```bash\n  :s/old/new/  替换数据\n  :s/olr/new/g  替换文件中一行所有old\n  :m,ns/old/new/g 替换行号之间的所有old\n  :$s/old/new/g 替换整个文件中的old\n  :$s/old/new/gc 替换整个文件中的old，但是每次都提醒\n  ```\n\n# 11.基本脚本\n\n- 创建shell脚本\n  `#!/bin/bash`,bash找你的文件都是从path目录下，如果没有设置path目录那么就需要通过绝对路径和相对路径引用你的命令。然后是注意你的文件权限`umask`决定了你文件创建时候的默认权限\n- 文本信息  \n  echo可使用单引号和双引号来划定文本字符串\n  1. `echo  \"This is a test to see if you're paying attention\"`  文本中有单引号\n  2. `echo  'Rich says \"scripting is easy\".'` 文本中有双引号\n  3. 如果是单/双引号混合会怎样？\n  4. 文本字符串和命令输出到同一行\n\n- 使用变量\n  1. 用户变量区分大小写长度不超过20个字符\n  2. 变量,等号,值之间不能出现空格\n  3. 引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符.没有美元符号引用变量进行赋值shell就会将其理解为字符串\n  4. 命令替换分为`$()`和\\` \\`,testing=$(date)他们中间没有空格.命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的.在命令行提示符下使用路径./运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。在命令行提示符下运行脚本时一定要留心！\n  5.\n- 输入输出重定向\n  - `>`会覆盖,`>>`追加\n  - `wc < test6` 输入重定向,内联重定向`<<`,在命令行上使用内联输入重定向时,shell会用PS2环境变量中定义的次提示符（参见第6章）\n  - 管道，Linux管道命令（断条符号）允许你将命令的输出直接重定向到另一个命令的输入。【这里的问题还很多】\n\n- 执行数学计算\n  1. `expr`命令,特别注意`expr 1+5`这种是不起作用的(建议以后少用)\n  2. `$[ ]`对`expr`的改进,bash shell数学运算符只支持整数运算,`zsh`支持浮点运算\n  3. `bc`计算器\n     - `scale=4` 保留四位精度，`3.44 / 5 = .6880`, 支持定义变量\n     - 在脚本中使用`bc`,`variable=$(echo \"scale=4 ;3.44 / 5\" | bc)`,`var3=$(echo \"scale=4; $var1 / $var2\" | bc)`这里的var1和var2都是预定义的\n     - 将表达式定义到一个文件中，或者内联表达式\n\n        ```bash\n        #!/bin/bash \n        var1=10.46 \n        var2=43.67 \n        var3=33.2 \n        var4=71 \n        var5=$(bc << EOF \n        scale = 4 \n        a1 = ( $var1 * $var2) \n        b1 = ($var3 * $var4) \n        a1 + b1 \n        EOF \n        )\n\n        echo The final answer for this mess is $var5\n        ```\n\n- 退出脚本\n  1. `0`成功结束，`1`一般未知错误，`2`不适合的shell命令，`126`命令不可执行,`127`没找到命令，`128`无效退出参数，`128+x`与linux信号x相关的严重错误，`130`通过ctrl+退出，`255`正常范围之外的退出状态码\n  2. `exit`退出命令，可以自定义状态码，退出状态码最大只能是255，所以超过255会进行模运算\n\n# 12. 使用结构化命令\n\n- if statement\n\n  ```bash\n  ## style 1\n  if pwd\n  then\n    echo \"it works\"\n  fi\n  ## style 2\n  if pwd ; then \n    echo \"it works\"\n  fi\n\n  # style 3 \n  ## 如果grep返回0 就去执行echo statement\n  if grep $testuser /etc/passwd\n  then \n    echo \"this is my first command\"\n    echo \"this is my second command\"\n  fi\n  ## if elif else  ,在elif语句中，紧跟其后的else语句属于elif代码块。它们并不属于之前的if-then代码块 \n  if pwd \n  then \n    echo 1\n  else | elif command  ;then  echo 3 ; else  fi\n    echo 2\n  fi\n\n  ```\n\n- test命令\n\n  如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。支持符合条件检查\n\n  ```bash\n    ## 单一逻辑校验\n    if [ condition ] \n    then \n      commands\n    fi\n    ## 符合逻辑校验\n    if [ condition1 ] && [ condition2 ] || [ condition ] \n    then \n      commands\n    fi\n  ```\n\n  - 数值比较\n    - n1 -eq n2   等于\n    - n1 -ge n2   大于等于\n    - n1 -gt n2   大于\n    - n1 -le n2   小于等于\n    - n1 -lt n2   小于\n  - 字符串比较\n    - str1 = str2 字面量相等，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内\n    - str1 != str2 不相等\n    - str1 < str2   小于. `if [ $val1 > $val2 ]`直接这样比较字符串会创建一个文件。所以必须要转义`if [ $val1 \\> $val2 ]`。在比较测试中，大写字母被认为是小于小写字母的。比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果但sort命令恰好相反，本地语言设置（英语），A在a前面\n    - str1 > str2   大于\n    - -n str1  判断长度是否为非零\n    - -z str1  判断长度是否为零\n\n  - 文件比较\n    |比较|描述|\n    |---|---|\n    |-d file         |d=directory. 检查file是否存在并是一个目录|\n    |-e file         |e=exist. 检查file是否存在|\n    |-f file         |f=file. 检查file是否存在并是一个文件|\n    |-r file         |r=read. 检查file是否存在并可读|\n    |-s file         |s=检查file 是否存在并非空|\n    |-w file         |w=write. 检查file是否存在并可写|\n    |-x file         |检查file 是否存在并可执行|\n    |-O file         |O=all user 检查file是否存在并属当前用户所有|\n    |-G file         |G=group 检查file是否存在并且默认组与当前用户相同|\n    |file1 -nt file2 |检查file1是否比file2新|\n    |file1 -ot file2 |检查file1是否比file2旧|\n\n- (( ))和[[ ]]提供高级特性\n  - (( )) 提供更加方便的数学表达式计算，像其他oop语言一样\n  - [[ ]] 提供更加方便的字符串处理功能\n\n- `case`命令\n\n  ```bash\n  case variable in \n  pattern1 | pattern2 ) command1;;\n  pattern3) command2;;\n  *) command3;;\n  esac\n\n  ```\n\n# 13. for 循环\n\n## 13.1 for命令\n\n- for 基本语句\n\n```bash\nlist=\"Alabama Alaska Arizona Arkansas Colorado\" \nlist=$list\" Connecticut\"\nfor v in v_list\ndo\n  echo 1\n\ndone\n\n```\n\nv_list如果有单引号，1.用转义字符转义。2.用双引号定义用到的单引号的值。3.如果在单独的数据值中有空格，就必须用双引号将这些值圈起来，可直接拼接值。\n\n```bash\nfile=\"path of your file\"\nfor state in $(cat $file) \ndo \n echo \"Visit beautiful $state\" \ndone\n\n```\n\n读取文件内容进行迭代\n(ubuntu没有IFS环境变量和IFS.OLD)\n\n- 更改字段分隔符\n默认分隔符是`空格`，`制表符`，`换行符`环境变量IFS,控制着字段分隔符，有时候想灵活一点,有些地方用的换行符，但是其他地方继续保留原先的分隔符，可使用IFS=$'\\n', IFS.OLD=$IFS,IFS=$'\\n',但是如果想加入冒号作为换行符可以更改`/etc/passwd`文件加上IFS=:,如果想加多个可以依次在后面加IFS='\\n':;\"\n\n- 通配符\n\n  ```bash\n  #!bin/bash\n  for file in /home/rich/test/* \n  do \n    if [ -d \"$file\" ] \n    then \n      echo \"$file is a directory\" \n    elif [ -f \"$file\" ] \n    then \n      echo \"$file is a file\" \n    fi \n  done\n  ## 目录文件都会匹配\n  ##请注意这次条件判断有些特别使用了if [ -d \"$file\" ] 因为在linux中文件名有空格是合法的\n\n  ```\n\n## 13.2 C语言风格\n\n```bash\n\nfor (( a=1,b=10;a<=10;a++,b--))\ndo\n  echo 1\ndone\n\n```\n\n## 13.3 while语句\n\n```bash\nwhile true\ndo\n  echo\n\ndone\n\n```\n\n`break` 还可以指定跳出循环层数,两层`for`就跳出最内层,`break n`就会跳出.  \n`continue`结束本次循环，n为1，表明跳出的是当前的循环。如果你将n设为2，break命令就会停止下一级的外部循环  \n\n- 处理循环中的输出\n\n  ```bash\n  for file in /home/rich/* \n  do \n  if [ -d \"$file\" ] \n  then \n    echo \"$file is a directory\" \n  elif \n    echo \"$file is a file\"  \n  fi \n  done > output.txt\n  ```\n\n- 处理多个测试命令\n\n  这种情况下要注意，判断了所有条件，因为有一个条件返回为false，所以相当于逻辑`与`判断\n\n  ```bash\n  #!/bin/bash\n  # testing a multicommand while loop \n  var1=10 \n  while echo $var1 \n          [ $var1 -ge 0 ] \n  do \n  echo \"This is inside the loop\" \n  var1=$[ $var1 - 1 ] \n  done \n\n  ```\n\nwhile 或者for的嵌套循环中，内部循环可以读到外部变量\n\n## 13.4 until命令\n\n有点像其他语言的\ndo .... while 语法\n\n## 13.5 循环处理数据并以特定分隔符分割数据\n\n主要是修改IFS变量\n\n```bash\n#!/bin/bash \n# changing the IFS value \nIFS.OLD=$IFS \nIFS='\\n'\nfor entry in $(cat /etc/passwd) \ndo \n echo \"Values in $entry –\" \n IFS=':'\n  for value in $entry \n  do \n    echo \" $value\" \n  done \ndone \n```\n\n# 14. 处理用户输入\n\n## 14.1 读取参数，脚本名和测试参数\n\n- ./sumAB.sh  a  b  ## 这里$0是程序名, `$1`是a, `$2`是b. 超过九个就一定要花括号引用变量比如`${10}`，`$#`返回参数个数， `${!#}`获取最后一个参数，如果没有参数就会输出脚本名，`$*`变量会将所有参数当成单个参数,`$@`变量会组成数组，轻松访问所有的参数.\n\n  ```bash\n  for param in \"$@\"\n  do \n  echo \"\\$@ Parameter #$count = $param\" \n  count=$[ $count + 1 ] \n  done \n  ```\n\n- 如果程序名是`./test.sh`,那么echo $0 就是`./test.sh`\n- 如果程序名是`bash  /usr/lib/test.sh`,那么echo $0 就是`/usr/lib/test.sh`\n- 定义了参数位置，如果不传参会报错\n- `name=$(basename $0)` 可以只返回脚本名\n- `if [ -n \"$1\" ]`是指`$1`不为空\n- `shift`命令会移动命令参数,`shift n`可以指定跳过`n`参数.\n\n## 14.2 处理选项\n\nbash命令提供了`选项`和`参数`来控制,可以通过`shift`命令来控制\n\n- 处理简单的选项\n\n  ```bash\n  #!/bin/bash\n  # extracting command line options as parameters \n  # \n  echo \n  while [ -n \"$1\" ] \n  do \n  case \"$1\" in \n    -a) echo \"Found the -a option\" ;; \n    -b) echo \"Found the -b option\" ;; \n    -c) echo \"Found the -c option\" ;; \n    *) echo \"$1 is not an option\" ;; \n  esac\n  shift \n  done \n  $ ./test15.sh -a -b -c -d\n  ```\n\n- 分离选项和参数\n\n  ```bash\n  #!/bin/bash\n  # extracting options and parameters \n  echo \n  while [ -n \"$1\" ] \n  do \n    case \"$1\" in \n      -a) echo \"Found the -a option\" ;; \n      -b) echo \"Found the -b option\";; \n      -c) echo \"Found the -c option\" ;; \n      --) shift \n                break ;; \n      *) echo \"$1 is not an option\";; \n    esac \n  shift \n  done \n  # \n  count=1 \n  for param in $@ \n  do \n    echo \"Parameter #$count: $param\" \n    count=$[ $count + 1 ] \n  done \n  $ ./test16.sh -c -a -b -- test1 test2 test3\n  ```\n\n- 处理带值的选项\n\n  ```bash\n  #!/bin/bash\n  # extracting command line options and values \n  echo \n  while [ -n \"$1\" ] \n  do \n    case \"$1\" in \n      -a) echo \"Found the -a option\";; \n      -b) param=\"$2\" \n      echo \"Found the -b option, with parameter value $param\" \n      shift ;; \n      -c) echo \"Found the -c option\";; \n      --) shift \n      break ;; \n      *) echo \"$1 is not an option\";; \n    esac \n    shift \n  done \n  # \n  count=1 \n  for param in \"$@\" \n  do \n    echo \"Parameter #$count: $param\" \n    count=$[ $count + 1 ] \n  done \n  $ ./test17.sh -a -b test1 -d\n  ```\n\n  case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是$1，额外的参数值就应该位于$2（因为所有的参数在处理完之后都会被移出）。只要将参数值从$2变量中提取出来就可以了\n\n- 使用getopt与getopts命令\n  getopts命令会用到两个环境变量。如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。\n  OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。\n  这样你就能在处理完选项之后继续处理其他命令行参数了。\n\n  ```bash\n  #!/bin/bash\n  # simple demonstration of the getopts command \n  # \n  echo \n    while getopts :ab:c opt \n  do \n    case \"$opt\" in \n    a) echo \"Found the -a option\" ;; \n    b) echo \"Found the -b option, with value $OPTARG\";; \n    c) echo \"Found the -c option\" ;; \n    *) echo \"Unknown option: $opt\";; \n    esac \n  done\n  $ bash ./test19.sh -a -b \"1 2\" -c  # 在参数中加空格\n  $ bash ./test19.sh -abtest1        # 可以挨在一起\n  $ bash ./test19.sh -d              # 返回问号\n  $ bash ./test19.sh -a -b 456 -cdefg# 如果有参数的就要分开写\n  ```\n\n  - 使用OPTIND参数和OPTARG参数\n\n  ```bash\n  #!/bin/bash\n  # Processing options & parameters with getopts \n  # \n  echo \n  while getopts :ab:cd opt \n  do \n  case \"$opt\" in \n    a) echo \"Found the -a option\" ;; \n    b) echo \"Found the -b option, with value $OPTARG\" ;; \n    c) echo \"Found the -c option\" ;; \n    d) echo \"Found the -d option\" ;; \n    *) echo \"Unknown option: $opt\" ;; \n  esac \n  done \n  # \n  shift $[ $OPTIND - 1 ] \n  # \n  echo \n    count=1 \n  for param in \"$@\" \n  do \n    echo \"Parameter $count: $param\" \n    count=$[ $count + 1 ] \n  done\n  ```\n\n- 选项标准化\n  |参数|解释|\n  |---|---|\n  |-a |显示所有对象|\n  |-c |生成一个计数|\n  |-d |指定一个目录|\n  |-e |扩展一个对象|\n  |-f |指定读入数据的文件|\n  |-h |显示命令的帮助信息|\n  |-i |忽略文本大小写|\n  |-l |产生输出的长格式版本|\n  |-n |使用非交互模式（批处理）|\n  |-o |将所有输出重定向到的指定的输出文件|\n  |-q |以安静模式运行|\n  |-r |递归地处理目录和文件|\n  |-s |以安静模式运行|\n  |-v |生成详细输出|\n  |-x |排除某个对象|\n  |-y |对所有问题回答yes |\n\n## 14.3 获取用户输入\n\n- `read`命令，\n  - read命令包含了-p选项，允许你直接在read命令行指定提示符,\n  - read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量\n  - `-t`代表超时\n  - `-n 1`read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量\n  - `-s` 选项可以避免在read命令中输入的数据出现在显示器上\n  - 从文件中读取数据\n\n  ```bash\n  //单个变量\n  read -p \"please enter your age\" age\n  //多个变量\n  read -p \"please enter your name\" first last\n  // 超时参数\n  read -t 5 -p \n  // 获取指定字符个数\n  read -n1  -p \"Do you want to continue [Y/N]?\" answer\n  //隐藏输入\n  read -s -p \"Enter your password: \" pass \n  // 从文件中读取数据\n  #!/bin/bash\n  # reading data from a file \n  # \n  count=1 \n  cat test | while read line \n  do \n    echo \"Line $count: $line\" \n    count=$[ $count + 1] \n  done \n  echo \"Finished processing the file\" \n  ```\n  \n# 15. 呈现数据\n\n这一章主要是讲如何将脚本输出重定型向到系统其他位置\n\n## 15.1 理解输入和输出\n\n### 15.1.1 标准文件描述符\n\nLinux系统将每个对象(操作的文件，linux万物皆文件)当作文件处理。这包括输入和输出进程。Linux用文件描述符（filedescriptor）来标识每个文件对象\n\n```bash\n文件描述符  缩 写   描 述\n0           STDIN   标准输入\n1           STDOUT  标准输出\n2           STDERR  标准错误\n```\n\n1. STDIN实例  \n   `cat` 就会从STDIN输入数据，这时候你输入什么屏幕就会显示什么  \n   `cat < file.txt`通过STDIN通过重定向符号使`cat`查看一个非STDIN文件的输入\n2. STDOUT  \n3. STDERR\n   shell通过特殊的`STDERR`文件描述符来处理错误消息。`STDERR`文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置\n\n### 15.1.2 重定向错误\n\n1. 只重定向错误\n通过`2> file.txt`的方式将错误信息重定向到文件中\n2. 重定向错误和数据\n`ls -al test test2 test3 badtest 2> test6 1> test7` 这种就是将`STDERR`重定向到test6,然后将`STDOUT`重定向到test7.  \n也可以将STDERR和STDOUT的输出重定向到同一个输出文件使用`&>`,比如`ls -al test test2 test3 badtest &> test7`，bash消息赋予error更高的优先级\n\n## 15.2 在脚本中重定向输出\n\n可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：\n\n- 临时重定向行输出\n- 永久重定向脚本中的所有命令\n\n### 15.2.1 临时重定向\n\n如果使用上文提到的`STDERR`重定向方法就会将全局的`STDERR`信息都重定向到文件中，但是如果只重定向自己特定某些error信息就可以使用临时重定向，必须在文件描述符数字之前加一个`&`\n\n```bash\n# 举个例子 ./test8\n#!/bin/bash\n# testing STDERR messages \necho \"This is an error\" >&2 \necho \"This is normal output\" \n```\n\n如果像平常一样运行这个脚本，你可能看不出什么区别,因为所有输出都到了STDOUT,但是默认情况下，linux会将STDERR导向STDOUT,但是，如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向。\n\n```bash\n$ ./test8 2> test9\nThis is normal output \n$ cat test9 \nThis is an error \n```\n\n### 15.2.2 永久重定向\n\n如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可以用`exec`命令告诉shell在脚本执行期间重定向某个特定文件描述符。\n\n```bash\n#!/bin/bash\n# redirecting all output to a file \nexec 1>testout \necho \"This is a test of redirecting all output\" \necho \"from a script to another file.\" \necho \"without having to redirect every individual line\" \n```\n\n## 15.3 在脚本中重定向输入\n\n`exec`命令允许你将STDIN重定向到Linux系统上的文件中`exec 0< testfile`\n\n```bash\n# redirecting file input \nexec 0< testfile \ncount=1 \nwhile read line \ndo \n echo \"Line #$count: $line\" \n count=$[ $count + 1 ] \ndone \n```\n\n## 15.4 创建自己的重定向\n\n### 15.4.1 创建输出文件描述符\n\n可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件\n描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。这里有个在脚本中使用其\n他文件描述符的简单例子。(不是太理解这句话)\n\n```bash\n#./test13\n#!/bin/bash\n# using an alternative file descriptor \nexec 3>test13out \necho \"This should display on the monitor\" \necho \"and this should be stored in the file\" >&3 \necho \"Then this should be back on the monitor\" \n$ ./test13 \n```\n\n这个脚本用exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内\n容会像预想中那样显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入\n了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如\n日志文件）。\n\n### 15.4.2 重定向文件描述符\n\n现在介绍怎么恢复已重定向的文件描述符。你可以分配另外一个文件描述符给标准文件描述\n符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用\n该文件描述符重定向回STDOUT。听起来可能有点复杂，但实际上相当直接。这个简单的例子能\n帮你理清楚。\n\n```bash\n# ./test14 \n#!/bin/bash\n# storing STDOUT, then coming back to it \nexec 3>&1\nexec 1>test14out \necho \"This should store in the output file\" \necho \"along with this line.\" \nexec 1>&3\necho \"Now things should be back to normal\" \n$ \n$ ./test14 \nNow things should be back to normal \n$ cat test14out \nThis should store in the output file \nalong with this line. \n$ \n```\n\n这个方法可能有点叫人困惑，但这是一种在脚本中临时重定向输出，然后恢复默认输出设置\n的常用方法。\n\n### 15.4.3 创建输入文件描述符\n\n(不是很懂)\n可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，\n先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它\n原来的位置\n\n```bash\n#!/bin/bash \n# redirecting input file descriptors \nexec 6<&0 \nexec 0< testfile \ncount=1 \nwhile read line \ndo \n echo \"Line #$count: $line\" \n count=$[ $count + 1 ] \ndone \nexec 0<&6 \nread -p \"Are you done now? \" answer \ncase $answer in \nY|y) echo \"Goodbye\";; \nN|n) echo \"Sorry, this is the end.\";; \nesac\n\n```\n\n### 15.4.4 创建读写文件描述符\n\n（不是太理解）\n\n尽管看起来可能会很奇怪，但是你也可以打开单个文件描述符来作为输入和输出。可以用同\n一个文件描述符对同一个文件进行读写。\n不过用这种方法时，你要特别小心。由于你是对同一个文件进行数据读写，shell会维护一个\n内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。如果不够小\n心，它会产生一些令人瞠目的结果。看看下面这个例子。\n\n```bash\n\n#!/bin/bash \n# testing input/output file descriptor \nexec 3<> testfile \nread line <&3 \necho \"Read: $line\" \necho \"This is a test line\" >&3 \n$ cat testfile \nThis is the first line. \nThis is the second line. \nThis is the third line. \n\n#输出\n\n$ ./test16 \nRead: This is the first line. \n```\n\n### 15.4.5 关闭文件描述符\n\n不懂\n\n## 15.5 列出未关闭的文件描述符\n\n你能用的文件描述符只有9个，你可能会觉得这没什么复杂的。但有时要记住哪个文件描述\n符被重定向到了哪里很难。为了帮助你理清条理，bash shell提供了`lsof`命令。`$$`可以读取当前程序运行的的PID,`-a`\n对其他两个选项的输出做AND运算  \n\n```bash\n/usr/sbin/lsof -a -p $$ -d 0,1,2\n# lsof的默认输出\nCOMMAND     正在运行的命令名的前9个字符\nPID         进程的PID \nUSER        进程属主的登录名\nFD          文件描述符号以及访问类型（r代表读，w代表写，u代表读写）\nTYPE        文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）\nDEVICE      设备的设备号（主设备号和从设备号）\nSIZE        如果有的话，表示文件的大小\nNODE        本地文件的节点号\nNAME        文件名\n```\n\n(不是很懂)\n\n## 15.6 组织命令输出\n\n如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这\n会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。\n要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名\n字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。\n在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，\n不会显示。\n\n```bash\n\ncat /dev/null/ > test18\n# 这时候test18文件就是空的\n\n```\n\n## 15.7 创建临时文件\n\n### 15.7.1 创建本地临时文件\n\n```bash\nmktemp   kirk.XXXXXX  # 这里面的XXXXXX是必须的\n```\n\n这是在本地目录创建临时文件\n\n### 15.7.2 在/temp/创建临时文件\n\n```bash\nmktemp -t kirk.XXXXXX\n```\n\n在/temp/目录下创建了一个临时文件夹\n\n### 15.7.3 创建临时目录\n\n```bash\nmktemp -d kirk.XXXXXX\n```\n\n在/temp/目录下创建文件夹\n\n## 15.8 记录消息\n\n有时候想把STDOUT输出到指定文件，又想输出到屏幕上，可以考虑使用`tee`命令,但是tee命令会覆盖以前的内容\n但是如果你想把输出追加到文件中需要使用`-a`选项\n\n## 15.9 实战\n\n稍后完善\n\n# 16. 控制脚本\n\n## 16.1 处理信号\n\nlinux利用信号与运行在系统中的进程进行通信，\n\n### 16.1.1 重温linux信号\n\nlinux可以与程序产生30多种信号\n\n```bash\n信 号     值       描 述\n1         SIGHUP  挂起进程\n2         SIGINT  终止进程\n3         SIGQUIT 停止进程\n9         SIGKILL 无条件终止进程\n15        SIGTERM 尽可能终止进程\n17        SIGSTOP 无条件停止进程，但不是终止进程\n18        SIGTSTP 停止或暂停进程，但不终止进程\n19        SIGCONT 继续运行停止的进程\n```\n\n默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，\n交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。\n如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退\n出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。\n\n### 16.1.2 生成信号\n\n1. crtl+C 生成SIGINT(2)终止进程信号\n2. crtl+Z 生成SIGTSTP(17)停止shell中运行的任何进程\n   停止shell中运行的任何进程。停止（stopping）进程，跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置\n继续运行。在16.4节中，你会了解如何重启一个已经停止的进程。可以使用`ps -l`命令来显示各进程\n\n### 16.1.3 捕获信号\n\ntrap命令允许你来指定shell\n脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再\n由shell处理，而是交由本地处理。\n\n```bash\n#!/bin/bash \n# Testing signal trapping \n# \ntrap \"echo ' Sorry! I have trapped Ctrl-C'\" SIGINT \n# \necho This is a test script \n# \ncount=1 \nwhile [ $count -le 10 ] \ndo \n echo \"Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone\n```\n\n该脚本使用trap命令捕获信号，使我们编写的脚本处理信号而不是shell处理\n当使用`ctrl-C`时候，我们脚本的trap命令就会处理这个SIGINT信号\n\n### 16.1.4 捕获脚本退出\n\n除了在shell脚本中捕获退出，你也可以在shell退出时就行捕获，这是shell完成任务时一种执行命令的一种方式，要捕获shell的退出只需要在trap命令后面加上`EXIT`信号就行.\n\n```bash\n\n#!/bin/bash \n# Trapping the script exit \n# \ntrap \"echo Goodbye...\" EXIT \n# \ncount=1 \nwhile [ $count -le 5 ] \ndo \n echo \"Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone \n#1. 脚本正常执行完，然后执行了trap脚本\n#2. ctrl-c 命令也会触发退出命令,ctrl-c之后就不会执行剩余代码。\n```\n\n### 16.1.5 修改或移除捕获\n\n捕获或移除这节一句话概括就是设置trap命令的有效期，或者叫生命周期。也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上\n两个破折号就行了，\n\n```bash\n\n#!/bin/bash \n# Modifying a set trap \n# \ntrap \"echo ' Sorry... Ctrl-C is trapped.'\" SIGINT \n# \ncount=1 \nwhile [ $count -le 5 ] \ndo \n echo \"Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone \n# \ntrap \"echo ' I modified the trap!'\" SIGINT \n# \ncount=1 \nwhile [ $count -le 5 ] \ndo \n echo \"Second Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone\n\n```\n\n```bash\n$ ./test3.sh\nLoop #1 \nLoop #2 \nLoop #3 \n^C Sorry... Ctrl-C is trapped. \nLoop #4 \nLoop #5 \nSecond Loop #1 \nSecond Loop #2 \n^C I modified the trap! \nSecond Loop #3 \nSecond Loop #4 \nSecond Loop #5 \n$\n\n```\n\n也可以在trap命令后使用单破折号来恢复信号的默认行为  \n移除信号捕获后，脚本按照默认行为来处理SIGINT信号，也就是终止脚本运行。但如果信\n号是在捕获被移除前接收到的，那么脚本会按照原先trap命令中的设置进行处理。  \n在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，\n脚本会照旧执行trap中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。  \n总结:  \n修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的trap命令进行处理。trap根绝接收到信号会\n立刻从sleep中唤醒\n\n## 16.2 以后台模式运行脚本\n\n### 16.2.1 后台运行脚本\n\n当`&`符放到命令后时，它会将命令和bash shell分离开来,然后给分配一个`调度号`和`PID号`,在后台模式中，\n进程运行时不会和终端会话上的STDIN、STDOUT以及STDERR关联\n\n### 16.2.2 运行多个后台作业\n\n当我们同时运行多个后台运行程序的时候，然后使用`ps`命令这时候发现很多进程与`pts/0`绑定着，如果终端会话退出，那么后台进程也会随之退出\n\n### 16.2.3 在非控制台下运行程序\n\n有时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退\n出了终端会话。这可以用`nohup`命令来实现.和普通后台进程一样，shell会给命令分配一个作业号，Linux系统会为其分配一个`PID号`。区\n别在于，当你使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号。\n由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。\n为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为\nnohup.out的文件中。\n当多个命令同时使用nohup命令时候，且同时修改nohup命令的时候，他们会追加到nohup.out命令\n\n```bash\n# 命令demo\nnohup ./test1.sh &\n```\n## 16.4 作业控制\n\n### 16.4.1 查看作业\n\n`jobs`命令可以查看分配给shell的作业，`jobs -l`可以查看完整的PID  \n\n```bash\n参数  描述\n-l    列出进程的PID以及作业号\n-n    只列出上次shell发出的通知后改变了状态的作业\n-p    只列出作业的PID \n-r    只列出运行中的作业\n-s    只列出已停止的作业\n#你可能注意到了jobs命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用\n#作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。\n#当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加\n#号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。\n```\n\n### 16.4.2 重启停止的作业\n\n在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你\n当前工作的终端，所以在使用该功能时要小心了。  \n要以后台模式重启一个作业，可用bg命令加上作业号\n\n```bash\n\n[1]+ Stopped ./test11.sh \n$ bg # 这时候就重启了./test11.sh 作业，以后台模式\n# 如果重启多个就是用bg 2\n# 要以前台模式重启作业，可用带有作业号的fg命令。\n\n```\n\n## 16.5 调整谦让度\n\n1. 在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调\n度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统\n中，由shell启动的所有进程的调度优先级默认都是相同的。  \n2. 调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell\n以优先级0来启动所有进程。  \n最低值20是最高优先级，而最高值19是最低优先级，这太容易记混了。只要记住那句俗\n语“好人难做”就行了。  \n3. 有时你想要改变一个shell脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他\n进程过多的处理能力），还是给予它更高的优先级（这样它就能获得更多的处理时间），你都可以\n通过nice命令做到。\n\n### 16.5.1 nice 命令\n\nnice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice\n的-n命令行来指定新的优先级级别。\n\n```bash\nnice -n 10 ./test4.sh > test4.out &  # 注意，必须将nice命令和要启动的命令放在同一行中。\n```\n\n一旦用nice命令设置了优先级，就不可以用nice重新设置优先级\n\n### 16.5.2 renice 命令\n\n有时你想改变系统上已运行命令的优先级。这正是renice命令可以做到的。它允许你指定\n运行进程的PID来改变它的优先级。\n\n```bash\nrenice -n 10 -p 5055 # -p应该是指进程\n```\n\nrenice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一\n些限制:  \n\n- 只能对属于你的进程执行renice；\n- 只能通过renice降低进程的优先级；\n- root用户可以通过renice来任意调整进程的优先级。\n如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令\n\n## 16.6 定时运行作业\n\n### 16.6.1 用at命令来计划执行作业\n\n1. at命令的格式\n    at命令只执行一次，区别于cron\n\n    ```bash\n    at [-f filename] time # -f 后面用来指定读取命令\n    ```\n\n    time : 参数指定运行时间，如果错过就会在第二天同一时间再运行  \n    time能识别多种时间格式\n\n    - 标准小时和分钟的格式，比如10：15\n    - AM/PM指示符，比如10：15PM\n    - 特定可命名时间，比如now,noon,midnight,或者teatime(4 PM)\n    - 标准日期格式，比如MMDDYY,MM/DD/YY,DD.MM.YY\n    - 文本日期比如jul 4或Dec 25 加不加年份都可以。\n    - 你也可以指定增量时间\n      - 当前时间+25 min\n      - 明天10：15 PM\n      - 10：15+7天\n    通过`at`命令都会被提交到作业队列，针对不同的优先级存在26种不同的作业队列，使用\n    a-z和A-Z来指代，即使通过at命令提交过作业，也可以通过-q参数指定不同的队列字母\n    作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的\n    作业会被提交到a作业队列\n\n2. 获取作业的输出\nat命令利用sendemail应用程序发送邮件，这样其实很麻烦，但是可以将输出重定向到STDOUT\n和STDERR,再如果可以使用`-M`屏蔽输出\n\n3. 列出等待的作业\natq命令可以查看系统中哪些作业处于等待状态\n\n4. 删除作业\natrm删除等待种的作业\n\n```bash\n#demo\natq 命令可以列出作业编号\natrm 作业编号 # 只能删除你提交的作业，不能删除其他人的。\n```\n\n### 16.6.2 安排需要定期执行的脚本\n\n1. cron时间表\n\n    ```bash\n    min hour dayofmonth month dayofweek command\n    ```\n\n    比如你想每天10：15运行一个命令可以使用cron时间表条目\n\n    ```bash\n    min hour dayofmonth  month dayofweek  command\n    15  10   *           *     *          command\n    ```\n\n    但是如果想在每周一的下午4点15分执行，可写为\n\n    ```bash\n    15 16 * * 1 command\n    ```\n\n    可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）\n    或数值（0为周日，6为周六）,dayofmonth表项指定月份中的日期值（1~31）。\n\n    聪明的读者可能会问如何设置一个在每个月的最后一天执行的命令，因为你无法设置\n    dayofmonth的值来涵盖所有的月份。这个问题困扰着Linux和Unix程序员，也激发了不少解\n    决办法。常用的方法是加一条使用date命令的if-then语句来检查明天的日期是不是01：\n\n    ```bash\n    00 12 * * * if [ `date +%d -d tomorrow` = 01 ] ; then ; command\n    ```\n\n    它会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。\n\n    命令必须要指定要运行的脚本名字，或者添加重定向符号  \n    cron程序会用提交作业的用户账户运行该脚本。因此，你必须有访问该命令和命令中指定的\n    输出文件的权限。\n\n2. 构建cron时间表\n可以使用crontab -l来处理cron时间表  \n默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。\n在添加条目时，crontab命令会启用一个文本编辑器（参见第10章），使用已有的cron时间表作\n为文件内容（或者是一个空文件，如果时间表不存在的话）。\n\n3. 浏览cron目录\n\n    如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个\n    基本目录：hourly、daily、monthly和weekly。\n\n    - /etc/cron.daily\n    - /etc/cron.hourly\n    - /etc/cron.monthly\n    - /etc/cron.weekly\n    因此，如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它\n\n4. anacron程序\n如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么\n这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问\n题，许多Linux发行版还包含了anacron程序。  \nanacron\n程序只会处理位于cron目录的程序，比如/etc/cron.monthly。它用时间戳来决定作业\n是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/anacron。\n\n```bash\nsudo cat /var/spool/anacron/cron.monthly\n20150626\n```\n\nanacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录。  \nanacron时间表的基本格式和cron时间表略有不同：\n\n```bash\nperiod delay identifier command\n```\n\nperiod条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间\n戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。\ncommand条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的\n任何脚本。\n注意，anacron不会运行位于/etc/cron.hourly的脚本。这是因为anacron程序不会处理执行时间\n需求小于一天的脚本。\nidentifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误\n邮件中的作业。\n\n### 16.6.3 使用新shell启动脚本\n\n.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是\n当你登入bash shell时，另一次是当你启动一个bash shell时。如果你需要一个脚本在两个时刻都得\n以运行，可以把这个脚本放进该文件中。\n\n# 17. 创建函数\n\n## 17.1 基本的脚本函数\n\n### 17.1.1 创建函数\n有两种方式定义函数  \n```bash\nfunction name(){\ncommand;\n}\n```\n\n另一种更像是高级编程语言定义函数  \n\n```bash\nname(){\ncommand;\n}\n```\n\n### 17.1.2 使用函数\n\n正常情况就像是其他高级语言一样，但是bash的函数有个特殊情况。如果是重定义了一个旧函数，\n那么就会覆盖以前的定义,正如下面的例子\n\n```bash\n#!/bin/bash\n# testing using a duplicate function name \nfunction func1 { \necho \"This is the first definition of the function name\" \n} \nfunc1 \nfunction func1 { \n echo \"This is a repeat of the same function name\" \n} \nfunc1 \necho \"This is the end of the script\"\n\n```\n\n## 17.2 返回值\n\n### 17.2.1 默认退出状态码\n\n即使是在函数中，command1,command2,command3 中的1，2执行错误，3成功了，那么退出\n状态码也是0.所以说默认退出状态码是很危险的。\n\n### 17.2.2 使用return命令\n\nreturn的demo如下\n\n```bash\n#!/bin/bash\n# using the return command in a function \nfunction dbl { \n read -p \"Enter a value: \" value \n echo \"doubling the value\" \n return $[ $value * 2 ] \n} \ndbl \necho \"The new value is $?\"\n\n```\n\ndbl函数会将$value的值翻倍，然后返回，有两点要小心\n\n- 记住，函数一结束就取返回值\n- 记住，退出码必须是0~255\n\n也可以返回字符串和较大的数值，可以看下一节\n\n### 17.2.3 使用函数输出\n\n```bash\n#!/bin/bash\n# using the echo to return a value \nfunction dbl { \n read -p \"Enter a value: \" value \n echo $[ $value * 2 ] \n} \nresult=$(dbl) \necho \"The new value is $result\"\n\n#$ ./test5b\n#Enter a value: 200 \n#The new value is 400\n```\n\n可以看到是将一函数结果执行取值运算得到返回值。\n通过这种技术，你还可以返回浮点值和字符串值。这使它成为一种获取函数返回值的强\n大方法。\n\n## 17.3 在函数中使用变量\n\n### 17.3.1 向函数传递参数\n\n错误传递参数代码\n```bash\n#!/bin/bash \n# trying to access script parameters inside a function \nfunction badfunc1 { \n echo $[ $1 * $2 ] \n} \nif [ $# -eq 2 ] \nthen \n value=$(badfunc1) \n echo \"The result is $value\" \nelse \n echo \"Usage: badtest1 a b\" \nfi \n# $ ./badtest1\n# Usage: badtest1 a b \n# $ ./badtest1 10 15 \n# ./badtest1: * : syntax error: operand expected (error token is \"* \n# \") \n# The result is \n# 脚本的$1和$2和函数调用的$1,$2变量是不一样的\n```\n\n接下来是正确的代码\n\n```bash\n#!/bin/bash \n# trying to access script parameters inside a function \nfunction func7 { \n echo $[ $1 * $2 ] \n} \nif [ $# -eq 2 ] \nthen \n value=$(func7 $1 $2) \n echo \"The result is $value\" \nelse \n echo \"Usage: badtest1 a b\" \nfi \n#$ \n#$ ./test7 \n#Usage: badtest1 a b \n#$ ./test7 10 15 \n#The result is 150 \n\n```\n\n通过将$1和$2变量传给函数，它们就能跟其他变量一样供函数使用了\n\n### 17.3.2 在函数中处理变量\n\n- 全局变量\n全局变量被覆盖\n\n```bash\n#!/bin/bash \n# demonstrating a bad use of variables \nfunction func1 { \n temp=$[ $value + 5 ] \n result=$[ $temp * 2 ] \n} \ntemp=4 \nvalue=6 \nfunc1 \necho \"The result is $result\" \nif [ $temp -gt $value ] \nthen \n echo \"temp is larger\" \nelse \n echo \"temp is smaller\" \nfi \n\n#$ ./badtest2\n#The result is 22 \n#temp is larger \n# 说明TEMP变量受到了影响，读和写都是改变的全局变量\n```\n\n- 局部变量\nlocal关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，\n那么shell将会保持这两个变量的值是分离的\n\n```bash\n#!/bin/bash\n# demonstrating the local keyword \nfunction func1 { \n local temp=$[ $value + 5 ] \n result=$[ $temp * 2 ] \n} \ntemp=4 \nvalue=6 \nfunc1 \necho \"The result is $result\" \nif [ $temp -gt $value ] \nthen \n echo \"temp is larger\" \nelse \n echo \"temp is smaller\" \nfi \n#$ ./test9\n#The result is 22 \n#temp is smaller \n```\n\nif里面的$temp参数是全局的，因为已经在函数外\n\n## 17.4 数组变量和函数\n\n直接传入只会传入数组的第一个值，可考虑如下方法\n\n```bash\n#!/bin/bash \n# array variable to function test \nfunction testit { \n local newarray \n newarray=(;'echo \"$@\"') \n echo \"The new array value is: ${newarray[*]}\" \n} \nmyarray=(1 2 3 4 5) \necho \"The original array is ${myarray[*]}\" \ntestit ${myarray[*]} \n#$ \n#$ ./test10 \n#The original array is 1 2 3 4 5 \n#The new array value is: 1 2 3 4 5 \n\n```\n第二种也可以\n```bash\n#!/bin/bash\n# adding values in an array \nfunction addarray { \n local sum=0 \n local newarray \n newarray=($(echo \"$@\")) \n for value in ${newarray[*]} \n do \n      sum=$[ $sum + $value ] \n done\n echo $sum \n}\nmyarray=(1 2 3 4 5)\necho \"The original array is: ${myarray[*]}\" \narg1=$(echo ${myarray[*]}) \nresult=$(addarray $arg1) \necho \"The result is $result\" \n\n#$ ./test11 \n#The original array is: 1 2 3 4 5 \n#The result is 15 \n```\n\n### 17.4.2 从函数中返回数组\n\n```bash\n#!/bin/bash\n# returning an array value \nfunction arraydblr { \n local origarray \n local newarray \n local elements \n local i \n origarray=($(echo \"$@\")) \n newarray=($(echo \"$@\")) \n elements=$[ $# - 1 ] \n for (( i = 0; i <= $elements; i++ )) \n { \n newarray[$i]=$[ ${origarray[$i]} * 2 ] \n } \n echo ${newarray[*]} \n} \nmyarray=(1 2 3 4 5) \necho \"The original array is: ${myarray[*]}\" \narg1=$(echo ${myarray[*]}) \nresult=($(arraydblr $arg1)) \necho \"The new array is: ${result[*]}\" \n\n```\narraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来\n重新生成一个新的数组变量。\n\n## 17.5 函数递归\n\n```bash\n#!/bin/bash\n# using recursion \nfunction factorial { \n if [ $1 -eq 1 ] \n then \n echo 1 \n else \n local temp=$[ $1 - 1 ] \n local result=$(factorial $temp) \n echo $[ $result * $1 ] \nfi \n}\nread -p \"Enter value: \" value \nresult=$(factorial $value) \necho \"The factorial of $value is: $result\" \n\n#$ ./test13\n#Enter value: 5 \n#The factorial of 5 is: 120 \n\n```\n\n## 17.6 创建库\n\n问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的\n\n```bash\n#!/bin/bash\n# using a library file the wrong way \n./myfuncs \nresult=$(addem 10 15) \necho \"The result is $result\"\n\n$ ./badtest4 \n./badtest4: addem: command not found \nThe result is \n```\n\n使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是\n创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。\n\n## 17.7 在命令行上使用函数\n\n和在shell脚本中将脚本函数当命令使用一样，在命令行界面中你也可以这样做。这个功能很，不错，因为一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数。有几种方法可以实现。\n\n### 17.7.1 在命令上创建函数\n\n- 简单点直接定义 `function divem { echo $[ $1 / $2 ]; } `\n- 另一种采用多行式\n\n  ```bash\n  $ function multem { \n  > echo $[ $1 * $2 ] \n  > } \n  $ multem 2 5 \n  ```\n\n### 17.7.2 在.bashrc 文件中定义函数\n\n1. 直接定义函数\n\n   ```bash\n    $ cat .bashrc\n    # .bashrc \n    # Source global definitions \n    if [ -r /etc/bashrc ]; then \n    . /etc/bashrc \n    fi \n    function addem { \n    echo $[ $1 + $2 ] \n    } \n   ```\n\n2. 读取函数文件\n直接定义在特地的文件内，然后读取在`.bashrc`中读取\n\n## 17.8 实例\n\n### 17.8.1 下载安装第三方库\n\n### 17.8.2 构建库\n\n下载，编译，安装。这里面涉及到`CMAKE`的相关知识\n\n### 17.8.3 shtool库函数\n\n这里就是介绍些shtool提供的一些函数，后面会很有用，但是需要与公司内的环境做适配\n\n### 17.8.4 使用库\n\n编译，安装完后，就可以在脚本中使用了\n\n# 18. 图形化界面中脚本编程\n\n暂时不需要\n\n# 19.初识sed和gawk\n你得熟悉Linux中的sed和gawk工具。这两个工具能够极大简化需要进行的数据处\n理任务。\n## 19.1 文本处理\n\n### 19.1.1 sed编辑器\nsed编辑器被称作流编辑器（stream editor），和普通的交互式文本编辑器恰好相反。在交互式\n文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。流编\n辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。\n\n- 一次输入一行\n- 根据所提供的编辑器命令匹配数据。\n- 按照命令修改流中数据\n- 将最后结果输出到STDOUT\n\n> sed  options  script  file\n\necho 'this is a test' | sed  's/test/big test/'  使用s命令将test替换为big test\n\nsed 's/dog/cat/'  data.txt    这是修改文件中dog为cat\nsed  -e  's/brown/red;  s/blue/yellow/'   data/txt\n\n从文件中读取编辑器命令\n\nsed -f script.sed  data.txt\n\ngawk\n\noption\n\n-F fs  指定行中划分数据字段的字段分隔符\n-f file  从指定的文件中读取程序\n-v var=value  定义gawk程序中的一个变量及其默认值\n-mf N  指定要处理的数据文件中的最大字段数\n-mr N  指定数据文件中的最大数据行数\n-W keyword  指定gawk的兼容模式或警告等级\n\n- 从命令行读取程序脚本\n  gawk '{print \"Hello World!\"}'\n\n- 从文件中读取数据\n  自动为文件每一行数据分配一个变量gawk '{print $1}' data2.txt 数据文件中每一行的第一个字符\n  eg: gawk -F: '{print $1}' /etc/passwd\n\n- 在程序脚本中使用多个命令\n\n  echo \"my name is rich\" | gawk '{$4=\"Christine\"; print $0}' , 给第四个字段名赋值，并输出文本名 ，如果不指定文件名就会从标准输入等待输入\n\n- 从文件中读取程序\n\n  command_gawk.gawk        gawk -F: -f  command_gawk.gawk  /etc/passwd\n\n  ```bash\n  BEGIN {\n  print \"The latest list of users and shells\"\n  print \" UserID \\t Shell\"\n  print \"-------- \\t -------\"\n  FS=\":\"\n  }\n  {\n  print $NF \" \\t \" $7\n  }\n  END {\n  print \"This concludes the listing\"\n  }\n  ```\n\n- 在处理数据前运行脚本\n\n  gawk 'BEGIN {print \"Hello World!\"}'\n\n  \\>{print $0}' data3.txt\n\n- 处理数据后运行脚本\n\n## 19.2 sed and gawk进阶\n\n替换标记\ns/pattern/replacement/flags\n\n- 数字， 说明新文本将替换第几处的地方\n- g，说明文本将替换所有\n- p, 原先行要打印\n- w file ， 将结果输出到新文件中\n- option 位置是 n 说明禁止输出\n\n替换字符\n在替换文件路径时候涉及到转义字符这样很影响阅读性\n\n替换指定行\nsed '2s/dog/cat/' data1.txt        这个命令的意思就是将data1.txt替换第二行中的dog，替换成cat\nsed '2,3s/dog/cat/' data1.txt    以此类推是第二行，第三行\nsed '2,$s/dog/cat/' data1.txt    从第二行开始到最后一行\nsed '/Samantha/s/bash/csh/' /etc/passwd   推过模式匹配\nsed '3,${\n  s/brown/green/\n  s/lazy/active/\n  }' data1.txt\n\n# 20.正则表达式\n\n## 20.1 什么是正则表达式\n\n正则表达式就是某种模板(筛子)，正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是\n一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。\n\n- POSIX基础正则表达式（basic regular expression，BRE）引擎\n- POSIX扩展正则表达式（extended regular expression，ERE）引擎\n\n## 20.2 定义BRE模式\n\n### 20.2.1. 纯文本\n\n`echo \"This is a test\" | sed -n '/this/p'` 这里面p是print,少了-n是打印两条，this没匹配到所以没有显示  \n空格也是普通的字符，比如`sed -n /  /p data.set`\n\n### 20.2.2 特殊字符\n\n`echo \"3 / 2\" | sed -n '///p'` 正斜线也需要转义字符，故正确的是`echo \"3 / 2\" | sed -n '/\\//p'`\n\n### 20.2.3 锚定字符\n\n1. `^`锚定字符  \n主要是锚定字符串行首。如果模式出现在行首之外的位置则不匹配，如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了`echo \"This is ^ a test\" | sed -n '/s ^/p'`\n``\n2. `$`锚定结尾\n特殊字符美元符`$`定义了行尾锚点。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。`echo \"This is a good book\" | sed -n '/book$/p'`\n3. 组合锚定\n\n    ```bash\n    $ cat data4\n    this is a test of using both anchors  # 这一行会被忽略\n    I said this is a test \n    this is a test \n    I'm sure this is a test. \n    $ sed -n '/^this is a test$/p' data4 \n    this is a test\n    ```\n\n    第二种情况\n\n    ```bash\n    $ cat data5\n    This is one test line. \n    This is another test line. \n    $ sed '/^$/d' data5 \n    This is one test line. \n    This is another test line. \n    ```\n\n    定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行。由于空白行在两个换行符之间没有文本，刚好匹配了正则表达式模式。sed编辑器用删除命令d来删除匹配该正则表达式模式的行，因此删除了文本中的所有空白行。这是从文档中删除空白行的有效方法\n\n### 20.2.4 点字符\n\n特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。\n\n```bash\n$ cat data6\nThis is a test of a line. \nThe cat is sleeping. \nThat is a very nice hat. \nThis test is at line four. \nat ten o'clock we'll go home. \n$ sed -n '/.at/p' data6 \nThe cat is sleeping. \nThat is a very nice hat. \nThis test is at line four. \n\n```\n\n### 20.2.5 字符数组\n\n点字符在模糊匹配上很有用，但是你想在某一位置上指定字符范围，那么字符数组就会很有用\n\n```bash\n$ sed -n '/[ch]at/p' data6\nThe cat is sleeping. \nThat is a very nice hat. \n\n```\n\n### 20.2.6 排除型字符\n\n```bash\n$ sed -n '/[\nch]at/p' data6\nThis test is at line four. \n```\n\n通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字\n符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at\n开头的行仍然未能匹配模式\n\n### 20.2.7 区间\n\n想想匹配邮编那个case，实在是太麻烦，我们可以简化为`区间`表示  \n\n```bash\nsed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8 \n```\n\n也可以指定多个区间`sed -n '/[a-ch-m]at/p' data6`,该字符组允许区间a~c、h~m中的字母出现在at文本前\n\n### 20.2.8 特殊的字符数组\n\n```bash\n#BRE特殊字符组\n组                      描 述\n[[:alpha:]]             匹配任意字母字符，不管是大写还是小写\n[[:alnum:]]             匹配任意字母数字字符0~9、A~Z或a~z \n[[:blank:]]             匹配空格或制表符\n[[:digit:]]             匹配0~9之间的数字\n[[:lower:]]             匹配小写字母字符a~z \n[[:print:]]             匹配任意可打印字符\n[[:punct:]]             匹配标点符号    \n[[:space:]]             匹配任意空白字符：空格、制表符、NL、FF、VT和CR \n[[:upper:]]             匹配任意大写字母字符A~Z \n```\n\n### 20.2.9 星号\n\n在字符后面放置**星号**表明该字符必须在匹配模式的文本中出现0次或多次\n\n```bash\n$ echo \"ik\" | sed -n '/ie*k/p'\nik \n$ echo \"iek\" | sed -n '/ie*k/p' \niek \n$ echo \"ieek\" | sed -n '/ie*k/p' \nieek \n$ echo \"ieeek\" | sed -n '/ie*k/p'\n```\n\n另一个方便的特性是将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量\n的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。\n\n```bash\n$ echo \"this is a regular pattern expression\" | sed -n '\n> /regular.*expression/p' \nthis is a regular pattern expression \n```\n\n星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。  \n\n```bash\n$ echo \"bt\" | sed -n '/b[ae]*t/p'\nbt \n$ echo \"bat\" | sed -n '/b[ae]*t/p' \nbat \n$ echo \"bet\" | sed -n '/b[ae]*t/p' \nbet \n$ echo \"btt\" | sed -n '/b[ae]*t/p' \nbtt \n$ \n$ echo \"baat\" | sed -n '/b[ae]*t/p' \nbaat \n$ echo \"baaeeet\" | sed -n '/b[ae]*t/p' \nbaaeeet \n$ echo \"baeeaeeat\" | sed -n '/b[ae]*t/p' \nbaeeaeeat \n$ echo \"baakeeet\" | sed -n '/b[ae]*t/p' \n$ \n```\n\n只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。\n\n# AppendIndex\n\n- re-read 意思是重新理解该章节\n","source":"_posts/Linux命令行與shell腳本編程大全.md","raw":"---\ntitle: Linux命令行与shell腳本編程大全\ncategories:\n- linux\n---\n\n- [1. linux入门](#1-linux入门)\n- [2. 走进shell](#2-走进shell)\n- [3. 基本shell命令](#3-基本shell命令)\n  - [3.1 启动shell](#31-启动shell)\n  - [3.2 bash 手册](#32-bash-手册)\n  - [3.4 文件系统](#34-文件系统)\n- [4. 其他shell命令](#4-其他shell命令)\n  - [4.1 监控程序](#41-监控程序)\n  - [4.2 磁盘空间监控](#42-磁盘空间监控)\n  - [4.3 处理文件](#43-处理文件)\n  - [4.4 date命令及其格式化](#44-date命令及其格式化)\n- [5. 理解shell](#5-理解shell)\n  - [5.1 shell的类型](#51-shell的类型)\n  - [5.2 shell的父子关系](#52-shell的父子关系)\n    - [5.2.1 进程列表](#521-进程列表)\n    - [5.2.2 子shell的其他用法](#522-子shell的其他用法)\n  - [5.3 理解shell的内建命令](#53-理解shell的内建命令)\n    - [5.3.1 外部命令](#531-外部命令)\n    - [5.3.2 内部命令](#532-内部命令)\n- [6. 环境变量](#6-环境变量)\n- [7. linux文件权限](#7-linux文件权限)\n  - [7.1 linux的安全性](#71-linux的安全性)\n    - [7.1.1 添加linux用户](#711-添加linux用户)\n    - [7.1.2 删除用户](#712-删除用户)\n    - [7.1.2 修改用户](#712-修改用户)\n  - [7.2 使用linux组](#72-使用linux组)\n  - [7.3 理解文件权限](#73-理解文件权限)\n  - [7.4 改变安全性设置](#74-改变安全性设置)\n  - [7.5 共享文件](#75-共享文件)\n- [9. 安装软件程序](#9-安装软件程序)\n  - [9.1 包管理工具](#91-包管理工具)\n  - [9.2 基于Debian的系统](#92-基于debian的系统)\n    - [9.2.1 用aptitude 管理软件包](#921-用aptitude-管理软件包)\n  - [9.3 基于源码安装](#93-基于源码安装)\n- [10. 使用编辑器](#10-使用编辑器)\n  - [10.1 vim 编辑器](#101-vim-编辑器)\n- [11.基本脚本](#11基本脚本)\n- [12. 使用结构化命令](#12-使用结构化命令)\n- [13. for 循环](#13-for-循环)\n  - [13.1 for命令](#131-for命令)\n  - [13.2 C语言风格](#132-c语言风格)\n  - [13.3 while语句](#133-while语句)\n  - [13.4 until命令](#134-until命令)\n  - [13.5 循环处理数据并以特定分隔符分割数据](#135-循环处理数据并以特定分隔符分割数据)\n- [14. 处理用户输入](#14-处理用户输入)\n  - [14.1 读取参数，脚本名和测试参数](#141-读取参数脚本名和测试参数)\n  - [14.2 处理选项](#142-处理选项)\n  - [14.3 获取用户输入](#143-获取用户输入)\n- [15. 呈现数据](#15-呈现数据)\n  - [15.1 理解输入和输出](#151-理解输入和输出)\n    - [15.1.1 标准文件描述符](#1511-标准文件描述符)\n    - [15.1.2 重定向错误](#1512-重定向错误)\n  - [15.2 在脚本中重定向输出](#152-在脚本中重定向输出)\n    - [15.2.1 临时重定向](#1521-临时重定向)\n    - [15.2.2 永久重定向](#1522-永久重定向)\n  - [15.3 在脚本中重定向输入](#153-在脚本中重定向输入)\n  - [15.4 创建自己的重定向](#154-创建自己的重定向)\n    - [15.4.1 创建输出文件描述符](#1541-创建输出文件描述符)\n    - [15.4.2 重定向文件描述符](#1542-重定向文件描述符)\n    - [15.4.3 创建输入文件描述符](#1543-创建输入文件描述符)\n    - [15.4.4 创建读写文件描述符](#1544-创建读写文件描述符)\n    - [15.4.5 关闭文件描述符](#1545-关闭文件描述符)\n  - [15.5 列出未关闭的文件描述符](#155-列出未关闭的文件描述符)\n  - [15.6 组织命令输出](#156-组织命令输出)\n  - [15.7 创建临时文件](#157-创建临时文件)\n    - [15.7.1 创建本地临时文件](#1571-创建本地临时文件)\n    - [15.7.2 在/temp/创建临时文件](#1572-在temp创建临时文件)\n    - [15.7.3 创建临时目录](#1573-创建临时目录)\n  - [15.8 记录消息](#158-记录消息)\n  - [15.9 实战](#159-实战)\n- [16. 控制脚本](#16-控制脚本)\n  - [16.1 处理信号](#161-处理信号)\n    - [16.1.1 重温linux信号](#1611-重温linux信号)\n    - [16.1.2 生成信号](#1612-生成信号)\n    - [16.1.3 捕获信号](#1613-捕获信号)\n    - [16.1.4 捕获脚本退出](#1614-捕获脚本退出)\n    - [16.1.5 修改或移除捕获](#1615-修改或移除捕获)\n  - [16.2 以后台模式运行脚本](#162-以后台模式运行脚本)\n    - [16.2.1 后台运行脚本](#1621-后台运行脚本)\n    - [16.2.2 运行多个后台作业](#1622-运行多个后台作业)\n    - [16.2.3 在非控制台下运行程序](#1623-在非控制台下运行程序)\n  - [16.4 作业控制](#164-作业控制)\n    - [16.4.1 查看作业](#1641-查看作业)\n    - [16.4.2 重启停止的作业](#1642-重启停止的作业)\n  - [16.5 调整谦让度](#165-调整谦让度)\n    - [16.5.1 nice 命令](#1651-nice-命令)\n    - [16.5.2 renice 命令](#1652-renice-命令)\n  - [16.6 定时运行作业](#166-定时运行作业)\n    - [16.6.1 用at命令来计划执行作业](#1661-用at命令来计划执行作业)\n    - [16.6.2 安排需要定期执行的脚本](#1662-安排需要定期执行的脚本)\n    - [16.6.3 使用新shell启动脚本](#1663-使用新shell启动脚本)\n- [17. 创建函数](#17-创建函数)\n  - [17.1 基本的脚本函数](#171-基本的脚本函数)\n    - [17.1.1 创建函数](#1711-创建函数)\n    - [17.1.2 使用函数](#1712-使用函数)\n  - [17.2 返回值](#172-返回值)\n    - [17.2.1 默认退出状态码](#1721-默认退出状态码)\n    - [17.2.2 使用return命令](#1722-使用return命令)\n    - [17.2.3 使用函数输出](#1723-使用函数输出)\n  - [17.3 在函数中使用变量](#173-在函数中使用变量)\n    - [17.3.1 向函数传递参数](#1731-向函数传递参数)\n    - [17.3.2 在函数中处理变量](#1732-在函数中处理变量)\n  - [17.4 数组变量和函数](#174-数组变量和函数)\n    - [17.4.2 从函数中返回数组](#1742-从函数中返回数组)\n  - [17.5 函数递归](#175-函数递归)\n  - [17.6 创建库](#176-创建库)\n  - [17.7 在命令行上使用函数](#177-在命令行上使用函数)\n    - [17.7.1 在命令上创建函数](#1771-在命令上创建函数)\n    - [17.7.2 在.bashrc 文件中定义函数](#1772-在bashrc-文件中定义函数)\n  - [17.8 实例](#178-实例)\n    - [17.8.1 下载安装第三方库](#1781-下载安装第三方库)\n    - [17.8.2 构建库](#1782-构建库)\n    - [17.8.3 shtool库函数](#1783-shtool库函数)\n    - [17.8.4 使用库](#1784-使用库)\n- [18. 图形化界面中脚本编程](#18-图形化界面中脚本编程)\n- [19.初识sed和gawk](#19初识sed和gawk)\n  - [19.1 文本处理](#191-文本处理)\n    - [19.1.1 sed编辑器](#1911-sed编辑器)\n  - [19.2 sed and gawk进阶](#192-sed-and-gawk进阶)\n- [20.正则表达式](#20正则表达式)\n  - [20.1 什么是正则表达式](#201-什么是正则表达式)\n  - [20.2 定义BRE模式](#202-定义bre模式)\n    - [20.2.1. 纯文本](#2021-纯文本)\n    - [20.2.2 特殊字符](#2022-特殊字符)\n    - [20.2.3 锚定字符](#2023-锚定字符)\n    - [20.2.4 点字符](#2024-点字符)\n    - [20.2.5 字符数组](#2025-字符数组)\n    - [20.2.6 排除型字符](#2026-排除型字符)\n    - [20.2.7 区间](#2027-区间)\n    - [20.2.8 特殊的字符数组](#2028-特殊的字符数组)\n    - [20.2.9 星号](#2029-星号)\n- [AppendIndex](#appendindex)\n\n# 1. linux入门\n\nlinux是一款开源操作系统统称，其有很多发行版本，像ubuntu..，它的核心是其`内核`，早期由linus torvalds开发\n\n![linus本人](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da5122af2d44d499197cd6eafe8fc02~tplv-k3u1fbpfcp-watermark.image?)\n\n内核主要负责以下四种功能:\n\n- 系统内存管理\n- 软件程序管理\n    linux管理所有运行程序的进程.内核启动时会将`init`进程加载到`虚拟内存`，一些发行版本在`/etc/inittab`位置进行管理自启动进程,ubuntu则是在`/etc/init.d`或者`/etc/rcX.d`,`/etc/rcX.d`，`X`是某一特定是某一特定类型的进程，如下`rc0.d/`,`rc1.d/`,`rc2.d/`,`rc3.d/`,`rc4.d/`,`rc5.d/`,`rc6.d/`,`rcS.d/`运行级为**1**时，只启动基本的系统进程以及一个控制台终端进程。称之为**单用户模式**。单用户模式通常用来在系统有问题时进行紧急的文件系统维护。在这种模式下，仅有一个人（通常是系统管理员）能登录到系统上操作数据（这块部分以后涉及再补充也来的急，别深究）\n- 硬件设备管理\n  两种方式将驱动程序插入到系统内核\n  1. 编译进内核的设备驱动代码\n     - 以前加入新的驱动要重新编译内核，效率低下\n  2. 可插入内核的设备驱动模块\n      可插拔式内核驱动，Linux系统将硬件设备当成特殊的文件，称为`设备文件`。设备文件有3种分类：\n      - 字符型设备文件\n      - 块设备文件\n      - 网络设备文件\n\n- 文件系统管理\n    linux自有的诸多文件系统外，Linux还支持从其他操作系统（比如Microsoft Windows）采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持\n\n# 2. 走进shell\n\n在图形化桌面出现之前，与Unix(linux是兼容unix操作系统)系统进行交互的唯一方式就是借助由shell所提供的`文本命令`行界面(command line interface，CLI),是一种同Linux系统交互的直接接口\n\n# 3. 基本shell命令\n\n## 3.1 启动shell\n\n- `/etc/passwd`包含用户的基本信息,如下输出\n\n```bash\nchristine: x :501:501:Christine Bresnahan:/home/christine:/bin/bash\n```\n\n位置以此类推是用户名,密码,UID,GID,用户文本描述,家目录,默认启动启动bash作为自己的shell命令(第七章将有详细描述),目前绝大多数linux发行版将密码放在`/etc/shadow`目录下,普通方式是无法直接看到的\n\n## 3.2 bash 手册\n\nlinux自带命令手册，方便用户查看相关命令的具体选项和参数。在手册左上角括号内的数字表明对应的内容区域。每个内容区域都分配了一个数字，\n\n|序号|解释|\n|---|---|\n|1|可执行程序或shell命令|\n|2|系统调用|\n|3|库调用|\n|4|特殊文件|\n|5|文件格式与约定|\n|6|游戏|\n|7|概览,约定及杂项|\n|8|超级用户和系统管理员命令|\n|9|内核例程|\n\n如果你忘了命令的关键字那么可以使用`man -k`的方式查找命令，比如`mkdir`,就可以使用`man -k mkdir`,就可以检索出与`mkdir`相关的命令.\n包括对系统主机名的概述。要想查看所需要的页面，输入`man section linux-CMD-sytax`。对手册页中的第1部分而言，就是输入`man 1 hostname`。对于手册页中的第7部分，就是输入`man 7 hostname`  \n手册页不是唯一的参考资料。还有另一种叫作info页面的信息。可以输入`info info`来了解info页面的相关内容。\n\n## 3.4 文件系统\n\n简单理解，linux文件系统跟windows的文件布局是不一样的。\n\n- linux 文件系统\n  |目录|描述|\n  |---|---|\n  |/bin |二进制目录，存放许多用户级的GNU工具|\n  |/boot |启动目录，存放启动文件|\n  |/dev |设备目录，Linux在这里创建设备节点|\n  |/etc |系统配置文件目录|\n  |/home |主目录，Linux在这里创建用户目录|\n  |/lib |库目录，存放系统和应用程序的库文件|\n  |/media| 媒体目录，可移动媒体设备的常用挂载点|\n  |/mnt |挂载目录，另一个可移动媒体设备的常用挂载点|\n  |/opt |可选目录，常用于存放第三方软件包和数据文件|\n  |/proc |进程目录，存放现有硬件及当前进程的相关信息|\n  |/root |root用户的主目录|\n  |/sbin |系统二进制目录，存放许多GNU管理员级工具|\n  |/run |运行目录，存放系统运作时的运行时数据|\n  |/srv |服务目录，存放本地服务的相关文件|\n  |/sys |系统目录，存放系统硬件信息的相关文件|\n  |/tmp |临时目录，可以在该目录中创建和删除临时工作文件|\n  |/usr |用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里|\n  |/var |可变目录，用以存放经常变化的文件，比如日志文件|\n\n- 遍历目录(cd命令)\n  需要你知道文件树状结构,这样才能知道你将访问文件的具体位置，无论是`相对路径`还是`绝对路径`\n  `cd`命令，这时要注意文件系统的相对路径和绝对路径问题，linux通过这两种方式确定目录位置，符号`/`是表示根目录\n  - 绝对路径  通过从root目录开始一层一层的进行访问，最终访问到目标文件或者目录,`/bin/bash`从根目录定位到bash\n  - 相对路径\n    - `./` 当前目录\n    - `../` 上层目录\n    - `~/` 表示当前用户home目录\n\n  ```bash\n  cd ~/   # 进到对应账号的home目录下\n  cd /home/kirkzhang  #使用绝对路径进入家目录\n  ```\n\n- 目录列表(ls命令)\n  `ls`按照字母序列,参数`-l` 显示长列表,更多参数查看ls手册\n  - 问号（?）代表一个字符\n  - 星号（*）代表零个或多个字符\n- 文件链接\n  - 软连接\n    当我们需要相同文件时,不必要在每个文件夹下都放一份文件夹，只需要使用软链接\n    ls -s /usr/local/mysql/bin/mysql /usr/bin\n  - 硬链接\n\n# 4. 其他shell命令\n\n\n\n## 4.1 监控程序\n\n- ps查看进程\n\n  ```bash\n  ps 选项\n  -A 显示所有进程 \n  -N 显示与指定参数不符的所有进程 \n  -a 显示除控制进程（session leader①）和无终端进程外的所有进程 \n  -d 显示除控制进程外的所有进程 \n  -e 显示所有进程 \n  -C cmdlist 显示包含在cmdlist列表中的进程 \n  -G grplist 显示组ID在grplist列表中的进程 \n  -U userlist 显示属主的用户ID在userlist列表中的进程 \n  -g grplist 显示会话或组ID在grplist列表中的进程② \n  -p pidlist 显示PID在pidlist列表中的进程\n  -f 完整格式输出\n  ```\n\n  命令输出关键词意义\n  |名词|解释|\n  |---|---|\n  |UID|启动这些进程的用户  |\n  |PID|进程的ID  |\n  |PPID|父进程的进程号（如果该进程是由另一个进程启动的）  |\n  |C|进程生命周期中的CPU利用率 |\n  |STIME|进程启动时的系统时间 |\n  |TTY|进程启动时的终端设  |\n  |TIME|运行进程需要的累计CPU时间  |\n  |CMD|启动的程序名称|\n\n- top实时监控\n  - 第一行：当前时间，系统运行时间，登录用户数，系统的平均负载(15分钟的参数越大且超过，说明有问题)  \n  - 第二行：进程状态  \n  - 第三行：CPU相关数值，使用率  \n\n  |名词|解释|\n  |---|---|\n  |PID：|进程的ID|  \n  |USER：|进程属主的名字  |\n  |PR：|进程的优先级  |\n  |NI：|进程的谦让度度|\n  |VIRT：|进程占用的虚拟内存总量|\n  |RES：|进程占用的物理内存总量  |\n  |SHR：|进程和其他进程共享的内存总量|\n  |S：|进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表 跟踪状态或停止状态，Z代表僵化状态) |\n  |%CPU：|进程使用的CPU时间比例  |\n  |%MEM：||进程使用的内存占可用内存的比例  |\n  |TIME+：|自进程启动到目前为止的CPU时间总量|\n  |COMMAND|：进程所对应的命令行名称，也就是启动的程序名  |\n- kill结束进程\n  | 信号 | 名称 |描述|\n  | --- | --- |---|\n  | 1 | HUP | 挂起 |\n  | 2 | INT | 中断 |\n  | 3 | QUIT | 退出 |\n  | 9 | KILL | 无条件终止 |\n  | 11 | SEGV | 段错误 |\n  | 15 | TERM | 尽可能终止 |\n  | 17 | STOP | 无条件终止 |\n  | 18 | TSTP | 停止或暂停，但在后台运行 |\n  | 19 | CONT | 在STOP或TSTP之后恢复执行 |\n- 系统performance监控\n  这个要下载`sysstat`程序。\n  - iostat - reports CPU statistics and input/output statistics for block devices and partitions.\n  - mpstat - Processors Statistics\n    - `mpstat -P ALl` 所有processor\n    - `mpstat -P ALL 2 5` 迭代五次间隔两秒\n  - pidstat - Process and Kernel Threads Statistics\n  - tapestat - reports statistics for tape drives connected to the system\n  - cifsiostat - reports CIFS statistics.\n\n## 4.2 磁盘空间监控\n\n- mount挂在存储媒体\n  `mount`提供如下信息`媒体设备名`,`挂载点`,`文件类型`,`访问方式`  \n\n  ```bash\n  #将A设备挂在到B目录上,type 参数指定了磁盘被格式化的文件系统类型,如`vfat`,`iso9660`,`ntfs`,例如`mount -t vfat /dev/sdb1 /media/  disk`\n  mount -t type  A  B  \n  ```\n\n- mount参数列表，详情见man手册，或者如下\n  |参 数|  描 述 |\n  |---|---|\n  |-a|挂载/etc/fstab文件中指定的所有文件系统|\n  |-f|使 mount 命令模拟挂载设备，但并不真的挂载|\n  |-F|和 -a 参数一起使用时，会同时挂载所有文件系统|\n  |-v|详细模式，将会说明挂载设备的每一步|\n  |-I|不启用任何/sbin/mount.filesystem下的文件系统帮助文件|\n  |-l|给ext2、ext3或XFS文件系统自动添加文件系统标签|\n  |-n| 挂载设备，但不注册到/etc/mtab已挂载设备文件中|\n  |-p| num进行加密挂载时，从文件描述符 num 中获得密码短语|\n  |-s| 忽略该文件系统不支持的挂载选项|\n  |-r| 将设备挂载为只读的|\n  |-w| 将设备挂载为可读写的（默认参数）|\n  |-L label|  将设备按指定的 label 挂载|\n  |-U uuid|  将设备按指定的 uuid 挂载|\n  |-O| 和 -a 参数一起使用，限制命令只作用到特定的一组文件系统上|\n  |-o| 给文件系统添加特定的选项|\n- `-o`参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。以下为常用的选项\n\n  ```bash\n  ro #只读挂载  \n  rw #读写挂载\n  user #允许普通用户挂在\n  loop #挂载一个文件\n  check=none #挂载时进行完整性校验\n  ```\n\n- unmount 卸载设备\n\n  ```bash\n  unmount [directory | device] # //卸载文件应在外侧目录完成,命令行提示符仍然在挂载设备的文件系统目录中，`umount` 命令无法卸载该镜像\n  ```\n\n- df 查看文件大小  \n\n  ```bash\n  df -h #以M,G描述问价大小\n  ```\n\n- du 查看文件大小\n\n  ```bash\n  -c #显示所有已列出文件总的大小(还是不宜读)\n  -h #按用户易读的格式输出大小，即用K替代千字节\n  -s #显示每个输出参数的总计\n  ```\n\n- find\n\n  ```bash\n  find 目录 -\n  ```\n  \n## 4.3 处理文件  \n\n- sort - 文件排序  \n\n  ```bash\n   -n  #sort命令会把数字当做字符来执行标准的字符排序,解决\n   -M  #按照月份排序\n   -k  #和`-t`参数在对按字段分隔的数据进行排序时非常有用`sort -t ':' -k 3 -n /etc/passwd`\n   -n  #按照数值排序du -hs * | sort -nr\n   -r  #反向排序 \n   ```\n\n- grep - 搜索文件  \n\n  ```bash\n  -v #输出不匹配的行\n  -n #输出行号\n  -c #计算匹配到的行数\n  -e #指定多个匹配模式\n  grep [tf] file1 #支持正则匹配\n  ```\n\n- egrep, fgrep 功能更强大  \n- 压缩数据 - zip , gzip:gz, compress:Z, bzip2:bz2\n\n  ```bash\n    gzip #压缩文件\n    gzcat #查看文件内容\n    gunzip #用来解压文件  \n  ```\n\n- 归档数据 - tar\n\n  ```bash\n  -c #~ create`创建一个新的tar文件\n  -r #追加文件到tar文件末尾\n  -x #~ extract`抽取tar文件\n  -v #显示文件列表\n  -z #将输出重定向给gzip命令\n  -f # file`输出文件结果到文化，`tar -cvf test.tar test/ test2/` 创建一个新文件\n  -t # list`列举tar内容\n  -C #指定具体目录\n  tar -xvf test.tar`令从tar文件test.tar中提取内容。如果tar文件是从一个目录结构创建的，那整个目录结构都会在当前目录下重新创建\n  ```\n\n## 4.4 date命令及其格式化\n\n- 格式化占位符\n\n  ```bash\n    %D – Display date as mm/dd/yy\n    %Y – Year (e.g., 2020)\n    %m – Month (01-12)\n    %B – Long month name (e.g., November)\n    %b – Short month name (e.g., Nov)\n    %d – Day of month (e.g., 01)\n    %j – Day of year (001-366)\n    %u – Day of week (1-7)\n    %A – Full weekday name (e.g., Friday)\n    %a – Short weekday name (e.g., Fri)\n    %H – Hour (00-23)\n    %I – Hour (01-12)\n    %M – Minute (00-59)\n    %S – Second (00-60)\n  ```\n\n- date时间加减\n\n  ```bash\n    echo  `date --date=\"-5 day\" +%Y%m%d`\n    echo  `date --date=\"-5 month\" +%Y%m%d`\n    echo  `date --date=\"-5 year\" +%Y%m%d`\n  ```\n\n- set和change系统时间\n\n  `date --set=\"20100513 05:30\"`谨慎使用\n\n- 展示某一日期文件的日期\n\n  `--file`选项打印出文件中每一行存在的日期字符串。\n\n  ```bash\n  date --file=\n  ```\n\n- 重写日期\n\n  ```bash\n  date -d 'TZ=\"Australia/Sydney\" 04:30 next Monday'\n  ```\n\n  下面命令可以列出`timezone`\n\n  ```bash\n  timedatectl list-timezones\n  ```\n\n- 与其他shell混用\n\n  ```bash\n  mysqldump  database_name > database_name-$(date +%Y%m%d).sql\n\n  ```\n\n- 使用Unix纪元时间（纪元转换）。\n\n  ```bash\n  date +%s # To show the number of seconds from the epoch to the current day, use the %s format control\n  date -d \"1984-04-08\" +\"%s\" # To see how many seconds passed from epoch to a specific date, enter\n  ```\n\n一个完整的带有详细时间的`date`命令是`date --date=\"-5 day\"  +\"%Y-%m-%d %H:%M:%S\"`\n\n# 5. 理解shell\n\n## 5.1 shell的类型\n\n不同Linux系统有很多种shell,`cat /etc/passwd`可以看到用户默认登录默认的shell\n\n- Debian的是dash\n- csh\n- sh(你经常会看到某些发行版使用软链接将默认的系统shell设置成bash shell，如本书所使用的CentOS发行版)\n\n## 5.2 shell的父子关系\n\n在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中的一些东西造成影响\n|参数|描述|\n|---|---|\n|-c string|从 string 中读取命令并进行处理|\n|-i|启动一个能够接收用户输入的交互shell|\n|-l |以登录shell的形式启动|\n|-r|启动一个受限shell，用户会被限制在默认目录中|\n|-s|从标准输入中读取命令|\n\n### 5.2.1 进程列表\n\n1. `(pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)`,括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令\n2. 语法为 `{ command; }` 。使用花括号进行命令分组,并不会像进程列表那样创建出子shell\n3. ( pwd ; (echo $BASH_SUBSHELL)) 创建子shell的子shell\n4. 在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢\n处理速度。在交互式的CLI shell会话中，子shell同样存在问题。它并非真正的多进程处理，因为\n终端控制着子shell的I/O\n\n### 5.2.2 子shell的其他用法\n\n1. 后台运行模式( & )\n2. 进程列表置于后台 (sleep 2 ; echo $BASH_SUBSHELL ; sleep 2) &\n3. 携程\n    - coproc My_Job { sleep 10; }, My_Job 是自定义名字，必须确保在第一个花括号（ { ）和命令名之间有一个空格\n    - 将`协程`与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,\n      然后把命令 `coproc` 放在前面就行了`coproc ( sleep 10; sleep 2 )`\n\n## 5.3 理解shell的内建命令\n\n### 5.3.1 外部命令\n\n当外部命令执行时，会创建出一个子进程。这种操作被称为`衍生`(forking),有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中\n\n- `which ps`\n- `type -a ps`\n- 当进程必须执行衍生操作时，它需要花费时间和精力来设置新子进程的环境。所以说，外部命令多少还是有代价的,就算衍生出子进程或是创建了子shell，你仍然可以通过发送信号与其沟通，这一点无论是\n在命令行还是在脚本编写中都是极其有用的\n\n### 5.3.2 内部命令\n\n1. 命令`type -a`显示出了每个命令的两种实现。注意， which 命令只显示出了外部命令文件\n2. `!数字`可以使用.bash_history文件的命令\n3. `alias -p`,有一个别名取代了标准命令 `ls`.它自动加入了`--color`选项，表明终端支持彩色模式的列表\n4. `alias li='ls -li'`,一个别名仅在它所被定义的shell进程中才有效\n\n# 6. 环境变量\n\n- login shell : 用户成功登陆后使用的是 Login shell。例如，当你通过终端、SSH 或使用 \"su -\" 命令来切换账号时都会使用的Login Shell\n- non-login shell : Non Login Shell 是指通过 login shell 开启的shell,Non-login shell执行`~/.bashrc`脚本来初始shell环境\n- 交互式shell ： 就是终端等待你输入命令的就是交互式shell\n- 非交互式shell : 非交互式模式，以shell script(非交互)方式执行。在这种模式 下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF，shell也就终止了\n\n如何快速辨别是login shell 还是non-login shell ,可通过`echo $0`如果是输出`-bash`说明是login shell,`bash`说明是non-login shell  \n\n- 全局环境变量对于所有shell都是可见的,对于子shell来说这是非常重要的,`printenv`or`env`命令查看全局命令\n- 局部变量，`set`返回全局变量，用户自定义变量,所以返回局部变量有点复杂，以字母序进行排序\n\n- 用户自定义变量\n\n  `echo $my_variable -> my_variable=Hello`可赋值,并且当你想要使用自定义变量时候要使用`${my_variable}`语法，大小写敏感\n\n- 设置全局环境变量\n  - `export my_variable`导出为全局变量，在子shell中修改该值，只会在子shell中生效\n  - `unset my_variable`删除环境变量,这条规则的一个例外就是使用 printenv 显示某个变量的值)\n  - 默认的环境变量，直接使用就好了\n\n    ![linux_default_variables](./../picture/linux_命令行与shell脚本/linux_default_variables.png)\n    ![linux_default_variables_1](./../picture/linux_命令行与shell脚本/linux_default_variables_1.png)\n  - 设置`path`环境变量,当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序.`PATH`环境变量定义了用于进行命令和程序查找的目录\n  - 定位环境变量\n    - 登录式shell  \n      在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作`启动文件`或`环境文件`。bash检查启动文件的方式取决于你启动bash的方式，启动bash shell有3种方式\n      - 登录时作为默认登录shell(login shell)\n        当你登录系统的时候，bash shell会作为登陆式shell进行启动，会在如下文件五个不同启动文件读取命令`/etc/profile`,`$HOME/.bash_profile`,`$HOME/.bash_login`,`$HOME/.profile`,`$HOME/.bashrc`\n        - `/etc/profile`  是系统默认的bash shell主启动文件，系统上每个用户登陆时候都会读取这个主启动文件，\n          两个发行版的`/etc/profile`文件都用到了同一个特性：for语句。它用来迭代`/etc/profile.d`目录，这为Linux系统提供了一个放置特定应用程序启动文件的地方，\n          当用户登录时，shell会执行这些文件。在本书所用的Ubuntu Linux系统中，\n          `/etc/profile.d`目录下包含以下文件  \n        - shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略,这里没提到`$HOME/.bashrc`文件，这个文件通常是通过其他文件运行  \n          - `$HOME/.bash_profile`\n          - `$HOME/.bash_login`\n          - `$HOME/.profile`\n\n        **NOTE** : 要留意的是有些Linux发行版使用了可拆卸式认证模块(Pluggable AuthenticationModules ，PAM)。在这种情况下，PAM文件会在bash shell启动之前处理，这些文件中可能会包含环境变量。PAM文件包括`/etc/environment`文 件 和`$HOME/.pam_environment`文件\n    - 交互式shell(non-login shell)  \n      如果你的shell不是登录系统时候启动的，那么你启动的shell就是交互式shell，它不会访问`/etc/profile`只会检查`.bashrc`文件，`.bashrc`文件有两个作用：一是查看/etc目录下通用的`bashrc`文件，二是为用户提供一个定制自己的命令别名(参见第5章)和私有脚本函数的地方(将在第17章中讲到)\n    - 非交互shell  \n      TBC\n    - 环境变量的持久化\n        对全局环境变量来说（Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修改过的变量设置放在`/etc/profile`文件中，但这可不是什么好主意。如果你升级了所用的发行版，这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。最好是在`/etc/profile.d`目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。在大多数发行版中，存储个人用户永久性bash shell变量的地方是`$HOME/.bashrc`文件。这一点适用于所有类型的shell进程。但如果设置了`BASH_ENV`变量，那么记住，除非它指向的是$HOME/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方\n- 环境变量数组\n    `mytest=(one two three four five)`定义了环境变量数组,`echo ${mytest[2]}`使用下标索引可以访问具体值,`echo ${mytest[*]}`可以访问所有的值,`unset mytest[2]`删除某个值,`unset mytest`删除全部\n- 总结\n    bash shell会在启动时执行几个启动文件。这些启动文件包含了环境变量的定义，可用于为每个bash会话设置标准环境变量。每次登录Linux系统，bash shell都会访问`/etc/profile`启动文件以及3个针对每个用户的本地启动文件：`$HOME/.bash_profile`、`$HOME/.bash_login`和`$HOME/.profile`。用户可以在这些文件中定制自己想要的环境变量和启动脚本。\n\n# 7. linux文件权限\n\n用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是`登录名`。登录名是用户用来登录系统的最长八字符的字符串（字符可以是数字或字母），同时会关联一个对应的密码\n\n## 7.1 linux的安全性\n\n- `/etc/passwd`包含用户的基本信息,所有在服务器后台运行都需要个`系统账户`运行\n\n  ```bash\n  1. 登录用户名\n  2. 用户密码\n  3. 用户账户的UID（数字形式）\n  4. 用户账户的组ID（GID）（数字形式）\n  5. 用户账户的文本描述（称为备注字段）\n  6. 用户HOME目录的位置\n  7. 用户的默认shell\n  ```\n\n  root固定分配UID是0，Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作`系统账户`，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个(application account)，如果全都是root权限登录系统就很危险，被攻陷就直接是root权限。\n- `/etc/shadow`真正存密码的文件,只允许root用户访问\n\n  ```bash\n  1. 与/etc/passwd文件中的登录名字段对应的登录名\n  2. 加密后的密码\n  3. 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）\n  4. 多少天后才能更改密码\n  5. 多少天后必须更改密码\n  6. 密码过期前提前多少天提醒用户更改密码\n  7. 密码过期后多少天禁用用户账户\n  8. 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）\n  9. 预留字段给将来使用\n  ```\n\n### 7.1.1 添加linux用户\n\n- `useradd`命令添加默认配置的用户,`/etc/default/useradd`可以加入`-D`选项查看默认参数如下(一些Linux发行版会把Linux用户和组工具放在/usr/sbin目录下，这个目录可能不在`PATH`环境变量里)\n  - 新用户会被添加到GID为100 的公共组；\n  - 新用户的HOME目录将会位于/home/loginname；\n  - 新用户账户密码在过期后不会被禁用；\n  - 新用户账户未被设置过期日期；\n  - 新用户账户将bash shell作为默认shell；\n  - 系统会将/etc/skel目录下的内容复制到用户的HOME目录下；\n  - 系统为该用户账户在mail目录下创建一个用于接收邮件的文件\n\n  `/etc/skel`下面它们是bash shell环境的标准启动文件,允许管理员把它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系统文件,`useradd`参数可以控制这些默认值,ubuntu系统在`/etc/skel`下，默认命令行参数\n\n  ```bash\n  -c comment 给新用户添加备注\n  -d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话）\n  -e expire_date 用YYYY-MM-DD格式指定一个账户过期的日期\n  -f inactive_days 指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示禁用这个功能\n  -g initial_group 指定用户登录组的GID或组名\n  -G group ... 指定用户除登录组之外所属的一个或多个附加组\n  -k 必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录\n  -m 创建用户的HOME目录\n  -M 不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项）\n  -n 创建一个与用户登录名同名的新组\n  -r 创建系统账户\n  -p passwd 为用户账户指定默认密码\n  -s shell 指定默认的登录shell \n  -u uid 为账户指定唯一的UID \n  ```\n\n  同时也可以更改默认值的参数\n\n  ```bash\n  -b default_home  更改默认的创建用户HOME目录的位置\n  -e expiration_date  更改默认的新账户的过期日期\n  -f inactive  更改默认的新用户从密码过期到账户被禁用的天数\n  -g group  更改默认的组名称或GID \n  -s shell  更改默认的登录shell \n  # 更改用户默认shell\n  useradd -D -s /bin/tsch\n  ```\n\n### 7.1.2 删除用户\n\nto_be_continue\n\n### 7.1.2 修改用户\n\nto_be_continue\n\n## 7.2 使用linux组\n\n- /etc/group 存储一个组的信息，低于500是系统的，高于500是用户组的\n  - 组名\n  - 组密码\n  - GID\n  - 属于该组的用户列表\n- 创建组\n- 修改组\n\n## 7.3 理解文件权限\n\n- 理解文件权限符号\n\n  ```bash\n  `-`代表文件\n  `d` 代表目录\n  `l` 代表链接\n  `c` 代表字符型设备\n  `b` 代表块设备\n  `n` 代表网络设备\n  `r` 可写\n  `w` 可写\n  `x` 可执行\n  文件owner,和对象组\n  ```\n\n- 设置默认文件权限\n  设置`umask`的值,默认文件权限等于文件最大权限，减去`umask`值，第一位代表了一项特别的安全特性，叫作粘着位（sticky bit）\n  rwx = 4 + 2 + 1 = 7, rw = 4 + 2 = 6, rx = 4 +1 = 5.\n\n## 7.4 改变安全性设置\n\n- chmod 改文件权限，如果使用的符号模式设置就是`u`代表用户，`g`代表组，`o`代表其他，`a`代表所有，`+`代表增加权限，`-`代表移除权限，`=`将权限设置成后面的值，额外的第三作用符号如下\n\n  ```bash\n  `X` ：如果对象是目录或者它已有执行权限，赋予执行权限。\n  `s` ：运行时重新设置UID或GID。\n  `t` ：保留文件或目录。\n  `u` ：将权限设置为跟属主一样。\n  `g` ：将权限设置为跟属组一样。\n  `o` ：将权限设置为跟其他用户一样\n  ```\n\n- chown 改文件所属\n  `chown option owner file[.group] file`\n  `chown owner.group file`直接改属主和组\n  `chown owner .` 属主和组都同名\n  `chgrp` 更改文件目录的默认属组\n\n## 7.5 共享文件\n\nLinux还为每个文件和目录存储了3个额外的信息位。\n\n- 设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。\n- 设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。\n- 粘着位：进程结束后文件还驻留（粘着）在内存中。\n如果你用的是八进制模式，你需要知道这些位的位置\n\n|二进制值|八进制值|描述|\n|---|---|---|\n|000|  0|所有位都清零|\n|001 | 1|粘着位置位|\n|010 | 2|SGID位置位|\n|011 | 3|SGID位和粘着位都置位|\n|100 | 4|SUID位置位|\n|101 | 5|SUID位和粘着位都置位|\n|110 | 6|SUID位和SGID位都置位|\n|111 | 7|所有位都置位|\n\n首先，用 `mkdir` 命令来创建希望共享的目录。然后通过 `chgrp` 命令将目录的默认属组改为包\n含所有需要共享文件的用户的组（你必须是该组的成员）。最后，将目录的SGID位置位，以保证\n目录中新建文件都用shared作为默认属组  \n\n```bash\n$ mkdir testdir\n$ ls -l\ndrwxrwxr-x 2 rich rich 4096 Sep 20 23:12 testdir/\n$ chgrp shared testdir\n$ chmod g+s testdir  // chmod 6770 testdir\n$ ls -l\ndrwxrwsr-x 2 rich shared 4096 Sep 20 23:12 testdir/\n$ umask 002\n$ cd testdir\n$ touch testfile\n$ ls -l\ntotal 0\n-rw-rw-r-- 1 rich shared 0 Sep 20 23:13 testfile\n\n```\n\n# 9. 安装软件程序\n\n## 9.1 包管理工具\n\n管理版本\n\n## 9.2 基于Debian的系统\n\n基于 Debian 的系统\n\n- dpkg 包管理工具\n- apt\n- apt-get\n- aptitude\n\n### 9.2.1 用aptitude 管理软件包\n\n`apt`,`dpkg`是包管理工具，`aptitude`是完整的软件包管理系统\n\n1. aptitude show wine  显示包wine的详细信息\n2. aptitude install package_name\n3. aptitude search package_name\n    如果看到一个 `i` ，说明这个包现在已经安装到了你的系统上了。如果看到一个 `p` 或 `v` ，说明这个包可用，但还没安装\n4. aptitude safe-upgrade\n5. aptitude remove/purge package_name\n6. `/etc/apt/sources.list`前面有deb说明是编译过的，deb-src是源代码，package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。你可以看到诸如main、restricted、universe和partner这样的值\n\ndpkg -L vim  显示vim的所有安装信息\ndpkg --search vim\n\n## 9.3 基于源码安装\n\nC++编译要使用CMake\n\n# 10. 使用编辑器\n\n## 10.1 vim 编辑器\n\n1. 移动光标\n\n   ```bash\n   文件很大,用方向键移动\n   gg 移动到最后一行\n   num G 移动到指定行数\n   G 移动到第一行\n   w file_name 将文件保存到另一个文件中\n   Pagedown + Pageup 翻页\n   w file_name 保存为另一个文件\n\n  ```\n\n2. 编辑数据\n   ```\n\n   x 删除光标当前所在字符(剪切)\n   dd 是切除当前行, p 是粘贴(剪切)\n   dw 删除光标当前所在当前字符(剪切)\n   yw 复制一个单词  y$复制整个行\n   u 撤销\n   a 在文件尾追加数据\n   A 在当前行尾追加数据\n   r char 用char 替换当前光标位置字符\n   R char 用text文本替换当前文本字符\n\n  ```\n3. 替换数据\n  ```bash\n  :s/old/new/  替换数据\n  :s/olr/new/g  替换文件中一行所有old\n  :m,ns/old/new/g 替换行号之间的所有old\n  :$s/old/new/g 替换整个文件中的old\n  :$s/old/new/gc 替换整个文件中的old，但是每次都提醒\n  ```\n\n# 11.基本脚本\n\n- 创建shell脚本\n  `#!/bin/bash`,bash找你的文件都是从path目录下，如果没有设置path目录那么就需要通过绝对路径和相对路径引用你的命令。然后是注意你的文件权限`umask`决定了你文件创建时候的默认权限\n- 文本信息  \n  echo可使用单引号和双引号来划定文本字符串\n  1. `echo  \"This is a test to see if you're paying attention\"`  文本中有单引号\n  2. `echo  'Rich says \"scripting is easy\".'` 文本中有双引号\n  3. 如果是单/双引号混合会怎样？\n  4. 文本字符串和命令输出到同一行\n\n- 使用变量\n  1. 用户变量区分大小写长度不超过20个字符\n  2. 变量,等号,值之间不能出现空格\n  3. 引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符.没有美元符号引用变量进行赋值shell就会将其理解为字符串\n  4. 命令替换分为`$()`和\\` \\`,testing=$(date)他们中间没有空格.命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的.在命令行提示符下使用路径./运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。在命令行提示符下运行脚本时一定要留心！\n  5.\n- 输入输出重定向\n  - `>`会覆盖,`>>`追加\n  - `wc < test6` 输入重定向,内联重定向`<<`,在命令行上使用内联输入重定向时,shell会用PS2环境变量中定义的次提示符（参见第6章）\n  - 管道，Linux管道命令（断条符号）允许你将命令的输出直接重定向到另一个命令的输入。【这里的问题还很多】\n\n- 执行数学计算\n  1. `expr`命令,特别注意`expr 1+5`这种是不起作用的(建议以后少用)\n  2. `$[ ]`对`expr`的改进,bash shell数学运算符只支持整数运算,`zsh`支持浮点运算\n  3. `bc`计算器\n     - `scale=4` 保留四位精度，`3.44 / 5 = .6880`, 支持定义变量\n     - 在脚本中使用`bc`,`variable=$(echo \"scale=4 ;3.44 / 5\" | bc)`,`var3=$(echo \"scale=4; $var1 / $var2\" | bc)`这里的var1和var2都是预定义的\n     - 将表达式定义到一个文件中，或者内联表达式\n\n        ```bash\n        #!/bin/bash \n        var1=10.46 \n        var2=43.67 \n        var3=33.2 \n        var4=71 \n        var5=$(bc << EOF \n        scale = 4 \n        a1 = ( $var1 * $var2) \n        b1 = ($var3 * $var4) \n        a1 + b1 \n        EOF \n        )\n\n        echo The final answer for this mess is $var5\n        ```\n\n- 退出脚本\n  1. `0`成功结束，`1`一般未知错误，`2`不适合的shell命令，`126`命令不可执行,`127`没找到命令，`128`无效退出参数，`128+x`与linux信号x相关的严重错误，`130`通过ctrl+退出，`255`正常范围之外的退出状态码\n  2. `exit`退出命令，可以自定义状态码，退出状态码最大只能是255，所以超过255会进行模运算\n\n# 12. 使用结构化命令\n\n- if statement\n\n  ```bash\n  ## style 1\n  if pwd\n  then\n    echo \"it works\"\n  fi\n  ## style 2\n  if pwd ; then \n    echo \"it works\"\n  fi\n\n  # style 3 \n  ## 如果grep返回0 就去执行echo statement\n  if grep $testuser /etc/passwd\n  then \n    echo \"this is my first command\"\n    echo \"this is my second command\"\n  fi\n  ## if elif else  ,在elif语句中，紧跟其后的else语句属于elif代码块。它们并不属于之前的if-then代码块 \n  if pwd \n  then \n    echo 1\n  else | elif command  ;then  echo 3 ; else  fi\n    echo 2\n  fi\n\n  ```\n\n- test命令\n\n  如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。支持符合条件检查\n\n  ```bash\n    ## 单一逻辑校验\n    if [ condition ] \n    then \n      commands\n    fi\n    ## 符合逻辑校验\n    if [ condition1 ] && [ condition2 ] || [ condition ] \n    then \n      commands\n    fi\n  ```\n\n  - 数值比较\n    - n1 -eq n2   等于\n    - n1 -ge n2   大于等于\n    - n1 -gt n2   大于\n    - n1 -le n2   小于等于\n    - n1 -lt n2   小于\n  - 字符串比较\n    - str1 = str2 字面量相等，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内\n    - str1 != str2 不相等\n    - str1 < str2   小于. `if [ $val1 > $val2 ]`直接这样比较字符串会创建一个文件。所以必须要转义`if [ $val1 \\> $val2 ]`。在比较测试中，大写字母被认为是小于小写字母的。比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果但sort命令恰好相反，本地语言设置（英语），A在a前面\n    - str1 > str2   大于\n    - -n str1  判断长度是否为非零\n    - -z str1  判断长度是否为零\n\n  - 文件比较\n    |比较|描述|\n    |---|---|\n    |-d file         |d=directory. 检查file是否存在并是一个目录|\n    |-e file         |e=exist. 检查file是否存在|\n    |-f file         |f=file. 检查file是否存在并是一个文件|\n    |-r file         |r=read. 检查file是否存在并可读|\n    |-s file         |s=检查file 是否存在并非空|\n    |-w file         |w=write. 检查file是否存在并可写|\n    |-x file         |检查file 是否存在并可执行|\n    |-O file         |O=all user 检查file是否存在并属当前用户所有|\n    |-G file         |G=group 检查file是否存在并且默认组与当前用户相同|\n    |file1 -nt file2 |检查file1是否比file2新|\n    |file1 -ot file2 |检查file1是否比file2旧|\n\n- (( ))和[[ ]]提供高级特性\n  - (( )) 提供更加方便的数学表达式计算，像其他oop语言一样\n  - [[ ]] 提供更加方便的字符串处理功能\n\n- `case`命令\n\n  ```bash\n  case variable in \n  pattern1 | pattern2 ) command1;;\n  pattern3) command2;;\n  *) command3;;\n  esac\n\n  ```\n\n# 13. for 循环\n\n## 13.1 for命令\n\n- for 基本语句\n\n```bash\nlist=\"Alabama Alaska Arizona Arkansas Colorado\" \nlist=$list\" Connecticut\"\nfor v in v_list\ndo\n  echo 1\n\ndone\n\n```\n\nv_list如果有单引号，1.用转义字符转义。2.用双引号定义用到的单引号的值。3.如果在单独的数据值中有空格，就必须用双引号将这些值圈起来，可直接拼接值。\n\n```bash\nfile=\"path of your file\"\nfor state in $(cat $file) \ndo \n echo \"Visit beautiful $state\" \ndone\n\n```\n\n读取文件内容进行迭代\n(ubuntu没有IFS环境变量和IFS.OLD)\n\n- 更改字段分隔符\n默认分隔符是`空格`，`制表符`，`换行符`环境变量IFS,控制着字段分隔符，有时候想灵活一点,有些地方用的换行符，但是其他地方继续保留原先的分隔符，可使用IFS=$'\\n', IFS.OLD=$IFS,IFS=$'\\n',但是如果想加入冒号作为换行符可以更改`/etc/passwd`文件加上IFS=:,如果想加多个可以依次在后面加IFS='\\n':;\"\n\n- 通配符\n\n  ```bash\n  #!bin/bash\n  for file in /home/rich/test/* \n  do \n    if [ -d \"$file\" ] \n    then \n      echo \"$file is a directory\" \n    elif [ -f \"$file\" ] \n    then \n      echo \"$file is a file\" \n    fi \n  done\n  ## 目录文件都会匹配\n  ##请注意这次条件判断有些特别使用了if [ -d \"$file\" ] 因为在linux中文件名有空格是合法的\n\n  ```\n\n## 13.2 C语言风格\n\n```bash\n\nfor (( a=1,b=10;a<=10;a++,b--))\ndo\n  echo 1\ndone\n\n```\n\n## 13.3 while语句\n\n```bash\nwhile true\ndo\n  echo\n\ndone\n\n```\n\n`break` 还可以指定跳出循环层数,两层`for`就跳出最内层,`break n`就会跳出.  \n`continue`结束本次循环，n为1，表明跳出的是当前的循环。如果你将n设为2，break命令就会停止下一级的外部循环  \n\n- 处理循环中的输出\n\n  ```bash\n  for file in /home/rich/* \n  do \n  if [ -d \"$file\" ] \n  then \n    echo \"$file is a directory\" \n  elif \n    echo \"$file is a file\"  \n  fi \n  done > output.txt\n  ```\n\n- 处理多个测试命令\n\n  这种情况下要注意，判断了所有条件，因为有一个条件返回为false，所以相当于逻辑`与`判断\n\n  ```bash\n  #!/bin/bash\n  # testing a multicommand while loop \n  var1=10 \n  while echo $var1 \n          [ $var1 -ge 0 ] \n  do \n  echo \"This is inside the loop\" \n  var1=$[ $var1 - 1 ] \n  done \n\n  ```\n\nwhile 或者for的嵌套循环中，内部循环可以读到外部变量\n\n## 13.4 until命令\n\n有点像其他语言的\ndo .... while 语法\n\n## 13.5 循环处理数据并以特定分隔符分割数据\n\n主要是修改IFS变量\n\n```bash\n#!/bin/bash \n# changing the IFS value \nIFS.OLD=$IFS \nIFS='\\n'\nfor entry in $(cat /etc/passwd) \ndo \n echo \"Values in $entry –\" \n IFS=':'\n  for value in $entry \n  do \n    echo \" $value\" \n  done \ndone \n```\n\n# 14. 处理用户输入\n\n## 14.1 读取参数，脚本名和测试参数\n\n- ./sumAB.sh  a  b  ## 这里$0是程序名, `$1`是a, `$2`是b. 超过九个就一定要花括号引用变量比如`${10}`，`$#`返回参数个数， `${!#}`获取最后一个参数，如果没有参数就会输出脚本名，`$*`变量会将所有参数当成单个参数,`$@`变量会组成数组，轻松访问所有的参数.\n\n  ```bash\n  for param in \"$@\"\n  do \n  echo \"\\$@ Parameter #$count = $param\" \n  count=$[ $count + 1 ] \n  done \n  ```\n\n- 如果程序名是`./test.sh`,那么echo $0 就是`./test.sh`\n- 如果程序名是`bash  /usr/lib/test.sh`,那么echo $0 就是`/usr/lib/test.sh`\n- 定义了参数位置，如果不传参会报错\n- `name=$(basename $0)` 可以只返回脚本名\n- `if [ -n \"$1\" ]`是指`$1`不为空\n- `shift`命令会移动命令参数,`shift n`可以指定跳过`n`参数.\n\n## 14.2 处理选项\n\nbash命令提供了`选项`和`参数`来控制,可以通过`shift`命令来控制\n\n- 处理简单的选项\n\n  ```bash\n  #!/bin/bash\n  # extracting command line options as parameters \n  # \n  echo \n  while [ -n \"$1\" ] \n  do \n  case \"$1\" in \n    -a) echo \"Found the -a option\" ;; \n    -b) echo \"Found the -b option\" ;; \n    -c) echo \"Found the -c option\" ;; \n    *) echo \"$1 is not an option\" ;; \n  esac\n  shift \n  done \n  $ ./test15.sh -a -b -c -d\n  ```\n\n- 分离选项和参数\n\n  ```bash\n  #!/bin/bash\n  # extracting options and parameters \n  echo \n  while [ -n \"$1\" ] \n  do \n    case \"$1\" in \n      -a) echo \"Found the -a option\" ;; \n      -b) echo \"Found the -b option\";; \n      -c) echo \"Found the -c option\" ;; \n      --) shift \n                break ;; \n      *) echo \"$1 is not an option\";; \n    esac \n  shift \n  done \n  # \n  count=1 \n  for param in $@ \n  do \n    echo \"Parameter #$count: $param\" \n    count=$[ $count + 1 ] \n  done \n  $ ./test16.sh -c -a -b -- test1 test2 test3\n  ```\n\n- 处理带值的选项\n\n  ```bash\n  #!/bin/bash\n  # extracting command line options and values \n  echo \n  while [ -n \"$1\" ] \n  do \n    case \"$1\" in \n      -a) echo \"Found the -a option\";; \n      -b) param=\"$2\" \n      echo \"Found the -b option, with parameter value $param\" \n      shift ;; \n      -c) echo \"Found the -c option\";; \n      --) shift \n      break ;; \n      *) echo \"$1 is not an option\";; \n    esac \n    shift \n  done \n  # \n  count=1 \n  for param in \"$@\" \n  do \n    echo \"Parameter #$count: $param\" \n    count=$[ $count + 1 ] \n  done \n  $ ./test17.sh -a -b test1 -d\n  ```\n\n  case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是$1，额外的参数值就应该位于$2（因为所有的参数在处理完之后都会被移出）。只要将参数值从$2变量中提取出来就可以了\n\n- 使用getopt与getopts命令\n  getopts命令会用到两个环境变量。如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。\n  OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。\n  这样你就能在处理完选项之后继续处理其他命令行参数了。\n\n  ```bash\n  #!/bin/bash\n  # simple demonstration of the getopts command \n  # \n  echo \n    while getopts :ab:c opt \n  do \n    case \"$opt\" in \n    a) echo \"Found the -a option\" ;; \n    b) echo \"Found the -b option, with value $OPTARG\";; \n    c) echo \"Found the -c option\" ;; \n    *) echo \"Unknown option: $opt\";; \n    esac \n  done\n  $ bash ./test19.sh -a -b \"1 2\" -c  # 在参数中加空格\n  $ bash ./test19.sh -abtest1        # 可以挨在一起\n  $ bash ./test19.sh -d              # 返回问号\n  $ bash ./test19.sh -a -b 456 -cdefg# 如果有参数的就要分开写\n  ```\n\n  - 使用OPTIND参数和OPTARG参数\n\n  ```bash\n  #!/bin/bash\n  # Processing options & parameters with getopts \n  # \n  echo \n  while getopts :ab:cd opt \n  do \n  case \"$opt\" in \n    a) echo \"Found the -a option\" ;; \n    b) echo \"Found the -b option, with value $OPTARG\" ;; \n    c) echo \"Found the -c option\" ;; \n    d) echo \"Found the -d option\" ;; \n    *) echo \"Unknown option: $opt\" ;; \n  esac \n  done \n  # \n  shift $[ $OPTIND - 1 ] \n  # \n  echo \n    count=1 \n  for param in \"$@\" \n  do \n    echo \"Parameter $count: $param\" \n    count=$[ $count + 1 ] \n  done\n  ```\n\n- 选项标准化\n  |参数|解释|\n  |---|---|\n  |-a |显示所有对象|\n  |-c |生成一个计数|\n  |-d |指定一个目录|\n  |-e |扩展一个对象|\n  |-f |指定读入数据的文件|\n  |-h |显示命令的帮助信息|\n  |-i |忽略文本大小写|\n  |-l |产生输出的长格式版本|\n  |-n |使用非交互模式（批处理）|\n  |-o |将所有输出重定向到的指定的输出文件|\n  |-q |以安静模式运行|\n  |-r |递归地处理目录和文件|\n  |-s |以安静模式运行|\n  |-v |生成详细输出|\n  |-x |排除某个对象|\n  |-y |对所有问题回答yes |\n\n## 14.3 获取用户输入\n\n- `read`命令，\n  - read命令包含了-p选项，允许你直接在read命令行指定提示符,\n  - read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量\n  - `-t`代表超时\n  - `-n 1`read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量\n  - `-s` 选项可以避免在read命令中输入的数据出现在显示器上\n  - 从文件中读取数据\n\n  ```bash\n  //单个变量\n  read -p \"please enter your age\" age\n  //多个变量\n  read -p \"please enter your name\" first last\n  // 超时参数\n  read -t 5 -p \n  // 获取指定字符个数\n  read -n1  -p \"Do you want to continue [Y/N]?\" answer\n  //隐藏输入\n  read -s -p \"Enter your password: \" pass \n  // 从文件中读取数据\n  #!/bin/bash\n  # reading data from a file \n  # \n  count=1 \n  cat test | while read line \n  do \n    echo \"Line $count: $line\" \n    count=$[ $count + 1] \n  done \n  echo \"Finished processing the file\" \n  ```\n  \n# 15. 呈现数据\n\n这一章主要是讲如何将脚本输出重定型向到系统其他位置\n\n## 15.1 理解输入和输出\n\n### 15.1.1 标准文件描述符\n\nLinux系统将每个对象(操作的文件，linux万物皆文件)当作文件处理。这包括输入和输出进程。Linux用文件描述符（filedescriptor）来标识每个文件对象\n\n```bash\n文件描述符  缩 写   描 述\n0           STDIN   标准输入\n1           STDOUT  标准输出\n2           STDERR  标准错误\n```\n\n1. STDIN实例  \n   `cat` 就会从STDIN输入数据，这时候你输入什么屏幕就会显示什么  \n   `cat < file.txt`通过STDIN通过重定向符号使`cat`查看一个非STDIN文件的输入\n2. STDOUT  \n3. STDERR\n   shell通过特殊的`STDERR`文件描述符来处理错误消息。`STDERR`文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置\n\n### 15.1.2 重定向错误\n\n1. 只重定向错误\n通过`2> file.txt`的方式将错误信息重定向到文件中\n2. 重定向错误和数据\n`ls -al test test2 test3 badtest 2> test6 1> test7` 这种就是将`STDERR`重定向到test6,然后将`STDOUT`重定向到test7.  \n也可以将STDERR和STDOUT的输出重定向到同一个输出文件使用`&>`,比如`ls -al test test2 test3 badtest &> test7`，bash消息赋予error更高的优先级\n\n## 15.2 在脚本中重定向输出\n\n可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：\n\n- 临时重定向行输出\n- 永久重定向脚本中的所有命令\n\n### 15.2.1 临时重定向\n\n如果使用上文提到的`STDERR`重定向方法就会将全局的`STDERR`信息都重定向到文件中，但是如果只重定向自己特定某些error信息就可以使用临时重定向，必须在文件描述符数字之前加一个`&`\n\n```bash\n# 举个例子 ./test8\n#!/bin/bash\n# testing STDERR messages \necho \"This is an error\" >&2 \necho \"This is normal output\" \n```\n\n如果像平常一样运行这个脚本，你可能看不出什么区别,因为所有输出都到了STDOUT,但是默认情况下，linux会将STDERR导向STDOUT,但是，如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向。\n\n```bash\n$ ./test8 2> test9\nThis is normal output \n$ cat test9 \nThis is an error \n```\n\n### 15.2.2 永久重定向\n\n如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可以用`exec`命令告诉shell在脚本执行期间重定向某个特定文件描述符。\n\n```bash\n#!/bin/bash\n# redirecting all output to a file \nexec 1>testout \necho \"This is a test of redirecting all output\" \necho \"from a script to another file.\" \necho \"without having to redirect every individual line\" \n```\n\n## 15.3 在脚本中重定向输入\n\n`exec`命令允许你将STDIN重定向到Linux系统上的文件中`exec 0< testfile`\n\n```bash\n# redirecting file input \nexec 0< testfile \ncount=1 \nwhile read line \ndo \n echo \"Line #$count: $line\" \n count=$[ $count + 1 ] \ndone \n```\n\n## 15.4 创建自己的重定向\n\n### 15.4.1 创建输出文件描述符\n\n可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件\n描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。这里有个在脚本中使用其\n他文件描述符的简单例子。(不是太理解这句话)\n\n```bash\n#./test13\n#!/bin/bash\n# using an alternative file descriptor \nexec 3>test13out \necho \"This should display on the monitor\" \necho \"and this should be stored in the file\" >&3 \necho \"Then this should be back on the monitor\" \n$ ./test13 \n```\n\n这个脚本用exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内\n容会像预想中那样显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入\n了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如\n日志文件）。\n\n### 15.4.2 重定向文件描述符\n\n现在介绍怎么恢复已重定向的文件描述符。你可以分配另外一个文件描述符给标准文件描述\n符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用\n该文件描述符重定向回STDOUT。听起来可能有点复杂，但实际上相当直接。这个简单的例子能\n帮你理清楚。\n\n```bash\n# ./test14 \n#!/bin/bash\n# storing STDOUT, then coming back to it \nexec 3>&1\nexec 1>test14out \necho \"This should store in the output file\" \necho \"along with this line.\" \nexec 1>&3\necho \"Now things should be back to normal\" \n$ \n$ ./test14 \nNow things should be back to normal \n$ cat test14out \nThis should store in the output file \nalong with this line. \n$ \n```\n\n这个方法可能有点叫人困惑，但这是一种在脚本中临时重定向输出，然后恢复默认输出设置\n的常用方法。\n\n### 15.4.3 创建输入文件描述符\n\n(不是很懂)\n可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，\n先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它\n原来的位置\n\n```bash\n#!/bin/bash \n# redirecting input file descriptors \nexec 6<&0 \nexec 0< testfile \ncount=1 \nwhile read line \ndo \n echo \"Line #$count: $line\" \n count=$[ $count + 1 ] \ndone \nexec 0<&6 \nread -p \"Are you done now? \" answer \ncase $answer in \nY|y) echo \"Goodbye\";; \nN|n) echo \"Sorry, this is the end.\";; \nesac\n\n```\n\n### 15.4.4 创建读写文件描述符\n\n（不是太理解）\n\n尽管看起来可能会很奇怪，但是你也可以打开单个文件描述符来作为输入和输出。可以用同\n一个文件描述符对同一个文件进行读写。\n不过用这种方法时，你要特别小心。由于你是对同一个文件进行数据读写，shell会维护一个\n内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。如果不够小\n心，它会产生一些令人瞠目的结果。看看下面这个例子。\n\n```bash\n\n#!/bin/bash \n# testing input/output file descriptor \nexec 3<> testfile \nread line <&3 \necho \"Read: $line\" \necho \"This is a test line\" >&3 \n$ cat testfile \nThis is the first line. \nThis is the second line. \nThis is the third line. \n\n#输出\n\n$ ./test16 \nRead: This is the first line. \n```\n\n### 15.4.5 关闭文件描述符\n\n不懂\n\n## 15.5 列出未关闭的文件描述符\n\n你能用的文件描述符只有9个，你可能会觉得这没什么复杂的。但有时要记住哪个文件描述\n符被重定向到了哪里很难。为了帮助你理清条理，bash shell提供了`lsof`命令。`$$`可以读取当前程序运行的的PID,`-a`\n对其他两个选项的输出做AND运算  \n\n```bash\n/usr/sbin/lsof -a -p $$ -d 0,1,2\n# lsof的默认输出\nCOMMAND     正在运行的命令名的前9个字符\nPID         进程的PID \nUSER        进程属主的登录名\nFD          文件描述符号以及访问类型（r代表读，w代表写，u代表读写）\nTYPE        文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）\nDEVICE      设备的设备号（主设备号和从设备号）\nSIZE        如果有的话，表示文件的大小\nNODE        本地文件的节点号\nNAME        文件名\n```\n\n(不是很懂)\n\n## 15.6 组织命令输出\n\n如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这\n会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。\n要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名\n字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。\n在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，\n不会显示。\n\n```bash\n\ncat /dev/null/ > test18\n# 这时候test18文件就是空的\n\n```\n\n## 15.7 创建临时文件\n\n### 15.7.1 创建本地临时文件\n\n```bash\nmktemp   kirk.XXXXXX  # 这里面的XXXXXX是必须的\n```\n\n这是在本地目录创建临时文件\n\n### 15.7.2 在/temp/创建临时文件\n\n```bash\nmktemp -t kirk.XXXXXX\n```\n\n在/temp/目录下创建了一个临时文件夹\n\n### 15.7.3 创建临时目录\n\n```bash\nmktemp -d kirk.XXXXXX\n```\n\n在/temp/目录下创建文件夹\n\n## 15.8 记录消息\n\n有时候想把STDOUT输出到指定文件，又想输出到屏幕上，可以考虑使用`tee`命令,但是tee命令会覆盖以前的内容\n但是如果你想把输出追加到文件中需要使用`-a`选项\n\n## 15.9 实战\n\n稍后完善\n\n# 16. 控制脚本\n\n## 16.1 处理信号\n\nlinux利用信号与运行在系统中的进程进行通信，\n\n### 16.1.1 重温linux信号\n\nlinux可以与程序产生30多种信号\n\n```bash\n信 号     值       描 述\n1         SIGHUP  挂起进程\n2         SIGINT  终止进程\n3         SIGQUIT 停止进程\n9         SIGKILL 无条件终止进程\n15        SIGTERM 尽可能终止进程\n17        SIGSTOP 无条件停止进程，但不是终止进程\n18        SIGTSTP 停止或暂停进程，但不终止进程\n19        SIGCONT 继续运行停止的进程\n```\n\n默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，\n交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。\n如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退\n出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。\n\n### 16.1.2 生成信号\n\n1. crtl+C 生成SIGINT(2)终止进程信号\n2. crtl+Z 生成SIGTSTP(17)停止shell中运行的任何进程\n   停止shell中运行的任何进程。停止（stopping）进程，跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置\n继续运行。在16.4节中，你会了解如何重启一个已经停止的进程。可以使用`ps -l`命令来显示各进程\n\n### 16.1.3 捕获信号\n\ntrap命令允许你来指定shell\n脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再\n由shell处理，而是交由本地处理。\n\n```bash\n#!/bin/bash \n# Testing signal trapping \n# \ntrap \"echo ' Sorry! I have trapped Ctrl-C'\" SIGINT \n# \necho This is a test script \n# \ncount=1 \nwhile [ $count -le 10 ] \ndo \n echo \"Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone\n```\n\n该脚本使用trap命令捕获信号，使我们编写的脚本处理信号而不是shell处理\n当使用`ctrl-C`时候，我们脚本的trap命令就会处理这个SIGINT信号\n\n### 16.1.4 捕获脚本退出\n\n除了在shell脚本中捕获退出，你也可以在shell退出时就行捕获，这是shell完成任务时一种执行命令的一种方式，要捕获shell的退出只需要在trap命令后面加上`EXIT`信号就行.\n\n```bash\n\n#!/bin/bash \n# Trapping the script exit \n# \ntrap \"echo Goodbye...\" EXIT \n# \ncount=1 \nwhile [ $count -le 5 ] \ndo \n echo \"Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone \n#1. 脚本正常执行完，然后执行了trap脚本\n#2. ctrl-c 命令也会触发退出命令,ctrl-c之后就不会执行剩余代码。\n```\n\n### 16.1.5 修改或移除捕获\n\n捕获或移除这节一句话概括就是设置trap命令的有效期，或者叫生命周期。也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上\n两个破折号就行了，\n\n```bash\n\n#!/bin/bash \n# Modifying a set trap \n# \ntrap \"echo ' Sorry... Ctrl-C is trapped.'\" SIGINT \n# \ncount=1 \nwhile [ $count -le 5 ] \ndo \n echo \"Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone \n# \ntrap \"echo ' I modified the trap!'\" SIGINT \n# \ncount=1 \nwhile [ $count -le 5 ] \ndo \n echo \"Second Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone\n\n```\n\n```bash\n$ ./test3.sh\nLoop #1 \nLoop #2 \nLoop #3 \n^C Sorry... Ctrl-C is trapped. \nLoop #4 \nLoop #5 \nSecond Loop #1 \nSecond Loop #2 \n^C I modified the trap! \nSecond Loop #3 \nSecond Loop #4 \nSecond Loop #5 \n$\n\n```\n\n也可以在trap命令后使用单破折号来恢复信号的默认行为  \n移除信号捕获后，脚本按照默认行为来处理SIGINT信号，也就是终止脚本运行。但如果信\n号是在捕获被移除前接收到的，那么脚本会按照原先trap命令中的设置进行处理。  \n在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，\n脚本会照旧执行trap中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。  \n总结:  \n修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的trap命令进行处理。trap根绝接收到信号会\n立刻从sleep中唤醒\n\n## 16.2 以后台模式运行脚本\n\n### 16.2.1 后台运行脚本\n\n当`&`符放到命令后时，它会将命令和bash shell分离开来,然后给分配一个`调度号`和`PID号`,在后台模式中，\n进程运行时不会和终端会话上的STDIN、STDOUT以及STDERR关联\n\n### 16.2.2 运行多个后台作业\n\n当我们同时运行多个后台运行程序的时候，然后使用`ps`命令这时候发现很多进程与`pts/0`绑定着，如果终端会话退出，那么后台进程也会随之退出\n\n### 16.2.3 在非控制台下运行程序\n\n有时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退\n出了终端会话。这可以用`nohup`命令来实现.和普通后台进程一样，shell会给命令分配一个作业号，Linux系统会为其分配一个`PID号`。区\n别在于，当你使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号。\n由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。\n为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为\nnohup.out的文件中。\n当多个命令同时使用nohup命令时候，且同时修改nohup命令的时候，他们会追加到nohup.out命令\n\n```bash\n# 命令demo\nnohup ./test1.sh &\n```\n## 16.4 作业控制\n\n### 16.4.1 查看作业\n\n`jobs`命令可以查看分配给shell的作业，`jobs -l`可以查看完整的PID  \n\n```bash\n参数  描述\n-l    列出进程的PID以及作业号\n-n    只列出上次shell发出的通知后改变了状态的作业\n-p    只列出作业的PID \n-r    只列出运行中的作业\n-s    只列出已停止的作业\n#你可能注意到了jobs命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用\n#作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。\n#当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加\n#号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。\n```\n\n### 16.4.2 重启停止的作业\n\n在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你\n当前工作的终端，所以在使用该功能时要小心了。  \n要以后台模式重启一个作业，可用bg命令加上作业号\n\n```bash\n\n[1]+ Stopped ./test11.sh \n$ bg # 这时候就重启了./test11.sh 作业，以后台模式\n# 如果重启多个就是用bg 2\n# 要以前台模式重启作业，可用带有作业号的fg命令。\n\n```\n\n## 16.5 调整谦让度\n\n1. 在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调\n度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统\n中，由shell启动的所有进程的调度优先级默认都是相同的。  \n2. 调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell\n以优先级0来启动所有进程。  \n最低值20是最高优先级，而最高值19是最低优先级，这太容易记混了。只要记住那句俗\n语“好人难做”就行了。  \n3. 有时你想要改变一个shell脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他\n进程过多的处理能力），还是给予它更高的优先级（这样它就能获得更多的处理时间），你都可以\n通过nice命令做到。\n\n### 16.5.1 nice 命令\n\nnice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice\n的-n命令行来指定新的优先级级别。\n\n```bash\nnice -n 10 ./test4.sh > test4.out &  # 注意，必须将nice命令和要启动的命令放在同一行中。\n```\n\n一旦用nice命令设置了优先级，就不可以用nice重新设置优先级\n\n### 16.5.2 renice 命令\n\n有时你想改变系统上已运行命令的优先级。这正是renice命令可以做到的。它允许你指定\n运行进程的PID来改变它的优先级。\n\n```bash\nrenice -n 10 -p 5055 # -p应该是指进程\n```\n\nrenice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一\n些限制:  \n\n- 只能对属于你的进程执行renice；\n- 只能通过renice降低进程的优先级；\n- root用户可以通过renice来任意调整进程的优先级。\n如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令\n\n## 16.6 定时运行作业\n\n### 16.6.1 用at命令来计划执行作业\n\n1. at命令的格式\n    at命令只执行一次，区别于cron\n\n    ```bash\n    at [-f filename] time # -f 后面用来指定读取命令\n    ```\n\n    time : 参数指定运行时间，如果错过就会在第二天同一时间再运行  \n    time能识别多种时间格式\n\n    - 标准小时和分钟的格式，比如10：15\n    - AM/PM指示符，比如10：15PM\n    - 特定可命名时间，比如now,noon,midnight,或者teatime(4 PM)\n    - 标准日期格式，比如MMDDYY,MM/DD/YY,DD.MM.YY\n    - 文本日期比如jul 4或Dec 25 加不加年份都可以。\n    - 你也可以指定增量时间\n      - 当前时间+25 min\n      - 明天10：15 PM\n      - 10：15+7天\n    通过`at`命令都会被提交到作业队列，针对不同的优先级存在26种不同的作业队列，使用\n    a-z和A-Z来指代，即使通过at命令提交过作业，也可以通过-q参数指定不同的队列字母\n    作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的\n    作业会被提交到a作业队列\n\n2. 获取作业的输出\nat命令利用sendemail应用程序发送邮件，这样其实很麻烦，但是可以将输出重定向到STDOUT\n和STDERR,再如果可以使用`-M`屏蔽输出\n\n3. 列出等待的作业\natq命令可以查看系统中哪些作业处于等待状态\n\n4. 删除作业\natrm删除等待种的作业\n\n```bash\n#demo\natq 命令可以列出作业编号\natrm 作业编号 # 只能删除你提交的作业，不能删除其他人的。\n```\n\n### 16.6.2 安排需要定期执行的脚本\n\n1. cron时间表\n\n    ```bash\n    min hour dayofmonth month dayofweek command\n    ```\n\n    比如你想每天10：15运行一个命令可以使用cron时间表条目\n\n    ```bash\n    min hour dayofmonth  month dayofweek  command\n    15  10   *           *     *          command\n    ```\n\n    但是如果想在每周一的下午4点15分执行，可写为\n\n    ```bash\n    15 16 * * 1 command\n    ```\n\n    可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）\n    或数值（0为周日，6为周六）,dayofmonth表项指定月份中的日期值（1~31）。\n\n    聪明的读者可能会问如何设置一个在每个月的最后一天执行的命令，因为你无法设置\n    dayofmonth的值来涵盖所有的月份。这个问题困扰着Linux和Unix程序员，也激发了不少解\n    决办法。常用的方法是加一条使用date命令的if-then语句来检查明天的日期是不是01：\n\n    ```bash\n    00 12 * * * if [ `date +%d -d tomorrow` = 01 ] ; then ; command\n    ```\n\n    它会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。\n\n    命令必须要指定要运行的脚本名字，或者添加重定向符号  \n    cron程序会用提交作业的用户账户运行该脚本。因此，你必须有访问该命令和命令中指定的\n    输出文件的权限。\n\n2. 构建cron时间表\n可以使用crontab -l来处理cron时间表  \n默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。\n在添加条目时，crontab命令会启用一个文本编辑器（参见第10章），使用已有的cron时间表作\n为文件内容（或者是一个空文件，如果时间表不存在的话）。\n\n3. 浏览cron目录\n\n    如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个\n    基本目录：hourly、daily、monthly和weekly。\n\n    - /etc/cron.daily\n    - /etc/cron.hourly\n    - /etc/cron.monthly\n    - /etc/cron.weekly\n    因此，如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它\n\n4. anacron程序\n如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么\n这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问\n题，许多Linux发行版还包含了anacron程序。  \nanacron\n程序只会处理位于cron目录的程序，比如/etc/cron.monthly。它用时间戳来决定作业\n是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/anacron。\n\n```bash\nsudo cat /var/spool/anacron/cron.monthly\n20150626\n```\n\nanacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录。  \nanacron时间表的基本格式和cron时间表略有不同：\n\n```bash\nperiod delay identifier command\n```\n\nperiod条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间\n戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。\ncommand条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的\n任何脚本。\n注意，anacron不会运行位于/etc/cron.hourly的脚本。这是因为anacron程序不会处理执行时间\n需求小于一天的脚本。\nidentifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误\n邮件中的作业。\n\n### 16.6.3 使用新shell启动脚本\n\n.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是\n当你登入bash shell时，另一次是当你启动一个bash shell时。如果你需要一个脚本在两个时刻都得\n以运行，可以把这个脚本放进该文件中。\n\n# 17. 创建函数\n\n## 17.1 基本的脚本函数\n\n### 17.1.1 创建函数\n有两种方式定义函数  \n```bash\nfunction name(){\ncommand;\n}\n```\n\n另一种更像是高级编程语言定义函数  \n\n```bash\nname(){\ncommand;\n}\n```\n\n### 17.1.2 使用函数\n\n正常情况就像是其他高级语言一样，但是bash的函数有个特殊情况。如果是重定义了一个旧函数，\n那么就会覆盖以前的定义,正如下面的例子\n\n```bash\n#!/bin/bash\n# testing using a duplicate function name \nfunction func1 { \necho \"This is the first definition of the function name\" \n} \nfunc1 \nfunction func1 { \n echo \"This is a repeat of the same function name\" \n} \nfunc1 \necho \"This is the end of the script\"\n\n```\n\n## 17.2 返回值\n\n### 17.2.1 默认退出状态码\n\n即使是在函数中，command1,command2,command3 中的1，2执行错误，3成功了，那么退出\n状态码也是0.所以说默认退出状态码是很危险的。\n\n### 17.2.2 使用return命令\n\nreturn的demo如下\n\n```bash\n#!/bin/bash\n# using the return command in a function \nfunction dbl { \n read -p \"Enter a value: \" value \n echo \"doubling the value\" \n return $[ $value * 2 ] \n} \ndbl \necho \"The new value is $?\"\n\n```\n\ndbl函数会将$value的值翻倍，然后返回，有两点要小心\n\n- 记住，函数一结束就取返回值\n- 记住，退出码必须是0~255\n\n也可以返回字符串和较大的数值，可以看下一节\n\n### 17.2.3 使用函数输出\n\n```bash\n#!/bin/bash\n# using the echo to return a value \nfunction dbl { \n read -p \"Enter a value: \" value \n echo $[ $value * 2 ] \n} \nresult=$(dbl) \necho \"The new value is $result\"\n\n#$ ./test5b\n#Enter a value: 200 \n#The new value is 400\n```\n\n可以看到是将一函数结果执行取值运算得到返回值。\n通过这种技术，你还可以返回浮点值和字符串值。这使它成为一种获取函数返回值的强\n大方法。\n\n## 17.3 在函数中使用变量\n\n### 17.3.1 向函数传递参数\n\n错误传递参数代码\n```bash\n#!/bin/bash \n# trying to access script parameters inside a function \nfunction badfunc1 { \n echo $[ $1 * $2 ] \n} \nif [ $# -eq 2 ] \nthen \n value=$(badfunc1) \n echo \"The result is $value\" \nelse \n echo \"Usage: badtest1 a b\" \nfi \n# $ ./badtest1\n# Usage: badtest1 a b \n# $ ./badtest1 10 15 \n# ./badtest1: * : syntax error: operand expected (error token is \"* \n# \") \n# The result is \n# 脚本的$1和$2和函数调用的$1,$2变量是不一样的\n```\n\n接下来是正确的代码\n\n```bash\n#!/bin/bash \n# trying to access script parameters inside a function \nfunction func7 { \n echo $[ $1 * $2 ] \n} \nif [ $# -eq 2 ] \nthen \n value=$(func7 $1 $2) \n echo \"The result is $value\" \nelse \n echo \"Usage: badtest1 a b\" \nfi \n#$ \n#$ ./test7 \n#Usage: badtest1 a b \n#$ ./test7 10 15 \n#The result is 150 \n\n```\n\n通过将$1和$2变量传给函数，它们就能跟其他变量一样供函数使用了\n\n### 17.3.2 在函数中处理变量\n\n- 全局变量\n全局变量被覆盖\n\n```bash\n#!/bin/bash \n# demonstrating a bad use of variables \nfunction func1 { \n temp=$[ $value + 5 ] \n result=$[ $temp * 2 ] \n} \ntemp=4 \nvalue=6 \nfunc1 \necho \"The result is $result\" \nif [ $temp -gt $value ] \nthen \n echo \"temp is larger\" \nelse \n echo \"temp is smaller\" \nfi \n\n#$ ./badtest2\n#The result is 22 \n#temp is larger \n# 说明TEMP变量受到了影响，读和写都是改变的全局变量\n```\n\n- 局部变量\nlocal关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，\n那么shell将会保持这两个变量的值是分离的\n\n```bash\n#!/bin/bash\n# demonstrating the local keyword \nfunction func1 { \n local temp=$[ $value + 5 ] \n result=$[ $temp * 2 ] \n} \ntemp=4 \nvalue=6 \nfunc1 \necho \"The result is $result\" \nif [ $temp -gt $value ] \nthen \n echo \"temp is larger\" \nelse \n echo \"temp is smaller\" \nfi \n#$ ./test9\n#The result is 22 \n#temp is smaller \n```\n\nif里面的$temp参数是全局的，因为已经在函数外\n\n## 17.4 数组变量和函数\n\n直接传入只会传入数组的第一个值，可考虑如下方法\n\n```bash\n#!/bin/bash \n# array variable to function test \nfunction testit { \n local newarray \n newarray=(;'echo \"$@\"') \n echo \"The new array value is: ${newarray[*]}\" \n} \nmyarray=(1 2 3 4 5) \necho \"The original array is ${myarray[*]}\" \ntestit ${myarray[*]} \n#$ \n#$ ./test10 \n#The original array is 1 2 3 4 5 \n#The new array value is: 1 2 3 4 5 \n\n```\n第二种也可以\n```bash\n#!/bin/bash\n# adding values in an array \nfunction addarray { \n local sum=0 \n local newarray \n newarray=($(echo \"$@\")) \n for value in ${newarray[*]} \n do \n      sum=$[ $sum + $value ] \n done\n echo $sum \n}\nmyarray=(1 2 3 4 5)\necho \"The original array is: ${myarray[*]}\" \narg1=$(echo ${myarray[*]}) \nresult=$(addarray $arg1) \necho \"The result is $result\" \n\n#$ ./test11 \n#The original array is: 1 2 3 4 5 \n#The result is 15 \n```\n\n### 17.4.2 从函数中返回数组\n\n```bash\n#!/bin/bash\n# returning an array value \nfunction arraydblr { \n local origarray \n local newarray \n local elements \n local i \n origarray=($(echo \"$@\")) \n newarray=($(echo \"$@\")) \n elements=$[ $# - 1 ] \n for (( i = 0; i <= $elements; i++ )) \n { \n newarray[$i]=$[ ${origarray[$i]} * 2 ] \n } \n echo ${newarray[*]} \n} \nmyarray=(1 2 3 4 5) \necho \"The original array is: ${myarray[*]}\" \narg1=$(echo ${myarray[*]}) \nresult=($(arraydblr $arg1)) \necho \"The new array is: ${result[*]}\" \n\n```\narraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来\n重新生成一个新的数组变量。\n\n## 17.5 函数递归\n\n```bash\n#!/bin/bash\n# using recursion \nfunction factorial { \n if [ $1 -eq 1 ] \n then \n echo 1 \n else \n local temp=$[ $1 - 1 ] \n local result=$(factorial $temp) \n echo $[ $result * $1 ] \nfi \n}\nread -p \"Enter value: \" value \nresult=$(factorial $value) \necho \"The factorial of $value is: $result\" \n\n#$ ./test13\n#Enter value: 5 \n#The factorial of 5 is: 120 \n\n```\n\n## 17.6 创建库\n\n问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的\n\n```bash\n#!/bin/bash\n# using a library file the wrong way \n./myfuncs \nresult=$(addem 10 15) \necho \"The result is $result\"\n\n$ ./badtest4 \n./badtest4: addem: command not found \nThe result is \n```\n\n使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是\n创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。\n\n## 17.7 在命令行上使用函数\n\n和在shell脚本中将脚本函数当命令使用一样，在命令行界面中你也可以这样做。这个功能很，不错，因为一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数。有几种方法可以实现。\n\n### 17.7.1 在命令上创建函数\n\n- 简单点直接定义 `function divem { echo $[ $1 / $2 ]; } `\n- 另一种采用多行式\n\n  ```bash\n  $ function multem { \n  > echo $[ $1 * $2 ] \n  > } \n  $ multem 2 5 \n  ```\n\n### 17.7.2 在.bashrc 文件中定义函数\n\n1. 直接定义函数\n\n   ```bash\n    $ cat .bashrc\n    # .bashrc \n    # Source global definitions \n    if [ -r /etc/bashrc ]; then \n    . /etc/bashrc \n    fi \n    function addem { \n    echo $[ $1 + $2 ] \n    } \n   ```\n\n2. 读取函数文件\n直接定义在特地的文件内，然后读取在`.bashrc`中读取\n\n## 17.8 实例\n\n### 17.8.1 下载安装第三方库\n\n### 17.8.2 构建库\n\n下载，编译，安装。这里面涉及到`CMAKE`的相关知识\n\n### 17.8.3 shtool库函数\n\n这里就是介绍些shtool提供的一些函数，后面会很有用，但是需要与公司内的环境做适配\n\n### 17.8.4 使用库\n\n编译，安装完后，就可以在脚本中使用了\n\n# 18. 图形化界面中脚本编程\n\n暂时不需要\n\n# 19.初识sed和gawk\n你得熟悉Linux中的sed和gawk工具。这两个工具能够极大简化需要进行的数据处\n理任务。\n## 19.1 文本处理\n\n### 19.1.1 sed编辑器\nsed编辑器被称作流编辑器（stream editor），和普通的交互式文本编辑器恰好相反。在交互式\n文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。流编\n辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。\n\n- 一次输入一行\n- 根据所提供的编辑器命令匹配数据。\n- 按照命令修改流中数据\n- 将最后结果输出到STDOUT\n\n> sed  options  script  file\n\necho 'this is a test' | sed  's/test/big test/'  使用s命令将test替换为big test\n\nsed 's/dog/cat/'  data.txt    这是修改文件中dog为cat\nsed  -e  's/brown/red;  s/blue/yellow/'   data/txt\n\n从文件中读取编辑器命令\n\nsed -f script.sed  data.txt\n\ngawk\n\noption\n\n-F fs  指定行中划分数据字段的字段分隔符\n-f file  从指定的文件中读取程序\n-v var=value  定义gawk程序中的一个变量及其默认值\n-mf N  指定要处理的数据文件中的最大字段数\n-mr N  指定数据文件中的最大数据行数\n-W keyword  指定gawk的兼容模式或警告等级\n\n- 从命令行读取程序脚本\n  gawk '{print \"Hello World!\"}'\n\n- 从文件中读取数据\n  自动为文件每一行数据分配一个变量gawk '{print $1}' data2.txt 数据文件中每一行的第一个字符\n  eg: gawk -F: '{print $1}' /etc/passwd\n\n- 在程序脚本中使用多个命令\n\n  echo \"my name is rich\" | gawk '{$4=\"Christine\"; print $0}' , 给第四个字段名赋值，并输出文本名 ，如果不指定文件名就会从标准输入等待输入\n\n- 从文件中读取程序\n\n  command_gawk.gawk        gawk -F: -f  command_gawk.gawk  /etc/passwd\n\n  ```bash\n  BEGIN {\n  print \"The latest list of users and shells\"\n  print \" UserID \\t Shell\"\n  print \"-------- \\t -------\"\n  FS=\":\"\n  }\n  {\n  print $NF \" \\t \" $7\n  }\n  END {\n  print \"This concludes the listing\"\n  }\n  ```\n\n- 在处理数据前运行脚本\n\n  gawk 'BEGIN {print \"Hello World!\"}'\n\n  \\>{print $0}' data3.txt\n\n- 处理数据后运行脚本\n\n## 19.2 sed and gawk进阶\n\n替换标记\ns/pattern/replacement/flags\n\n- 数字， 说明新文本将替换第几处的地方\n- g，说明文本将替换所有\n- p, 原先行要打印\n- w file ， 将结果输出到新文件中\n- option 位置是 n 说明禁止输出\n\n替换字符\n在替换文件路径时候涉及到转义字符这样很影响阅读性\n\n替换指定行\nsed '2s/dog/cat/' data1.txt        这个命令的意思就是将data1.txt替换第二行中的dog，替换成cat\nsed '2,3s/dog/cat/' data1.txt    以此类推是第二行，第三行\nsed '2,$s/dog/cat/' data1.txt    从第二行开始到最后一行\nsed '/Samantha/s/bash/csh/' /etc/passwd   推过模式匹配\nsed '3,${\n  s/brown/green/\n  s/lazy/active/\n  }' data1.txt\n\n# 20.正则表达式\n\n## 20.1 什么是正则表达式\n\n正则表达式就是某种模板(筛子)，正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是\n一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。\n\n- POSIX基础正则表达式（basic regular expression，BRE）引擎\n- POSIX扩展正则表达式（extended regular expression，ERE）引擎\n\n## 20.2 定义BRE模式\n\n### 20.2.1. 纯文本\n\n`echo \"This is a test\" | sed -n '/this/p'` 这里面p是print,少了-n是打印两条，this没匹配到所以没有显示  \n空格也是普通的字符，比如`sed -n /  /p data.set`\n\n### 20.2.2 特殊字符\n\n`echo \"3 / 2\" | sed -n '///p'` 正斜线也需要转义字符，故正确的是`echo \"3 / 2\" | sed -n '/\\//p'`\n\n### 20.2.3 锚定字符\n\n1. `^`锚定字符  \n主要是锚定字符串行首。如果模式出现在行首之外的位置则不匹配，如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了`echo \"This is ^ a test\" | sed -n '/s ^/p'`\n``\n2. `$`锚定结尾\n特殊字符美元符`$`定义了行尾锚点。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。`echo \"This is a good book\" | sed -n '/book$/p'`\n3. 组合锚定\n\n    ```bash\n    $ cat data4\n    this is a test of using both anchors  # 这一行会被忽略\n    I said this is a test \n    this is a test \n    I'm sure this is a test. \n    $ sed -n '/^this is a test$/p' data4 \n    this is a test\n    ```\n\n    第二种情况\n\n    ```bash\n    $ cat data5\n    This is one test line. \n    This is another test line. \n    $ sed '/^$/d' data5 \n    This is one test line. \n    This is another test line. \n    ```\n\n    定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行。由于空白行在两个换行符之间没有文本，刚好匹配了正则表达式模式。sed编辑器用删除命令d来删除匹配该正则表达式模式的行，因此删除了文本中的所有空白行。这是从文档中删除空白行的有效方法\n\n### 20.2.4 点字符\n\n特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。\n\n```bash\n$ cat data6\nThis is a test of a line. \nThe cat is sleeping. \nThat is a very nice hat. \nThis test is at line four. \nat ten o'clock we'll go home. \n$ sed -n '/.at/p' data6 \nThe cat is sleeping. \nThat is a very nice hat. \nThis test is at line four. \n\n```\n\n### 20.2.5 字符数组\n\n点字符在模糊匹配上很有用，但是你想在某一位置上指定字符范围，那么字符数组就会很有用\n\n```bash\n$ sed -n '/[ch]at/p' data6\nThe cat is sleeping. \nThat is a very nice hat. \n\n```\n\n### 20.2.6 排除型字符\n\n```bash\n$ sed -n '/[\nch]at/p' data6\nThis test is at line four. \n```\n\n通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字\n符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at\n开头的行仍然未能匹配模式\n\n### 20.2.7 区间\n\n想想匹配邮编那个case，实在是太麻烦，我们可以简化为`区间`表示  \n\n```bash\nsed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8 \n```\n\n也可以指定多个区间`sed -n '/[a-ch-m]at/p' data6`,该字符组允许区间a~c、h~m中的字母出现在at文本前\n\n### 20.2.8 特殊的字符数组\n\n```bash\n#BRE特殊字符组\n组                      描 述\n[[:alpha:]]             匹配任意字母字符，不管是大写还是小写\n[[:alnum:]]             匹配任意字母数字字符0~9、A~Z或a~z \n[[:blank:]]             匹配空格或制表符\n[[:digit:]]             匹配0~9之间的数字\n[[:lower:]]             匹配小写字母字符a~z \n[[:print:]]             匹配任意可打印字符\n[[:punct:]]             匹配标点符号    \n[[:space:]]             匹配任意空白字符：空格、制表符、NL、FF、VT和CR \n[[:upper:]]             匹配任意大写字母字符A~Z \n```\n\n### 20.2.9 星号\n\n在字符后面放置**星号**表明该字符必须在匹配模式的文本中出现0次或多次\n\n```bash\n$ echo \"ik\" | sed -n '/ie*k/p'\nik \n$ echo \"iek\" | sed -n '/ie*k/p' \niek \n$ echo \"ieek\" | sed -n '/ie*k/p' \nieek \n$ echo \"ieeek\" | sed -n '/ie*k/p'\n```\n\n另一个方便的特性是将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量\n的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。\n\n```bash\n$ echo \"this is a regular pattern expression\" | sed -n '\n> /regular.*expression/p' \nthis is a regular pattern expression \n```\n\n星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。  \n\n```bash\n$ echo \"bt\" | sed -n '/b[ae]*t/p'\nbt \n$ echo \"bat\" | sed -n '/b[ae]*t/p' \nbat \n$ echo \"bet\" | sed -n '/b[ae]*t/p' \nbet \n$ echo \"btt\" | sed -n '/b[ae]*t/p' \nbtt \n$ \n$ echo \"baat\" | sed -n '/b[ae]*t/p' \nbaat \n$ echo \"baaeeet\" | sed -n '/b[ae]*t/p' \nbaaeeet \n$ echo \"baeeaeeat\" | sed -n '/b[ae]*t/p' \nbaeeaeeat \n$ echo \"baakeeet\" | sed -n '/b[ae]*t/p' \n$ \n```\n\n只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。\n\n# AppendIndex\n\n- re-read 意思是重新理解该章节\n","slug":"Linux命令行與shell腳本編程大全","published":1,"date":"2022-06-22T13:53:01.881Z","updated":"2022-10-07T14:10:01.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5f0004l1dbb0tfcbhh","content":"<ul>\n<li><a href=\"#1-linux%E5%85%A5%E9%97%A8\">1. linux入门</a></li>\n<li><a href=\"#2-%E8%B5%B0%E8%BF%9Bshell\">2. 走进shell</a></li>\n<li><a href=\"#3-%E5%9F%BA%E6%9C%ACshell%E5%91%BD%E4%BB%A4\">3. 基本shell命令</a><ul>\n<li><a href=\"#31-%E5%90%AF%E5%8A%A8shell\">3.1 启动shell</a></li>\n<li><a href=\"#32-bash-%E6%89%8B%E5%86%8C\">3.2 bash 手册</a></li>\n<li><a href=\"#34-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\">3.4 文件系统</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E5%85%B6%E4%BB%96shell%E5%91%BD%E4%BB%A4\">4. 其他shell命令</a><ul>\n<li><a href=\"#41-%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F\">4.1 监控程序</a></li>\n<li><a href=\"#42-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9B%91%E6%8E%A7\">4.2 磁盘空间监控</a></li>\n<li><a href=\"#43-%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6\">4.3 处理文件</a></li>\n<li><a href=\"#44-date%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6%E6%A0%BC%E5%BC%8F%E5%8C%96\">4.4 date命令及其格式化</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E7%90%86%E8%A7%A3shell\">5. 理解shell</a><ul>\n<li><a href=\"#51-shell%E7%9A%84%E7%B1%BB%E5%9E%8B\">5.1 shell的类型</a></li>\n<li><a href=\"#52-shell%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB\">5.2 shell的父子关系</a><ul>\n<li><a href=\"#521-%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8\">5.2.1 进程列表</a></li>\n<li><a href=\"#522-%E5%AD%90shell%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95\">5.2.2 子shell的其他用法</a></li>\n</ul>\n</li>\n<li><a href=\"#53-%E7%90%86%E8%A7%A3shell%E7%9A%84%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4\">5.3 理解shell的内建命令</a><ul>\n<li><a href=\"#531-%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4\">5.3.1 外部命令</a></li>\n<li><a href=\"#532-%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4\">5.3.2 内部命令</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#6-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">6. 环境变量</a></li>\n<li><a href=\"#7-linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90\">7. linux文件权限</a><ul>\n<li><a href=\"#71-linux%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7\">7.1 linux的安全性</a><ul>\n<li><a href=\"#711-%E6%B7%BB%E5%8A%A0linux%E7%94%A8%E6%88%B7\">7.1.1 添加linux用户</a></li>\n<li><a href=\"#712-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7\">7.1.2 删除用户</a></li>\n<li><a href=\"#712-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7\">7.1.2 修改用户</a></li>\n</ul>\n</li>\n<li><a href=\"#72-%E4%BD%BF%E7%94%A8linux%E7%BB%84\">7.2 使用linux组</a></li>\n<li><a href=\"#73-%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90\">7.3 理解文件权限</a></li>\n<li><a href=\"#74-%E6%94%B9%E5%8F%98%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E7%BD%AE\">7.4 改变安全性设置</a></li>\n<li><a href=\"#75-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">7.5 共享文件</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F\">9. 安装软件程序</a><ul>\n<li><a href=\"#91-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\">9.1 包管理工具</a></li>\n<li><a href=\"#92-%E5%9F%BA%E4%BA%8Edebian%E7%9A%84%E7%B3%BB%E7%BB%9F\">9.2 基于Debian的系统</a><ul>\n<li><a href=\"#921-%E7%94%A8aptitude-%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85\">9.2.1 用aptitude 管理软件包</a></li>\n</ul>\n</li>\n<li><a href=\"#93-%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85\">9.3 基于源码安装</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%E4%BD%BF%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8\">10. 使用编辑器</a><ul>\n<li><a href=\"#101-vim-%E7%BC%96%E8%BE%91%E5%99%A8\">10.1 vim 编辑器</a></li>\n</ul>\n</li>\n<li><a href=\"#11%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC\">11.基本脚本</a></li>\n<li><a href=\"#12-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4\">12. 使用结构化命令</a></li>\n<li><a href=\"#13-for-%E5%BE%AA%E7%8E%AF\">13. for 循环</a><ul>\n<li><a href=\"#131-for%E5%91%BD%E4%BB%A4\">13.1 for命令</a></li>\n<li><a href=\"#132-c%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC\">13.2 C语言风格</a></li>\n<li><a href=\"#133-while%E8%AF%AD%E5%8F%A5\">13.3 while语句</a></li>\n<li><a href=\"#134-until%E5%91%BD%E4%BB%A4\">13.4 until命令</a></li>\n<li><a href=\"#135-%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BB%A5%E7%89%B9%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6%E5%88%86%E5%89%B2%E6%95%B0%E6%8D%AE\">13.5 循环处理数据并以特定分隔符分割数据</a></li>\n</ul>\n</li>\n<li><a href=\"#14-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5\">14. 处理用户输入</a><ul>\n<li><a href=\"#141-%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E8%84%9A%E6%9C%AC%E5%90%8D%E5%92%8C%E6%B5%8B%E8%AF%95%E5%8F%82%E6%95%B0\">14.1 读取参数，脚本名和测试参数</a></li>\n<li><a href=\"#142-%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9\">14.2 处理选项</a></li>\n<li><a href=\"#143-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5\">14.3 获取用户输入</a></li>\n</ul>\n</li>\n<li><a href=\"#15-%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE\">15. 呈现数据</a><ul>\n<li><a href=\"#151-%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA\">15.1 理解输入和输出</a><ul>\n<li><a href=\"#1511-%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.1.1 标准文件描述符</a></li>\n<li><a href=\"#1512-%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF\">15.1.2 重定向错误</a></li>\n</ul>\n</li>\n<li><a href=\"#152-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA\">15.2 在脚本中重定向输出</a><ul>\n<li><a href=\"#1521-%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91\">15.2.1 临时重定向</a></li>\n<li><a href=\"#1522-%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91\">15.2.2 永久重定向</a></li>\n</ul>\n</li>\n<li><a href=\"#153-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5\">15.3 在脚本中重定向输入</a></li>\n<li><a href=\"#154-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91\">15.4 创建自己的重定向</a><ul>\n<li><a href=\"#1541-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.1 创建输出文件描述符</a></li>\n<li><a href=\"#1542-%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.2 重定向文件描述符</a></li>\n<li><a href=\"#1543-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.3 创建输入文件描述符</a></li>\n<li><a href=\"#1544-%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.4 创建读写文件描述符</a></li>\n<li><a href=\"#1545-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.5 关闭文件描述符</a></li>\n</ul>\n</li>\n<li><a href=\"#155-%E5%88%97%E5%87%BA%E6%9C%AA%E5%85%B3%E9%97%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.5 列出未关闭的文件描述符</a></li>\n<li><a href=\"#156-%E7%BB%84%E7%BB%87%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA\">15.6 组织命令输出</a></li>\n<li><a href=\"#157-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6\">15.7 创建临时文件</a><ul>\n<li><a href=\"#1571-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6\">15.7.1 创建本地临时文件</a></li>\n<li><a href=\"#1572-%E5%9C%A8temp%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6\">15.7.2 在&#x2F;temp&#x2F;创建临时文件</a></li>\n<li><a href=\"#1573-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95\">15.7.3 创建临时目录</a></li>\n</ul>\n</li>\n<li><a href=\"#158-%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF\">15.8 记录消息</a></li>\n<li><a href=\"#159-%E5%AE%9E%E6%88%98\">15.9 实战</a></li>\n</ul>\n</li>\n<li><a href=\"#16-%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC\">16. 控制脚本</a><ul>\n<li><a href=\"#161-%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7\">16.1 处理信号</a><ul>\n<li><a href=\"#1611-%E9%87%8D%E6%B8%A9linux%E4%BF%A1%E5%8F%B7\">16.1.1 重温linux信号</a></li>\n<li><a href=\"#1612-%E7%94%9F%E6%88%90%E4%BF%A1%E5%8F%B7\">16.1.2 生成信号</a></li>\n<li><a href=\"#1613-%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7\">16.1.3 捕获信号</a></li>\n<li><a href=\"#1614-%E6%8D%95%E8%8E%B7%E8%84%9A%E6%9C%AC%E9%80%80%E5%87%BA\">16.1.4 捕获脚本退出</a></li>\n<li><a href=\"#1615-%E4%BF%AE%E6%94%B9%E6%88%96%E7%A7%BB%E9%99%A4%E6%8D%95%E8%8E%B7\">16.1.5 修改或移除捕获</a></li>\n</ul>\n</li>\n<li><a href=\"#162-%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC\">16.2 以后台模式运行脚本</a><ul>\n<li><a href=\"#1621-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC\">16.2.1 后台运行脚本</a></li>\n<li><a href=\"#1622-%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%90%8E%E5%8F%B0%E4%BD%9C%E4%B8%9A\">16.2.2 运行多个后台作业</a></li>\n<li><a href=\"#1623-%E5%9C%A8%E9%9D%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F\">16.2.3 在非控制台下运行程序</a></li>\n</ul>\n</li>\n<li><a href=\"#164-%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6\">16.4 作业控制</a><ul>\n<li><a href=\"#1641-%E6%9F%A5%E7%9C%8B%E4%BD%9C%E4%B8%9A\">16.4.1 查看作业</a></li>\n<li><a href=\"#1642-%E9%87%8D%E5%90%AF%E5%81%9C%E6%AD%A2%E7%9A%84%E4%BD%9C%E4%B8%9A\">16.4.2 重启停止的作业</a></li>\n</ul>\n</li>\n<li><a href=\"#165-%E8%B0%83%E6%95%B4%E8%B0%A6%E8%AE%A9%E5%BA%A6\">16.5 调整谦让度</a><ul>\n<li><a href=\"#1651-nice-%E5%91%BD%E4%BB%A4\">16.5.1 nice 命令</a></li>\n<li><a href=\"#1652-renice-%E5%91%BD%E4%BB%A4\">16.5.2 renice 命令</a></li>\n</ul>\n</li>\n<li><a href=\"#166-%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A\">16.6 定时运行作业</a><ul>\n<li><a href=\"#1661-%E7%94%A8at%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%AE%A1%E5%88%92%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A\">16.6.1 用at命令来计划执行作业</a></li>\n<li><a href=\"#1662-%E5%AE%89%E6%8E%92%E9%9C%80%E8%A6%81%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC\">16.6.2 安排需要定期执行的脚本</a></li>\n<li><a href=\"#1663-%E4%BD%BF%E7%94%A8%E6%96%B0shell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC\">16.6.3 使用新shell启动脚本</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#17-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0\">17. 创建函数</a><ul>\n<li><a href=\"#171-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0\">17.1 基本的脚本函数</a><ul>\n<li><a href=\"#1711-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0\">17.1.1 创建函数</a></li>\n<li><a href=\"#1712-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0\">17.1.2 使用函数</a></li>\n</ul>\n</li>\n<li><a href=\"#172-%E8%BF%94%E5%9B%9E%E5%80%BC\">17.2 返回值</a><ul>\n<li><a href=\"#1721-%E9%BB%98%E8%AE%A4%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81\">17.2.1 默认退出状态码</a></li>\n<li><a href=\"#1722-%E4%BD%BF%E7%94%A8return%E5%91%BD%E4%BB%A4\">17.2.2 使用return命令</a></li>\n<li><a href=\"#1723-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA\">17.2.3 使用函数输出</a></li>\n</ul>\n</li>\n<li><a href=\"#173-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F\">17.3 在函数中使用变量</a><ul>\n<li><a href=\"#1731-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0\">17.3.1 向函数传递参数</a></li>\n<li><a href=\"#1732-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F\">17.3.2 在函数中处理变量</a></li>\n</ul>\n</li>\n<li><a href=\"#174-%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0\">17.4 数组变量和函数</a><ul>\n<li><a href=\"#1742-%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84\">17.4.2 从函数中返回数组</a></li>\n</ul>\n</li>\n<li><a href=\"#175-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92\">17.5 函数递归</a></li>\n<li><a href=\"#176-%E5%88%9B%E5%BB%BA%E5%BA%93\">17.6 创建库</a></li>\n<li><a href=\"#177-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0\">17.7 在命令行上使用函数</a><ul>\n<li><a href=\"#1771-%E5%9C%A8%E5%91%BD%E4%BB%A4%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0\">17.7.1 在命令上创建函数</a></li>\n<li><a href=\"#1772-%E5%9C%A8bashrc-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0\">17.7.2 在.bashrc 文件中定义函数</a></li>\n</ul>\n</li>\n<li><a href=\"#178-%E5%AE%9E%E4%BE%8B\">17.8 实例</a><ul>\n<li><a href=\"#1781-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\">17.8.1 下载安装第三方库</a></li>\n<li><a href=\"#1782-%E6%9E%84%E5%BB%BA%E5%BA%93\">17.8.2 构建库</a></li>\n<li><a href=\"#1783-shtool%E5%BA%93%E5%87%BD%E6%95%B0\">17.8.3 shtool库函数</a></li>\n<li><a href=\"#1784-%E4%BD%BF%E7%94%A8%E5%BA%93\">17.8.4 使用库</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#18-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E4%B8%AD%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B\">18. 图形化界面中脚本编程</a></li>\n<li><a href=\"#19%E5%88%9D%E8%AF%86sed%E5%92%8Cgawk\">19.初识sed和gawk</a><ul>\n<li><a href=\"#191-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86\">19.1 文本处理</a><ul>\n<li><a href=\"#1911-sed%E7%BC%96%E8%BE%91%E5%99%A8\">19.1.1 sed编辑器</a></li>\n</ul>\n</li>\n<li><a href=\"#192-sed-and-gawk%E8%BF%9B%E9%98%B6\">19.2 sed and gawk进阶</a></li>\n</ul>\n</li>\n<li><a href=\"#20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">20.正则表达式</a><ul>\n<li><a href=\"#201-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">20.1 什么是正则表达式</a></li>\n<li><a href=\"#202-%E5%AE%9A%E4%B9%89bre%E6%A8%A1%E5%BC%8F\">20.2 定义BRE模式</a><ul>\n<li><a href=\"#2021-%E7%BA%AF%E6%96%87%E6%9C%AC\">20.2.1. 纯文本</a></li>\n<li><a href=\"#2022-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6\">20.2.2 特殊字符</a></li>\n<li><a href=\"#2023-%E9%94%9A%E5%AE%9A%E5%AD%97%E7%AC%A6\">20.2.3 锚定字符</a></li>\n<li><a href=\"#2024-%E7%82%B9%E5%AD%97%E7%AC%A6\">20.2.4 点字符</a></li>\n<li><a href=\"#2025-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84\">20.2.5 字符数组</a></li>\n<li><a href=\"#2026-%E6%8E%92%E9%99%A4%E5%9E%8B%E5%AD%97%E7%AC%A6\">20.2.6 排除型字符</a></li>\n<li><a href=\"#2027-%E5%8C%BA%E9%97%B4\">20.2.7 区间</a></li>\n<li><a href=\"#2028-%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84\">20.2.8 特殊的字符数组</a></li>\n<li><a href=\"#2029-%E6%98%9F%E5%8F%B7\">20.2.9 星号</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#appendindex\">AppendIndex</a></li>\n</ul>\n<h1 id=\"1-linux入门\"><a href=\"#1-linux入门\" class=\"headerlink\" title=\"1. linux入门\"></a>1. linux入门</h1><p>linux是一款开源操作系统统称，其有很多发行版本，像ubuntu..，它的核心是其<code>内核</code>，早期由linus torvalds开发</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da5122af2d44d499197cd6eafe8fc02~tplv-k3u1fbpfcp-watermark.image\" alt=\"linus本人\"></p>\n<p>内核主要负责以下四种功能:</p>\n<ul>\n<li><p>系统内存管理</p>\n</li>\n<li><p>软件程序管理<br>  linux管理所有运行程序的进程.内核启动时会将<code>init</code>进程加载到<code>虚拟内存</code>，一些发行版本在<code>/etc/inittab</code>位置进行管理自启动进程,ubuntu则是在<code>/etc/init.d</code>或者<code>/etc/rcX.d</code>,<code>/etc/rcX.d</code>，<code>X</code>是某一特定是某一特定类型的进程，如下<code>rc0.d/</code>,<code>rc1.d/</code>,<code>rc2.d/</code>,<code>rc3.d/</code>,<code>rc4.d/</code>,<code>rc5.d/</code>,<code>rc6.d/</code>,<code>rcS.d/</code>运行级为<strong>1</strong>时，只启动基本的系统进程以及一个控制台终端进程。称之为<strong>单用户模式</strong>。单用户模式通常用来在系统有问题时进行紧急的文件系统维护。在这种模式下，仅有一个人（通常是系统管理员）能登录到系统上操作数据（这块部分以后涉及再补充也来的急，别深究）</p>\n</li>\n<li><p>硬件设备管理<br>两种方式将驱动程序插入到系统内核</p>\n<ol>\n<li>编译进内核的设备驱动代码<ul>\n<li>以前加入新的驱动要重新编译内核，效率低下</li>\n</ul>\n</li>\n<li>可插入内核的设备驱动模块<br> 可插拔式内核驱动，Linux系统将硬件设备当成特殊的文件，称为<code>设备文件</code>。设备文件有3种分类：<ul>\n<li>字符型设备文件</li>\n<li>块设备文件</li>\n<li>网络设备文件</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>文件系统管理<br>  linux自有的诸多文件系统外，Linux还支持从其他操作系统（比如Microsoft Windows）采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持</p>\n</li>\n</ul>\n<h1 id=\"2-走进shell\"><a href=\"#2-走进shell\" class=\"headerlink\" title=\"2. 走进shell\"></a>2. 走进shell</h1><p>在图形化桌面出现之前，与Unix(linux是兼容unix操作系统)系统进行交互的唯一方式就是借助由shell所提供的<code>文本命令</code>行界面(command line interface，CLI),是一种同Linux系统交互的直接接口</p>\n<h1 id=\"3-基本shell命令\"><a href=\"#3-基本shell命令\" class=\"headerlink\" title=\"3. 基本shell命令\"></a>3. 基本shell命令</h1><h2 id=\"3-1-启动shell\"><a href=\"#3-1-启动shell\" class=\"headerlink\" title=\"3.1 启动shell\"></a>3.1 启动shell</h2><ul>\n<li><code>/etc/passwd</code>包含用户的基本信息,如下输出</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">christine: x :501:501:Christine Bresnahan:/home/christine:/bin/bash</code></pre>\n\n<p>位置以此类推是用户名,密码,UID,GID,用户文本描述,家目录,默认启动启动bash作为自己的shell命令(第七章将有详细描述),目前绝大多数linux发行版将密码放在<code>/etc/shadow</code>目录下,普通方式是无法直接看到的</p>\n<h2 id=\"3-2-bash-手册\"><a href=\"#3-2-bash-手册\" class=\"headerlink\" title=\"3.2 bash 手册\"></a>3.2 bash 手册</h2><p>linux自带命令手册，方便用户查看相关命令的具体选项和参数。在手册左上角括号内的数字表明对应的内容区域。每个内容区域都分配了一个数字，</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>可执行程序或shell命令</td>\n</tr>\n<tr>\n<td>2</td>\n<td>系统调用</td>\n</tr>\n<tr>\n<td>3</td>\n<td>库调用</td>\n</tr>\n<tr>\n<td>4</td>\n<td>特殊文件</td>\n</tr>\n<tr>\n<td>5</td>\n<td>文件格式与约定</td>\n</tr>\n<tr>\n<td>6</td>\n<td>游戏</td>\n</tr>\n<tr>\n<td>7</td>\n<td>概览,约定及杂项</td>\n</tr>\n<tr>\n<td>8</td>\n<td>超级用户和系统管理员命令</td>\n</tr>\n<tr>\n<td>9</td>\n<td>内核例程</td>\n</tr>\n</tbody></table>\n<p>如果你忘了命令的关键字那么可以使用<code>man -k</code>的方式查找命令，比如<code>mkdir</code>,就可以使用<code>man -k mkdir</code>,就可以检索出与<code>mkdir</code>相关的命令.<br>包括对系统主机名的概述。要想查看所需要的页面，输入<code>man section linux-CMD-sytax</code>。对手册页中的第1部分而言，就是输入<code>man 1 hostname</code>。对于手册页中的第7部分，就是输入<code>man 7 hostname</code><br>手册页不是唯一的参考资料。还有另一种叫作info页面的信息。可以输入<code>info info</code>来了解info页面的相关内容。</p>\n<h2 id=\"3-4-文件系统\"><a href=\"#3-4-文件系统\" class=\"headerlink\" title=\"3.4 文件系统\"></a>3.4 文件系统</h2><p>简单理解，linux文件系统跟windows的文件布局是不一样的。</p>\n<ul>\n<li><p>linux 文件系统</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;bin</td>\n<td>二进制目录，存放许多用户级的GNU工具</td>\n</tr>\n<tr>\n<td>&#x2F;boot</td>\n<td>启动目录，存放启动文件</td>\n</tr>\n<tr>\n<td>&#x2F;dev</td>\n<td>设备目录，Linux在这里创建设备节点</td>\n</tr>\n<tr>\n<td>&#x2F;etc</td>\n<td>系统配置文件目录</td>\n</tr>\n<tr>\n<td>&#x2F;home</td>\n<td>主目录，Linux在这里创建用户目录</td>\n</tr>\n<tr>\n<td>&#x2F;lib</td>\n<td>库目录，存放系统和应用程序的库文件</td>\n</tr>\n<tr>\n<td>&#x2F;media</td>\n<td>媒体目录，可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>&#x2F;mnt</td>\n<td>挂载目录，另一个可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>&#x2F;opt</td>\n<td>可选目录，常用于存放第三方软件包和数据文件</td>\n</tr>\n<tr>\n<td>&#x2F;proc</td>\n<td>进程目录，存放现有硬件及当前进程的相关信息</td>\n</tr>\n<tr>\n<td>&#x2F;root</td>\n<td>root用户的主目录</td>\n</tr>\n<tr>\n<td>&#x2F;sbin</td>\n<td>系统二进制目录，存放许多GNU管理员级工具</td>\n</tr>\n<tr>\n<td>&#x2F;run</td>\n<td>运行目录，存放系统运作时的运行时数据</td>\n</tr>\n<tr>\n<td>&#x2F;srv</td>\n<td>服务目录，存放本地服务的相关文件</td>\n</tr>\n<tr>\n<td>&#x2F;sys</td>\n<td>系统目录，存放系统硬件信息的相关文件</td>\n</tr>\n<tr>\n<td>&#x2F;tmp</td>\n<td>临时目录，可以在该目录中创建和删除临时工作文件</td>\n</tr>\n<tr>\n<td>&#x2F;usr</td>\n<td>用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</td>\n</tr>\n<tr>\n<td>&#x2F;var</td>\n<td>可变目录，用以存放经常变化的文件，比如日志文件</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>遍历目录(cd命令)<br>需要你知道文件树状结构,这样才能知道你将访问文件的具体位置，无论是<code>相对路径</code>还是<code>绝对路径</code><br><code>cd</code>命令，这时要注意文件系统的相对路径和绝对路径问题，linux通过这两种方式确定目录位置，符号<code>/</code>是表示根目录</p>\n<ul>\n<li>绝对路径  通过从root目录开始一层一层的进行访问，最终访问到目标文件或者目录,<code>/bin/bash</code>从根目录定位到bash</li>\n<li>相对路径<ul>\n<li><code>./</code> 当前目录</li>\n<li><code>../</code> 上层目录</li>\n<li><code>~/</code> 表示当前用户home目录</li>\n</ul>\n</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> ~/   <span class=\"token comment\"># 进到对应账号的home目录下</span>\n<span class=\"token builtin class-name\">cd</span> /home/kirkzhang  <span class=\"token comment\">#使用绝对路径进入家目录</span></code></pre>\n</li>\n<li><p>目录列表(ls命令)<br><code>ls</code>按照字母序列,参数<code>-l</code> 显示长列表,更多参数查看ls手册</p>\n<ul>\n<li>问号（?）代表一个字符</li>\n<li>星号（*）代表零个或多个字符</li>\n</ul>\n</li>\n<li><p>文件链接</p>\n<ul>\n<li>软连接<br>当我们需要相同文件时,不必要在每个文件夹下都放一份文件夹，只需要使用软链接<br>ls -s &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql &#x2F;usr&#x2F;bin</li>\n<li>硬链接</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"4-其他shell命令\"><a href=\"#4-其他shell命令\" class=\"headerlink\" title=\"4. 其他shell命令\"></a>4. 其他shell命令</h1><h2 id=\"4-1-监控程序\"><a href=\"#4-1-监控程序\" class=\"headerlink\" title=\"4.1 监控程序\"></a>4.1 监控程序</h2><ul>\n<li><p>ps查看进程</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">ps</span> 选项\n-A 显示所有进程 \n-N 显示与指定参数不符的所有进程 \n-a 显示除控制进程（session leader①）和无终端进程外的所有进程 \n-d 显示除控制进程外的所有进程 \n-e 显示所有进程 \n-C cmdlist 显示包含在cmdlist列表中的进程 \n-G grplist 显示组ID在grplist列表中的进程 \n-U userlist 显示属主的用户ID在userlist列表中的进程 \n-g grplist 显示会话或组ID在grplist列表中的进程② \n-p pidlist 显示PID在pidlist列表中的进程\n-f 完整格式输出</code></pre>\n\n<p>命令输出关键词意义</p>\n<table>\n<thead>\n<tr>\n<th>名词</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UID</td>\n<td>启动这些进程的用户</td>\n</tr>\n<tr>\n<td>PID</td>\n<td>进程的ID</td>\n</tr>\n<tr>\n<td>PPID</td>\n<td>父进程的进程号（如果该进程是由另一个进程启动的）</td>\n</tr>\n<tr>\n<td>C</td>\n<td>进程生命周期中的CPU利用率</td>\n</tr>\n<tr>\n<td>STIME</td>\n<td>进程启动时的系统时间</td>\n</tr>\n<tr>\n<td>TTY</td>\n<td>进程启动时的终端设</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>运行进程需要的累计CPU时间</td>\n</tr>\n<tr>\n<td>CMD</td>\n<td>启动的程序名称</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>top实时监控</p>\n<ul>\n<li>第一行：当前时间，系统运行时间，登录用户数，系统的平均负载(15分钟的参数越大且超过，说明有问题)  </li>\n<li>第二行：进程状态  </li>\n<li>第三行：CPU相关数值，使用率</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名词</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PID：</td>\n<td>进程的ID</td>\n</tr>\n<tr>\n<td>USER：</td>\n<td>进程属主的名字</td>\n</tr>\n<tr>\n<td>PR：</td>\n<td>进程的优先级</td>\n</tr>\n<tr>\n<td>NI：</td>\n<td>进程的谦让度度</td>\n</tr>\n<tr>\n<td>VIRT：</td>\n<td>进程占用的虚拟内存总量</td>\n</tr>\n<tr>\n<td>RES：</td>\n<td>进程占用的物理内存总量</td>\n</tr>\n<tr>\n<td>SHR：</td>\n<td>进程和其他进程共享的内存总量</td>\n</tr>\n<tr>\n<td>S：</td>\n<td>进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表 跟踪状态或停止状态，Z代表僵化状态)</td>\n</tr>\n<tr>\n<td>%CPU：</td>\n<td>进程使用的CPU时间比例</td>\n</tr>\n<tr>\n<td>%MEM：</td>\n<td></td>\n</tr>\n<tr>\n<td>TIME+：</td>\n<td>自进程启动到目前为止的CPU时间总量</td>\n</tr>\n<tr>\n<td>COMMAND</td>\n<td>：进程所对应的命令行名称，也就是启动的程序名</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>kill结束进程</p>\n<table>\n<thead>\n<tr>\n<th>信号</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>HUP</td>\n<td>挂起</td>\n</tr>\n<tr>\n<td>2</td>\n<td>INT</td>\n<td>中断</td>\n</tr>\n<tr>\n<td>3</td>\n<td>QUIT</td>\n<td>退出</td>\n</tr>\n<tr>\n<td>9</td>\n<td>KILL</td>\n<td>无条件终止</td>\n</tr>\n<tr>\n<td>11</td>\n<td>SEGV</td>\n<td>段错误</td>\n</tr>\n<tr>\n<td>15</td>\n<td>TERM</td>\n<td>尽可能终止</td>\n</tr>\n<tr>\n<td>17</td>\n<td>STOP</td>\n<td>无条件终止</td>\n</tr>\n<tr>\n<td>18</td>\n<td>TSTP</td>\n<td>停止或暂停，但在后台运行</td>\n</tr>\n<tr>\n<td>19</td>\n<td>CONT</td>\n<td>在STOP或TSTP之后恢复执行</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>系统performance监控<br>这个要下载<code>sysstat</code>程序。</p>\n<ul>\n<li>iostat - reports CPU statistics and input&#x2F;output statistics for block devices and partitions.</li>\n<li>mpstat - Processors Statistics<ul>\n<li><code>mpstat -P ALl</code> 所有processor</li>\n<li><code>mpstat -P ALL 2 5</code> 迭代五次间隔两秒</li>\n</ul>\n</li>\n<li>pidstat - Process and Kernel Threads Statistics</li>\n<li>tapestat - reports statistics for tape drives connected to the system</li>\n<li>cifsiostat - reports CIFS statistics.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-2-磁盘空间监控\"><a href=\"#4-2-磁盘空间监控\" class=\"headerlink\" title=\"4.2 磁盘空间监控\"></a>4.2 磁盘空间监控</h2><ul>\n<li><p>mount挂在存储媒体<br><code>mount</code>提供如下信息<code>媒体设备名</code>,<code>挂载点</code>,<code>文件类型</code>,<code>访问方式</code>  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#将A设备挂在到B目录上,type 参数指定了磁盘被格式化的文件系统类型,如`vfat`,`iso9660`,`ntfs`,例如`mount -t vfat /dev/sdb1 /media/  disk`</span>\n<span class=\"token function\">mount</span> -t <span class=\"token builtin class-name\">type</span>  A  B  </code></pre>\n</li>\n<li><p>mount参数列表，详情见man手册，或者如下</p>\n<table>\n<thead>\n<tr>\n<th>参 数</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>挂载&#x2F;etc&#x2F;fstab文件中指定的所有文件系统</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>使 mount 命令模拟挂载设备，但并不真的挂载</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>和 -a 参数一起使用时，会同时挂载所有文件系统</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>详细模式，将会说明挂载设备的每一步</td>\n</tr>\n<tr>\n<td>-I</td>\n<td>不启用任何&#x2F;sbin&#x2F;mount.filesystem下的文件系统帮助文件</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>给ext2、ext3或XFS文件系统自动添加文件系统标签</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>挂载设备，但不注册到&#x2F;etc&#x2F;mtab已挂载设备文件中</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>num进行加密挂载时，从文件描述符 num 中获得密码短语</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>忽略该文件系统不支持的挂载选项</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>将设备挂载为只读的</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>将设备挂载为可读写的（默认参数）</td>\n</tr>\n<tr>\n<td>-L label</td>\n<td>将设备按指定的 label 挂载</td>\n</tr>\n<tr>\n<td>-U uuid</td>\n<td>将设备按指定的 uuid 挂载</td>\n</tr>\n<tr>\n<td>-O</td>\n<td>和 -a 参数一起使用，限制命令只作用到特定的一组文件系统上</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>给文件系统添加特定的选项</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>-o</code>参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。以下为常用的选项</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">ro <span class=\"token comment\">#只读挂载  </span>\nrw <span class=\"token comment\">#读写挂载</span>\nuser <span class=\"token comment\">#允许普通用户挂在</span>\nloop <span class=\"token comment\">#挂载一个文件</span>\n<span class=\"token assign-left variable\">check</span><span class=\"token operator\">=</span>none <span class=\"token comment\">#挂载时进行完整性校验</span></code></pre>\n</li>\n<li><p>unmount 卸载设备</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">unmount <span class=\"token punctuation\">[</span>directory <span class=\"token operator\">|</span> device<span class=\"token punctuation\">]</span> <span class=\"token comment\"># //卸载文件应在外侧目录完成,命令行提示符仍然在挂载设备的文件系统目录中，`umount` 命令无法卸载该镜像</span></code></pre>\n</li>\n<li><p>df 查看文件大小  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">df</span> -h <span class=\"token comment\">#以M,G描述问价大小</span></code></pre>\n</li>\n<li><p>du 查看文件大小</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-c <span class=\"token comment\">#显示所有已列出文件总的大小(还是不宜读)</span>\n-h <span class=\"token comment\">#按用户易读的格式输出大小，即用K替代千字节</span>\n-s <span class=\"token comment\">#显示每个输出参数的总计</span></code></pre>\n</li>\n<li><p>find</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> 目录 -</code></pre></li>\n</ul>\n<h2 id=\"4-3-处理文件\"><a href=\"#4-3-处理文件\" class=\"headerlink\" title=\"4.3 处理文件\"></a>4.3 处理文件</h2><ul>\n<li><p>sort - 文件排序  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-n  <span class=\"token comment\">#sort命令会把数字当做字符来执行标准的字符排序,解决</span>\n-M  <span class=\"token comment\">#按照月份排序</span>\n-k  <span class=\"token comment\">#和`-t`参数在对按字段分隔的数据进行排序时非常有用`sort -t ':' -k 3 -n /etc/passwd`</span>\n-n  <span class=\"token comment\">#按照数值排序du -hs * | sort -nr</span>\n-r  <span class=\"token comment\">#反向排序 </span></code></pre>\n</li>\n<li><p>grep - 搜索文件  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-v <span class=\"token comment\">#输出不匹配的行</span>\n-n <span class=\"token comment\">#输出行号</span>\n-c <span class=\"token comment\">#计算匹配到的行数</span>\n-e <span class=\"token comment\">#指定多个匹配模式</span>\n<span class=\"token function\">grep</span> <span class=\"token punctuation\">[</span>tf<span class=\"token punctuation\">]</span> file1 <span class=\"token comment\">#支持正则匹配</span></code></pre>\n</li>\n<li><p>egrep, fgrep 功能更强大  </p>\n</li>\n<li><p>压缩数据 - zip , gzip:gz, compress:Z, bzip2:bz2</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">gzip</span> <span class=\"token comment\">#压缩文件</span>\ngzcat <span class=\"token comment\">#查看文件内容</span>\ngunzip <span class=\"token comment\">#用来解压文件  </span></code></pre>\n</li>\n<li><p>归档数据 - tar</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-c <span class=\"token comment\">#~ create`创建一个新的tar文件</span>\n-r <span class=\"token comment\">#追加文件到tar文件末尾</span>\n-x <span class=\"token comment\">#~ extract`抽取tar文件</span>\n-v <span class=\"token comment\">#显示文件列表</span>\n-z <span class=\"token comment\">#将输出重定向给gzip命令</span>\n-f <span class=\"token comment\"># file`输出文件结果到文化，`tar -cvf test.tar test/ test2/` 创建一个新文件</span>\n-t <span class=\"token comment\"># list`列举tar内容</span>\n-C <span class=\"token comment\">#指定具体目录</span>\n<span class=\"token function\">tar</span> -xvf test.tar`令从tar文件test.tar中提取内容。如果tar文件是从一个目录结构创建的，那整个目录结构都会在当前目录下重新创建</code></pre></li>\n</ul>\n<h2 id=\"4-4-date命令及其格式化\"><a href=\"#4-4-date命令及其格式化\" class=\"headerlink\" title=\"4.4 date命令及其格式化\"></a>4.4 date命令及其格式化</h2><ul>\n<li><p>格式化占位符</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">%D – Display <span class=\"token function\">date</span> as mm/dd/yy\n%Y – Year <span class=\"token punctuation\">(</span>e.g., <span class=\"token number\">2020</span><span class=\"token punctuation\">)</span>\n%m – Month <span class=\"token punctuation\">(</span>01-12<span class=\"token punctuation\">)</span>\n%B – Long month name <span class=\"token punctuation\">(</span>e.g., November<span class=\"token punctuation\">)</span>\n%b – Short month name <span class=\"token punctuation\">(</span>e.g., Nov<span class=\"token punctuation\">)</span>\n%d – Day of month <span class=\"token punctuation\">(</span>e.g., 01<span class=\"token punctuation\">)</span>\n%j – Day of year <span class=\"token punctuation\">(</span>001-366<span class=\"token punctuation\">)</span>\n%u – Day of week <span class=\"token punctuation\">(</span><span class=\"token number\">1</span>-7<span class=\"token punctuation\">)</span>\n%A – Full weekday name <span class=\"token punctuation\">(</span>e.g., Friday<span class=\"token punctuation\">)</span>\n%a – Short weekday name <span class=\"token punctuation\">(</span>e.g., Fri<span class=\"token punctuation\">)</span>\n%H – Hour <span class=\"token punctuation\">(</span>00-23<span class=\"token punctuation\">)</span>\n%I – Hour <span class=\"token punctuation\">(</span>01-12<span class=\"token punctuation\">)</span>\n%M – Minute <span class=\"token punctuation\">(</span>00-59<span class=\"token punctuation\">)</span>\n%S – Second <span class=\"token punctuation\">(</span>00-60<span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li><p>date时间加减</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span>  <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> --date<span class=\"token operator\">=</span><span class=\"token string\">\"-5 day\"</span> +%Y%m%d<span class=\"token variable\">`</span></span>\n<span class=\"token builtin class-name\">echo</span>  <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> --date<span class=\"token operator\">=</span><span class=\"token string\">\"-5 month\"</span> +%Y%m%d<span class=\"token variable\">`</span></span>\n<span class=\"token builtin class-name\">echo</span>  <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> --date<span class=\"token operator\">=</span><span class=\"token string\">\"-5 year\"</span> +%Y%m%d<span class=\"token variable\">`</span></span></code></pre>\n</li>\n<li><p>set和change系统时间</p>\n<p><code>date --set=&quot;20100513 05:30&quot;</code>谨慎使用</p>\n</li>\n<li><p>展示某一日期文件的日期</p>\n<p><code>--file</code>选项打印出文件中每一行存在的日期字符串。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> --file<span class=\"token operator\">=</span></code></pre>\n</li>\n<li><p>重写日期</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> -d <span class=\"token string\">'TZ=\"Australia/Sydney\" 04:30 next Monday'</span></code></pre>\n\n<p>下面命令可以列出<code>timezone</code></p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">timedatectl list-timezones</code></pre>\n</li>\n<li><p>与其他shell混用</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">mysqldump  database_name <span class=\"token operator\">></span> database_name-<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +%Y%m%d<span class=\"token variable\">)</span></span>.sql\n</code></pre>\n</li>\n<li><p>使用Unix纪元时间（纪元转换）。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> +%s <span class=\"token comment\"># To show the number of seconds from the epoch to the current day, use the %s format control</span>\n<span class=\"token function\">date</span> -d <span class=\"token string\">\"1984-04-08\"</span> +<span class=\"token string\">\"%s\"</span> <span class=\"token comment\"># To see how many seconds passed from epoch to a specific date, enter</span></code></pre></li>\n</ul>\n<p>一个完整的带有详细时间的<code>date</code>命令是<code>date --date=&quot;-5 day&quot;  +&quot;%Y-%m-%d %H:%M:%S&quot;</code></p>\n<h1 id=\"5-理解shell\"><a href=\"#5-理解shell\" class=\"headerlink\" title=\"5. 理解shell\"></a>5. 理解shell</h1><h2 id=\"5-1-shell的类型\"><a href=\"#5-1-shell的类型\" class=\"headerlink\" title=\"5.1 shell的类型\"></a>5.1 shell的类型</h2><p>不同Linux系统有很多种shell,<code>cat /etc/passwd</code>可以看到用户默认登录默认的shell</p>\n<ul>\n<li>Debian的是dash</li>\n<li>csh</li>\n<li>sh(你经常会看到某些发行版使用软链接将默认的系统shell设置成bash shell，如本书所使用的CentOS发行版)</li>\n</ul>\n<h2 id=\"5-2-shell的父子关系\"><a href=\"#5-2-shell的父子关系\" class=\"headerlink\" title=\"5.2 shell的父子关系\"></a>5.2 shell的父子关系</h2><p>在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中的一些东西造成影响</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c string</td>\n<td>从 string 中读取命令并进行处理</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>启动一个能够接收用户输入的交互shell</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>以登录shell的形式启动</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>启动一个受限shell，用户会被限制在默认目录中</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>从标准输入中读取命令</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-2-1-进程列表\"><a href=\"#5-2-1-进程列表\" class=\"headerlink\" title=\"5.2.1 进程列表\"></a>5.2.1 进程列表</h3><ol>\n<li><code>(pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)</code>,括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令</li>\n<li>语法为 <code>&#123; command; &#125;</code> 。使用花括号进行命令分组,并不会像进程列表那样创建出子shell</li>\n<li>( pwd ; (echo $BASH_SUBSHELL)) 创建子shell的子shell</li>\n<li>在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢<br>处理速度。在交互式的CLI shell会话中，子shell同样存在问题。它并非真正的多进程处理，因为<br>终端控制着子shell的I&#x2F;O</li>\n</ol>\n<h3 id=\"5-2-2-子shell的其他用法\"><a href=\"#5-2-2-子shell的其他用法\" class=\"headerlink\" title=\"5.2.2 子shell的其他用法\"></a>5.2.2 子shell的其他用法</h3><ol>\n<li>后台运行模式( &amp; )</li>\n<li>进程列表置于后台 (sleep 2 ; echo $BASH_SUBSHELL ; sleep 2) &amp;</li>\n<li>携程<ul>\n<li>coproc My_Job { sleep 10; }, My_Job 是自定义名字，必须确保在第一个花括号（ { ）和命令名之间有一个空格</li>\n<li>将<code>协程</code>与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,<br>然后把命令 <code>coproc</code> 放在前面就行了<code>coproc ( sleep 10; sleep 2 )</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-3-理解shell的内建命令\"><a href=\"#5-3-理解shell的内建命令\" class=\"headerlink\" title=\"5.3 理解shell的内建命令\"></a>5.3 理解shell的内建命令</h2><h3 id=\"5-3-1-外部命令\"><a href=\"#5-3-1-外部命令\" class=\"headerlink\" title=\"5.3.1 外部命令\"></a>5.3.1 外部命令</h3><p>当外部命令执行时，会创建出一个子进程。这种操作被称为<code>衍生</code>(forking),有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于&#x2F;bin、&#x2F;usr&#x2F;bin、&#x2F;sbin或&#x2F;usr&#x2F;sbin中</p>\n<ul>\n<li><code>which ps</code></li>\n<li><code>type -a ps</code></li>\n<li>当进程必须执行衍生操作时，它需要花费时间和精力来设置新子进程的环境。所以说，外部命令多少还是有代价的,就算衍生出子进程或是创建了子shell，你仍然可以通过发送信号与其沟通，这一点无论是<br>在命令行还是在脚本编写中都是极其有用的</li>\n</ul>\n<h3 id=\"5-3-2-内部命令\"><a href=\"#5-3-2-内部命令\" class=\"headerlink\" title=\"5.3.2 内部命令\"></a>5.3.2 内部命令</h3><ol>\n<li>命令<code>type -a</code>显示出了每个命令的两种实现。注意， which 命令只显示出了外部命令文件</li>\n<li><code>!数字</code>可以使用.bash_history文件的命令</li>\n<li><code>alias -p</code>,有一个别名取代了标准命令 <code>ls</code>.它自动加入了<code>--color</code>选项，表明终端支持彩色模式的列表</li>\n<li><code>alias li=&#39;ls -li&#39;</code>,一个别名仅在它所被定义的shell进程中才有效</li>\n</ol>\n<h1 id=\"6-环境变量\"><a href=\"#6-环境变量\" class=\"headerlink\" title=\"6. 环境变量\"></a>6. 环境变量</h1><ul>\n<li>login shell : 用户成功登陆后使用的是 Login shell。例如，当你通过终端、SSH 或使用 “su -“ 命令来切换账号时都会使用的Login Shell</li>\n<li>non-login shell : Non Login Shell 是指通过 login shell 开启的shell,Non-login shell执行<code>~/.bashrc</code>脚本来初始shell环境</li>\n<li>交互式shell ： 就是终端等待你输入命令的就是交互式shell</li>\n<li>非交互式shell : 非交互式模式，以shell script(非交互)方式执行。在这种模式 下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF，shell也就终止了</li>\n</ul>\n<p>如何快速辨别是login shell 还是non-login shell ,可通过<code>echo $0</code>如果是输出<code>-bash</code>说明是login shell,<code>bash</code>说明是non-login shell  </p>\n<ul>\n<li><p>全局环境变量对于所有shell都是可见的,对于子shell来说这是非常重要的,<code>printenv</code>or<code>env</code>命令查看全局命令</p>\n</li>\n<li><p>局部变量，<code>set</code>返回全局变量，用户自定义变量,所以返回局部变量有点复杂，以字母序进行排序</p>\n</li>\n<li><p>用户自定义变量</p>\n<p><code>echo $my_variable -&gt; my_variable=Hello</code>可赋值,并且当你想要使用自定义变量时候要使用<code>$&#123;my_variable&#125;</code>语法，大小写敏感</p>\n</li>\n<li><p>设置全局环境变量</p>\n<ul>\n<li><p><code>export my_variable</code>导出为全局变量，在子shell中修改该值，只会在子shell中生效</p>\n</li>\n<li><p><code>unset my_variable</code>删除环境变量,这条规则的一个例外就是使用 printenv 显示某个变量的值)</p>\n</li>\n<li><p>默认的环境变量，直接使用就好了</p>\n<p><img src=\"/./../picture/linux_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/linux_default_variables.png\" alt=\"linux_default_variables\"><br><img src=\"/./../picture/linux_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/linux_default_variables_1.png\" alt=\"linux_default_variables_1\"></p>\n</li>\n<li><p>设置<code>path</code>环境变量,当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序.<code>PATH</code>环境变量定义了用于进行命令和程序查找的目录</p>\n</li>\n<li><p>定位环境变量</p>\n<ul>\n<li>登录式shell<br>在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作<code>启动文件</code>或<code>环境文件</code>。bash检查启动文件的方式取决于你启动bash的方式，启动bash shell有3种方式<ul>\n<li><p>登录时作为默认登录shell(login shell)<br>当你登录系统的时候，bash shell会作为登陆式shell进行启动，会在如下文件五个不同启动文件读取命令<code>/etc/profile</code>,<code>$HOME/.bash_profile</code>,<code>$HOME/.bash_login</code>,<code>$HOME/.profile</code>,<code>$HOME/.bashrc</code></p>\n<ul>\n<li><code>/etc/profile</code>  是系统默认的bash shell主启动文件，系统上每个用户登陆时候都会读取这个主启动文件，<br>两个发行版的<code>/etc/profile</code>文件都用到了同一个特性：for语句。它用来迭代<code>/etc/profile.d</code>目录，这为Linux系统提供了一个放置特定应用程序启动文件的地方，<br>当用户登录时，shell会执行这些文件。在本书所用的Ubuntu Linux系统中，<br><code>/etc/profile.d</code>目录下包含以下文件  </li>\n<li>shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略,这里没提到<code>$HOME/.bashrc</code>文件，这个文件通常是通过其他文件运行  <ul>\n<li><code>$HOME/.bash_profile</code></li>\n<li><code>$HOME/.bash_login</code></li>\n<li><code>$HOME/.profile</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>NOTE</strong> : 要留意的是有些Linux发行版使用了可拆卸式认证模块(Pluggable AuthenticationModules ，PAM)。在这种情况下，PAM文件会在bash shell启动之前处理，这些文件中可能会包含环境变量。PAM文件包括<code>/etc/environment</code>文 件 和<code>$HOME/.pam_environment</code>文件</p>\n</li>\n</ul>\n</li>\n<li>交互式shell(non-login shell)<br>如果你的shell不是登录系统时候启动的，那么你启动的shell就是交互式shell，它不会访问<code>/etc/profile</code>只会检查<code>.bashrc</code>文件，<code>.bashrc</code>文件有两个作用：一是查看&#x2F;etc目录下通用的<code>bashrc</code>文件，二是为用户提供一个定制自己的命令别名(参见第5章)和私有脚本函数的地方(将在第17章中讲到)</li>\n<li>非交互shell<br>TBC</li>\n<li>环境变量的持久化<br>  对全局环境变量来说（Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修改过的变量设置放在<code>/etc/profile</code>文件中，但这可不是什么好主意。如果你升级了所用的发行版，这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。最好是在<code>/etc/profile.d</code>目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。在大多数发行版中，存储个人用户永久性bash shell变量的地方是<code>$HOME/.bashrc</code>文件。这一点适用于所有类型的shell进程。但如果设置了<code>BASH_ENV</code>变量，那么记住，除非它指向的是$HOME&#x2F;.bashrc，否则你应该将非交互式shell的用户变量放在别的地方</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>环境变量数组<br>  <code>mytest=(one two three four five)</code>定义了环境变量数组,<code>echo $&#123;mytest[2]&#125;</code>使用下标索引可以访问具体值,<code>echo $&#123;mytest[*]&#125;</code>可以访问所有的值,<code>unset mytest[2]</code>删除某个值,<code>unset mytest</code>删除全部</p>\n</li>\n<li><p>总结<br>  bash shell会在启动时执行几个启动文件。这些启动文件包含了环境变量的定义，可用于为每个bash会话设置标准环境变量。每次登录Linux系统，bash shell都会访问<code>/etc/profile</code>启动文件以及3个针对每个用户的本地启动文件：<code>$HOME/.bash_profile</code>、<code>$HOME/.bash_login</code>和<code>$HOME/.profile</code>。用户可以在这些文件中定制自己想要的环境变量和启动脚本。</p>\n</li>\n</ul>\n<h1 id=\"7-linux文件权限\"><a href=\"#7-linux文件权限\" class=\"headerlink\" title=\"7. linux文件权限\"></a>7. linux文件权限</h1><p>用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是<code>登录名</code>。登录名是用户用来登录系统的最长八字符的字符串（字符可以是数字或字母），同时会关联一个对应的密码</p>\n<h2 id=\"7-1-linux的安全性\"><a href=\"#7-1-linux的安全性\" class=\"headerlink\" title=\"7.1 linux的安全性\"></a>7.1 linux的安全性</h2><ul>\n<li><p><code>/etc/passwd</code>包含用户的基本信息,所有在服务器后台运行都需要个<code>系统账户</code>运行</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>. 登录用户名\n<span class=\"token number\">2</span>. 用户密码\n<span class=\"token number\">3</span>. 用户账户的<span class=\"token environment constant\">UID</span>（数字形式）\n<span class=\"token number\">4</span>. 用户账户的组ID（GID）（数字形式）\n<span class=\"token number\">5</span>. 用户账户的文本描述（称为备注字段）\n<span class=\"token number\">6</span>. 用户<span class=\"token environment constant\">HOME</span>目录的位置\n<span class=\"token number\">7</span>. 用户的默认shell</code></pre>\n\n<p>root固定分配UID是0，Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作<code>系统账户</code>，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个(application account)，如果全都是root权限登录系统就很危险，被攻陷就直接是root权限。</p>\n</li>\n<li><p><code>/etc/shadow</code>真正存密码的文件,只允许root用户访问</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>. 与/etc/passwd文件中的登录名字段对应的登录名\n<span class=\"token number\">2</span>. 加密后的密码\n<span class=\"token number\">3</span>. 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）\n<span class=\"token number\">4</span>. 多少天后才能更改密码\n<span class=\"token number\">5</span>. 多少天后必须更改密码\n<span class=\"token number\">6</span>. 密码过期前提前多少天提醒用户更改密码\n<span class=\"token number\">7</span>. 密码过期后多少天禁用用户账户\n<span class=\"token number\">8</span>. 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）\n<span class=\"token number\">9</span>. 预留字段给将来使用</code></pre></li>\n</ul>\n<h3 id=\"7-1-1-添加linux用户\"><a href=\"#7-1-1-添加linux用户\" class=\"headerlink\" title=\"7.1.1 添加linux用户\"></a>7.1.1 添加linux用户</h3><ul>\n<li><p><code>useradd</code>命令添加默认配置的用户,<code>/etc/default/useradd</code>可以加入<code>-D</code>选项查看默认参数如下(一些Linux发行版会把Linux用户和组工具放在&#x2F;usr&#x2F;sbin目录下，这个目录可能不在<code>PATH</code>环境变量里)</p>\n<ul>\n<li>新用户会被添加到GID为100 的公共组；</li>\n<li>新用户的HOME目录将会位于&#x2F;home&#x2F;loginname；</li>\n<li>新用户账户密码在过期后不会被禁用；</li>\n<li>新用户账户未被设置过期日期；</li>\n<li>新用户账户将bash shell作为默认shell；</li>\n<li>系统会将&#x2F;etc&#x2F;skel目录下的内容复制到用户的HOME目录下；</li>\n<li>系统为该用户账户在mail目录下创建一个用于接收邮件的文件</li>\n</ul>\n<p><code>/etc/skel</code>下面它们是bash shell环境的标准启动文件,允许管理员把它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系统文件,<code>useradd</code>参数可以控制这些默认值,ubuntu系统在<code>/etc/skel</code>下，默认命令行参数</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-c comment 给新用户添加备注\n-d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话）\n-e expire_date 用YYYY-MM-DD格式指定一个账户过期的日期\n-f inactive_days 指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示禁用这个功能\n-g initial_group 指定用户登录组的GID或组名\n-G group <span class=\"token punctuation\">..</span>. 指定用户除登录组之外所属的一个或多个附加组\n-k 必须和-m一起使用，将/etc/skel目录的内容复制到用户的<span class=\"token environment constant\">HOME</span>目录\n-m 创建用户的<span class=\"token environment constant\">HOME</span>目录\n-M 不创建用户的<span class=\"token environment constant\">HOME</span>目录（当默认设置里要求创建时才使用这个选项）\n-n 创建一个与用户登录名同名的新组\n-r 创建系统账户\n-p <span class=\"token function\">passwd</span> 为用户账户指定默认密码\n-s shell 指定默认的登录shell \n-u uid 为账户指定唯一的<span class=\"token environment constant\">UID</span> </code></pre>\n\n<p>同时也可以更改默认值的参数</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-b default_home  更改默认的创建用户<span class=\"token environment constant\">HOME</span>目录的位置\n-e expiration_date  更改默认的新账户的过期日期\n-f inactive  更改默认的新用户从密码过期到账户被禁用的天数\n-g group  更改默认的组名称或GID \n-s shell  更改默认的登录shell \n<span class=\"token comment\"># 更改用户默认shell</span>\n<span class=\"token function\">useradd</span> -D -s /bin/tsch</code></pre></li>\n</ul>\n<h3 id=\"7-1-2-删除用户\"><a href=\"#7-1-2-删除用户\" class=\"headerlink\" title=\"7.1.2 删除用户\"></a>7.1.2 删除用户</h3><p>to_be_continue</p>\n<h3 id=\"7-1-2-修改用户\"><a href=\"#7-1-2-修改用户\" class=\"headerlink\" title=\"7.1.2 修改用户\"></a>7.1.2 修改用户</h3><p>to_be_continue</p>\n<h2 id=\"7-2-使用linux组\"><a href=\"#7-2-使用linux组\" class=\"headerlink\" title=\"7.2 使用linux组\"></a>7.2 使用linux组</h2><ul>\n<li>&#x2F;etc&#x2F;group 存储一个组的信息，低于500是系统的，高于500是用户组的<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n</li>\n<li>创建组</li>\n<li>修改组</li>\n</ul>\n<h2 id=\"7-3-理解文件权限\"><a href=\"#7-3-理解文件权限\" class=\"headerlink\" title=\"7.3 理解文件权限\"></a>7.3 理解文件权限</h2><ul>\n<li><p>理解文件权限符号</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\"><span class=\"token variable\">`</span>-<span class=\"token variable\">`</span></span>代表文件\n<span class=\"token variable\"><span class=\"token variable\">`</span>d<span class=\"token variable\">`</span></span> 代表目录\n<span class=\"token variable\"><span class=\"token variable\">`</span>l<span class=\"token variable\">`</span></span> 代表链接\n<span class=\"token variable\"><span class=\"token variable\">`</span>c<span class=\"token variable\">`</span></span> 代表字符型设备\n<span class=\"token variable\"><span class=\"token variable\">`</span>b<span class=\"token variable\">`</span></span> 代表块设备\n<span class=\"token variable\"><span class=\"token variable\">`</span>n<span class=\"token variable\">`</span></span> 代表网络设备\n<span class=\"token variable\"><span class=\"token variable\">`</span>r<span class=\"token variable\">`</span></span> 可写\n<span class=\"token variable\"><span class=\"token variable\">`</span>w<span class=\"token variable\">`</span></span> 可写\n<span class=\"token variable\"><span class=\"token variable\">`</span>x<span class=\"token variable\">`</span></span> 可执行\n文件owner,和对象组</code></pre>\n</li>\n<li><p>设置默认文件权限<br>设置<code>umask</code>的值,默认文件权限等于文件最大权限，减去<code>umask</code>值，第一位代表了一项特别的安全特性，叫作粘着位（sticky bit）<br>rwx &#x3D; 4 + 2 + 1 &#x3D; 7, rw &#x3D; 4 + 2 &#x3D; 6, rx &#x3D; 4 +1 &#x3D; 5.</p>\n</li>\n</ul>\n<h2 id=\"7-4-改变安全性设置\"><a href=\"#7-4-改变安全性设置\" class=\"headerlink\" title=\"7.4 改变安全性设置\"></a>7.4 改变安全性设置</h2><ul>\n<li><p>chmod 改文件权限，如果使用的符号模式设置就是<code>u</code>代表用户，<code>g</code>代表组，<code>o</code>代表其他，<code>a</code>代表所有，<code>+</code>代表增加权限，<code>-</code>代表移除权限，<code>=</code>将权限设置成后面的值，额外的第三作用符号如下</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\"><span class=\"token variable\">`</span>X<span class=\"token variable\">`</span></span> ：如果对象是目录或者它已有执行权限，赋予执行权限。\n<span class=\"token variable\"><span class=\"token variable\">`</span>s<span class=\"token variable\">`</span></span> ：运行时重新设置<span class=\"token environment constant\">UID</span>或GID。\n<span class=\"token variable\"><span class=\"token variable\">`</span>t<span class=\"token variable\">`</span></span> ：保留文件或目录。\n<span class=\"token variable\"><span class=\"token variable\">`</span>u<span class=\"token variable\">`</span></span> ：将权限设置为跟属主一样。\n<span class=\"token variable\"><span class=\"token variable\">`</span>g<span class=\"token variable\">`</span></span> ：将权限设置为跟属组一样。\n<span class=\"token variable\"><span class=\"token variable\">`</span>o<span class=\"token variable\">`</span></span> ：将权限设置为跟其他用户一样</code></pre>\n</li>\n<li><p>chown 改文件所属<br><code>chown option owner file[.group] file</code><br><code>chown owner.group file</code>直接改属主和组<br><code>chown owner .</code> 属主和组都同名<br><code>chgrp</code> 更改文件目录的默认属组</p>\n</li>\n</ul>\n<h2 id=\"7-5-共享文件\"><a href=\"#7-5-共享文件\" class=\"headerlink\" title=\"7.5 共享文件\"></a>7.5 共享文件</h2><p>Linux还为每个文件和目录存储了3个额外的信息位。</p>\n<ul>\n<li>设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。</li>\n<li>设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。</li>\n<li>粘着位：进程结束后文件还驻留（粘着）在内存中。<br>如果你用的是八进制模式，你需要知道这些位的位置</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>二进制值</th>\n<th>八进制值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>000</td>\n<td>0</td>\n<td>所有位都清零</td>\n</tr>\n<tr>\n<td>001</td>\n<td>1</td>\n<td>粘着位置位</td>\n</tr>\n<tr>\n<td>010</td>\n<td>2</td>\n<td>SGID位置位</td>\n</tr>\n<tr>\n<td>011</td>\n<td>3</td>\n<td>SGID位和粘着位都置位</td>\n</tr>\n<tr>\n<td>100</td>\n<td>4</td>\n<td>SUID位置位</td>\n</tr>\n<tr>\n<td>101</td>\n<td>5</td>\n<td>SUID位和粘着位都置位</td>\n</tr>\n<tr>\n<td>110</td>\n<td>6</td>\n<td>SUID位和SGID位都置位</td>\n</tr>\n<tr>\n<td>111</td>\n<td>7</td>\n<td>所有位都置位</td>\n</tr>\n</tbody></table>\n<p>首先，用 <code>mkdir</code> 命令来创建希望共享的目录。然后通过 <code>chgrp</code> 命令将目录的默认属组改为包<br>含所有需要共享文件的用户的组（你必须是该组的成员）。最后，将目录的SGID位置位，以保证<br>目录中新建文件都用shared作为默认属组  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">mkdir</span> testdir\n$ <span class=\"token function\">ls</span> -l\ndrwxrwxr-x <span class=\"token number\">2</span> rich rich <span class=\"token number\">4096</span> Sep <span class=\"token number\">20</span> <span class=\"token number\">23</span>:12 testdir/\n$ <span class=\"token function\">chgrp</span> shared testdir\n$ <span class=\"token function\">chmod</span> g+s testdir  // <span class=\"token function\">chmod</span> <span class=\"token number\">6770</span> testdir\n$ <span class=\"token function\">ls</span> -l\ndrwxrwsr-x <span class=\"token number\">2</span> rich shared <span class=\"token number\">4096</span> Sep <span class=\"token number\">20</span> <span class=\"token number\">23</span>:12 testdir/\n$ <span class=\"token builtin class-name\">umask</span> 002\n$ <span class=\"token builtin class-name\">cd</span> testdir\n$ <span class=\"token function\">touch</span> testfile\n$ <span class=\"token function\">ls</span> -l\ntotal <span class=\"token number\">0</span>\n-rw-rw-r-- <span class=\"token number\">1</span> rich shared <span class=\"token number\">0</span> Sep <span class=\"token number\">20</span> <span class=\"token number\">23</span>:13 testfile\n</code></pre>\n\n<h1 id=\"9-安装软件程序\"><a href=\"#9-安装软件程序\" class=\"headerlink\" title=\"9. 安装软件程序\"></a>9. 安装软件程序</h1><h2 id=\"9-1-包管理工具\"><a href=\"#9-1-包管理工具\" class=\"headerlink\" title=\"9.1 包管理工具\"></a>9.1 包管理工具</h2><p>管理版本</p>\n<h2 id=\"9-2-基于Debian的系统\"><a href=\"#9-2-基于Debian的系统\" class=\"headerlink\" title=\"9.2 基于Debian的系统\"></a>9.2 基于Debian的系统</h2><p>基于 Debian 的系统</p>\n<ul>\n<li>dpkg 包管理工具</li>\n<li>apt</li>\n<li>apt-get</li>\n<li>aptitude</li>\n</ul>\n<h3 id=\"9-2-1-用aptitude-管理软件包\"><a href=\"#9-2-1-用aptitude-管理软件包\" class=\"headerlink\" title=\"9.2.1 用aptitude 管理软件包\"></a>9.2.1 用aptitude 管理软件包</h3><p><code>apt</code>,<code>dpkg</code>是包管理工具，<code>aptitude</code>是完整的软件包管理系统</p>\n<ol>\n<li>aptitude show wine  显示包wine的详细信息</li>\n<li>aptitude install package_name</li>\n<li>aptitude search package_name<br> 如果看到一个 <code>i</code> ，说明这个包现在已经安装到了你的系统上了。如果看到一个 <code>p</code> 或 <code>v</code> ，说明这个包可用，但还没安装</li>\n<li>aptitude safe-upgrade</li>\n<li>aptitude remove&#x2F;purge package_name</li>\n<li><code>/etc/apt/sources.list</code>前面有deb说明是编译过的，deb-src是源代码，package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。你可以看到诸如main、restricted、universe和partner这样的值</li>\n</ol>\n<p>dpkg -L vim  显示vim的所有安装信息<br>dpkg –search vim</p>\n<h2 id=\"9-3-基于源码安装\"><a href=\"#9-3-基于源码安装\" class=\"headerlink\" title=\"9.3 基于源码安装\"></a>9.3 基于源码安装</h2><p>C++编译要使用CMake</p>\n<h1 id=\"10-使用编辑器\"><a href=\"#10-使用编辑器\" class=\"headerlink\" title=\"10. 使用编辑器\"></a>10. 使用编辑器</h1><h2 id=\"10-1-vim-编辑器\"><a href=\"#10-1-vim-编辑器\" class=\"headerlink\" title=\"10.1 vim 编辑器\"></a>10.1 vim 编辑器</h2><ol>\n<li><p>移动光标</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">文件很大,用方向键移动\ngg 移动到最后一行\nnum G 移动到指定行数\nG 移动到第一行\nw file_name 将文件保存到另一个文件中\nPagedown + Pageup 翻页\nw file_name 保存为另一个文件\n</code></pre>\n</li>\n<li><p>编辑数据</p>\n<pre class=\"language-none\"><code class=\"language-none\">\nx 删除光标当前所在字符(剪切)\ndd 是切除当前行, p 是粘贴(剪切)\ndw 删除光标当前所在当前字符(剪切)\nyw 复制一个单词  y$复制整个行\nu 撤销\na 在文件尾追加数据\nA 在当前行尾追加数据\nr char 用char 替换当前光标位置字符\nR char 用text文本替换当前文本字符\n</code></pre></li>\n<li><p>替换数据</p>\n  <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">:s/old/new/  替换数据\n:s/olr/new/g  替换文件中一行所有old\n:m,ns/old/new/g 替换行号之间的所有old\n<span class=\"token builtin class-name\">:</span><span class=\"token variable\">$s</span>/old/new/g 替换整个文件中的old\n<span class=\"token builtin class-name\">:</span><span class=\"token variable\">$s</span>/old/new/gc 替换整个文件中的old，但是每次都提醒</code></pre></li>\n</ol>\n<h1 id=\"11-基本脚本\"><a href=\"#11-基本脚本\" class=\"headerlink\" title=\"11.基本脚本\"></a>11.基本脚本</h1><ul>\n<li><p>创建shell脚本<br><code>#!/bin/bash</code>,bash找你的文件都是从path目录下，如果没有设置path目录那么就需要通过绝对路径和相对路径引用你的命令。然后是注意你的文件权限<code>umask</code>决定了你文件创建时候的默认权限</p>\n</li>\n<li><p>文本信息<br>echo可使用单引号和双引号来划定文本字符串</p>\n<ol>\n<li><code>echo  &quot;This is a test to see if you&#39;re paying attention&quot;</code>  文本中有单引号</li>\n<li><code>echo  &#39;Rich says &quot;scripting is easy&quot;.&#39;</code> 文本中有双引号</li>\n<li>如果是单&#x2F;双引号混合会怎样？</li>\n<li>文本字符串和命令输出到同一行</li>\n</ol>\n</li>\n<li><p>使用变量</p>\n<ol>\n<li>用户变量区分大小写长度不超过20个字符</li>\n<li>变量,等号,值之间不能出现空格</li>\n<li>引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符.没有美元符号引用变量进行赋值shell就会将其理解为字符串</li>\n<li>命令替换分为<code>$()</code>和` `,testing&#x3D;$(date)他们中间没有空格.命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的.在命令行提示符下使用路径.&#x2F;运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。在命令行提示符下运行脚本时一定要留心！</li>\n<li></li>\n</ol>\n</li>\n<li><p>输入输出重定向</p>\n<ul>\n<li><code>&gt;</code>会覆盖,<code>&gt;&gt;</code>追加</li>\n<li><code>wc &lt; test6</code> 输入重定向,内联重定向<code>&lt;&lt;</code>,在命令行上使用内联输入重定向时,shell会用PS2环境变量中定义的次提示符（参见第6章）</li>\n<li>管道，Linux管道命令（断条符号）允许你将命令的输出直接重定向到另一个命令的输入。【这里的问题还很多】</li>\n</ul>\n</li>\n<li><p>执行数学计算</p>\n<ol>\n<li><code>expr</code>命令,特别注意<code>expr 1+5</code>这种是不起作用的(建议以后少用)</li>\n<li><code>$[ ]</code>对<code>expr</code>的改进,bash shell数学运算符只支持整数运算,<code>zsh</code>支持浮点运算</li>\n<li><code>bc</code>计算器<ul>\n<li><p><code>scale=4</code> 保留四位精度，<code>3.44 / 5 = .6880</code>, 支持定义变量</p>\n</li>\n<li><p>在脚本中使用<code>bc</code>,<code>variable=$(echo &quot;scale=4 ;3.44 / 5&quot; | bc)</code>,<code>var3=$(echo &quot;scale=4; $var1 / $var2&quot; | bc)</code>这里的var1和var2都是预定义的</p>\n</li>\n<li><p>将表达式定义到一个文件中，或者内联表达式</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">10.46</span> \n<span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span><span class=\"token number\">43.67</span> \n<span class=\"token assign-left variable\">var3</span><span class=\"token operator\">=</span><span class=\"token number\">33.2</span> \n<span class=\"token assign-left variable\">var4</span><span class=\"token operator\">=</span><span class=\"token number\">71</span> \n<span class=\"token assign-left variable\">var5</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">bc</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOF \nscale = 4 \na1 = ( <span class=\"token variable\">$var1</span> * <span class=\"token variable\">$var2</span>) \nb1 = (<span class=\"token variable\">$var3</span> * <span class=\"token variable\">$var4</span>) \na1 + b1 \nEOF</span> \n<span class=\"token variable\">)</span></span>\n\n<span class=\"token builtin class-name\">echo</span> The final answer <span class=\"token keyword\">for</span> this mess is <span class=\"token variable\">$var5</span></code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>退出脚本</p>\n<ol>\n<li><code>0</code>成功结束，<code>1</code>一般未知错误，<code>2</code>不适合的shell命令，<code>126</code>命令不可执行,<code>127</code>没找到命令，<code>128</code>无效退出参数，<code>128+x</code>与linux信号x相关的严重错误，<code>130</code>通过ctrl+退出，<code>255</code>正常范围之外的退出状态码</li>\n<li><code>exit</code>退出命令，可以自定义状态码，退出状态码最大只能是255，所以超过255会进行模运算</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"12-使用结构化命令\"><a href=\"#12-使用结构化命令\" class=\"headerlink\" title=\"12. 使用结构化命令\"></a>12. 使用结构化命令</h1><ul>\n<li><p>if statement</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">## style 1</span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">pwd</span>\n<span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it works\"</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">## style 2</span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">pwd</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it works\"</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token comment\"># style 3 </span>\n<span class=\"token comment\">## 如果grep返回0 就去执行echo statement</span>\n<span class=\"token keyword\">if</span> <span class=\"token function\">grep</span> <span class=\"token variable\">$testuser</span> /etc/passwd\n<span class=\"token keyword\">then</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"this is my first command\"</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"this is my second command\"</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">## if elif else  ,在elif语句中，紧跟其后的else语句属于elif代码块。它们并不属于之前的if-then代码块 </span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">pwd</span> \n<span class=\"token keyword\">then</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">else</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">elif</span> <span class=\"token builtin class-name\">command</span>  <span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">else</span>  <span class=\"token keyword\">fi</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span>\n<span class=\"token keyword\">fi</span>\n</code></pre>\n</li>\n<li><p>test命令</p>\n<p>如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。支持符合条件检查</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">## 单一逻辑校验</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> condition <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n  commands\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">## 符合逻辑校验</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> condition1 <span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span> condition2 <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> condition <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n  commands\n<span class=\"token keyword\">fi</span></code></pre>\n\n<ul>\n<li><p>数值比较</p>\n<ul>\n<li>n1 -eq n2   等于</li>\n<li>n1 -ge n2   大于等于</li>\n<li>n1 -gt n2   大于</li>\n<li>n1 -le n2   小于等于</li>\n<li>n1 -lt n2   小于</li>\n</ul>\n</li>\n<li><p>字符串比较</p>\n<ul>\n<li>str1 &#x3D; str2 字面量相等，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内</li>\n<li>str1 !&#x3D; str2 不相等</li>\n<li>str1 &lt; str2   小于. <code>if [ $val1 &gt; $val2 ]</code>直接这样比较字符串会创建一个文件。所以必须要转义<code>if [ $val1 \\&gt; $val2 ]</code>。在比较测试中，大写字母被认为是小于小写字母的。比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果但sort命令恰好相反，本地语言设置（英语），A在a前面</li>\n<li>str1 &gt; str2   大于</li>\n<li>-n str1  判断长度是否为非零</li>\n<li>-z str1  判断长度是否为零</li>\n</ul>\n</li>\n<li><p>文件比较</p>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-d file</td>\n<td>d&#x3D;directory. 检查file是否存在并是一个目录</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>e&#x3D;exist. 检查file是否存在</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>f&#x3D;file. 检查file是否存在并是一个文件</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>r&#x3D;read. 检查file是否存在并可读</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>s&#x3D;检查file 是否存在并非空</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>w&#x3D;write. 检查file是否存在并可写</td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>检查file 是否存在并可执行</td>\n</tr>\n<tr>\n<td>-O file</td>\n<td>O&#x3D;all user 检查file是否存在并属当前用户所有</td>\n</tr>\n<tr>\n<td>-G file</td>\n<td>G&#x3D;group 检查file是否存在并且默认组与当前用户相同</td>\n</tr>\n<tr>\n<td>file1 -nt file2</td>\n<td>检查file1是否比file2新</td>\n</tr>\n<tr>\n<td>file1 -ot file2</td>\n<td>检查file1是否比file2旧</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n<li><p>(( ))和[[ ]]提供高级特性</p>\n<ul>\n<li>(( )) 提供更加方便的数学表达式计算，像其他oop语言一样</li>\n<li>[[ ]] 提供更加方便的字符串处理功能</li>\n</ul>\n</li>\n<li><p><code>case</code>命令</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">case</span> variable <span class=\"token keyword\">in</span> \npattern1 <span class=\"token operator\">|</span> pattern2 <span class=\"token punctuation\">)</span> command1<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\npattern3<span class=\"token punctuation\">)</span> command2<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n*<span class=\"token punctuation\">)</span> command3<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span>\n</code></pre></li>\n</ul>\n<h1 id=\"13-for-循环\"><a href=\"#13-for-循环\" class=\"headerlink\" title=\"13. for 循环\"></a>13. for 循环</h1><h2 id=\"13-1-for命令\"><a href=\"#13-1-for命令\" class=\"headerlink\" title=\"13.1 for命令\"></a>13.1 for命令</h2><ul>\n<li>for 基本语句</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">list</span><span class=\"token operator\">=</span><span class=\"token string\">\"Alabama Alaska Arizona Arkansas Colorado\"</span> \n<span class=\"token assign-left variable\">list</span><span class=\"token operator\">=</span><span class=\"token variable\">$list</span><span class=\"token string\">\" Connecticut\"</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">v</span> <span class=\"token keyword\">in</span> v_list\n<span class=\"token keyword\">do</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<p>v_list如果有单引号，1.用转义字符转义。2.用双引号定义用到的单引号的值。3.如果在单独的数据值中有空格，就必须用双引号将这些值圈起来，可直接拼接值。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">file</span><span class=\"token operator\">=</span><span class=\"token string\">\"path of your file\"</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">state</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">cat</span> $file<span class=\"token variable\">)</span></span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Visit beautiful <span class=\"token variable\">$state</span>\"</span> \n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<p>读取文件内容进行迭代<br>(ubuntu没有IFS环境变量和IFS.OLD)</p>\n<ul>\n<li><p>更改字段分隔符<br>默认分隔符是<code>空格</code>，<code>制表符</code>，<code>换行符</code>环境变量IFS,控制着字段分隔符，有时候想灵活一点,有些地方用的换行符，但是其他地方继续保留原先的分隔符，可使用IFS&#x3D;$’\\n’, IFS.OLD&#x3D;$IFS,IFS&#x3D;$’\\n’,但是如果想加入冒号作为换行符可以更改<code>/etc/passwd</code>文件加上IFS&#x3D;:,如果想加多个可以依次在后面加IFS&#x3D;’\\n’:;”</p>\n</li>\n<li><p>通配符</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#!bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> /home/rich/test/* \n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -d <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span> \n  <span class=\"token keyword\">then</span> \n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a directory\"</span> \n  <span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> -f <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span> \n  <span class=\"token keyword\">then</span> \n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a file\"</span> \n  <span class=\"token keyword\">fi</span> \n<span class=\"token keyword\">done</span>\n<span class=\"token comment\">## 目录文件都会匹配</span>\n<span class=\"token comment\">##请注意这次条件判断有些特别使用了if [ -d \"$file\" ] 因为在linux中文件名有空格是合法的</span>\n</code></pre></li>\n</ul>\n<h2 id=\"13-2-C语言风格\"><a href=\"#13-2-C语言风格\" class=\"headerlink\" title=\"13.2 C语言风格\"></a>13.2 C语言风格</h2><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>b<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>a<span class=\"token operator\">&lt;=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>a<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span>b<span class=\"token operator\">--</span><span class=\"token punctuation\">))</span></span>\n<span class=\"token keyword\">do</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<h2 id=\"13-3-while语句\"><a href=\"#13-3-while语句\" class=\"headerlink\" title=\"13.3 while语句\"></a>13.3 while语句</h2><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> <span class=\"token boolean\">true</span>\n<span class=\"token keyword\">do</span>\n  <span class=\"token builtin class-name\">echo</span>\n\n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<p><code>break</code> 还可以指定跳出循环层数,两层<code>for</code>就跳出最内层,<code>break n</code>就会跳出.<br><code>continue</code>结束本次循环，n为1，表明跳出的是当前的循环。如果你将n设为2，break命令就会停止下一级的外部循环  </p>\n<ul>\n<li><p>处理循环中的输出</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> /home/rich/* \n<span class=\"token keyword\">do</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -d <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a directory\"</span> \n<span class=\"token keyword\">elif</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a file\"</span>  \n<span class=\"token keyword\">fi</span> \n<span class=\"token keyword\">done</span> <span class=\"token operator\">></span> output.txt</code></pre>\n</li>\n<li><p>处理多个测试命令</p>\n<p>这种情况下要注意，判断了所有条件，因为有一个条件返回为false，所以相当于逻辑<code>与</code>判断</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># testing a multicommand while loop </span>\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">10</span> \n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var1</span> \n        <span class=\"token punctuation\">[</span> <span class=\"token variable\">$var1</span> -ge <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is inside the loop\"</span> \n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$var1</span> - <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n</code></pre></li>\n</ul>\n<p>while 或者for的嵌套循环中，内部循环可以读到外部变量</p>\n<h2 id=\"13-4-until命令\"><a href=\"#13-4-until命令\" class=\"headerlink\" title=\"13.4 until命令\"></a>13.4 until命令</h2><p>有点像其他语言的<br>do …. while 语法</p>\n<h2 id=\"13-5-循环处理数据并以特定分隔符分割数据\"><a href=\"#13-5-循环处理数据并以特定分隔符分割数据\" class=\"headerlink\" title=\"13.5 循环处理数据并以特定分隔符分割数据\"></a>13.5 循环处理数据并以特定分隔符分割数据</h2><p>主要是修改IFS变量</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># changing the IFS value </span>\n<span class=\"token environment constant\">IFS</span>.OLD<span class=\"token operator\">=</span><span class=\"token environment constant\">$IFS</span> \n<span class=\"token assign-left variable\"><span class=\"token environment constant\">IFS</span></span><span class=\"token operator\">=</span><span class=\"token string\">'\\n'</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">entry</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">cat</span> /etc/passwd<span class=\"token variable\">)</span></span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Values in <span class=\"token variable\">$entry</span> –\"</span> \n <span class=\"token assign-left variable\"><span class=\"token environment constant\">IFS</span></span><span class=\"token operator\">=</span><span class=\"token string\">':'</span>\n  <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">value</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$entry</span> \n  <span class=\"token keyword\">do</span> \n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\" <span class=\"token variable\">$value</span>\"</span> \n  <span class=\"token keyword\">done</span> \n<span class=\"token keyword\">done</span> </code></pre>\n\n<h1 id=\"14-处理用户输入\"><a href=\"#14-处理用户输入\" class=\"headerlink\" title=\"14. 处理用户输入\"></a>14. 处理用户输入</h1><h2 id=\"14-1-读取参数，脚本名和测试参数\"><a href=\"#14-1-读取参数，脚本名和测试参数\" class=\"headerlink\" title=\"14.1 读取参数，脚本名和测试参数\"></a>14.1 读取参数，脚本名和测试参数</h2><ul>\n<li><p>.&#x2F;sumAB.sh  a  b  ## 这里$0是程序名, <code>$1</code>是a, <code>$2</code>是b. 超过九个就一定要花括号引用变量比如<code>$&#123;10&#125;</code>，<code>$#</code>返回参数个数， <code>$&#123;!#&#125;</code>获取最后一个参数，如果没有参数就会输出脚本名，<code>$*</code>变量会将所有参数当成单个参数,<code>$@</code>变量会组成数组，轻松访问所有的参数.</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span>\n<span class=\"token keyword\">do</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\\<span class=\"token variable\">$@</span> Parameter #<span class=\"token variable\">$count</span> = <span class=\"token variable\">$param</span>\"</span> \n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> </code></pre>\n</li>\n<li><p>如果程序名是<code>./test.sh</code>,那么echo $0 就是<code>./test.sh</code></p>\n</li>\n<li><p>如果程序名是<code>bash  /usr/lib/test.sh</code>,那么echo $0 就是<code>/usr/lib/test.sh</code></p>\n</li>\n<li><p>定义了参数位置，如果不传参会报错</p>\n</li>\n<li><p><code>name=$(basename $0)</code> 可以只返回脚本名</p>\n</li>\n<li><p><code>if [ -n &quot;$1&quot; ]</code>是指<code>$1</code>不为空</p>\n</li>\n<li><p><code>shift</code>命令会移动命令参数,<code>shift n</code>可以指定跳过<code>n</code>参数.</p>\n</li>\n</ul>\n<h2 id=\"14-2-处理选项\"><a href=\"#14-2-处理选项\" class=\"headerlink\" title=\"14.2 处理选项\"></a>14.2 处理选项</h2><p>bash命令提供了<code>选项</code>和<code>参数</code>来控制,可以通过<code>shift</code>命令来控制</p>\n<ul>\n<li><p>处理简单的选项</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># extracting command line options as parameters </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> -n <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n<span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span> \n  -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  -b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">esac</span>\n<span class=\"token builtin class-name\">shift</span> \n<span class=\"token keyword\">done</span> \n$ ./test15.sh -a -b -c -d</code></pre>\n</li>\n<li><p>分离选项和参数</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># extracting options and parameters </span>\n<span class=\"token builtin class-name\">echo</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> -n <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span> \n    -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    -b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    --<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">shift</span> \n              <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">esac</span> \n<span class=\"token builtin class-name\">shift</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$@</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Parameter #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$param</span>\"</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n$ ./test16.sh -c -a -b -- test1 test2 test3</code></pre>\n</li>\n<li><p>处理带值的选项</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># extracting command line options and values </span>\n<span class=\"token builtin class-name\">echo</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> -n <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span> \n    -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    -b<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">param</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$2</span>\"</span> \n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option, with parameter value <span class=\"token variable\">$param</span>\"</span> \n    <span class=\"token builtin class-name\">shift</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    --<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">shift</span> \n    <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">esac</span> \n  <span class=\"token builtin class-name\">shift</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Parameter #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$param</span>\"</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n$ ./test17.sh -a -b test1 -d</code></pre>\n\n<p>case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是$1，额外的参数值就应该位于$2（因为所有的参数在处理完之后都会被移出）。只要将参数值从$2变量中提取出来就可以了</p>\n</li>\n<li><p>使用getopt与getopts命令<br>getopts命令会用到两个环境变量。如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。<br>OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。<br>这样你就能在处理完选项之后继续处理其他命令行参数了。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># simple demonstration of the getopts command </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> \n  <span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">getopts</span> :ab:c opt \n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$opt</span>\"</span> <span class=\"token keyword\">in</span> \n  a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option, with value <span class=\"token variable\">$OPTARG</span>\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Unknown option: <span class=\"token variable\">$opt</span>\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">esac</span> \n<span class=\"token keyword\">done</span>\n$ <span class=\"token function\">bash</span> ./test19.sh -a -b <span class=\"token string\">\"1 2\"</span> -c  <span class=\"token comment\"># 在参数中加空格</span>\n$ <span class=\"token function\">bash</span> ./test19.sh -abtest1        <span class=\"token comment\"># 可以挨在一起</span>\n$ <span class=\"token function\">bash</span> ./test19.sh -d              <span class=\"token comment\"># 返回问号</span>\n$ <span class=\"token function\">bash</span> ./test19.sh -a -b <span class=\"token number\">456</span> -cdefg<span class=\"token comment\"># 如果有参数的就要分开写</span></code></pre>\n\n<ul>\n<li>使用OPTIND参数和OPTARG参数</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Processing options &amp; parameters with getopts </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> \n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">getopts</span> :ab:cd opt \n<span class=\"token keyword\">do</span> \n<span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$opt</span>\"</span> <span class=\"token keyword\">in</span> \n  a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option, with value <span class=\"token variable\">$OPTARG</span>\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  d<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -d option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Unknown option: <span class=\"token variable\">$opt</span>\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">esac</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">shift</span> $<span class=\"token punctuation\">[</span> <span class=\"token environment constant\">$OPTIND</span> - <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Parameter <span class=\"token variable\">$count</span>: <span class=\"token variable\">$param</span>\"</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span></code></pre>\n</li>\n<li><p>选项标准化</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>显示所有对象</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>生成一个计数</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>指定一个目录</td>\n</tr>\n<tr>\n<td>-e</td>\n<td>扩展一个对象</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>指定读入数据的文件</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>显示命令的帮助信息</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>忽略文本大小写</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>产生输出的长格式版本</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>使用非交互模式（批处理）</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>将所有输出重定向到的指定的输出文件</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>以安静模式运行</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归地处理目录和文件</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>以安静模式运行</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>生成详细输出</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>排除某个对象</td>\n</tr>\n<tr>\n<td>-y</td>\n<td>对所有问题回答yes</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"14-3-获取用户输入\"><a href=\"#14-3-获取用户输入\" class=\"headerlink\" title=\"14.3 获取用户输入\"></a>14.3 获取用户输入</h2><ul>\n<li><p><code>read</code>命令，</p>\n<ul>\n<li>read命令包含了-p选项，允许你直接在read命令行指定提示符,</li>\n<li>read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量</li>\n<li><code>-t</code>代表超时</li>\n<li><code>-n 1</code>read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量</li>\n<li><code>-s</code> 选项可以避免在read命令中输入的数据出现在显示器上</li>\n<li>从文件中读取数据</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">//单个变量\n<span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"please enter your age\"</span> age\n//多个变量\n<span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"please enter your name\"</span> first last\n// 超时参数\n<span class=\"token builtin class-name\">read</span> -t <span class=\"token number\">5</span> -p \n// 获取指定字符个数\n<span class=\"token builtin class-name\">read</span> -n1  -p <span class=\"token string\">\"Do you want to continue [Y/N]?\"</span> answer\n//隐藏输入\n<span class=\"token builtin class-name\">read</span> -s -p <span class=\"token string\">\"Enter your password: \"</span> pass \n// 从文件中读取数据\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># reading data from a file </span>\n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token function\">cat</span> <span class=\"token builtin class-name\">test</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line \n<span class=\"token keyword\">do</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line <span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Finished processing the file\"</span> </code></pre></li>\n</ul>\n<h1 id=\"15-呈现数据\"><a href=\"#15-呈现数据\" class=\"headerlink\" title=\"15. 呈现数据\"></a>15. 呈现数据</h1><p>这一章主要是讲如何将脚本输出重定型向到系统其他位置</p>\n<h2 id=\"15-1-理解输入和输出\"><a href=\"#15-1-理解输入和输出\" class=\"headerlink\" title=\"15.1 理解输入和输出\"></a>15.1 理解输入和输出</h2><h3 id=\"15-1-1-标准文件描述符\"><a href=\"#15-1-1-标准文件描述符\" class=\"headerlink\" title=\"15.1.1 标准文件描述符\"></a>15.1.1 标准文件描述符</h3><p>Linux系统将每个对象(操作的文件，linux万物皆文件)当作文件处理。这包括输入和输出进程。Linux用文件描述符（filedescriptor）来标识每个文件对象</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">文件描述符  缩 写   描 述\n<span class=\"token number\">0</span>           STDIN   标准输入\n<span class=\"token number\">1</span>           STDOUT  标准输出\n<span class=\"token number\">2</span>           STDERR  标准错误</code></pre>\n\n<ol>\n<li>STDIN实例<br><code>cat</code> 就会从STDIN输入数据，这时候你输入什么屏幕就会显示什么<br><code>cat &lt; file.txt</code>通过STDIN通过重定向符号使<code>cat</code>查看一个非STDIN文件的输入</li>\n<li>STDOUT  </li>\n<li>STDERR<br>shell通过特殊的<code>STDERR</code>文件描述符来处理错误消息。<code>STDERR</code>文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置</li>\n</ol>\n<h3 id=\"15-1-2-重定向错误\"><a href=\"#15-1-2-重定向错误\" class=\"headerlink\" title=\"15.1.2 重定向错误\"></a>15.1.2 重定向错误</h3><ol>\n<li>只重定向错误<br>通过<code>2&gt; file.txt</code>的方式将错误信息重定向到文件中</li>\n<li>重定向错误和数据<br><code>ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</code> 这种就是将<code>STDERR</code>重定向到test6,然后将<code>STDOUT</code>重定向到test7.<br>也可以将STDERR和STDOUT的输出重定向到同一个输出文件使用<code>&amp;&gt;</code>,比如<code>ls -al test test2 test3 badtest &amp;&gt; test7</code>，bash消息赋予error更高的优先级</li>\n</ol>\n<h2 id=\"15-2-在脚本中重定向输出\"><a href=\"#15-2-在脚本中重定向输出\" class=\"headerlink\" title=\"15.2 在脚本中重定向输出\"></a>15.2 在脚本中重定向输出</h2><p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>\n<ul>\n<li>临时重定向行输出</li>\n<li>永久重定向脚本中的所有命令</li>\n</ul>\n<h3 id=\"15-2-1-临时重定向\"><a href=\"#15-2-1-临时重定向\" class=\"headerlink\" title=\"15.2.1 临时重定向\"></a>15.2.1 临时重定向</h3><p>如果使用上文提到的<code>STDERR</code>重定向方法就会将全局的<code>STDERR</code>信息都重定向到文件中，但是如果只重定向自己特定某些error信息就可以使用临时重定向，必须在文件描述符数字之前加一个<code>&amp;</code></p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 举个例子 ./test8</span>\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># testing STDERR messages </span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is an error\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is normal output\"</span> </code></pre>\n\n<p>如果像平常一样运行这个脚本，你可能看不出什么区别,因为所有输出都到了STDOUT,但是默认情况下，linux会将STDERR导向STDOUT,但是，如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ./test8 <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> test9\nThis is normal output \n$ <span class=\"token function\">cat</span> test9 \nThis is an error </code></pre>\n\n<h3 id=\"15-2-2-永久重定向\"><a href=\"#15-2-2-永久重定向\" class=\"headerlink\" title=\"15.2.2 永久重定向\"></a>15.2.2 永久重定向</h3><p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可以用<code>exec</code>命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting all output to a file </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>testout \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is a test of redirecting all output\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"from a script to another file.\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"without having to redirect every individual line\"</span> </code></pre>\n\n<h2 id=\"15-3-在脚本中重定向输入\"><a href=\"#15-3-在脚本中重定向输入\" class=\"headerlink\" title=\"15.3 在脚本中重定向输入\"></a>15.3 在脚本中重定向输入</h2><p><code>exec</code>命令允许你将STDIN重定向到Linux系统上的文件中<code>exec 0&lt; testfile</code></p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># redirecting file input </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> testfile \n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> </code></pre>\n\n<h2 id=\"15-4-创建自己的重定向\"><a href=\"#15-4-创建自己的重定向\" class=\"headerlink\" title=\"15.4 创建自己的重定向\"></a>15.4 创建自己的重定向</h2><h3 id=\"15-4-1-创建输出文件描述符\"><a href=\"#15-4-1-创建输出文件描述符\" class=\"headerlink\" title=\"15.4.1 创建输出文件描述符\"></a>15.4.1 创建输出文件描述符</h3><p>可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件<br>描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。这里有个在脚本中使用其<br>他文件描述符的简单例子。(不是太理解这句话)</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#./test13</span>\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># using an alternative file descriptor </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span>test13out \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This should display on the monitor\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"and this should be stored in the file\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Then this should be back on the monitor\"</span> \n$ ./test13 </code></pre>\n\n<p>这个脚本用exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内<br>容会像预想中那样显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入<br>了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如<br>日志文件）。</p>\n<h3 id=\"15-4-2-重定向文件描述符\"><a href=\"#15-4-2-重定向文件描述符\" class=\"headerlink\" title=\"15.4.2 重定向文件描述符\"></a>15.4.2 重定向文件描述符</h3><p>现在介绍怎么恢复已重定向的文件描述符。你可以分配另外一个文件描述符给标准文件描述<br>符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用<br>该文件描述符重定向回STDOUT。听起来可能有点复杂，但实际上相当直接。这个简单的例子能<br>帮你理清楚。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># ./test14 </span>\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># storing STDOUT, then coming back to it </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>test14out \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This should store in the output file\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"along with this line.\"</span> \n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span><span class=\"token file-descriptor important\">&amp;3</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Now things should be back to normal\"</span> \n$ \n$ ./test14 \nNow things should be back to normal \n$ <span class=\"token function\">cat</span> test14out \nThis should store <span class=\"token keyword\">in</span> the output <span class=\"token function\">file</span> \nalong with this line. \n$ </code></pre>\n\n<p>这个方法可能有点叫人困惑，但这是一种在脚本中临时重定向输出，然后恢复默认输出设置<br>的常用方法。</p>\n<h3 id=\"15-4-3-创建输入文件描述符\"><a href=\"#15-4-3-创建输入文件描述符\" class=\"headerlink\" title=\"15.4.3 创建输入文件描述符\"></a>15.4.3 创建输入文件描述符</h3><p>(不是很懂)<br>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，<br>先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它<br>原来的位置</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># redirecting input file descriptors </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">6</span>&lt;</span><span class=\"token file-descriptor important\">&amp;0</span> \n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> testfile \n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span><span class=\"token file-descriptor important\">&amp;6</span> \n<span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"Are you done now? \"</span> answer \n<span class=\"token keyword\">case</span> <span class=\"token variable\">$answer</span> <span class=\"token keyword\">in</span> \nY<span class=\"token operator\">|</span>y<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Goodbye\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \nN<span class=\"token operator\">|</span>n<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Sorry, this is the end.\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">esac</span>\n</code></pre>\n\n<h3 id=\"15-4-4-创建读写文件描述符\"><a href=\"#15-4-4-创建读写文件描述符\" class=\"headerlink\" title=\"15.4.4 创建读写文件描述符\"></a>15.4.4 创建读写文件描述符</h3><p>（不是太理解）</p>\n<p>尽管看起来可能会很奇怪，但是你也可以打开单个文件描述符来作为输入和输出。可以用同<br>一个文件描述符对同一个文件进行读写。<br>不过用这种方法时，你要特别小心。由于你是对同一个文件进行数据读写，shell会维护一个<br>内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。如果不够小<br>心，它会产生一些令人瞠目的结果。看看下面这个例子。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token comment\">#!/bin/bash </span>\n<span class=\"token comment\"># testing input/output file descriptor </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;></span> testfile \n<span class=\"token builtin class-name\">read</span> line <span class=\"token operator\">&lt;</span><span class=\"token file-descriptor important\">&amp;3</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Read: <span class=\"token variable\">$line</span>\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is a test line\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span> \n$ <span class=\"token function\">cat</span> testfile \nThis is the first line. \nThis is the second line. \nThis is the third line. \n\n<span class=\"token comment\">#输出</span>\n\n$ ./test16 \nRead: This is the first line. </code></pre>\n\n<h3 id=\"15-4-5-关闭文件描述符\"><a href=\"#15-4-5-关闭文件描述符\" class=\"headerlink\" title=\"15.4.5 关闭文件描述符\"></a>15.4.5 关闭文件描述符</h3><p>不懂</p>\n<h2 id=\"15-5-列出未关闭的文件描述符\"><a href=\"#15-5-列出未关闭的文件描述符\" class=\"headerlink\" title=\"15.5 列出未关闭的文件描述符\"></a>15.5 列出未关闭的文件描述符</h2><p>你能用的文件描述符只有9个，你可能会觉得这没什么复杂的。但有时要记住哪个文件描述<br>符被重定向到了哪里很难。为了帮助你理清条理，bash shell提供了<code>lsof</code>命令。<code>$$</code>可以读取当前程序运行的的PID,<code>-a</code><br>对其他两个选项的输出做AND运算  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">/usr/sbin/lsof -a -p <span class=\"token variable\">$$</span> -d <span class=\"token number\">0,1</span>,2\n<span class=\"token comment\"># lsof的默认输出</span>\nCOMMAND     正在运行的命令名的前9个字符\nPID         进程的PID \n<span class=\"token environment constant\">USER</span>        进程属主的登录名\nFD          文件描述符号以及访问类型（r代表读，w代表写，u代表读写）\nTYPE        文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）\nDEVICE      设备的设备号（主设备号和从设备号）\nSIZE        如果有的话，表示文件的大小\nNODE        本地文件的节点号\nNAME        文件名</code></pre>\n\n<p>(不是很懂)</p>\n<h2 id=\"15-6-组织命令输出\"><a href=\"#15-6-组织命令输出\" class=\"headerlink\" title=\"15.6 组织命令输出\"></a>15.6 组织命令输出</h2><p>如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这<br>会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。<br>要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名<br>字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。<br>在Linux系统上null文件的标准位置是&#x2F;dev&#x2F;null。你重定向到该位置的任何数据都会被丢掉，<br>不会显示。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token function\">cat</span> /dev/null/ <span class=\"token operator\">></span> test18\n<span class=\"token comment\"># 这时候test18文件就是空的</span>\n</code></pre>\n\n<h2 id=\"15-7-创建临时文件\"><a href=\"#15-7-创建临时文件\" class=\"headerlink\" title=\"15.7 创建临时文件\"></a>15.7 创建临时文件</h2><h3 id=\"15-7-1-创建本地临时文件\"><a href=\"#15-7-1-创建本地临时文件\" class=\"headerlink\" title=\"15.7.1 创建本地临时文件\"></a>15.7.1 创建本地临时文件</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">mktemp   kirk.XXXXXX  <span class=\"token comment\"># 这里面的XXXXXX是必须的</span></code></pre>\n\n<p>这是在本地目录创建临时文件</p>\n<h3 id=\"15-7-2-在-x2F-temp-x2F-创建临时文件\"><a href=\"#15-7-2-在-x2F-temp-x2F-创建临时文件\" class=\"headerlink\" title=\"15.7.2 在&#x2F;temp&#x2F;创建临时文件\"></a>15.7.2 在&#x2F;temp&#x2F;创建临时文件</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">mktemp -t kirk.XXXXXX</code></pre>\n\n<p>在&#x2F;temp&#x2F;目录下创建了一个临时文件夹</p>\n<h3 id=\"15-7-3-创建临时目录\"><a href=\"#15-7-3-创建临时目录\" class=\"headerlink\" title=\"15.7.3 创建临时目录\"></a>15.7.3 创建临时目录</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">mktemp -d kirk.XXXXXX</code></pre>\n\n<p>在&#x2F;temp&#x2F;目录下创建文件夹</p>\n<h2 id=\"15-8-记录消息\"><a href=\"#15-8-记录消息\" class=\"headerlink\" title=\"15.8 记录消息\"></a>15.8 记录消息</h2><p>有时候想把STDOUT输出到指定文件，又想输出到屏幕上，可以考虑使用<code>tee</code>命令,但是tee命令会覆盖以前的内容<br>但是如果你想把输出追加到文件中需要使用<code>-a</code>选项</p>\n<h2 id=\"15-9-实战\"><a href=\"#15-9-实战\" class=\"headerlink\" title=\"15.9 实战\"></a>15.9 实战</h2><p>稍后完善</p>\n<h1 id=\"16-控制脚本\"><a href=\"#16-控制脚本\" class=\"headerlink\" title=\"16. 控制脚本\"></a>16. 控制脚本</h1><h2 id=\"16-1-处理信号\"><a href=\"#16-1-处理信号\" class=\"headerlink\" title=\"16.1 处理信号\"></a>16.1 处理信号</h2><p>linux利用信号与运行在系统中的进程进行通信，</p>\n<h3 id=\"16-1-1-重温linux信号\"><a href=\"#16-1-1-重温linux信号\" class=\"headerlink\" title=\"16.1.1 重温linux信号\"></a>16.1.1 重温linux信号</h3><p>linux可以与程序产生30多种信号</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">信 号     值       描 述\n<span class=\"token number\">1</span>         SIGHUP  挂起进程\n<span class=\"token number\">2</span>         SIGINT  终止进程\n<span class=\"token number\">3</span>         SIGQUIT 停止进程\n<span class=\"token number\">9</span>         SIGKILL 无条件终止进程\n<span class=\"token number\">15</span>        SIGTERM 尽可能终止进程\n<span class=\"token number\">17</span>        SIGSTOP 无条件停止进程，但不是终止进程\n<span class=\"token number\">18</span>        SIGTSTP 停止或暂停进程，但不终止进程\n<span class=\"token number\">19</span>        SIGCONT 继续运行停止的进程</code></pre>\n\n<p>默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，<br>交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。<br>如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退<br>出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。</p>\n<h3 id=\"16-1-2-生成信号\"><a href=\"#16-1-2-生成信号\" class=\"headerlink\" title=\"16.1.2 生成信号\"></a>16.1.2 生成信号</h3><ol>\n<li>crtl+C 生成SIGINT(2)终止进程信号</li>\n<li>crtl+Z 生成SIGTSTP(17)停止shell中运行的任何进程<br>停止shell中运行的任何进程。停止（stopping）进程，跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置<br>继续运行。在16.4节中，你会了解如何重启一个已经停止的进程。可以使用<code>ps -l</code>命令来显示各进程</li>\n</ol>\n<h3 id=\"16-1-3-捕获信号\"><a href=\"#16-1-3-捕获信号\" class=\"headerlink\" title=\"16.1.3 捕获信号\"></a>16.1.3 捕获信号</h3><p>trap命令允许你来指定shell<br>脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再<br>由shell处理，而是交由本地处理。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># Testing signal trapping </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">trap</span> <span class=\"token string\">\"echo ' Sorry! I have trapped Ctrl-C'\"</span> SIGINT \n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> This is a <span class=\"token builtin class-name\">test</span> script \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> -le <span class=\"token number\">10</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Loop #<span class=\"token variable\">$count</span>\"</span> \n <span class=\"token function\">sleep</span> <span class=\"token number\">1</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span></code></pre>\n\n<p>该脚本使用trap命令捕获信号，使我们编写的脚本处理信号而不是shell处理<br>当使用<code>ctrl-C</code>时候，我们脚本的trap命令就会处理这个SIGINT信号</p>\n<h3 id=\"16-1-4-捕获脚本退出\"><a href=\"#16-1-4-捕获脚本退出\" class=\"headerlink\" title=\"16.1.4 捕获脚本退出\"></a>16.1.4 捕获脚本退出</h3><p>除了在shell脚本中捕获退出，你也可以在shell退出时就行捕获，这是shell完成任务时一种执行命令的一种方式，要捕获shell的退出只需要在trap命令后面加上<code>EXIT</code>信号就行.</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token comment\">#!/bin/bash </span>\n<span class=\"token comment\"># Trapping the script exit </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">trap</span> <span class=\"token string\">\"echo Goodbye...\"</span> EXIT \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> -le <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Loop #<span class=\"token variable\">$count</span>\"</span> \n <span class=\"token function\">sleep</span> <span class=\"token number\">1</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\">#1. 脚本正常执行完，然后执行了trap脚本</span>\n<span class=\"token comment\">#2. ctrl-c 命令也会触发退出命令,ctrl-c之后就不会执行剩余代码。</span></code></pre>\n\n<h3 id=\"16-1-5-修改或移除捕获\"><a href=\"#16-1-5-修改或移除捕获\" class=\"headerlink\" title=\"16.1.5 修改或移除捕获\"></a>16.1.5 修改或移除捕获</h3><p>捕获或移除这节一句话概括就是设置trap命令的有效期，或者叫生命周期。也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上<br>两个破折号就行了，</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token comment\">#!/bin/bash </span>\n<span class=\"token comment\"># Modifying a set trap </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">trap</span> <span class=\"token string\">\"echo ' Sorry... Ctrl-C is trapped.'\"</span> SIGINT \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> -le <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Loop #<span class=\"token variable\">$count</span>\"</span> \n <span class=\"token function\">sleep</span> <span class=\"token number\">1</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">trap</span> <span class=\"token string\">\"echo ' I modified the trap!'\"</span> SIGINT \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> -le <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Second Loop #<span class=\"token variable\">$count</span>\"</span> \n <span class=\"token function\">sleep</span> <span class=\"token number\">1</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ./test3.sh\nLoop <span class=\"token comment\">#1 </span>\nLoop <span class=\"token comment\">#2 </span>\nLoop <span class=\"token comment\">#3 </span>\n^C Sorry<span class=\"token punctuation\">..</span>. Ctrl-C is trapped. \nLoop <span class=\"token comment\">#4 </span>\nLoop <span class=\"token comment\">#5 </span>\nSecond Loop <span class=\"token comment\">#1 </span>\nSecond Loop <span class=\"token comment\">#2 </span>\n^C I modified the trap<span class=\"token operator\">!</span> \nSecond Loop <span class=\"token comment\">#3 </span>\nSecond Loop <span class=\"token comment\">#4 </span>\nSecond Loop <span class=\"token comment\">#5 </span>\n$\n</code></pre>\n\n<p>也可以在trap命令后使用单破折号来恢复信号的默认行为<br>移除信号捕获后，脚本按照默认行为来处理SIGINT信号，也就是终止脚本运行。但如果信<br>号是在捕获被移除前接收到的，那么脚本会按照原先trap命令中的设置进行处理。<br>在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，<br>脚本会照旧执行trap中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。<br>总结:<br>修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的trap命令进行处理。trap根绝接收到信号会<br>立刻从sleep中唤醒</p>\n<h2 id=\"16-2-以后台模式运行脚本\"><a href=\"#16-2-以后台模式运行脚本\" class=\"headerlink\" title=\"16.2 以后台模式运行脚本\"></a>16.2 以后台模式运行脚本</h2><h3 id=\"16-2-1-后台运行脚本\"><a href=\"#16-2-1-后台运行脚本\" class=\"headerlink\" title=\"16.2.1 后台运行脚本\"></a>16.2.1 后台运行脚本</h3><p>当<code>&amp;</code>符放到命令后时，它会将命令和bash shell分离开来,然后给分配一个<code>调度号</code>和<code>PID号</code>,在后台模式中，<br>进程运行时不会和终端会话上的STDIN、STDOUT以及STDERR关联</p>\n<h3 id=\"16-2-2-运行多个后台作业\"><a href=\"#16-2-2-运行多个后台作业\" class=\"headerlink\" title=\"16.2.2 运行多个后台作业\"></a>16.2.2 运行多个后台作业</h3><p>当我们同时运行多个后台运行程序的时候，然后使用<code>ps</code>命令这时候发现很多进程与<code>pts/0</code>绑定着，如果终端会话退出，那么后台进程也会随之退出</p>\n<h3 id=\"16-2-3-在非控制台下运行程序\"><a href=\"#16-2-3-在非控制台下运行程序\" class=\"headerlink\" title=\"16.2.3 在非控制台下运行程序\"></a>16.2.3 在非控制台下运行程序</h3><p>有时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退<br>出了终端会话。这可以用<code>nohup</code>命令来实现.和普通后台进程一样，shell会给命令分配一个作业号，Linux系统会为其分配一个<code>PID号</code>。区<br>别在于，当你使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号。<br>由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。<br>为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为<br>nohup.out的文件中。<br>当多个命令同时使用nohup命令时候，且同时修改nohup命令的时候，他们会追加到nohup.out命令</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 命令demo</span>\n<span class=\"token function\">nohup</span> ./test1.sh <span class=\"token operator\">&amp;</span></code></pre>\n<h2 id=\"16-4-作业控制\"><a href=\"#16-4-作业控制\" class=\"headerlink\" title=\"16.4 作业控制\"></a>16.4 作业控制</h2><h3 id=\"16-4-1-查看作业\"><a href=\"#16-4-1-查看作业\" class=\"headerlink\" title=\"16.4.1 查看作业\"></a>16.4.1 查看作业</h3><p><code>jobs</code>命令可以查看分配给shell的作业，<code>jobs -l</code>可以查看完整的PID  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">参数  描述\n-l    列出进程的PID以及作业号\n-n    只列出上次shell发出的通知后改变了状态的作业\n-p    只列出作业的PID \n-r    只列出运行中的作业\n-s    只列出已停止的作业\n<span class=\"token comment\">#你可能注意到了jobs命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用</span>\n<span class=\"token comment\">#作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。</span>\n<span class=\"token comment\">#当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加</span>\n<span class=\"token comment\">#号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。</span></code></pre>\n\n<h3 id=\"16-4-2-重启停止的作业\"><a href=\"#16-4-2-重启停止的作业\" class=\"headerlink\" title=\"16.4.2 重启停止的作业\"></a>16.4.2 重启停止的作业</h3><p>在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你<br>当前工作的终端，所以在使用该功能时要小心了。<br>要以后台模式重启一个作业，可用bg命令加上作业号</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>+ Stopped ./test11.sh \n$ <span class=\"token function\">bg</span> <span class=\"token comment\"># 这时候就重启了./test11.sh 作业，以后台模式</span>\n<span class=\"token comment\"># 如果重启多个就是用bg 2</span>\n<span class=\"token comment\"># 要以前台模式重启作业，可用带有作业号的fg命令。</span>\n</code></pre>\n\n<h2 id=\"16-5-调整谦让度\"><a href=\"#16-5-调整谦让度\" class=\"headerlink\" title=\"16.5 调整谦让度\"></a>16.5 调整谦让度</h2><ol>\n<li>在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调<br>度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统<br>中，由shell启动的所有进程的调度优先级默认都是相同的。  </li>\n<li>调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell<br>以优先级0来启动所有进程。<br>最低值20是最高优先级，而最高值19是最低优先级，这太容易记混了。只要记住那句俗<br>语“好人难做”就行了。  </li>\n<li>有时你想要改变一个shell脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他<br>进程过多的处理能力），还是给予它更高的优先级（这样它就能获得更多的处理时间），你都可以<br>通过nice命令做到。</li>\n</ol>\n<h3 id=\"16-5-1-nice-命令\"><a href=\"#16-5-1-nice-命令\" class=\"headerlink\" title=\"16.5.1 nice 命令\"></a>16.5.1 nice 命令</h3><p>nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice<br>的-n命令行来指定新的优先级级别。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">nice</span> -n <span class=\"token number\">10</span> ./test4.sh <span class=\"token operator\">></span> test4.out <span class=\"token operator\">&amp;</span>  <span class=\"token comment\"># 注意，必须将nice命令和要启动的命令放在同一行中。</span></code></pre>\n\n<p>一旦用nice命令设置了优先级，就不可以用nice重新设置优先级</p>\n<h3 id=\"16-5-2-renice-命令\"><a href=\"#16-5-2-renice-命令\" class=\"headerlink\" title=\"16.5.2 renice 命令\"></a>16.5.2 renice 命令</h3><p>有时你想改变系统上已运行命令的优先级。这正是renice命令可以做到的。它允许你指定<br>运行进程的PID来改变它的优先级。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">renice</span> -n <span class=\"token number\">10</span> -p <span class=\"token number\">5055</span> <span class=\"token comment\"># -p应该是指进程</span></code></pre>\n\n<p>renice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一<br>些限制:  </p>\n<ul>\n<li>只能对属于你的进程执行renice；</li>\n<li>只能通过renice降低进程的优先级；</li>\n<li>root用户可以通过renice来任意调整进程的优先级。<br>如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令</li>\n</ul>\n<h2 id=\"16-6-定时运行作业\"><a href=\"#16-6-定时运行作业\" class=\"headerlink\" title=\"16.6 定时运行作业\"></a>16.6 定时运行作业</h2><h3 id=\"16-6-1-用at命令来计划执行作业\"><a href=\"#16-6-1-用at命令来计划执行作业\" class=\"headerlink\" title=\"16.6.1 用at命令来计划执行作业\"></a>16.6.1 用at命令来计划执行作业</h3><ol>\n<li><p>at命令的格式<br> at命令只执行一次，区别于cron</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">at <span class=\"token punctuation\">[</span>-f filename<span class=\"token punctuation\">]</span> <span class=\"token function\">time</span> <span class=\"token comment\"># -f 后面用来指定读取命令</span></code></pre>\n\n<p> time : 参数指定运行时间，如果错过就会在第二天同一时间再运行<br> time能识别多种时间格式</p>\n<ul>\n<li>标准小时和分钟的格式，比如10：15</li>\n<li>AM&#x2F;PM指示符，比如10：15PM</li>\n<li>特定可命名时间，比如now,noon,midnight,或者teatime(4 PM)</li>\n<li>标准日期格式，比如MMDDYY,MM&#x2F;DD&#x2F;YY,DD.MM.YY</li>\n<li>文本日期比如jul 4或Dec 25 加不加年份都可以。</li>\n<li>你也可以指定增量时间<ul>\n<li>当前时间+25 min</li>\n<li>明天10：15 PM</li>\n<li>10：15+7天<br> 通过<code>at</code>命令都会被提交到作业队列，针对不同的优先级存在26种不同的作业队列，使用<br> a-z和A-Z来指代，即使通过at命令提交过作业，也可以通过-q参数指定不同的队列字母<br> 作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的<br> 作业会被提交到a作业队列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>获取作业的输出<br>at命令利用sendemail应用程序发送邮件，这样其实很麻烦，但是可以将输出重定向到STDOUT<br>和STDERR,再如果可以使用<code>-M</code>屏蔽输出</p>\n</li>\n<li><p>列出等待的作业<br>atq命令可以查看系统中哪些作业处于等待状态</p>\n</li>\n<li><p>删除作业<br>atrm删除等待种的作业</p>\n</li>\n</ol>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#demo</span>\natq 命令可以列出作业编号\natrm 作业编号 <span class=\"token comment\"># 只能删除你提交的作业，不能删除其他人的。</span></code></pre>\n\n<h3 id=\"16-6-2-安排需要定期执行的脚本\"><a href=\"#16-6-2-安排需要定期执行的脚本\" class=\"headerlink\" title=\"16.6.2 安排需要定期执行的脚本\"></a>16.6.2 安排需要定期执行的脚本</h3><ol>\n<li><p>cron时间表</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">min hour dayofmonth month dayofweek <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p> 比如你想每天10：15运行一个命令可以使用cron时间表条目</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">min hour dayofmonth  month dayofweek  <span class=\"token builtin class-name\">command</span>\n<span class=\"token number\">15</span>  <span class=\"token number\">10</span>   *           *     *          <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p> 但是如果想在每周一的下午4点15分执行，可写为</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">15</span> <span class=\"token number\">16</span> * * <span class=\"token number\">1</span> <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p> 可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）<br> 或数值（0为周日，6为周六）,dayofmonth表项指定月份中的日期值（1~31）。</p>\n<p> 聪明的读者可能会问如何设置一个在每个月的最后一天执行的命令，因为你无法设置<br> dayofmonth的值来涵盖所有的月份。这个问题困扰着Linux和Unix程序员，也激发了不少解<br> 决办法。常用的方法是加一条使用date命令的if-then语句来检查明天的日期是不是01：</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">00 <span class=\"token number\">12</span> * * * <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> +%d -d tomorrow<span class=\"token variable\">`</span></span> <span class=\"token operator\">=</span> 01 <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p> 它会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。</p>\n<p> 命令必须要指定要运行的脚本名字，或者添加重定向符号<br> cron程序会用提交作业的用户账户运行该脚本。因此，你必须有访问该命令和命令中指定的<br> 输出文件的权限。</p>\n</li>\n<li><p>构建cron时间表<br>可以使用crontab -l来处理cron时间表<br>默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。<br>在添加条目时，crontab命令会启用一个文本编辑器（参见第10章），使用已有的cron时间表作<br>为文件内容（或者是一个空文件，如果时间表不存在的话）。</p>\n</li>\n<li><p>浏览cron目录</p>\n<p> 如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个<br> 基本目录：hourly、daily、monthly和weekly。</p>\n<ul>\n<li>&#x2F;etc&#x2F;cron.daily</li>\n<li>&#x2F;etc&#x2F;cron.hourly</li>\n<li>&#x2F;etc&#x2F;cron.monthly</li>\n<li>&#x2F;etc&#x2F;cron.weekly<br> 因此，如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它</li>\n</ul>\n</li>\n<li><p>anacron程序<br>如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么<br>这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问<br>题，许多Linux发行版还包含了anacron程序。<br>anacron<br>程序只会处理位于cron目录的程序，比如&#x2F;etc&#x2F;cron.monthly。它用时间戳来决定作业<br>是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于&#x2F;var&#x2F;spool&#x2F;anacron。</p>\n</li>\n</ol>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">cat</span> /var/spool/anacron/cron.monthly\n<span class=\"token number\">20150626</span></code></pre>\n\n<p>anacron程序使用自己的时间表（通常位于&#x2F;etc&#x2F;anacrontab）来检查作业目录。<br>anacron时间表的基本格式和cron时间表略有不同：</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">period delay identifier <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p>period条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间<br>戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。<br>command条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的<br>任何脚本。<br>注意，anacron不会运行位于&#x2F;etc&#x2F;cron.hourly的脚本。这是因为anacron程序不会处理执行时间<br>需求小于一天的脚本。<br>identifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误<br>邮件中的作业。</p>\n<h3 id=\"16-6-3-使用新shell启动脚本\"><a href=\"#16-6-3-使用新shell启动脚本\" class=\"headerlink\" title=\"16.6.3 使用新shell启动脚本\"></a>16.6.3 使用新shell启动脚本</h3><p>.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是<br>当你登入bash shell时，另一次是当你启动一个bash shell时。如果你需要一个脚本在两个时刻都得<br>以运行，可以把这个脚本放进该文件中。</p>\n<h1 id=\"17-创建函数\"><a href=\"#17-创建函数\" class=\"headerlink\" title=\"17. 创建函数\"></a>17. 创建函数</h1><h2 id=\"17-1-基本的脚本函数\"><a href=\"#17-1-基本的脚本函数\" class=\"headerlink\" title=\"17.1 基本的脚本函数\"></a>17.1 基本的脚本函数</h2><h3 id=\"17-1-1-创建函数\"><a href=\"#17-1-1-创建函数\" class=\"headerlink\" title=\"17.1.1 创建函数\"></a>17.1.1 创建函数</h3><p>有两种方式定义函数  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> <span class=\"token function-name function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">command</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>另一种更像是高级编程语言定义函数  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function-name function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">command</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h3 id=\"17-1-2-使用函数\"><a href=\"#17-1-2-使用函数\" class=\"headerlink\" title=\"17.1.2 使用函数\"></a>17.1.2 使用函数</h3><p>正常情况就像是其他高级语言一样，但是bash的函数有个特殊情况。如果是重定义了一个旧函数，<br>那么就会覆盖以前的定义,正如下面的例子</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># testing using a duplicate function name </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is the first definition of the function name\"</span> \n<span class=\"token punctuation\">&#125;</span> \nfunc1 \n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is a repeat of the same function name\"</span> \n<span class=\"token punctuation\">&#125;</span> \nfunc1 \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is the end of the script\"</span>\n</code></pre>\n\n<h2 id=\"17-2-返回值\"><a href=\"#17-2-返回值\" class=\"headerlink\" title=\"17.2 返回值\"></a>17.2 返回值</h2><h3 id=\"17-2-1-默认退出状态码\"><a href=\"#17-2-1-默认退出状态码\" class=\"headerlink\" title=\"17.2.1 默认退出状态码\"></a>17.2.1 默认退出状态码</h3><p>即使是在函数中，command1,command2,command3 中的1，2执行错误，3成功了，那么退出<br>状态码也是0.所以说默认退出状态码是很危险的。</p>\n<h3 id=\"17-2-2-使用return命令\"><a href=\"#17-2-2-使用return命令\" class=\"headerlink\" title=\"17.2.2 使用return命令\"></a>17.2.2 使用return命令</h3><p>return的demo如下</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using the return command in a function </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">dbl</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"Enter a value: \"</span> value \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"doubling the value\"</span> \n <span class=\"token builtin class-name\">return</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \ndbl \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new value is <span class=\"token variable\">$?</span>\"</span>\n</code></pre>\n\n<p>dbl函数会将$value的值翻倍，然后返回，有两点要小心</p>\n<ul>\n<li>记住，函数一结束就取返回值</li>\n<li>记住，退出码必须是0~255</li>\n</ul>\n<p>也可以返回字符串和较大的数值，可以看下一节</p>\n<h3 id=\"17-2-3-使用函数输出\"><a href=\"#17-2-3-使用函数输出\" class=\"headerlink\" title=\"17.2.3 使用函数输出\"></a>17.2.3 使用函数输出</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using the echo to return a value </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">dbl</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"Enter a value: \"</span> value \n <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>dbl<span class=\"token variable\">)</span></span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new value is <span class=\"token variable\">$result</span>\"</span>\n\n<span class=\"token comment\">#$ ./test5b</span>\n<span class=\"token comment\">#Enter a value: 200 </span>\n<span class=\"token comment\">#The new value is 400</span></code></pre>\n\n<p>可以看到是将一函数结果执行取值运算得到返回值。<br>通过这种技术，你还可以返回浮点值和字符串值。这使它成为一种获取函数返回值的强<br>大方法。</p>\n<h2 id=\"17-3-在函数中使用变量\"><a href=\"#17-3-在函数中使用变量\" class=\"headerlink\" title=\"17.3 在函数中使用变量\"></a>17.3 在函数中使用变量</h2><h3 id=\"17-3-1-向函数传递参数\"><a href=\"#17-3-1-向函数传递参数\" class=\"headerlink\" title=\"17.3.1 向函数传递参数\"></a>17.3.1 向函数传递参数</h3><p>错误传递参数代码</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># trying to access script parameters inside a function </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">badfunc1</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> -eq <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n <span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>badfunc1<span class=\"token variable\">)</span></span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$value</span>\"</span> \n<span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage: badtest1 a b\"</span> \n<span class=\"token keyword\">fi</span> \n<span class=\"token comment\"># $ ./badtest1</span>\n<span class=\"token comment\"># Usage: badtest1 a b </span>\n<span class=\"token comment\"># $ ./badtest1 10 15 </span>\n<span class=\"token comment\"># ./badtest1: * : syntax error: operand expected (error token is \"* </span>\n<span class=\"token comment\"># \") </span>\n<span class=\"token comment\"># The result is </span>\n<span class=\"token comment\"># 脚本的$1和$2和函数调用的$1,$2变量是不一样的</span></code></pre>\n\n<p>接下来是正确的代码</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># trying to access script parameters inside a function </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func7</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> -eq <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n <span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>func7 $1 $2<span class=\"token variable\">)</span></span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$value</span>\"</span> \n<span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage: badtest1 a b\"</span> \n<span class=\"token keyword\">fi</span> \n<span class=\"token comment\">#$ </span>\n<span class=\"token comment\">#$ ./test7 </span>\n<span class=\"token comment\">#Usage: badtest1 a b </span>\n<span class=\"token comment\">#$ ./test7 10 15 </span>\n<span class=\"token comment\">#The result is 150 </span>\n</code></pre>\n\n<p>通过将$1和$2变量传给函数，它们就能跟其他变量一样供函数使用了</p>\n<h3 id=\"17-3-2-在函数中处理变量\"><a href=\"#17-3-2-在函数中处理变量\" class=\"headerlink\" title=\"17.3.2 在函数中处理变量\"></a>17.3.2 在函数中处理变量</h3><ul>\n<li>全局变量<br>全局变量被覆盖</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># demonstrating a bad use of variables </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> + <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> \n<span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token number\">6</span> \nfunc1 \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> -gt <span class=\"token variable\">$value</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is larger\"</span> \n<span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is smaller\"</span> \n<span class=\"token keyword\">fi</span> \n\n<span class=\"token comment\">#$ ./badtest2</span>\n<span class=\"token comment\">#The result is 22 </span>\n<span class=\"token comment\">#temp is larger </span>\n<span class=\"token comment\"># 说明TEMP变量受到了影响，读和写都是改变的全局变量</span></code></pre>\n\n<ul>\n<li>局部变量<br>local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，<br>那么shell将会保持这两个变量的值是分离的</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># demonstrating the local keyword </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> + <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> \n<span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token number\">6</span> \nfunc1 \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> -gt <span class=\"token variable\">$value</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is larger\"</span> \n<span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is smaller\"</span> \n<span class=\"token keyword\">fi</span> \n<span class=\"token comment\">#$ ./test9</span>\n<span class=\"token comment\">#The result is 22 </span>\n<span class=\"token comment\">#temp is smaller </span></code></pre>\n\n<p>if里面的$temp参数是全局的，因为已经在函数外</p>\n<h2 id=\"17-4-数组变量和函数\"><a href=\"#17-4-数组变量和函数\" class=\"headerlink\" title=\"17.4 数组变量和函数\"></a>17.4 数组变量和函数</h2><p>直接传入只会传入数组的第一个值，可考虑如下方法</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># array variable to function test </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">testit</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">local</span> newarray \n <span class=\"token assign-left variable\">newarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token string\">'echo \"$@\"'</span><span class=\"token punctuation\">)</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new array value is: <span class=\"token variable\">$&#123;newarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">myarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The original array is <span class=\"token variable\">$&#123;myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \ntestit <span class=\"token variable\">$&#123;myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span> \n<span class=\"token comment\">#$ </span>\n<span class=\"token comment\">#$ ./test10 </span>\n<span class=\"token comment\">#The original array is 1 2 3 4 5 </span>\n<span class=\"token comment\">#The new array value is: 1 2 3 4 5 </span>\n</code></pre>\n<p>第二种也可以</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># adding values in an array </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">addarray</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> \n <span class=\"token builtin class-name\">local</span> newarray \n <span class=\"token assign-left variable\">newarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">)</span> \n <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">value</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$&#123;newarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span> \n <span class=\"token keyword\">do</span> \n      <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$sum</span> + <span class=\"token variable\">$value</span> <span class=\"token punctuation\">]</span> \n <span class=\"token keyword\">done</span>\n <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$sum</span> \n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token assign-left variable\">myarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The original array is: <span class=\"token variable\">$&#123;myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \n<span class=\"token assign-left variable\">arg1</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">&#123;</span>myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#125;</span><span class=\"token variable\">)</span></span> \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>addarray $arg1<span class=\"token variable\">)</span></span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span> \n\n<span class=\"token comment\">#$ ./test11 </span>\n<span class=\"token comment\">#The original array is: 1 2 3 4 5 </span>\n<span class=\"token comment\">#The result is 15 </span></code></pre>\n\n<h3 id=\"17-4-2-从函数中返回数组\"><a href=\"#17-4-2-从函数中返回数组\" class=\"headerlink\" title=\"17.4.2 从函数中返回数组\"></a>17.4.2 从函数中返回数组</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># returning an array value </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">arraydblr</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">local</span> origarray \n <span class=\"token builtin class-name\">local</span> newarray \n <span class=\"token builtin class-name\">local</span> elements \n <span class=\"token builtin class-name\">local</span> i \n <span class=\"token assign-left variable\">origarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">)</span> \n <span class=\"token assign-left variable\">newarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">)</span> \n <span class=\"token assign-left variable\">elements</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> - <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n <span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> $elements<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">))</span></span> \n <span class=\"token punctuation\">&#123;</span> \n newarray<span class=\"token punctuation\">[</span><span class=\"token variable\">$i</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$&#123;origarray<span class=\"token punctuation\">[</span>$i<span class=\"token punctuation\">]</span>&#125;</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n <span class=\"token punctuation\">&#125;</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$&#123;newarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">myarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The original array is: <span class=\"token variable\">$&#123;myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \n<span class=\"token assign-left variable\">arg1</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">&#123;</span>myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#125;</span><span class=\"token variable\">)</span></span> \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">$(</span>arraydblr $arg1<span class=\"token variable\">)</span></span><span class=\"token punctuation\">)</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new array is: <span class=\"token variable\">$&#123;result<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \n</code></pre>\n<p>arraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来<br>重新生成一个新的数组变量。</p>\n<h2 id=\"17-5-函数递归\"><a href=\"#17-5-函数递归\" class=\"headerlink\" title=\"17.5 函数递归\"></a>17.5 函数递归</h2><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using recursion </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">factorial</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> -eq <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n <span class=\"token keyword\">then</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> \n <span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> - <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>factorial $temp<span class=\"token variable\">)</span></span> \n <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$result</span> * <span class=\"token variable\">$1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">fi</span> \n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"Enter value: \"</span> value \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>factorial $value<span class=\"token variable\">)</span></span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The factorial of <span class=\"token variable\">$value</span> is: <span class=\"token variable\">$result</span>\"</span> \n\n<span class=\"token comment\">#$ ./test13</span>\n<span class=\"token comment\">#Enter value: 5 </span>\n<span class=\"token comment\">#The factorial of 5 is: 120 </span>\n</code></pre>\n\n<h2 id=\"17-6-创建库\"><a href=\"#17-6-创建库\" class=\"headerlink\" title=\"17.6 创建库\"></a>17.6 创建库</h2><p>问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using a library file the wrong way </span>\n./myfuncs \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>addem <span class=\"token number\">10</span> <span class=\"token number\">15</span><span class=\"token variable\">)</span></span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span>\n\n$ ./badtest4 \n./badtest4: addem: <span class=\"token builtin class-name\">command</span> not found \nThe result is </code></pre>\n\n<p>使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是<br>创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p>\n<h2 id=\"17-7-在命令行上使用函数\"><a href=\"#17-7-在命令行上使用函数\" class=\"headerlink\" title=\"17.7 在命令行上使用函数\"></a>17.7 在命令行上使用函数</h2><p>和在shell脚本中将脚本函数当命令使用一样，在命令行界面中你也可以这样做。这个功能很，不错，因为一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数。有几种方法可以实现。</p>\n<h3 id=\"17-7-1-在命令上创建函数\"><a href=\"#17-7-1-在命令上创建函数\" class=\"headerlink\" title=\"17.7.1 在命令上创建函数\"></a>17.7.1 在命令上创建函数</h3><ul>\n<li><p>简单点直接定义 <code>function divem &#123; echo $[ $1 / $2 ]; &#125; </code></p>\n</li>\n<li><p>另一种采用多行式</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token keyword\">function</span> <span class=\"token function-name function\">multem</span> <span class=\"token punctuation\">&#123;</span> \n<span class=\"token operator\">></span> <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token operator\">></span> <span class=\"token punctuation\">&#125;</span> \n$ multem <span class=\"token number\">2</span> <span class=\"token number\">5</span> </code></pre></li>\n</ul>\n<h3 id=\"17-7-2-在-bashrc-文件中定义函数\"><a href=\"#17-7-2-在-bashrc-文件中定义函数\" class=\"headerlink\" title=\"17.7.2 在.bashrc 文件中定义函数\"></a>17.7.2 在.bashrc 文件中定义函数</h3><ol>\n<li><p>直接定义函数</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> .bashrc\n<span class=\"token comment\"># .bashrc </span>\n<span class=\"token comment\"># Source global definitions </span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -r /etc/bashrc <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> \n<span class=\"token builtin class-name\">.</span> /etc/bashrc \n<span class=\"token keyword\">fi</span> \n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">addem</span> <span class=\"token punctuation\">&#123;</span> \n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> </code></pre>\n</li>\n<li><p>读取函数文件<br>直接定义在特地的文件内，然后读取在<code>.bashrc</code>中读取</p>\n</li>\n</ol>\n<h2 id=\"17-8-实例\"><a href=\"#17-8-实例\" class=\"headerlink\" title=\"17.8 实例\"></a>17.8 实例</h2><h3 id=\"17-8-1-下载安装第三方库\"><a href=\"#17-8-1-下载安装第三方库\" class=\"headerlink\" title=\"17.8.1 下载安装第三方库\"></a>17.8.1 下载安装第三方库</h3><h3 id=\"17-8-2-构建库\"><a href=\"#17-8-2-构建库\" class=\"headerlink\" title=\"17.8.2 构建库\"></a>17.8.2 构建库</h3><p>下载，编译，安装。这里面涉及到<code>CMAKE</code>的相关知识</p>\n<h3 id=\"17-8-3-shtool库函数\"><a href=\"#17-8-3-shtool库函数\" class=\"headerlink\" title=\"17.8.3 shtool库函数\"></a>17.8.3 shtool库函数</h3><p>这里就是介绍些shtool提供的一些函数，后面会很有用，但是需要与公司内的环境做适配</p>\n<h3 id=\"17-8-4-使用库\"><a href=\"#17-8-4-使用库\" class=\"headerlink\" title=\"17.8.4 使用库\"></a>17.8.4 使用库</h3><p>编译，安装完后，就可以在脚本中使用了</p>\n<h1 id=\"18-图形化界面中脚本编程\"><a href=\"#18-图形化界面中脚本编程\" class=\"headerlink\" title=\"18. 图形化界面中脚本编程\"></a>18. 图形化界面中脚本编程</h1><p>暂时不需要</p>\n<h1 id=\"19-初识sed和gawk\"><a href=\"#19-初识sed和gawk\" class=\"headerlink\" title=\"19.初识sed和gawk\"></a>19.初识sed和gawk</h1><p>你得熟悉Linux中的sed和gawk工具。这两个工具能够极大简化需要进行的数据处<br>理任务。</p>\n<h2 id=\"19-1-文本处理\"><a href=\"#19-1-文本处理\" class=\"headerlink\" title=\"19.1 文本处理\"></a>19.1 文本处理</h2><h3 id=\"19-1-1-sed编辑器\"><a href=\"#19-1-1-sed编辑器\" class=\"headerlink\" title=\"19.1.1 sed编辑器\"></a>19.1.1 sed编辑器</h3><p>sed编辑器被称作流编辑器（stream editor），和普通的交互式文本编辑器恰好相反。在交互式<br>文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。流编<br>辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。</p>\n<ul>\n<li>一次输入一行</li>\n<li>根据所提供的编辑器命令匹配数据。</li>\n<li>按照命令修改流中数据</li>\n<li>将最后结果输出到STDOUT</li>\n</ul>\n<blockquote>\n<p>sed  options  script  file</p>\n</blockquote>\n<p>echo ‘this is a test’ | sed  ‘s&#x2F;test&#x2F;big test&#x2F;‘  使用s命令将test替换为big test</p>\n<p>sed ‘s&#x2F;dog&#x2F;cat&#x2F;‘  data.txt    这是修改文件中dog为cat<br>sed  -e  ‘s&#x2F;brown&#x2F;red;  s&#x2F;blue&#x2F;yellow&#x2F;‘   data&#x2F;txt</p>\n<p>从文件中读取编辑器命令</p>\n<p>sed -f script.sed  data.txt</p>\n<p>gawk</p>\n<p>option</p>\n<p>-F fs  指定行中划分数据字段的字段分隔符<br>-f file  从指定的文件中读取程序<br>-v var&#x3D;value  定义gawk程序中的一个变量及其默认值<br>-mf N  指定要处理的数据文件中的最大字段数<br>-mr N  指定数据文件中的最大数据行数<br>-W keyword  指定gawk的兼容模式或警告等级</p>\n<ul>\n<li><p>从命令行读取程序脚本<br>gawk ‘{print “Hello World!”}’</p>\n</li>\n<li><p>从文件中读取数据<br>自动为文件每一行数据分配一个变量gawk ‘{print $1}’ data2.txt 数据文件中每一行的第一个字符<br>eg: gawk -F: ‘{print $1}’ &#x2F;etc&#x2F;passwd</p>\n</li>\n<li><p>在程序脚本中使用多个命令</p>\n<p>echo “my name is rich” | gawk ‘{$4&#x3D;”Christine”; print $0}’ , 给第四个字段名赋值，并输出文本名 ，如果不指定文件名就会从标准输入等待输入</p>\n</li>\n<li><p>从文件中读取程序</p>\n<p>command_gawk.gawk        gawk -F: -f  command_gawk.gawk  &#x2F;etc&#x2F;passwd</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">BEGIN <span class=\"token punctuation\">&#123;</span>\nprint <span class=\"token string\">\"The latest list of users and shells\"</span>\nprint <span class=\"token string\">\" UserID <span class=\"token entity\" title=\"\\t\">\\t</span> Shell\"</span>\nprint <span class=\"token string\">\"-------- <span class=\"token entity\" title=\"\\t\">\\t</span> -------\"</span>\n<span class=\"token assign-left variable\">FS</span><span class=\"token operator\">=</span><span class=\"token string\">\":\"</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#123;</span>\nprint <span class=\"token variable\">$NF</span> <span class=\"token string\">\" <span class=\"token entity\" title=\"\\t\">\\t</span> \"</span> <span class=\"token variable\">$7</span>\n<span class=\"token punctuation\">&#125;</span>\nEND <span class=\"token punctuation\">&#123;</span>\nprint <span class=\"token string\">\"This concludes the listing\"</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n</li>\n<li><p>在处理数据前运行脚本</p>\n<p>gawk ‘BEGIN {print “Hello World!”}’</p>\n<p>&gt;{print $0}’ data3.txt</p>\n</li>\n<li><p>处理数据后运行脚本</p>\n</li>\n</ul>\n<h2 id=\"19-2-sed-and-gawk进阶\"><a href=\"#19-2-sed-and-gawk进阶\" class=\"headerlink\" title=\"19.2 sed and gawk进阶\"></a>19.2 sed and gawk进阶</h2><p>替换标记<br>s&#x2F;pattern&#x2F;replacement&#x2F;flags</p>\n<ul>\n<li>数字， 说明新文本将替换第几处的地方</li>\n<li>g，说明文本将替换所有</li>\n<li>p, 原先行要打印</li>\n<li>w file ， 将结果输出到新文件中</li>\n<li>option 位置是 n 说明禁止输出</li>\n</ul>\n<p>替换字符<br>在替换文件路径时候涉及到转义字符这样很影响阅读性</p>\n<p>替换指定行<br>sed ‘2s&#x2F;dog&#x2F;cat&#x2F;‘ data1.txt        这个命令的意思就是将data1.txt替换第二行中的dog，替换成cat<br>sed ‘2,3s&#x2F;dog&#x2F;cat&#x2F;‘ data1.txt    以此类推是第二行，第三行<br>sed ‘2,$s&#x2F;dog&#x2F;cat&#x2F;‘ data1.txt    从第二行开始到最后一行<br>sed ‘&#x2F;Samantha&#x2F;s&#x2F;bash&#x2F;csh&#x2F;‘ &#x2F;etc&#x2F;passwd   推过模式匹配<br>sed ‘3,${<br>  s&#x2F;brown&#x2F;green&#x2F;<br>  s&#x2F;lazy&#x2F;active&#x2F;<br>  }’ data1.txt</p>\n<h1 id=\"20-正则表达式\"><a href=\"#20-正则表达式\" class=\"headerlink\" title=\"20.正则表达式\"></a>20.正则表达式</h1><h2 id=\"20-1-什么是正则表达式\"><a href=\"#20-1-什么是正则表达式\" class=\"headerlink\" title=\"20.1 什么是正则表达式\"></a>20.1 什么是正则表达式</h2><p>正则表达式就是某种模板(筛子)，正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是<br>一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。</p>\n<ul>\n<li>POSIX基础正则表达式（basic regular expression，BRE）引擎</li>\n<li>POSIX扩展正则表达式（extended regular expression，ERE）引擎</li>\n</ul>\n<h2 id=\"20-2-定义BRE模式\"><a href=\"#20-2-定义BRE模式\" class=\"headerlink\" title=\"20.2 定义BRE模式\"></a>20.2 定义BRE模式</h2><h3 id=\"20-2-1-纯文本\"><a href=\"#20-2-1-纯文本\" class=\"headerlink\" title=\"20.2.1. 纯文本\"></a>20.2.1. 纯文本</h3><p><code>echo &quot;This is a test&quot; | sed -n &#39;/this/p&#39;</code> 这里面p是print,少了-n是打印两条，this没匹配到所以没有显示<br>空格也是普通的字符，比如<code>sed -n /  /p data.set</code></p>\n<h3 id=\"20-2-2-特殊字符\"><a href=\"#20-2-2-特殊字符\" class=\"headerlink\" title=\"20.2.2 特殊字符\"></a>20.2.2 特殊字符</h3><p><code>echo &quot;3 / 2&quot; | sed -n &#39;///p&#39;</code> 正斜线也需要转义字符，故正确的是<code>echo &quot;3 / 2&quot; | sed -n &#39;/\\//p&#39;</code></p>\n<h3 id=\"20-2-3-锚定字符\"><a href=\"#20-2-3-锚定字符\" class=\"headerlink\" title=\"20.2.3 锚定字符\"></a>20.2.3 锚定字符</h3><ol>\n<li><p><code>^</code>锚定字符<br>主要是锚定字符串行首。如果模式出现在行首之外的位置则不匹配，如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了<code>echo &quot;This is ^ a test&quot; | sed -n &#39;/s ^/p&#39;</code><br>&#96;&#96;</p>\n</li>\n<li><p><code>$</code>锚定结尾<br>特殊字符美元符<code>$</code>定义了行尾锚点。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。<code>echo &quot;This is a good book&quot; | sed -n &#39;/book$/p&#39;</code></p>\n</li>\n<li><p>组合锚定</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> data4\nthis is a <span class=\"token builtin class-name\">test</span> of using both anchors  <span class=\"token comment\"># 这一行会被忽略</span>\nI said this is a <span class=\"token builtin class-name\">test</span> \nthis is a <span class=\"token builtin class-name\">test</span> \nI<span class=\"token string\">'m sure this is a test. \n$ sed -n '</span>/^this is a test$/p' data4 \nthis is a <span class=\"token builtin class-name\">test</span></code></pre>\n\n<p> 第二种情况</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> data5\nThis is one <span class=\"token builtin class-name\">test</span> line. \nThis is another <span class=\"token builtin class-name\">test</span> line. \n$ <span class=\"token function\">sed</span> <span class=\"token string\">'/^$/d'</span> data5 \nThis is one <span class=\"token builtin class-name\">test</span> line. \nThis is another <span class=\"token builtin class-name\">test</span> line. </code></pre>\n\n<p> 定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行。由于空白行在两个换行符之间没有文本，刚好匹配了正则表达式模式。sed编辑器用删除命令d来删除匹配该正则表达式模式的行，因此删除了文本中的所有空白行。这是从文档中删除空白行的有效方法</p>\n</li>\n</ol>\n<h3 id=\"20-2-4-点字符\"><a href=\"#20-2-4-点字符\" class=\"headerlink\" title=\"20.2.4 点字符\"></a>20.2.4 点字符</h3><p>特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> data6\nThis is a <span class=\"token builtin class-name\">test</span> of a line. \nThe <span class=\"token function\">cat</span> is sleeping. \nThat is a very <span class=\"token function\">nice</span> hat. \nThis <span class=\"token builtin class-name\">test</span> is at line four. \nat ten o<span class=\"token string\">'clock we'</span>ll go home. \n$ <span class=\"token function\">sed</span> -n <span class=\"token string\">'/.at/p'</span> data6 \nThe <span class=\"token function\">cat</span> is sleeping. \nThat is a very <span class=\"token function\">nice</span> hat. \nThis <span class=\"token builtin class-name\">test</span> is at line four. \n</code></pre>\n\n<h3 id=\"20-2-5-字符数组\"><a href=\"#20-2-5-字符数组\" class=\"headerlink\" title=\"20.2.5 字符数组\"></a>20.2.5 字符数组</h3><p>点字符在模糊匹配上很有用，但是你想在某一位置上指定字符范围，那么字符数组就会很有用</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sed</span> -n <span class=\"token string\">'/[ch]at/p'</span> data6\nThe <span class=\"token function\">cat</span> is sleeping. \nThat is a very <span class=\"token function\">nice</span> hat. \n</code></pre>\n\n<h3 id=\"20-2-6-排除型字符\"><a href=\"#20-2-6-排除型字符\" class=\"headerlink\" title=\"20.2.6 排除型字符\"></a>20.2.6 排除型字符</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sed</span> -n <span class=\"token string\">'/[\nch]at/p'</span> data6\nThis <span class=\"token builtin class-name\">test</span> is at line four. </code></pre>\n\n<p>通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字<br>符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at<br>开头的行仍然未能匹配模式</p>\n<h3 id=\"20-2-7-区间\"><a href=\"#20-2-7-区间\" class=\"headerlink\" title=\"20.2.7 区间\"></a>20.2.7 区间</h3><p>想想匹配邮编那个case，实在是太麻烦，我们可以简化为<code>区间</code>表示  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> -n <span class=\"token string\">'/^[0-9][0-9][0-9][0-9][0-9]$/p'</span> data8 </code></pre>\n\n<p>也可以指定多个区间<code>sed -n &#39;/[a-ch-m]at/p&#39; data6</code>,该字符组允许区间a<del>c、h</del>m中的字母出现在at文本前</p>\n<h3 id=\"20-2-8-特殊的字符数组\"><a href=\"#20-2-8-特殊的字符数组\" class=\"headerlink\" title=\"20.2.8 特殊的字符数组\"></a>20.2.8 特殊的字符数组</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#BRE特殊字符组</span>\n组                      描 述\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:alpha:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意字母字符，不管是大写还是小写\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:alnum:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意字母数字字符0~9、A~Z或a~z \n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:blank:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配空格或制表符\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:digit:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配0~9之间的数字\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:lower:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配小写字母字符a~z \n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:print:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意可打印字符\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:punct:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配标点符号    \n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:space:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意空白字符：空格、制表符、NL、FF、VT和CR \n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:upper:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意大写字母字符A~Z </code></pre>\n\n<h3 id=\"20-2-9-星号\"><a href=\"#20-2-9-星号\" class=\"headerlink\" title=\"20.2.9 星号\"></a>20.2.9 星号</h3><p>在字符后面放置<strong>星号</strong>表明该字符必须在匹配模式的文本中出现0次或多次</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"ik\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/ie*k/p'</span>\nik \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"iek\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/ie*k/p'</span> \niek \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"ieek\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/ie*k/p'</span> \nieek \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"ieeek\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/ie*k/p'</span></code></pre>\n\n<p>另一个方便的特性是将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量<br>的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"this is a regular pattern expression\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'\n> /regular.*expression/p'</span> \nthis is a regular pattern expression </code></pre>\n\n<p>星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"bt\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span>\nbt \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"bat\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbat \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"bet\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbet \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"btt\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbtt \n$ \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"baat\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbaat \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"baaeeet\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbaaeeet \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"baeeaeeat\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbaeeaeeat \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"baakeeet\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \n$ </code></pre>\n\n<p>只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。</p>\n<h1 id=\"AppendIndex\"><a href=\"#AppendIndex\" class=\"headerlink\" title=\"AppendIndex\"></a>AppendIndex</h1><ul>\n<li>re-read 意思是重新理解该章节</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"#1-linux%E5%85%A5%E9%97%A8\">1. linux入门</a></li>\n<li><a href=\"#2-%E8%B5%B0%E8%BF%9Bshell\">2. 走进shell</a></li>\n<li><a href=\"#3-%E5%9F%BA%E6%9C%ACshell%E5%91%BD%E4%BB%A4\">3. 基本shell命令</a><ul>\n<li><a href=\"#31-%E5%90%AF%E5%8A%A8shell\">3.1 启动shell</a></li>\n<li><a href=\"#32-bash-%E6%89%8B%E5%86%8C\">3.2 bash 手册</a></li>\n<li><a href=\"#34-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\">3.4 文件系统</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E5%85%B6%E4%BB%96shell%E5%91%BD%E4%BB%A4\">4. 其他shell命令</a><ul>\n<li><a href=\"#41-%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F\">4.1 监控程序</a></li>\n<li><a href=\"#42-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9B%91%E6%8E%A7\">4.2 磁盘空间监控</a></li>\n<li><a href=\"#43-%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6\">4.3 处理文件</a></li>\n<li><a href=\"#44-date%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6%E6%A0%BC%E5%BC%8F%E5%8C%96\">4.4 date命令及其格式化</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E7%90%86%E8%A7%A3shell\">5. 理解shell</a><ul>\n<li><a href=\"#51-shell%E7%9A%84%E7%B1%BB%E5%9E%8B\">5.1 shell的类型</a></li>\n<li><a href=\"#52-shell%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB\">5.2 shell的父子关系</a><ul>\n<li><a href=\"#521-%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8\">5.2.1 进程列表</a></li>\n<li><a href=\"#522-%E5%AD%90shell%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95\">5.2.2 子shell的其他用法</a></li>\n</ul>\n</li>\n<li><a href=\"#53-%E7%90%86%E8%A7%A3shell%E7%9A%84%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4\">5.3 理解shell的内建命令</a><ul>\n<li><a href=\"#531-%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4\">5.3.1 外部命令</a></li>\n<li><a href=\"#532-%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4\">5.3.2 内部命令</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#6-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">6. 环境变量</a></li>\n<li><a href=\"#7-linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90\">7. linux文件权限</a><ul>\n<li><a href=\"#71-linux%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7\">7.1 linux的安全性</a><ul>\n<li><a href=\"#711-%E6%B7%BB%E5%8A%A0linux%E7%94%A8%E6%88%B7\">7.1.1 添加linux用户</a></li>\n<li><a href=\"#712-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7\">7.1.2 删除用户</a></li>\n<li><a href=\"#712-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7\">7.1.2 修改用户</a></li>\n</ul>\n</li>\n<li><a href=\"#72-%E4%BD%BF%E7%94%A8linux%E7%BB%84\">7.2 使用linux组</a></li>\n<li><a href=\"#73-%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90\">7.3 理解文件权限</a></li>\n<li><a href=\"#74-%E6%94%B9%E5%8F%98%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E7%BD%AE\">7.4 改变安全性设置</a></li>\n<li><a href=\"#75-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">7.5 共享文件</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F\">9. 安装软件程序</a><ul>\n<li><a href=\"#91-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\">9.1 包管理工具</a></li>\n<li><a href=\"#92-%E5%9F%BA%E4%BA%8Edebian%E7%9A%84%E7%B3%BB%E7%BB%9F\">9.2 基于Debian的系统</a><ul>\n<li><a href=\"#921-%E7%94%A8aptitude-%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85\">9.2.1 用aptitude 管理软件包</a></li>\n</ul>\n</li>\n<li><a href=\"#93-%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85\">9.3 基于源码安装</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%E4%BD%BF%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8\">10. 使用编辑器</a><ul>\n<li><a href=\"#101-vim-%E7%BC%96%E8%BE%91%E5%99%A8\">10.1 vim 编辑器</a></li>\n</ul>\n</li>\n<li><a href=\"#11%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC\">11.基本脚本</a></li>\n<li><a href=\"#12-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4\">12. 使用结构化命令</a></li>\n<li><a href=\"#13-for-%E5%BE%AA%E7%8E%AF\">13. for 循环</a><ul>\n<li><a href=\"#131-for%E5%91%BD%E4%BB%A4\">13.1 for命令</a></li>\n<li><a href=\"#132-c%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC\">13.2 C语言风格</a></li>\n<li><a href=\"#133-while%E8%AF%AD%E5%8F%A5\">13.3 while语句</a></li>\n<li><a href=\"#134-until%E5%91%BD%E4%BB%A4\">13.4 until命令</a></li>\n<li><a href=\"#135-%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BB%A5%E7%89%B9%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6%E5%88%86%E5%89%B2%E6%95%B0%E6%8D%AE\">13.5 循环处理数据并以特定分隔符分割数据</a></li>\n</ul>\n</li>\n<li><a href=\"#14-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5\">14. 处理用户输入</a><ul>\n<li><a href=\"#141-%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E8%84%9A%E6%9C%AC%E5%90%8D%E5%92%8C%E6%B5%8B%E8%AF%95%E5%8F%82%E6%95%B0\">14.1 读取参数，脚本名和测试参数</a></li>\n<li><a href=\"#142-%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9\">14.2 处理选项</a></li>\n<li><a href=\"#143-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5\">14.3 获取用户输入</a></li>\n</ul>\n</li>\n<li><a href=\"#15-%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE\">15. 呈现数据</a><ul>\n<li><a href=\"#151-%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA\">15.1 理解输入和输出</a><ul>\n<li><a href=\"#1511-%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.1.1 标准文件描述符</a></li>\n<li><a href=\"#1512-%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF\">15.1.2 重定向错误</a></li>\n</ul>\n</li>\n<li><a href=\"#152-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA\">15.2 在脚本中重定向输出</a><ul>\n<li><a href=\"#1521-%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91\">15.2.1 临时重定向</a></li>\n<li><a href=\"#1522-%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91\">15.2.2 永久重定向</a></li>\n</ul>\n</li>\n<li><a href=\"#153-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5\">15.3 在脚本中重定向输入</a></li>\n<li><a href=\"#154-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91\">15.4 创建自己的重定向</a><ul>\n<li><a href=\"#1541-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.1 创建输出文件描述符</a></li>\n<li><a href=\"#1542-%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.2 重定向文件描述符</a></li>\n<li><a href=\"#1543-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.3 创建输入文件描述符</a></li>\n<li><a href=\"#1544-%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.4 创建读写文件描述符</a></li>\n<li><a href=\"#1545-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.4.5 关闭文件描述符</a></li>\n</ul>\n</li>\n<li><a href=\"#155-%E5%88%97%E5%87%BA%E6%9C%AA%E5%85%B3%E9%97%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">15.5 列出未关闭的文件描述符</a></li>\n<li><a href=\"#156-%E7%BB%84%E7%BB%87%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA\">15.6 组织命令输出</a></li>\n<li><a href=\"#157-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6\">15.7 创建临时文件</a><ul>\n<li><a href=\"#1571-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6\">15.7.1 创建本地临时文件</a></li>\n<li><a href=\"#1572-%E5%9C%A8temp%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6\">15.7.2 在&#x2F;temp&#x2F;创建临时文件</a></li>\n<li><a href=\"#1573-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95\">15.7.3 创建临时目录</a></li>\n</ul>\n</li>\n<li><a href=\"#158-%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF\">15.8 记录消息</a></li>\n<li><a href=\"#159-%E5%AE%9E%E6%88%98\">15.9 实战</a></li>\n</ul>\n</li>\n<li><a href=\"#16-%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC\">16. 控制脚本</a><ul>\n<li><a href=\"#161-%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7\">16.1 处理信号</a><ul>\n<li><a href=\"#1611-%E9%87%8D%E6%B8%A9linux%E4%BF%A1%E5%8F%B7\">16.1.1 重温linux信号</a></li>\n<li><a href=\"#1612-%E7%94%9F%E6%88%90%E4%BF%A1%E5%8F%B7\">16.1.2 生成信号</a></li>\n<li><a href=\"#1613-%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7\">16.1.3 捕获信号</a></li>\n<li><a href=\"#1614-%E6%8D%95%E8%8E%B7%E8%84%9A%E6%9C%AC%E9%80%80%E5%87%BA\">16.1.4 捕获脚本退出</a></li>\n<li><a href=\"#1615-%E4%BF%AE%E6%94%B9%E6%88%96%E7%A7%BB%E9%99%A4%E6%8D%95%E8%8E%B7\">16.1.5 修改或移除捕获</a></li>\n</ul>\n</li>\n<li><a href=\"#162-%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC\">16.2 以后台模式运行脚本</a><ul>\n<li><a href=\"#1621-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC\">16.2.1 后台运行脚本</a></li>\n<li><a href=\"#1622-%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%90%8E%E5%8F%B0%E4%BD%9C%E4%B8%9A\">16.2.2 运行多个后台作业</a></li>\n<li><a href=\"#1623-%E5%9C%A8%E9%9D%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F\">16.2.3 在非控制台下运行程序</a></li>\n</ul>\n</li>\n<li><a href=\"#164-%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6\">16.4 作业控制</a><ul>\n<li><a href=\"#1641-%E6%9F%A5%E7%9C%8B%E4%BD%9C%E4%B8%9A\">16.4.1 查看作业</a></li>\n<li><a href=\"#1642-%E9%87%8D%E5%90%AF%E5%81%9C%E6%AD%A2%E7%9A%84%E4%BD%9C%E4%B8%9A\">16.4.2 重启停止的作业</a></li>\n</ul>\n</li>\n<li><a href=\"#165-%E8%B0%83%E6%95%B4%E8%B0%A6%E8%AE%A9%E5%BA%A6\">16.5 调整谦让度</a><ul>\n<li><a href=\"#1651-nice-%E5%91%BD%E4%BB%A4\">16.5.1 nice 命令</a></li>\n<li><a href=\"#1652-renice-%E5%91%BD%E4%BB%A4\">16.5.2 renice 命令</a></li>\n</ul>\n</li>\n<li><a href=\"#166-%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A\">16.6 定时运行作业</a><ul>\n<li><a href=\"#1661-%E7%94%A8at%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%AE%A1%E5%88%92%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A\">16.6.1 用at命令来计划执行作业</a></li>\n<li><a href=\"#1662-%E5%AE%89%E6%8E%92%E9%9C%80%E8%A6%81%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC\">16.6.2 安排需要定期执行的脚本</a></li>\n<li><a href=\"#1663-%E4%BD%BF%E7%94%A8%E6%96%B0shell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC\">16.6.3 使用新shell启动脚本</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#17-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0\">17. 创建函数</a><ul>\n<li><a href=\"#171-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0\">17.1 基本的脚本函数</a><ul>\n<li><a href=\"#1711-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0\">17.1.1 创建函数</a></li>\n<li><a href=\"#1712-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0\">17.1.2 使用函数</a></li>\n</ul>\n</li>\n<li><a href=\"#172-%E8%BF%94%E5%9B%9E%E5%80%BC\">17.2 返回值</a><ul>\n<li><a href=\"#1721-%E9%BB%98%E8%AE%A4%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81\">17.2.1 默认退出状态码</a></li>\n<li><a href=\"#1722-%E4%BD%BF%E7%94%A8return%E5%91%BD%E4%BB%A4\">17.2.2 使用return命令</a></li>\n<li><a href=\"#1723-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA\">17.2.3 使用函数输出</a></li>\n</ul>\n</li>\n<li><a href=\"#173-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F\">17.3 在函数中使用变量</a><ul>\n<li><a href=\"#1731-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0\">17.3.1 向函数传递参数</a></li>\n<li><a href=\"#1732-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F\">17.3.2 在函数中处理变量</a></li>\n</ul>\n</li>\n<li><a href=\"#174-%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0\">17.4 数组变量和函数</a><ul>\n<li><a href=\"#1742-%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84\">17.4.2 从函数中返回数组</a></li>\n</ul>\n</li>\n<li><a href=\"#175-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92\">17.5 函数递归</a></li>\n<li><a href=\"#176-%E5%88%9B%E5%BB%BA%E5%BA%93\">17.6 创建库</a></li>\n<li><a href=\"#177-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0\">17.7 在命令行上使用函数</a><ul>\n<li><a href=\"#1771-%E5%9C%A8%E5%91%BD%E4%BB%A4%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0\">17.7.1 在命令上创建函数</a></li>\n<li><a href=\"#1772-%E5%9C%A8bashrc-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0\">17.7.2 在.bashrc 文件中定义函数</a></li>\n</ul>\n</li>\n<li><a href=\"#178-%E5%AE%9E%E4%BE%8B\">17.8 实例</a><ul>\n<li><a href=\"#1781-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\">17.8.1 下载安装第三方库</a></li>\n<li><a href=\"#1782-%E6%9E%84%E5%BB%BA%E5%BA%93\">17.8.2 构建库</a></li>\n<li><a href=\"#1783-shtool%E5%BA%93%E5%87%BD%E6%95%B0\">17.8.3 shtool库函数</a></li>\n<li><a href=\"#1784-%E4%BD%BF%E7%94%A8%E5%BA%93\">17.8.4 使用库</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#18-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E4%B8%AD%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B\">18. 图形化界面中脚本编程</a></li>\n<li><a href=\"#19%E5%88%9D%E8%AF%86sed%E5%92%8Cgawk\">19.初识sed和gawk</a><ul>\n<li><a href=\"#191-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86\">19.1 文本处理</a><ul>\n<li><a href=\"#1911-sed%E7%BC%96%E8%BE%91%E5%99%A8\">19.1.1 sed编辑器</a></li>\n</ul>\n</li>\n<li><a href=\"#192-sed-and-gawk%E8%BF%9B%E9%98%B6\">19.2 sed and gawk进阶</a></li>\n</ul>\n</li>\n<li><a href=\"#20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">20.正则表达式</a><ul>\n<li><a href=\"#201-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">20.1 什么是正则表达式</a></li>\n<li><a href=\"#202-%E5%AE%9A%E4%B9%89bre%E6%A8%A1%E5%BC%8F\">20.2 定义BRE模式</a><ul>\n<li><a href=\"#2021-%E7%BA%AF%E6%96%87%E6%9C%AC\">20.2.1. 纯文本</a></li>\n<li><a href=\"#2022-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6\">20.2.2 特殊字符</a></li>\n<li><a href=\"#2023-%E9%94%9A%E5%AE%9A%E5%AD%97%E7%AC%A6\">20.2.3 锚定字符</a></li>\n<li><a href=\"#2024-%E7%82%B9%E5%AD%97%E7%AC%A6\">20.2.4 点字符</a></li>\n<li><a href=\"#2025-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84\">20.2.5 字符数组</a></li>\n<li><a href=\"#2026-%E6%8E%92%E9%99%A4%E5%9E%8B%E5%AD%97%E7%AC%A6\">20.2.6 排除型字符</a></li>\n<li><a href=\"#2027-%E5%8C%BA%E9%97%B4\">20.2.7 区间</a></li>\n<li><a href=\"#2028-%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84\">20.2.8 特殊的字符数组</a></li>\n<li><a href=\"#2029-%E6%98%9F%E5%8F%B7\">20.2.9 星号</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#appendindex\">AppendIndex</a></li>\n</ul>\n<h1 id=\"1-linux入门\"><a href=\"#1-linux入门\" class=\"headerlink\" title=\"1. linux入门\"></a>1. linux入门</h1><p>linux是一款开源操作系统统称，其有很多发行版本，像ubuntu..，它的核心是其<code>内核</code>，早期由linus torvalds开发</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da5122af2d44d499197cd6eafe8fc02~tplv-k3u1fbpfcp-watermark.image\" alt=\"linus本人\"></p>\n<p>内核主要负责以下四种功能:</p>\n<ul>\n<li><p>系统内存管理</p>\n</li>\n<li><p>软件程序管理<br>  linux管理所有运行程序的进程.内核启动时会将<code>init</code>进程加载到<code>虚拟内存</code>，一些发行版本在<code>/etc/inittab</code>位置进行管理自启动进程,ubuntu则是在<code>/etc/init.d</code>或者<code>/etc/rcX.d</code>,<code>/etc/rcX.d</code>，<code>X</code>是某一特定是某一特定类型的进程，如下<code>rc0.d/</code>,<code>rc1.d/</code>,<code>rc2.d/</code>,<code>rc3.d/</code>,<code>rc4.d/</code>,<code>rc5.d/</code>,<code>rc6.d/</code>,<code>rcS.d/</code>运行级为<strong>1</strong>时，只启动基本的系统进程以及一个控制台终端进程。称之为<strong>单用户模式</strong>。单用户模式通常用来在系统有问题时进行紧急的文件系统维护。在这种模式下，仅有一个人（通常是系统管理员）能登录到系统上操作数据（这块部分以后涉及再补充也来的急，别深究）</p>\n</li>\n<li><p>硬件设备管理<br>两种方式将驱动程序插入到系统内核</p>\n<ol>\n<li>编译进内核的设备驱动代码<ul>\n<li>以前加入新的驱动要重新编译内核，效率低下</li>\n</ul>\n</li>\n<li>可插入内核的设备驱动模块<br> 可插拔式内核驱动，Linux系统将硬件设备当成特殊的文件，称为<code>设备文件</code>。设备文件有3种分类：<ul>\n<li>字符型设备文件</li>\n<li>块设备文件</li>\n<li>网络设备文件</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>文件系统管理<br>  linux自有的诸多文件系统外，Linux还支持从其他操作系统（比如Microsoft Windows）采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持</p>\n</li>\n</ul>\n<h1 id=\"2-走进shell\"><a href=\"#2-走进shell\" class=\"headerlink\" title=\"2. 走进shell\"></a>2. 走进shell</h1><p>在图形化桌面出现之前，与Unix(linux是兼容unix操作系统)系统进行交互的唯一方式就是借助由shell所提供的<code>文本命令</code>行界面(command line interface，CLI),是一种同Linux系统交互的直接接口</p>\n<h1 id=\"3-基本shell命令\"><a href=\"#3-基本shell命令\" class=\"headerlink\" title=\"3. 基本shell命令\"></a>3. 基本shell命令</h1><h2 id=\"3-1-启动shell\"><a href=\"#3-1-启动shell\" class=\"headerlink\" title=\"3.1 启动shell\"></a>3.1 启动shell</h2><ul>\n<li><code>/etc/passwd</code>包含用户的基本信息,如下输出</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">christine: x :501:501:Christine Bresnahan:/home/christine:/bin/bash</code></pre>\n\n<p>位置以此类推是用户名,密码,UID,GID,用户文本描述,家目录,默认启动启动bash作为自己的shell命令(第七章将有详细描述),目前绝大多数linux发行版将密码放在<code>/etc/shadow</code>目录下,普通方式是无法直接看到的</p>\n<h2 id=\"3-2-bash-手册\"><a href=\"#3-2-bash-手册\" class=\"headerlink\" title=\"3.2 bash 手册\"></a>3.2 bash 手册</h2><p>linux自带命令手册，方便用户查看相关命令的具体选项和参数。在手册左上角括号内的数字表明对应的内容区域。每个内容区域都分配了一个数字，</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>可执行程序或shell命令</td>\n</tr>\n<tr>\n<td>2</td>\n<td>系统调用</td>\n</tr>\n<tr>\n<td>3</td>\n<td>库调用</td>\n</tr>\n<tr>\n<td>4</td>\n<td>特殊文件</td>\n</tr>\n<tr>\n<td>5</td>\n<td>文件格式与约定</td>\n</tr>\n<tr>\n<td>6</td>\n<td>游戏</td>\n</tr>\n<tr>\n<td>7</td>\n<td>概览,约定及杂项</td>\n</tr>\n<tr>\n<td>8</td>\n<td>超级用户和系统管理员命令</td>\n</tr>\n<tr>\n<td>9</td>\n<td>内核例程</td>\n</tr>\n</tbody></table>\n<p>如果你忘了命令的关键字那么可以使用<code>man -k</code>的方式查找命令，比如<code>mkdir</code>,就可以使用<code>man -k mkdir</code>,就可以检索出与<code>mkdir</code>相关的命令.<br>包括对系统主机名的概述。要想查看所需要的页面，输入<code>man section linux-CMD-sytax</code>。对手册页中的第1部分而言，就是输入<code>man 1 hostname</code>。对于手册页中的第7部分，就是输入<code>man 7 hostname</code><br>手册页不是唯一的参考资料。还有另一种叫作info页面的信息。可以输入<code>info info</code>来了解info页面的相关内容。</p>\n<h2 id=\"3-4-文件系统\"><a href=\"#3-4-文件系统\" class=\"headerlink\" title=\"3.4 文件系统\"></a>3.4 文件系统</h2><p>简单理解，linux文件系统跟windows的文件布局是不一样的。</p>\n<ul>\n<li><p>linux 文件系统</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;bin</td>\n<td>二进制目录，存放许多用户级的GNU工具</td>\n</tr>\n<tr>\n<td>&#x2F;boot</td>\n<td>启动目录，存放启动文件</td>\n</tr>\n<tr>\n<td>&#x2F;dev</td>\n<td>设备目录，Linux在这里创建设备节点</td>\n</tr>\n<tr>\n<td>&#x2F;etc</td>\n<td>系统配置文件目录</td>\n</tr>\n<tr>\n<td>&#x2F;home</td>\n<td>主目录，Linux在这里创建用户目录</td>\n</tr>\n<tr>\n<td>&#x2F;lib</td>\n<td>库目录，存放系统和应用程序的库文件</td>\n</tr>\n<tr>\n<td>&#x2F;media</td>\n<td>媒体目录，可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>&#x2F;mnt</td>\n<td>挂载目录，另一个可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>&#x2F;opt</td>\n<td>可选目录，常用于存放第三方软件包和数据文件</td>\n</tr>\n<tr>\n<td>&#x2F;proc</td>\n<td>进程目录，存放现有硬件及当前进程的相关信息</td>\n</tr>\n<tr>\n<td>&#x2F;root</td>\n<td>root用户的主目录</td>\n</tr>\n<tr>\n<td>&#x2F;sbin</td>\n<td>系统二进制目录，存放许多GNU管理员级工具</td>\n</tr>\n<tr>\n<td>&#x2F;run</td>\n<td>运行目录，存放系统运作时的运行时数据</td>\n</tr>\n<tr>\n<td>&#x2F;srv</td>\n<td>服务目录，存放本地服务的相关文件</td>\n</tr>\n<tr>\n<td>&#x2F;sys</td>\n<td>系统目录，存放系统硬件信息的相关文件</td>\n</tr>\n<tr>\n<td>&#x2F;tmp</td>\n<td>临时目录，可以在该目录中创建和删除临时工作文件</td>\n</tr>\n<tr>\n<td>&#x2F;usr</td>\n<td>用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</td>\n</tr>\n<tr>\n<td>&#x2F;var</td>\n<td>可变目录，用以存放经常变化的文件，比如日志文件</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>遍历目录(cd命令)<br>需要你知道文件树状结构,这样才能知道你将访问文件的具体位置，无论是<code>相对路径</code>还是<code>绝对路径</code><br><code>cd</code>命令，这时要注意文件系统的相对路径和绝对路径问题，linux通过这两种方式确定目录位置，符号<code>/</code>是表示根目录</p>\n<ul>\n<li>绝对路径  通过从root目录开始一层一层的进行访问，最终访问到目标文件或者目录,<code>/bin/bash</code>从根目录定位到bash</li>\n<li>相对路径<ul>\n<li><code>./</code> 当前目录</li>\n<li><code>../</code> 上层目录</li>\n<li><code>~/</code> 表示当前用户home目录</li>\n</ul>\n</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> ~/   <span class=\"token comment\"># 进到对应账号的home目录下</span>\n<span class=\"token builtin class-name\">cd</span> /home/kirkzhang  <span class=\"token comment\">#使用绝对路径进入家目录</span></code></pre>\n</li>\n<li><p>目录列表(ls命令)<br><code>ls</code>按照字母序列,参数<code>-l</code> 显示长列表,更多参数查看ls手册</p>\n<ul>\n<li>问号（?）代表一个字符</li>\n<li>星号（*）代表零个或多个字符</li>\n</ul>\n</li>\n<li><p>文件链接</p>\n<ul>\n<li>软连接<br>当我们需要相同文件时,不必要在每个文件夹下都放一份文件夹，只需要使用软链接<br>ls -s &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql &#x2F;usr&#x2F;bin</li>\n<li>硬链接</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"4-其他shell命令\"><a href=\"#4-其他shell命令\" class=\"headerlink\" title=\"4. 其他shell命令\"></a>4. 其他shell命令</h1><h2 id=\"4-1-监控程序\"><a href=\"#4-1-监控程序\" class=\"headerlink\" title=\"4.1 监控程序\"></a>4.1 监控程序</h2><ul>\n<li><p>ps查看进程</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">ps</span> 选项\n-A 显示所有进程 \n-N 显示与指定参数不符的所有进程 \n-a 显示除控制进程（session leader①）和无终端进程外的所有进程 \n-d 显示除控制进程外的所有进程 \n-e 显示所有进程 \n-C cmdlist 显示包含在cmdlist列表中的进程 \n-G grplist 显示组ID在grplist列表中的进程 \n-U userlist 显示属主的用户ID在userlist列表中的进程 \n-g grplist 显示会话或组ID在grplist列表中的进程② \n-p pidlist 显示PID在pidlist列表中的进程\n-f 完整格式输出</code></pre>\n\n<p>命令输出关键词意义</p>\n<table>\n<thead>\n<tr>\n<th>名词</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UID</td>\n<td>启动这些进程的用户</td>\n</tr>\n<tr>\n<td>PID</td>\n<td>进程的ID</td>\n</tr>\n<tr>\n<td>PPID</td>\n<td>父进程的进程号（如果该进程是由另一个进程启动的）</td>\n</tr>\n<tr>\n<td>C</td>\n<td>进程生命周期中的CPU利用率</td>\n</tr>\n<tr>\n<td>STIME</td>\n<td>进程启动时的系统时间</td>\n</tr>\n<tr>\n<td>TTY</td>\n<td>进程启动时的终端设</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>运行进程需要的累计CPU时间</td>\n</tr>\n<tr>\n<td>CMD</td>\n<td>启动的程序名称</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>top实时监控</p>\n<ul>\n<li>第一行：当前时间，系统运行时间，登录用户数，系统的平均负载(15分钟的参数越大且超过，说明有问题)  </li>\n<li>第二行：进程状态  </li>\n<li>第三行：CPU相关数值，使用率</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名词</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PID：</td>\n<td>进程的ID</td>\n</tr>\n<tr>\n<td>USER：</td>\n<td>进程属主的名字</td>\n</tr>\n<tr>\n<td>PR：</td>\n<td>进程的优先级</td>\n</tr>\n<tr>\n<td>NI：</td>\n<td>进程的谦让度度</td>\n</tr>\n<tr>\n<td>VIRT：</td>\n<td>进程占用的虚拟内存总量</td>\n</tr>\n<tr>\n<td>RES：</td>\n<td>进程占用的物理内存总量</td>\n</tr>\n<tr>\n<td>SHR：</td>\n<td>进程和其他进程共享的内存总量</td>\n</tr>\n<tr>\n<td>S：</td>\n<td>进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表 跟踪状态或停止状态，Z代表僵化状态)</td>\n</tr>\n<tr>\n<td>%CPU：</td>\n<td>进程使用的CPU时间比例</td>\n</tr>\n<tr>\n<td>%MEM：</td>\n<td></td>\n</tr>\n<tr>\n<td>TIME+：</td>\n<td>自进程启动到目前为止的CPU时间总量</td>\n</tr>\n<tr>\n<td>COMMAND</td>\n<td>：进程所对应的命令行名称，也就是启动的程序名</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>kill结束进程</p>\n<table>\n<thead>\n<tr>\n<th>信号</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>HUP</td>\n<td>挂起</td>\n</tr>\n<tr>\n<td>2</td>\n<td>INT</td>\n<td>中断</td>\n</tr>\n<tr>\n<td>3</td>\n<td>QUIT</td>\n<td>退出</td>\n</tr>\n<tr>\n<td>9</td>\n<td>KILL</td>\n<td>无条件终止</td>\n</tr>\n<tr>\n<td>11</td>\n<td>SEGV</td>\n<td>段错误</td>\n</tr>\n<tr>\n<td>15</td>\n<td>TERM</td>\n<td>尽可能终止</td>\n</tr>\n<tr>\n<td>17</td>\n<td>STOP</td>\n<td>无条件终止</td>\n</tr>\n<tr>\n<td>18</td>\n<td>TSTP</td>\n<td>停止或暂停，但在后台运行</td>\n</tr>\n<tr>\n<td>19</td>\n<td>CONT</td>\n<td>在STOP或TSTP之后恢复执行</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>系统performance监控<br>这个要下载<code>sysstat</code>程序。</p>\n<ul>\n<li>iostat - reports CPU statistics and input&#x2F;output statistics for block devices and partitions.</li>\n<li>mpstat - Processors Statistics<ul>\n<li><code>mpstat -P ALl</code> 所有processor</li>\n<li><code>mpstat -P ALL 2 5</code> 迭代五次间隔两秒</li>\n</ul>\n</li>\n<li>pidstat - Process and Kernel Threads Statistics</li>\n<li>tapestat - reports statistics for tape drives connected to the system</li>\n<li>cifsiostat - reports CIFS statistics.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-2-磁盘空间监控\"><a href=\"#4-2-磁盘空间监控\" class=\"headerlink\" title=\"4.2 磁盘空间监控\"></a>4.2 磁盘空间监控</h2><ul>\n<li><p>mount挂在存储媒体<br><code>mount</code>提供如下信息<code>媒体设备名</code>,<code>挂载点</code>,<code>文件类型</code>,<code>访问方式</code>  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#将A设备挂在到B目录上,type 参数指定了磁盘被格式化的文件系统类型,如`vfat`,`iso9660`,`ntfs`,例如`mount -t vfat /dev/sdb1 /media/  disk`</span>\n<span class=\"token function\">mount</span> -t <span class=\"token builtin class-name\">type</span>  A  B  </code></pre>\n</li>\n<li><p>mount参数列表，详情见man手册，或者如下</p>\n<table>\n<thead>\n<tr>\n<th>参 数</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>挂载&#x2F;etc&#x2F;fstab文件中指定的所有文件系统</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>使 mount 命令模拟挂载设备，但并不真的挂载</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>和 -a 参数一起使用时，会同时挂载所有文件系统</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>详细模式，将会说明挂载设备的每一步</td>\n</tr>\n<tr>\n<td>-I</td>\n<td>不启用任何&#x2F;sbin&#x2F;mount.filesystem下的文件系统帮助文件</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>给ext2、ext3或XFS文件系统自动添加文件系统标签</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>挂载设备，但不注册到&#x2F;etc&#x2F;mtab已挂载设备文件中</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>num进行加密挂载时，从文件描述符 num 中获得密码短语</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>忽略该文件系统不支持的挂载选项</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>将设备挂载为只读的</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>将设备挂载为可读写的（默认参数）</td>\n</tr>\n<tr>\n<td>-L label</td>\n<td>将设备按指定的 label 挂载</td>\n</tr>\n<tr>\n<td>-U uuid</td>\n<td>将设备按指定的 uuid 挂载</td>\n</tr>\n<tr>\n<td>-O</td>\n<td>和 -a 参数一起使用，限制命令只作用到特定的一组文件系统上</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>给文件系统添加特定的选项</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>-o</code>参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。以下为常用的选项</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">ro <span class=\"token comment\">#只读挂载  </span>\nrw <span class=\"token comment\">#读写挂载</span>\nuser <span class=\"token comment\">#允许普通用户挂在</span>\nloop <span class=\"token comment\">#挂载一个文件</span>\n<span class=\"token assign-left variable\">check</span><span class=\"token operator\">=</span>none <span class=\"token comment\">#挂载时进行完整性校验</span></code></pre>\n</li>\n<li><p>unmount 卸载设备</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">unmount <span class=\"token punctuation\">[</span>directory <span class=\"token operator\">|</span> device<span class=\"token punctuation\">]</span> <span class=\"token comment\"># //卸载文件应在外侧目录完成,命令行提示符仍然在挂载设备的文件系统目录中，`umount` 命令无法卸载该镜像</span></code></pre>\n</li>\n<li><p>df 查看文件大小  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">df</span> -h <span class=\"token comment\">#以M,G描述问价大小</span></code></pre>\n</li>\n<li><p>du 查看文件大小</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-c <span class=\"token comment\">#显示所有已列出文件总的大小(还是不宜读)</span>\n-h <span class=\"token comment\">#按用户易读的格式输出大小，即用K替代千字节</span>\n-s <span class=\"token comment\">#显示每个输出参数的总计</span></code></pre>\n</li>\n<li><p>find</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> 目录 -</code></pre></li>\n</ul>\n<h2 id=\"4-3-处理文件\"><a href=\"#4-3-处理文件\" class=\"headerlink\" title=\"4.3 处理文件\"></a>4.3 处理文件</h2><ul>\n<li><p>sort - 文件排序  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-n  <span class=\"token comment\">#sort命令会把数字当做字符来执行标准的字符排序,解决</span>\n-M  <span class=\"token comment\">#按照月份排序</span>\n-k  <span class=\"token comment\">#和`-t`参数在对按字段分隔的数据进行排序时非常有用`sort -t ':' -k 3 -n /etc/passwd`</span>\n-n  <span class=\"token comment\">#按照数值排序du -hs * | sort -nr</span>\n-r  <span class=\"token comment\">#反向排序 </span></code></pre>\n</li>\n<li><p>grep - 搜索文件  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-v <span class=\"token comment\">#输出不匹配的行</span>\n-n <span class=\"token comment\">#输出行号</span>\n-c <span class=\"token comment\">#计算匹配到的行数</span>\n-e <span class=\"token comment\">#指定多个匹配模式</span>\n<span class=\"token function\">grep</span> <span class=\"token punctuation\">[</span>tf<span class=\"token punctuation\">]</span> file1 <span class=\"token comment\">#支持正则匹配</span></code></pre>\n</li>\n<li><p>egrep, fgrep 功能更强大  </p>\n</li>\n<li><p>压缩数据 - zip , gzip:gz, compress:Z, bzip2:bz2</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">gzip</span> <span class=\"token comment\">#压缩文件</span>\ngzcat <span class=\"token comment\">#查看文件内容</span>\ngunzip <span class=\"token comment\">#用来解压文件  </span></code></pre>\n</li>\n<li><p>归档数据 - tar</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-c <span class=\"token comment\">#~ create`创建一个新的tar文件</span>\n-r <span class=\"token comment\">#追加文件到tar文件末尾</span>\n-x <span class=\"token comment\">#~ extract`抽取tar文件</span>\n-v <span class=\"token comment\">#显示文件列表</span>\n-z <span class=\"token comment\">#将输出重定向给gzip命令</span>\n-f <span class=\"token comment\"># file`输出文件结果到文化，`tar -cvf test.tar test/ test2/` 创建一个新文件</span>\n-t <span class=\"token comment\"># list`列举tar内容</span>\n-C <span class=\"token comment\">#指定具体目录</span>\n<span class=\"token function\">tar</span> -xvf test.tar`令从tar文件test.tar中提取内容。如果tar文件是从一个目录结构创建的，那整个目录结构都会在当前目录下重新创建</code></pre></li>\n</ul>\n<h2 id=\"4-4-date命令及其格式化\"><a href=\"#4-4-date命令及其格式化\" class=\"headerlink\" title=\"4.4 date命令及其格式化\"></a>4.4 date命令及其格式化</h2><ul>\n<li><p>格式化占位符</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">%D – Display <span class=\"token function\">date</span> as mm/dd/yy\n%Y – Year <span class=\"token punctuation\">(</span>e.g., <span class=\"token number\">2020</span><span class=\"token punctuation\">)</span>\n%m – Month <span class=\"token punctuation\">(</span>01-12<span class=\"token punctuation\">)</span>\n%B – Long month name <span class=\"token punctuation\">(</span>e.g., November<span class=\"token punctuation\">)</span>\n%b – Short month name <span class=\"token punctuation\">(</span>e.g., Nov<span class=\"token punctuation\">)</span>\n%d – Day of month <span class=\"token punctuation\">(</span>e.g., 01<span class=\"token punctuation\">)</span>\n%j – Day of year <span class=\"token punctuation\">(</span>001-366<span class=\"token punctuation\">)</span>\n%u – Day of week <span class=\"token punctuation\">(</span><span class=\"token number\">1</span>-7<span class=\"token punctuation\">)</span>\n%A – Full weekday name <span class=\"token punctuation\">(</span>e.g., Friday<span class=\"token punctuation\">)</span>\n%a – Short weekday name <span class=\"token punctuation\">(</span>e.g., Fri<span class=\"token punctuation\">)</span>\n%H – Hour <span class=\"token punctuation\">(</span>00-23<span class=\"token punctuation\">)</span>\n%I – Hour <span class=\"token punctuation\">(</span>01-12<span class=\"token punctuation\">)</span>\n%M – Minute <span class=\"token punctuation\">(</span>00-59<span class=\"token punctuation\">)</span>\n%S – Second <span class=\"token punctuation\">(</span>00-60<span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li><p>date时间加减</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span>  <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> --date<span class=\"token operator\">=</span><span class=\"token string\">\"-5 day\"</span> +%Y%m%d<span class=\"token variable\">`</span></span>\n<span class=\"token builtin class-name\">echo</span>  <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> --date<span class=\"token operator\">=</span><span class=\"token string\">\"-5 month\"</span> +%Y%m%d<span class=\"token variable\">`</span></span>\n<span class=\"token builtin class-name\">echo</span>  <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> --date<span class=\"token operator\">=</span><span class=\"token string\">\"-5 year\"</span> +%Y%m%d<span class=\"token variable\">`</span></span></code></pre>\n</li>\n<li><p>set和change系统时间</p>\n<p><code>date --set=&quot;20100513 05:30&quot;</code>谨慎使用</p>\n</li>\n<li><p>展示某一日期文件的日期</p>\n<p><code>--file</code>选项打印出文件中每一行存在的日期字符串。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> --file<span class=\"token operator\">=</span></code></pre>\n</li>\n<li><p>重写日期</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> -d <span class=\"token string\">'TZ=\"Australia/Sydney\" 04:30 next Monday'</span></code></pre>\n\n<p>下面命令可以列出<code>timezone</code></p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">timedatectl list-timezones</code></pre>\n</li>\n<li><p>与其他shell混用</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">mysqldump  database_name <span class=\"token operator\">></span> database_name-<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">date</span> +%Y%m%d<span class=\"token variable\">)</span></span>.sql\n</code></pre>\n</li>\n<li><p>使用Unix纪元时间（纪元转换）。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">date</span> +%s <span class=\"token comment\"># To show the number of seconds from the epoch to the current day, use the %s format control</span>\n<span class=\"token function\">date</span> -d <span class=\"token string\">\"1984-04-08\"</span> +<span class=\"token string\">\"%s\"</span> <span class=\"token comment\"># To see how many seconds passed from epoch to a specific date, enter</span></code></pre></li>\n</ul>\n<p>一个完整的带有详细时间的<code>date</code>命令是<code>date --date=&quot;-5 day&quot;  +&quot;%Y-%m-%d %H:%M:%S&quot;</code></p>\n<h1 id=\"5-理解shell\"><a href=\"#5-理解shell\" class=\"headerlink\" title=\"5. 理解shell\"></a>5. 理解shell</h1><h2 id=\"5-1-shell的类型\"><a href=\"#5-1-shell的类型\" class=\"headerlink\" title=\"5.1 shell的类型\"></a>5.1 shell的类型</h2><p>不同Linux系统有很多种shell,<code>cat /etc/passwd</code>可以看到用户默认登录默认的shell</p>\n<ul>\n<li>Debian的是dash</li>\n<li>csh</li>\n<li>sh(你经常会看到某些发行版使用软链接将默认的系统shell设置成bash shell，如本书所使用的CentOS发行版)</li>\n</ul>\n<h2 id=\"5-2-shell的父子关系\"><a href=\"#5-2-shell的父子关系\" class=\"headerlink\" title=\"5.2 shell的父子关系\"></a>5.2 shell的父子关系</h2><p>在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中的一些东西造成影响</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c string</td>\n<td>从 string 中读取命令并进行处理</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>启动一个能够接收用户输入的交互shell</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>以登录shell的形式启动</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>启动一个受限shell，用户会被限制在默认目录中</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>从标准输入中读取命令</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-2-1-进程列表\"><a href=\"#5-2-1-进程列表\" class=\"headerlink\" title=\"5.2.1 进程列表\"></a>5.2.1 进程列表</h3><ol>\n<li><code>(pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)</code>,括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令</li>\n<li>语法为 <code>&#123; command; &#125;</code> 。使用花括号进行命令分组,并不会像进程列表那样创建出子shell</li>\n<li>( pwd ; (echo $BASH_SUBSHELL)) 创建子shell的子shell</li>\n<li>在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢<br>处理速度。在交互式的CLI shell会话中，子shell同样存在问题。它并非真正的多进程处理，因为<br>终端控制着子shell的I&#x2F;O</li>\n</ol>\n<h3 id=\"5-2-2-子shell的其他用法\"><a href=\"#5-2-2-子shell的其他用法\" class=\"headerlink\" title=\"5.2.2 子shell的其他用法\"></a>5.2.2 子shell的其他用法</h3><ol>\n<li>后台运行模式( &amp; )</li>\n<li>进程列表置于后台 (sleep 2 ; echo $BASH_SUBSHELL ; sleep 2) &amp;</li>\n<li>携程<ul>\n<li>coproc My_Job { sleep 10; }, My_Job 是自定义名字，必须确保在第一个花括号（ { ）和命令名之间有一个空格</li>\n<li>将<code>协程</code>与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,<br>然后把命令 <code>coproc</code> 放在前面就行了<code>coproc ( sleep 10; sleep 2 )</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-3-理解shell的内建命令\"><a href=\"#5-3-理解shell的内建命令\" class=\"headerlink\" title=\"5.3 理解shell的内建命令\"></a>5.3 理解shell的内建命令</h2><h3 id=\"5-3-1-外部命令\"><a href=\"#5-3-1-外部命令\" class=\"headerlink\" title=\"5.3.1 外部命令\"></a>5.3.1 外部命令</h3><p>当外部命令执行时，会创建出一个子进程。这种操作被称为<code>衍生</code>(forking),有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于&#x2F;bin、&#x2F;usr&#x2F;bin、&#x2F;sbin或&#x2F;usr&#x2F;sbin中</p>\n<ul>\n<li><code>which ps</code></li>\n<li><code>type -a ps</code></li>\n<li>当进程必须执行衍生操作时，它需要花费时间和精力来设置新子进程的环境。所以说，外部命令多少还是有代价的,就算衍生出子进程或是创建了子shell，你仍然可以通过发送信号与其沟通，这一点无论是<br>在命令行还是在脚本编写中都是极其有用的</li>\n</ul>\n<h3 id=\"5-3-2-内部命令\"><a href=\"#5-3-2-内部命令\" class=\"headerlink\" title=\"5.3.2 内部命令\"></a>5.3.2 内部命令</h3><ol>\n<li>命令<code>type -a</code>显示出了每个命令的两种实现。注意， which 命令只显示出了外部命令文件</li>\n<li><code>!数字</code>可以使用.bash_history文件的命令</li>\n<li><code>alias -p</code>,有一个别名取代了标准命令 <code>ls</code>.它自动加入了<code>--color</code>选项，表明终端支持彩色模式的列表</li>\n<li><code>alias li=&#39;ls -li&#39;</code>,一个别名仅在它所被定义的shell进程中才有效</li>\n</ol>\n<h1 id=\"6-环境变量\"><a href=\"#6-环境变量\" class=\"headerlink\" title=\"6. 环境变量\"></a>6. 环境变量</h1><ul>\n<li>login shell : 用户成功登陆后使用的是 Login shell。例如，当你通过终端、SSH 或使用 “su -“ 命令来切换账号时都会使用的Login Shell</li>\n<li>non-login shell : Non Login Shell 是指通过 login shell 开启的shell,Non-login shell执行<code>~/.bashrc</code>脚本来初始shell环境</li>\n<li>交互式shell ： 就是终端等待你输入命令的就是交互式shell</li>\n<li>非交互式shell : 非交互式模式，以shell script(非交互)方式执行。在这种模式 下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF，shell也就终止了</li>\n</ul>\n<p>如何快速辨别是login shell 还是non-login shell ,可通过<code>echo $0</code>如果是输出<code>-bash</code>说明是login shell,<code>bash</code>说明是non-login shell  </p>\n<ul>\n<li><p>全局环境变量对于所有shell都是可见的,对于子shell来说这是非常重要的,<code>printenv</code>or<code>env</code>命令查看全局命令</p>\n</li>\n<li><p>局部变量，<code>set</code>返回全局变量，用户自定义变量,所以返回局部变量有点复杂，以字母序进行排序</p>\n</li>\n<li><p>用户自定义变量</p>\n<p><code>echo $my_variable -&gt; my_variable=Hello</code>可赋值,并且当你想要使用自定义变量时候要使用<code>$&#123;my_variable&#125;</code>语法，大小写敏感</p>\n</li>\n<li><p>设置全局环境变量</p>\n<ul>\n<li><p><code>export my_variable</code>导出为全局变量，在子shell中修改该值，只会在子shell中生效</p>\n</li>\n<li><p><code>unset my_variable</code>删除环境变量,这条规则的一个例外就是使用 printenv 显示某个变量的值)</p>\n</li>\n<li><p>默认的环境变量，直接使用就好了</p>\n<p><img src=\"/./../picture/linux_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/linux_default_variables.png\" alt=\"linux_default_variables\"><br><img src=\"/./../picture/linux_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/linux_default_variables_1.png\" alt=\"linux_default_variables_1\"></p>\n</li>\n<li><p>设置<code>path</code>环境变量,当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序.<code>PATH</code>环境变量定义了用于进行命令和程序查找的目录</p>\n</li>\n<li><p>定位环境变量</p>\n<ul>\n<li>登录式shell<br>在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作<code>启动文件</code>或<code>环境文件</code>。bash检查启动文件的方式取决于你启动bash的方式，启动bash shell有3种方式<ul>\n<li><p>登录时作为默认登录shell(login shell)<br>当你登录系统的时候，bash shell会作为登陆式shell进行启动，会在如下文件五个不同启动文件读取命令<code>/etc/profile</code>,<code>$HOME/.bash_profile</code>,<code>$HOME/.bash_login</code>,<code>$HOME/.profile</code>,<code>$HOME/.bashrc</code></p>\n<ul>\n<li><code>/etc/profile</code>  是系统默认的bash shell主启动文件，系统上每个用户登陆时候都会读取这个主启动文件，<br>两个发行版的<code>/etc/profile</code>文件都用到了同一个特性：for语句。它用来迭代<code>/etc/profile.d</code>目录，这为Linux系统提供了一个放置特定应用程序启动文件的地方，<br>当用户登录时，shell会执行这些文件。在本书所用的Ubuntu Linux系统中，<br><code>/etc/profile.d</code>目录下包含以下文件  </li>\n<li>shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略,这里没提到<code>$HOME/.bashrc</code>文件，这个文件通常是通过其他文件运行  <ul>\n<li><code>$HOME/.bash_profile</code></li>\n<li><code>$HOME/.bash_login</code></li>\n<li><code>$HOME/.profile</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>NOTE</strong> : 要留意的是有些Linux发行版使用了可拆卸式认证模块(Pluggable AuthenticationModules ，PAM)。在这种情况下，PAM文件会在bash shell启动之前处理，这些文件中可能会包含环境变量。PAM文件包括<code>/etc/environment</code>文 件 和<code>$HOME/.pam_environment</code>文件</p>\n</li>\n</ul>\n</li>\n<li>交互式shell(non-login shell)<br>如果你的shell不是登录系统时候启动的，那么你启动的shell就是交互式shell，它不会访问<code>/etc/profile</code>只会检查<code>.bashrc</code>文件，<code>.bashrc</code>文件有两个作用：一是查看&#x2F;etc目录下通用的<code>bashrc</code>文件，二是为用户提供一个定制自己的命令别名(参见第5章)和私有脚本函数的地方(将在第17章中讲到)</li>\n<li>非交互shell<br>TBC</li>\n<li>环境变量的持久化<br>  对全局环境变量来说（Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修改过的变量设置放在<code>/etc/profile</code>文件中，但这可不是什么好主意。如果你升级了所用的发行版，这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。最好是在<code>/etc/profile.d</code>目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。在大多数发行版中，存储个人用户永久性bash shell变量的地方是<code>$HOME/.bashrc</code>文件。这一点适用于所有类型的shell进程。但如果设置了<code>BASH_ENV</code>变量，那么记住，除非它指向的是$HOME&#x2F;.bashrc，否则你应该将非交互式shell的用户变量放在别的地方</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>环境变量数组<br>  <code>mytest=(one two three four five)</code>定义了环境变量数组,<code>echo $&#123;mytest[2]&#125;</code>使用下标索引可以访问具体值,<code>echo $&#123;mytest[*]&#125;</code>可以访问所有的值,<code>unset mytest[2]</code>删除某个值,<code>unset mytest</code>删除全部</p>\n</li>\n<li><p>总结<br>  bash shell会在启动时执行几个启动文件。这些启动文件包含了环境变量的定义，可用于为每个bash会话设置标准环境变量。每次登录Linux系统，bash shell都会访问<code>/etc/profile</code>启动文件以及3个针对每个用户的本地启动文件：<code>$HOME/.bash_profile</code>、<code>$HOME/.bash_login</code>和<code>$HOME/.profile</code>。用户可以在这些文件中定制自己想要的环境变量和启动脚本。</p>\n</li>\n</ul>\n<h1 id=\"7-linux文件权限\"><a href=\"#7-linux文件权限\" class=\"headerlink\" title=\"7. linux文件权限\"></a>7. linux文件权限</h1><p>用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是<code>登录名</code>。登录名是用户用来登录系统的最长八字符的字符串（字符可以是数字或字母），同时会关联一个对应的密码</p>\n<h2 id=\"7-1-linux的安全性\"><a href=\"#7-1-linux的安全性\" class=\"headerlink\" title=\"7.1 linux的安全性\"></a>7.1 linux的安全性</h2><ul>\n<li><p><code>/etc/passwd</code>包含用户的基本信息,所有在服务器后台运行都需要个<code>系统账户</code>运行</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>. 登录用户名\n<span class=\"token number\">2</span>. 用户密码\n<span class=\"token number\">3</span>. 用户账户的<span class=\"token environment constant\">UID</span>（数字形式）\n<span class=\"token number\">4</span>. 用户账户的组ID（GID）（数字形式）\n<span class=\"token number\">5</span>. 用户账户的文本描述（称为备注字段）\n<span class=\"token number\">6</span>. 用户<span class=\"token environment constant\">HOME</span>目录的位置\n<span class=\"token number\">7</span>. 用户的默认shell</code></pre>\n\n<p>root固定分配UID是0，Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作<code>系统账户</code>，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个(application account)，如果全都是root权限登录系统就很危险，被攻陷就直接是root权限。</p>\n</li>\n<li><p><code>/etc/shadow</code>真正存密码的文件,只允许root用户访问</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>. 与/etc/passwd文件中的登录名字段对应的登录名\n<span class=\"token number\">2</span>. 加密后的密码\n<span class=\"token number\">3</span>. 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）\n<span class=\"token number\">4</span>. 多少天后才能更改密码\n<span class=\"token number\">5</span>. 多少天后必须更改密码\n<span class=\"token number\">6</span>. 密码过期前提前多少天提醒用户更改密码\n<span class=\"token number\">7</span>. 密码过期后多少天禁用用户账户\n<span class=\"token number\">8</span>. 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）\n<span class=\"token number\">9</span>. 预留字段给将来使用</code></pre></li>\n</ul>\n<h3 id=\"7-1-1-添加linux用户\"><a href=\"#7-1-1-添加linux用户\" class=\"headerlink\" title=\"7.1.1 添加linux用户\"></a>7.1.1 添加linux用户</h3><ul>\n<li><p><code>useradd</code>命令添加默认配置的用户,<code>/etc/default/useradd</code>可以加入<code>-D</code>选项查看默认参数如下(一些Linux发行版会把Linux用户和组工具放在&#x2F;usr&#x2F;sbin目录下，这个目录可能不在<code>PATH</code>环境变量里)</p>\n<ul>\n<li>新用户会被添加到GID为100 的公共组；</li>\n<li>新用户的HOME目录将会位于&#x2F;home&#x2F;loginname；</li>\n<li>新用户账户密码在过期后不会被禁用；</li>\n<li>新用户账户未被设置过期日期；</li>\n<li>新用户账户将bash shell作为默认shell；</li>\n<li>系统会将&#x2F;etc&#x2F;skel目录下的内容复制到用户的HOME目录下；</li>\n<li>系统为该用户账户在mail目录下创建一个用于接收邮件的文件</li>\n</ul>\n<p><code>/etc/skel</code>下面它们是bash shell环境的标准启动文件,允许管理员把它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系统文件,<code>useradd</code>参数可以控制这些默认值,ubuntu系统在<code>/etc/skel</code>下，默认命令行参数</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-c comment 给新用户添加备注\n-d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话）\n-e expire_date 用YYYY-MM-DD格式指定一个账户过期的日期\n-f inactive_days 指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示禁用这个功能\n-g initial_group 指定用户登录组的GID或组名\n-G group <span class=\"token punctuation\">..</span>. 指定用户除登录组之外所属的一个或多个附加组\n-k 必须和-m一起使用，将/etc/skel目录的内容复制到用户的<span class=\"token environment constant\">HOME</span>目录\n-m 创建用户的<span class=\"token environment constant\">HOME</span>目录\n-M 不创建用户的<span class=\"token environment constant\">HOME</span>目录（当默认设置里要求创建时才使用这个选项）\n-n 创建一个与用户登录名同名的新组\n-r 创建系统账户\n-p <span class=\"token function\">passwd</span> 为用户账户指定默认密码\n-s shell 指定默认的登录shell \n-u uid 为账户指定唯一的<span class=\"token environment constant\">UID</span> </code></pre>\n\n<p>同时也可以更改默认值的参数</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">-b default_home  更改默认的创建用户<span class=\"token environment constant\">HOME</span>目录的位置\n-e expiration_date  更改默认的新账户的过期日期\n-f inactive  更改默认的新用户从密码过期到账户被禁用的天数\n-g group  更改默认的组名称或GID \n-s shell  更改默认的登录shell \n<span class=\"token comment\"># 更改用户默认shell</span>\n<span class=\"token function\">useradd</span> -D -s /bin/tsch</code></pre></li>\n</ul>\n<h3 id=\"7-1-2-删除用户\"><a href=\"#7-1-2-删除用户\" class=\"headerlink\" title=\"7.1.2 删除用户\"></a>7.1.2 删除用户</h3><p>to_be_continue</p>\n<h3 id=\"7-1-2-修改用户\"><a href=\"#7-1-2-修改用户\" class=\"headerlink\" title=\"7.1.2 修改用户\"></a>7.1.2 修改用户</h3><p>to_be_continue</p>\n<h2 id=\"7-2-使用linux组\"><a href=\"#7-2-使用linux组\" class=\"headerlink\" title=\"7.2 使用linux组\"></a>7.2 使用linux组</h2><ul>\n<li>&#x2F;etc&#x2F;group 存储一个组的信息，低于500是系统的，高于500是用户组的<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n</li>\n<li>创建组</li>\n<li>修改组</li>\n</ul>\n<h2 id=\"7-3-理解文件权限\"><a href=\"#7-3-理解文件权限\" class=\"headerlink\" title=\"7.3 理解文件权限\"></a>7.3 理解文件权限</h2><ul>\n<li><p>理解文件权限符号</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\"><span class=\"token variable\">`</span>-<span class=\"token variable\">`</span></span>代表文件\n<span class=\"token variable\"><span class=\"token variable\">`</span>d<span class=\"token variable\">`</span></span> 代表目录\n<span class=\"token variable\"><span class=\"token variable\">`</span>l<span class=\"token variable\">`</span></span> 代表链接\n<span class=\"token variable\"><span class=\"token variable\">`</span>c<span class=\"token variable\">`</span></span> 代表字符型设备\n<span class=\"token variable\"><span class=\"token variable\">`</span>b<span class=\"token variable\">`</span></span> 代表块设备\n<span class=\"token variable\"><span class=\"token variable\">`</span>n<span class=\"token variable\">`</span></span> 代表网络设备\n<span class=\"token variable\"><span class=\"token variable\">`</span>r<span class=\"token variable\">`</span></span> 可写\n<span class=\"token variable\"><span class=\"token variable\">`</span>w<span class=\"token variable\">`</span></span> 可写\n<span class=\"token variable\"><span class=\"token variable\">`</span>x<span class=\"token variable\">`</span></span> 可执行\n文件owner,和对象组</code></pre>\n</li>\n<li><p>设置默认文件权限<br>设置<code>umask</code>的值,默认文件权限等于文件最大权限，减去<code>umask</code>值，第一位代表了一项特别的安全特性，叫作粘着位（sticky bit）<br>rwx &#x3D; 4 + 2 + 1 &#x3D; 7, rw &#x3D; 4 + 2 &#x3D; 6, rx &#x3D; 4 +1 &#x3D; 5.</p>\n</li>\n</ul>\n<h2 id=\"7-4-改变安全性设置\"><a href=\"#7-4-改变安全性设置\" class=\"headerlink\" title=\"7.4 改变安全性设置\"></a>7.4 改变安全性设置</h2><ul>\n<li><p>chmod 改文件权限，如果使用的符号模式设置就是<code>u</code>代表用户，<code>g</code>代表组，<code>o</code>代表其他，<code>a</code>代表所有，<code>+</code>代表增加权限，<code>-</code>代表移除权限，<code>=</code>将权限设置成后面的值，额外的第三作用符号如下</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\"><span class=\"token variable\">`</span>X<span class=\"token variable\">`</span></span> ：如果对象是目录或者它已有执行权限，赋予执行权限。\n<span class=\"token variable\"><span class=\"token variable\">`</span>s<span class=\"token variable\">`</span></span> ：运行时重新设置<span class=\"token environment constant\">UID</span>或GID。\n<span class=\"token variable\"><span class=\"token variable\">`</span>t<span class=\"token variable\">`</span></span> ：保留文件或目录。\n<span class=\"token variable\"><span class=\"token variable\">`</span>u<span class=\"token variable\">`</span></span> ：将权限设置为跟属主一样。\n<span class=\"token variable\"><span class=\"token variable\">`</span>g<span class=\"token variable\">`</span></span> ：将权限设置为跟属组一样。\n<span class=\"token variable\"><span class=\"token variable\">`</span>o<span class=\"token variable\">`</span></span> ：将权限设置为跟其他用户一样</code></pre>\n</li>\n<li><p>chown 改文件所属<br><code>chown option owner file[.group] file</code><br><code>chown owner.group file</code>直接改属主和组<br><code>chown owner .</code> 属主和组都同名<br><code>chgrp</code> 更改文件目录的默认属组</p>\n</li>\n</ul>\n<h2 id=\"7-5-共享文件\"><a href=\"#7-5-共享文件\" class=\"headerlink\" title=\"7.5 共享文件\"></a>7.5 共享文件</h2><p>Linux还为每个文件和目录存储了3个额外的信息位。</p>\n<ul>\n<li>设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。</li>\n<li>设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。</li>\n<li>粘着位：进程结束后文件还驻留（粘着）在内存中。<br>如果你用的是八进制模式，你需要知道这些位的位置</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>二进制值</th>\n<th>八进制值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>000</td>\n<td>0</td>\n<td>所有位都清零</td>\n</tr>\n<tr>\n<td>001</td>\n<td>1</td>\n<td>粘着位置位</td>\n</tr>\n<tr>\n<td>010</td>\n<td>2</td>\n<td>SGID位置位</td>\n</tr>\n<tr>\n<td>011</td>\n<td>3</td>\n<td>SGID位和粘着位都置位</td>\n</tr>\n<tr>\n<td>100</td>\n<td>4</td>\n<td>SUID位置位</td>\n</tr>\n<tr>\n<td>101</td>\n<td>5</td>\n<td>SUID位和粘着位都置位</td>\n</tr>\n<tr>\n<td>110</td>\n<td>6</td>\n<td>SUID位和SGID位都置位</td>\n</tr>\n<tr>\n<td>111</td>\n<td>7</td>\n<td>所有位都置位</td>\n</tr>\n</tbody></table>\n<p>首先，用 <code>mkdir</code> 命令来创建希望共享的目录。然后通过 <code>chgrp</code> 命令将目录的默认属组改为包<br>含所有需要共享文件的用户的组（你必须是该组的成员）。最后，将目录的SGID位置位，以保证<br>目录中新建文件都用shared作为默认属组  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">mkdir</span> testdir\n$ <span class=\"token function\">ls</span> -l\ndrwxrwxr-x <span class=\"token number\">2</span> rich rich <span class=\"token number\">4096</span> Sep <span class=\"token number\">20</span> <span class=\"token number\">23</span>:12 testdir/\n$ <span class=\"token function\">chgrp</span> shared testdir\n$ <span class=\"token function\">chmod</span> g+s testdir  // <span class=\"token function\">chmod</span> <span class=\"token number\">6770</span> testdir\n$ <span class=\"token function\">ls</span> -l\ndrwxrwsr-x <span class=\"token number\">2</span> rich shared <span class=\"token number\">4096</span> Sep <span class=\"token number\">20</span> <span class=\"token number\">23</span>:12 testdir/\n$ <span class=\"token builtin class-name\">umask</span> 002\n$ <span class=\"token builtin class-name\">cd</span> testdir\n$ <span class=\"token function\">touch</span> testfile\n$ <span class=\"token function\">ls</span> -l\ntotal <span class=\"token number\">0</span>\n-rw-rw-r-- <span class=\"token number\">1</span> rich shared <span class=\"token number\">0</span> Sep <span class=\"token number\">20</span> <span class=\"token number\">23</span>:13 testfile\n</code></pre>\n\n<h1 id=\"9-安装软件程序\"><a href=\"#9-安装软件程序\" class=\"headerlink\" title=\"9. 安装软件程序\"></a>9. 安装软件程序</h1><h2 id=\"9-1-包管理工具\"><a href=\"#9-1-包管理工具\" class=\"headerlink\" title=\"9.1 包管理工具\"></a>9.1 包管理工具</h2><p>管理版本</p>\n<h2 id=\"9-2-基于Debian的系统\"><a href=\"#9-2-基于Debian的系统\" class=\"headerlink\" title=\"9.2 基于Debian的系统\"></a>9.2 基于Debian的系统</h2><p>基于 Debian 的系统</p>\n<ul>\n<li>dpkg 包管理工具</li>\n<li>apt</li>\n<li>apt-get</li>\n<li>aptitude</li>\n</ul>\n<h3 id=\"9-2-1-用aptitude-管理软件包\"><a href=\"#9-2-1-用aptitude-管理软件包\" class=\"headerlink\" title=\"9.2.1 用aptitude 管理软件包\"></a>9.2.1 用aptitude 管理软件包</h3><p><code>apt</code>,<code>dpkg</code>是包管理工具，<code>aptitude</code>是完整的软件包管理系统</p>\n<ol>\n<li>aptitude show wine  显示包wine的详细信息</li>\n<li>aptitude install package_name</li>\n<li>aptitude search package_name<br> 如果看到一个 <code>i</code> ，说明这个包现在已经安装到了你的系统上了。如果看到一个 <code>p</code> 或 <code>v</code> ，说明这个包可用，但还没安装</li>\n<li>aptitude safe-upgrade</li>\n<li>aptitude remove&#x2F;purge package_name</li>\n<li><code>/etc/apt/sources.list</code>前面有deb说明是编译过的，deb-src是源代码，package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。你可以看到诸如main、restricted、universe和partner这样的值</li>\n</ol>\n<p>dpkg -L vim  显示vim的所有安装信息<br>dpkg –search vim</p>\n<h2 id=\"9-3-基于源码安装\"><a href=\"#9-3-基于源码安装\" class=\"headerlink\" title=\"9.3 基于源码安装\"></a>9.3 基于源码安装</h2><p>C++编译要使用CMake</p>\n<h1 id=\"10-使用编辑器\"><a href=\"#10-使用编辑器\" class=\"headerlink\" title=\"10. 使用编辑器\"></a>10. 使用编辑器</h1><h2 id=\"10-1-vim-编辑器\"><a href=\"#10-1-vim-编辑器\" class=\"headerlink\" title=\"10.1 vim 编辑器\"></a>10.1 vim 编辑器</h2><ol>\n<li><p>移动光标</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">文件很大,用方向键移动\ngg 移动到最后一行\nnum G 移动到指定行数\nG 移动到第一行\nw file_name 将文件保存到另一个文件中\nPagedown + Pageup 翻页\nw file_name 保存为另一个文件\n</code></pre>\n</li>\n<li><p>编辑数据</p>\n<pre class=\"language-none\"><code class=\"language-none\">\nx 删除光标当前所在字符(剪切)\ndd 是切除当前行, p 是粘贴(剪切)\ndw 删除光标当前所在当前字符(剪切)\nyw 复制一个单词  y$复制整个行\nu 撤销\na 在文件尾追加数据\nA 在当前行尾追加数据\nr char 用char 替换当前光标位置字符\nR char 用text文本替换当前文本字符\n</code></pre></li>\n<li><p>替换数据</p>\n  <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">:s/old/new/  替换数据\n:s/olr/new/g  替换文件中一行所有old\n:m,ns/old/new/g 替换行号之间的所有old\n<span class=\"token builtin class-name\">:</span><span class=\"token variable\">$s</span>/old/new/g 替换整个文件中的old\n<span class=\"token builtin class-name\">:</span><span class=\"token variable\">$s</span>/old/new/gc 替换整个文件中的old，但是每次都提醒</code></pre></li>\n</ol>\n<h1 id=\"11-基本脚本\"><a href=\"#11-基本脚本\" class=\"headerlink\" title=\"11.基本脚本\"></a>11.基本脚本</h1><ul>\n<li><p>创建shell脚本<br><code>#!/bin/bash</code>,bash找你的文件都是从path目录下，如果没有设置path目录那么就需要通过绝对路径和相对路径引用你的命令。然后是注意你的文件权限<code>umask</code>决定了你文件创建时候的默认权限</p>\n</li>\n<li><p>文本信息<br>echo可使用单引号和双引号来划定文本字符串</p>\n<ol>\n<li><code>echo  &quot;This is a test to see if you&#39;re paying attention&quot;</code>  文本中有单引号</li>\n<li><code>echo  &#39;Rich says &quot;scripting is easy&quot;.&#39;</code> 文本中有双引号</li>\n<li>如果是单&#x2F;双引号混合会怎样？</li>\n<li>文本字符串和命令输出到同一行</li>\n</ol>\n</li>\n<li><p>使用变量</p>\n<ol>\n<li>用户变量区分大小写长度不超过20个字符</li>\n<li>变量,等号,值之间不能出现空格</li>\n<li>引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符.没有美元符号引用变量进行赋值shell就会将其理解为字符串</li>\n<li>命令替换分为<code>$()</code>和` `,testing&#x3D;$(date)他们中间没有空格.命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的.在命令行提示符下使用路径.&#x2F;运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。在命令行提示符下运行脚本时一定要留心！</li>\n<li></li>\n</ol>\n</li>\n<li><p>输入输出重定向</p>\n<ul>\n<li><code>&gt;</code>会覆盖,<code>&gt;&gt;</code>追加</li>\n<li><code>wc &lt; test6</code> 输入重定向,内联重定向<code>&lt;&lt;</code>,在命令行上使用内联输入重定向时,shell会用PS2环境变量中定义的次提示符（参见第6章）</li>\n<li>管道，Linux管道命令（断条符号）允许你将命令的输出直接重定向到另一个命令的输入。【这里的问题还很多】</li>\n</ul>\n</li>\n<li><p>执行数学计算</p>\n<ol>\n<li><code>expr</code>命令,特别注意<code>expr 1+5</code>这种是不起作用的(建议以后少用)</li>\n<li><code>$[ ]</code>对<code>expr</code>的改进,bash shell数学运算符只支持整数运算,<code>zsh</code>支持浮点运算</li>\n<li><code>bc</code>计算器<ul>\n<li><p><code>scale=4</code> 保留四位精度，<code>3.44 / 5 = .6880</code>, 支持定义变量</p>\n</li>\n<li><p>在脚本中使用<code>bc</code>,<code>variable=$(echo &quot;scale=4 ;3.44 / 5&quot; | bc)</code>,<code>var3=$(echo &quot;scale=4; $var1 / $var2&quot; | bc)</code>这里的var1和var2都是预定义的</p>\n</li>\n<li><p>将表达式定义到一个文件中，或者内联表达式</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">10.46</span> \n<span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span><span class=\"token number\">43.67</span> \n<span class=\"token assign-left variable\">var3</span><span class=\"token operator\">=</span><span class=\"token number\">33.2</span> \n<span class=\"token assign-left variable\">var4</span><span class=\"token operator\">=</span><span class=\"token number\">71</span> \n<span class=\"token assign-left variable\">var5</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">bc</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOF \nscale = 4 \na1 = ( <span class=\"token variable\">$var1</span> * <span class=\"token variable\">$var2</span>) \nb1 = (<span class=\"token variable\">$var3</span> * <span class=\"token variable\">$var4</span>) \na1 + b1 \nEOF</span> \n<span class=\"token variable\">)</span></span>\n\n<span class=\"token builtin class-name\">echo</span> The final answer <span class=\"token keyword\">for</span> this mess is <span class=\"token variable\">$var5</span></code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>退出脚本</p>\n<ol>\n<li><code>0</code>成功结束，<code>1</code>一般未知错误，<code>2</code>不适合的shell命令，<code>126</code>命令不可执行,<code>127</code>没找到命令，<code>128</code>无效退出参数，<code>128+x</code>与linux信号x相关的严重错误，<code>130</code>通过ctrl+退出，<code>255</code>正常范围之外的退出状态码</li>\n<li><code>exit</code>退出命令，可以自定义状态码，退出状态码最大只能是255，所以超过255会进行模运算</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"12-使用结构化命令\"><a href=\"#12-使用结构化命令\" class=\"headerlink\" title=\"12. 使用结构化命令\"></a>12. 使用结构化命令</h1><ul>\n<li><p>if statement</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">## style 1</span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">pwd</span>\n<span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it works\"</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">## style 2</span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">pwd</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it works\"</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token comment\"># style 3 </span>\n<span class=\"token comment\">## 如果grep返回0 就去执行echo statement</span>\n<span class=\"token keyword\">if</span> <span class=\"token function\">grep</span> <span class=\"token variable\">$testuser</span> /etc/passwd\n<span class=\"token keyword\">then</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"this is my first command\"</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"this is my second command\"</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">## if elif else  ,在elif语句中，紧跟其后的else语句属于elif代码块。它们并不属于之前的if-then代码块 </span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">pwd</span> \n<span class=\"token keyword\">then</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">else</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">elif</span> <span class=\"token builtin class-name\">command</span>  <span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">else</span>  <span class=\"token keyword\">fi</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span>\n<span class=\"token keyword\">fi</span>\n</code></pre>\n</li>\n<li><p>test命令</p>\n<p>如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。支持符合条件检查</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">## 单一逻辑校验</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> condition <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n  commands\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">## 符合逻辑校验</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> condition1 <span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span> condition2 <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> condition <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n  commands\n<span class=\"token keyword\">fi</span></code></pre>\n\n<ul>\n<li><p>数值比较</p>\n<ul>\n<li>n1 -eq n2   等于</li>\n<li>n1 -ge n2   大于等于</li>\n<li>n1 -gt n2   大于</li>\n<li>n1 -le n2   小于等于</li>\n<li>n1 -lt n2   小于</li>\n</ul>\n</li>\n<li><p>字符串比较</p>\n<ul>\n<li>str1 &#x3D; str2 字面量相等，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内</li>\n<li>str1 !&#x3D; str2 不相等</li>\n<li>str1 &lt; str2   小于. <code>if [ $val1 &gt; $val2 ]</code>直接这样比较字符串会创建一个文件。所以必须要转义<code>if [ $val1 \\&gt; $val2 ]</code>。在比较测试中，大写字母被认为是小于小写字母的。比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果但sort命令恰好相反，本地语言设置（英语），A在a前面</li>\n<li>str1 &gt; str2   大于</li>\n<li>-n str1  判断长度是否为非零</li>\n<li>-z str1  判断长度是否为零</li>\n</ul>\n</li>\n<li><p>文件比较</p>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-d file</td>\n<td>d&#x3D;directory. 检查file是否存在并是一个目录</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>e&#x3D;exist. 检查file是否存在</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>f&#x3D;file. 检查file是否存在并是一个文件</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>r&#x3D;read. 检查file是否存在并可读</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>s&#x3D;检查file 是否存在并非空</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>w&#x3D;write. 检查file是否存在并可写</td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>检查file 是否存在并可执行</td>\n</tr>\n<tr>\n<td>-O file</td>\n<td>O&#x3D;all user 检查file是否存在并属当前用户所有</td>\n</tr>\n<tr>\n<td>-G file</td>\n<td>G&#x3D;group 检查file是否存在并且默认组与当前用户相同</td>\n</tr>\n<tr>\n<td>file1 -nt file2</td>\n<td>检查file1是否比file2新</td>\n</tr>\n<tr>\n<td>file1 -ot file2</td>\n<td>检查file1是否比file2旧</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n<li><p>(( ))和[[ ]]提供高级特性</p>\n<ul>\n<li>(( )) 提供更加方便的数学表达式计算，像其他oop语言一样</li>\n<li>[[ ]] 提供更加方便的字符串处理功能</li>\n</ul>\n</li>\n<li><p><code>case</code>命令</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">case</span> variable <span class=\"token keyword\">in</span> \npattern1 <span class=\"token operator\">|</span> pattern2 <span class=\"token punctuation\">)</span> command1<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\npattern3<span class=\"token punctuation\">)</span> command2<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n*<span class=\"token punctuation\">)</span> command3<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span>\n</code></pre></li>\n</ul>\n<h1 id=\"13-for-循环\"><a href=\"#13-for-循环\" class=\"headerlink\" title=\"13. for 循环\"></a>13. for 循环</h1><h2 id=\"13-1-for命令\"><a href=\"#13-1-for命令\" class=\"headerlink\" title=\"13.1 for命令\"></a>13.1 for命令</h2><ul>\n<li>for 基本语句</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">list</span><span class=\"token operator\">=</span><span class=\"token string\">\"Alabama Alaska Arizona Arkansas Colorado\"</span> \n<span class=\"token assign-left variable\">list</span><span class=\"token operator\">=</span><span class=\"token variable\">$list</span><span class=\"token string\">\" Connecticut\"</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">v</span> <span class=\"token keyword\">in</span> v_list\n<span class=\"token keyword\">do</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<p>v_list如果有单引号，1.用转义字符转义。2.用双引号定义用到的单引号的值。3.如果在单独的数据值中有空格，就必须用双引号将这些值圈起来，可直接拼接值。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">file</span><span class=\"token operator\">=</span><span class=\"token string\">\"path of your file\"</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">state</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">cat</span> $file<span class=\"token variable\">)</span></span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Visit beautiful <span class=\"token variable\">$state</span>\"</span> \n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<p>读取文件内容进行迭代<br>(ubuntu没有IFS环境变量和IFS.OLD)</p>\n<ul>\n<li><p>更改字段分隔符<br>默认分隔符是<code>空格</code>，<code>制表符</code>，<code>换行符</code>环境变量IFS,控制着字段分隔符，有时候想灵活一点,有些地方用的换行符，但是其他地方继续保留原先的分隔符，可使用IFS&#x3D;$’\\n’, IFS.OLD&#x3D;$IFS,IFS&#x3D;$’\\n’,但是如果想加入冒号作为换行符可以更改<code>/etc/passwd</code>文件加上IFS&#x3D;:,如果想加多个可以依次在后面加IFS&#x3D;’\\n’:;”</p>\n</li>\n<li><p>通配符</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#!bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> /home/rich/test/* \n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -d <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span> \n  <span class=\"token keyword\">then</span> \n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a directory\"</span> \n  <span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> -f <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span> \n  <span class=\"token keyword\">then</span> \n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a file\"</span> \n  <span class=\"token keyword\">fi</span> \n<span class=\"token keyword\">done</span>\n<span class=\"token comment\">## 目录文件都会匹配</span>\n<span class=\"token comment\">##请注意这次条件判断有些特别使用了if [ -d \"$file\" ] 因为在linux中文件名有空格是合法的</span>\n</code></pre></li>\n</ul>\n<h2 id=\"13-2-C语言风格\"><a href=\"#13-2-C语言风格\" class=\"headerlink\" title=\"13.2 C语言风格\"></a>13.2 C语言风格</h2><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>b<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>a<span class=\"token operator\">&lt;=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>a<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span>b<span class=\"token operator\">--</span><span class=\"token punctuation\">))</span></span>\n<span class=\"token keyword\">do</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<h2 id=\"13-3-while语句\"><a href=\"#13-3-while语句\" class=\"headerlink\" title=\"13.3 while语句\"></a>13.3 while语句</h2><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> <span class=\"token boolean\">true</span>\n<span class=\"token keyword\">do</span>\n  <span class=\"token builtin class-name\">echo</span>\n\n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<p><code>break</code> 还可以指定跳出循环层数,两层<code>for</code>就跳出最内层,<code>break n</code>就会跳出.<br><code>continue</code>结束本次循环，n为1，表明跳出的是当前的循环。如果你将n设为2，break命令就会停止下一级的外部循环  </p>\n<ul>\n<li><p>处理循环中的输出</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> /home/rich/* \n<span class=\"token keyword\">do</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -d <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a directory\"</span> \n<span class=\"token keyword\">elif</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a file\"</span>  \n<span class=\"token keyword\">fi</span> \n<span class=\"token keyword\">done</span> <span class=\"token operator\">></span> output.txt</code></pre>\n</li>\n<li><p>处理多个测试命令</p>\n<p>这种情况下要注意，判断了所有条件，因为有一个条件返回为false，所以相当于逻辑<code>与</code>判断</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># testing a multicommand while loop </span>\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">10</span> \n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var1</span> \n        <span class=\"token punctuation\">[</span> <span class=\"token variable\">$var1</span> -ge <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is inside the loop\"</span> \n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$var1</span> - <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n</code></pre></li>\n</ul>\n<p>while 或者for的嵌套循环中，内部循环可以读到外部变量</p>\n<h2 id=\"13-4-until命令\"><a href=\"#13-4-until命令\" class=\"headerlink\" title=\"13.4 until命令\"></a>13.4 until命令</h2><p>有点像其他语言的<br>do …. while 语法</p>\n<h2 id=\"13-5-循环处理数据并以特定分隔符分割数据\"><a href=\"#13-5-循环处理数据并以特定分隔符分割数据\" class=\"headerlink\" title=\"13.5 循环处理数据并以特定分隔符分割数据\"></a>13.5 循环处理数据并以特定分隔符分割数据</h2><p>主要是修改IFS变量</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># changing the IFS value </span>\n<span class=\"token environment constant\">IFS</span>.OLD<span class=\"token operator\">=</span><span class=\"token environment constant\">$IFS</span> \n<span class=\"token assign-left variable\"><span class=\"token environment constant\">IFS</span></span><span class=\"token operator\">=</span><span class=\"token string\">'\\n'</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">entry</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">cat</span> /etc/passwd<span class=\"token variable\">)</span></span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Values in <span class=\"token variable\">$entry</span> –\"</span> \n <span class=\"token assign-left variable\"><span class=\"token environment constant\">IFS</span></span><span class=\"token operator\">=</span><span class=\"token string\">':'</span>\n  <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">value</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$entry</span> \n  <span class=\"token keyword\">do</span> \n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\" <span class=\"token variable\">$value</span>\"</span> \n  <span class=\"token keyword\">done</span> \n<span class=\"token keyword\">done</span> </code></pre>\n\n<h1 id=\"14-处理用户输入\"><a href=\"#14-处理用户输入\" class=\"headerlink\" title=\"14. 处理用户输入\"></a>14. 处理用户输入</h1><h2 id=\"14-1-读取参数，脚本名和测试参数\"><a href=\"#14-1-读取参数，脚本名和测试参数\" class=\"headerlink\" title=\"14.1 读取参数，脚本名和测试参数\"></a>14.1 读取参数，脚本名和测试参数</h2><ul>\n<li><p>.&#x2F;sumAB.sh  a  b  ## 这里$0是程序名, <code>$1</code>是a, <code>$2</code>是b. 超过九个就一定要花括号引用变量比如<code>$&#123;10&#125;</code>，<code>$#</code>返回参数个数， <code>$&#123;!#&#125;</code>获取最后一个参数，如果没有参数就会输出脚本名，<code>$*</code>变量会将所有参数当成单个参数,<code>$@</code>变量会组成数组，轻松访问所有的参数.</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span>\n<span class=\"token keyword\">do</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\\<span class=\"token variable\">$@</span> Parameter #<span class=\"token variable\">$count</span> = <span class=\"token variable\">$param</span>\"</span> \n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> </code></pre>\n</li>\n<li><p>如果程序名是<code>./test.sh</code>,那么echo $0 就是<code>./test.sh</code></p>\n</li>\n<li><p>如果程序名是<code>bash  /usr/lib/test.sh</code>,那么echo $0 就是<code>/usr/lib/test.sh</code></p>\n</li>\n<li><p>定义了参数位置，如果不传参会报错</p>\n</li>\n<li><p><code>name=$(basename $0)</code> 可以只返回脚本名</p>\n</li>\n<li><p><code>if [ -n &quot;$1&quot; ]</code>是指<code>$1</code>不为空</p>\n</li>\n<li><p><code>shift</code>命令会移动命令参数,<code>shift n</code>可以指定跳过<code>n</code>参数.</p>\n</li>\n</ul>\n<h2 id=\"14-2-处理选项\"><a href=\"#14-2-处理选项\" class=\"headerlink\" title=\"14.2 处理选项\"></a>14.2 处理选项</h2><p>bash命令提供了<code>选项</code>和<code>参数</code>来控制,可以通过<code>shift</code>命令来控制</p>\n<ul>\n<li><p>处理简单的选项</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># extracting command line options as parameters </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> -n <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n<span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span> \n  -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  -b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">esac</span>\n<span class=\"token builtin class-name\">shift</span> \n<span class=\"token keyword\">done</span> \n$ ./test15.sh -a -b -c -d</code></pre>\n</li>\n<li><p>分离选项和参数</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># extracting options and parameters </span>\n<span class=\"token builtin class-name\">echo</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> -n <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span> \n    -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    -b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    --<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">shift</span> \n              <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">esac</span> \n<span class=\"token builtin class-name\">shift</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$@</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Parameter #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$param</span>\"</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n$ ./test16.sh -c -a -b -- test1 test2 test3</code></pre>\n</li>\n<li><p>处理带值的选项</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># extracting command line options and values </span>\n<span class=\"token builtin class-name\">echo</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> -n <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span> \n    -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    -b<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">param</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$2</span>\"</span> \n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option, with parameter value <span class=\"token variable\">$param</span>\"</span> \n    <span class=\"token builtin class-name\">shift</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    --<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">shift</span> \n    <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n    *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">esac</span> \n  <span class=\"token builtin class-name\">shift</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Parameter #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$param</span>\"</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n$ ./test17.sh -a -b test1 -d</code></pre>\n\n<p>case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是$1，额外的参数值就应该位于$2（因为所有的参数在处理完之后都会被移出）。只要将参数值从$2变量中提取出来就可以了</p>\n</li>\n<li><p>使用getopt与getopts命令<br>getopts命令会用到两个环境变量。如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。<br>OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。<br>这样你就能在处理完选项之后继续处理其他命令行参数了。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># simple demonstration of the getopts command </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> \n  <span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">getopts</span> :ab:c opt \n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$opt</span>\"</span> <span class=\"token keyword\">in</span> \n  a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option, with value <span class=\"token variable\">$OPTARG</span>\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Unknown option: <span class=\"token variable\">$opt</span>\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">esac</span> \n<span class=\"token keyword\">done</span>\n$ <span class=\"token function\">bash</span> ./test19.sh -a -b <span class=\"token string\">\"1 2\"</span> -c  <span class=\"token comment\"># 在参数中加空格</span>\n$ <span class=\"token function\">bash</span> ./test19.sh -abtest1        <span class=\"token comment\"># 可以挨在一起</span>\n$ <span class=\"token function\">bash</span> ./test19.sh -d              <span class=\"token comment\"># 返回问号</span>\n$ <span class=\"token function\">bash</span> ./test19.sh -a -b <span class=\"token number\">456</span> -cdefg<span class=\"token comment\"># 如果有参数的就要分开写</span></code></pre>\n\n<ul>\n<li>使用OPTIND参数和OPTARG参数</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Processing options &amp; parameters with getopts </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> \n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">getopts</span> :ab:cd opt \n<span class=\"token keyword\">do</span> \n<span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$opt</span>\"</span> <span class=\"token keyword\">in</span> \n  a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option, with value <span class=\"token variable\">$OPTARG</span>\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  d<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -d option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n  *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Unknown option: <span class=\"token variable\">$opt</span>\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">esac</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">shift</span> $<span class=\"token punctuation\">[</span> <span class=\"token environment constant\">$OPTIND</span> - <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span> \n<span class=\"token keyword\">do</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Parameter <span class=\"token variable\">$count</span>: <span class=\"token variable\">$param</span>\"</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span></code></pre>\n</li>\n<li><p>选项标准化</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>显示所有对象</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>生成一个计数</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>指定一个目录</td>\n</tr>\n<tr>\n<td>-e</td>\n<td>扩展一个对象</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>指定读入数据的文件</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>显示命令的帮助信息</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>忽略文本大小写</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>产生输出的长格式版本</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>使用非交互模式（批处理）</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>将所有输出重定向到的指定的输出文件</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>以安静模式运行</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归地处理目录和文件</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>以安静模式运行</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>生成详细输出</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>排除某个对象</td>\n</tr>\n<tr>\n<td>-y</td>\n<td>对所有问题回答yes</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"14-3-获取用户输入\"><a href=\"#14-3-获取用户输入\" class=\"headerlink\" title=\"14.3 获取用户输入\"></a>14.3 获取用户输入</h2><ul>\n<li><p><code>read</code>命令，</p>\n<ul>\n<li>read命令包含了-p选项，允许你直接在read命令行指定提示符,</li>\n<li>read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量</li>\n<li><code>-t</code>代表超时</li>\n<li><code>-n 1</code>read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量</li>\n<li><code>-s</code> 选项可以避免在read命令中输入的数据出现在显示器上</li>\n<li>从文件中读取数据</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">//单个变量\n<span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"please enter your age\"</span> age\n//多个变量\n<span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"please enter your name\"</span> first last\n// 超时参数\n<span class=\"token builtin class-name\">read</span> -t <span class=\"token number\">5</span> -p \n// 获取指定字符个数\n<span class=\"token builtin class-name\">read</span> -n1  -p <span class=\"token string\">\"Do you want to continue [Y/N]?\"</span> answer\n//隐藏输入\n<span class=\"token builtin class-name\">read</span> -s -p <span class=\"token string\">\"Enter your password: \"</span> pass \n// 从文件中读取数据\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># reading data from a file </span>\n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token function\">cat</span> <span class=\"token builtin class-name\">test</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line \n<span class=\"token keyword\">do</span> \n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line <span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span> \n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Finished processing the file\"</span> </code></pre></li>\n</ul>\n<h1 id=\"15-呈现数据\"><a href=\"#15-呈现数据\" class=\"headerlink\" title=\"15. 呈现数据\"></a>15. 呈现数据</h1><p>这一章主要是讲如何将脚本输出重定型向到系统其他位置</p>\n<h2 id=\"15-1-理解输入和输出\"><a href=\"#15-1-理解输入和输出\" class=\"headerlink\" title=\"15.1 理解输入和输出\"></a>15.1 理解输入和输出</h2><h3 id=\"15-1-1-标准文件描述符\"><a href=\"#15-1-1-标准文件描述符\" class=\"headerlink\" title=\"15.1.1 标准文件描述符\"></a>15.1.1 标准文件描述符</h3><p>Linux系统将每个对象(操作的文件，linux万物皆文件)当作文件处理。这包括输入和输出进程。Linux用文件描述符（filedescriptor）来标识每个文件对象</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">文件描述符  缩 写   描 述\n<span class=\"token number\">0</span>           STDIN   标准输入\n<span class=\"token number\">1</span>           STDOUT  标准输出\n<span class=\"token number\">2</span>           STDERR  标准错误</code></pre>\n\n<ol>\n<li>STDIN实例<br><code>cat</code> 就会从STDIN输入数据，这时候你输入什么屏幕就会显示什么<br><code>cat &lt; file.txt</code>通过STDIN通过重定向符号使<code>cat</code>查看一个非STDIN文件的输入</li>\n<li>STDOUT  </li>\n<li>STDERR<br>shell通过特殊的<code>STDERR</code>文件描述符来处理错误消息。<code>STDERR</code>文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置</li>\n</ol>\n<h3 id=\"15-1-2-重定向错误\"><a href=\"#15-1-2-重定向错误\" class=\"headerlink\" title=\"15.1.2 重定向错误\"></a>15.1.2 重定向错误</h3><ol>\n<li>只重定向错误<br>通过<code>2&gt; file.txt</code>的方式将错误信息重定向到文件中</li>\n<li>重定向错误和数据<br><code>ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</code> 这种就是将<code>STDERR</code>重定向到test6,然后将<code>STDOUT</code>重定向到test7.<br>也可以将STDERR和STDOUT的输出重定向到同一个输出文件使用<code>&amp;&gt;</code>,比如<code>ls -al test test2 test3 badtest &amp;&gt; test7</code>，bash消息赋予error更高的优先级</li>\n</ol>\n<h2 id=\"15-2-在脚本中重定向输出\"><a href=\"#15-2-在脚本中重定向输出\" class=\"headerlink\" title=\"15.2 在脚本中重定向输出\"></a>15.2 在脚本中重定向输出</h2><p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>\n<ul>\n<li>临时重定向行输出</li>\n<li>永久重定向脚本中的所有命令</li>\n</ul>\n<h3 id=\"15-2-1-临时重定向\"><a href=\"#15-2-1-临时重定向\" class=\"headerlink\" title=\"15.2.1 临时重定向\"></a>15.2.1 临时重定向</h3><p>如果使用上文提到的<code>STDERR</code>重定向方法就会将全局的<code>STDERR</code>信息都重定向到文件中，但是如果只重定向自己特定某些error信息就可以使用临时重定向，必须在文件描述符数字之前加一个<code>&amp;</code></p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 举个例子 ./test8</span>\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># testing STDERR messages </span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is an error\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is normal output\"</span> </code></pre>\n\n<p>如果像平常一样运行这个脚本，你可能看不出什么区别,因为所有输出都到了STDOUT,但是默认情况下，linux会将STDERR导向STDOUT,但是，如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ./test8 <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> test9\nThis is normal output \n$ <span class=\"token function\">cat</span> test9 \nThis is an error </code></pre>\n\n<h3 id=\"15-2-2-永久重定向\"><a href=\"#15-2-2-永久重定向\" class=\"headerlink\" title=\"15.2.2 永久重定向\"></a>15.2.2 永久重定向</h3><p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可以用<code>exec</code>命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting all output to a file </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>testout \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is a test of redirecting all output\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"from a script to another file.\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"without having to redirect every individual line\"</span> </code></pre>\n\n<h2 id=\"15-3-在脚本中重定向输入\"><a href=\"#15-3-在脚本中重定向输入\" class=\"headerlink\" title=\"15.3 在脚本中重定向输入\"></a>15.3 在脚本中重定向输入</h2><p><code>exec</code>命令允许你将STDIN重定向到Linux系统上的文件中<code>exec 0&lt; testfile</code></p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># redirecting file input </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> testfile \n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> </code></pre>\n\n<h2 id=\"15-4-创建自己的重定向\"><a href=\"#15-4-创建自己的重定向\" class=\"headerlink\" title=\"15.4 创建自己的重定向\"></a>15.4 创建自己的重定向</h2><h3 id=\"15-4-1-创建输出文件描述符\"><a href=\"#15-4-1-创建输出文件描述符\" class=\"headerlink\" title=\"15.4.1 创建输出文件描述符\"></a>15.4.1 创建输出文件描述符</h3><p>可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件<br>描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。这里有个在脚本中使用其<br>他文件描述符的简单例子。(不是太理解这句话)</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#./test13</span>\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># using an alternative file descriptor </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span>test13out \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This should display on the monitor\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"and this should be stored in the file\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Then this should be back on the monitor\"</span> \n$ ./test13 </code></pre>\n\n<p>这个脚本用exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内<br>容会像预想中那样显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入<br>了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如<br>日志文件）。</p>\n<h3 id=\"15-4-2-重定向文件描述符\"><a href=\"#15-4-2-重定向文件描述符\" class=\"headerlink\" title=\"15.4.2 重定向文件描述符\"></a>15.4.2 重定向文件描述符</h3><p>现在介绍怎么恢复已重定向的文件描述符。你可以分配另外一个文件描述符给标准文件描述<br>符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用<br>该文件描述符重定向回STDOUT。听起来可能有点复杂，但实际上相当直接。这个简单的例子能<br>帮你理清楚。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># ./test14 </span>\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># storing STDOUT, then coming back to it </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>test14out \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This should store in the output file\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"along with this line.\"</span> \n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span><span class=\"token file-descriptor important\">&amp;3</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Now things should be back to normal\"</span> \n$ \n$ ./test14 \nNow things should be back to normal \n$ <span class=\"token function\">cat</span> test14out \nThis should store <span class=\"token keyword\">in</span> the output <span class=\"token function\">file</span> \nalong with this line. \n$ </code></pre>\n\n<p>这个方法可能有点叫人困惑，但这是一种在脚本中临时重定向输出，然后恢复默认输出设置<br>的常用方法。</p>\n<h3 id=\"15-4-3-创建输入文件描述符\"><a href=\"#15-4-3-创建输入文件描述符\" class=\"headerlink\" title=\"15.4.3 创建输入文件描述符\"></a>15.4.3 创建输入文件描述符</h3><p>(不是很懂)<br>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，<br>先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它<br>原来的位置</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># redirecting input file descriptors </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">6</span>&lt;</span><span class=\"token file-descriptor important\">&amp;0</span> \n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> testfile \n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span><span class=\"token file-descriptor important\">&amp;6</span> \n<span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"Are you done now? \"</span> answer \n<span class=\"token keyword\">case</span> <span class=\"token variable\">$answer</span> <span class=\"token keyword\">in</span> \nY<span class=\"token operator\">|</span>y<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Goodbye\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \nN<span class=\"token operator\">|</span>n<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Sorry, this is the end.\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">esac</span>\n</code></pre>\n\n<h3 id=\"15-4-4-创建读写文件描述符\"><a href=\"#15-4-4-创建读写文件描述符\" class=\"headerlink\" title=\"15.4.4 创建读写文件描述符\"></a>15.4.4 创建读写文件描述符</h3><p>（不是太理解）</p>\n<p>尽管看起来可能会很奇怪，但是你也可以打开单个文件描述符来作为输入和输出。可以用同<br>一个文件描述符对同一个文件进行读写。<br>不过用这种方法时，你要特别小心。由于你是对同一个文件进行数据读写，shell会维护一个<br>内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。如果不够小<br>心，它会产生一些令人瞠目的结果。看看下面这个例子。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token comment\">#!/bin/bash </span>\n<span class=\"token comment\"># testing input/output file descriptor </span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;></span> testfile \n<span class=\"token builtin class-name\">read</span> line <span class=\"token operator\">&lt;</span><span class=\"token file-descriptor important\">&amp;3</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Read: <span class=\"token variable\">$line</span>\"</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is a test line\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span> \n$ <span class=\"token function\">cat</span> testfile \nThis is the first line. \nThis is the second line. \nThis is the third line. \n\n<span class=\"token comment\">#输出</span>\n\n$ ./test16 \nRead: This is the first line. </code></pre>\n\n<h3 id=\"15-4-5-关闭文件描述符\"><a href=\"#15-4-5-关闭文件描述符\" class=\"headerlink\" title=\"15.4.5 关闭文件描述符\"></a>15.4.5 关闭文件描述符</h3><p>不懂</p>\n<h2 id=\"15-5-列出未关闭的文件描述符\"><a href=\"#15-5-列出未关闭的文件描述符\" class=\"headerlink\" title=\"15.5 列出未关闭的文件描述符\"></a>15.5 列出未关闭的文件描述符</h2><p>你能用的文件描述符只有9个，你可能会觉得这没什么复杂的。但有时要记住哪个文件描述<br>符被重定向到了哪里很难。为了帮助你理清条理，bash shell提供了<code>lsof</code>命令。<code>$$</code>可以读取当前程序运行的的PID,<code>-a</code><br>对其他两个选项的输出做AND运算  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">/usr/sbin/lsof -a -p <span class=\"token variable\">$$</span> -d <span class=\"token number\">0,1</span>,2\n<span class=\"token comment\"># lsof的默认输出</span>\nCOMMAND     正在运行的命令名的前9个字符\nPID         进程的PID \n<span class=\"token environment constant\">USER</span>        进程属主的登录名\nFD          文件描述符号以及访问类型（r代表读，w代表写，u代表读写）\nTYPE        文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）\nDEVICE      设备的设备号（主设备号和从设备号）\nSIZE        如果有的话，表示文件的大小\nNODE        本地文件的节点号\nNAME        文件名</code></pre>\n\n<p>(不是很懂)</p>\n<h2 id=\"15-6-组织命令输出\"><a href=\"#15-6-组织命令输出\" class=\"headerlink\" title=\"15.6 组织命令输出\"></a>15.6 组织命令输出</h2><p>如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这<br>会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。<br>要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名<br>字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。<br>在Linux系统上null文件的标准位置是&#x2F;dev&#x2F;null。你重定向到该位置的任何数据都会被丢掉，<br>不会显示。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token function\">cat</span> /dev/null/ <span class=\"token operator\">></span> test18\n<span class=\"token comment\"># 这时候test18文件就是空的</span>\n</code></pre>\n\n<h2 id=\"15-7-创建临时文件\"><a href=\"#15-7-创建临时文件\" class=\"headerlink\" title=\"15.7 创建临时文件\"></a>15.7 创建临时文件</h2><h3 id=\"15-7-1-创建本地临时文件\"><a href=\"#15-7-1-创建本地临时文件\" class=\"headerlink\" title=\"15.7.1 创建本地临时文件\"></a>15.7.1 创建本地临时文件</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">mktemp   kirk.XXXXXX  <span class=\"token comment\"># 这里面的XXXXXX是必须的</span></code></pre>\n\n<p>这是在本地目录创建临时文件</p>\n<h3 id=\"15-7-2-在-x2F-temp-x2F-创建临时文件\"><a href=\"#15-7-2-在-x2F-temp-x2F-创建临时文件\" class=\"headerlink\" title=\"15.7.2 在&#x2F;temp&#x2F;创建临时文件\"></a>15.7.2 在&#x2F;temp&#x2F;创建临时文件</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">mktemp -t kirk.XXXXXX</code></pre>\n\n<p>在&#x2F;temp&#x2F;目录下创建了一个临时文件夹</p>\n<h3 id=\"15-7-3-创建临时目录\"><a href=\"#15-7-3-创建临时目录\" class=\"headerlink\" title=\"15.7.3 创建临时目录\"></a>15.7.3 创建临时目录</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">mktemp -d kirk.XXXXXX</code></pre>\n\n<p>在&#x2F;temp&#x2F;目录下创建文件夹</p>\n<h2 id=\"15-8-记录消息\"><a href=\"#15-8-记录消息\" class=\"headerlink\" title=\"15.8 记录消息\"></a>15.8 记录消息</h2><p>有时候想把STDOUT输出到指定文件，又想输出到屏幕上，可以考虑使用<code>tee</code>命令,但是tee命令会覆盖以前的内容<br>但是如果你想把输出追加到文件中需要使用<code>-a</code>选项</p>\n<h2 id=\"15-9-实战\"><a href=\"#15-9-实战\" class=\"headerlink\" title=\"15.9 实战\"></a>15.9 实战</h2><p>稍后完善</p>\n<h1 id=\"16-控制脚本\"><a href=\"#16-控制脚本\" class=\"headerlink\" title=\"16. 控制脚本\"></a>16. 控制脚本</h1><h2 id=\"16-1-处理信号\"><a href=\"#16-1-处理信号\" class=\"headerlink\" title=\"16.1 处理信号\"></a>16.1 处理信号</h2><p>linux利用信号与运行在系统中的进程进行通信，</p>\n<h3 id=\"16-1-1-重温linux信号\"><a href=\"#16-1-1-重温linux信号\" class=\"headerlink\" title=\"16.1.1 重温linux信号\"></a>16.1.1 重温linux信号</h3><p>linux可以与程序产生30多种信号</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">信 号     值       描 述\n<span class=\"token number\">1</span>         SIGHUP  挂起进程\n<span class=\"token number\">2</span>         SIGINT  终止进程\n<span class=\"token number\">3</span>         SIGQUIT 停止进程\n<span class=\"token number\">9</span>         SIGKILL 无条件终止进程\n<span class=\"token number\">15</span>        SIGTERM 尽可能终止进程\n<span class=\"token number\">17</span>        SIGSTOP 无条件停止进程，但不是终止进程\n<span class=\"token number\">18</span>        SIGTSTP 停止或暂停进程，但不终止进程\n<span class=\"token number\">19</span>        SIGCONT 继续运行停止的进程</code></pre>\n\n<p>默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，<br>交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。<br>如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退<br>出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。</p>\n<h3 id=\"16-1-2-生成信号\"><a href=\"#16-1-2-生成信号\" class=\"headerlink\" title=\"16.1.2 生成信号\"></a>16.1.2 生成信号</h3><ol>\n<li>crtl+C 生成SIGINT(2)终止进程信号</li>\n<li>crtl+Z 生成SIGTSTP(17)停止shell中运行的任何进程<br>停止shell中运行的任何进程。停止（stopping）进程，跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置<br>继续运行。在16.4节中，你会了解如何重启一个已经停止的进程。可以使用<code>ps -l</code>命令来显示各进程</li>\n</ol>\n<h3 id=\"16-1-3-捕获信号\"><a href=\"#16-1-3-捕获信号\" class=\"headerlink\" title=\"16.1.3 捕获信号\"></a>16.1.3 捕获信号</h3><p>trap命令允许你来指定shell<br>脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再<br>由shell处理，而是交由本地处理。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># Testing signal trapping </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">trap</span> <span class=\"token string\">\"echo ' Sorry! I have trapped Ctrl-C'\"</span> SIGINT \n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">echo</span> This is a <span class=\"token builtin class-name\">test</span> script \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> -le <span class=\"token number\">10</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Loop #<span class=\"token variable\">$count</span>\"</span> \n <span class=\"token function\">sleep</span> <span class=\"token number\">1</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span></code></pre>\n\n<p>该脚本使用trap命令捕获信号，使我们编写的脚本处理信号而不是shell处理<br>当使用<code>ctrl-C</code>时候，我们脚本的trap命令就会处理这个SIGINT信号</p>\n<h3 id=\"16-1-4-捕获脚本退出\"><a href=\"#16-1-4-捕获脚本退出\" class=\"headerlink\" title=\"16.1.4 捕获脚本退出\"></a>16.1.4 捕获脚本退出</h3><p>除了在shell脚本中捕获退出，你也可以在shell退出时就行捕获，这是shell完成任务时一种执行命令的一种方式，要捕获shell的退出只需要在trap命令后面加上<code>EXIT</code>信号就行.</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token comment\">#!/bin/bash </span>\n<span class=\"token comment\"># Trapping the script exit </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">trap</span> <span class=\"token string\">\"echo Goodbye...\"</span> EXIT \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> -le <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Loop #<span class=\"token variable\">$count</span>\"</span> \n <span class=\"token function\">sleep</span> <span class=\"token number\">1</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\">#1. 脚本正常执行完，然后执行了trap脚本</span>\n<span class=\"token comment\">#2. ctrl-c 命令也会触发退出命令,ctrl-c之后就不会执行剩余代码。</span></code></pre>\n\n<h3 id=\"16-1-5-修改或移除捕获\"><a href=\"#16-1-5-修改或移除捕获\" class=\"headerlink\" title=\"16.1.5 修改或移除捕获\"></a>16.1.5 修改或移除捕获</h3><p>捕获或移除这节一句话概括就是设置trap命令的有效期，或者叫生命周期。也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上<br>两个破折号就行了，</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token comment\">#!/bin/bash </span>\n<span class=\"token comment\"># Modifying a set trap </span>\n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">trap</span> <span class=\"token string\">\"echo ' Sorry... Ctrl-C is trapped.'\"</span> SIGINT \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> -le <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Loop #<span class=\"token variable\">$count</span>\"</span> \n <span class=\"token function\">sleep</span> <span class=\"token number\">1</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span> \n<span class=\"token comment\"># </span>\n<span class=\"token builtin class-name\">trap</span> <span class=\"token string\">\"echo ' I modified the trap!'\"</span> SIGINT \n<span class=\"token comment\"># </span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> -le <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">do</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Second Loop #<span class=\"token variable\">$count</span>\"</span> \n <span class=\"token function\">sleep</span> <span class=\"token number\">1</span> \n <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">done</span>\n</code></pre>\n\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ./test3.sh\nLoop <span class=\"token comment\">#1 </span>\nLoop <span class=\"token comment\">#2 </span>\nLoop <span class=\"token comment\">#3 </span>\n^C Sorry<span class=\"token punctuation\">..</span>. Ctrl-C is trapped. \nLoop <span class=\"token comment\">#4 </span>\nLoop <span class=\"token comment\">#5 </span>\nSecond Loop <span class=\"token comment\">#1 </span>\nSecond Loop <span class=\"token comment\">#2 </span>\n^C I modified the trap<span class=\"token operator\">!</span> \nSecond Loop <span class=\"token comment\">#3 </span>\nSecond Loop <span class=\"token comment\">#4 </span>\nSecond Loop <span class=\"token comment\">#5 </span>\n$\n</code></pre>\n\n<p>也可以在trap命令后使用单破折号来恢复信号的默认行为<br>移除信号捕获后，脚本按照默认行为来处理SIGINT信号，也就是终止脚本运行。但如果信<br>号是在捕获被移除前接收到的，那么脚本会按照原先trap命令中的设置进行处理。<br>在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，<br>脚本会照旧执行trap中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。<br>总结:<br>修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的trap命令进行处理。trap根绝接收到信号会<br>立刻从sleep中唤醒</p>\n<h2 id=\"16-2-以后台模式运行脚本\"><a href=\"#16-2-以后台模式运行脚本\" class=\"headerlink\" title=\"16.2 以后台模式运行脚本\"></a>16.2 以后台模式运行脚本</h2><h3 id=\"16-2-1-后台运行脚本\"><a href=\"#16-2-1-后台运行脚本\" class=\"headerlink\" title=\"16.2.1 后台运行脚本\"></a>16.2.1 后台运行脚本</h3><p>当<code>&amp;</code>符放到命令后时，它会将命令和bash shell分离开来,然后给分配一个<code>调度号</code>和<code>PID号</code>,在后台模式中，<br>进程运行时不会和终端会话上的STDIN、STDOUT以及STDERR关联</p>\n<h3 id=\"16-2-2-运行多个后台作业\"><a href=\"#16-2-2-运行多个后台作业\" class=\"headerlink\" title=\"16.2.2 运行多个后台作业\"></a>16.2.2 运行多个后台作业</h3><p>当我们同时运行多个后台运行程序的时候，然后使用<code>ps</code>命令这时候发现很多进程与<code>pts/0</code>绑定着，如果终端会话退出，那么后台进程也会随之退出</p>\n<h3 id=\"16-2-3-在非控制台下运行程序\"><a href=\"#16-2-3-在非控制台下运行程序\" class=\"headerlink\" title=\"16.2.3 在非控制台下运行程序\"></a>16.2.3 在非控制台下运行程序</h3><p>有时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退<br>出了终端会话。这可以用<code>nohup</code>命令来实现.和普通后台进程一样，shell会给命令分配一个作业号，Linux系统会为其分配一个<code>PID号</code>。区<br>别在于，当你使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号。<br>由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。<br>为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为<br>nohup.out的文件中。<br>当多个命令同时使用nohup命令时候，且同时修改nohup命令的时候，他们会追加到nohup.out命令</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 命令demo</span>\n<span class=\"token function\">nohup</span> ./test1.sh <span class=\"token operator\">&amp;</span></code></pre>\n<h2 id=\"16-4-作业控制\"><a href=\"#16-4-作业控制\" class=\"headerlink\" title=\"16.4 作业控制\"></a>16.4 作业控制</h2><h3 id=\"16-4-1-查看作业\"><a href=\"#16-4-1-查看作业\" class=\"headerlink\" title=\"16.4.1 查看作业\"></a>16.4.1 查看作业</h3><p><code>jobs</code>命令可以查看分配给shell的作业，<code>jobs -l</code>可以查看完整的PID  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">参数  描述\n-l    列出进程的PID以及作业号\n-n    只列出上次shell发出的通知后改变了状态的作业\n-p    只列出作业的PID \n-r    只列出运行中的作业\n-s    只列出已停止的作业\n<span class=\"token comment\">#你可能注意到了jobs命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用</span>\n<span class=\"token comment\">#作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。</span>\n<span class=\"token comment\">#当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加</span>\n<span class=\"token comment\">#号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。</span></code></pre>\n\n<h3 id=\"16-4-2-重启停止的作业\"><a href=\"#16-4-2-重启停止的作业\" class=\"headerlink\" title=\"16.4.2 重启停止的作业\"></a>16.4.2 重启停止的作业</h3><p>在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你<br>当前工作的终端，所以在使用该功能时要小心了。<br>要以后台模式重启一个作业，可用bg命令加上作业号</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>+ Stopped ./test11.sh \n$ <span class=\"token function\">bg</span> <span class=\"token comment\"># 这时候就重启了./test11.sh 作业，以后台模式</span>\n<span class=\"token comment\"># 如果重启多个就是用bg 2</span>\n<span class=\"token comment\"># 要以前台模式重启作业，可用带有作业号的fg命令。</span>\n</code></pre>\n\n<h2 id=\"16-5-调整谦让度\"><a href=\"#16-5-调整谦让度\" class=\"headerlink\" title=\"16.5 调整谦让度\"></a>16.5 调整谦让度</h2><ol>\n<li>在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调<br>度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统<br>中，由shell启动的所有进程的调度优先级默认都是相同的。  </li>\n<li>调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell<br>以优先级0来启动所有进程。<br>最低值20是最高优先级，而最高值19是最低优先级，这太容易记混了。只要记住那句俗<br>语“好人难做”就行了。  </li>\n<li>有时你想要改变一个shell脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他<br>进程过多的处理能力），还是给予它更高的优先级（这样它就能获得更多的处理时间），你都可以<br>通过nice命令做到。</li>\n</ol>\n<h3 id=\"16-5-1-nice-命令\"><a href=\"#16-5-1-nice-命令\" class=\"headerlink\" title=\"16.5.1 nice 命令\"></a>16.5.1 nice 命令</h3><p>nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice<br>的-n命令行来指定新的优先级级别。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">nice</span> -n <span class=\"token number\">10</span> ./test4.sh <span class=\"token operator\">></span> test4.out <span class=\"token operator\">&amp;</span>  <span class=\"token comment\"># 注意，必须将nice命令和要启动的命令放在同一行中。</span></code></pre>\n\n<p>一旦用nice命令设置了优先级，就不可以用nice重新设置优先级</p>\n<h3 id=\"16-5-2-renice-命令\"><a href=\"#16-5-2-renice-命令\" class=\"headerlink\" title=\"16.5.2 renice 命令\"></a>16.5.2 renice 命令</h3><p>有时你想改变系统上已运行命令的优先级。这正是renice命令可以做到的。它允许你指定<br>运行进程的PID来改变它的优先级。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">renice</span> -n <span class=\"token number\">10</span> -p <span class=\"token number\">5055</span> <span class=\"token comment\"># -p应该是指进程</span></code></pre>\n\n<p>renice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一<br>些限制:  </p>\n<ul>\n<li>只能对属于你的进程执行renice；</li>\n<li>只能通过renice降低进程的优先级；</li>\n<li>root用户可以通过renice来任意调整进程的优先级。<br>如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令</li>\n</ul>\n<h2 id=\"16-6-定时运行作业\"><a href=\"#16-6-定时运行作业\" class=\"headerlink\" title=\"16.6 定时运行作业\"></a>16.6 定时运行作业</h2><h3 id=\"16-6-1-用at命令来计划执行作业\"><a href=\"#16-6-1-用at命令来计划执行作业\" class=\"headerlink\" title=\"16.6.1 用at命令来计划执行作业\"></a>16.6.1 用at命令来计划执行作业</h3><ol>\n<li><p>at命令的格式<br> at命令只执行一次，区别于cron</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">at <span class=\"token punctuation\">[</span>-f filename<span class=\"token punctuation\">]</span> <span class=\"token function\">time</span> <span class=\"token comment\"># -f 后面用来指定读取命令</span></code></pre>\n\n<p> time : 参数指定运行时间，如果错过就会在第二天同一时间再运行<br> time能识别多种时间格式</p>\n<ul>\n<li>标准小时和分钟的格式，比如10：15</li>\n<li>AM&#x2F;PM指示符，比如10：15PM</li>\n<li>特定可命名时间，比如now,noon,midnight,或者teatime(4 PM)</li>\n<li>标准日期格式，比如MMDDYY,MM&#x2F;DD&#x2F;YY,DD.MM.YY</li>\n<li>文本日期比如jul 4或Dec 25 加不加年份都可以。</li>\n<li>你也可以指定增量时间<ul>\n<li>当前时间+25 min</li>\n<li>明天10：15 PM</li>\n<li>10：15+7天<br> 通过<code>at</code>命令都会被提交到作业队列，针对不同的优先级存在26种不同的作业队列，使用<br> a-z和A-Z来指代，即使通过at命令提交过作业，也可以通过-q参数指定不同的队列字母<br> 作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的<br> 作业会被提交到a作业队列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>获取作业的输出<br>at命令利用sendemail应用程序发送邮件，这样其实很麻烦，但是可以将输出重定向到STDOUT<br>和STDERR,再如果可以使用<code>-M</code>屏蔽输出</p>\n</li>\n<li><p>列出等待的作业<br>atq命令可以查看系统中哪些作业处于等待状态</p>\n</li>\n<li><p>删除作业<br>atrm删除等待种的作业</p>\n</li>\n</ol>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#demo</span>\natq 命令可以列出作业编号\natrm 作业编号 <span class=\"token comment\"># 只能删除你提交的作业，不能删除其他人的。</span></code></pre>\n\n<h3 id=\"16-6-2-安排需要定期执行的脚本\"><a href=\"#16-6-2-安排需要定期执行的脚本\" class=\"headerlink\" title=\"16.6.2 安排需要定期执行的脚本\"></a>16.6.2 安排需要定期执行的脚本</h3><ol>\n<li><p>cron时间表</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">min hour dayofmonth month dayofweek <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p> 比如你想每天10：15运行一个命令可以使用cron时间表条目</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">min hour dayofmonth  month dayofweek  <span class=\"token builtin class-name\">command</span>\n<span class=\"token number\">15</span>  <span class=\"token number\">10</span>   *           *     *          <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p> 但是如果想在每周一的下午4点15分执行，可写为</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">15</span> <span class=\"token number\">16</span> * * <span class=\"token number\">1</span> <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p> 可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）<br> 或数值（0为周日，6为周六）,dayofmonth表项指定月份中的日期值（1~31）。</p>\n<p> 聪明的读者可能会问如何设置一个在每个月的最后一天执行的命令，因为你无法设置<br> dayofmonth的值来涵盖所有的月份。这个问题困扰着Linux和Unix程序员，也激发了不少解<br> 决办法。常用的方法是加一条使用date命令的if-then语句来检查明天的日期是不是01：</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">00 <span class=\"token number\">12</span> * * * <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> +%d -d tomorrow<span class=\"token variable\">`</span></span> <span class=\"token operator\">=</span> 01 <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p> 它会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。</p>\n<p> 命令必须要指定要运行的脚本名字，或者添加重定向符号<br> cron程序会用提交作业的用户账户运行该脚本。因此，你必须有访问该命令和命令中指定的<br> 输出文件的权限。</p>\n</li>\n<li><p>构建cron时间表<br>可以使用crontab -l来处理cron时间表<br>默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。<br>在添加条目时，crontab命令会启用一个文本编辑器（参见第10章），使用已有的cron时间表作<br>为文件内容（或者是一个空文件，如果时间表不存在的话）。</p>\n</li>\n<li><p>浏览cron目录</p>\n<p> 如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个<br> 基本目录：hourly、daily、monthly和weekly。</p>\n<ul>\n<li>&#x2F;etc&#x2F;cron.daily</li>\n<li>&#x2F;etc&#x2F;cron.hourly</li>\n<li>&#x2F;etc&#x2F;cron.monthly</li>\n<li>&#x2F;etc&#x2F;cron.weekly<br> 因此，如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它</li>\n</ul>\n</li>\n<li><p>anacron程序<br>如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么<br>这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问<br>题，许多Linux发行版还包含了anacron程序。<br>anacron<br>程序只会处理位于cron目录的程序，比如&#x2F;etc&#x2F;cron.monthly。它用时间戳来决定作业<br>是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于&#x2F;var&#x2F;spool&#x2F;anacron。</p>\n</li>\n</ol>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">cat</span> /var/spool/anacron/cron.monthly\n<span class=\"token number\">20150626</span></code></pre>\n\n<p>anacron程序使用自己的时间表（通常位于&#x2F;etc&#x2F;anacrontab）来检查作业目录。<br>anacron时间表的基本格式和cron时间表略有不同：</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">period delay identifier <span class=\"token builtin class-name\">command</span></code></pre>\n\n<p>period条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间<br>戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。<br>command条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的<br>任何脚本。<br>注意，anacron不会运行位于&#x2F;etc&#x2F;cron.hourly的脚本。这是因为anacron程序不会处理执行时间<br>需求小于一天的脚本。<br>identifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误<br>邮件中的作业。</p>\n<h3 id=\"16-6-3-使用新shell启动脚本\"><a href=\"#16-6-3-使用新shell启动脚本\" class=\"headerlink\" title=\"16.6.3 使用新shell启动脚本\"></a>16.6.3 使用新shell启动脚本</h3><p>.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是<br>当你登入bash shell时，另一次是当你启动一个bash shell时。如果你需要一个脚本在两个时刻都得<br>以运行，可以把这个脚本放进该文件中。</p>\n<h1 id=\"17-创建函数\"><a href=\"#17-创建函数\" class=\"headerlink\" title=\"17. 创建函数\"></a>17. 创建函数</h1><h2 id=\"17-1-基本的脚本函数\"><a href=\"#17-1-基本的脚本函数\" class=\"headerlink\" title=\"17.1 基本的脚本函数\"></a>17.1 基本的脚本函数</h2><h3 id=\"17-1-1-创建函数\"><a href=\"#17-1-1-创建函数\" class=\"headerlink\" title=\"17.1.1 创建函数\"></a>17.1.1 创建函数</h3><p>有两种方式定义函数  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> <span class=\"token function-name function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">command</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>另一种更像是高级编程语言定义函数  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function-name function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">command</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h3 id=\"17-1-2-使用函数\"><a href=\"#17-1-2-使用函数\" class=\"headerlink\" title=\"17.1.2 使用函数\"></a>17.1.2 使用函数</h3><p>正常情况就像是其他高级语言一样，但是bash的函数有个特殊情况。如果是重定义了一个旧函数，<br>那么就会覆盖以前的定义,正如下面的例子</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># testing using a duplicate function name </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is the first definition of the function name\"</span> \n<span class=\"token punctuation\">&#125;</span> \nfunc1 \n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is a repeat of the same function name\"</span> \n<span class=\"token punctuation\">&#125;</span> \nfunc1 \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is the end of the script\"</span>\n</code></pre>\n\n<h2 id=\"17-2-返回值\"><a href=\"#17-2-返回值\" class=\"headerlink\" title=\"17.2 返回值\"></a>17.2 返回值</h2><h3 id=\"17-2-1-默认退出状态码\"><a href=\"#17-2-1-默认退出状态码\" class=\"headerlink\" title=\"17.2.1 默认退出状态码\"></a>17.2.1 默认退出状态码</h3><p>即使是在函数中，command1,command2,command3 中的1，2执行错误，3成功了，那么退出<br>状态码也是0.所以说默认退出状态码是很危险的。</p>\n<h3 id=\"17-2-2-使用return命令\"><a href=\"#17-2-2-使用return命令\" class=\"headerlink\" title=\"17.2.2 使用return命令\"></a>17.2.2 使用return命令</h3><p>return的demo如下</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using the return command in a function </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">dbl</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"Enter a value: \"</span> value \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"doubling the value\"</span> \n <span class=\"token builtin class-name\">return</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \ndbl \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new value is <span class=\"token variable\">$?</span>\"</span>\n</code></pre>\n\n<p>dbl函数会将$value的值翻倍，然后返回，有两点要小心</p>\n<ul>\n<li>记住，函数一结束就取返回值</li>\n<li>记住，退出码必须是0~255</li>\n</ul>\n<p>也可以返回字符串和较大的数值，可以看下一节</p>\n<h3 id=\"17-2-3-使用函数输出\"><a href=\"#17-2-3-使用函数输出\" class=\"headerlink\" title=\"17.2.3 使用函数输出\"></a>17.2.3 使用函数输出</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using the echo to return a value </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">dbl</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"Enter a value: \"</span> value \n <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>dbl<span class=\"token variable\">)</span></span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new value is <span class=\"token variable\">$result</span>\"</span>\n\n<span class=\"token comment\">#$ ./test5b</span>\n<span class=\"token comment\">#Enter a value: 200 </span>\n<span class=\"token comment\">#The new value is 400</span></code></pre>\n\n<p>可以看到是将一函数结果执行取值运算得到返回值。<br>通过这种技术，你还可以返回浮点值和字符串值。这使它成为一种获取函数返回值的强<br>大方法。</p>\n<h2 id=\"17-3-在函数中使用变量\"><a href=\"#17-3-在函数中使用变量\" class=\"headerlink\" title=\"17.3 在函数中使用变量\"></a>17.3 在函数中使用变量</h2><h3 id=\"17-3-1-向函数传递参数\"><a href=\"#17-3-1-向函数传递参数\" class=\"headerlink\" title=\"17.3.1 向函数传递参数\"></a>17.3.1 向函数传递参数</h3><p>错误传递参数代码</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># trying to access script parameters inside a function </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">badfunc1</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> -eq <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n <span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>badfunc1<span class=\"token variable\">)</span></span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$value</span>\"</span> \n<span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage: badtest1 a b\"</span> \n<span class=\"token keyword\">fi</span> \n<span class=\"token comment\"># $ ./badtest1</span>\n<span class=\"token comment\"># Usage: badtest1 a b </span>\n<span class=\"token comment\"># $ ./badtest1 10 15 </span>\n<span class=\"token comment\"># ./badtest1: * : syntax error: operand expected (error token is \"* </span>\n<span class=\"token comment\"># \") </span>\n<span class=\"token comment\"># The result is </span>\n<span class=\"token comment\"># 脚本的$1和$2和函数调用的$1,$2变量是不一样的</span></code></pre>\n\n<p>接下来是正确的代码</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># trying to access script parameters inside a function </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func7</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> -eq <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n <span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>func7 $1 $2<span class=\"token variable\">)</span></span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$value</span>\"</span> \n<span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage: badtest1 a b\"</span> \n<span class=\"token keyword\">fi</span> \n<span class=\"token comment\">#$ </span>\n<span class=\"token comment\">#$ ./test7 </span>\n<span class=\"token comment\">#Usage: badtest1 a b </span>\n<span class=\"token comment\">#$ ./test7 10 15 </span>\n<span class=\"token comment\">#The result is 150 </span>\n</code></pre>\n\n<p>通过将$1和$2变量传给函数，它们就能跟其他变量一样供函数使用了</p>\n<h3 id=\"17-3-2-在函数中处理变量\"><a href=\"#17-3-2-在函数中处理变量\" class=\"headerlink\" title=\"17.3.2 在函数中处理变量\"></a>17.3.2 在函数中处理变量</h3><ul>\n<li>全局变量<br>全局变量被覆盖</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># demonstrating a bad use of variables </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> + <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> \n<span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token number\">6</span> \nfunc1 \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> -gt <span class=\"token variable\">$value</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is larger\"</span> \n<span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is smaller\"</span> \n<span class=\"token keyword\">fi</span> \n\n<span class=\"token comment\">#$ ./badtest2</span>\n<span class=\"token comment\">#The result is 22 </span>\n<span class=\"token comment\">#temp is larger </span>\n<span class=\"token comment\"># 说明TEMP变量受到了影响，读和写都是改变的全局变量</span></code></pre>\n\n<ul>\n<li>局部变量<br>local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，<br>那么shell将会保持这两个变量的值是分离的</li>\n</ul>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># demonstrating the local keyword </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> + <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span> \n <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> \n<span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token number\">6</span> \nfunc1 \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> -gt <span class=\"token variable\">$value</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">then</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is larger\"</span> \n<span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is smaller\"</span> \n<span class=\"token keyword\">fi</span> \n<span class=\"token comment\">#$ ./test9</span>\n<span class=\"token comment\">#The result is 22 </span>\n<span class=\"token comment\">#temp is smaller </span></code></pre>\n\n<p>if里面的$temp参数是全局的，因为已经在函数外</p>\n<h2 id=\"17-4-数组变量和函数\"><a href=\"#17-4-数组变量和函数\" class=\"headerlink\" title=\"17.4 数组变量和函数\"></a>17.4 数组变量和函数</h2><p>直接传入只会传入数组的第一个值，可考虑如下方法</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash </span>\n<span class=\"token comment\"># array variable to function test </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">testit</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">local</span> newarray \n <span class=\"token assign-left variable\">newarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token string\">'echo \"$@\"'</span><span class=\"token punctuation\">)</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new array value is: <span class=\"token variable\">$&#123;newarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">myarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The original array is <span class=\"token variable\">$&#123;myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \ntestit <span class=\"token variable\">$&#123;myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span> \n<span class=\"token comment\">#$ </span>\n<span class=\"token comment\">#$ ./test10 </span>\n<span class=\"token comment\">#The original array is 1 2 3 4 5 </span>\n<span class=\"token comment\">#The new array value is: 1 2 3 4 5 </span>\n</code></pre>\n<p>第二种也可以</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># adding values in an array </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">addarray</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> \n <span class=\"token builtin class-name\">local</span> newarray \n <span class=\"token assign-left variable\">newarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">)</span> \n <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">value</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$&#123;newarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span> \n <span class=\"token keyword\">do</span> \n      <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$sum</span> + <span class=\"token variable\">$value</span> <span class=\"token punctuation\">]</span> \n <span class=\"token keyword\">done</span>\n <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$sum</span> \n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token assign-left variable\">myarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The original array is: <span class=\"token variable\">$&#123;myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \n<span class=\"token assign-left variable\">arg1</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">&#123;</span>myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#125;</span><span class=\"token variable\">)</span></span> \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>addarray $arg1<span class=\"token variable\">)</span></span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span> \n\n<span class=\"token comment\">#$ ./test11 </span>\n<span class=\"token comment\">#The original array is: 1 2 3 4 5 </span>\n<span class=\"token comment\">#The result is 15 </span></code></pre>\n\n<h3 id=\"17-4-2-从函数中返回数组\"><a href=\"#17-4-2-从函数中返回数组\" class=\"headerlink\" title=\"17.4.2 从函数中返回数组\"></a>17.4.2 从函数中返回数组</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># returning an array value </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">arraydblr</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token builtin class-name\">local</span> origarray \n <span class=\"token builtin class-name\">local</span> newarray \n <span class=\"token builtin class-name\">local</span> elements \n <span class=\"token builtin class-name\">local</span> i \n <span class=\"token assign-left variable\">origarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">)</span> \n <span class=\"token assign-left variable\">newarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">)</span> \n <span class=\"token assign-left variable\">elements</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> - <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n <span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> $elements<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">))</span></span> \n <span class=\"token punctuation\">&#123;</span> \n newarray<span class=\"token punctuation\">[</span><span class=\"token variable\">$i</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$&#123;origarray<span class=\"token punctuation\">[</span>$i<span class=\"token punctuation\">]</span>&#125;</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span> \n <span class=\"token punctuation\">&#125;</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$&#123;newarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token assign-left variable\">myarray</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The original array is: <span class=\"token variable\">$&#123;myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \n<span class=\"token assign-left variable\">arg1</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">&#123;</span>myarray<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#125;</span><span class=\"token variable\">)</span></span> \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">$(</span>arraydblr $arg1<span class=\"token variable\">)</span></span><span class=\"token punctuation\">)</span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new array is: <span class=\"token variable\">$&#123;result<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span>&#125;</span>\"</span> \n</code></pre>\n<p>arraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来<br>重新生成一个新的数组变量。</p>\n<h2 id=\"17-5-函数递归\"><a href=\"#17-5-函数递归\" class=\"headerlink\" title=\"17.5 函数递归\"></a>17.5 函数递归</h2><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using recursion </span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">factorial</span> <span class=\"token punctuation\">&#123;</span> \n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> -eq <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n <span class=\"token keyword\">then</span> \n <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> \n <span class=\"token keyword\">else</span> \n <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> - <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span> \n <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>factorial $temp<span class=\"token variable\">)</span></span> \n <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$result</span> * <span class=\"token variable\">$1</span> <span class=\"token punctuation\">]</span> \n<span class=\"token keyword\">fi</span> \n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token builtin class-name\">read</span> -p <span class=\"token string\">\"Enter value: \"</span> value \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>factorial $value<span class=\"token variable\">)</span></span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The factorial of <span class=\"token variable\">$value</span> is: <span class=\"token variable\">$result</span>\"</span> \n\n<span class=\"token comment\">#$ ./test13</span>\n<span class=\"token comment\">#Enter value: 5 </span>\n<span class=\"token comment\">#The factorial of 5 is: 120 </span>\n</code></pre>\n\n<h2 id=\"17-6-创建库\"><a href=\"#17-6-创建库\" class=\"headerlink\" title=\"17.6 创建库\"></a>17.6 创建库</h2><p>问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using a library file the wrong way </span>\n./myfuncs \n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>addem <span class=\"token number\">10</span> <span class=\"token number\">15</span><span class=\"token variable\">)</span></span> \n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span>\n\n$ ./badtest4 \n./badtest4: addem: <span class=\"token builtin class-name\">command</span> not found \nThe result is </code></pre>\n\n<p>使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是<br>创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p>\n<h2 id=\"17-7-在命令行上使用函数\"><a href=\"#17-7-在命令行上使用函数\" class=\"headerlink\" title=\"17.7 在命令行上使用函数\"></a>17.7 在命令行上使用函数</h2><p>和在shell脚本中将脚本函数当命令使用一样，在命令行界面中你也可以这样做。这个功能很，不错，因为一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数。有几种方法可以实现。</p>\n<h3 id=\"17-7-1-在命令上创建函数\"><a href=\"#17-7-1-在命令上创建函数\" class=\"headerlink\" title=\"17.7.1 在命令上创建函数\"></a>17.7.1 在命令上创建函数</h3><ul>\n<li><p>简单点直接定义 <code>function divem &#123; echo $[ $1 / $2 ]; &#125; </code></p>\n</li>\n<li><p>另一种采用多行式</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token keyword\">function</span> <span class=\"token function-name function\">multem</span> <span class=\"token punctuation\">&#123;</span> \n<span class=\"token operator\">></span> <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token operator\">></span> <span class=\"token punctuation\">&#125;</span> \n$ multem <span class=\"token number\">2</span> <span class=\"token number\">5</span> </code></pre></li>\n</ul>\n<h3 id=\"17-7-2-在-bashrc-文件中定义函数\"><a href=\"#17-7-2-在-bashrc-文件中定义函数\" class=\"headerlink\" title=\"17.7.2 在.bashrc 文件中定义函数\"></a>17.7.2 在.bashrc 文件中定义函数</h3><ol>\n<li><p>直接定义函数</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> .bashrc\n<span class=\"token comment\"># .bashrc </span>\n<span class=\"token comment\"># Source global definitions </span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -r /etc/bashrc <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span> \n<span class=\"token builtin class-name\">.</span> /etc/bashrc \n<span class=\"token keyword\">fi</span> \n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">addem</span> <span class=\"token punctuation\">&#123;</span> \n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> </code></pre>\n</li>\n<li><p>读取函数文件<br>直接定义在特地的文件内，然后读取在<code>.bashrc</code>中读取</p>\n</li>\n</ol>\n<h2 id=\"17-8-实例\"><a href=\"#17-8-实例\" class=\"headerlink\" title=\"17.8 实例\"></a>17.8 实例</h2><h3 id=\"17-8-1-下载安装第三方库\"><a href=\"#17-8-1-下载安装第三方库\" class=\"headerlink\" title=\"17.8.1 下载安装第三方库\"></a>17.8.1 下载安装第三方库</h3><h3 id=\"17-8-2-构建库\"><a href=\"#17-8-2-构建库\" class=\"headerlink\" title=\"17.8.2 构建库\"></a>17.8.2 构建库</h3><p>下载，编译，安装。这里面涉及到<code>CMAKE</code>的相关知识</p>\n<h3 id=\"17-8-3-shtool库函数\"><a href=\"#17-8-3-shtool库函数\" class=\"headerlink\" title=\"17.8.3 shtool库函数\"></a>17.8.3 shtool库函数</h3><p>这里就是介绍些shtool提供的一些函数，后面会很有用，但是需要与公司内的环境做适配</p>\n<h3 id=\"17-8-4-使用库\"><a href=\"#17-8-4-使用库\" class=\"headerlink\" title=\"17.8.4 使用库\"></a>17.8.4 使用库</h3><p>编译，安装完后，就可以在脚本中使用了</p>\n<h1 id=\"18-图形化界面中脚本编程\"><a href=\"#18-图形化界面中脚本编程\" class=\"headerlink\" title=\"18. 图形化界面中脚本编程\"></a>18. 图形化界面中脚本编程</h1><p>暂时不需要</p>\n<h1 id=\"19-初识sed和gawk\"><a href=\"#19-初识sed和gawk\" class=\"headerlink\" title=\"19.初识sed和gawk\"></a>19.初识sed和gawk</h1><p>你得熟悉Linux中的sed和gawk工具。这两个工具能够极大简化需要进行的数据处<br>理任务。</p>\n<h2 id=\"19-1-文本处理\"><a href=\"#19-1-文本处理\" class=\"headerlink\" title=\"19.1 文本处理\"></a>19.1 文本处理</h2><h3 id=\"19-1-1-sed编辑器\"><a href=\"#19-1-1-sed编辑器\" class=\"headerlink\" title=\"19.1.1 sed编辑器\"></a>19.1.1 sed编辑器</h3><p>sed编辑器被称作流编辑器（stream editor），和普通的交互式文本编辑器恰好相反。在交互式<br>文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。流编<br>辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。</p>\n<ul>\n<li>一次输入一行</li>\n<li>根据所提供的编辑器命令匹配数据。</li>\n<li>按照命令修改流中数据</li>\n<li>将最后结果输出到STDOUT</li>\n</ul>\n<blockquote>\n<p>sed  options  script  file</p>\n</blockquote>\n<p>echo ‘this is a test’ | sed  ‘s&#x2F;test&#x2F;big test&#x2F;‘  使用s命令将test替换为big test</p>\n<p>sed ‘s&#x2F;dog&#x2F;cat&#x2F;‘  data.txt    这是修改文件中dog为cat<br>sed  -e  ‘s&#x2F;brown&#x2F;red;  s&#x2F;blue&#x2F;yellow&#x2F;‘   data&#x2F;txt</p>\n<p>从文件中读取编辑器命令</p>\n<p>sed -f script.sed  data.txt</p>\n<p>gawk</p>\n<p>option</p>\n<p>-F fs  指定行中划分数据字段的字段分隔符<br>-f file  从指定的文件中读取程序<br>-v var&#x3D;value  定义gawk程序中的一个变量及其默认值<br>-mf N  指定要处理的数据文件中的最大字段数<br>-mr N  指定数据文件中的最大数据行数<br>-W keyword  指定gawk的兼容模式或警告等级</p>\n<ul>\n<li><p>从命令行读取程序脚本<br>gawk ‘{print “Hello World!”}’</p>\n</li>\n<li><p>从文件中读取数据<br>自动为文件每一行数据分配一个变量gawk ‘{print $1}’ data2.txt 数据文件中每一行的第一个字符<br>eg: gawk -F: ‘{print $1}’ &#x2F;etc&#x2F;passwd</p>\n</li>\n<li><p>在程序脚本中使用多个命令</p>\n<p>echo “my name is rich” | gawk ‘{$4&#x3D;”Christine”; print $0}’ , 给第四个字段名赋值，并输出文本名 ，如果不指定文件名就会从标准输入等待输入</p>\n</li>\n<li><p>从文件中读取程序</p>\n<p>command_gawk.gawk        gawk -F: -f  command_gawk.gawk  &#x2F;etc&#x2F;passwd</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">BEGIN <span class=\"token punctuation\">&#123;</span>\nprint <span class=\"token string\">\"The latest list of users and shells\"</span>\nprint <span class=\"token string\">\" UserID <span class=\"token entity\" title=\"\\t\">\\t</span> Shell\"</span>\nprint <span class=\"token string\">\"-------- <span class=\"token entity\" title=\"\\t\">\\t</span> -------\"</span>\n<span class=\"token assign-left variable\">FS</span><span class=\"token operator\">=</span><span class=\"token string\">\":\"</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#123;</span>\nprint <span class=\"token variable\">$NF</span> <span class=\"token string\">\" <span class=\"token entity\" title=\"\\t\">\\t</span> \"</span> <span class=\"token variable\">$7</span>\n<span class=\"token punctuation\">&#125;</span>\nEND <span class=\"token punctuation\">&#123;</span>\nprint <span class=\"token string\">\"This concludes the listing\"</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n</li>\n<li><p>在处理数据前运行脚本</p>\n<p>gawk ‘BEGIN {print “Hello World!”}’</p>\n<p>&gt;{print $0}’ data3.txt</p>\n</li>\n<li><p>处理数据后运行脚本</p>\n</li>\n</ul>\n<h2 id=\"19-2-sed-and-gawk进阶\"><a href=\"#19-2-sed-and-gawk进阶\" class=\"headerlink\" title=\"19.2 sed and gawk进阶\"></a>19.2 sed and gawk进阶</h2><p>替换标记<br>s&#x2F;pattern&#x2F;replacement&#x2F;flags</p>\n<ul>\n<li>数字， 说明新文本将替换第几处的地方</li>\n<li>g，说明文本将替换所有</li>\n<li>p, 原先行要打印</li>\n<li>w file ， 将结果输出到新文件中</li>\n<li>option 位置是 n 说明禁止输出</li>\n</ul>\n<p>替换字符<br>在替换文件路径时候涉及到转义字符这样很影响阅读性</p>\n<p>替换指定行<br>sed ‘2s&#x2F;dog&#x2F;cat&#x2F;‘ data1.txt        这个命令的意思就是将data1.txt替换第二行中的dog，替换成cat<br>sed ‘2,3s&#x2F;dog&#x2F;cat&#x2F;‘ data1.txt    以此类推是第二行，第三行<br>sed ‘2,$s&#x2F;dog&#x2F;cat&#x2F;‘ data1.txt    从第二行开始到最后一行<br>sed ‘&#x2F;Samantha&#x2F;s&#x2F;bash&#x2F;csh&#x2F;‘ &#x2F;etc&#x2F;passwd   推过模式匹配<br>sed ‘3,${<br>  s&#x2F;brown&#x2F;green&#x2F;<br>  s&#x2F;lazy&#x2F;active&#x2F;<br>  }’ data1.txt</p>\n<h1 id=\"20-正则表达式\"><a href=\"#20-正则表达式\" class=\"headerlink\" title=\"20.正则表达式\"></a>20.正则表达式</h1><h2 id=\"20-1-什么是正则表达式\"><a href=\"#20-1-什么是正则表达式\" class=\"headerlink\" title=\"20.1 什么是正则表达式\"></a>20.1 什么是正则表达式</h2><p>正则表达式就是某种模板(筛子)，正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是<br>一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。</p>\n<ul>\n<li>POSIX基础正则表达式（basic regular expression，BRE）引擎</li>\n<li>POSIX扩展正则表达式（extended regular expression，ERE）引擎</li>\n</ul>\n<h2 id=\"20-2-定义BRE模式\"><a href=\"#20-2-定义BRE模式\" class=\"headerlink\" title=\"20.2 定义BRE模式\"></a>20.2 定义BRE模式</h2><h3 id=\"20-2-1-纯文本\"><a href=\"#20-2-1-纯文本\" class=\"headerlink\" title=\"20.2.1. 纯文本\"></a>20.2.1. 纯文本</h3><p><code>echo &quot;This is a test&quot; | sed -n &#39;/this/p&#39;</code> 这里面p是print,少了-n是打印两条，this没匹配到所以没有显示<br>空格也是普通的字符，比如<code>sed -n /  /p data.set</code></p>\n<h3 id=\"20-2-2-特殊字符\"><a href=\"#20-2-2-特殊字符\" class=\"headerlink\" title=\"20.2.2 特殊字符\"></a>20.2.2 特殊字符</h3><p><code>echo &quot;3 / 2&quot; | sed -n &#39;///p&#39;</code> 正斜线也需要转义字符，故正确的是<code>echo &quot;3 / 2&quot; | sed -n &#39;/\\//p&#39;</code></p>\n<h3 id=\"20-2-3-锚定字符\"><a href=\"#20-2-3-锚定字符\" class=\"headerlink\" title=\"20.2.3 锚定字符\"></a>20.2.3 锚定字符</h3><ol>\n<li><p><code>^</code>锚定字符<br>主要是锚定字符串行首。如果模式出现在行首之外的位置则不匹配，如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了<code>echo &quot;This is ^ a test&quot; | sed -n &#39;/s ^/p&#39;</code><br>&#96;&#96;</p>\n</li>\n<li><p><code>$</code>锚定结尾<br>特殊字符美元符<code>$</code>定义了行尾锚点。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。<code>echo &quot;This is a good book&quot; | sed -n &#39;/book$/p&#39;</code></p>\n</li>\n<li><p>组合锚定</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> data4\nthis is a <span class=\"token builtin class-name\">test</span> of using both anchors  <span class=\"token comment\"># 这一行会被忽略</span>\nI said this is a <span class=\"token builtin class-name\">test</span> \nthis is a <span class=\"token builtin class-name\">test</span> \nI<span class=\"token string\">'m sure this is a test. \n$ sed -n '</span>/^this is a test$/p' data4 \nthis is a <span class=\"token builtin class-name\">test</span></code></pre>\n\n<p> 第二种情况</p>\n <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> data5\nThis is one <span class=\"token builtin class-name\">test</span> line. \nThis is another <span class=\"token builtin class-name\">test</span> line. \n$ <span class=\"token function\">sed</span> <span class=\"token string\">'/^$/d'</span> data5 \nThis is one <span class=\"token builtin class-name\">test</span> line. \nThis is another <span class=\"token builtin class-name\">test</span> line. </code></pre>\n\n<p> 定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行。由于空白行在两个换行符之间没有文本，刚好匹配了正则表达式模式。sed编辑器用删除命令d来删除匹配该正则表达式模式的行，因此删除了文本中的所有空白行。这是从文档中删除空白行的有效方法</p>\n</li>\n</ol>\n<h3 id=\"20-2-4-点字符\"><a href=\"#20-2-4-点字符\" class=\"headerlink\" title=\"20.2.4 点字符\"></a>20.2.4 点字符</h3><p>特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> data6\nThis is a <span class=\"token builtin class-name\">test</span> of a line. \nThe <span class=\"token function\">cat</span> is sleeping. \nThat is a very <span class=\"token function\">nice</span> hat. \nThis <span class=\"token builtin class-name\">test</span> is at line four. \nat ten o<span class=\"token string\">'clock we'</span>ll go home. \n$ <span class=\"token function\">sed</span> -n <span class=\"token string\">'/.at/p'</span> data6 \nThe <span class=\"token function\">cat</span> is sleeping. \nThat is a very <span class=\"token function\">nice</span> hat. \nThis <span class=\"token builtin class-name\">test</span> is at line four. \n</code></pre>\n\n<h3 id=\"20-2-5-字符数组\"><a href=\"#20-2-5-字符数组\" class=\"headerlink\" title=\"20.2.5 字符数组\"></a>20.2.5 字符数组</h3><p>点字符在模糊匹配上很有用，但是你想在某一位置上指定字符范围，那么字符数组就会很有用</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sed</span> -n <span class=\"token string\">'/[ch]at/p'</span> data6\nThe <span class=\"token function\">cat</span> is sleeping. \nThat is a very <span class=\"token function\">nice</span> hat. \n</code></pre>\n\n<h3 id=\"20-2-6-排除型字符\"><a href=\"#20-2-6-排除型字符\" class=\"headerlink\" title=\"20.2.6 排除型字符\"></a>20.2.6 排除型字符</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sed</span> -n <span class=\"token string\">'/[\nch]at/p'</span> data6\nThis <span class=\"token builtin class-name\">test</span> is at line four. </code></pre>\n\n<p>通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字<br>符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at<br>开头的行仍然未能匹配模式</p>\n<h3 id=\"20-2-7-区间\"><a href=\"#20-2-7-区间\" class=\"headerlink\" title=\"20.2.7 区间\"></a>20.2.7 区间</h3><p>想想匹配邮编那个case，实在是太麻烦，我们可以简化为<code>区间</code>表示  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> -n <span class=\"token string\">'/^[0-9][0-9][0-9][0-9][0-9]$/p'</span> data8 </code></pre>\n\n<p>也可以指定多个区间<code>sed -n &#39;/[a-ch-m]at/p&#39; data6</code>,该字符组允许区间a<del>c、h</del>m中的字母出现在at文本前</p>\n<h3 id=\"20-2-8-特殊的字符数组\"><a href=\"#20-2-8-特殊的字符数组\" class=\"headerlink\" title=\"20.2.8 特殊的字符数组\"></a>20.2.8 特殊的字符数组</h3><pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#BRE特殊字符组</span>\n组                      描 述\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:alpha:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意字母字符，不管是大写还是小写\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:alnum:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意字母数字字符0~9、A~Z或a~z \n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:blank:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配空格或制表符\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:digit:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配0~9之间的数字\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:lower:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配小写字母字符a~z \n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:print:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意可打印字符\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:punct:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配标点符号    \n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:space:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意空白字符：空格、制表符、NL、FF、VT和CR \n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>:upper:<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>             匹配任意大写字母字符A~Z </code></pre>\n\n<h3 id=\"20-2-9-星号\"><a href=\"#20-2-9-星号\" class=\"headerlink\" title=\"20.2.9 星号\"></a>20.2.9 星号</h3><p>在字符后面放置<strong>星号</strong>表明该字符必须在匹配模式的文本中出现0次或多次</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"ik\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/ie*k/p'</span>\nik \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"iek\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/ie*k/p'</span> \niek \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"ieek\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/ie*k/p'</span> \nieek \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"ieeek\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/ie*k/p'</span></code></pre>\n\n<p>另一个方便的特性是将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量<br>的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"this is a regular pattern expression\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'\n> /regular.*expression/p'</span> \nthis is a regular pattern expression </code></pre>\n\n<p>星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。  </p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"bt\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span>\nbt \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"bat\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbat \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"bet\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbet \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"btt\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbtt \n$ \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"baat\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbaat \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"baaeeet\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbaaeeet \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"baeeaeeat\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \nbaeeaeeat \n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"baakeeet\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'/b[ae]*t/p'</span> \n$ </code></pre>\n\n<p>只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。</p>\n<h1 id=\"AppendIndex\"><a href=\"#AppendIndex\" class=\"headerlink\" title=\"AppendIndex\"></a>AppendIndex</h1><ul>\n<li>re-read 意思是重新理解该章节</li>\n</ul>\n"},{"title":"docker从入门到实践","_content":"\n\n- [1. 什么是docker](#1-什么是docker)\n- [2.docker镜像基本概念与基本命令](#2docker镜像基本概念与基本命令)\n  - [2.1 镜像基本命令](#21-镜像基本命令)\n  - [2.2 定制镜像](#22-定制镜像)\n    - [2.2.1 使用Dockerfile定制镜像](#221-使用dockerfile定制镜像)\n    - [2.2.2 直接用 Git repo构建镜像](#222-直接用-git-repo构建镜像)\n    - [2.2.3 用网络位置上tar构建镜像](#223-用网络位置上tar构建镜像)\n    - [2.2.4 从标准输入输出定制](#224-从标准输入输出定制)\n    - [2.2.5 从标准输入中读取上下文压缩包进行构建](#225-从标准输入中读取上下文压缩包进行构建)\n  - [2.3 Dockerfile构建命令详解](#23-dockerfile构建命令详解)\n    - [2.3.1 COPY复制](#231-copy复制)\n    - [2.3.2 ADD更高级的复制命令](#232-add更高级的复制命令)\n    - [2.3.3 CMD容器启动命令](#233-cmd容器启动命令)\n    - [2.3.4 ENTRYPOINT 入口点](#234-entrypoint-入口点)\n    - [2.3.5 ENV 设置环境变量](#235-env-设置环境变量)\n    - [2.3.6 ARG 构建指令](#236-arg-构建指令)\n    - [2.3.7 VOLUME 定义匿名卷](#237-volume-定义匿名卷)\n    - [2.3.8 EXPOSE 暴露端口](#238-expose-暴露端口)\n    - [2.3.9 WORKDIR 指定工作目录](#239-workdir-指定工作目录)\n    - [2.3.10 USER指定当前用户](#2310-user指定当前用户)\n    - [2.3.11 HEALTHCHECK 健康检查`HEALTHCHECK` 支持下列选项](#2311-healthcheck-健康检查healthcheck-支持下列选项)\n    - [2.3.12 ONBUILD 为他人作嫁衣裳](#2312-onbuild-为他人作嫁衣裳)\n    - [2.3.13 LABEL 为镜像添加元数据](#2313-label-为镜像添加元数据)\n    - [2.3.14 shell指令](#2314-shell指令)\n    - [2.3.15 参考文档](#2315-参考文档)\n  - [2.4 Dockerfile 多阶段构建](#24-dockerfile-多阶段构建)\n  - [实战多阶段构建镜像](#实战多阶段构建镜像)\n  - [2.5 构建多种系统架构支持的docker镜像](#25-构建多种系统架构支持的docker镜像)\n  - [2.6 其它制作镜像的方式](#26-其它制作镜像的方式)\n- [3. 操作容器](#3-操作容器)\n  - [3.1 容器基本操作](#31-容器基本操作)\n- [4. 访问仓库](#4-访问仓库)\n- [5. 数据管理](#5-数据管理)\n  - [5.1 数据卷](#51-数据卷)\n  - [5.2 挂载主机目录](#52-挂载主机目录)\n- [6. 网络](#6-网络)\n  - [6.1 端口映射](#61-端口映射)\n  - [6.2 容器互联](#62-容器互联)\n  - [6.3. 配置DNS](#63-配置dns)\n- [7. 高级网络配置](#7-高级网络配置)\n- [8. Docker Buildx](#8-docker-buildx)\n- [9. Docker Compose](#9-docker-compose)\n  - [9.1 搭建一个web应用](#91-搭建一个web应用)\n- [10. 安全](#10-安全)\n- [11. 底层实现](#11-底层实现)\n- [12. Kubernetes](#12-kubernetes)\n- [13. 实战案例 - CI/CD](#13-实战案例---cicd)\n# 1. 什么是docker\n\nDocker是云技术的一次革新，2013年以Apache协议开源，基于linux内核的**cgroup**,**namespace**以及OverlayFS的**UnionFS**实现，对进程进行封装，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主机因此称为容器\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b5d51fa80b2435386d16496375409c2~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f40405bc364cd295076c36c9d354e5~tplv-k3u1fbpfcp-watermark.image?)\n\n- 镜像\n操作系统分为`内核`和`用户空间`，而docker的镜像就是一种特殊的文件系统，除了提供容器运行所需的程序，库，资源，配置等文件外，还包括为运行时准备的的一些配置参数\n\n- 分层存储\nDocker 设计时，就充分利用 [Union FS](https://en.wikipedia.org/wiki/Union_mount) 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 `ISO` 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。\n\n- 容器\n容器跟镜像的关系就像是面向对象中类和实例的概念，容器的实质是进程，与宿主机的进程不同，容器拥有自己独立的命空间，因此拥有自己的root文件系统，自己的网络配置，自己的进程空间，自己的用户id空间。进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。\n一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 **容器存储层**\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失（后面建议挂载volume）\n\n- 仓库\n[仓库](https://yeasy.gitbook.io/docker_practice/basic_concept/repository)\n\n# 2.docker镜像基本概念与基本命令\n\n## 2.1 镜像基本命令\n\n拉取镜像:\n\n- docker pull [OPTION] NAME\n\n```text\n<域名/IP>[:端口号]\n```\n\n运行镜像：\n\n- docker run -it --rm 镜像 [命令 /bin/bash]  参数  \n列举镜像：\n- docker image ls\n- docker images\n- docker image ls -f since=mongo:3.2 //查看某个镜像之前创建的镜像，同理也有查看某个镜像之后的镜像\n- docker ps = docker container ls //现实运行中的容器\n查看镜像体积\n- docker system df\n虚悬镜像\n仓库名和版本号都是none，这是因为新版本的镜像跟旧镜像冲突，，删除虚悬镜像\n- docker image prune\n- docker image ls -f dangling=true //列举虚悬镜像\n- docker image ls -a //有些none镜像不是虚悬镜像是中间镜像\n以特定格式显示\n- docker image ls -q\n- `docker image ls --format \"{{ .ID }}:{{ .Repository }}\" ` //支持go模板用法,方便其他程序调用\n- `docker image ls --format \"table {{ .ID }} \\t {{ .Repository }} \\t {{ .Tag }}\"` // 会显示title\n删除镜像\n- docker image rm [选项] <镜像1> [<镜像2> ...]\n- docker image rm $(docker image ls -q redis)  //使用docker image ls命令配合使用\n\nuntageged和删除  \n\n- 当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 `docker pull` 看到的层数不一样的原因  \n\n利用commit来持久化容器变化到镜像(黑箱镜)\n\n```Dockerfile\ndocker commit \\\n--author \"Tao Wang <twang2218@gmail.com>\" \\\n--message \"修改了默认网页\" \\\nwebserver \\\nnginx:v2\n```\n\n- `docker history` 具体查看镜像内的历史记录\n\n## 2.2 定制镜像\n\n### 2.2.1 使用Dockerfile定制镜像\n\n**From** 关键字指定基础镜像  \n***RUN*** 执行命令,在撰写 Dockerfile 的时候,要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建，使用docker build 构建编写的Dockerfile  \n> `docker` 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能,当服务端需要本地文件时候该怎么获得\n\n***COPY***  复制 **上下文（context）** 目录下的源文件\n> COPY ./package.json /app/\n\n复制 **上下文（context）** 目录下的 `package.json`,`COPY` 这类指令中的源文件的路径都是*相对路径*。现在就可以理解刚才的命令 `docker build -t nginx:v3 .` 中的这个 `.`，实际上是在指定上下文的目录，`docker build` 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像\n\n- 那么为什么会有人误以为 `.` 是指定 `Dockerfile` 所在目录呢？这是因为在默认情况下，如果不额外指定 `Dockerfile` 的话，会将上下文目录下的名为 `Dockerfile` 的文件作为 Dockerfile\n- 如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore`，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的\n- 实际上 `Dockerfile` 的文件名并不要求必须为 `Dockerfile`，而且并不要求必须位于上下文目录中，比如可以用 `-f ../Dockerfile.php` 参数指定某个文件作为 `Dockerfile`\n\n### 2.2.2 直接用 Git repo构建镜像\n\n```Dockerfile\n# $env:DOCKER_BUILDKIT=0\n# export DOCKER_BUILDKIT=0\n$ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world\nStep 1/3 : FROM scratch\n--->\nStep 2/3 : COPY hello /\n---> ac779757d46e\nStep 3/3 : CMD [\"/hello\"]\n---> Running in d2a513a760ed\nRemoving intermediate container d2a513a760ed\n---> 038ad4142d2b\nSuccessfully built 038ad4142d2b\n```\n\n### 2.2.3 用网络位置上tar构建镜像\n\n如果所给出的 URL 不是个 Git repo，而是个 `tar` 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建.  \n\n### 2.2.4 从标准输入输出定制  \n\ndocker build - < Dockerfile  \ncat Dockerfile | docker build -\n因为没有上下文，所以Dockerfile里面不可以使用`copy`  \n\n### 2.2.5 从标准输入中读取上下文压缩包进行构建\n\ndocker build - < context.tar.gz\n说白了就是解压后进行构建\n\n## 2.3 Dockerfile构建命令详解\n\n### 2.3.1 COPY复制\n\n- 将上下文目录的文件复制到容器中的对应的目录下\n- 支持通配符\n- 源路径是相对路径，目标路径支持绝对路径\n- `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候\n- example\n\n```Dockerfile\nCOPY requirements.txt /code  //copy 文件到容器中的/code目录下\n```\n\n### 2.3.2 ADD更高级的复制命令\n\n- 源路径是tar包会在目标路径下解压(非常实用)\n- `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢\n- `--chown=<user>:<group>` 选项来改变文件的所属用户及所属组\n\n```\nADD --chown=55:mygroup files* /mydir/\nADD --chown=bin files* /mydir/\nADD --chown=1 files* /mydir/\nADD --chown=10:11 files* /mydir/\n```\n\n### 2.3.3 CMD容器启动命令\n\n容器既然是进程，那么启动时就需要指定运行参数  \n\n- example  \n`CMD [ \"sh\", \"-c\", \"echo $HOME\" ]`\n\n```Dockerfile\nFROM ubuntu:18.04\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\nCMD [ \"curl\", \"-s\", \"http://myip.ipip.net\" ]\n```\n\n这个时候运行容器，docker run myip 就会打印ip相关信息，但是如果你想加参数`-i`，以如下方式  \n`docker run myip -i` 就会报错，因为myip后面传入的参数会被认为是命令，而正确是的方式是  \n`docker run myip curl -s http://myip.ipip.net -i`，显然这不是一个好的方案。可以使用2.3.4的参数来设计\n\n### 2.3.4 ENTRYPOINT 入口点\n\n`ENTRYPOINT` 的目的和 `CMD` 一样，都是在指定容器启动程序及参数,例子如下\n\n- 场景一:让镜像像命令一样使用`ENTRYPOINT`\n\n```Dockerfile\nFROM ubuntu:18.04\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\nENTRYPOINT [ \"curl\", \"-s\", \"http://myip.ipip.net\" ]\n//再次尝试跑 docker run myip -i，就会将-i作为参数传给curl命令\n```\n\n- 场景二: 应用运行前的准备工作\n比如 `mysql` 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。\n\n```Dockerfile\nFROM alpine:3.4\nRUN addgroup -S redis && adduser -S -G redis redis\nENTRYPOINT [\"docker-entrypoint.sh\"]\nEXPOSE 6379\nCMD [ \"redis-server\" ]\n//redis服务创建了redis用户，并在最后ENTRYPOINT指定了entrypoint.sh的脚本,该脚本的内容就是根据CMD的内容\n//来判断，如果是redis-server的话，则切换到redis用户身份启动服务器，否则依旧使用root身份执行。比如：\n```\n\n### 2.3.5 ENV 设置环境变量\n\n可以为后面的RUN命令提供环境变量，是以键值对的形式存在，如果value部分有空格，需要使用双引号括起来\n\n### 2.3.6 ARG 构建指令\n\nARG指令有生效范围，如果在FROM之前指定的，那么只能用于`FROM`指令中\n\n```Dockerfile\nARG DOCKER_USERNAME=library\nFROM ${DOCKER_USERNAME}/alpine\nRUN set -x ; echo ${DOCKER_USERNAME}\n```\n\n`RUN`拿不到变量值，要想使用只能是在`FROM`命令后面重新指定`ARG`,多阶段构建需要指定各个阶段的`ARG`\n\n### 2.3.7 VOLUME 定义匿名卷\n\n`VOLUME /data` 挂在匿名卷,向容器/data写入的数据最终会落入host磁盘  \n`$ docker run -d -v mydata:/data xxxx`\n就使用了 `mydata` 这个命名卷挂载到了 `/data` 这个位置，替代了 `Dockerfile` 中定义的匿名卷的挂载配置\n\n### 2.3.8 EXPOSE 暴露端口\n\n与-p <宿主端口>:<容器端口>, 映射端口不通，EXPOSE是暴漏容器端口给其他容器\n\n### 2.3.9 WORKDIR 指定工作目录\n\n使用 `WORKDIR` 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，`WORKDIR` 会帮你建立目录\n\n### 2.3.10 USER指定当前用户\n\n`USER` 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。\n\n### 2.3.11 HEALTHCHECK 健康检查`HEALTHCHECK` 支持下列选项\n\n- `--interval=<间隔>`：两次健康检查的间隔，默认为 30 秒；\n- `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；\n- `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为 `unhealthy`，默认 3 次。\n\n```Dockerfile\nFROM nginx\nRUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*\nHEALTHCHECK --interval=5s --timeout=3s \\\nCMD curl -fs http://localhost/ || exit 1\n\n//这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），\n//如果健康检查命令超过 3 //秒没响应就视为失败，并且使用 `curl -fs http://localhost/ || exit 1`\n//作为健康检查命令。\n```\n\n### 2.3.12 ONBUILD 为他人作嫁衣裳\n\n### 2.3.13 LABEL 为镜像添加元数据\n\n我们还可以用一些标签来申明镜像的作者、文档地址等：\n\n```shell\nLABEL org.opencontainers.image.authors=\"yeasy\"\nLABEL org.opencontainers.image.documentation=\"https://yeasy.gitbooks.io\"\n```\n\n### 2.3.14 shell指令\n\n`SHELL` 指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell程序，Linux 中默认为 `[\"/bin/sh\", \"-c\"]`\n\n### 2.3.15 参考文档\n\n- `Dockerfie` 官方文档：<https://docs.docker.com/engine/reference/builder/>\n\n- `Dockerfile` 最佳实践文档：<https://docs.docker.com/develop/develop-images/dockerfile_best-practices/>\n\n- `Docker` 官方镜像 `Dockerfile`：<https://github.com/docker-library/docs>\n\n## 2.4 Dockerfile 多阶段构建\n\n- 以前是全部放到一个Dockerfile里面，将编译，测试，打包放在一起，可能导致镜像层次过多，源代码泄露风险\n- 分多个Dockerfile编写，然后指定文件逐个构建\n- 使用多阶段构建\n\n```Dockerfile\nFROM golang:alpine as builder\nRUN apk --no-cache add git\nWORKDIR /go/src/github.com/go/helloworld/\nRUN go get -d -v github.com/go-sql-driver/mysql\nCOPY app.go .\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\nFROM alpine:latest as prod\nRUN apk --no-cache add ca-certificates\nWORKDIR /root/\nCOPY --from=0 /go/src/github.com/go/helloworld/app .\nCMD [\"./app\"]\n// 构建镜像  docker build -t go/helloworld:3 .\n```\n\n    - 我们可以使用 `as` 来为某一阶段命名，例如`FROM golang:alpine as builder`\n    - 例如当我们只想构建 `builder` 阶段的镜像时，增加 `--target=builder` 参数即可 `$ docker build --target builder -t username/imagename:tag .`\n\n- 构建时从其他镜像复制文件\n上面例子中我们使用 `COPY --from=0 /go/src/github.com/go/helloworld/app .` 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件  \n`$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf`\n\n## 实战多阶段构建镜像\n\n[实战地址](https://github.com/nigelpoulton/dotnet-docker-samples.git)  \n\n- 生产环境多阶段构建需要保持镜像精简，可以通过&&精简镜像层\n- run指令执行完会残留构建镜像完后的文件，直接上生产及其不妥，docker提供了多种方式解决这个问题，重瞳方式叫`建造者模式`\n\n    1. 构建`Dockerfile.dev`文件\n    2. 在此基础之上构建新一层镜像\n    3. 编写Dockerfile.prod，把上一步容器的相关代码和文件复制过来\n\n- 多阶段构建方式\n分析Dockerfile文件\n\n```Dockerfile\nFROM mcr.microsoft.com/dotnet/sdk:6.0 AS build\nWORKDIR /source\n\n# copy csproj and restore as distinct layers\nCOPY *.sln .\nCOPY aspnetapp/*.csproj ./aspnetapp/\nRUN dotnet restore\n\n# copy everything else and build app\nCOPY aspnetapp/. ./aspnetapp/\nWORKDIR /source/aspnetapp\nRUN dotnet publish -c release -o /app --no-restore\n\n# final stage/image\nFROM mcr.microsoft.com/dotnet/aspnet:6.0\nWORKDIR /app\nCOPY --from=build /app ./\nENTRYPOINT [\"dotnet\", \"aspnetapp.dll\"]\n```\n\n首先注意到，`Dockerfile`有三个`FROM`指令。每一个`FROM`指令构成一个单独的**构建阶段**  \n\n 1. 阶段`0`：`build-env`\n `build-env`阶段拉取了`aspnetcore-build:2.0`作为基础镜像，然后设置了工作目录，复制一些应用代码，接着执行两个`RUN`指令，生成`1`个镜像层并显著得到一个比原镜像大得多的镜像，包含许多构建工具和应用代码\n\n 2. 阶段`1`：`microsoft/aspnetcore:2.0`\n `aspnetcore:2.0`阶段拉取了`aspnetcore:2.0`作为基础镜像，设置工作目录，然后执行`COPY --from`指令从`build-env`阶段生成的镜像中复制一些应用代码过来，最后执行`ENTRYPOINT`指令指定容器的默认应用程序\n\n上述构建过程的重点在于`COPY --from`指令**表示从之前的构建阶段复制生产环境相关的应用代码，而不会复制生产环境不需要的构件**\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7053651f6091402c9c8ff10c99d1ae34~tplv-k3u1fbpfcp-watermark.image?)\n\n## 2.5 构建多种系统架构支持的docker镜像\n\n`$ docker manifest inspect golang:alpine`  \n查看manifest列表\n\n- 创建manifest 列表\n- 设置manifest列表\n- 查看manifest列表\n- 推送manifest列表\n- 测试\n- [官方博客](https://www.docker.com/blog/multi-arch-all-the-things/)\n\n## 2.6 其它制作镜像的方式\n\n- 从 rootfs 压缩包导入\n\n```docker\n$ docker import \\\n    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \\\n    openvz/ubuntu:16.04\n\nDownloading from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz\nsha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213\n// 从web远程下载ubuntu然后制作镜像\n```\n\n- Docker 镜像的导入和导出 `docker save` 和 `docker load` ，目前已经不推荐\n\n# 3. 操作容器\n\n## 3.1 容器基本操作\n\n两种启动容器方式，从镜像到容器，启动停止的容器\n\n- 新建容器\n\n```Dockerfile\n$ docker run -dit --name new_name ubuntu:18.04 /bin/echo 'Hello world'\nHello world\n```\n\n-itd 意思是指容器绑定标准输入输出，然后绑定个伪终端，然后以守护态运行\n要获取容器的输出信息，可以通过 `docker container logs` 命令\n\n- stop/restart 容器\ndocker container ls //查看容器\ndocker container restart\ndocker container stop/start\n- 进入容器\n`docker attach` 进入容器\n`docker exec -it` 进入容器\n- 导出/导入容器\n`docker export 7691a814370e > ubuntu.tar`  \n`docker import - test/ubuntu:v1.0`  \n`docker import url`\n- 删除容器\n`docker container rm trusting_newton`\n`docker container prune` 清理所有种植状态的容器\n\n# 4. 访问仓库\n\n1. docker hub\n2. 私有仓库\n3. 私有仓库高级配置\n4. nexus3\n\n# 5. 数据管理\n\n## 5.1 数据卷\n\n对数据卷的使用有点像linux的mount，镜像中被挂载的目录文件会复制到宿主机的目录上，独立于容器\n\n1. 创建一个数据卷\n\n```docker\ndocker volume create my-vol  创建一个数据卷  \ndocker volume ls  列举数据卷  \ndocker volume inspect my_vol 查看某一个数据卷  \n```\n\n2. 启动一个挂在了数据卷的容器\n\n```docker\ndocker run -d -P \\\n    --name web \\\n    # -v my-vol:/usr/share/nginx/html \\\n    --mount source=my-vol,target=/usr/share/nginx/html \\\n    nginx:alpine\n//使用my_vol数据卷，映射到/usr/share/nginx/html\n```\n\n3. 查看数据卷具体信息\n\n```docker\ndocker inspect web //数据卷信息在Mounts key下\n....\n\"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\" //默认位置\n```\n\n4.删除一个数据卷\n\n```docker\ndocker volume rm my-vol\ndocker volume prune //删除无主的数据卷\n```\n\n- 数据卷可以在容器间共用\n- 对数据卷的修改会立马生效\n- 对数据卷的更新，不会影响镜像\n- 数据卷默认会一直存在，即使容器被输出\n\n## 5.2 挂载主机目录\n\n1. 挂载目录到容器目录\n\n```docker\n$ docker run -d -P \\\n    --name web \\\n    # -v /src/webapp:/usr/share/nginx/html \\\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html, readonly \\\n    nginx:alpine\n```\n\n`挂载主机目录` 的配置信息在 \"Mounts\" Key 下面\n\n- 目录与容器目录绑定，容器写进文件，就会落盘到宿主机上  \n- 目前如果source不存在就会报错  \n- 宿主机目录也可以指定readonly  \n\n2. 挂载宿主机文件到容器文件中  \n   source=  ,target= 关键字处直接替换成文件\n\n# 6. 网络\n\n## 6.1 端口映射\n\n-P 会随即映射  \n-p 特定端口映,可使用多次指定多个端口\n\n- `$ docker run -d -p 80:80 nginx:alpine` hostport:containerport  \n- `$ docker run -d -p 127.0.0.1:80:80 nginx:alpine` 指定地址绑定，容器有自己的网络和地址\n- `$ docker run -d -p 127.0.0.1::80/udp nginx:alpine` 容器80端口随机映射到主机,并指定传输协议\n\n## 6.2 容器互联\n\n1. 新建网络\n\n```docker\ndocker network create -d bridge my-net\n```\n\n`-d` 参数指定 Docker 网络类型，有 `bridge` `overlay`。其中 `overlay` 网络类型用于 [Swarm mode](/docker_practice/swarm_mode)，在本小节中你可以忽略它\n2. 容器互联\n\n```docker\ndocker run -it --rm --name busybox1 --network my-net busybox sh\ndocker run -it --rm --name busybox2 --network my-net busybox sh\n\n```\n\n可以直接ping另外的容器\n\n- Docker Compose 可以考虑使用\n\n## 6.3. 配置DNS\n\nTBC\n\n# 7. 高级网络配置\n\n# 8. Docker Buildx\n\n# 9. Docker Compose\n\n结合实战操纵理解\n\n## 9.1 搭建一个web应用\n\n- 服务：运行多个相同镜像的实例\n- 项目：一组应用容器组成的一个完整单元\n[docker compose](https://docs.docker.com/compose/compose-file/)\n\n# 10. 安全\n\n# 11. 底层实现\n\n# 12. Kubernetes\n\n# 13. 实战案例 - CI/CD\n","source":"_posts/docker从入门到实践.md","raw":"---\ntitle: docker从入门到实践\ncategories: \n- CICD\ntag: Docker\n---\n\n\n- [1. 什么是docker](#1-什么是docker)\n- [2.docker镜像基本概念与基本命令](#2docker镜像基本概念与基本命令)\n  - [2.1 镜像基本命令](#21-镜像基本命令)\n  - [2.2 定制镜像](#22-定制镜像)\n    - [2.2.1 使用Dockerfile定制镜像](#221-使用dockerfile定制镜像)\n    - [2.2.2 直接用 Git repo构建镜像](#222-直接用-git-repo构建镜像)\n    - [2.2.3 用网络位置上tar构建镜像](#223-用网络位置上tar构建镜像)\n    - [2.2.4 从标准输入输出定制](#224-从标准输入输出定制)\n    - [2.2.5 从标准输入中读取上下文压缩包进行构建](#225-从标准输入中读取上下文压缩包进行构建)\n  - [2.3 Dockerfile构建命令详解](#23-dockerfile构建命令详解)\n    - [2.3.1 COPY复制](#231-copy复制)\n    - [2.3.2 ADD更高级的复制命令](#232-add更高级的复制命令)\n    - [2.3.3 CMD容器启动命令](#233-cmd容器启动命令)\n    - [2.3.4 ENTRYPOINT 入口点](#234-entrypoint-入口点)\n    - [2.3.5 ENV 设置环境变量](#235-env-设置环境变量)\n    - [2.3.6 ARG 构建指令](#236-arg-构建指令)\n    - [2.3.7 VOLUME 定义匿名卷](#237-volume-定义匿名卷)\n    - [2.3.8 EXPOSE 暴露端口](#238-expose-暴露端口)\n    - [2.3.9 WORKDIR 指定工作目录](#239-workdir-指定工作目录)\n    - [2.3.10 USER指定当前用户](#2310-user指定当前用户)\n    - [2.3.11 HEALTHCHECK 健康检查`HEALTHCHECK` 支持下列选项](#2311-healthcheck-健康检查healthcheck-支持下列选项)\n    - [2.3.12 ONBUILD 为他人作嫁衣裳](#2312-onbuild-为他人作嫁衣裳)\n    - [2.3.13 LABEL 为镜像添加元数据](#2313-label-为镜像添加元数据)\n    - [2.3.14 shell指令](#2314-shell指令)\n    - [2.3.15 参考文档](#2315-参考文档)\n  - [2.4 Dockerfile 多阶段构建](#24-dockerfile-多阶段构建)\n  - [实战多阶段构建镜像](#实战多阶段构建镜像)\n  - [2.5 构建多种系统架构支持的docker镜像](#25-构建多种系统架构支持的docker镜像)\n  - [2.6 其它制作镜像的方式](#26-其它制作镜像的方式)\n- [3. 操作容器](#3-操作容器)\n  - [3.1 容器基本操作](#31-容器基本操作)\n- [4. 访问仓库](#4-访问仓库)\n- [5. 数据管理](#5-数据管理)\n  - [5.1 数据卷](#51-数据卷)\n  - [5.2 挂载主机目录](#52-挂载主机目录)\n- [6. 网络](#6-网络)\n  - [6.1 端口映射](#61-端口映射)\n  - [6.2 容器互联](#62-容器互联)\n  - [6.3. 配置DNS](#63-配置dns)\n- [7. 高级网络配置](#7-高级网络配置)\n- [8. Docker Buildx](#8-docker-buildx)\n- [9. Docker Compose](#9-docker-compose)\n  - [9.1 搭建一个web应用](#91-搭建一个web应用)\n- [10. 安全](#10-安全)\n- [11. 底层实现](#11-底层实现)\n- [12. Kubernetes](#12-kubernetes)\n- [13. 实战案例 - CI/CD](#13-实战案例---cicd)\n# 1. 什么是docker\n\nDocker是云技术的一次革新，2013年以Apache协议开源，基于linux内核的**cgroup**,**namespace**以及OverlayFS的**UnionFS**实现，对进程进行封装，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主机因此称为容器\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b5d51fa80b2435386d16496375409c2~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f40405bc364cd295076c36c9d354e5~tplv-k3u1fbpfcp-watermark.image?)\n\n- 镜像\n操作系统分为`内核`和`用户空间`，而docker的镜像就是一种特殊的文件系统，除了提供容器运行所需的程序，库，资源，配置等文件外，还包括为运行时准备的的一些配置参数\n\n- 分层存储\nDocker 设计时，就充分利用 [Union FS](https://en.wikipedia.org/wiki/Union_mount) 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 `ISO` 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。\n\n- 容器\n容器跟镜像的关系就像是面向对象中类和实例的概念，容器的实质是进程，与宿主机的进程不同，容器拥有自己独立的命空间，因此拥有自己的root文件系统，自己的网络配置，自己的进程空间，自己的用户id空间。进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。\n一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 **容器存储层**\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失（后面建议挂载volume）\n\n- 仓库\n[仓库](https://yeasy.gitbook.io/docker_practice/basic_concept/repository)\n\n# 2.docker镜像基本概念与基本命令\n\n## 2.1 镜像基本命令\n\n拉取镜像:\n\n- docker pull [OPTION] NAME\n\n```text\n<域名/IP>[:端口号]\n```\n\n运行镜像：\n\n- docker run -it --rm 镜像 [命令 /bin/bash]  参数  \n列举镜像：\n- docker image ls\n- docker images\n- docker image ls -f since=mongo:3.2 //查看某个镜像之前创建的镜像，同理也有查看某个镜像之后的镜像\n- docker ps = docker container ls //现实运行中的容器\n查看镜像体积\n- docker system df\n虚悬镜像\n仓库名和版本号都是none，这是因为新版本的镜像跟旧镜像冲突，，删除虚悬镜像\n- docker image prune\n- docker image ls -f dangling=true //列举虚悬镜像\n- docker image ls -a //有些none镜像不是虚悬镜像是中间镜像\n以特定格式显示\n- docker image ls -q\n- `docker image ls --format \"{{ .ID }}:{{ .Repository }}\" ` //支持go模板用法,方便其他程序调用\n- `docker image ls --format \"table {{ .ID }} \\t {{ .Repository }} \\t {{ .Tag }}\"` // 会显示title\n删除镜像\n- docker image rm [选项] <镜像1> [<镜像2> ...]\n- docker image rm $(docker image ls -q redis)  //使用docker image ls命令配合使用\n\nuntageged和删除  \n\n- 当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 `docker pull` 看到的层数不一样的原因  \n\n利用commit来持久化容器变化到镜像(黑箱镜)\n\n```Dockerfile\ndocker commit \\\n--author \"Tao Wang <twang2218@gmail.com>\" \\\n--message \"修改了默认网页\" \\\nwebserver \\\nnginx:v2\n```\n\n- `docker history` 具体查看镜像内的历史记录\n\n## 2.2 定制镜像\n\n### 2.2.1 使用Dockerfile定制镜像\n\n**From** 关键字指定基础镜像  \n***RUN*** 执行命令,在撰写 Dockerfile 的时候,要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建，使用docker build 构建编写的Dockerfile  \n> `docker` 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能,当服务端需要本地文件时候该怎么获得\n\n***COPY***  复制 **上下文（context）** 目录下的源文件\n> COPY ./package.json /app/\n\n复制 **上下文（context）** 目录下的 `package.json`,`COPY` 这类指令中的源文件的路径都是*相对路径*。现在就可以理解刚才的命令 `docker build -t nginx:v3 .` 中的这个 `.`，实际上是在指定上下文的目录，`docker build` 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像\n\n- 那么为什么会有人误以为 `.` 是指定 `Dockerfile` 所在目录呢？这是因为在默认情况下，如果不额外指定 `Dockerfile` 的话，会将上下文目录下的名为 `Dockerfile` 的文件作为 Dockerfile\n- 如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore`，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的\n- 实际上 `Dockerfile` 的文件名并不要求必须为 `Dockerfile`，而且并不要求必须位于上下文目录中，比如可以用 `-f ../Dockerfile.php` 参数指定某个文件作为 `Dockerfile`\n\n### 2.2.2 直接用 Git repo构建镜像\n\n```Dockerfile\n# $env:DOCKER_BUILDKIT=0\n# export DOCKER_BUILDKIT=0\n$ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world\nStep 1/3 : FROM scratch\n--->\nStep 2/3 : COPY hello /\n---> ac779757d46e\nStep 3/3 : CMD [\"/hello\"]\n---> Running in d2a513a760ed\nRemoving intermediate container d2a513a760ed\n---> 038ad4142d2b\nSuccessfully built 038ad4142d2b\n```\n\n### 2.2.3 用网络位置上tar构建镜像\n\n如果所给出的 URL 不是个 Git repo，而是个 `tar` 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建.  \n\n### 2.2.4 从标准输入输出定制  \n\ndocker build - < Dockerfile  \ncat Dockerfile | docker build -\n因为没有上下文，所以Dockerfile里面不可以使用`copy`  \n\n### 2.2.5 从标准输入中读取上下文压缩包进行构建\n\ndocker build - < context.tar.gz\n说白了就是解压后进行构建\n\n## 2.3 Dockerfile构建命令详解\n\n### 2.3.1 COPY复制\n\n- 将上下文目录的文件复制到容器中的对应的目录下\n- 支持通配符\n- 源路径是相对路径，目标路径支持绝对路径\n- `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候\n- example\n\n```Dockerfile\nCOPY requirements.txt /code  //copy 文件到容器中的/code目录下\n```\n\n### 2.3.2 ADD更高级的复制命令\n\n- 源路径是tar包会在目标路径下解压(非常实用)\n- `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢\n- `--chown=<user>:<group>` 选项来改变文件的所属用户及所属组\n\n```\nADD --chown=55:mygroup files* /mydir/\nADD --chown=bin files* /mydir/\nADD --chown=1 files* /mydir/\nADD --chown=10:11 files* /mydir/\n```\n\n### 2.3.3 CMD容器启动命令\n\n容器既然是进程，那么启动时就需要指定运行参数  \n\n- example  \n`CMD [ \"sh\", \"-c\", \"echo $HOME\" ]`\n\n```Dockerfile\nFROM ubuntu:18.04\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\nCMD [ \"curl\", \"-s\", \"http://myip.ipip.net\" ]\n```\n\n这个时候运行容器，docker run myip 就会打印ip相关信息，但是如果你想加参数`-i`，以如下方式  \n`docker run myip -i` 就会报错，因为myip后面传入的参数会被认为是命令，而正确是的方式是  \n`docker run myip curl -s http://myip.ipip.net -i`，显然这不是一个好的方案。可以使用2.3.4的参数来设计\n\n### 2.3.4 ENTRYPOINT 入口点\n\n`ENTRYPOINT` 的目的和 `CMD` 一样，都是在指定容器启动程序及参数,例子如下\n\n- 场景一:让镜像像命令一样使用`ENTRYPOINT`\n\n```Dockerfile\nFROM ubuntu:18.04\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\nENTRYPOINT [ \"curl\", \"-s\", \"http://myip.ipip.net\" ]\n//再次尝试跑 docker run myip -i，就会将-i作为参数传给curl命令\n```\n\n- 场景二: 应用运行前的准备工作\n比如 `mysql` 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。\n\n```Dockerfile\nFROM alpine:3.4\nRUN addgroup -S redis && adduser -S -G redis redis\nENTRYPOINT [\"docker-entrypoint.sh\"]\nEXPOSE 6379\nCMD [ \"redis-server\" ]\n//redis服务创建了redis用户，并在最后ENTRYPOINT指定了entrypoint.sh的脚本,该脚本的内容就是根据CMD的内容\n//来判断，如果是redis-server的话，则切换到redis用户身份启动服务器，否则依旧使用root身份执行。比如：\n```\n\n### 2.3.5 ENV 设置环境变量\n\n可以为后面的RUN命令提供环境变量，是以键值对的形式存在，如果value部分有空格，需要使用双引号括起来\n\n### 2.3.6 ARG 构建指令\n\nARG指令有生效范围，如果在FROM之前指定的，那么只能用于`FROM`指令中\n\n```Dockerfile\nARG DOCKER_USERNAME=library\nFROM ${DOCKER_USERNAME}/alpine\nRUN set -x ; echo ${DOCKER_USERNAME}\n```\n\n`RUN`拿不到变量值，要想使用只能是在`FROM`命令后面重新指定`ARG`,多阶段构建需要指定各个阶段的`ARG`\n\n### 2.3.7 VOLUME 定义匿名卷\n\n`VOLUME /data` 挂在匿名卷,向容器/data写入的数据最终会落入host磁盘  \n`$ docker run -d -v mydata:/data xxxx`\n就使用了 `mydata` 这个命名卷挂载到了 `/data` 这个位置，替代了 `Dockerfile` 中定义的匿名卷的挂载配置\n\n### 2.3.8 EXPOSE 暴露端口\n\n与-p <宿主端口>:<容器端口>, 映射端口不通，EXPOSE是暴漏容器端口给其他容器\n\n### 2.3.9 WORKDIR 指定工作目录\n\n使用 `WORKDIR` 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，`WORKDIR` 会帮你建立目录\n\n### 2.3.10 USER指定当前用户\n\n`USER` 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。\n\n### 2.3.11 HEALTHCHECK 健康检查`HEALTHCHECK` 支持下列选项\n\n- `--interval=<间隔>`：两次健康检查的间隔，默认为 30 秒；\n- `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；\n- `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为 `unhealthy`，默认 3 次。\n\n```Dockerfile\nFROM nginx\nRUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*\nHEALTHCHECK --interval=5s --timeout=3s \\\nCMD curl -fs http://localhost/ || exit 1\n\n//这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），\n//如果健康检查命令超过 3 //秒没响应就视为失败，并且使用 `curl -fs http://localhost/ || exit 1`\n//作为健康检查命令。\n```\n\n### 2.3.12 ONBUILD 为他人作嫁衣裳\n\n### 2.3.13 LABEL 为镜像添加元数据\n\n我们还可以用一些标签来申明镜像的作者、文档地址等：\n\n```shell\nLABEL org.opencontainers.image.authors=\"yeasy\"\nLABEL org.opencontainers.image.documentation=\"https://yeasy.gitbooks.io\"\n```\n\n### 2.3.14 shell指令\n\n`SHELL` 指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell程序，Linux 中默认为 `[\"/bin/sh\", \"-c\"]`\n\n### 2.3.15 参考文档\n\n- `Dockerfie` 官方文档：<https://docs.docker.com/engine/reference/builder/>\n\n- `Dockerfile` 最佳实践文档：<https://docs.docker.com/develop/develop-images/dockerfile_best-practices/>\n\n- `Docker` 官方镜像 `Dockerfile`：<https://github.com/docker-library/docs>\n\n## 2.4 Dockerfile 多阶段构建\n\n- 以前是全部放到一个Dockerfile里面，将编译，测试，打包放在一起，可能导致镜像层次过多，源代码泄露风险\n- 分多个Dockerfile编写，然后指定文件逐个构建\n- 使用多阶段构建\n\n```Dockerfile\nFROM golang:alpine as builder\nRUN apk --no-cache add git\nWORKDIR /go/src/github.com/go/helloworld/\nRUN go get -d -v github.com/go-sql-driver/mysql\nCOPY app.go .\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\nFROM alpine:latest as prod\nRUN apk --no-cache add ca-certificates\nWORKDIR /root/\nCOPY --from=0 /go/src/github.com/go/helloworld/app .\nCMD [\"./app\"]\n// 构建镜像  docker build -t go/helloworld:3 .\n```\n\n    - 我们可以使用 `as` 来为某一阶段命名，例如`FROM golang:alpine as builder`\n    - 例如当我们只想构建 `builder` 阶段的镜像时，增加 `--target=builder` 参数即可 `$ docker build --target builder -t username/imagename:tag .`\n\n- 构建时从其他镜像复制文件\n上面例子中我们使用 `COPY --from=0 /go/src/github.com/go/helloworld/app .` 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件  \n`$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf`\n\n## 实战多阶段构建镜像\n\n[实战地址](https://github.com/nigelpoulton/dotnet-docker-samples.git)  \n\n- 生产环境多阶段构建需要保持镜像精简，可以通过&&精简镜像层\n- run指令执行完会残留构建镜像完后的文件，直接上生产及其不妥，docker提供了多种方式解决这个问题，重瞳方式叫`建造者模式`\n\n    1. 构建`Dockerfile.dev`文件\n    2. 在此基础之上构建新一层镜像\n    3. 编写Dockerfile.prod，把上一步容器的相关代码和文件复制过来\n\n- 多阶段构建方式\n分析Dockerfile文件\n\n```Dockerfile\nFROM mcr.microsoft.com/dotnet/sdk:6.0 AS build\nWORKDIR /source\n\n# copy csproj and restore as distinct layers\nCOPY *.sln .\nCOPY aspnetapp/*.csproj ./aspnetapp/\nRUN dotnet restore\n\n# copy everything else and build app\nCOPY aspnetapp/. ./aspnetapp/\nWORKDIR /source/aspnetapp\nRUN dotnet publish -c release -o /app --no-restore\n\n# final stage/image\nFROM mcr.microsoft.com/dotnet/aspnet:6.0\nWORKDIR /app\nCOPY --from=build /app ./\nENTRYPOINT [\"dotnet\", \"aspnetapp.dll\"]\n```\n\n首先注意到，`Dockerfile`有三个`FROM`指令。每一个`FROM`指令构成一个单独的**构建阶段**  \n\n 1. 阶段`0`：`build-env`\n `build-env`阶段拉取了`aspnetcore-build:2.0`作为基础镜像，然后设置了工作目录，复制一些应用代码，接着执行两个`RUN`指令，生成`1`个镜像层并显著得到一个比原镜像大得多的镜像，包含许多构建工具和应用代码\n\n 2. 阶段`1`：`microsoft/aspnetcore:2.0`\n `aspnetcore:2.0`阶段拉取了`aspnetcore:2.0`作为基础镜像，设置工作目录，然后执行`COPY --from`指令从`build-env`阶段生成的镜像中复制一些应用代码过来，最后执行`ENTRYPOINT`指令指定容器的默认应用程序\n\n上述构建过程的重点在于`COPY --from`指令**表示从之前的构建阶段复制生产环境相关的应用代码，而不会复制生产环境不需要的构件**\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7053651f6091402c9c8ff10c99d1ae34~tplv-k3u1fbpfcp-watermark.image?)\n\n## 2.5 构建多种系统架构支持的docker镜像\n\n`$ docker manifest inspect golang:alpine`  \n查看manifest列表\n\n- 创建manifest 列表\n- 设置manifest列表\n- 查看manifest列表\n- 推送manifest列表\n- 测试\n- [官方博客](https://www.docker.com/blog/multi-arch-all-the-things/)\n\n## 2.6 其它制作镜像的方式\n\n- 从 rootfs 压缩包导入\n\n```docker\n$ docker import \\\n    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \\\n    openvz/ubuntu:16.04\n\nDownloading from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz\nsha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213\n// 从web远程下载ubuntu然后制作镜像\n```\n\n- Docker 镜像的导入和导出 `docker save` 和 `docker load` ，目前已经不推荐\n\n# 3. 操作容器\n\n## 3.1 容器基本操作\n\n两种启动容器方式，从镜像到容器，启动停止的容器\n\n- 新建容器\n\n```Dockerfile\n$ docker run -dit --name new_name ubuntu:18.04 /bin/echo 'Hello world'\nHello world\n```\n\n-itd 意思是指容器绑定标准输入输出，然后绑定个伪终端，然后以守护态运行\n要获取容器的输出信息，可以通过 `docker container logs` 命令\n\n- stop/restart 容器\ndocker container ls //查看容器\ndocker container restart\ndocker container stop/start\n- 进入容器\n`docker attach` 进入容器\n`docker exec -it` 进入容器\n- 导出/导入容器\n`docker export 7691a814370e > ubuntu.tar`  \n`docker import - test/ubuntu:v1.0`  \n`docker import url`\n- 删除容器\n`docker container rm trusting_newton`\n`docker container prune` 清理所有种植状态的容器\n\n# 4. 访问仓库\n\n1. docker hub\n2. 私有仓库\n3. 私有仓库高级配置\n4. nexus3\n\n# 5. 数据管理\n\n## 5.1 数据卷\n\n对数据卷的使用有点像linux的mount，镜像中被挂载的目录文件会复制到宿主机的目录上，独立于容器\n\n1. 创建一个数据卷\n\n```docker\ndocker volume create my-vol  创建一个数据卷  \ndocker volume ls  列举数据卷  \ndocker volume inspect my_vol 查看某一个数据卷  \n```\n\n2. 启动一个挂在了数据卷的容器\n\n```docker\ndocker run -d -P \\\n    --name web \\\n    # -v my-vol:/usr/share/nginx/html \\\n    --mount source=my-vol,target=/usr/share/nginx/html \\\n    nginx:alpine\n//使用my_vol数据卷，映射到/usr/share/nginx/html\n```\n\n3. 查看数据卷具体信息\n\n```docker\ndocker inspect web //数据卷信息在Mounts key下\n....\n\"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\" //默认位置\n```\n\n4.删除一个数据卷\n\n```docker\ndocker volume rm my-vol\ndocker volume prune //删除无主的数据卷\n```\n\n- 数据卷可以在容器间共用\n- 对数据卷的修改会立马生效\n- 对数据卷的更新，不会影响镜像\n- 数据卷默认会一直存在，即使容器被输出\n\n## 5.2 挂载主机目录\n\n1. 挂载目录到容器目录\n\n```docker\n$ docker run -d -P \\\n    --name web \\\n    # -v /src/webapp:/usr/share/nginx/html \\\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html, readonly \\\n    nginx:alpine\n```\n\n`挂载主机目录` 的配置信息在 \"Mounts\" Key 下面\n\n- 目录与容器目录绑定，容器写进文件，就会落盘到宿主机上  \n- 目前如果source不存在就会报错  \n- 宿主机目录也可以指定readonly  \n\n2. 挂载宿主机文件到容器文件中  \n   source=  ,target= 关键字处直接替换成文件\n\n# 6. 网络\n\n## 6.1 端口映射\n\n-P 会随即映射  \n-p 特定端口映,可使用多次指定多个端口\n\n- `$ docker run -d -p 80:80 nginx:alpine` hostport:containerport  \n- `$ docker run -d -p 127.0.0.1:80:80 nginx:alpine` 指定地址绑定，容器有自己的网络和地址\n- `$ docker run -d -p 127.0.0.1::80/udp nginx:alpine` 容器80端口随机映射到主机,并指定传输协议\n\n## 6.2 容器互联\n\n1. 新建网络\n\n```docker\ndocker network create -d bridge my-net\n```\n\n`-d` 参数指定 Docker 网络类型，有 `bridge` `overlay`。其中 `overlay` 网络类型用于 [Swarm mode](/docker_practice/swarm_mode)，在本小节中你可以忽略它\n2. 容器互联\n\n```docker\ndocker run -it --rm --name busybox1 --network my-net busybox sh\ndocker run -it --rm --name busybox2 --network my-net busybox sh\n\n```\n\n可以直接ping另外的容器\n\n- Docker Compose 可以考虑使用\n\n## 6.3. 配置DNS\n\nTBC\n\n# 7. 高级网络配置\n\n# 8. Docker Buildx\n\n# 9. Docker Compose\n\n结合实战操纵理解\n\n## 9.1 搭建一个web应用\n\n- 服务：运行多个相同镜像的实例\n- 项目：一组应用容器组成的一个完整单元\n[docker compose](https://docs.docker.com/compose/compose-file/)\n\n# 10. 安全\n\n# 11. 底层实现\n\n# 12. Kubernetes\n\n# 13. 实战案例 - CI/CD\n","slug":"docker从入门到实践","published":1,"date":"2022-06-22T12:47:28.131Z","updated":"2022-09-06T11:24:41.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5f0005l1db6lco6d8y","content":"<ul>\n<li><a href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AFdocker\">1. 什么是docker</a></li>\n<li><a href=\"#2docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4\">2.docker镜像基本概念与基本命令</a><ul>\n<li><a href=\"#21-%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4\">2.1 镜像基本命令</a></li>\n<li><a href=\"#22-%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F\">2.2 定制镜像</a><ul>\n<li><a href=\"#221-%E4%BD%BF%E7%94%A8dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F\">2.2.1 使用Dockerfile定制镜像</a></li>\n<li><a href=\"#222-%E7%9B%B4%E6%8E%A5%E7%94%A8-git-repo%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\">2.2.2 直接用 Git repo构建镜像</a></li>\n<li><a href=\"#223-%E7%94%A8%E7%BD%91%E7%BB%9C%E4%BD%8D%E7%BD%AE%E4%B8%8Atar%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\">2.2.3 用网络位置上tar构建镜像</a></li>\n<li><a href=\"#224-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AE%9A%E5%88%B6\">2.2.4 从标准输入输出定制</a></li>\n<li><a href=\"#225-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA\">2.2.5 从标准输入中读取上下文压缩包进行构建</a></li>\n</ul>\n</li>\n<li><a href=\"#23-dockerfile%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3\">2.3 Dockerfile构建命令详解</a><ul>\n<li><a href=\"#231-copy%E5%A4%8D%E5%88%B6\">2.3.1 COPY复制</a></li>\n<li><a href=\"#232-add%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4\">2.3.2 ADD更高级的复制命令</a></li>\n<li><a href=\"#233-cmd%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4\">2.3.3 CMD容器启动命令</a></li>\n<li><a href=\"#234-entrypoint-%E5%85%A5%E5%8F%A3%E7%82%B9\">2.3.4 ENTRYPOINT 入口点</a></li>\n<li><a href=\"#235-env-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">2.3.5 ENV 设置环境变量</a></li>\n<li><a href=\"#236-arg-%E6%9E%84%E5%BB%BA%E6%8C%87%E4%BB%A4\">2.3.6 ARG 构建指令</a></li>\n<li><a href=\"#237-volume-%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%8D%B7\">2.3.7 VOLUME 定义匿名卷</a></li>\n<li><a href=\"#238-expose-%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3\">2.3.8 EXPOSE 暴露端口</a></li>\n<li><a href=\"#239-workdir-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95\">2.3.9 WORKDIR 指定工作目录</a></li>\n<li><a href=\"#2310-user%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7\">2.3.10 USER指定当前用户</a></li>\n<li><a href=\"#2311-healthcheck-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5healthcheck-%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%97%E9%80%89%E9%A1%B9\">2.3.11 HEALTHCHECK 健康检查<code>HEALTHCHECK</code> 支持下列选项</a></li>\n<li><a href=\"#2312-onbuild-%E4%B8%BA%E4%BB%96%E4%BA%BA%E4%BD%9C%E5%AB%81%E8%A1%A3%E8%A3%B3\">2.3.12 ONBUILD 为他人作嫁衣裳</a></li>\n<li><a href=\"#2313-label-%E4%B8%BA%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE\">2.3.13 LABEL 为镜像添加元数据</a></li>\n<li><a href=\"#2314-shell%E6%8C%87%E4%BB%A4\">2.3.14 shell指令</a></li>\n<li><a href=\"#2315-%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3\">2.3.15 参考文档</a></li>\n</ul>\n</li>\n<li><a href=\"#24-dockerfile-%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA\">2.4 Dockerfile 多阶段构建</a></li>\n<li><a href=\"#%E5%AE%9E%E6%88%98%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\">实战多阶段构建镜像</a></li>\n<li><a href=\"#25-%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81%E7%9A%84docker%E9%95%9C%E5%83%8F\">2.5 构建多种系统架构支持的docker镜像</a></li>\n<li><a href=\"#26-%E5%85%B6%E5%AE%83%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%9A%84%E6%96%B9%E5%BC%8F\">2.6 其它制作镜像的方式</a></li>\n</ul>\n</li>\n<li><a href=\"#3-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8\">3. 操作容器</a><ul>\n<li><a href=\"#31-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\">3.1 容器基本操作</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E8%AE%BF%E9%97%AE%E4%BB%93%E5%BA%93\">4. 访问仓库</a></li>\n<li><a href=\"#5-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86\">5. 数据管理</a><ul>\n<li><a href=\"#51-%E6%95%B0%E6%8D%AE%E5%8D%B7\">5.1 数据卷</a></li>\n<li><a href=\"#52-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95\">5.2 挂载主机目录</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E7%BD%91%E7%BB%9C\">6. 网络</a><ul>\n<li><a href=\"#61-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84\">6.1 端口映射</a></li>\n<li><a href=\"#62-%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94\">6.2 容器互联</a></li>\n<li><a href=\"#63-%E9%85%8D%E7%BD%AEdns\">6.3. 配置DNS</a></li>\n</ul>\n</li>\n<li><a href=\"#7-%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE\">7. 高级网络配置</a></li>\n<li><a href=\"#8-docker-buildx\">8. Docker Buildx</a></li>\n<li><a href=\"#9-docker-compose\">9. Docker Compose</a><ul>\n<li><a href=\"#91-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAweb%E5%BA%94%E7%94%A8\">9.1 搭建一个web应用</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%E5%AE%89%E5%85%A8\">10. 安全</a></li>\n<li><a href=\"#11-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0\">11. 底层实现</a></li>\n<li><a href=\"#12-kubernetes\">12. Kubernetes</a></li>\n<li><a href=\"#13-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B---cicd\">13. 实战案例 - CI&#x2F;CD</a></li>\n</ul>\n<h1 id=\"1-什么是docker\"><a href=\"#1-什么是docker\" class=\"headerlink\" title=\"1. 什么是docker\"></a>1. 什么是docker</h1><p>Docker是云技术的一次革新，2013年以Apache协议开源，基于linux内核的<strong>cgroup</strong>,<strong>namespace</strong>以及OverlayFS的<strong>UnionFS</strong>实现，对进程进行封装，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主机因此称为容器</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b5d51fa80b2435386d16496375409c2~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f40405bc364cd295076c36c9d354e5~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li><p>镜像<br>操作系统分为<code>内核</code>和<code>用户空间</code>，而docker的镜像就是一种特殊的文件系统，除了提供容器运行所需的程序，库，资源，配置等文件外，还包括为运行时准备的的一些配置参数</p>\n</li>\n<li><p>分层存储<br>Docker 设计时，就充分利用 <a href=\"https://en.wikipedia.org/wiki/Union_mount\">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>\n</li>\n<li><p>容器<br>容器跟镜像的关系就像是面向对象中类和实例的概念，容器的实质是进程，与宿主机的进程不同，容器拥有自己独立的命空间，因此拥有自己的root文件系统，自己的网络配置，自己的进程空间，自己的用户id空间。进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。<br>一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong><br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失（后面建议挂载volume）</p>\n</li>\n<li><p>仓库<br><a href=\"https://yeasy.gitbook.io/docker_practice/basic_concept/repository\">仓库</a></p>\n</li>\n</ul>\n<h1 id=\"2-docker镜像基本概念与基本命令\"><a href=\"#2-docker镜像基本概念与基本命令\" class=\"headerlink\" title=\"2.docker镜像基本概念与基本命令\"></a>2.docker镜像基本概念与基本命令</h1><h2 id=\"2-1-镜像基本命令\"><a href=\"#2-1-镜像基本命令\" class=\"headerlink\" title=\"2.1 镜像基本命令\"></a>2.1 镜像基本命令</h2><p>拉取镜像:</p>\n<ul>\n<li>docker pull [OPTION] NAME</li>\n</ul>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">&lt;域名/IP>[:端口号]</code></pre>\n\n<p>运行镜像：</p>\n<ul>\n<li>docker run -it –rm 镜像 [命令 &#x2F;bin&#x2F;bash]  参数<br>列举镜像：</li>\n<li>docker image ls</li>\n<li>docker images</li>\n<li>docker image ls -f since&#x3D;mongo:3.2 &#x2F;&#x2F;查看某个镜像之前创建的镜像，同理也有查看某个镜像之后的镜像</li>\n<li>docker ps &#x3D; docker container ls &#x2F;&#x2F;现实运行中的容器<br>查看镜像体积</li>\n<li>docker system df<br>虚悬镜像<br>仓库名和版本号都是none，这是因为新版本的镜像跟旧镜像冲突，，删除虚悬镜像</li>\n<li>docker image prune</li>\n<li>docker image ls -f dangling&#x3D;true &#x2F;&#x2F;列举虚悬镜像</li>\n<li>docker image ls -a &#x2F;&#x2F;有些none镜像不是虚悬镜像是中间镜像<br>以特定格式显示</li>\n<li>docker image ls -q</li>\n<li><code>docker image ls --format &quot;&#123;&#123; .ID &#125;&#125;:&#123;&#123; .Repository &#125;&#125;&quot; </code> &#x2F;&#x2F;支持go模板用法,方便其他程序调用</li>\n<li><code>docker image ls --format &quot;table &#123;&#123; .ID &#125;&#125; \\t &#123;&#123; .Repository &#125;&#125; \\t &#123;&#123; .Tag &#125;&#125;&quot;</code> &#x2F;&#x2F; 会显示title<br>删除镜像</li>\n<li>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</li>\n<li>docker image rm $(docker image ls -q redis)  &#x2F;&#x2F;使用docker image ls命令配合使用</li>\n</ul>\n<p>untageged和删除  </p>\n<ul>\n<li>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因</li>\n</ul>\n<p>利用commit来持久化容器变化到镜像(黑箱镜)</p>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">docker commit \\\n--author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\\n--message &quot;修改了默认网页&quot; \\\nwebserver \\\nnginx:v2</code></pre>\n\n<ul>\n<li><code>docker history</code> 具体查看镜像内的历史记录</li>\n</ul>\n<h2 id=\"2-2-定制镜像\"><a href=\"#2-2-定制镜像\" class=\"headerlink\" title=\"2.2 定制镜像\"></a>2.2 定制镜像</h2><h3 id=\"2-2-1-使用Dockerfile定制镜像\"><a href=\"#2-2-1-使用Dockerfile定制镜像\" class=\"headerlink\" title=\"2.2.1 使用Dockerfile定制镜像\"></a>2.2.1 使用Dockerfile定制镜像</h3><p><strong>From</strong> 关键字指定基础镜像<br><em><strong>RUN</strong></em> 执行命令,在撰写 Dockerfile 的时候,要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建，使用docker build 构建编写的Dockerfile  </p>\n<blockquote>\n<p><code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能,当服务端需要本地文件时候该怎么获得</p>\n</blockquote>\n<p><em><strong>COPY</strong></em>  复制 <strong>上下文（context）</strong> 目录下的源文件</p>\n<blockquote>\n<p>COPY .&#x2F;package.json &#x2F;app&#x2F;</p>\n</blockquote>\n<p>复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>,<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像</p>\n<ul>\n<li>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile</li>\n<li>如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的</li>\n<li>实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code></li>\n</ul>\n<h3 id=\"2-2-2-直接用-Git-repo构建镜像\"><a href=\"#2-2-2-直接用-Git-repo构建镜像\" class=\"headerlink\" title=\"2.2.2 直接用 Git repo构建镜像\"></a>2.2.2 直接用 Git repo构建镜像</h3><pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\"># $env:DOCKER_BUILDKIT&#x3D;0\n# export DOCKER_BUILDKIT&#x3D;0\n$ docker build -t hello-world https:&#x2F;&#x2F;github.com&#x2F;docker-library&#x2F;hello-world.git#master:amd64&#x2F;hello-world\nStep 1&#x2F;3 : FROM scratch\n---&gt;\nStep 2&#x2F;3 : COPY hello &#x2F;\n---&gt; ac779757d46e\nStep 3&#x2F;3 : CMD [&quot;&#x2F;hello&quot;]\n---&gt; Running in d2a513a760ed\nRemoving intermediate container d2a513a760ed\n---&gt; 038ad4142d2b\nSuccessfully built 038ad4142d2b</code></pre>\n\n<h3 id=\"2-2-3-用网络位置上tar构建镜像\"><a href=\"#2-2-3-用网络位置上tar构建镜像\" class=\"headerlink\" title=\"2.2.3 用网络位置上tar构建镜像\"></a>2.2.3 用网络位置上tar构建镜像</h3><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建.  </p>\n<h3 id=\"2-2-4-从标准输入输出定制\"><a href=\"#2-2-4-从标准输入输出定制\" class=\"headerlink\" title=\"2.2.4 从标准输入输出定制\"></a>2.2.4 从标准输入输出定制</h3><p>docker build - &lt; Dockerfile<br>cat Dockerfile | docker build -<br>因为没有上下文，所以Dockerfile里面不可以使用<code>copy</code>  </p>\n<h3 id=\"2-2-5-从标准输入中读取上下文压缩包进行构建\"><a href=\"#2-2-5-从标准输入中读取上下文压缩包进行构建\" class=\"headerlink\" title=\"2.2.5 从标准输入中读取上下文压缩包进行构建\"></a>2.2.5 从标准输入中读取上下文压缩包进行构建</h3><p>docker build - &lt; context.tar.gz<br>说白了就是解压后进行构建</p>\n<h2 id=\"2-3-Dockerfile构建命令详解\"><a href=\"#2-3-Dockerfile构建命令详解\" class=\"headerlink\" title=\"2.3 Dockerfile构建命令详解\"></a>2.3 Dockerfile构建命令详解</h2><h3 id=\"2-3-1-COPY复制\"><a href=\"#2-3-1-COPY复制\" class=\"headerlink\" title=\"2.3.1 COPY复制\"></a>2.3.1 COPY复制</h3><ul>\n<li>将上下文目录的文件复制到容器中的对应的目录下</li>\n<li>支持通配符</li>\n<li>源路径是相对路径，目标路径支持绝对路径</li>\n<li><code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候</li>\n<li>example</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">COPY requirements.txt &#x2F;code  &#x2F;&#x2F;copy 文件到容器中的&#x2F;code目录下</code></pre>\n\n<h3 id=\"2-3-2-ADD更高级的复制命令\"><a href=\"#2-3-2-ADD更高级的复制命令\" class=\"headerlink\" title=\"2.3.2 ADD更高级的复制命令\"></a>2.3.2 ADD更高级的复制命令</h3><ul>\n<li>源路径是tar包会在目标路径下解压(非常实用)</li>\n<li><code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</li>\n<li><code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组</li>\n</ul>\n<pre class=\"language-none\"><code class=\"language-none\">ADD --chown&#x3D;55:mygroup files* &#x2F;mydir&#x2F;\nADD --chown&#x3D;bin files* &#x2F;mydir&#x2F;\nADD --chown&#x3D;1 files* &#x2F;mydir&#x2F;\nADD --chown&#x3D;10:11 files* &#x2F;mydir&#x2F;</code></pre>\n\n<h3 id=\"2-3-3-CMD容器启动命令\"><a href=\"#2-3-3-CMD容器启动命令\" class=\"headerlink\" title=\"2.3.3 CMD容器启动命令\"></a>2.3.3 CMD容器启动命令</h3><p>容器既然是进程，那么启动时就需要指定运行参数  </p>\n<ul>\n<li>example<br><code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM ubuntu:18.04\nRUN apt-get update \\\n&amp;&amp; apt-get install -y curl \\\n&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\nCMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]</code></pre>\n\n<p>这个时候运行容器，docker run myip 就会打印ip相关信息，但是如果你想加参数<code>-i</code>，以如下方式<br><code>docker run myip -i</code> 就会报错，因为myip后面传入的参数会被认为是命令，而正确是的方式是<br><code>docker run myip curl -s http://myip.ipip.net -i</code>，显然这不是一个好的方案。可以使用2.3.4的参数来设计</p>\n<h3 id=\"2-3-4-ENTRYPOINT-入口点\"><a href=\"#2-3-4-ENTRYPOINT-入口点\" class=\"headerlink\" title=\"2.3.4 ENTRYPOINT 入口点\"></a>2.3.4 ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数,例子如下</p>\n<ul>\n<li>场景一:让镜像像命令一样使用<code>ENTRYPOINT</code></li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM ubuntu:18.04\nRUN apt-get update \\\n&amp;&amp; apt-get install -y curl \\\n&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\nENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]\n&#x2F;&#x2F;再次尝试跑 docker run myip -i，就会将-i作为参数传给curl命令</code></pre>\n\n<ul>\n<li>场景二: 应用运行前的准备工作<br>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM alpine:3.4\nRUN addgroup -S redis &amp;&amp; adduser -S -G redis redis\nENTRYPOINT [&quot;docker-entrypoint.sh&quot;]\nEXPOSE 6379\nCMD [ &quot;redis-server&quot; ]\n&#x2F;&#x2F;redis服务创建了redis用户，并在最后ENTRYPOINT指定了entrypoint.sh的脚本,该脚本的内容就是根据CMD的内容\n&#x2F;&#x2F;来判断，如果是redis-server的话，则切换到redis用户身份启动服务器，否则依旧使用root身份执行。比如：</code></pre>\n\n<h3 id=\"2-3-5-ENV-设置环境变量\"><a href=\"#2-3-5-ENV-设置环境变量\" class=\"headerlink\" title=\"2.3.5 ENV 设置环境变量\"></a>2.3.5 ENV 设置环境变量</h3><p>可以为后面的RUN命令提供环境变量，是以键值对的形式存在，如果value部分有空格，需要使用双引号括起来</p>\n<h3 id=\"2-3-6-ARG-构建指令\"><a href=\"#2-3-6-ARG-构建指令\" class=\"headerlink\" title=\"2.3.6 ARG 构建指令\"></a>2.3.6 ARG 构建指令</h3><p>ARG指令有生效范围，如果在FROM之前指定的，那么只能用于<code>FROM</code>指令中</p>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">ARG DOCKER_USERNAME&#x3D;library\nFROM $&#123;DOCKER_USERNAME&#125;&#x2F;alpine\nRUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</code></pre>\n\n<p><code>RUN</code>拿不到变量值，要想使用只能是在<code>FROM</code>命令后面重新指定<code>ARG</code>,多阶段构建需要指定各个阶段的<code>ARG</code></p>\n<h3 id=\"2-3-7-VOLUME-定义匿名卷\"><a href=\"#2-3-7-VOLUME-定义匿名卷\" class=\"headerlink\" title=\"2.3.7 VOLUME 定义匿名卷\"></a>2.3.7 VOLUME 定义匿名卷</h3><p><code>VOLUME /data</code> 挂在匿名卷,向容器&#x2F;data写入的数据最终会落入host磁盘<br><code>$ docker run -d -v mydata:/data xxxx</code><br>就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置</p>\n<h3 id=\"2-3-8-EXPOSE-暴露端口\"><a href=\"#2-3-8-EXPOSE-暴露端口\" class=\"headerlink\" title=\"2.3.8 EXPOSE 暴露端口\"></a>2.3.8 EXPOSE 暴露端口</h3><p>与-p &lt;宿主端口&gt;:&lt;容器端口&gt;, 映射端口不通，EXPOSE是暴漏容器端口给其他容器</p>\n<h3 id=\"2-3-9-WORKDIR-指定工作目录\"><a href=\"#2-3-9-WORKDIR-指定工作目录\" class=\"headerlink\" title=\"2.3.9 WORKDIR 指定工作目录\"></a>2.3.9 WORKDIR 指定工作目录</h3><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录</p>\n<h3 id=\"2-3-10-USER指定当前用户\"><a href=\"#2-3-10-USER指定当前用户\" class=\"headerlink\" title=\"2.3.10 USER指定当前用户\"></a>2.3.10 USER指定当前用户</h3><p><code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>\n<h3 id=\"2-3-11-HEALTHCHECK-健康检查HEALTHCHECK-支持下列选项\"><a href=\"#2-3-11-HEALTHCHECK-健康检查HEALTHCHECK-支持下列选项\" class=\"headerlink\" title=\"2.3.11 HEALTHCHECK 健康检查HEALTHCHECK 支持下列选项\"></a>2.3.11 HEALTHCHECK 健康检查<code>HEALTHCHECK</code> 支持下列选项</h3><ul>\n<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>\n<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>\n<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM nginx\nRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\nHEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \\\nCMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1\n\n&#x2F;&#x2F;这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），\n&#x2F;&#x2F;如果健康检查命令超过 3 &#x2F;&#x2F;秒没响应就视为失败，并且使用 &#96;curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1&#96;\n&#x2F;&#x2F;作为健康检查命令。</code></pre>\n\n<h3 id=\"2-3-12-ONBUILD-为他人作嫁衣裳\"><a href=\"#2-3-12-ONBUILD-为他人作嫁衣裳\" class=\"headerlink\" title=\"2.3.12 ONBUILD 为他人作嫁衣裳\"></a>2.3.12 ONBUILD 为他人作嫁衣裳</h3><h3 id=\"2-3-13-LABEL-为镜像添加元数据\"><a href=\"#2-3-13-LABEL-为镜像添加元数据\" class=\"headerlink\" title=\"2.3.13 LABEL 为镜像添加元数据\"></a>2.3.13 LABEL 为镜像添加元数据</h3><p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">LABEL org.opencontainers.image.authors<span class=\"token operator\">=</span><span class=\"token string\">\"yeasy\"</span>\nLABEL org.opencontainers.image.documentation<span class=\"token operator\">=</span><span class=\"token string\">\"https://yeasy.gitbooks.io\"</span></code></pre>\n\n<h3 id=\"2-3-14-shell指令\"><a href=\"#2-3-14-shell指令\" class=\"headerlink\" title=\"2.3.14 shell指令\"></a>2.3.14 shell指令</h3><p><code>SHELL</code> 指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell程序，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code></p>\n<h3 id=\"2-3-15-参考文档\"><a href=\"#2-3-15-参考文档\" class=\"headerlink\" title=\"2.3.15 参考文档\"></a>2.3.15 参考文档</h3><ul>\n<li><p><code>Dockerfie</code> 官方文档：<a href=\"https://docs.docker.com/engine/reference/builder/\">https://docs.docker.com/engine/reference/builder/</a></p>\n</li>\n<li><p><code>Dockerfile</code> 最佳实践文档：<a href=\"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/\">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p>\n</li>\n<li><p><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a href=\"https://github.com/docker-library/docs\">https://github.com/docker-library/docs</a></p>\n</li>\n</ul>\n<h2 id=\"2-4-Dockerfile-多阶段构建\"><a href=\"#2-4-Dockerfile-多阶段构建\" class=\"headerlink\" title=\"2.4 Dockerfile 多阶段构建\"></a>2.4 Dockerfile 多阶段构建</h2><ul>\n<li>以前是全部放到一个Dockerfile里面，将编译，测试，打包放在一起，可能导致镜像层次过多，源代码泄露风险</li>\n<li>分多个Dockerfile编写，然后指定文件逐个构建</li>\n<li>使用多阶段构建</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM golang:alpine as builder\nRUN apk --no-cache add git\nWORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;\nRUN go get -d -v github.com&#x2F;go-sql-driver&#x2F;mysql\nCOPY app.go .\nRUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .\nFROM alpine:latest as prod\nRUN apk --no-cache add ca-certificates\nWORKDIR &#x2F;root&#x2F;\nCOPY --from&#x3D;0 &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;app .\nCMD [&quot;.&#x2F;app&quot;]\n&#x2F;&#x2F; 构建镜像  docker build -t go&#x2F;helloworld:3 .</code></pre>\n\n<pre><code>- 我们可以使用 `as` 来为某一阶段命名，例如`FROM golang:alpine as builder`\n- 例如当我们只想构建 `builder` 阶段的镜像时，增加 `--target=builder` 参数即可 `$ docker build --target builder -t username/imagename:tag .`\n</code></pre>\n<ul>\n<li>构建时从其他镜像复制文件<br>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件<br><code>$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code></li>\n</ul>\n<h2 id=\"实战多阶段构建镜像\"><a href=\"#实战多阶段构建镜像\" class=\"headerlink\" title=\"实战多阶段构建镜像\"></a>实战多阶段构建镜像</h2><p><a href=\"https://github.com/nigelpoulton/dotnet-docker-samples.git\">实战地址</a>  </p>\n<ul>\n<li><p>生产环境多阶段构建需要保持镜像精简，可以通过&amp;&amp;精简镜像层</p>\n</li>\n<li><p>run指令执行完会残留构建镜像完后的文件，直接上生产及其不妥，docker提供了多种方式解决这个问题，重瞳方式叫<code>建造者模式</code></p>\n<ol>\n<li>构建<code>Dockerfile.dev</code>文件</li>\n<li>在此基础之上构建新一层镜像</li>\n<li>编写Dockerfile.prod，把上一步容器的相关代码和文件复制过来</li>\n</ol>\n</li>\n<li><p>多阶段构建方式<br>分析Dockerfile文件</p>\n</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM mcr.microsoft.com&#x2F;dotnet&#x2F;sdk:6.0 AS build\nWORKDIR &#x2F;source\n\n# copy csproj and restore as distinct layers\nCOPY *.sln .\nCOPY aspnetapp&#x2F;*.csproj .&#x2F;aspnetapp&#x2F;\nRUN dotnet restore\n\n# copy everything else and build app\nCOPY aspnetapp&#x2F;. .&#x2F;aspnetapp&#x2F;\nWORKDIR &#x2F;source&#x2F;aspnetapp\nRUN dotnet publish -c release -o &#x2F;app --no-restore\n\n# final stage&#x2F;image\nFROM mcr.microsoft.com&#x2F;dotnet&#x2F;aspnet:6.0\nWORKDIR &#x2F;app\nCOPY --from&#x3D;build &#x2F;app .&#x2F;\nENTRYPOINT [&quot;dotnet&quot;, &quot;aspnetapp.dll&quot;]</code></pre>\n\n<p>首先注意到，<code>Dockerfile</code>有三个<code>FROM</code>指令。每一个<code>FROM</code>指令构成一个单独的<strong>构建阶段</strong>  </p>\n<ol>\n<li><p>阶段<code>0</code>：<code>build-env</code><br> <code>build-env</code>阶段拉取了<code>aspnetcore-build:2.0</code>作为基础镜像，然后设置了工作目录，复制一些应用代码，接着执行两个<code>RUN</code>指令，生成<code>1</code>个镜像层并显著得到一个比原镜像大得多的镜像，包含许多构建工具和应用代码</p>\n</li>\n<li><p>阶段<code>1</code>：<code>microsoft/aspnetcore:2.0</code><br> <code>aspnetcore:2.0</code>阶段拉取了<code>aspnetcore:2.0</code>作为基础镜像，设置工作目录，然后执行<code>COPY --from</code>指令从<code>build-env</code>阶段生成的镜像中复制一些应用代码过来，最后执行<code>ENTRYPOINT</code>指令指定容器的默认应用程序</p>\n</li>\n</ol>\n<p>上述构建过程的重点在于<code>COPY --from</code>指令<strong>表示从之前的构建阶段复制生产环境相关的应用代码，而不会复制生产环境不需要的构件</strong></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7053651f6091402c9c8ff10c99d1ae34~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2 id=\"2-5-构建多种系统架构支持的docker镜像\"><a href=\"#2-5-构建多种系统架构支持的docker镜像\" class=\"headerlink\" title=\"2.5 构建多种系统架构支持的docker镜像\"></a>2.5 构建多种系统架构支持的docker镜像</h2><p><code>$ docker manifest inspect golang:alpine</code><br>查看manifest列表</p>\n<ul>\n<li>创建manifest 列表</li>\n<li>设置manifest列表</li>\n<li>查看manifest列表</li>\n<li>推送manifest列表</li>\n<li>测试</li>\n<li><a href=\"https://www.docker.com/blog/multi-arch-all-the-things/\">官方博客</a></li>\n</ul>\n<h2 id=\"2-6-其它制作镜像的方式\"><a href=\"#2-6-其它制作镜像的方式\" class=\"headerlink\" title=\"2.6 其它制作镜像的方式\"></a>2.6 其它制作镜像的方式</h2><ul>\n<li>从 rootfs 压缩包导入</li>\n</ul>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">$ docker import \\\n    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \\\n    openvz/ubuntu:16.04\n\nDownloading from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz\nsha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213\n// 从web远程下载ubuntu然后制作镜像</code></pre>\n\n<ul>\n<li>Docker 镜像的导入和导出 <code>docker save</code> 和 <code>docker load</code> ，目前已经不推荐</li>\n</ul>\n<h1 id=\"3-操作容器\"><a href=\"#3-操作容器\" class=\"headerlink\" title=\"3. 操作容器\"></a>3. 操作容器</h1><h2 id=\"3-1-容器基本操作\"><a href=\"#3-1-容器基本操作\" class=\"headerlink\" title=\"3.1 容器基本操作\"></a>3.1 容器基本操作</h2><p>两种启动容器方式，从镜像到容器，启动停止的容器</p>\n<ul>\n<li>新建容器</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">$ docker run -dit --name new_name ubuntu:18.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;\nHello world</code></pre>\n\n<p>-itd 意思是指容器绑定标准输入输出，然后绑定个伪终端，然后以守护态运行<br>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令</p>\n<ul>\n<li>stop&#x2F;restart 容器<br>docker container ls &#x2F;&#x2F;查看容器<br>docker container restart<br>docker container stop&#x2F;start</li>\n<li>进入容器<br><code>docker attach</code> 进入容器<br><code>docker exec -it</code> 进入容器</li>\n<li>导出&#x2F;导入容器<br><code>docker export 7691a814370e &gt; ubuntu.tar</code><br><code>docker import - test/ubuntu:v1.0</code><br><code>docker import url</code></li>\n<li>删除容器<br><code>docker container rm trusting_newton</code><br><code>docker container prune</code> 清理所有种植状态的容器</li>\n</ul>\n<h1 id=\"4-访问仓库\"><a href=\"#4-访问仓库\" class=\"headerlink\" title=\"4. 访问仓库\"></a>4. 访问仓库</h1><ol>\n<li>docker hub</li>\n<li>私有仓库</li>\n<li>私有仓库高级配置</li>\n<li>nexus3</li>\n</ol>\n<h1 id=\"5-数据管理\"><a href=\"#5-数据管理\" class=\"headerlink\" title=\"5. 数据管理\"></a>5. 数据管理</h1><h2 id=\"5-1-数据卷\"><a href=\"#5-1-数据卷\" class=\"headerlink\" title=\"5.1 数据卷\"></a>5.1 数据卷</h2><p>对数据卷的使用有点像linux的mount，镜像中被挂载的目录文件会复制到宿主机的目录上，独立于容器</p>\n<ol>\n<li>创建一个数据卷</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker volume create my-vol  创建一个数据卷  \ndocker volume ls  列举数据卷  \ndocker volume inspect my_vol 查看某一个数据卷  </code></pre>\n\n<ol start=\"2\">\n<li>启动一个挂在了数据卷的容器</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker run -d -P \\\n    --name web \\\n    <span class=\"token comment\"># -v my-vol:/usr/share/nginx/html \\</span>\n    --mount source=my-vol,target=/usr/share/nginx/html \\\n    nginx:alpine\n//使用my_vol数据卷，映射到/usr/share/nginx/html</code></pre>\n\n<ol start=\"3\">\n<li>查看数据卷具体信息</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker inspect web //数据卷信息在Mounts key下\n....\n\"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\" //默认位置</code></pre>\n\n<p>4.删除一个数据卷</p>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker volume rm my-vol\ndocker volume prune //删除无主的数据卷</code></pre>\n\n<ul>\n<li>数据卷可以在容器间共用</li>\n<li>对数据卷的修改会立马生效</li>\n<li>对数据卷的更新，不会影响镜像</li>\n<li>数据卷默认会一直存在，即使容器被输出</li>\n</ul>\n<h2 id=\"5-2-挂载主机目录\"><a href=\"#5-2-挂载主机目录\" class=\"headerlink\" title=\"5.2 挂载主机目录\"></a>5.2 挂载主机目录</h2><ol>\n<li>挂载目录到容器目录</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">$ docker run -d -P \\\n    --name web \\\n    <span class=\"token comment\"># -v /src/webapp:/usr/share/nginx/html \\</span>\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html, readonly \\\n    nginx:alpine</code></pre>\n\n<p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p>\n<ul>\n<li>目录与容器目录绑定，容器写进文件，就会落盘到宿主机上  </li>\n<li>目前如果source不存在就会报错  </li>\n<li>宿主机目录也可以指定readonly</li>\n</ul>\n<ol start=\"2\">\n<li>挂载宿主机文件到容器文件中<br>source&#x3D;  ,target&#x3D; 关键字处直接替换成文件</li>\n</ol>\n<h1 id=\"6-网络\"><a href=\"#6-网络\" class=\"headerlink\" title=\"6. 网络\"></a>6. 网络</h1><h2 id=\"6-1-端口映射\"><a href=\"#6-1-端口映射\" class=\"headerlink\" title=\"6.1 端口映射\"></a>6.1 端口映射</h2><p>-P 会随即映射<br>-p 特定端口映,可使用多次指定多个端口</p>\n<ul>\n<li><code>$ docker run -d -p 80:80 nginx:alpine</code> hostport:containerport  </li>\n<li><code>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</code> 指定地址绑定，容器有自己的网络和地址</li>\n<li><code>$ docker run -d -p 127.0.0.1::80/udp nginx:alpine</code> 容器80端口随机映射到主机,并指定传输协议</li>\n</ul>\n<h2 id=\"6-2-容器互联\"><a href=\"#6-2-容器互联\" class=\"headerlink\" title=\"6.2 容器互联\"></a>6.2 容器互联</h2><ol>\n<li>新建网络</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker network create -d bridge my-net</code></pre>\n\n<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href=\"/docker_practice/swarm_mode\">Swarm mode</a>，在本小节中你可以忽略它<br>2. 容器互联</p>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker run -it --rm --name busybox1 --network my-net busybox sh\ndocker run -it --rm --name busybox2 --network my-net busybox sh\n</code></pre>\n\n<p>可以直接ping另外的容器</p>\n<ul>\n<li>Docker Compose 可以考虑使用</li>\n</ul>\n<h2 id=\"6-3-配置DNS\"><a href=\"#6-3-配置DNS\" class=\"headerlink\" title=\"6.3. 配置DNS\"></a>6.3. 配置DNS</h2><p>TBC</p>\n<h1 id=\"7-高级网络配置\"><a href=\"#7-高级网络配置\" class=\"headerlink\" title=\"7. 高级网络配置\"></a>7. 高级网络配置</h1><h1 id=\"8-Docker-Buildx\"><a href=\"#8-Docker-Buildx\" class=\"headerlink\" title=\"8. Docker Buildx\"></a>8. Docker Buildx</h1><h1 id=\"9-Docker-Compose\"><a href=\"#9-Docker-Compose\" class=\"headerlink\" title=\"9. Docker Compose\"></a>9. Docker Compose</h1><p>结合实战操纵理解</p>\n<h2 id=\"9-1-搭建一个web应用\"><a href=\"#9-1-搭建一个web应用\" class=\"headerlink\" title=\"9.1 搭建一个web应用\"></a>9.1 搭建一个web应用</h2><ul>\n<li>服务：运行多个相同镜像的实例</li>\n<li>项目：一组应用容器组成的一个完整单元<br><a href=\"https://docs.docker.com/compose/compose-file/\">docker compose</a></li>\n</ul>\n<h1 id=\"10-安全\"><a href=\"#10-安全\" class=\"headerlink\" title=\"10. 安全\"></a>10. 安全</h1><h1 id=\"11-底层实现\"><a href=\"#11-底层实现\" class=\"headerlink\" title=\"11. 底层实现\"></a>11. 底层实现</h1><h1 id=\"12-Kubernetes\"><a href=\"#12-Kubernetes\" class=\"headerlink\" title=\"12. Kubernetes\"></a>12. Kubernetes</h1><h1 id=\"13-实战案例-CI-x2F-CD\"><a href=\"#13-实战案例-CI-x2F-CD\" class=\"headerlink\" title=\"13. 实战案例 - CI&#x2F;CD\"></a>13. 实战案例 - CI&#x2F;CD</h1>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AFdocker\">1. 什么是docker</a></li>\n<li><a href=\"#2docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4\">2.docker镜像基本概念与基本命令</a><ul>\n<li><a href=\"#21-%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4\">2.1 镜像基本命令</a></li>\n<li><a href=\"#22-%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F\">2.2 定制镜像</a><ul>\n<li><a href=\"#221-%E4%BD%BF%E7%94%A8dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F\">2.2.1 使用Dockerfile定制镜像</a></li>\n<li><a href=\"#222-%E7%9B%B4%E6%8E%A5%E7%94%A8-git-repo%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\">2.2.2 直接用 Git repo构建镜像</a></li>\n<li><a href=\"#223-%E7%94%A8%E7%BD%91%E7%BB%9C%E4%BD%8D%E7%BD%AE%E4%B8%8Atar%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\">2.2.3 用网络位置上tar构建镜像</a></li>\n<li><a href=\"#224-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AE%9A%E5%88%B6\">2.2.4 从标准输入输出定制</a></li>\n<li><a href=\"#225-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA\">2.2.5 从标准输入中读取上下文压缩包进行构建</a></li>\n</ul>\n</li>\n<li><a href=\"#23-dockerfile%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3\">2.3 Dockerfile构建命令详解</a><ul>\n<li><a href=\"#231-copy%E5%A4%8D%E5%88%B6\">2.3.1 COPY复制</a></li>\n<li><a href=\"#232-add%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4\">2.3.2 ADD更高级的复制命令</a></li>\n<li><a href=\"#233-cmd%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4\">2.3.3 CMD容器启动命令</a></li>\n<li><a href=\"#234-entrypoint-%E5%85%A5%E5%8F%A3%E7%82%B9\">2.3.4 ENTRYPOINT 入口点</a></li>\n<li><a href=\"#235-env-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">2.3.5 ENV 设置环境变量</a></li>\n<li><a href=\"#236-arg-%E6%9E%84%E5%BB%BA%E6%8C%87%E4%BB%A4\">2.3.6 ARG 构建指令</a></li>\n<li><a href=\"#237-volume-%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%8D%B7\">2.3.7 VOLUME 定义匿名卷</a></li>\n<li><a href=\"#238-expose-%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3\">2.3.8 EXPOSE 暴露端口</a></li>\n<li><a href=\"#239-workdir-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95\">2.3.9 WORKDIR 指定工作目录</a></li>\n<li><a href=\"#2310-user%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7\">2.3.10 USER指定当前用户</a></li>\n<li><a href=\"#2311-healthcheck-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5healthcheck-%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%97%E9%80%89%E9%A1%B9\">2.3.11 HEALTHCHECK 健康检查<code>HEALTHCHECK</code> 支持下列选项</a></li>\n<li><a href=\"#2312-onbuild-%E4%B8%BA%E4%BB%96%E4%BA%BA%E4%BD%9C%E5%AB%81%E8%A1%A3%E8%A3%B3\">2.3.12 ONBUILD 为他人作嫁衣裳</a></li>\n<li><a href=\"#2313-label-%E4%B8%BA%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE\">2.3.13 LABEL 为镜像添加元数据</a></li>\n<li><a href=\"#2314-shell%E6%8C%87%E4%BB%A4\">2.3.14 shell指令</a></li>\n<li><a href=\"#2315-%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3\">2.3.15 参考文档</a></li>\n</ul>\n</li>\n<li><a href=\"#24-dockerfile-%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA\">2.4 Dockerfile 多阶段构建</a></li>\n<li><a href=\"#%E5%AE%9E%E6%88%98%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\">实战多阶段构建镜像</a></li>\n<li><a href=\"#25-%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81%E7%9A%84docker%E9%95%9C%E5%83%8F\">2.5 构建多种系统架构支持的docker镜像</a></li>\n<li><a href=\"#26-%E5%85%B6%E5%AE%83%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%9A%84%E6%96%B9%E5%BC%8F\">2.6 其它制作镜像的方式</a></li>\n</ul>\n</li>\n<li><a href=\"#3-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8\">3. 操作容器</a><ul>\n<li><a href=\"#31-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\">3.1 容器基本操作</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E8%AE%BF%E9%97%AE%E4%BB%93%E5%BA%93\">4. 访问仓库</a></li>\n<li><a href=\"#5-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86\">5. 数据管理</a><ul>\n<li><a href=\"#51-%E6%95%B0%E6%8D%AE%E5%8D%B7\">5.1 数据卷</a></li>\n<li><a href=\"#52-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95\">5.2 挂载主机目录</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E7%BD%91%E7%BB%9C\">6. 网络</a><ul>\n<li><a href=\"#61-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84\">6.1 端口映射</a></li>\n<li><a href=\"#62-%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94\">6.2 容器互联</a></li>\n<li><a href=\"#63-%E9%85%8D%E7%BD%AEdns\">6.3. 配置DNS</a></li>\n</ul>\n</li>\n<li><a href=\"#7-%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE\">7. 高级网络配置</a></li>\n<li><a href=\"#8-docker-buildx\">8. Docker Buildx</a></li>\n<li><a href=\"#9-docker-compose\">9. Docker Compose</a><ul>\n<li><a href=\"#91-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAweb%E5%BA%94%E7%94%A8\">9.1 搭建一个web应用</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%E5%AE%89%E5%85%A8\">10. 安全</a></li>\n<li><a href=\"#11-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0\">11. 底层实现</a></li>\n<li><a href=\"#12-kubernetes\">12. Kubernetes</a></li>\n<li><a href=\"#13-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B---cicd\">13. 实战案例 - CI&#x2F;CD</a></li>\n</ul>\n<h1 id=\"1-什么是docker\"><a href=\"#1-什么是docker\" class=\"headerlink\" title=\"1. 什么是docker\"></a>1. 什么是docker</h1><p>Docker是云技术的一次革新，2013年以Apache协议开源，基于linux内核的<strong>cgroup</strong>,<strong>namespace</strong>以及OverlayFS的<strong>UnionFS</strong>实现，对进程进行封装，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主机因此称为容器</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b5d51fa80b2435386d16496375409c2~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f40405bc364cd295076c36c9d354e5~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li><p>镜像<br>操作系统分为<code>内核</code>和<code>用户空间</code>，而docker的镜像就是一种特殊的文件系统，除了提供容器运行所需的程序，库，资源，配置等文件外，还包括为运行时准备的的一些配置参数</p>\n</li>\n<li><p>分层存储<br>Docker 设计时，就充分利用 <a href=\"https://en.wikipedia.org/wiki/Union_mount\">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>\n</li>\n<li><p>容器<br>容器跟镜像的关系就像是面向对象中类和实例的概念，容器的实质是进程，与宿主机的进程不同，容器拥有自己独立的命空间，因此拥有自己的root文件系统，自己的网络配置，自己的进程空间，自己的用户id空间。进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。<br>一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong><br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失（后面建议挂载volume）</p>\n</li>\n<li><p>仓库<br><a href=\"https://yeasy.gitbook.io/docker_practice/basic_concept/repository\">仓库</a></p>\n</li>\n</ul>\n<h1 id=\"2-docker镜像基本概念与基本命令\"><a href=\"#2-docker镜像基本概念与基本命令\" class=\"headerlink\" title=\"2.docker镜像基本概念与基本命令\"></a>2.docker镜像基本概念与基本命令</h1><h2 id=\"2-1-镜像基本命令\"><a href=\"#2-1-镜像基本命令\" class=\"headerlink\" title=\"2.1 镜像基本命令\"></a>2.1 镜像基本命令</h2><p>拉取镜像:</p>\n<ul>\n<li>docker pull [OPTION] NAME</li>\n</ul>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">&lt;域名/IP>[:端口号]</code></pre>\n\n<p>运行镜像：</p>\n<ul>\n<li>docker run -it –rm 镜像 [命令 &#x2F;bin&#x2F;bash]  参数<br>列举镜像：</li>\n<li>docker image ls</li>\n<li>docker images</li>\n<li>docker image ls -f since&#x3D;mongo:3.2 &#x2F;&#x2F;查看某个镜像之前创建的镜像，同理也有查看某个镜像之后的镜像</li>\n<li>docker ps &#x3D; docker container ls &#x2F;&#x2F;现实运行中的容器<br>查看镜像体积</li>\n<li>docker system df<br>虚悬镜像<br>仓库名和版本号都是none，这是因为新版本的镜像跟旧镜像冲突，，删除虚悬镜像</li>\n<li>docker image prune</li>\n<li>docker image ls -f dangling&#x3D;true &#x2F;&#x2F;列举虚悬镜像</li>\n<li>docker image ls -a &#x2F;&#x2F;有些none镜像不是虚悬镜像是中间镜像<br>以特定格式显示</li>\n<li>docker image ls -q</li>\n<li><code>docker image ls --format &quot;&#123;&#123; .ID &#125;&#125;:&#123;&#123; .Repository &#125;&#125;&quot; </code> &#x2F;&#x2F;支持go模板用法,方便其他程序调用</li>\n<li><code>docker image ls --format &quot;table &#123;&#123; .ID &#125;&#125; \\t &#123;&#123; .Repository &#125;&#125; \\t &#123;&#123; .Tag &#125;&#125;&quot;</code> &#x2F;&#x2F; 会显示title<br>删除镜像</li>\n<li>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</li>\n<li>docker image rm $(docker image ls -q redis)  &#x2F;&#x2F;使用docker image ls命令配合使用</li>\n</ul>\n<p>untageged和删除  </p>\n<ul>\n<li>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因</li>\n</ul>\n<p>利用commit来持久化容器变化到镜像(黑箱镜)</p>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">docker commit \\\n--author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\\n--message &quot;修改了默认网页&quot; \\\nwebserver \\\nnginx:v2</code></pre>\n\n<ul>\n<li><code>docker history</code> 具体查看镜像内的历史记录</li>\n</ul>\n<h2 id=\"2-2-定制镜像\"><a href=\"#2-2-定制镜像\" class=\"headerlink\" title=\"2.2 定制镜像\"></a>2.2 定制镜像</h2><h3 id=\"2-2-1-使用Dockerfile定制镜像\"><a href=\"#2-2-1-使用Dockerfile定制镜像\" class=\"headerlink\" title=\"2.2.1 使用Dockerfile定制镜像\"></a>2.2.1 使用Dockerfile定制镜像</h3><p><strong>From</strong> 关键字指定基础镜像<br><em><strong>RUN</strong></em> 执行命令,在撰写 Dockerfile 的时候,要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建，使用docker build 构建编写的Dockerfile  </p>\n<blockquote>\n<p><code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能,当服务端需要本地文件时候该怎么获得</p>\n</blockquote>\n<p><em><strong>COPY</strong></em>  复制 <strong>上下文（context）</strong> 目录下的源文件</p>\n<blockquote>\n<p>COPY .&#x2F;package.json &#x2F;app&#x2F;</p>\n</blockquote>\n<p>复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>,<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像</p>\n<ul>\n<li>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile</li>\n<li>如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的</li>\n<li>实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code></li>\n</ul>\n<h3 id=\"2-2-2-直接用-Git-repo构建镜像\"><a href=\"#2-2-2-直接用-Git-repo构建镜像\" class=\"headerlink\" title=\"2.2.2 直接用 Git repo构建镜像\"></a>2.2.2 直接用 Git repo构建镜像</h3><pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\"># $env:DOCKER_BUILDKIT&#x3D;0\n# export DOCKER_BUILDKIT&#x3D;0\n$ docker build -t hello-world https:&#x2F;&#x2F;github.com&#x2F;docker-library&#x2F;hello-world.git#master:amd64&#x2F;hello-world\nStep 1&#x2F;3 : FROM scratch\n---&gt;\nStep 2&#x2F;3 : COPY hello &#x2F;\n---&gt; ac779757d46e\nStep 3&#x2F;3 : CMD [&quot;&#x2F;hello&quot;]\n---&gt; Running in d2a513a760ed\nRemoving intermediate container d2a513a760ed\n---&gt; 038ad4142d2b\nSuccessfully built 038ad4142d2b</code></pre>\n\n<h3 id=\"2-2-3-用网络位置上tar构建镜像\"><a href=\"#2-2-3-用网络位置上tar构建镜像\" class=\"headerlink\" title=\"2.2.3 用网络位置上tar构建镜像\"></a>2.2.3 用网络位置上tar构建镜像</h3><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建.  </p>\n<h3 id=\"2-2-4-从标准输入输出定制\"><a href=\"#2-2-4-从标准输入输出定制\" class=\"headerlink\" title=\"2.2.4 从标准输入输出定制\"></a>2.2.4 从标准输入输出定制</h3><p>docker build - &lt; Dockerfile<br>cat Dockerfile | docker build -<br>因为没有上下文，所以Dockerfile里面不可以使用<code>copy</code>  </p>\n<h3 id=\"2-2-5-从标准输入中读取上下文压缩包进行构建\"><a href=\"#2-2-5-从标准输入中读取上下文压缩包进行构建\" class=\"headerlink\" title=\"2.2.5 从标准输入中读取上下文压缩包进行构建\"></a>2.2.5 从标准输入中读取上下文压缩包进行构建</h3><p>docker build - &lt; context.tar.gz<br>说白了就是解压后进行构建</p>\n<h2 id=\"2-3-Dockerfile构建命令详解\"><a href=\"#2-3-Dockerfile构建命令详解\" class=\"headerlink\" title=\"2.3 Dockerfile构建命令详解\"></a>2.3 Dockerfile构建命令详解</h2><h3 id=\"2-3-1-COPY复制\"><a href=\"#2-3-1-COPY复制\" class=\"headerlink\" title=\"2.3.1 COPY复制\"></a>2.3.1 COPY复制</h3><ul>\n<li>将上下文目录的文件复制到容器中的对应的目录下</li>\n<li>支持通配符</li>\n<li>源路径是相对路径，目标路径支持绝对路径</li>\n<li><code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候</li>\n<li>example</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">COPY requirements.txt &#x2F;code  &#x2F;&#x2F;copy 文件到容器中的&#x2F;code目录下</code></pre>\n\n<h3 id=\"2-3-2-ADD更高级的复制命令\"><a href=\"#2-3-2-ADD更高级的复制命令\" class=\"headerlink\" title=\"2.3.2 ADD更高级的复制命令\"></a>2.3.2 ADD更高级的复制命令</h3><ul>\n<li>源路径是tar包会在目标路径下解压(非常实用)</li>\n<li><code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</li>\n<li><code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组</li>\n</ul>\n<pre class=\"language-none\"><code class=\"language-none\">ADD --chown&#x3D;55:mygroup files* &#x2F;mydir&#x2F;\nADD --chown&#x3D;bin files* &#x2F;mydir&#x2F;\nADD --chown&#x3D;1 files* &#x2F;mydir&#x2F;\nADD --chown&#x3D;10:11 files* &#x2F;mydir&#x2F;</code></pre>\n\n<h3 id=\"2-3-3-CMD容器启动命令\"><a href=\"#2-3-3-CMD容器启动命令\" class=\"headerlink\" title=\"2.3.3 CMD容器启动命令\"></a>2.3.3 CMD容器启动命令</h3><p>容器既然是进程，那么启动时就需要指定运行参数  </p>\n<ul>\n<li>example<br><code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM ubuntu:18.04\nRUN apt-get update \\\n&amp;&amp; apt-get install -y curl \\\n&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\nCMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]</code></pre>\n\n<p>这个时候运行容器，docker run myip 就会打印ip相关信息，但是如果你想加参数<code>-i</code>，以如下方式<br><code>docker run myip -i</code> 就会报错，因为myip后面传入的参数会被认为是命令，而正确是的方式是<br><code>docker run myip curl -s http://myip.ipip.net -i</code>，显然这不是一个好的方案。可以使用2.3.4的参数来设计</p>\n<h3 id=\"2-3-4-ENTRYPOINT-入口点\"><a href=\"#2-3-4-ENTRYPOINT-入口点\" class=\"headerlink\" title=\"2.3.4 ENTRYPOINT 入口点\"></a>2.3.4 ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数,例子如下</p>\n<ul>\n<li>场景一:让镜像像命令一样使用<code>ENTRYPOINT</code></li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM ubuntu:18.04\nRUN apt-get update \\\n&amp;&amp; apt-get install -y curl \\\n&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\nENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]\n&#x2F;&#x2F;再次尝试跑 docker run myip -i，就会将-i作为参数传给curl命令</code></pre>\n\n<ul>\n<li>场景二: 应用运行前的准备工作<br>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM alpine:3.4\nRUN addgroup -S redis &amp;&amp; adduser -S -G redis redis\nENTRYPOINT [&quot;docker-entrypoint.sh&quot;]\nEXPOSE 6379\nCMD [ &quot;redis-server&quot; ]\n&#x2F;&#x2F;redis服务创建了redis用户，并在最后ENTRYPOINT指定了entrypoint.sh的脚本,该脚本的内容就是根据CMD的内容\n&#x2F;&#x2F;来判断，如果是redis-server的话，则切换到redis用户身份启动服务器，否则依旧使用root身份执行。比如：</code></pre>\n\n<h3 id=\"2-3-5-ENV-设置环境变量\"><a href=\"#2-3-5-ENV-设置环境变量\" class=\"headerlink\" title=\"2.3.5 ENV 设置环境变量\"></a>2.3.5 ENV 设置环境变量</h3><p>可以为后面的RUN命令提供环境变量，是以键值对的形式存在，如果value部分有空格，需要使用双引号括起来</p>\n<h3 id=\"2-3-6-ARG-构建指令\"><a href=\"#2-3-6-ARG-构建指令\" class=\"headerlink\" title=\"2.3.6 ARG 构建指令\"></a>2.3.6 ARG 构建指令</h3><p>ARG指令有生效范围，如果在FROM之前指定的，那么只能用于<code>FROM</code>指令中</p>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">ARG DOCKER_USERNAME&#x3D;library\nFROM $&#123;DOCKER_USERNAME&#125;&#x2F;alpine\nRUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</code></pre>\n\n<p><code>RUN</code>拿不到变量值，要想使用只能是在<code>FROM</code>命令后面重新指定<code>ARG</code>,多阶段构建需要指定各个阶段的<code>ARG</code></p>\n<h3 id=\"2-3-7-VOLUME-定义匿名卷\"><a href=\"#2-3-7-VOLUME-定义匿名卷\" class=\"headerlink\" title=\"2.3.7 VOLUME 定义匿名卷\"></a>2.3.7 VOLUME 定义匿名卷</h3><p><code>VOLUME /data</code> 挂在匿名卷,向容器&#x2F;data写入的数据最终会落入host磁盘<br><code>$ docker run -d -v mydata:/data xxxx</code><br>就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置</p>\n<h3 id=\"2-3-8-EXPOSE-暴露端口\"><a href=\"#2-3-8-EXPOSE-暴露端口\" class=\"headerlink\" title=\"2.3.8 EXPOSE 暴露端口\"></a>2.3.8 EXPOSE 暴露端口</h3><p>与-p &lt;宿主端口&gt;:&lt;容器端口&gt;, 映射端口不通，EXPOSE是暴漏容器端口给其他容器</p>\n<h3 id=\"2-3-9-WORKDIR-指定工作目录\"><a href=\"#2-3-9-WORKDIR-指定工作目录\" class=\"headerlink\" title=\"2.3.9 WORKDIR 指定工作目录\"></a>2.3.9 WORKDIR 指定工作目录</h3><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录</p>\n<h3 id=\"2-3-10-USER指定当前用户\"><a href=\"#2-3-10-USER指定当前用户\" class=\"headerlink\" title=\"2.3.10 USER指定当前用户\"></a>2.3.10 USER指定当前用户</h3><p><code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>\n<h3 id=\"2-3-11-HEALTHCHECK-健康检查HEALTHCHECK-支持下列选项\"><a href=\"#2-3-11-HEALTHCHECK-健康检查HEALTHCHECK-支持下列选项\" class=\"headerlink\" title=\"2.3.11 HEALTHCHECK 健康检查HEALTHCHECK 支持下列选项\"></a>2.3.11 HEALTHCHECK 健康检查<code>HEALTHCHECK</code> 支持下列选项</h3><ul>\n<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>\n<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>\n<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM nginx\nRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*\nHEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \\\nCMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1\n\n&#x2F;&#x2F;这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），\n&#x2F;&#x2F;如果健康检查命令超过 3 &#x2F;&#x2F;秒没响应就视为失败，并且使用 &#96;curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1&#96;\n&#x2F;&#x2F;作为健康检查命令。</code></pre>\n\n<h3 id=\"2-3-12-ONBUILD-为他人作嫁衣裳\"><a href=\"#2-3-12-ONBUILD-为他人作嫁衣裳\" class=\"headerlink\" title=\"2.3.12 ONBUILD 为他人作嫁衣裳\"></a>2.3.12 ONBUILD 为他人作嫁衣裳</h3><h3 id=\"2-3-13-LABEL-为镜像添加元数据\"><a href=\"#2-3-13-LABEL-为镜像添加元数据\" class=\"headerlink\" title=\"2.3.13 LABEL 为镜像添加元数据\"></a>2.3.13 LABEL 为镜像添加元数据</h3><p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">LABEL org.opencontainers.image.authors<span class=\"token operator\">=</span><span class=\"token string\">\"yeasy\"</span>\nLABEL org.opencontainers.image.documentation<span class=\"token operator\">=</span><span class=\"token string\">\"https://yeasy.gitbooks.io\"</span></code></pre>\n\n<h3 id=\"2-3-14-shell指令\"><a href=\"#2-3-14-shell指令\" class=\"headerlink\" title=\"2.3.14 shell指令\"></a>2.3.14 shell指令</h3><p><code>SHELL</code> 指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell程序，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code></p>\n<h3 id=\"2-3-15-参考文档\"><a href=\"#2-3-15-参考文档\" class=\"headerlink\" title=\"2.3.15 参考文档\"></a>2.3.15 参考文档</h3><ul>\n<li><p><code>Dockerfie</code> 官方文档：<a href=\"https://docs.docker.com/engine/reference/builder/\">https://docs.docker.com/engine/reference/builder/</a></p>\n</li>\n<li><p><code>Dockerfile</code> 最佳实践文档：<a href=\"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/\">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p>\n</li>\n<li><p><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a href=\"https://github.com/docker-library/docs\">https://github.com/docker-library/docs</a></p>\n</li>\n</ul>\n<h2 id=\"2-4-Dockerfile-多阶段构建\"><a href=\"#2-4-Dockerfile-多阶段构建\" class=\"headerlink\" title=\"2.4 Dockerfile 多阶段构建\"></a>2.4 Dockerfile 多阶段构建</h2><ul>\n<li>以前是全部放到一个Dockerfile里面，将编译，测试，打包放在一起，可能导致镜像层次过多，源代码泄露风险</li>\n<li>分多个Dockerfile编写，然后指定文件逐个构建</li>\n<li>使用多阶段构建</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM golang:alpine as builder\nRUN apk --no-cache add git\nWORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;\nRUN go get -d -v github.com&#x2F;go-sql-driver&#x2F;mysql\nCOPY app.go .\nRUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .\nFROM alpine:latest as prod\nRUN apk --no-cache add ca-certificates\nWORKDIR &#x2F;root&#x2F;\nCOPY --from&#x3D;0 &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;app .\nCMD [&quot;.&#x2F;app&quot;]\n&#x2F;&#x2F; 构建镜像  docker build -t go&#x2F;helloworld:3 .</code></pre>\n\n<pre><code>- 我们可以使用 `as` 来为某一阶段命名，例如`FROM golang:alpine as builder`\n- 例如当我们只想构建 `builder` 阶段的镜像时，增加 `--target=builder` 参数即可 `$ docker build --target builder -t username/imagename:tag .`\n</code></pre>\n<ul>\n<li>构建时从其他镜像复制文件<br>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件<br><code>$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code></li>\n</ul>\n<h2 id=\"实战多阶段构建镜像\"><a href=\"#实战多阶段构建镜像\" class=\"headerlink\" title=\"实战多阶段构建镜像\"></a>实战多阶段构建镜像</h2><p><a href=\"https://github.com/nigelpoulton/dotnet-docker-samples.git\">实战地址</a>  </p>\n<ul>\n<li><p>生产环境多阶段构建需要保持镜像精简，可以通过&amp;&amp;精简镜像层</p>\n</li>\n<li><p>run指令执行完会残留构建镜像完后的文件，直接上生产及其不妥，docker提供了多种方式解决这个问题，重瞳方式叫<code>建造者模式</code></p>\n<ol>\n<li>构建<code>Dockerfile.dev</code>文件</li>\n<li>在此基础之上构建新一层镜像</li>\n<li>编写Dockerfile.prod，把上一步容器的相关代码和文件复制过来</li>\n</ol>\n</li>\n<li><p>多阶段构建方式<br>分析Dockerfile文件</p>\n</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM mcr.microsoft.com&#x2F;dotnet&#x2F;sdk:6.0 AS build\nWORKDIR &#x2F;source\n\n# copy csproj and restore as distinct layers\nCOPY *.sln .\nCOPY aspnetapp&#x2F;*.csproj .&#x2F;aspnetapp&#x2F;\nRUN dotnet restore\n\n# copy everything else and build app\nCOPY aspnetapp&#x2F;. .&#x2F;aspnetapp&#x2F;\nWORKDIR &#x2F;source&#x2F;aspnetapp\nRUN dotnet publish -c release -o &#x2F;app --no-restore\n\n# final stage&#x2F;image\nFROM mcr.microsoft.com&#x2F;dotnet&#x2F;aspnet:6.0\nWORKDIR &#x2F;app\nCOPY --from&#x3D;build &#x2F;app .&#x2F;\nENTRYPOINT [&quot;dotnet&quot;, &quot;aspnetapp.dll&quot;]</code></pre>\n\n<p>首先注意到，<code>Dockerfile</code>有三个<code>FROM</code>指令。每一个<code>FROM</code>指令构成一个单独的<strong>构建阶段</strong>  </p>\n<ol>\n<li><p>阶段<code>0</code>：<code>build-env</code><br> <code>build-env</code>阶段拉取了<code>aspnetcore-build:2.0</code>作为基础镜像，然后设置了工作目录，复制一些应用代码，接着执行两个<code>RUN</code>指令，生成<code>1</code>个镜像层并显著得到一个比原镜像大得多的镜像，包含许多构建工具和应用代码</p>\n</li>\n<li><p>阶段<code>1</code>：<code>microsoft/aspnetcore:2.0</code><br> <code>aspnetcore:2.0</code>阶段拉取了<code>aspnetcore:2.0</code>作为基础镜像，设置工作目录，然后执行<code>COPY --from</code>指令从<code>build-env</code>阶段生成的镜像中复制一些应用代码过来，最后执行<code>ENTRYPOINT</code>指令指定容器的默认应用程序</p>\n</li>\n</ol>\n<p>上述构建过程的重点在于<code>COPY --from</code>指令<strong>表示从之前的构建阶段复制生产环境相关的应用代码，而不会复制生产环境不需要的构件</strong></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7053651f6091402c9c8ff10c99d1ae34~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2 id=\"2-5-构建多种系统架构支持的docker镜像\"><a href=\"#2-5-构建多种系统架构支持的docker镜像\" class=\"headerlink\" title=\"2.5 构建多种系统架构支持的docker镜像\"></a>2.5 构建多种系统架构支持的docker镜像</h2><p><code>$ docker manifest inspect golang:alpine</code><br>查看manifest列表</p>\n<ul>\n<li>创建manifest 列表</li>\n<li>设置manifest列表</li>\n<li>查看manifest列表</li>\n<li>推送manifest列表</li>\n<li>测试</li>\n<li><a href=\"https://www.docker.com/blog/multi-arch-all-the-things/\">官方博客</a></li>\n</ul>\n<h2 id=\"2-6-其它制作镜像的方式\"><a href=\"#2-6-其它制作镜像的方式\" class=\"headerlink\" title=\"2.6 其它制作镜像的方式\"></a>2.6 其它制作镜像的方式</h2><ul>\n<li>从 rootfs 压缩包导入</li>\n</ul>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">$ docker import \\\n    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \\\n    openvz/ubuntu:16.04\n\nDownloading from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz\nsha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213\n// 从web远程下载ubuntu然后制作镜像</code></pre>\n\n<ul>\n<li>Docker 镜像的导入和导出 <code>docker save</code> 和 <code>docker load</code> ，目前已经不推荐</li>\n</ul>\n<h1 id=\"3-操作容器\"><a href=\"#3-操作容器\" class=\"headerlink\" title=\"3. 操作容器\"></a>3. 操作容器</h1><h2 id=\"3-1-容器基本操作\"><a href=\"#3-1-容器基本操作\" class=\"headerlink\" title=\"3.1 容器基本操作\"></a>3.1 容器基本操作</h2><p>两种启动容器方式，从镜像到容器，启动停止的容器</p>\n<ul>\n<li>新建容器</li>\n</ul>\n<pre class=\"language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">$ docker run -dit --name new_name ubuntu:18.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;\nHello world</code></pre>\n\n<p>-itd 意思是指容器绑定标准输入输出，然后绑定个伪终端，然后以守护态运行<br>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令</p>\n<ul>\n<li>stop&#x2F;restart 容器<br>docker container ls &#x2F;&#x2F;查看容器<br>docker container restart<br>docker container stop&#x2F;start</li>\n<li>进入容器<br><code>docker attach</code> 进入容器<br><code>docker exec -it</code> 进入容器</li>\n<li>导出&#x2F;导入容器<br><code>docker export 7691a814370e &gt; ubuntu.tar</code><br><code>docker import - test/ubuntu:v1.0</code><br><code>docker import url</code></li>\n<li>删除容器<br><code>docker container rm trusting_newton</code><br><code>docker container prune</code> 清理所有种植状态的容器</li>\n</ul>\n<h1 id=\"4-访问仓库\"><a href=\"#4-访问仓库\" class=\"headerlink\" title=\"4. 访问仓库\"></a>4. 访问仓库</h1><ol>\n<li>docker hub</li>\n<li>私有仓库</li>\n<li>私有仓库高级配置</li>\n<li>nexus3</li>\n</ol>\n<h1 id=\"5-数据管理\"><a href=\"#5-数据管理\" class=\"headerlink\" title=\"5. 数据管理\"></a>5. 数据管理</h1><h2 id=\"5-1-数据卷\"><a href=\"#5-1-数据卷\" class=\"headerlink\" title=\"5.1 数据卷\"></a>5.1 数据卷</h2><p>对数据卷的使用有点像linux的mount，镜像中被挂载的目录文件会复制到宿主机的目录上，独立于容器</p>\n<ol>\n<li>创建一个数据卷</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker volume create my-vol  创建一个数据卷  \ndocker volume ls  列举数据卷  \ndocker volume inspect my_vol 查看某一个数据卷  </code></pre>\n\n<ol start=\"2\">\n<li>启动一个挂在了数据卷的容器</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker run -d -P \\\n    --name web \\\n    <span class=\"token comment\"># -v my-vol:/usr/share/nginx/html \\</span>\n    --mount source=my-vol,target=/usr/share/nginx/html \\\n    nginx:alpine\n//使用my_vol数据卷，映射到/usr/share/nginx/html</code></pre>\n\n<ol start=\"3\">\n<li>查看数据卷具体信息</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker inspect web //数据卷信息在Mounts key下\n....\n\"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\" //默认位置</code></pre>\n\n<p>4.删除一个数据卷</p>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker volume rm my-vol\ndocker volume prune //删除无主的数据卷</code></pre>\n\n<ul>\n<li>数据卷可以在容器间共用</li>\n<li>对数据卷的修改会立马生效</li>\n<li>对数据卷的更新，不会影响镜像</li>\n<li>数据卷默认会一直存在，即使容器被输出</li>\n</ul>\n<h2 id=\"5-2-挂载主机目录\"><a href=\"#5-2-挂载主机目录\" class=\"headerlink\" title=\"5.2 挂载主机目录\"></a>5.2 挂载主机目录</h2><ol>\n<li>挂载目录到容器目录</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">$ docker run -d -P \\\n    --name web \\\n    <span class=\"token comment\"># -v /src/webapp:/usr/share/nginx/html \\</span>\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html, readonly \\\n    nginx:alpine</code></pre>\n\n<p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p>\n<ul>\n<li>目录与容器目录绑定，容器写进文件，就会落盘到宿主机上  </li>\n<li>目前如果source不存在就会报错  </li>\n<li>宿主机目录也可以指定readonly</li>\n</ul>\n<ol start=\"2\">\n<li>挂载宿主机文件到容器文件中<br>source&#x3D;  ,target&#x3D; 关键字处直接替换成文件</li>\n</ol>\n<h1 id=\"6-网络\"><a href=\"#6-网络\" class=\"headerlink\" title=\"6. 网络\"></a>6. 网络</h1><h2 id=\"6-1-端口映射\"><a href=\"#6-1-端口映射\" class=\"headerlink\" title=\"6.1 端口映射\"></a>6.1 端口映射</h2><p>-P 会随即映射<br>-p 特定端口映,可使用多次指定多个端口</p>\n<ul>\n<li><code>$ docker run -d -p 80:80 nginx:alpine</code> hostport:containerport  </li>\n<li><code>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</code> 指定地址绑定，容器有自己的网络和地址</li>\n<li><code>$ docker run -d -p 127.0.0.1::80/udp nginx:alpine</code> 容器80端口随机映射到主机,并指定传输协议</li>\n</ul>\n<h2 id=\"6-2-容器互联\"><a href=\"#6-2-容器互联\" class=\"headerlink\" title=\"6.2 容器互联\"></a>6.2 容器互联</h2><ol>\n<li>新建网络</li>\n</ol>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker network create -d bridge my-net</code></pre>\n\n<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href=\"/docker_practice/swarm_mode\">Swarm mode</a>，在本小节中你可以忽略它<br>2. 容器互联</p>\n<pre class=\"language-docker\" data-language=\"docker\"><code class=\"language-docker\">docker run -it --rm --name busybox1 --network my-net busybox sh\ndocker run -it --rm --name busybox2 --network my-net busybox sh\n</code></pre>\n\n<p>可以直接ping另外的容器</p>\n<ul>\n<li>Docker Compose 可以考虑使用</li>\n</ul>\n<h2 id=\"6-3-配置DNS\"><a href=\"#6-3-配置DNS\" class=\"headerlink\" title=\"6.3. 配置DNS\"></a>6.3. 配置DNS</h2><p>TBC</p>\n<h1 id=\"7-高级网络配置\"><a href=\"#7-高级网络配置\" class=\"headerlink\" title=\"7. 高级网络配置\"></a>7. 高级网络配置</h1><h1 id=\"8-Docker-Buildx\"><a href=\"#8-Docker-Buildx\" class=\"headerlink\" title=\"8. Docker Buildx\"></a>8. Docker Buildx</h1><h1 id=\"9-Docker-Compose\"><a href=\"#9-Docker-Compose\" class=\"headerlink\" title=\"9. Docker Compose\"></a>9. Docker Compose</h1><p>结合实战操纵理解</p>\n<h2 id=\"9-1-搭建一个web应用\"><a href=\"#9-1-搭建一个web应用\" class=\"headerlink\" title=\"9.1 搭建一个web应用\"></a>9.1 搭建一个web应用</h2><ul>\n<li>服务：运行多个相同镜像的实例</li>\n<li>项目：一组应用容器组成的一个完整单元<br><a href=\"https://docs.docker.com/compose/compose-file/\">docker compose</a></li>\n</ul>\n<h1 id=\"10-安全\"><a href=\"#10-安全\" class=\"headerlink\" title=\"10. 安全\"></a>10. 安全</h1><h1 id=\"11-底层实现\"><a href=\"#11-底层实现\" class=\"headerlink\" title=\"11. 底层实现\"></a>11. 底层实现</h1><h1 id=\"12-Kubernetes\"><a href=\"#12-Kubernetes\" class=\"headerlink\" title=\"12. Kubernetes\"></a>12. Kubernetes</h1><h1 id=\"13-实战案例-CI-x2F-CD\"><a href=\"#13-实战案例-CI-x2F-CD\" class=\"headerlink\" title=\"13. 实战案例 - CI&#x2F;CD\"></a>13. 实战案例 - CI&#x2F;CD</h1>"},{"title":"pro_git","_content":"","source":"_posts/pro_git.md","raw":"---\ntitle: pro_git\n\n---\n","slug":"pro_git","published":1,"date":"2022-09-09T04:21:02.133Z","updated":"2022-09-09T04:41:11.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5g0007l1dbhfslc22j","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"奔跑吧ansible","_content":"\n# 3. 第三章 inventory:描述你的服务器\n\nansible管理的多台主机文件叫inventory\n\n## 3.1 inventory基本参数含义\n\ninventory文件通常是.ini格式的，常用inventory参数如下\n\n```txt\nansible_ssh_host     #用于指定被管理的主机的真实IP和将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\nansible_ssh_port     #用于指定连接到被管理主机的ssh端口号，默认是22，如果不是默认的端口号,通过此变量设置.\nansible_ssh_user     #ssh连接时默认使用的用户名\nansible_ssh_pass     #ssh连接时的密码，(这种方式并不安全,我们强烈建议使用 --ask-pass（交互密码）或 SSH 密钥)\nansible_sudo_pass     #使用sudo连接用户时的密码，(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\nansible_sudo_exec     #如果sudo命令不在默认路径，需要指定sudo命令路径(适用于1.8及以上版本)\nansible_ssh_private_key_file     #秘钥文件路径，秘钥文件如果不想使用ssh-agent管理时可以使用此选项\nansible_shell_type     #目标系统的shell的类型，默认sh，可设置为 'csh' 或 'fish'.\nansible_connection     #SSH 连接的类型： local , ssh , paramiko，在 ansible 1.2 之前默认是 paramiko ，后来智能选择，优先使用基于 ControlPersist 的 ssh （支持的前提）\nansible_python_interpreter     #用来指定python解释器的路径，默认为/usr/bin/python 同样可以指定ruby 、perl 的路径\nansible_*_interpreter     #其他解释器路径，用法与ansible_python_interpreter类似，这里\"*\"可以是ruby或才perl等其他语言\n以上是2.0版本之前的参数，2.0之后有更换，但是向下兼容\n```\n\n### 3.1.1 主机别名和群组\n\ninventory支持群组,类似于下面\n\n```yml\n[webservers]\ntestserver ansible_port=2202\n\n//群组变量\n[webservers:vars] \nansible_user = vagrant\nansible_host = 127.0.0.1\nansible_private_key_file = .vagrant/machines/default/virtualbox/private_key\n\n[web]\nweb[1:20].example.com\n\n```\n\n### 3.1.2 主机和群组变量，在inventory各自文件中\n\n在inventory目录下我们根据环境，将不同阶段的变量放进文件，`group_vars`文件夹下文件名要与`hosts`文件中的群组保持一致\n\n```text\ngroup_vars\n|----production\n|      |- db_primary_host: rhodeisland.example.com\n|      |- db_replica_host: virginia.example.com\n|      |- db_name: widget_production\n|      |- db_user: widgetuser\n|      |- db_password: pFmMxcyD;Fc6)6\n|      |- rabbitmq_host: pennsylvania.example.com\n|----preprod\n|      |- db_primary_host: chicago.example.com\n|      |- db_replica_host: amsterdam.example.com\n|      |- db_name: widget_staging\n|      |- db_user: widgetuser\n|      |- db_password: L@4Ryz8cRUXedj\n|      |- rabbitmq_host: chicago.example.com\n```\n\n### 3.1.3 动态inventory脚本接口\n\n对于用何种语言实现脚本，没有要求，但必须支持传`--list`和`--host=<hostname>`参数,同时`--list`输出的json字符串也有要求。有群组和主机键值对，`_meta`要保存主机变量\n\n```bash\n./dynamic.py  --list\n```\n\noutput\n\n```json\n\n{\n    \"group1\": {\n        \"hosts\": [\n            \"192.168.28.71\",\n            \"192.168.28.72\"\n        ],\n        \"vars\": {\n            \"ansible_ssh_user\": \"johndoe\",\n            \"ansible_ssh_private_key_file\": \"~/.ssh/mykey\",\n            \"example_variable\": \"value\"\n        },\n        \"children\":['group2']\n    },\n    \"_meta\": {\n        \"hostvars\": {\n            \"192.168.28.71\": {\n                \"host_specific_var\": \"bar\"\n            },\n            \"192.168.28.72\": {\n                \"host_specific_var\": \"foo\"\n            }\n        }\n    }\n}\n```\n\n```bash\n./dynamic.py  --host=192.168.28.71\n```\n\noutput\n\n```json\n{\n    \"host_specific_var\": \"foo\"\n}\n```\n\nansible支持将动态inventory和动态的inventory放在同一文件夹下(名为inventory的文件夹)通过ansible.cfg的hostfile进行控制，也可以使用`-i`参数进行控制\n\n### 3.1.4 add_host模块和group_by模块\n\n`add_host`  \nplaybook运行时，主机被创建是无法追加新主机的。使用`add_host`模块就可以添加新主机并在此次playbook中生效  \n`group_by`\n书上使用group_by 实现了按照OS系统类型进行分组执行(像if语句)，yml中具体参数不知道什么意思.\n","source":"_posts/奔跑吧ansible.md","raw":"---\ntitle: 奔跑吧ansible\ncategories:\n- CICD\ntag: ansible\n---\n\n# 3. 第三章 inventory:描述你的服务器\n\nansible管理的多台主机文件叫inventory\n\n## 3.1 inventory基本参数含义\n\ninventory文件通常是.ini格式的，常用inventory参数如下\n\n```txt\nansible_ssh_host     #用于指定被管理的主机的真实IP和将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\nansible_ssh_port     #用于指定连接到被管理主机的ssh端口号，默认是22，如果不是默认的端口号,通过此变量设置.\nansible_ssh_user     #ssh连接时默认使用的用户名\nansible_ssh_pass     #ssh连接时的密码，(这种方式并不安全,我们强烈建议使用 --ask-pass（交互密码）或 SSH 密钥)\nansible_sudo_pass     #使用sudo连接用户时的密码，(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\nansible_sudo_exec     #如果sudo命令不在默认路径，需要指定sudo命令路径(适用于1.8及以上版本)\nansible_ssh_private_key_file     #秘钥文件路径，秘钥文件如果不想使用ssh-agent管理时可以使用此选项\nansible_shell_type     #目标系统的shell的类型，默认sh，可设置为 'csh' 或 'fish'.\nansible_connection     #SSH 连接的类型： local , ssh , paramiko，在 ansible 1.2 之前默认是 paramiko ，后来智能选择，优先使用基于 ControlPersist 的 ssh （支持的前提）\nansible_python_interpreter     #用来指定python解释器的路径，默认为/usr/bin/python 同样可以指定ruby 、perl 的路径\nansible_*_interpreter     #其他解释器路径，用法与ansible_python_interpreter类似，这里\"*\"可以是ruby或才perl等其他语言\n以上是2.0版本之前的参数，2.0之后有更换，但是向下兼容\n```\n\n### 3.1.1 主机别名和群组\n\ninventory支持群组,类似于下面\n\n```yml\n[webservers]\ntestserver ansible_port=2202\n\n//群组变量\n[webservers:vars] \nansible_user = vagrant\nansible_host = 127.0.0.1\nansible_private_key_file = .vagrant/machines/default/virtualbox/private_key\n\n[web]\nweb[1:20].example.com\n\n```\n\n### 3.1.2 主机和群组变量，在inventory各自文件中\n\n在inventory目录下我们根据环境，将不同阶段的变量放进文件，`group_vars`文件夹下文件名要与`hosts`文件中的群组保持一致\n\n```text\ngroup_vars\n|----production\n|      |- db_primary_host: rhodeisland.example.com\n|      |- db_replica_host: virginia.example.com\n|      |- db_name: widget_production\n|      |- db_user: widgetuser\n|      |- db_password: pFmMxcyD;Fc6)6\n|      |- rabbitmq_host: pennsylvania.example.com\n|----preprod\n|      |- db_primary_host: chicago.example.com\n|      |- db_replica_host: amsterdam.example.com\n|      |- db_name: widget_staging\n|      |- db_user: widgetuser\n|      |- db_password: L@4Ryz8cRUXedj\n|      |- rabbitmq_host: chicago.example.com\n```\n\n### 3.1.3 动态inventory脚本接口\n\n对于用何种语言实现脚本，没有要求，但必须支持传`--list`和`--host=<hostname>`参数,同时`--list`输出的json字符串也有要求。有群组和主机键值对，`_meta`要保存主机变量\n\n```bash\n./dynamic.py  --list\n```\n\noutput\n\n```json\n\n{\n    \"group1\": {\n        \"hosts\": [\n            \"192.168.28.71\",\n            \"192.168.28.72\"\n        ],\n        \"vars\": {\n            \"ansible_ssh_user\": \"johndoe\",\n            \"ansible_ssh_private_key_file\": \"~/.ssh/mykey\",\n            \"example_variable\": \"value\"\n        },\n        \"children\":['group2']\n    },\n    \"_meta\": {\n        \"hostvars\": {\n            \"192.168.28.71\": {\n                \"host_specific_var\": \"bar\"\n            },\n            \"192.168.28.72\": {\n                \"host_specific_var\": \"foo\"\n            }\n        }\n    }\n}\n```\n\n```bash\n./dynamic.py  --host=192.168.28.71\n```\n\noutput\n\n```json\n{\n    \"host_specific_var\": \"foo\"\n}\n```\n\nansible支持将动态inventory和动态的inventory放在同一文件夹下(名为inventory的文件夹)通过ansible.cfg的hostfile进行控制，也可以使用`-i`参数进行控制\n\n### 3.1.4 add_host模块和group_by模块\n\n`add_host`  \nplaybook运行时，主机被创建是无法追加新主机的。使用`add_host`模块就可以添加新主机并在此次playbook中生效  \n`group_by`\n书上使用group_by 实现了按照OS系统类型进行分组执行(像if语句)，yml中具体参数不知道什么意思.\n","slug":"奔跑吧ansible","published":1,"date":"2022-06-22T12:45:28.981Z","updated":"2022-09-19T17:18:08.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5i0009l1dbfmys5w82","content":"<h1 id=\"3-第三章-inventory-描述你的服务器\"><a href=\"#3-第三章-inventory-描述你的服务器\" class=\"headerlink\" title=\"3. 第三章 inventory:描述你的服务器\"></a>3. 第三章 inventory:描述你的服务器</h1><p>ansible管理的多台主机文件叫inventory</p>\n<h2 id=\"3-1-inventory基本参数含义\"><a href=\"#3-1-inventory基本参数含义\" class=\"headerlink\" title=\"3.1 inventory基本参数含义\"></a>3.1 inventory基本参数含义</h2><p>inventory文件通常是.ini格式的，常用inventory参数如下</p>\n<pre class=\"language-txt\" data-language=\"txt\"><code class=\"language-txt\">ansible_ssh_host     #用于指定被管理的主机的真实IP和将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\nansible_ssh_port     #用于指定连接到被管理主机的ssh端口号，默认是22，如果不是默认的端口号,通过此变量设置.\nansible_ssh_user     #ssh连接时默认使用的用户名\nansible_ssh_pass     #ssh连接时的密码，(这种方式并不安全,我们强烈建议使用 --ask-pass（交互密码）或 SSH 密钥)\nansible_sudo_pass     #使用sudo连接用户时的密码，(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\nansible_sudo_exec     #如果sudo命令不在默认路径，需要指定sudo命令路径(适用于1.8及以上版本)\nansible_ssh_private_key_file     #秘钥文件路径，秘钥文件如果不想使用ssh-agent管理时可以使用此选项\nansible_shell_type     #目标系统的shell的类型，默认sh，可设置为 'csh' 或 'fish'.\nansible_connection     #SSH 连接的类型： local , ssh , paramiko，在 ansible 1.2 之前默认是 paramiko ，后来智能选择，优先使用基于 ControlPersist 的 ssh （支持的前提）\nansible_python_interpreter     #用来指定python解释器的路径，默认为/usr/bin/python 同样可以指定ruby 、perl 的路径\nansible_*_interpreter     #其他解释器路径，用法与ansible_python_interpreter类似，这里\"*\"可以是ruby或才perl等其他语言\n以上是2.0版本之前的参数，2.0之后有更换，但是向下兼容</code></pre>\n\n<h3 id=\"3-1-1-主机别名和群组\"><a href=\"#3-1-1-主机别名和群组\" class=\"headerlink\" title=\"3.1.1 主机别名和群组\"></a>3.1.1 主机别名和群组</h3><p>inventory支持群组,类似于下面</p>\n<pre class=\"language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">[</span>webservers<span class=\"token punctuation\">]</span>\ntestserver ansible_port=2202\n\n//群组变量\n<span class=\"token punctuation\">[</span>webservers<span class=\"token punctuation\">:</span>vars<span class=\"token punctuation\">]</span> \nansible_user = vagrant\nansible_host = 127.0.0.1\nansible_private_key_file = .vagrant/machines/default/virtualbox/private_key\n\n<span class=\"token punctuation\">[</span>web<span class=\"token punctuation\">]</span>\nweb<span class=\"token punctuation\">[</span><span class=\"token datetime number\">1:20</span><span class=\"token punctuation\">]</span>.example.com\n</code></pre>\n\n<h3 id=\"3-1-2-主机和群组变量，在inventory各自文件中\"><a href=\"#3-1-2-主机和群组变量，在inventory各自文件中\" class=\"headerlink\" title=\"3.1.2 主机和群组变量，在inventory各自文件中\"></a>3.1.2 主机和群组变量，在inventory各自文件中</h3><p>在inventory目录下我们根据环境，将不同阶段的变量放进文件，<code>group_vars</code>文件夹下文件名要与<code>hosts</code>文件中的群组保持一致</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">group_vars\n|----production\n|      |- db_primary_host: rhodeisland.example.com\n|      |- db_replica_host: virginia.example.com\n|      |- db_name: widget_production\n|      |- db_user: widgetuser\n|      |- db_password: pFmMxcyD;Fc6)6\n|      |- rabbitmq_host: pennsylvania.example.com\n|----preprod\n|      |- db_primary_host: chicago.example.com\n|      |- db_replica_host: amsterdam.example.com\n|      |- db_name: widget_staging\n|      |- db_user: widgetuser\n|      |- db_password: L@4Ryz8cRUXedj\n|      |- rabbitmq_host: chicago.example.com</code></pre>\n\n<h3 id=\"3-1-3-动态inventory脚本接口\"><a href=\"#3-1-3-动态inventory脚本接口\" class=\"headerlink\" title=\"3.1.3 动态inventory脚本接口\"></a>3.1.3 动态inventory脚本接口</h3><p>对于用何种语言实现脚本，没有要求，但必须支持传<code>--list</code>和<code>--host=&lt;hostname&gt;</code>参数,同时<code>--list</code>输出的json字符串也有要求。有群组和主机键值对，<code>_meta</code>要保存主机变量</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">./dynamic.py  --list</code></pre>\n\n<p>output</p>\n<pre class=\"language-json\" data-language=\"json\"><code class=\"language-json\">\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token property\">\"group1\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token property\">\"hosts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n            <span class=\"token string\">\"192.168.28.71\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"192.168.28.72\"</span>\n        <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"vars\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token property\">\"ansible_ssh_user\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"johndoe\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"ansible_ssh_private_key_file\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"~/.ssh/mykey\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"example_variable\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"value\"</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"children\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>'group2'<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"_meta\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token property\">\"hostvars\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token property\">\"192.168.28.71\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token property\">\"host_specific_var\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"192.168.28.72\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token property\">\"host_specific_var\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"foo\"</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">./dynamic.py  --host<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.28.71</code></pre>\n\n<p>output</p>\n<pre class=\"language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token property\">\"host_specific_var\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"foo\"</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>ansible支持将动态inventory和动态的inventory放在同一文件夹下(名为inventory的文件夹)通过ansible.cfg的hostfile进行控制，也可以使用<code>-i</code>参数进行控制</p>\n<h3 id=\"3-1-4-add-host模块和group-by模块\"><a href=\"#3-1-4-add-host模块和group-by模块\" class=\"headerlink\" title=\"3.1.4 add_host模块和group_by模块\"></a>3.1.4 add_host模块和group_by模块</h3><p><code>add_host</code><br>playbook运行时，主机被创建是无法追加新主机的。使用<code>add_host</code>模块就可以添加新主机并在此次playbook中生效<br><code>group_by</code><br>书上使用group_by 实现了按照OS系统类型进行分组执行(像if语句)，yml中具体参数不知道什么意思.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"3-第三章-inventory-描述你的服务器\"><a href=\"#3-第三章-inventory-描述你的服务器\" class=\"headerlink\" title=\"3. 第三章 inventory:描述你的服务器\"></a>3. 第三章 inventory:描述你的服务器</h1><p>ansible管理的多台主机文件叫inventory</p>\n<h2 id=\"3-1-inventory基本参数含义\"><a href=\"#3-1-inventory基本参数含义\" class=\"headerlink\" title=\"3.1 inventory基本参数含义\"></a>3.1 inventory基本参数含义</h2><p>inventory文件通常是.ini格式的，常用inventory参数如下</p>\n<pre class=\"language-txt\" data-language=\"txt\"><code class=\"language-txt\">ansible_ssh_host     #用于指定被管理的主机的真实IP和将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\nansible_ssh_port     #用于指定连接到被管理主机的ssh端口号，默认是22，如果不是默认的端口号,通过此变量设置.\nansible_ssh_user     #ssh连接时默认使用的用户名\nansible_ssh_pass     #ssh连接时的密码，(这种方式并不安全,我们强烈建议使用 --ask-pass（交互密码）或 SSH 密钥)\nansible_sudo_pass     #使用sudo连接用户时的密码，(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\nansible_sudo_exec     #如果sudo命令不在默认路径，需要指定sudo命令路径(适用于1.8及以上版本)\nansible_ssh_private_key_file     #秘钥文件路径，秘钥文件如果不想使用ssh-agent管理时可以使用此选项\nansible_shell_type     #目标系统的shell的类型，默认sh，可设置为 'csh' 或 'fish'.\nansible_connection     #SSH 连接的类型： local , ssh , paramiko，在 ansible 1.2 之前默认是 paramiko ，后来智能选择，优先使用基于 ControlPersist 的 ssh （支持的前提）\nansible_python_interpreter     #用来指定python解释器的路径，默认为/usr/bin/python 同样可以指定ruby 、perl 的路径\nansible_*_interpreter     #其他解释器路径，用法与ansible_python_interpreter类似，这里\"*\"可以是ruby或才perl等其他语言\n以上是2.0版本之前的参数，2.0之后有更换，但是向下兼容</code></pre>\n\n<h3 id=\"3-1-1-主机别名和群组\"><a href=\"#3-1-1-主机别名和群组\" class=\"headerlink\" title=\"3.1.1 主机别名和群组\"></a>3.1.1 主机别名和群组</h3><p>inventory支持群组,类似于下面</p>\n<pre class=\"language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">[</span>webservers<span class=\"token punctuation\">]</span>\ntestserver ansible_port=2202\n\n//群组变量\n<span class=\"token punctuation\">[</span>webservers<span class=\"token punctuation\">:</span>vars<span class=\"token punctuation\">]</span> \nansible_user = vagrant\nansible_host = 127.0.0.1\nansible_private_key_file = .vagrant/machines/default/virtualbox/private_key\n\n<span class=\"token punctuation\">[</span>web<span class=\"token punctuation\">]</span>\nweb<span class=\"token punctuation\">[</span><span class=\"token datetime number\">1:20</span><span class=\"token punctuation\">]</span>.example.com\n</code></pre>\n\n<h3 id=\"3-1-2-主机和群组变量，在inventory各自文件中\"><a href=\"#3-1-2-主机和群组变量，在inventory各自文件中\" class=\"headerlink\" title=\"3.1.2 主机和群组变量，在inventory各自文件中\"></a>3.1.2 主机和群组变量，在inventory各自文件中</h3><p>在inventory目录下我们根据环境，将不同阶段的变量放进文件，<code>group_vars</code>文件夹下文件名要与<code>hosts</code>文件中的群组保持一致</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">group_vars\n|----production\n|      |- db_primary_host: rhodeisland.example.com\n|      |- db_replica_host: virginia.example.com\n|      |- db_name: widget_production\n|      |- db_user: widgetuser\n|      |- db_password: pFmMxcyD;Fc6)6\n|      |- rabbitmq_host: pennsylvania.example.com\n|----preprod\n|      |- db_primary_host: chicago.example.com\n|      |- db_replica_host: amsterdam.example.com\n|      |- db_name: widget_staging\n|      |- db_user: widgetuser\n|      |- db_password: L@4Ryz8cRUXedj\n|      |- rabbitmq_host: chicago.example.com</code></pre>\n\n<h3 id=\"3-1-3-动态inventory脚本接口\"><a href=\"#3-1-3-动态inventory脚本接口\" class=\"headerlink\" title=\"3.1.3 动态inventory脚本接口\"></a>3.1.3 动态inventory脚本接口</h3><p>对于用何种语言实现脚本，没有要求，但必须支持传<code>--list</code>和<code>--host=&lt;hostname&gt;</code>参数,同时<code>--list</code>输出的json字符串也有要求。有群组和主机键值对，<code>_meta</code>要保存主机变量</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">./dynamic.py  --list</code></pre>\n\n<p>output</p>\n<pre class=\"language-json\" data-language=\"json\"><code class=\"language-json\">\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token property\">\"group1\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token property\">\"hosts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n            <span class=\"token string\">\"192.168.28.71\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"192.168.28.72\"</span>\n        <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"vars\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token property\">\"ansible_ssh_user\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"johndoe\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"ansible_ssh_private_key_file\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"~/.ssh/mykey\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"example_variable\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"value\"</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"children\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>'group2'<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"_meta\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token property\">\"hostvars\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token property\">\"192.168.28.71\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token property\">\"host_specific_var\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"192.168.28.72\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token property\">\"host_specific_var\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"foo\"</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">./dynamic.py  --host<span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.28.71</code></pre>\n\n<p>output</p>\n<pre class=\"language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token property\">\"host_specific_var\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"foo\"</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>ansible支持将动态inventory和动态的inventory放在同一文件夹下(名为inventory的文件夹)通过ansible.cfg的hostfile进行控制，也可以使用<code>-i</code>参数进行控制</p>\n<h3 id=\"3-1-4-add-host模块和group-by模块\"><a href=\"#3-1-4-add-host模块和group-by模块\" class=\"headerlink\" title=\"3.1.4 add_host模块和group_by模块\"></a>3.1.4 add_host模块和group_by模块</h3><p><code>add_host</code><br>playbook运行时，主机被创建是无法追加新主机的。使用<code>add_host</code>模块就可以添加新主机并在此次playbook中生效<br><code>group_by</code><br>书上使用group_by 实现了按照OS系统类型进行分组执行(像if语句)，yml中具体参数不知道什么意思.</p>\n"},{"title":"数据结构讲义","_content":"\n\n","source":"_posts/数据结构讲义.md","raw":"---\ntitle: 数据结构讲义\ncategories:\n- 数据结构\n---\n\n\n","slug":"数据结构讲义","published":1,"date":"2022-07-12T15:27:09.787Z","updated":"2022-07-12T15:28:57.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5j000cl1db3qo638l6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"算法导论","_content":"## 15.动态规划\n\n简单讲跟分治方法很像，但是分治是将将问题分解然后一个一个解决，但是动态规划是找子问题重叠的情况，既不同的子问题有公共的子问题，及将子问题求解一遍再将其保存到表格中。传统的递归时间复杂度会有2的N次幂，而用DP改写就会有N的2次幂\n\n### 15.1 钢条切割\n\n一个钢条，按照不同长度切割可以卖出不同价格\n| length | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |\n| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| price  | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 30   |\n\n1. 传统递归\n其实是尝试遍了所有的可能性。所以开销很大\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b543d0ff04056b6813faff9f3c32e~tplv-k3u1fbpfcp-watermark.image?)\n就如上图，每一个分治就是一种可能\n\n2. 自底向上的动态规划\n\n```cpp\n// Cut-Rod with bottom-up method\nint BottomUpCutRod(const std::vector<int> &p, const int &n)\n{\n    std::vector<int> r{0};\n    for (auto j = 1; j <= n; ++j)\n    {\n        int q = INT8_MIN;\n        for (auto i = 1; i <= j; ++i)\n        {\n            q = std::max(q, p.at(i) + r.at(j - i));\n        }\n        r.push_back(q);\n    }\n    return r.at(n);\n}\n```\n\n### 15.2 最大子序和\n\n这道题是来自leetcode.给你一个整数数组 nums,请你找出一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和。子数组 是数组中的一个连续部分。\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb52e9f8c446efbe01435060ce41c4~tplv-k3u1fbpfcp-watermark.image?)\n\n```golang\n // {-2, 1, -3, 4, -1, 2, 1, -5, 4}\nfunc maxSubArray(nums []int) int {\n\n\n if len(nums) == 0 {\n  return 0\n }\n res := -32768\n f_n := -1\n\n for i := 0; i < len(nums); i++ {\n  f_n = Max(nums[i], f_n+nums[i])\n  res = Max(f_n, res)\n }\n return res\n}\n\nfunc Max(a int, b int) int {\n\n if a >= b {\n  return a\n }\n return b\n}\n```\n\n这里主要是使用了**kadane**算法,使用一个变量跟踪最大值，f_n = Max(nums[i], f_n+nums[i])是kadane的核心思想，如果我下个位置的数字大于你们前面的和，说明前面的结果就不是最大整数和\n","source":"_posts/算法导论.md","raw":"---\ntitle: 算法导论\ncategories:\n- 算法\n---\n## 15.动态规划\n\n简单讲跟分治方法很像，但是分治是将将问题分解然后一个一个解决，但是动态规划是找子问题重叠的情况，既不同的子问题有公共的子问题，及将子问题求解一遍再将其保存到表格中。传统的递归时间复杂度会有2的N次幂，而用DP改写就会有N的2次幂\n\n### 15.1 钢条切割\n\n一个钢条，按照不同长度切割可以卖出不同价格\n| length | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |\n| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| price  | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 30   |\n\n1. 传统递归\n其实是尝试遍了所有的可能性。所以开销很大\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b543d0ff04056b6813faff9f3c32e~tplv-k3u1fbpfcp-watermark.image?)\n就如上图，每一个分治就是一种可能\n\n2. 自底向上的动态规划\n\n```cpp\n// Cut-Rod with bottom-up method\nint BottomUpCutRod(const std::vector<int> &p, const int &n)\n{\n    std::vector<int> r{0};\n    for (auto j = 1; j <= n; ++j)\n    {\n        int q = INT8_MIN;\n        for (auto i = 1; i <= j; ++i)\n        {\n            q = std::max(q, p.at(i) + r.at(j - i));\n        }\n        r.push_back(q);\n    }\n    return r.at(n);\n}\n```\n\n### 15.2 最大子序和\n\n这道题是来自leetcode.给你一个整数数组 nums,请你找出一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和。子数组 是数组中的一个连续部分。\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb52e9f8c446efbe01435060ce41c4~tplv-k3u1fbpfcp-watermark.image?)\n\n```golang\n // {-2, 1, -3, 4, -1, 2, 1, -5, 4}\nfunc maxSubArray(nums []int) int {\n\n\n if len(nums) == 0 {\n  return 0\n }\n res := -32768\n f_n := -1\n\n for i := 0; i < len(nums); i++ {\n  f_n = Max(nums[i], f_n+nums[i])\n  res = Max(f_n, res)\n }\n return res\n}\n\nfunc Max(a int, b int) int {\n\n if a >= b {\n  return a\n }\n return b\n}\n```\n\n这里主要是使用了**kadane**算法,使用一个变量跟踪最大值，f_n = Max(nums[i], f_n+nums[i])是kadane的核心思想，如果我下个位置的数字大于你们前面的和，说明前面的结果就不是最大整数和\n","slug":"算法导论","published":1,"date":"2022-06-22T14:07:23.481Z","updated":"2022-06-22T14:17:54.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5j000dl1db5nty72rq","content":"<h2 id=\"15-动态规划\"><a href=\"#15-动态规划\" class=\"headerlink\" title=\"15.动态规划\"></a>15.动态规划</h2><p>简单讲跟分治方法很像，但是分治是将将问题分解然后一个一个解决，但是动态规划是找子问题重叠的情况，既不同的子问题有公共的子问题，及将子问题求解一遍再将其保存到表格中。传统的递归时间复杂度会有2的N次幂，而用DP改写就会有N的2次幂</p>\n<h3 id=\"15-1-钢条切割\"><a href=\"#15-1-钢条切割\" class=\"headerlink\" title=\"15.1 钢条切割\"></a>15.1 钢条切割</h3><p>一个钢条，按照不同长度切割可以卖出不同价格</p>\n<table>\n<thead>\n<tr>\n<th>length</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>price</td>\n<td>1</td>\n<td>5</td>\n<td>8</td>\n<td>9</td>\n<td>10</td>\n<td>17</td>\n<td>17</td>\n<td>20</td>\n<td>30</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>传统递归<br>其实是尝试遍了所有的可能性。所以开销很大<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b543d0ff04056b6813faff9f3c32e~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"><br>就如上图，每一个分治就是一种可能</p>\n</li>\n<li><p>自底向上的动态规划</p>\n</li>\n</ol>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// Cut-Rod with bottom-up method</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">BottomUpCutRod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> r<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> q <span class=\"token operator\">=</span> INT8_MIN<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> j<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            q <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        r<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h3 id=\"15-2-最大子序和\"><a href=\"#15-2-最大子序和\" class=\"headerlink\" title=\"15.2 最大子序和\"></a>15.2 最大子序和</h3><p>这道题是来自leetcode.给你一个整数数组 nums,请你找出一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和。子数组 是数组中的一个连续部分。<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb52e9f8c446efbe01435060ce41c4~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\"> &#x2F;&#x2F; &#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;\nfunc maxSubArray(nums []int) int &#123;\n\n\n if len(nums) &#x3D;&#x3D; 0 &#123;\n  return 0\n &#125;\n res :&#x3D; -32768\n f_n :&#x3D; -1\n\n for i :&#x3D; 0; i &lt; len(nums); i++ &#123;\n  f_n &#x3D; Max(nums[i], f_n+nums[i])\n  res &#x3D; Max(f_n, res)\n &#125;\n return res\n&#125;\n\nfunc Max(a int, b int) int &#123;\n\n if a &gt;&#x3D; b &#123;\n  return a\n &#125;\n return b\n&#125;</code></pre>\n\n<p>这里主要是使用了<strong>kadane</strong>算法,使用一个变量跟踪最大值，f_n &#x3D; Max(nums[i], f_n+nums[i])是kadane的核心思想，如果我下个位置的数字大于你们前面的和，说明前面的结果就不是最大整数和</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"15-动态规划\"><a href=\"#15-动态规划\" class=\"headerlink\" title=\"15.动态规划\"></a>15.动态规划</h2><p>简单讲跟分治方法很像，但是分治是将将问题分解然后一个一个解决，但是动态规划是找子问题重叠的情况，既不同的子问题有公共的子问题，及将子问题求解一遍再将其保存到表格中。传统的递归时间复杂度会有2的N次幂，而用DP改写就会有N的2次幂</p>\n<h3 id=\"15-1-钢条切割\"><a href=\"#15-1-钢条切割\" class=\"headerlink\" title=\"15.1 钢条切割\"></a>15.1 钢条切割</h3><p>一个钢条，按照不同长度切割可以卖出不同价格</p>\n<table>\n<thead>\n<tr>\n<th>length</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>price</td>\n<td>1</td>\n<td>5</td>\n<td>8</td>\n<td>9</td>\n<td>10</td>\n<td>17</td>\n<td>17</td>\n<td>20</td>\n<td>30</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>传统递归<br>其实是尝试遍了所有的可能性。所以开销很大<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b543d0ff04056b6813faff9f3c32e~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"><br>就如上图，每一个分治就是一种可能</p>\n</li>\n<li><p>自底向上的动态规划</p>\n</li>\n</ol>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// Cut-Rod with bottom-up method</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">BottomUpCutRod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> r<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> q <span class=\"token operator\">=</span> INT8_MIN<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> j<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            q <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        r<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<h3 id=\"15-2-最大子序和\"><a href=\"#15-2-最大子序和\" class=\"headerlink\" title=\"15.2 最大子序和\"></a>15.2 最大子序和</h3><p>这道题是来自leetcode.给你一个整数数组 nums,请你找出一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和。子数组 是数组中的一个连续部分。<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb52e9f8c446efbe01435060ce41c4~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\"> &#x2F;&#x2F; &#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;\nfunc maxSubArray(nums []int) int &#123;\n\n\n if len(nums) &#x3D;&#x3D; 0 &#123;\n  return 0\n &#125;\n res :&#x3D; -32768\n f_n :&#x3D; -1\n\n for i :&#x3D; 0; i &lt; len(nums); i++ &#123;\n  f_n &#x3D; Max(nums[i], f_n+nums[i])\n  res &#x3D; Max(f_n, res)\n &#125;\n return res\n&#125;\n\nfunc Max(a int, b int) int &#123;\n\n if a &gt;&#x3D; b &#123;\n  return a\n &#125;\n return b\n&#125;</code></pre>\n\n<p>这里主要是使用了<strong>kadane</strong>算法,使用一个变量跟踪最大值，f_n &#x3D; Max(nums[i], f_n+nums[i])是kadane的核心思想，如果我下个位置的数字大于你们前面的和，说明前面的结果就不是最大整数和</p>\n"},{"title":"MIT6.824之lab2_raft_lock_advice","_content":"\n# rule 1\n\nwhenever you have one more goroutine gonna modify data , you should use lock to prevent data and\navoid multip-goroutine change data ,go race is a good tool , that is enable to detect data race ,\nbut without any helpful on below rules\n\n# rule 2\n\nwhenever your code make a sequence of modification on shared code.if they looked at the\ndata midway through the sequence,other goroutines might malfunction, you should use lock\nto pretect code block which gonna be change and other routine read data midway, for example\n\n```golang\n  rf.mu.Lock()\n  rf.currentTerm += 1\n  rf.state = Candidate\n  rf.mu.Unlock()\n```\n\n\none more goroutine could not read any of above temp updates, so A goroutine should hold locking over the critical section.\non the other hand , if B goroutine using r.currenTerm or r.state, ,who must hold locking when access r.currenTerm at somewhere\n\n# rule 3\n\nWhenever code does a sequence of reads of shared data (or\nreads and writes), and would malfunction if another goroutine modified\nthe data midway through the sequence, you should use a lock around the\nwhole sequence.\n\nplease must take care and review the multi-goroutine change data at the same time.and must aware if another goroutine modified\nthe data midway through the sequence, you should use a lock around the whole sequence.\n\n```golang\n\nrf.mu.Lock()\n  if args.Term > rf.currentTerm {\n   rf.currentTerm = args.Term\n  }\n  rf.mu.Unlock()\n\n```\n\n# rule 4\n\nthis rule just only apply to lab2, it announces that It's usually a bad idea to hold a lock while doing anything that might wait: reading a Go channel, sending on a channel, waiting for a timer, calling time.Sleep(), or sending an RPC (and waiting for the\nreply).\n\n# rule 5\n\nthis rule is also apply for lab2 specifical case.\nBe careful about assumptions across a drop and re-acquire of a\nlock. One place this can arise is when avoiding waiting with locks\nheld.\n\nBe careful about assumptions across a drop and re-acquire of a\nlock. One place this can arise is when avoiding waiting with locks\nheld. For example, this code to send vote RPCs is incorrect:\n\n```golang\n  rf.mu.Lock()\n  rf.currentTerm += 1\n  rf.state = Candidate\n  for <each peer> {\n    go func() {\n      rf.mu.Lock()\n      args.Term = rf.currentTerm\n      rf.mu.Unlock()\n      Call(\"Raft.RequestVote\", &args, ...)\n      // handle the reply...\n    } ()\n  }\n  rf.mu.Unlock()\n```\n\nThe code sends each RPC in a separate goroutine. It's incorrect\nbecause args.Term may not be the same as the rf.currentTerm at which\nthe surrounding code decided to become a Candidate. Lots of time may\npass between when the surrounding code creates the goroutine and when\nthe goroutine reads rf.currentTerm; for example, multiple terms may\ncome and go, and the peer may no longer be a candidate. One way to fix\nthis is for the created goroutine to use a copy of rf.currentTerm made\nwhile the outer code holds the lock. Similarly, reply-handling code\nafter the Call() must re-check all relevant assumptions after\nre-acquiring the lock; for example, it should check that\nrf.currentTerm hasn't changed since the decision to become a\ncandidate.\n\nIt can be difficult to interpret and apply these rules. Perhaps most\npuzzling is the notion in Rules 2 and 3 of code sequences that\nshouldn't be interleaved with other goroutines' reads or writes. How\ncan one recognize such sequences? How should one decide where a\nsequence ought to start and end?\n\nOne approach is to start with code that has no locks, and think\ncarefully about where one needs to add locks to attain correctness.\nThis approach can be difficult since it requires reasoning about the\ncorrectness of concurrent code.\n\n一个更务实的方法是从观察开始的，如果没有\n没有并发性（没有同时执行的goroutine），你就根本不需要锁。\n就根本不需要锁了。但是，当RPC系统创建goroutines来执行RPC时，你的并发性被强加于你\n当RPC系统创建goroutines来执行RPC处理程序时，你的并发性是被迫的，并且\n因为你需要在不同的goroutine中发送RPC以避免等待。\n你可以有效地消除这种并发，方法是确定所有\n的地方（RPC处理程序、你在Make()中创建的后台goroutine\n中创建的后台goroutines，等等），在每个goroutine的开始时获取锁，并且只释放锁。\n锁，并且只有在该程序完全结束并返回时才释放锁。\n完全结束并返回时才释放锁。这个锁协议确保\n没有任何重要的东西是并行执行的；锁保证了\n每个goroutine在任何其他goroutine被允许启动之前执行完毕。\n允许启动。由于没有并行执行，所以很难违反\n规则1、2、3或5。如果每个goroutine的代码在孤立情况下是正确的\n(当单独执行时，没有并发的goroutine)，那么当你使用锁时，它很可能\n当你使用锁来抑制并发性时，它仍然是正确的。所以你\n可以避免对正确性进行明确的推理，或者明确的\n识别关键部分。\n> 通过www.DeepL.com/Translator（免费版）翻译\n\nHowever, Rule 4 is likely to be a problem. So the next step is to find\nplaces where the code waits, and to add lock releases and re-acquires\n(and/or goroutine creation) as needed, being careful to re-establish\nassumptions after each re-acquire. You may find this process easier to\nget right than directly identifying sequences that must be locked for\ncorrectness.\n\n(As an aside, what this approach sacrifices is any opportunity for\nbetter performance via parallel execution on multiple cores: your code\nis likely to hold locks when it doesn't need to, and may thus\nunnecessarily prohibit parallel execution of goroutines. On the other\nhand, there is not much opportunity for CPU parallelism within a\nsingle Raft peer.)\n\n# 原文\n\n<details>\n<summary>原文</summary>\n<pre>\nRaft Locking Advice\n\nIf you are wondering how to use locks in the 6.824 Raft labs, here are\nsome rules and ways of thinking that might be helpful.\n\nRule 1: Whenever you have data that more than one goroutine uses, and\nat least one goroutine might modify the data, the goroutines should\nuse locks to prevent simultaneous use of the data. The Go race\ndetector is pretty good at detecting violations of this rule (though\nit won't help with any of the rules below).\n\nRule 2: Whenever code makes a sequence of modifications to shared\ndata, and other goroutines might malfunction if they looked at the\ndata midway through the sequence, you should use a lock around the\nwhole sequence.\n\nAn example:\n\n  rf.mu.Lock()\n  rf.currentTerm += 1\n  rf.state = Candidate\n  rf.mu.Unlock()\n\nIt would be a mistake for another goroutine to see either of these\nupdates alone (i.e. the old state with the new term, or the new term\nwith the old state). So we need to hold the lock continuously over the\nwhole sequence of updates. All other code that uses rf.currentTerm or\nrf.state must also hold the lock, in order to ensure exclusive access\nfor all uses.\n\nThe code between Lock() and Unlock() is often called a \"critical\nsection.\" The locking rules a programmer chooses (e.g. \"a goroutine\nmust hold rf.mu when using rf.currentTerm or rf.state\") are often\ncalled a \"locking protocol\".\n\nRule 3: Whenever code does a sequence of reads of shared data (or\nreads and writes), and would malfunction if another goroutine modified\nthe data midway through the sequence, you should use a lock around the\nwhole sequence.\n\nAn example that could occur in a Raft RPC handler:\n\n  rf.mu.Lock()\n  if args.Term > rf.currentTerm {\n   rf.currentTerm = args.Term\n  }\n  rf.mu.Unlock()\n\nThis code needs to hold the lock continuously for the whole sequence.\nRaft requires that currentTerm only increases, and never decreases.\nAnother RPC handler could be executing in a separate goroutine; if it\nwere allowed to modify rf.currentTerm between the if statement and the\nupdate to rf.currentTerm, this code might end up decreasing\nrf.currentTerm. Hence the lock must be held continuously over the\nwhole sequence. In addition, every other use of currentTerm must hold\nthe lock, to ensure that no other goroutine modifies currentTerm\nduring our critical section.\n\nReal Raft code would need to use longer critical sections than these\nexamples; for example, a Raft RPC handler should probably hold the\nlock for the entire handler.\n\nRule 4: It's usually a bad idea to hold a lock while doing anything\nthat might wait: reading a Go channel, sending on a channel, waiting\nfor a timer, calling time.Sleep(), or sending an RPC (and waiting for the\nreply). One reason is that you probably want other goroutines to make\nprogress during the wait. Another reason is deadlock avoidance. Imagine\ntwo peers sending each other RPCs while holding locks; both RPC\nhandlers need the receiving peer's lock; neither RPC handler can ever\ncomplete because it needs the lock held by the waiting RPC call.\n\nCode that waits should first release locks. If that's not convenient,\nsometimes it's useful to create a separate goroutine to do the wait.\n\nRule 5: Be careful about assumptions across a drop and re-acquire of a\nlock. One place this can arise is when avoiding waiting with locks\nheld. For example, this code to send vote RPCs is incorrect:\n\n  rf.mu.Lock()\n  rf.currentTerm += 1\n  rf.state = Candidate\n  for <each peer> {\n    go func() {\n      rf.mu.Lock()\n      args.Term = rf.currentTerm\n      rf.mu.Unlock()\n      Call(\"Raft.RequestVote\", &args, ...)\n      // handle the reply...\n    } ()\n  }\n  rf.mu.Unlock()\n\nThe code sends each RPC in a separate goroutine. It's incorrect\nbecause args.Term may not be the same as the rf.currentTerm at which\nthe surrounding code decided to become a Candidate. Lots of time may\npass between when the surrounding code creates the goroutine and when\nthe goroutine reads rf.currentTerm; for example, multiple terms may\ncome and go, and the peer may no longer be a candidate. One way to fix\nthis is for the created goroutine to use a copy of rf.currentTerm made\nwhile the outer code holds the lock. Similarly, reply-handling code\nafter the Call() must re-check all relevant assumptions after\nre-acquiring the lock; for example, it should check that\nrf.currentTerm hasn't changed since the decision to become a\ncandidate.\n\nIt can be difficult to interpret and apply these rules. Perhaps most\npuzzling is the notion in Rules 2 and 3 of code sequences that\nshouldn't be interleaved with other goroutines' reads or writes. How\ncan one recognize such sequences? How should one decide where a\nsequence ought to start and end?\n\nOne approach is to start with code that has no locks, and think\ncarefully about where one needs to add locks to attain correctness.\nThis approach can be difficult since it requires reasoning about the\ncorrectness of concurrent code.\n\nA more pragmatic approach starts with the observation that if there\nwere no concurrency (no simultaneously executing goroutines), you\nwould not need locks at all. But you have concurrency forced on you\nwhen the RPC system creates goroutines to execute RPC handlers, and\nbecause you need to send RPCs in separate goroutines to avoid waiting.\nYou can effectively eliminate this concurrency by identifying all\nplaces where goroutines start (RPC handlers, background goroutines you\ncreate in Make(), &c), acquiring the lock at the very start of each\ngoroutine, and only releasing the lock when that goroutine has\ncompletely finished and returns. This locking protocol ensures that\nnothing significant ever executes in parallel; the locks ensure that\neach goroutine executes to completion before any other goroutine is\nallowed to start. With no parallel execution, it's hard to violate\nRules 1, 2, 3, or 5. If each goroutine's code is correct in isolation\n(when executed alone, with no concurrent goroutines), it's likely to\nstill be correct when you use locks to suppress concurrency. So you\ncan avoid explicit reasoning about correctness, or explicitly\nidentifying critical sections.\n\nHowever, Rule 4 is likely to be a problem. So the next step is to find\nplaces where the code waits, and to add lock releases and re-acquires\n(and/or goroutine creation) as needed, being careful to re-establish\nassumptions after each re-acquire. You may find this process easier to\nget right than directly identifying sequences that must be locked for\ncorrectness.\n\n(As an aside, what this approach sacrifices is any opportunity for\nbetter performance via parallel execution on multiple cores: your code\nis likely to hold locks when it doesn't need to, and may thus\nunnecessarily prohibit parallel execution of goroutines. On the other\nhand, there is not much opportunity for CPU parallelism within a\nsingle Raft peer.)\n</pre>\n</details>","source":"_posts/MIT6.824/lab2_lock_advice.md","raw":"---\ntitle: MIT6.824之lab2_raft_lock_advice\ncategories:\n- 分布式\n- MIT6.824\n---\n\n# rule 1\n\nwhenever you have one more goroutine gonna modify data , you should use lock to prevent data and\navoid multip-goroutine change data ,go race is a good tool , that is enable to detect data race ,\nbut without any helpful on below rules\n\n# rule 2\n\nwhenever your code make a sequence of modification on shared code.if they looked at the\ndata midway through the sequence,other goroutines might malfunction, you should use lock\nto pretect code block which gonna be change and other routine read data midway, for example\n\n```golang\n  rf.mu.Lock()\n  rf.currentTerm += 1\n  rf.state = Candidate\n  rf.mu.Unlock()\n```\n\n\none more goroutine could not read any of above temp updates, so A goroutine should hold locking over the critical section.\non the other hand , if B goroutine using r.currenTerm or r.state, ,who must hold locking when access r.currenTerm at somewhere\n\n# rule 3\n\nWhenever code does a sequence of reads of shared data (or\nreads and writes), and would malfunction if another goroutine modified\nthe data midway through the sequence, you should use a lock around the\nwhole sequence.\n\nplease must take care and review the multi-goroutine change data at the same time.and must aware if another goroutine modified\nthe data midway through the sequence, you should use a lock around the whole sequence.\n\n```golang\n\nrf.mu.Lock()\n  if args.Term > rf.currentTerm {\n   rf.currentTerm = args.Term\n  }\n  rf.mu.Unlock()\n\n```\n\n# rule 4\n\nthis rule just only apply to lab2, it announces that It's usually a bad idea to hold a lock while doing anything that might wait: reading a Go channel, sending on a channel, waiting for a timer, calling time.Sleep(), or sending an RPC (and waiting for the\nreply).\n\n# rule 5\n\nthis rule is also apply for lab2 specifical case.\nBe careful about assumptions across a drop and re-acquire of a\nlock. One place this can arise is when avoiding waiting with locks\nheld.\n\nBe careful about assumptions across a drop and re-acquire of a\nlock. One place this can arise is when avoiding waiting with locks\nheld. For example, this code to send vote RPCs is incorrect:\n\n```golang\n  rf.mu.Lock()\n  rf.currentTerm += 1\n  rf.state = Candidate\n  for <each peer> {\n    go func() {\n      rf.mu.Lock()\n      args.Term = rf.currentTerm\n      rf.mu.Unlock()\n      Call(\"Raft.RequestVote\", &args, ...)\n      // handle the reply...\n    } ()\n  }\n  rf.mu.Unlock()\n```\n\nThe code sends each RPC in a separate goroutine. It's incorrect\nbecause args.Term may not be the same as the rf.currentTerm at which\nthe surrounding code decided to become a Candidate. Lots of time may\npass between when the surrounding code creates the goroutine and when\nthe goroutine reads rf.currentTerm; for example, multiple terms may\ncome and go, and the peer may no longer be a candidate. One way to fix\nthis is for the created goroutine to use a copy of rf.currentTerm made\nwhile the outer code holds the lock. Similarly, reply-handling code\nafter the Call() must re-check all relevant assumptions after\nre-acquiring the lock; for example, it should check that\nrf.currentTerm hasn't changed since the decision to become a\ncandidate.\n\nIt can be difficult to interpret and apply these rules. Perhaps most\npuzzling is the notion in Rules 2 and 3 of code sequences that\nshouldn't be interleaved with other goroutines' reads or writes. How\ncan one recognize such sequences? How should one decide where a\nsequence ought to start and end?\n\nOne approach is to start with code that has no locks, and think\ncarefully about where one needs to add locks to attain correctness.\nThis approach can be difficult since it requires reasoning about the\ncorrectness of concurrent code.\n\n一个更务实的方法是从观察开始的，如果没有\n没有并发性（没有同时执行的goroutine），你就根本不需要锁。\n就根本不需要锁了。但是，当RPC系统创建goroutines来执行RPC时，你的并发性被强加于你\n当RPC系统创建goroutines来执行RPC处理程序时，你的并发性是被迫的，并且\n因为你需要在不同的goroutine中发送RPC以避免等待。\n你可以有效地消除这种并发，方法是确定所有\n的地方（RPC处理程序、你在Make()中创建的后台goroutine\n中创建的后台goroutines，等等），在每个goroutine的开始时获取锁，并且只释放锁。\n锁，并且只有在该程序完全结束并返回时才释放锁。\n完全结束并返回时才释放锁。这个锁协议确保\n没有任何重要的东西是并行执行的；锁保证了\n每个goroutine在任何其他goroutine被允许启动之前执行完毕。\n允许启动。由于没有并行执行，所以很难违反\n规则1、2、3或5。如果每个goroutine的代码在孤立情况下是正确的\n(当单独执行时，没有并发的goroutine)，那么当你使用锁时，它很可能\n当你使用锁来抑制并发性时，它仍然是正确的。所以你\n可以避免对正确性进行明确的推理，或者明确的\n识别关键部分。\n> 通过www.DeepL.com/Translator（免费版）翻译\n\nHowever, Rule 4 is likely to be a problem. So the next step is to find\nplaces where the code waits, and to add lock releases and re-acquires\n(and/or goroutine creation) as needed, being careful to re-establish\nassumptions after each re-acquire. You may find this process easier to\nget right than directly identifying sequences that must be locked for\ncorrectness.\n\n(As an aside, what this approach sacrifices is any opportunity for\nbetter performance via parallel execution on multiple cores: your code\nis likely to hold locks when it doesn't need to, and may thus\nunnecessarily prohibit parallel execution of goroutines. On the other\nhand, there is not much opportunity for CPU parallelism within a\nsingle Raft peer.)\n\n# 原文\n\n<details>\n<summary>原文</summary>\n<pre>\nRaft Locking Advice\n\nIf you are wondering how to use locks in the 6.824 Raft labs, here are\nsome rules and ways of thinking that might be helpful.\n\nRule 1: Whenever you have data that more than one goroutine uses, and\nat least one goroutine might modify the data, the goroutines should\nuse locks to prevent simultaneous use of the data. The Go race\ndetector is pretty good at detecting violations of this rule (though\nit won't help with any of the rules below).\n\nRule 2: Whenever code makes a sequence of modifications to shared\ndata, and other goroutines might malfunction if they looked at the\ndata midway through the sequence, you should use a lock around the\nwhole sequence.\n\nAn example:\n\n  rf.mu.Lock()\n  rf.currentTerm += 1\n  rf.state = Candidate\n  rf.mu.Unlock()\n\nIt would be a mistake for another goroutine to see either of these\nupdates alone (i.e. the old state with the new term, or the new term\nwith the old state). So we need to hold the lock continuously over the\nwhole sequence of updates. All other code that uses rf.currentTerm or\nrf.state must also hold the lock, in order to ensure exclusive access\nfor all uses.\n\nThe code between Lock() and Unlock() is often called a \"critical\nsection.\" The locking rules a programmer chooses (e.g. \"a goroutine\nmust hold rf.mu when using rf.currentTerm or rf.state\") are often\ncalled a \"locking protocol\".\n\nRule 3: Whenever code does a sequence of reads of shared data (or\nreads and writes), and would malfunction if another goroutine modified\nthe data midway through the sequence, you should use a lock around the\nwhole sequence.\n\nAn example that could occur in a Raft RPC handler:\n\n  rf.mu.Lock()\n  if args.Term > rf.currentTerm {\n   rf.currentTerm = args.Term\n  }\n  rf.mu.Unlock()\n\nThis code needs to hold the lock continuously for the whole sequence.\nRaft requires that currentTerm only increases, and never decreases.\nAnother RPC handler could be executing in a separate goroutine; if it\nwere allowed to modify rf.currentTerm between the if statement and the\nupdate to rf.currentTerm, this code might end up decreasing\nrf.currentTerm. Hence the lock must be held continuously over the\nwhole sequence. In addition, every other use of currentTerm must hold\nthe lock, to ensure that no other goroutine modifies currentTerm\nduring our critical section.\n\nReal Raft code would need to use longer critical sections than these\nexamples; for example, a Raft RPC handler should probably hold the\nlock for the entire handler.\n\nRule 4: It's usually a bad idea to hold a lock while doing anything\nthat might wait: reading a Go channel, sending on a channel, waiting\nfor a timer, calling time.Sleep(), or sending an RPC (and waiting for the\nreply). One reason is that you probably want other goroutines to make\nprogress during the wait. Another reason is deadlock avoidance. Imagine\ntwo peers sending each other RPCs while holding locks; both RPC\nhandlers need the receiving peer's lock; neither RPC handler can ever\ncomplete because it needs the lock held by the waiting RPC call.\n\nCode that waits should first release locks. If that's not convenient,\nsometimes it's useful to create a separate goroutine to do the wait.\n\nRule 5: Be careful about assumptions across a drop and re-acquire of a\nlock. One place this can arise is when avoiding waiting with locks\nheld. For example, this code to send vote RPCs is incorrect:\n\n  rf.mu.Lock()\n  rf.currentTerm += 1\n  rf.state = Candidate\n  for <each peer> {\n    go func() {\n      rf.mu.Lock()\n      args.Term = rf.currentTerm\n      rf.mu.Unlock()\n      Call(\"Raft.RequestVote\", &args, ...)\n      // handle the reply...\n    } ()\n  }\n  rf.mu.Unlock()\n\nThe code sends each RPC in a separate goroutine. It's incorrect\nbecause args.Term may not be the same as the rf.currentTerm at which\nthe surrounding code decided to become a Candidate. Lots of time may\npass between when the surrounding code creates the goroutine and when\nthe goroutine reads rf.currentTerm; for example, multiple terms may\ncome and go, and the peer may no longer be a candidate. One way to fix\nthis is for the created goroutine to use a copy of rf.currentTerm made\nwhile the outer code holds the lock. Similarly, reply-handling code\nafter the Call() must re-check all relevant assumptions after\nre-acquiring the lock; for example, it should check that\nrf.currentTerm hasn't changed since the decision to become a\ncandidate.\n\nIt can be difficult to interpret and apply these rules. Perhaps most\npuzzling is the notion in Rules 2 and 3 of code sequences that\nshouldn't be interleaved with other goroutines' reads or writes. How\ncan one recognize such sequences? How should one decide where a\nsequence ought to start and end?\n\nOne approach is to start with code that has no locks, and think\ncarefully about where one needs to add locks to attain correctness.\nThis approach can be difficult since it requires reasoning about the\ncorrectness of concurrent code.\n\nA more pragmatic approach starts with the observation that if there\nwere no concurrency (no simultaneously executing goroutines), you\nwould not need locks at all. But you have concurrency forced on you\nwhen the RPC system creates goroutines to execute RPC handlers, and\nbecause you need to send RPCs in separate goroutines to avoid waiting.\nYou can effectively eliminate this concurrency by identifying all\nplaces where goroutines start (RPC handlers, background goroutines you\ncreate in Make(), &c), acquiring the lock at the very start of each\ngoroutine, and only releasing the lock when that goroutine has\ncompletely finished and returns. This locking protocol ensures that\nnothing significant ever executes in parallel; the locks ensure that\neach goroutine executes to completion before any other goroutine is\nallowed to start. With no parallel execution, it's hard to violate\nRules 1, 2, 3, or 5. If each goroutine's code is correct in isolation\n(when executed alone, with no concurrent goroutines), it's likely to\nstill be correct when you use locks to suppress concurrency. So you\ncan avoid explicit reasoning about correctness, or explicitly\nidentifying critical sections.\n\nHowever, Rule 4 is likely to be a problem. So the next step is to find\nplaces where the code waits, and to add lock releases and re-acquires\n(and/or goroutine creation) as needed, being careful to re-establish\nassumptions after each re-acquire. You may find this process easier to\nget right than directly identifying sequences that must be locked for\ncorrectness.\n\n(As an aside, what this approach sacrifices is any opportunity for\nbetter performance via parallel execution on multiple cores: your code\nis likely to hold locks when it doesn't need to, and may thus\nunnecessarily prohibit parallel execution of goroutines. On the other\nhand, there is not much opportunity for CPU parallelism within a\nsingle Raft peer.)\n</pre>\n</details>","slug":"MIT6.824/lab2_lock_advice","published":1,"date":"2022-10-05T14:32:54.640Z","updated":"2022-10-07T00:39:20.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5k000il1db9ujx0n8r","content":"<h1 id=\"rule-1\"><a href=\"#rule-1\" class=\"headerlink\" title=\"rule 1\"></a>rule 1</h1><p>whenever you have one more goroutine gonna modify data , you should use lock to prevent data and<br>avoid multip-goroutine change data ,go race is a good tool , that is enable to detect data race ,<br>but without any helpful on below rules</p>\n<h1 id=\"rule-2\"><a href=\"#rule-2\" class=\"headerlink\" title=\"rule 2\"></a>rule 2</h1><p>whenever your code make a sequence of modification on shared code.if they looked at the<br>data midway through the sequence,other goroutines might malfunction, you should use lock<br>to pretect code block which gonna be change and other routine read data midway, for example</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">rf.mu.Lock()\nrf.currentTerm +&#x3D; 1\nrf.state &#x3D; Candidate\nrf.mu.Unlock()</code></pre>\n\n\n<p>one more goroutine could not read any of above temp updates, so A goroutine should hold locking over the critical section.<br>on the other hand , if B goroutine using r.currenTerm or r.state, ,who must hold locking when access r.currenTerm at somewhere</p>\n<h1 id=\"rule-3\"><a href=\"#rule-3\" class=\"headerlink\" title=\"rule 3\"></a>rule 3</h1><p>Whenever code does a sequence of reads of shared data (or<br>reads and writes), and would malfunction if another goroutine modified<br>the data midway through the sequence, you should use a lock around the<br>whole sequence.</p>\n<p>please must take care and review the multi-goroutine change data at the same time.and must aware if another goroutine modified<br>the data midway through the sequence, you should use a lock around the whole sequence.</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nrf.mu.Lock()\n  if args.Term &gt; rf.currentTerm &#123;\n   rf.currentTerm &#x3D; args.Term\n  &#125;\n  rf.mu.Unlock()\n</code></pre>\n\n<h1 id=\"rule-4\"><a href=\"#rule-4\" class=\"headerlink\" title=\"rule 4\"></a>rule 4</h1><p>this rule just only apply to lab2, it announces that It’s usually a bad idea to hold a lock while doing anything that might wait: reading a Go channel, sending on a channel, waiting for a timer, calling time.Sleep(), or sending an RPC (and waiting for the<br>reply).</p>\n<h1 id=\"rule-5\"><a href=\"#rule-5\" class=\"headerlink\" title=\"rule 5\"></a>rule 5</h1><p>this rule is also apply for lab2 specifical case.<br>Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held.</p>\n<p>Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held. For example, this code to send vote RPCs is incorrect:</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">rf.mu.Lock()\nrf.currentTerm +&#x3D; 1\nrf.state &#x3D; Candidate\nfor &lt;each peer&gt; &#123;\n  go func() &#123;\n    rf.mu.Lock()\n    args.Term &#x3D; rf.currentTerm\n    rf.mu.Unlock()\n    Call(&quot;Raft.RequestVote&quot;, &amp;args, ...)\n    &#x2F;&#x2F; handle the reply...\n  &#125; ()\n&#125;\nrf.mu.Unlock()</code></pre>\n\n<p>The code sends each RPC in a separate goroutine. It’s incorrect<br>because args.Term may not be the same as the rf.currentTerm at which<br>the surrounding code decided to become a Candidate. Lots of time may<br>pass between when the surrounding code creates the goroutine and when<br>the goroutine reads rf.currentTerm; for example, multiple terms may<br>come and go, and the peer may no longer be a candidate. One way to fix<br>this is for the created goroutine to use a copy of rf.currentTerm made<br>while the outer code holds the lock. Similarly, reply-handling code<br>after the Call() must re-check all relevant assumptions after<br>re-acquiring the lock; for example, it should check that<br>rf.currentTerm hasn’t changed since the decision to become a<br>candidate.</p>\n<p>It can be difficult to interpret and apply these rules. Perhaps most<br>puzzling is the notion in Rules 2 and 3 of code sequences that<br>shouldn’t be interleaved with other goroutines’ reads or writes. How<br>can one recognize such sequences? How should one decide where a<br>sequence ought to start and end?</p>\n<p>One approach is to start with code that has no locks, and think<br>carefully about where one needs to add locks to attain correctness.<br>This approach can be difficult since it requires reasoning about the<br>correctness of concurrent code.</p>\n<p>一个更务实的方法是从观察开始的，如果没有<br>没有并发性（没有同时执行的goroutine），你就根本不需要锁。<br>就根本不需要锁了。但是，当RPC系统创建goroutines来执行RPC时，你的并发性被强加于你<br>当RPC系统创建goroutines来执行RPC处理程序时，你的并发性是被迫的，并且<br>因为你需要在不同的goroutine中发送RPC以避免等待。<br>你可以有效地消除这种并发，方法是确定所有<br>的地方（RPC处理程序、你在Make()中创建的后台goroutine<br>中创建的后台goroutines，等等），在每个goroutine的开始时获取锁，并且只释放锁。<br>锁，并且只有在该程序完全结束并返回时才释放锁。<br>完全结束并返回时才释放锁。这个锁协议确保<br>没有任何重要的东西是并行执行的；锁保证了<br>每个goroutine在任何其他goroutine被允许启动之前执行完毕。<br>允许启动。由于没有并行执行，所以很难违反<br>规则1、2、3或5。如果每个goroutine的代码在孤立情况下是正确的<br>(当单独执行时，没有并发的goroutine)，那么当你使用锁时，它很可能<br>当你使用锁来抑制并发性时，它仍然是正确的。所以你<br>可以避免对正确性进行明确的推理，或者明确的<br>识别关键部分。</p>\n<blockquote>\n<p>通过<a href=\"http://www.deepl.com/Translator%EF%BC%88%E5%85%8D%E8%B4%B9%E7%89%88%EF%BC%89%E7%BF%BB%E8%AF%91\">www.DeepL.com/Translator（免费版）翻译</a></p>\n</blockquote>\n<p>However, Rule 4 is likely to be a problem. So the next step is to find<br>places where the code waits, and to add lock releases and re-acquires<br>(and&#x2F;or goroutine creation) as needed, being careful to re-establish<br>assumptions after each re-acquire. You may find this process easier to<br>get right than directly identifying sequences that must be locked for<br>correctness.</p>\n<p>(As an aside, what this approach sacrifices is any opportunity for<br>better performance via parallel execution on multiple cores: your code<br>is likely to hold locks when it doesn’t need to, and may thus<br>unnecessarily prohibit parallel execution of goroutines. On the other<br>hand, there is not much opportunity for CPU parallelism within a<br>single Raft peer.)</p>\n<h1 id=\"原文\"><a href=\"#原文\" class=\"headerlink\" title=\"原文\"></a>原文</h1><details>\n<summary>原文</summary>\n<pre>\nRaft Locking Advice\n\n<p>If you are wondering how to use locks in the 6.824 Raft labs, here are<br>some rules and ways of thinking that might be helpful.</p>\n<p>Rule 1: Whenever you have data that more than one goroutine uses, and<br>at least one goroutine might modify the data, the goroutines should<br>use locks to prevent simultaneous use of the data. The Go race<br>detector is pretty good at detecting violations of this rule (though<br>it won’t help with any of the rules below).</p>\n<p>Rule 2: Whenever code makes a sequence of modifications to shared<br>data, and other goroutines might malfunction if they looked at the<br>data midway through the sequence, you should use a lock around the<br>whole sequence.</p>\n<p>An example:</p>\n<p>  rf.mu.Lock()<br>  rf.currentTerm +&#x3D; 1<br>  rf.state &#x3D; Candidate<br>  rf.mu.Unlock()</p>\n<p>It would be a mistake for another goroutine to see either of these<br>updates alone (i.e. the old state with the new term, or the new term<br>with the old state). So we need to hold the lock continuously over the<br>whole sequence of updates. All other code that uses rf.currentTerm or<br>rf.state must also hold the lock, in order to ensure exclusive access<br>for all uses.</p>\n<p>The code between Lock() and Unlock() is often called a “critical<br>section.” The locking rules a programmer chooses (e.g. “a goroutine<br>must hold rf.mu when using rf.currentTerm or rf.state”) are often<br>called a “locking protocol”.</p>\n<p>Rule 3: Whenever code does a sequence of reads of shared data (or<br>reads and writes), and would malfunction if another goroutine modified<br>the data midway through the sequence, you should use a lock around the<br>whole sequence.</p>\n<p>An example that could occur in a Raft RPC handler:</p>\n<p>  rf.mu.Lock()<br>  if args.Term &gt; rf.currentTerm {<br>   rf.currentTerm &#x3D; args.Term<br>  }<br>  rf.mu.Unlock()</p>\n<p>This code needs to hold the lock continuously for the whole sequence.<br>Raft requires that currentTerm only increases, and never decreases.<br>Another RPC handler could be executing in a separate goroutine; if it<br>were allowed to modify rf.currentTerm between the if statement and the<br>update to rf.currentTerm, this code might end up decreasing<br>rf.currentTerm. Hence the lock must be held continuously over the<br>whole sequence. In addition, every other use of currentTerm must hold<br>the lock, to ensure that no other goroutine modifies currentTerm<br>during our critical section.</p>\n<p>Real Raft code would need to use longer critical sections than these<br>examples; for example, a Raft RPC handler should probably hold the<br>lock for the entire handler.</p>\n<p>Rule 4: It’s usually a bad idea to hold a lock while doing anything<br>that might wait: reading a Go channel, sending on a channel, waiting<br>for a timer, calling time.Sleep(), or sending an RPC (and waiting for the<br>reply). One reason is that you probably want other goroutines to make<br>progress during the wait. Another reason is deadlock avoidance. Imagine<br>two peers sending each other RPCs while holding locks; both RPC<br>handlers need the receiving peer’s lock; neither RPC handler can ever<br>complete because it needs the lock held by the waiting RPC call.</p>\n<p>Code that waits should first release locks. If that’s not convenient,<br>sometimes it’s useful to create a separate goroutine to do the wait.</p>\n<p>Rule 5: Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held. For example, this code to send vote RPCs is incorrect:</p>\n<p>  rf.mu.Lock()<br>  rf.currentTerm +&#x3D; 1<br>  rf.state &#x3D; Candidate<br>  for <each peer> {<br>    go func() {<br>      rf.mu.Lock()<br>      args.Term &#x3D; rf.currentTerm<br>      rf.mu.Unlock()<br>      Call(“Raft.RequestVote”, &amp;args, …)<br>      &#x2F;&#x2F; handle the reply…<br>    } ()<br>  }<br>  rf.mu.Unlock()</p>\n<p>The code sends each RPC in a separate goroutine. It’s incorrect<br>because args.Term may not be the same as the rf.currentTerm at which<br>the surrounding code decided to become a Candidate. Lots of time may<br>pass between when the surrounding code creates the goroutine and when<br>the goroutine reads rf.currentTerm; for example, multiple terms may<br>come and go, and the peer may no longer be a candidate. One way to fix<br>this is for the created goroutine to use a copy of rf.currentTerm made<br>while the outer code holds the lock. Similarly, reply-handling code<br>after the Call() must re-check all relevant assumptions after<br>re-acquiring the lock; for example, it should check that<br>rf.currentTerm hasn’t changed since the decision to become a<br>candidate.</p>\n<p>It can be difficult to interpret and apply these rules. Perhaps most<br>puzzling is the notion in Rules 2 and 3 of code sequences that<br>shouldn’t be interleaved with other goroutines’ reads or writes. How<br>can one recognize such sequences? How should one decide where a<br>sequence ought to start and end?</p>\n<p>One approach is to start with code that has no locks, and think<br>carefully about where one needs to add locks to attain correctness.<br>This approach can be difficult since it requires reasoning about the<br>correctness of concurrent code.</p>\n<p>A more pragmatic approach starts with the observation that if there<br>were no concurrency (no simultaneously executing goroutines), you<br>would not need locks at all. But you have concurrency forced on you<br>when the RPC system creates goroutines to execute RPC handlers, and<br>because you need to send RPCs in separate goroutines to avoid waiting.<br>You can effectively eliminate this concurrency by identifying all<br>places where goroutines start (RPC handlers, background goroutines you<br>create in Make(), &amp;c), acquiring the lock at the very start of each<br>goroutine, and only releasing the lock when that goroutine has<br>completely finished and returns. This locking protocol ensures that<br>nothing significant ever executes in parallel; the locks ensure that<br>each goroutine executes to completion before any other goroutine is<br>allowed to start. With no parallel execution, it’s hard to violate<br>Rules 1, 2, 3, or 5. If each goroutine’s code is correct in isolation<br>(when executed alone, with no concurrent goroutines), it’s likely to<br>still be correct when you use locks to suppress concurrency. So you<br>can avoid explicit reasoning about correctness, or explicitly<br>identifying critical sections.</p>\n<p>However, Rule 4 is likely to be a problem. So the next step is to find<br>places where the code waits, and to add lock releases and re-acquires<br>(and&#x2F;or goroutine creation) as needed, being careful to re-establish<br>assumptions after each re-acquire. You may find this process easier to<br>get right than directly identifying sequences that must be locked for<br>correctness.</p>\n<p>(As an aside, what this approach sacrifices is any opportunity for<br>better performance via parallel execution on multiple cores: your code<br>is likely to hold locks when it doesn’t need to, and may thus<br>unnecessarily prohibit parallel execution of goroutines. On the other<br>hand, there is not much opportunity for CPU parallelism within a<br>single Raft peer.)<br></pre></p>\n</details>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"rule-1\"><a href=\"#rule-1\" class=\"headerlink\" title=\"rule 1\"></a>rule 1</h1><p>whenever you have one more goroutine gonna modify data , you should use lock to prevent data and<br>avoid multip-goroutine change data ,go race is a good tool , that is enable to detect data race ,<br>but without any helpful on below rules</p>\n<h1 id=\"rule-2\"><a href=\"#rule-2\" class=\"headerlink\" title=\"rule 2\"></a>rule 2</h1><p>whenever your code make a sequence of modification on shared code.if they looked at the<br>data midway through the sequence,other goroutines might malfunction, you should use lock<br>to pretect code block which gonna be change and other routine read data midway, for example</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">rf.mu.Lock()\nrf.currentTerm +&#x3D; 1\nrf.state &#x3D; Candidate\nrf.mu.Unlock()</code></pre>\n\n\n<p>one more goroutine could not read any of above temp updates, so A goroutine should hold locking over the critical section.<br>on the other hand , if B goroutine using r.currenTerm or r.state, ,who must hold locking when access r.currenTerm at somewhere</p>\n<h1 id=\"rule-3\"><a href=\"#rule-3\" class=\"headerlink\" title=\"rule 3\"></a>rule 3</h1><p>Whenever code does a sequence of reads of shared data (or<br>reads and writes), and would malfunction if another goroutine modified<br>the data midway through the sequence, you should use a lock around the<br>whole sequence.</p>\n<p>please must take care and review the multi-goroutine change data at the same time.and must aware if another goroutine modified<br>the data midway through the sequence, you should use a lock around the whole sequence.</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nrf.mu.Lock()\n  if args.Term &gt; rf.currentTerm &#123;\n   rf.currentTerm &#x3D; args.Term\n  &#125;\n  rf.mu.Unlock()\n</code></pre>\n\n<h1 id=\"rule-4\"><a href=\"#rule-4\" class=\"headerlink\" title=\"rule 4\"></a>rule 4</h1><p>this rule just only apply to lab2, it announces that It’s usually a bad idea to hold a lock while doing anything that might wait: reading a Go channel, sending on a channel, waiting for a timer, calling time.Sleep(), or sending an RPC (and waiting for the<br>reply).</p>\n<h1 id=\"rule-5\"><a href=\"#rule-5\" class=\"headerlink\" title=\"rule 5\"></a>rule 5</h1><p>this rule is also apply for lab2 specifical case.<br>Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held.</p>\n<p>Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held. For example, this code to send vote RPCs is incorrect:</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">rf.mu.Lock()\nrf.currentTerm +&#x3D; 1\nrf.state &#x3D; Candidate\nfor &lt;each peer&gt; &#123;\n  go func() &#123;\n    rf.mu.Lock()\n    args.Term &#x3D; rf.currentTerm\n    rf.mu.Unlock()\n    Call(&quot;Raft.RequestVote&quot;, &amp;args, ...)\n    &#x2F;&#x2F; handle the reply...\n  &#125; ()\n&#125;\nrf.mu.Unlock()</code></pre>\n\n<p>The code sends each RPC in a separate goroutine. It’s incorrect<br>because args.Term may not be the same as the rf.currentTerm at which<br>the surrounding code decided to become a Candidate. Lots of time may<br>pass between when the surrounding code creates the goroutine and when<br>the goroutine reads rf.currentTerm; for example, multiple terms may<br>come and go, and the peer may no longer be a candidate. One way to fix<br>this is for the created goroutine to use a copy of rf.currentTerm made<br>while the outer code holds the lock. Similarly, reply-handling code<br>after the Call() must re-check all relevant assumptions after<br>re-acquiring the lock; for example, it should check that<br>rf.currentTerm hasn’t changed since the decision to become a<br>candidate.</p>\n<p>It can be difficult to interpret and apply these rules. Perhaps most<br>puzzling is the notion in Rules 2 and 3 of code sequences that<br>shouldn’t be interleaved with other goroutines’ reads or writes. How<br>can one recognize such sequences? How should one decide where a<br>sequence ought to start and end?</p>\n<p>One approach is to start with code that has no locks, and think<br>carefully about where one needs to add locks to attain correctness.<br>This approach can be difficult since it requires reasoning about the<br>correctness of concurrent code.</p>\n<p>一个更务实的方法是从观察开始的，如果没有<br>没有并发性（没有同时执行的goroutine），你就根本不需要锁。<br>就根本不需要锁了。但是，当RPC系统创建goroutines来执行RPC时，你的并发性被强加于你<br>当RPC系统创建goroutines来执行RPC处理程序时，你的并发性是被迫的，并且<br>因为你需要在不同的goroutine中发送RPC以避免等待。<br>你可以有效地消除这种并发，方法是确定所有<br>的地方（RPC处理程序、你在Make()中创建的后台goroutine<br>中创建的后台goroutines，等等），在每个goroutine的开始时获取锁，并且只释放锁。<br>锁，并且只有在该程序完全结束并返回时才释放锁。<br>完全结束并返回时才释放锁。这个锁协议确保<br>没有任何重要的东西是并行执行的；锁保证了<br>每个goroutine在任何其他goroutine被允许启动之前执行完毕。<br>允许启动。由于没有并行执行，所以很难违反<br>规则1、2、3或5。如果每个goroutine的代码在孤立情况下是正确的<br>(当单独执行时，没有并发的goroutine)，那么当你使用锁时，它很可能<br>当你使用锁来抑制并发性时，它仍然是正确的。所以你<br>可以避免对正确性进行明确的推理，或者明确的<br>识别关键部分。</p>\n<blockquote>\n<p>通过<a href=\"http://www.deepl.com/Translator%EF%BC%88%E5%85%8D%E8%B4%B9%E7%89%88%EF%BC%89%E7%BF%BB%E8%AF%91\">www.DeepL.com/Translator（免费版）翻译</a></p>\n</blockquote>\n<p>However, Rule 4 is likely to be a problem. So the next step is to find<br>places where the code waits, and to add lock releases and re-acquires<br>(and&#x2F;or goroutine creation) as needed, being careful to re-establish<br>assumptions after each re-acquire. You may find this process easier to<br>get right than directly identifying sequences that must be locked for<br>correctness.</p>\n<p>(As an aside, what this approach sacrifices is any opportunity for<br>better performance via parallel execution on multiple cores: your code<br>is likely to hold locks when it doesn’t need to, and may thus<br>unnecessarily prohibit parallel execution of goroutines. On the other<br>hand, there is not much opportunity for CPU parallelism within a<br>single Raft peer.)</p>\n<h1 id=\"原文\"><a href=\"#原文\" class=\"headerlink\" title=\"原文\"></a>原文</h1><details>\n<summary>原文</summary>\n<pre>\nRaft Locking Advice\n\n<p>If you are wondering how to use locks in the 6.824 Raft labs, here are<br>some rules and ways of thinking that might be helpful.</p>\n<p>Rule 1: Whenever you have data that more than one goroutine uses, and<br>at least one goroutine might modify the data, the goroutines should<br>use locks to prevent simultaneous use of the data. The Go race<br>detector is pretty good at detecting violations of this rule (though<br>it won’t help with any of the rules below).</p>\n<p>Rule 2: Whenever code makes a sequence of modifications to shared<br>data, and other goroutines might malfunction if they looked at the<br>data midway through the sequence, you should use a lock around the<br>whole sequence.</p>\n<p>An example:</p>\n<p>  rf.mu.Lock()<br>  rf.currentTerm +&#x3D; 1<br>  rf.state &#x3D; Candidate<br>  rf.mu.Unlock()</p>\n<p>It would be a mistake for another goroutine to see either of these<br>updates alone (i.e. the old state with the new term, or the new term<br>with the old state). So we need to hold the lock continuously over the<br>whole sequence of updates. All other code that uses rf.currentTerm or<br>rf.state must also hold the lock, in order to ensure exclusive access<br>for all uses.</p>\n<p>The code between Lock() and Unlock() is often called a “critical<br>section.” The locking rules a programmer chooses (e.g. “a goroutine<br>must hold rf.mu when using rf.currentTerm or rf.state”) are often<br>called a “locking protocol”.</p>\n<p>Rule 3: Whenever code does a sequence of reads of shared data (or<br>reads and writes), and would malfunction if another goroutine modified<br>the data midway through the sequence, you should use a lock around the<br>whole sequence.</p>\n<p>An example that could occur in a Raft RPC handler:</p>\n<p>  rf.mu.Lock()<br>  if args.Term &gt; rf.currentTerm {<br>   rf.currentTerm &#x3D; args.Term<br>  }<br>  rf.mu.Unlock()</p>\n<p>This code needs to hold the lock continuously for the whole sequence.<br>Raft requires that currentTerm only increases, and never decreases.<br>Another RPC handler could be executing in a separate goroutine; if it<br>were allowed to modify rf.currentTerm between the if statement and the<br>update to rf.currentTerm, this code might end up decreasing<br>rf.currentTerm. Hence the lock must be held continuously over the<br>whole sequence. In addition, every other use of currentTerm must hold<br>the lock, to ensure that no other goroutine modifies currentTerm<br>during our critical section.</p>\n<p>Real Raft code would need to use longer critical sections than these<br>examples; for example, a Raft RPC handler should probably hold the<br>lock for the entire handler.</p>\n<p>Rule 4: It’s usually a bad idea to hold a lock while doing anything<br>that might wait: reading a Go channel, sending on a channel, waiting<br>for a timer, calling time.Sleep(), or sending an RPC (and waiting for the<br>reply). One reason is that you probably want other goroutines to make<br>progress during the wait. Another reason is deadlock avoidance. Imagine<br>two peers sending each other RPCs while holding locks; both RPC<br>handlers need the receiving peer’s lock; neither RPC handler can ever<br>complete because it needs the lock held by the waiting RPC call.</p>\n<p>Code that waits should first release locks. If that’s not convenient,<br>sometimes it’s useful to create a separate goroutine to do the wait.</p>\n<p>Rule 5: Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held. For example, this code to send vote RPCs is incorrect:</p>\n<p>  rf.mu.Lock()<br>  rf.currentTerm +&#x3D; 1<br>  rf.state &#x3D; Candidate<br>  for <each peer> {<br>    go func() {<br>      rf.mu.Lock()<br>      args.Term &#x3D; rf.currentTerm<br>      rf.mu.Unlock()<br>      Call(“Raft.RequestVote”, &amp;args, …)<br>      &#x2F;&#x2F; handle the reply…<br>    } ()<br>  }<br>  rf.mu.Unlock()</p>\n<p>The code sends each RPC in a separate goroutine. It’s incorrect<br>because args.Term may not be the same as the rf.currentTerm at which<br>the surrounding code decided to become a Candidate. Lots of time may<br>pass between when the surrounding code creates the goroutine and when<br>the goroutine reads rf.currentTerm; for example, multiple terms may<br>come and go, and the peer may no longer be a candidate. One way to fix<br>this is for the created goroutine to use a copy of rf.currentTerm made<br>while the outer code holds the lock. Similarly, reply-handling code<br>after the Call() must re-check all relevant assumptions after<br>re-acquiring the lock; for example, it should check that<br>rf.currentTerm hasn’t changed since the decision to become a<br>candidate.</p>\n<p>It can be difficult to interpret and apply these rules. Perhaps most<br>puzzling is the notion in Rules 2 and 3 of code sequences that<br>shouldn’t be interleaved with other goroutines’ reads or writes. How<br>can one recognize such sequences? How should one decide where a<br>sequence ought to start and end?</p>\n<p>One approach is to start with code that has no locks, and think<br>carefully about where one needs to add locks to attain correctness.<br>This approach can be difficult since it requires reasoning about the<br>correctness of concurrent code.</p>\n<p>A more pragmatic approach starts with the observation that if there<br>were no concurrency (no simultaneously executing goroutines), you<br>would not need locks at all. But you have concurrency forced on you<br>when the RPC system creates goroutines to execute RPC handlers, and<br>because you need to send RPCs in separate goroutines to avoid waiting.<br>You can effectively eliminate this concurrency by identifying all<br>places where goroutines start (RPC handlers, background goroutines you<br>create in Make(), &amp;c), acquiring the lock at the very start of each<br>goroutine, and only releasing the lock when that goroutine has<br>completely finished and returns. This locking protocol ensures that<br>nothing significant ever executes in parallel; the locks ensure that<br>each goroutine executes to completion before any other goroutine is<br>allowed to start. With no parallel execution, it’s hard to violate<br>Rules 1, 2, 3, or 5. If each goroutine’s code is correct in isolation<br>(when executed alone, with no concurrent goroutines), it’s likely to<br>still be correct when you use locks to suppress concurrency. So you<br>can avoid explicit reasoning about correctness, or explicitly<br>identifying critical sections.</p>\n<p>However, Rule 4 is likely to be a problem. So the next step is to find<br>places where the code waits, and to add lock releases and re-acquires<br>(and&#x2F;or goroutine creation) as needed, being careful to re-establish<br>assumptions after each re-acquire. You may find this process easier to<br>get right than directly identifying sequences that must be locked for<br>correctness.</p>\n<p>(As an aside, what this approach sacrifices is any opportunity for<br>better performance via parallel execution on multiple cores: your code<br>is likely to hold locks when it doesn’t need to, and may thus<br>unnecessarily prohibit parallel execution of goroutines. On the other<br>hand, there is not much opportunity for CPU parallelism within a<br>single Raft peer.)<br></pre></p>\n</details>"},{"title":"MIT6.824之lab2_raft_paper","_content":"\n\n# 一.可理解的一致性算法研究-论文\n\n# 摘要\n\n- raft比paxos更容易理解,在构建大型系统的时候方便实现\n\n# 1 介绍\n\n1. 什么叫一致性算法，一致性算法就是协调多台机器有序工作，允许成员失败\n2. 天下苦paxos久矣，需要个更简单理解和实现的一致性算法，方便程序员理解什么是一致性算法\n3. raft将问题分解，减少raft不确定性，在实际的教学当中，raft要比paxos容易理解\n4. raft与Oki，VSR很像，但有如下新特性\n    - 强leader ： 日志只从领导流向follower\n    - leader选举 ： raft使用随机定时器来选举领导人。\n    - 成员变更 ： raft使用了一种新的`联合共识`的方法，多数两种不同的配置在转换过程中重叠在一起\n5. 使劲吹raft多么多么牛逼，算法性能与其他一致性算法差不多，本文的其余部分介绍了复制的状态机问题（第2节），讨论了Paxos的优点和缺点（第3节），描述了我们对可理解性的一般方法（第4节），提出了Raft共识算法（第5-8节），评估了Paxos，Raft共识算法（第5-8节），评估了Raft（第9节），并讨论了相关工作（第10节）。\n\n# 2. 复制状态机\n\n1. 共识通常出现在状态机背景下，冗余状态机通常被用来解决分布式系统中的容错问题，例如，诸如GFS [8], HDFS [38],和RAM云[33]通常使用一个状态机管理leader选举，存储相关重要的配置信息复制状态机的例子包括Chubby[2] 和 ZooKeeper [11]\n\n    ![raft_figure_1](./../../picture/mit6.824/raft_figure_1.png)\n\n2. 因为两台状态机按顺序执行相同的`日志`x=1.y=3等等,那么这两个状态机计算的状态和输出的结果也是一样的，所以共识算法要保证日志的一致性是非常重要的工作。即使一些状态机因为机械故障导致宕机(少于raft规定的数量)，但是这些服务器看起来还是像一个整体一样对外提供服务。\n    - 它们确保在所有非拜占庭条件下的安全性（永远不会返回错误的结果），包括网络延迟、分区、以及数据包丢失、重复和重新排序\n    - 只要有任何一台服务器在运行，它们就能完全发挥可用作用。大部分的服务器都在运行，并能与其他服务器和客户进行通信。彼此之间以及与客户端之间进行通信因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器的故障,假设服务器的故障是通过停止；它们后来可能从稳定的存储中恢复状态并重新加入集群。\n    - 它们并不依赖时间来确保日志的一致性：时钟故障和极端的消息延迟在最坏的情况下会导致可用性问题。延迟，在最坏的情况下，会导致可用性问题。\n    - 在通常情况下，只要集群中的大多数follower响应了命令，命令就以完成。一旦集群中的大多数follower对单轮RPC作出反应，一个命令就已经完成。少数缓慢的务器不影响整个系统的性能。\n\n    总结 : 第二节主要是引入状态机的太粘，并给出raft与状态机交互的大致流程\n\n# 3 Paxos怎么了？\n\n1. Leslie Lamport创造了paxos共识算法，paxos被证明是安全的(能够达到一致)，有效的。但是paxos有两个明显的缺点(ps:什么是多paxos,single-decree子集)\n    - paxos非常难以理解，专业人士也很难理解全面，Paxos的不透明性来自于它选择了(单法令)子集作为其基础\n    - 构建实际系统时候也很难去实现，并验证，，Paxos使用的是对称的对等方法为核心（尽管它最终建议采用一种弱的领导形式作为性能优化）。这在简化问题上是有意义的.但很少有实际的系统使用这种方法\n\n2. 构建一个paxos为基础的分布式系统很难，理解paxos算法也很难(ps:下面引用来自于Chubby系统的总结)。所以作者认为paxos没有为构建一个分布式系统提供一个很好的基础，所以作者提出了新的一致性算法 -- 容易理解，对构建大型分布式系统也有帮助。在设计raft算法的时候，作者使用问题分解方法，将问题分解为，选举，日志复制，安全和成员变更等主要子问题。\n    > Paxos算法的描述与现实世界的需求之间存在着巨大的差距。最终的系统将基于一个未经证实的协议[4]。\n3. 第二个简化的地方是简化了状态空间，使系统连贯，作者努力消除不确定性，日志不允许有洞，并且Raft限制了日志可能变得彼此不一致的方式，但在某些情况下，不确定性实际上提高了可理解性。特别是，随机化方法引入了不确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (\"选择什么,这并不重要\")。我们使用随机化来简化Raft领袖选举算法\n\n总结 : 第三节只是阐述了paxos的`问题`,比如难理解，很难实现在构建大型系统的。\n\n# 4. 设计的可理解性\n1. 在设计raft之初就设置了如下目标\n    - 提供正确的理论基础，方便理解\n    - 减少开发时间，并易于扩展\n    - 在斟酌备选方案时，主要是从可理解性，会不会raft(状态空间，系统)变得复杂，但是这种分析是很主观的(想想作者与我们的硬实力差距)，所以作者选择了两种研究方式。\n        - 问题分解，将共识分解为独立的子问题，分别为选举，日志复制，安全和成员变成。\n        - 减少状态空间(只有leader,candidate,follower,以及优化提到的prevote/vote/appendentry),不允许日志有漏洞(index1和3之间是空的日志)，raft通过冲突检测来矫正不一致情况。随机化的方法引入了非确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (\"选择什么；这并不重要\")。我们使用随机化 来简化Raft领袖选举算法\n\n# 5. raft一致性算法\n\n1. leader接受来自客户端的日志条目，将其复制到其他服务器上，并告诉服务器何时可以将日志条目应用到他们的状态机上。有一个领导者可以简化对复制日志的管理。例如只允许数据从领导者流向其他服务器。一个领导者可能失败或与其他服务器断开连接，在这种情况下 选举一个新的领导者\n\n![raft_figure_2](./../../picture/mit6.824/raft_figure_2.png)\n考虑到领导者的方法，Raft将共识问题分解为三个相对独立的子问题，这将在后面的小节中讨论.\n\n- leader选举 : 现任领导人失败,必须选择新的领导人\n- Log replication : 领导者必须接受日志条目从client,并在整个集群中复制它们。迫使其他日志与自己的日志一致（第5.3节）。\n- Safety : Raft的关键安全属性是图中的状态机安全属性。图3中的状态机安全属性：如果任何服务器 在其状态机上应用了一个特定的日志条目。 那么其他服务器就不能对相同的日志索引应用不同命令 对相同的日志索引应用不同的命令。第5.4节描述了如何Raft如何确保这一特性；该解决方案涉及到一个 第5.2节中描述的选举机制的额外限制。\n\n![raft_figure_3](./../../picture/mit6.824/raft_figure_3.png)\n\n- Election Safety: 一届任期内最多可以选出一位领导人\n- Leader Append-Only : 领导者从不覆盖或删除其日志中的的条目；它只添加新的条目\n- Log Matching : 如果两个日志包含一个具有相同的索引和术语，那么这两份日志的所有条目都是相同的。直到给定的索引为止\n- Leader Completeness : 如果在一个给定的term中提交了一个日志条目，那么该日志将出现在所有更高编号的术语的领导人的日志中。\n- State Machine Safety : 如果一个服务器在它的状态机上应用了一个日志条目 在它的状态机中应用了一个给定的索引，那么其他服务器将永远不会在同一索引应用不同的日志条目.\n- Raft保证这些属性中的每一个都是真的,在任何时候都是真实的。节号表示每个属性的讨论位置。\n\n![raft_figure_3](./../../picture/mit6.824/raft_figure_4_5.png)\n\n总结\n\n1. 所有节点都需要持久化的参数\n    - `currentTerm`持久化参数，第一次初始化为0然后单调递增\n    - `voteFor`当前term记录投票的candidateId\n    - `commitIndex`记录当前节点可以提交的日志index\n    - `lastApplied`记录当前节点可以提交给上层状态机的index\n    - `nextIndex[]`当leader被选出时需要初始化的参数，且是leader最新log+1的位置\n    - `matchIndex[]`初始化为0，表示leader与follower匹配的日志位置\n2. reqeustVote RPC细节\n    1. requestVote的请求参数\n        - `term`请求的term\n        - `candidateId`\n        - `lastLogIndex`candidate最新的log\n        - `lastLogTerm`candidate最新的term\n    2. reqeustVote response参数\n        - `term`投票时候的term\n        - `voteGranted`布尔类型，true说明follower同意投票\n    3. 重要交互逻辑\n        - 如果rpc的term小于follower的current term，follower拒绝投票\n        - 如果voteFor是空或者为candaditeID,并且candaidate的log至少与follower是一样，也可以比Follower多，新\n3. AppendEntry RPC细节\n    1. AppendEntry请求参数\n        - `term`post RPC时的term\n        - `leaderID`\n        - `preLogIndex`leader进行一致性检测日志的index\n        - `preLogTerm`leader进行一致性检测时日志的term\n        - `entries`搬运的日志\n        - `leaderCommit`leader的commitIndex\n    2. AppendEntry的response参数\n        - `term`RPC的当前term\n        - `success`布尔类型返回true说明preLogIndex和preLogTerm是匹配的\n    3. AppendEntry RPC的实现\n        - rpc's term小于follower's的term则返回false\n        - 如果preLogIndex，preLogTerm不匹配返回false\n        - preLogIndex匹配但是preLogTerm不匹配则删掉后面所有的存在的log\n        - append新log\n        - leaderCommit大于follower的commitIndex时候要把follower的commitIndex设置为min(leaderCommit,len(logs))\n4. 提交给状态机的规则\n    1. 如果follower节点的commitIndex大于lastApplied 那么就可以将log提交给状态机\n    2. 如果发现有大的term,那么一定要更新RPC中term参数,RPC term  > currentTerm,然后candidate或者leader转变为follower\n    3. Follower收不到心跳就进行选举\n    4. Follower负责响应candidate和leader,言外之意就是处理requestVote RPC和AppendEntry RPC\n    5. Candadite会增加自己的term,给自己投票，重置选举超时时间，发送requestVote RPC,得到多数投票就变成leader\n    6. Candidate收到其他的AppendEntry的RPC就变成follower\n    7. Candidate在选举超时时间内没有完成选举就重新再来一轮\n    8. Leader在位时会不间断的发送心跳抑制Follower选举\n    9. Leader接收来自client的命令，然后走共识层进行\n    10. Leader的logIndex大于nextIndex就开始进行发送AppendEntry的RPC,如果匹配成功就更新Leader的matchIndex和nextIndex,如果没成功就增加nextIndex然后重试\n    11. 如果存在一个整数N>commitIndex,然后大部分matchIndex[i]>=N，那么log[N]==currentTerm，然后将Leader设置commitIndex=N\n\n## 5.1 raft基础\n\n1. 五台服务器是一个典型的最小集群，它最多允许两台服务器宕机，并且每台服务器有三种状态分别是`leader`,`candidate`,`follower`,follower是被动的不发送任何的请求(RPC),只是简单的回leader和candidate的请求，如果follower接收到来自client的请求，也要路由给leader。Figure 4描述了三种状态的转换关系和条件\n2. raft主要将时间定义为任意长度的term,是连续且单调递增的,在某些情况下,会出现多个candidate同时竞选leader的情况，这时候或会出现`瓜分投票`的情况，这是整个raft系统就无法继续前进通过引入随机选举超时解决这个问题，如果一个follower没有在选举超时实践之内接收到leader的heartbeat就会开始选举\n3. 不同的服务器可能在不同的时间观察到term之间的转换。而在某些情况下，一个服务器\n可能观察不到一次选举，甚至是整个任期(candidate在一个term时间内无法完成选举)，term在Raft中充当逻辑时钟[14]，它们允许服务器检测过时的信息，如过时的leader。每个服务器存储一个当前的currentTerm，该currentTerm随着时间的推移单调地随时间增加。每当服务器进行通信时，就会交换currentTerm。如果一个服务器的currentTerm小于另一个服务器的currentTerm，那么它就会更新自己的currentTerm，那么它就将其currentTerm更新为较大的值。如果一个candidate或leader发现它的currenTerm已经过时，它就会变成follower。如果follower收到一个过时的term的请求，它将拒绝该请求。\n![feature 6](./../../picture/mit6.824/raft_figure_6.png)\n\n## 5.2  Leader election\n\n1. Raft使用心跳机制来触发领导者选举。当服务器启动时，它们开始作为跟随者。A 服务器只要收到有效的RPC从leader或者候选人,领导者定期发送 心跳（AppendEntries RPCs，不携带任何日志条目）。到所有追随者，以维持他们的权威。 如果一个 跟随者在一段时间内没有收到通信，称为选举超时。称为选举超时，那么它就认为没有可行的领导者，并开始选举，想成为一个新的领导者。\n\n2. 在开始选举，candidate递增其当前term并过渡到候选状态。然后,它为自己投票 并向集群中的每个服务器发出RequestVote RPCs。candidate继续处于 这个状态，直到发生以下三种情况之一: (a) 它赢得选举. (b) 另一个服务器确立了自己的领导地位，或者 (c) 一段时间内没有赢家。这些结果将在下面的段落中分别讨论\n\n3. 如果一个候选人在选举中获得了来自整个集群中大多数服务器的投票，那么它就赢得了的大多数服务器的投票选举。每台服务器在给定的任期内最多只能为一名候选人投票。以先来后到为原则（注意:第[5.4安全性](#54-安全性) 节对投票增加了一个额外的限制）。多数规则确保最多只有一名candidate能在某届选举中获胜（选举）。一旦一个candidate在选举中获胜，他就成为leader。然后它将心跳信息发送给所有的其他服务器，以建立其权威并防止新的选举。\n\n4. 在等待投票的过程中，候选人可能会收到一个来自另一个leader的AppendEntries RPC，该RPC来自另一服务器，声称自己是leader。如果leader的任期(包括在其RPC中)至少是与Candidate的当前任期一样大,那么candidate承认该leader是合法的，并返回到Follower状态。如果RPC中的term小于candidate的term,那么Candidate就拒绝RPC(被拒绝的RPC变成follower)，继续处于候选状态。\n\n5. 第三个可能的结果是，一个candidate既没有赢得选举，也没有失去选举：如果许多Follower同时成为候选人，选票可能被分割，因此没有候选人获得多数。当这种情况发生时，每个candidate都会超时，并通过增加其任期和启动新一轮的RequestVote RPC来开始新的选举。然而，如果没有额外的措施，分裂的投票 可以无限期地重复.(使用随即超时时间来解决follower同时变成candidate,也防止了candidate同时请求投票投票窘境)\n\n6. Raft使用随机的选举超时来确保分歧票的情况很少出现，而且能迅速解决。为了从一开始就防止分裂投票，从一个固定的时间间隔中随机选择选举超时（例如，150-300ms）。因此在大多数情况下,在分散服务器中，只有一个服务器会超时。它赢得了选举，并在其他服务器超时之前发送了在其他服务器超时前发送心跳。同样的机制被用来处理`分裂的投票`。每个candidate在选举开始时重新启动其随机的`选举超时`。并等待该超时过后再开始下一次选举。这减少了在新的选举中出现新的选举再次出现分裂票的可能性。第9.3节显示这种方法可以迅速选出一个领导者\n\n7. 选举是一个例子，说明可理解性如何指导我们对设计方案的选择。最初我们计划使用一个排名系统:每个candidate被分配一个独特的排名，用来在竞争的candidate之间进行选择。如果一个candidate发现了另一个排名更高的candidate，它就会回到follower的状态，这样排名更高的候选人就能更容易地赢得下一次选举。我们发现，这种方法在可用性方面产生了一些微妙的问题(一个排名较低的服务器可能需要超时，并成为一个新的服务器）。如果一个排名较高的服务器失败了，一个排名较低的服务器可能需要超时并再次成为候选人，但如果它过早地这样做，它可能会重置选举领导者的进展)。我们对算法进行了多次调整，但每次调整后都会出现新的corner cases。最终我们得出结论，随机重试的方法更加明显和容易理解。\n\n## 5.3 Log replication\n\n1. 一旦一个领导者被选出，它就开始为客户端请求。每个客户请求都包含一个命令，由复制的状态机执行。leader将该命令作为一个新条目附加到它的日志中，然后向其他每个服务器并行地发出AppendEntries RPCs来复制该条目。当该条目已经被安全复制后（如下所述），leader将该条目应用于其状态机并返回，并将执行的结果返回给客户端。如果跟随者崩溃或运行缓慢。或者网络数据包丢失，领导者会无限期地重试AppendEntries RPCs甚至在它已经响应了直到所有跟随者最终存储了所有的日志条目。\n\n2. 日志的组织方式如图figure 6所示。每个日志条目都存储了一条状态机命令，以及领导者收到该条目时的term编号。日志条目中的term被用来检测日志之间的不一致，并确保图figure 3中的一些属性。每个日志条目也有一个整数索引，用来识别它在日志中的位置\n\n3. leader决定何时将日志条目应用于状态机是安全的；这样的条目被称为`commited`。Raft保证所提交的logEntry是持久的并且最终会被所有可用的状态机执行。一旦创建日志条目的leader创建该条目的领导者将其复制到大多数的服务器上(例如，图6中的第7条)，包括之前leader创建的logEntry包括由以前的领导者创建的条目。第[5.4节](#54-安全性)它还表明，这种`commited`的定义是安全。领导者跟踪它所知道的最高`commited`的最高索引，并将该索引包括在未来的 AppendEntries RPCs（包括心跳）中，以便其他服务器最终发现。其他服务器最终会发现。一旦一个跟随者知道 一旦跟随者得知一个日志条目被提交，它就会将该条目应用到其本地状态机（按日志顺序).\n\n4. 我们设计的Raft日志机制在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更具可预测性，而且是确保安全的重要组成部分。Raft维护以下属性，它们共同构成了日志匹配属性在figure 3中.\n\n- 如果不同服务器日志中的两个条目具有相同的索引和term，那么它们存储的是同一个命令。\n- 如果不同服务器日志中的两个条目具有相同的索引和term，那么这些日志在所有前面的条目相同。\n\n1. 第一个属性：一个leader在一个给定的term中最多创建一个具有给定日志索引的logEntry，而logEntry永远不会改变它们在日志中的位置。第二个属性由AppendEntries执行的简单一致性检查来保证。当发送一个AppendEntries RPC时，leader在其日志中包括条目的索引以及紧接在其日志中的条目的索引和term。如果follower在其日志中没有找到具有相同索引和术语的条目它的日志中没有找到具有相同索引和term的条目，那么它就会拒绝这些logEntry。一致性检查充当了一个归纳步骤：日志的初始空状态满足了日志的匹配属性，而一致性检查则保留了只要日志被扩展，一致性检查就会保留日志匹配属性。因此，只要AppendEntries成功返回。领导者知道跟随者的logEntry与它的自己的logEntry相同的,直到新的条目。\n\n2. 在正常运行期间，领导者和跟随者的日志保持一致，因此AppendEntries一致性检查不会失败。然而，leader崩溃会使日志不一致（老leader可能没有完全复制其日志中的所有条目）。这些不一致会在一系列的领导者和追随者崩溃中加剧。figure 7说明了追随者的日志可能与新领导者的日志不同的方式。跟随者可能会缺少领导者的条目，可能会有领导者没有的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个term。\n\n3. 在Raft中，领导者通过强迫跟随者重复自己的日志来处理不一致的问题。跟随者的日志与自己的日志重复。这意味着 跟随者日志中的冲突条目将被领导者日志中的条目覆盖。第5.4节将表明这就是安全的 如果再加上一个限制。\n\n4. 为了使追随者的日志与自己的日志保持一致，领导者必须找到两个日志一致的最新日志条目，删除追随者日志中此后的所有条目，并向追随者发送此后领导者的所有条目。所有这些动作都是为了响应AppendEntries RPCs所进行的一致性检查而发生的。leader为每个follower维护一个nextIndex，它是领导将发送给该跟随者的下一个日志条目的索引。当一个领导者第一次上台时。它将所有的`nextIndex`值初始化为其日志中最后一条的索引（feature 7中的11）。如果跟随者的日志与领导者的日志不一致，在下一个AppendEntries RPC中，AppendEntries一致性检查将失败。在拒绝之后，领导者会减少`nextIndex`并重试 AppendEntries RPC。最终，`nextIndex`将达到 一个领导者和追随者日志匹配的点。当这种情况发生时，AppendEntries就会成功，这就删除了移除跟随者日志中任何冲突的条目，并从领导者日志中添加 从领导者的日志中添加条目（如果有的话）。一旦AppendEntries 成功后，跟随者的日志就与领导者的一致了。并且在余下的时间里保持这种状态。\n\n5. 如果需要，该协议可以被优化以减少被拒绝的AppendEntries RPC的数量。例如，当拒绝一个AppendEntries请求时，跟随者包括冲突条目的term和它为该term存储的第一个索引。有了这些信息，领导者可以递减 `nextIndex`以绕过该term中的所有冲突条目；每个有冲突条目的term将需要一个AppendEntries RPC而不是每个logEntry的RPC。在实践中，我们怀疑这种优化是否有必要，因为故障发生的频率很低而且不太可能有很多不一致的条目。\n6. 有了这种机制，领导者不需要采取任何特别的行动来恢复日志的一致性。它只是开始正常运行，而日志会自动收敛，以应Append-Entries一致性检查的失败。一个领导者从不覆盖或删除自己日志中的条目（figure 3中的 仅领导者append logEntry属性）。\n\n7. 这种日志复制机制表现出了第2节中所描述的理想的共识属性：只要大多数服务器都在运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目可以通过单轮RPCs复制到集群的大部分；而且一个缓慢的跟随者也不会影响性能。\n\n## 5.4 安全性\n\n目前来说已经说明raft是如何选举和复制日志的，但是这并不能保证不同的状态机执行不同的log，还是会因为follower进入不可用状态然后恢复活性并竞选为leader，这时候leader的日志就会不一致\n\n### 5.4.1 选举限制\n\nVSR算法一开始日志不全的情况下成为leader，然后当某台服务器成为leader之后会额外的同步这些未同步的日志，而raft则会检查candidate和follower的日志，因为如果集群保证半数node提交日志，那么就会有半数服务器是拥有最新的日志的，两份日志，任期号大的比较新，任期号相同，索引大的比较新\n\n### 5.4.2 提交之前任期内的日志条目\n\n熟读figure 8 的图，为了消除figure 8的情况，raft不会通过计算副本数量来提交日志，只有当前任期的日志会通过计算副本数量来进行提交日志，而raft使用了一种更加保守办法，为每个logEntry都保留任期号，想提交之前日志，leader必须使用当前任期号，与其他算法相比，raft只需要发送更少的日志条目\n\n","source":"_posts/MIT6.824/lab2_raft_paper.md","raw":"---\ntitle: MIT6.824之lab2_raft_paper\ncategories:\n- 分布式\n- MIT6.824\n---\n\n\n# 一.可理解的一致性算法研究-论文\n\n# 摘要\n\n- raft比paxos更容易理解,在构建大型系统的时候方便实现\n\n# 1 介绍\n\n1. 什么叫一致性算法，一致性算法就是协调多台机器有序工作，允许成员失败\n2. 天下苦paxos久矣，需要个更简单理解和实现的一致性算法，方便程序员理解什么是一致性算法\n3. raft将问题分解，减少raft不确定性，在实际的教学当中，raft要比paxos容易理解\n4. raft与Oki，VSR很像，但有如下新特性\n    - 强leader ： 日志只从领导流向follower\n    - leader选举 ： raft使用随机定时器来选举领导人。\n    - 成员变更 ： raft使用了一种新的`联合共识`的方法，多数两种不同的配置在转换过程中重叠在一起\n5. 使劲吹raft多么多么牛逼，算法性能与其他一致性算法差不多，本文的其余部分介绍了复制的状态机问题（第2节），讨论了Paxos的优点和缺点（第3节），描述了我们对可理解性的一般方法（第4节），提出了Raft共识算法（第5-8节），评估了Paxos，Raft共识算法（第5-8节），评估了Raft（第9节），并讨论了相关工作（第10节）。\n\n# 2. 复制状态机\n\n1. 共识通常出现在状态机背景下，冗余状态机通常被用来解决分布式系统中的容错问题，例如，诸如GFS [8], HDFS [38],和RAM云[33]通常使用一个状态机管理leader选举，存储相关重要的配置信息复制状态机的例子包括Chubby[2] 和 ZooKeeper [11]\n\n    ![raft_figure_1](./../../picture/mit6.824/raft_figure_1.png)\n\n2. 因为两台状态机按顺序执行相同的`日志`x=1.y=3等等,那么这两个状态机计算的状态和输出的结果也是一样的，所以共识算法要保证日志的一致性是非常重要的工作。即使一些状态机因为机械故障导致宕机(少于raft规定的数量)，但是这些服务器看起来还是像一个整体一样对外提供服务。\n    - 它们确保在所有非拜占庭条件下的安全性（永远不会返回错误的结果），包括网络延迟、分区、以及数据包丢失、重复和重新排序\n    - 只要有任何一台服务器在运行，它们就能完全发挥可用作用。大部分的服务器都在运行，并能与其他服务器和客户进行通信。彼此之间以及与客户端之间进行通信因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器的故障,假设服务器的故障是通过停止；它们后来可能从稳定的存储中恢复状态并重新加入集群。\n    - 它们并不依赖时间来确保日志的一致性：时钟故障和极端的消息延迟在最坏的情况下会导致可用性问题。延迟，在最坏的情况下，会导致可用性问题。\n    - 在通常情况下，只要集群中的大多数follower响应了命令，命令就以完成。一旦集群中的大多数follower对单轮RPC作出反应，一个命令就已经完成。少数缓慢的务器不影响整个系统的性能。\n\n    总结 : 第二节主要是引入状态机的太粘，并给出raft与状态机交互的大致流程\n\n# 3 Paxos怎么了？\n\n1. Leslie Lamport创造了paxos共识算法，paxos被证明是安全的(能够达到一致)，有效的。但是paxos有两个明显的缺点(ps:什么是多paxos,single-decree子集)\n    - paxos非常难以理解，专业人士也很难理解全面，Paxos的不透明性来自于它选择了(单法令)子集作为其基础\n    - 构建实际系统时候也很难去实现，并验证，，Paxos使用的是对称的对等方法为核心（尽管它最终建议采用一种弱的领导形式作为性能优化）。这在简化问题上是有意义的.但很少有实际的系统使用这种方法\n\n2. 构建一个paxos为基础的分布式系统很难，理解paxos算法也很难(ps:下面引用来自于Chubby系统的总结)。所以作者认为paxos没有为构建一个分布式系统提供一个很好的基础，所以作者提出了新的一致性算法 -- 容易理解，对构建大型分布式系统也有帮助。在设计raft算法的时候，作者使用问题分解方法，将问题分解为，选举，日志复制，安全和成员变更等主要子问题。\n    > Paxos算法的描述与现实世界的需求之间存在着巨大的差距。最终的系统将基于一个未经证实的协议[4]。\n3. 第二个简化的地方是简化了状态空间，使系统连贯，作者努力消除不确定性，日志不允许有洞，并且Raft限制了日志可能变得彼此不一致的方式，但在某些情况下，不确定性实际上提高了可理解性。特别是，随机化方法引入了不确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (\"选择什么,这并不重要\")。我们使用随机化来简化Raft领袖选举算法\n\n总结 : 第三节只是阐述了paxos的`问题`,比如难理解，很难实现在构建大型系统的。\n\n# 4. 设计的可理解性\n1. 在设计raft之初就设置了如下目标\n    - 提供正确的理论基础，方便理解\n    - 减少开发时间，并易于扩展\n    - 在斟酌备选方案时，主要是从可理解性，会不会raft(状态空间，系统)变得复杂，但是这种分析是很主观的(想想作者与我们的硬实力差距)，所以作者选择了两种研究方式。\n        - 问题分解，将共识分解为独立的子问题，分别为选举，日志复制，安全和成员变成。\n        - 减少状态空间(只有leader,candidate,follower,以及优化提到的prevote/vote/appendentry),不允许日志有漏洞(index1和3之间是空的日志)，raft通过冲突检测来矫正不一致情况。随机化的方法引入了非确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (\"选择什么；这并不重要\")。我们使用随机化 来简化Raft领袖选举算法\n\n# 5. raft一致性算法\n\n1. leader接受来自客户端的日志条目，将其复制到其他服务器上，并告诉服务器何时可以将日志条目应用到他们的状态机上。有一个领导者可以简化对复制日志的管理。例如只允许数据从领导者流向其他服务器。一个领导者可能失败或与其他服务器断开连接，在这种情况下 选举一个新的领导者\n\n![raft_figure_2](./../../picture/mit6.824/raft_figure_2.png)\n考虑到领导者的方法，Raft将共识问题分解为三个相对独立的子问题，这将在后面的小节中讨论.\n\n- leader选举 : 现任领导人失败,必须选择新的领导人\n- Log replication : 领导者必须接受日志条目从client,并在整个集群中复制它们。迫使其他日志与自己的日志一致（第5.3节）。\n- Safety : Raft的关键安全属性是图中的状态机安全属性。图3中的状态机安全属性：如果任何服务器 在其状态机上应用了一个特定的日志条目。 那么其他服务器就不能对相同的日志索引应用不同命令 对相同的日志索引应用不同的命令。第5.4节描述了如何Raft如何确保这一特性；该解决方案涉及到一个 第5.2节中描述的选举机制的额外限制。\n\n![raft_figure_3](./../../picture/mit6.824/raft_figure_3.png)\n\n- Election Safety: 一届任期内最多可以选出一位领导人\n- Leader Append-Only : 领导者从不覆盖或删除其日志中的的条目；它只添加新的条目\n- Log Matching : 如果两个日志包含一个具有相同的索引和术语，那么这两份日志的所有条目都是相同的。直到给定的索引为止\n- Leader Completeness : 如果在一个给定的term中提交了一个日志条目，那么该日志将出现在所有更高编号的术语的领导人的日志中。\n- State Machine Safety : 如果一个服务器在它的状态机上应用了一个日志条目 在它的状态机中应用了一个给定的索引，那么其他服务器将永远不会在同一索引应用不同的日志条目.\n- Raft保证这些属性中的每一个都是真的,在任何时候都是真实的。节号表示每个属性的讨论位置。\n\n![raft_figure_3](./../../picture/mit6.824/raft_figure_4_5.png)\n\n总结\n\n1. 所有节点都需要持久化的参数\n    - `currentTerm`持久化参数，第一次初始化为0然后单调递增\n    - `voteFor`当前term记录投票的candidateId\n    - `commitIndex`记录当前节点可以提交的日志index\n    - `lastApplied`记录当前节点可以提交给上层状态机的index\n    - `nextIndex[]`当leader被选出时需要初始化的参数，且是leader最新log+1的位置\n    - `matchIndex[]`初始化为0，表示leader与follower匹配的日志位置\n2. reqeustVote RPC细节\n    1. requestVote的请求参数\n        - `term`请求的term\n        - `candidateId`\n        - `lastLogIndex`candidate最新的log\n        - `lastLogTerm`candidate最新的term\n    2. reqeustVote response参数\n        - `term`投票时候的term\n        - `voteGranted`布尔类型，true说明follower同意投票\n    3. 重要交互逻辑\n        - 如果rpc的term小于follower的current term，follower拒绝投票\n        - 如果voteFor是空或者为candaditeID,并且candaidate的log至少与follower是一样，也可以比Follower多，新\n3. AppendEntry RPC细节\n    1. AppendEntry请求参数\n        - `term`post RPC时的term\n        - `leaderID`\n        - `preLogIndex`leader进行一致性检测日志的index\n        - `preLogTerm`leader进行一致性检测时日志的term\n        - `entries`搬运的日志\n        - `leaderCommit`leader的commitIndex\n    2. AppendEntry的response参数\n        - `term`RPC的当前term\n        - `success`布尔类型返回true说明preLogIndex和preLogTerm是匹配的\n    3. AppendEntry RPC的实现\n        - rpc's term小于follower's的term则返回false\n        - 如果preLogIndex，preLogTerm不匹配返回false\n        - preLogIndex匹配但是preLogTerm不匹配则删掉后面所有的存在的log\n        - append新log\n        - leaderCommit大于follower的commitIndex时候要把follower的commitIndex设置为min(leaderCommit,len(logs))\n4. 提交给状态机的规则\n    1. 如果follower节点的commitIndex大于lastApplied 那么就可以将log提交给状态机\n    2. 如果发现有大的term,那么一定要更新RPC中term参数,RPC term  > currentTerm,然后candidate或者leader转变为follower\n    3. Follower收不到心跳就进行选举\n    4. Follower负责响应candidate和leader,言外之意就是处理requestVote RPC和AppendEntry RPC\n    5. Candadite会增加自己的term,给自己投票，重置选举超时时间，发送requestVote RPC,得到多数投票就变成leader\n    6. Candidate收到其他的AppendEntry的RPC就变成follower\n    7. Candidate在选举超时时间内没有完成选举就重新再来一轮\n    8. Leader在位时会不间断的发送心跳抑制Follower选举\n    9. Leader接收来自client的命令，然后走共识层进行\n    10. Leader的logIndex大于nextIndex就开始进行发送AppendEntry的RPC,如果匹配成功就更新Leader的matchIndex和nextIndex,如果没成功就增加nextIndex然后重试\n    11. 如果存在一个整数N>commitIndex,然后大部分matchIndex[i]>=N，那么log[N]==currentTerm，然后将Leader设置commitIndex=N\n\n## 5.1 raft基础\n\n1. 五台服务器是一个典型的最小集群，它最多允许两台服务器宕机，并且每台服务器有三种状态分别是`leader`,`candidate`,`follower`,follower是被动的不发送任何的请求(RPC),只是简单的回leader和candidate的请求，如果follower接收到来自client的请求，也要路由给leader。Figure 4描述了三种状态的转换关系和条件\n2. raft主要将时间定义为任意长度的term,是连续且单调递增的,在某些情况下,会出现多个candidate同时竞选leader的情况，这时候或会出现`瓜分投票`的情况，这是整个raft系统就无法继续前进通过引入随机选举超时解决这个问题，如果一个follower没有在选举超时实践之内接收到leader的heartbeat就会开始选举\n3. 不同的服务器可能在不同的时间观察到term之间的转换。而在某些情况下，一个服务器\n可能观察不到一次选举，甚至是整个任期(candidate在一个term时间内无法完成选举)，term在Raft中充当逻辑时钟[14]，它们允许服务器检测过时的信息，如过时的leader。每个服务器存储一个当前的currentTerm，该currentTerm随着时间的推移单调地随时间增加。每当服务器进行通信时，就会交换currentTerm。如果一个服务器的currentTerm小于另一个服务器的currentTerm，那么它就会更新自己的currentTerm，那么它就将其currentTerm更新为较大的值。如果一个candidate或leader发现它的currenTerm已经过时，它就会变成follower。如果follower收到一个过时的term的请求，它将拒绝该请求。\n![feature 6](./../../picture/mit6.824/raft_figure_6.png)\n\n## 5.2  Leader election\n\n1. Raft使用心跳机制来触发领导者选举。当服务器启动时，它们开始作为跟随者。A 服务器只要收到有效的RPC从leader或者候选人,领导者定期发送 心跳（AppendEntries RPCs，不携带任何日志条目）。到所有追随者，以维持他们的权威。 如果一个 跟随者在一段时间内没有收到通信，称为选举超时。称为选举超时，那么它就认为没有可行的领导者，并开始选举，想成为一个新的领导者。\n\n2. 在开始选举，candidate递增其当前term并过渡到候选状态。然后,它为自己投票 并向集群中的每个服务器发出RequestVote RPCs。candidate继续处于 这个状态，直到发生以下三种情况之一: (a) 它赢得选举. (b) 另一个服务器确立了自己的领导地位，或者 (c) 一段时间内没有赢家。这些结果将在下面的段落中分别讨论\n\n3. 如果一个候选人在选举中获得了来自整个集群中大多数服务器的投票，那么它就赢得了的大多数服务器的投票选举。每台服务器在给定的任期内最多只能为一名候选人投票。以先来后到为原则（注意:第[5.4安全性](#54-安全性) 节对投票增加了一个额外的限制）。多数规则确保最多只有一名candidate能在某届选举中获胜（选举）。一旦一个candidate在选举中获胜，他就成为leader。然后它将心跳信息发送给所有的其他服务器，以建立其权威并防止新的选举。\n\n4. 在等待投票的过程中，候选人可能会收到一个来自另一个leader的AppendEntries RPC，该RPC来自另一服务器，声称自己是leader。如果leader的任期(包括在其RPC中)至少是与Candidate的当前任期一样大,那么candidate承认该leader是合法的，并返回到Follower状态。如果RPC中的term小于candidate的term,那么Candidate就拒绝RPC(被拒绝的RPC变成follower)，继续处于候选状态。\n\n5. 第三个可能的结果是，一个candidate既没有赢得选举，也没有失去选举：如果许多Follower同时成为候选人，选票可能被分割，因此没有候选人获得多数。当这种情况发生时，每个candidate都会超时，并通过增加其任期和启动新一轮的RequestVote RPC来开始新的选举。然而，如果没有额外的措施，分裂的投票 可以无限期地重复.(使用随即超时时间来解决follower同时变成candidate,也防止了candidate同时请求投票投票窘境)\n\n6. Raft使用随机的选举超时来确保分歧票的情况很少出现，而且能迅速解决。为了从一开始就防止分裂投票，从一个固定的时间间隔中随机选择选举超时（例如，150-300ms）。因此在大多数情况下,在分散服务器中，只有一个服务器会超时。它赢得了选举，并在其他服务器超时之前发送了在其他服务器超时前发送心跳。同样的机制被用来处理`分裂的投票`。每个candidate在选举开始时重新启动其随机的`选举超时`。并等待该超时过后再开始下一次选举。这减少了在新的选举中出现新的选举再次出现分裂票的可能性。第9.3节显示这种方法可以迅速选出一个领导者\n\n7. 选举是一个例子，说明可理解性如何指导我们对设计方案的选择。最初我们计划使用一个排名系统:每个candidate被分配一个独特的排名，用来在竞争的candidate之间进行选择。如果一个candidate发现了另一个排名更高的candidate，它就会回到follower的状态，这样排名更高的候选人就能更容易地赢得下一次选举。我们发现，这种方法在可用性方面产生了一些微妙的问题(一个排名较低的服务器可能需要超时，并成为一个新的服务器）。如果一个排名较高的服务器失败了，一个排名较低的服务器可能需要超时并再次成为候选人，但如果它过早地这样做，它可能会重置选举领导者的进展)。我们对算法进行了多次调整，但每次调整后都会出现新的corner cases。最终我们得出结论，随机重试的方法更加明显和容易理解。\n\n## 5.3 Log replication\n\n1. 一旦一个领导者被选出，它就开始为客户端请求。每个客户请求都包含一个命令，由复制的状态机执行。leader将该命令作为一个新条目附加到它的日志中，然后向其他每个服务器并行地发出AppendEntries RPCs来复制该条目。当该条目已经被安全复制后（如下所述），leader将该条目应用于其状态机并返回，并将执行的结果返回给客户端。如果跟随者崩溃或运行缓慢。或者网络数据包丢失，领导者会无限期地重试AppendEntries RPCs甚至在它已经响应了直到所有跟随者最终存储了所有的日志条目。\n\n2. 日志的组织方式如图figure 6所示。每个日志条目都存储了一条状态机命令，以及领导者收到该条目时的term编号。日志条目中的term被用来检测日志之间的不一致，并确保图figure 3中的一些属性。每个日志条目也有一个整数索引，用来识别它在日志中的位置\n\n3. leader决定何时将日志条目应用于状态机是安全的；这样的条目被称为`commited`。Raft保证所提交的logEntry是持久的并且最终会被所有可用的状态机执行。一旦创建日志条目的leader创建该条目的领导者将其复制到大多数的服务器上(例如，图6中的第7条)，包括之前leader创建的logEntry包括由以前的领导者创建的条目。第[5.4节](#54-安全性)它还表明，这种`commited`的定义是安全。领导者跟踪它所知道的最高`commited`的最高索引，并将该索引包括在未来的 AppendEntries RPCs（包括心跳）中，以便其他服务器最终发现。其他服务器最终会发现。一旦一个跟随者知道 一旦跟随者得知一个日志条目被提交，它就会将该条目应用到其本地状态机（按日志顺序).\n\n4. 我们设计的Raft日志机制在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更具可预测性，而且是确保安全的重要组成部分。Raft维护以下属性，它们共同构成了日志匹配属性在figure 3中.\n\n- 如果不同服务器日志中的两个条目具有相同的索引和term，那么它们存储的是同一个命令。\n- 如果不同服务器日志中的两个条目具有相同的索引和term，那么这些日志在所有前面的条目相同。\n\n1. 第一个属性：一个leader在一个给定的term中最多创建一个具有给定日志索引的logEntry，而logEntry永远不会改变它们在日志中的位置。第二个属性由AppendEntries执行的简单一致性检查来保证。当发送一个AppendEntries RPC时，leader在其日志中包括条目的索引以及紧接在其日志中的条目的索引和term。如果follower在其日志中没有找到具有相同索引和术语的条目它的日志中没有找到具有相同索引和term的条目，那么它就会拒绝这些logEntry。一致性检查充当了一个归纳步骤：日志的初始空状态满足了日志的匹配属性，而一致性检查则保留了只要日志被扩展，一致性检查就会保留日志匹配属性。因此，只要AppendEntries成功返回。领导者知道跟随者的logEntry与它的自己的logEntry相同的,直到新的条目。\n\n2. 在正常运行期间，领导者和跟随者的日志保持一致，因此AppendEntries一致性检查不会失败。然而，leader崩溃会使日志不一致（老leader可能没有完全复制其日志中的所有条目）。这些不一致会在一系列的领导者和追随者崩溃中加剧。figure 7说明了追随者的日志可能与新领导者的日志不同的方式。跟随者可能会缺少领导者的条目，可能会有领导者没有的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个term。\n\n3. 在Raft中，领导者通过强迫跟随者重复自己的日志来处理不一致的问题。跟随者的日志与自己的日志重复。这意味着 跟随者日志中的冲突条目将被领导者日志中的条目覆盖。第5.4节将表明这就是安全的 如果再加上一个限制。\n\n4. 为了使追随者的日志与自己的日志保持一致，领导者必须找到两个日志一致的最新日志条目，删除追随者日志中此后的所有条目，并向追随者发送此后领导者的所有条目。所有这些动作都是为了响应AppendEntries RPCs所进行的一致性检查而发生的。leader为每个follower维护一个nextIndex，它是领导将发送给该跟随者的下一个日志条目的索引。当一个领导者第一次上台时。它将所有的`nextIndex`值初始化为其日志中最后一条的索引（feature 7中的11）。如果跟随者的日志与领导者的日志不一致，在下一个AppendEntries RPC中，AppendEntries一致性检查将失败。在拒绝之后，领导者会减少`nextIndex`并重试 AppendEntries RPC。最终，`nextIndex`将达到 一个领导者和追随者日志匹配的点。当这种情况发生时，AppendEntries就会成功，这就删除了移除跟随者日志中任何冲突的条目，并从领导者日志中添加 从领导者的日志中添加条目（如果有的话）。一旦AppendEntries 成功后，跟随者的日志就与领导者的一致了。并且在余下的时间里保持这种状态。\n\n5. 如果需要，该协议可以被优化以减少被拒绝的AppendEntries RPC的数量。例如，当拒绝一个AppendEntries请求时，跟随者包括冲突条目的term和它为该term存储的第一个索引。有了这些信息，领导者可以递减 `nextIndex`以绕过该term中的所有冲突条目；每个有冲突条目的term将需要一个AppendEntries RPC而不是每个logEntry的RPC。在实践中，我们怀疑这种优化是否有必要，因为故障发生的频率很低而且不太可能有很多不一致的条目。\n6. 有了这种机制，领导者不需要采取任何特别的行动来恢复日志的一致性。它只是开始正常运行，而日志会自动收敛，以应Append-Entries一致性检查的失败。一个领导者从不覆盖或删除自己日志中的条目（figure 3中的 仅领导者append logEntry属性）。\n\n7. 这种日志复制机制表现出了第2节中所描述的理想的共识属性：只要大多数服务器都在运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目可以通过单轮RPCs复制到集群的大部分；而且一个缓慢的跟随者也不会影响性能。\n\n## 5.4 安全性\n\n目前来说已经说明raft是如何选举和复制日志的，但是这并不能保证不同的状态机执行不同的log，还是会因为follower进入不可用状态然后恢复活性并竞选为leader，这时候leader的日志就会不一致\n\n### 5.4.1 选举限制\n\nVSR算法一开始日志不全的情况下成为leader，然后当某台服务器成为leader之后会额外的同步这些未同步的日志，而raft则会检查candidate和follower的日志，因为如果集群保证半数node提交日志，那么就会有半数服务器是拥有最新的日志的，两份日志，任期号大的比较新，任期号相同，索引大的比较新\n\n### 5.4.2 提交之前任期内的日志条目\n\n熟读figure 8 的图，为了消除figure 8的情况，raft不会通过计算副本数量来提交日志，只有当前任期的日志会通过计算副本数量来进行提交日志，而raft使用了一种更加保守办法，为每个logEntry都保留任期号，想提交之前日志，leader必须使用当前任期号，与其他算法相比，raft只需要发送更少的日志条目\n\n","slug":"MIT6.824/lab2_raft_paper","published":1,"date":"2022-08-12T13:57:38.288Z","updated":"2022-10-07T01:25:49.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5l000jl1dbcro83u9l","content":"<h1 id=\"一-可理解的一致性算法研究-论文\"><a href=\"#一-可理解的一致性算法研究-论文\" class=\"headerlink\" title=\"一.可理解的一致性算法研究-论文\"></a>一.可理解的一致性算法研究-论文</h1><h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ul>\n<li>raft比paxos更容易理解,在构建大型系统的时候方便实现</li>\n</ul>\n<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1 介绍\"></a>1 介绍</h1><ol>\n<li>什么叫一致性算法，一致性算法就是协调多台机器有序工作，允许成员失败</li>\n<li>天下苦paxos久矣，需要个更简单理解和实现的一致性算法，方便程序员理解什么是一致性算法</li>\n<li>raft将问题分解，减少raft不确定性，在实际的教学当中，raft要比paxos容易理解</li>\n<li>raft与Oki，VSR很像，但有如下新特性<ul>\n<li>强leader ： 日志只从领导流向follower</li>\n<li>leader选举 ： raft使用随机定时器来选举领导人。</li>\n<li>成员变更 ： raft使用了一种新的<code>联合共识</code>的方法，多数两种不同的配置在转换过程中重叠在一起</li>\n</ul>\n</li>\n<li>使劲吹raft多么多么牛逼，算法性能与其他一致性算法差不多，本文的其余部分介绍了复制的状态机问题（第2节），讨论了Paxos的优点和缺点（第3节），描述了我们对可理解性的一般方法（第4节），提出了Raft共识算法（第5-8节），评估了Paxos，Raft共识算法（第5-8节），评估了Raft（第9节），并讨论了相关工作（第10节）。</li>\n</ol>\n<h1 id=\"2-复制状态机\"><a href=\"#2-复制状态机\" class=\"headerlink\" title=\"2. 复制状态机\"></a>2. 复制状态机</h1><ol>\n<li><p>共识通常出现在状态机背景下，冗余状态机通常被用来解决分布式系统中的容错问题，例如，诸如GFS [8], HDFS [38],和RAM云[33]通常使用一个状态机管理leader选举，存储相关重要的配置信息复制状态机的例子包括Chubby[2] 和 ZooKeeper [11]</p>\n<p> <img src=\"/./../../picture/mit6.824/raft_figure_1.png\" alt=\"raft_figure_1\"></p>\n</li>\n<li><p>因为两台状态机按顺序执行相同的<code>日志</code>x&#x3D;1.y&#x3D;3等等,那么这两个状态机计算的状态和输出的结果也是一样的，所以共识算法要保证日志的一致性是非常重要的工作。即使一些状态机因为机械故障导致宕机(少于raft规定的数量)，但是这些服务器看起来还是像一个整体一样对外提供服务。</p>\n<ul>\n<li>它们确保在所有非拜占庭条件下的安全性（永远不会返回错误的结果），包括网络延迟、分区、以及数据包丢失、重复和重新排序</li>\n<li>只要有任何一台服务器在运行，它们就能完全发挥可用作用。大部分的服务器都在运行，并能与其他服务器和客户进行通信。彼此之间以及与客户端之间进行通信因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器的故障,假设服务器的故障是通过停止；它们后来可能从稳定的存储中恢复状态并重新加入集群。</li>\n<li>它们并不依赖时间来确保日志的一致性：时钟故障和极端的消息延迟在最坏的情况下会导致可用性问题。延迟，在最坏的情况下，会导致可用性问题。</li>\n<li>在通常情况下，只要集群中的大多数follower响应了命令，命令就以完成。一旦集群中的大多数follower对单轮RPC作出反应，一个命令就已经完成。少数缓慢的务器不影响整个系统的性能。</li>\n</ul>\n<p> 总结 : 第二节主要是引入状态机的太粘，并给出raft与状态机交互的大致流程</p>\n</li>\n</ol>\n<h1 id=\"3-Paxos怎么了？\"><a href=\"#3-Paxos怎么了？\" class=\"headerlink\" title=\"3 Paxos怎么了？\"></a>3 Paxos怎么了？</h1><ol>\n<li><p>Leslie Lamport创造了paxos共识算法，paxos被证明是安全的(能够达到一致)，有效的。但是paxos有两个明显的缺点(ps:什么是多paxos,single-decree子集)</p>\n<ul>\n<li>paxos非常难以理解，专业人士也很难理解全面，Paxos的不透明性来自于它选择了(单法令)子集作为其基础</li>\n<li>构建实际系统时候也很难去实现，并验证，，Paxos使用的是对称的对等方法为核心（尽管它最终建议采用一种弱的领导形式作为性能优化）。这在简化问题上是有意义的.但很少有实际的系统使用这种方法</li>\n</ul>\n</li>\n<li><p>构建一个paxos为基础的分布式系统很难，理解paxos算法也很难(ps:下面引用来自于Chubby系统的总结)。所以作者认为paxos没有为构建一个分布式系统提供一个很好的基础，所以作者提出了新的一致性算法 – 容易理解，对构建大型分布式系统也有帮助。在设计raft算法的时候，作者使用问题分解方法，将问题分解为，选举，日志复制，安全和成员变更等主要子问题。</p>\n<blockquote>\n<p>Paxos算法的描述与现实世界的需求之间存在着巨大的差距。最终的系统将基于一个未经证实的协议[4]。</p>\n</blockquote>\n</li>\n<li><p>第二个简化的地方是简化了状态空间，使系统连贯，作者努力消除不确定性，日志不允许有洞，并且Raft限制了日志可能变得彼此不一致的方式，但在某些情况下，不确定性实际上提高了可理解性。特别是，随机化方法引入了不确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (“选择什么,这并不重要”)。我们使用随机化来简化Raft领袖选举算法</p>\n</li>\n</ol>\n<p>总结 : 第三节只是阐述了paxos的<code>问题</code>,比如难理解，很难实现在构建大型系统的。</p>\n<h1 id=\"4-设计的可理解性\"><a href=\"#4-设计的可理解性\" class=\"headerlink\" title=\"4. 设计的可理解性\"></a>4. 设计的可理解性</h1><ol>\n<li>在设计raft之初就设置了如下目标<ul>\n<li>提供正确的理论基础，方便理解</li>\n<li>减少开发时间，并易于扩展</li>\n<li>在斟酌备选方案时，主要是从可理解性，会不会raft(状态空间，系统)变得复杂，但是这种分析是很主观的(想想作者与我们的硬实力差距)，所以作者选择了两种研究方式。<ul>\n<li>问题分解，将共识分解为独立的子问题，分别为选举，日志复制，安全和成员变成。</li>\n<li>减少状态空间(只有leader,candidate,follower,以及优化提到的prevote&#x2F;vote&#x2F;appendentry),不允许日志有漏洞(index1和3之间是空的日志)，raft通过冲突检测来矫正不一致情况。随机化的方法引入了非确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (“选择什么；这并不重要”)。我们使用随机化 来简化Raft领袖选举算法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"5-raft一致性算法\"><a href=\"#5-raft一致性算法\" class=\"headerlink\" title=\"5. raft一致性算法\"></a>5. raft一致性算法</h1><ol>\n<li>leader接受来自客户端的日志条目，将其复制到其他服务器上，并告诉服务器何时可以将日志条目应用到他们的状态机上。有一个领导者可以简化对复制日志的管理。例如只允许数据从领导者流向其他服务器。一个领导者可能失败或与其他服务器断开连接，在这种情况下 选举一个新的领导者</li>\n</ol>\n<p><img src=\"/./../../picture/mit6.824/raft_figure_2.png\" alt=\"raft_figure_2\"><br>考虑到领导者的方法，Raft将共识问题分解为三个相对独立的子问题，这将在后面的小节中讨论.</p>\n<ul>\n<li>leader选举 : 现任领导人失败,必须选择新的领导人</li>\n<li>Log replication : 领导者必须接受日志条目从client,并在整个集群中复制它们。迫使其他日志与自己的日志一致（第5.3节）。</li>\n<li>Safety : Raft的关键安全属性是图中的状态机安全属性。图3中的状态机安全属性：如果任何服务器 在其状态机上应用了一个特定的日志条目。 那么其他服务器就不能对相同的日志索引应用不同命令 对相同的日志索引应用不同的命令。第5.4节描述了如何Raft如何确保这一特性；该解决方案涉及到一个 第5.2节中描述的选举机制的额外限制。</li>\n</ul>\n<p><img src=\"/./../../picture/mit6.824/raft_figure_3.png\" alt=\"raft_figure_3\"></p>\n<ul>\n<li>Election Safety: 一届任期内最多可以选出一位领导人</li>\n<li>Leader Append-Only : 领导者从不覆盖或删除其日志中的的条目；它只添加新的条目</li>\n<li>Log Matching : 如果两个日志包含一个具有相同的索引和术语，那么这两份日志的所有条目都是相同的。直到给定的索引为止</li>\n<li>Leader Completeness : 如果在一个给定的term中提交了一个日志条目，那么该日志将出现在所有更高编号的术语的领导人的日志中。</li>\n<li>State Machine Safety : 如果一个服务器在它的状态机上应用了一个日志条目 在它的状态机中应用了一个给定的索引，那么其他服务器将永远不会在同一索引应用不同的日志条目.</li>\n<li>Raft保证这些属性中的每一个都是真的,在任何时候都是真实的。节号表示每个属性的讨论位置。</li>\n</ul>\n<p><img src=\"/./../../picture/mit6.824/raft_figure_4_5.png\" alt=\"raft_figure_3\"></p>\n<p>总结</p>\n<ol>\n<li>所有节点都需要持久化的参数<ul>\n<li><code>currentTerm</code>持久化参数，第一次初始化为0然后单调递增</li>\n<li><code>voteFor</code>当前term记录投票的candidateId</li>\n<li><code>commitIndex</code>记录当前节点可以提交的日志index</li>\n<li><code>lastApplied</code>记录当前节点可以提交给上层状态机的index</li>\n<li><code>nextIndex[]</code>当leader被选出时需要初始化的参数，且是leader最新log+1的位置</li>\n<li><code>matchIndex[]</code>初始化为0，表示leader与follower匹配的日志位置</li>\n</ul>\n</li>\n<li>reqeustVote RPC细节<ol>\n<li>requestVote的请求参数<ul>\n<li><code>term</code>请求的term</li>\n<li><code>candidateId</code></li>\n<li><code>lastLogIndex</code>candidate最新的log</li>\n<li><code>lastLogTerm</code>candidate最新的term</li>\n</ul>\n</li>\n<li>reqeustVote response参数<ul>\n<li><code>term</code>投票时候的term</li>\n<li><code>voteGranted</code>布尔类型，true说明follower同意投票</li>\n</ul>\n</li>\n<li>重要交互逻辑<ul>\n<li>如果rpc的term小于follower的current term，follower拒绝投票</li>\n<li>如果voteFor是空或者为candaditeID,并且candaidate的log至少与follower是一样，也可以比Follower多，新</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>AppendEntry RPC细节<ol>\n<li>AppendEntry请求参数<ul>\n<li><code>term</code>post RPC时的term</li>\n<li><code>leaderID</code></li>\n<li><code>preLogIndex</code>leader进行一致性检测日志的index</li>\n<li><code>preLogTerm</code>leader进行一致性检测时日志的term</li>\n<li><code>entries</code>搬运的日志</li>\n<li><code>leaderCommit</code>leader的commitIndex</li>\n</ul>\n</li>\n<li>AppendEntry的response参数<ul>\n<li><code>term</code>RPC的当前term</li>\n<li><code>success</code>布尔类型返回true说明preLogIndex和preLogTerm是匹配的</li>\n</ul>\n</li>\n<li>AppendEntry RPC的实现<ul>\n<li>rpc’s term小于follower’s的term则返回false</li>\n<li>如果preLogIndex，preLogTerm不匹配返回false</li>\n<li>preLogIndex匹配但是preLogTerm不匹配则删掉后面所有的存在的log</li>\n<li>append新log</li>\n<li>leaderCommit大于follower的commitIndex时候要把follower的commitIndex设置为min(leaderCommit,len(logs))</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>提交给状态机的规则<ol>\n<li>如果follower节点的commitIndex大于lastApplied 那么就可以将log提交给状态机</li>\n<li>如果发现有大的term,那么一定要更新RPC中term参数,RPC term  &gt; currentTerm,然后candidate或者leader转变为follower</li>\n<li>Follower收不到心跳就进行选举</li>\n<li>Follower负责响应candidate和leader,言外之意就是处理requestVote RPC和AppendEntry RPC</li>\n<li>Candadite会增加自己的term,给自己投票，重置选举超时时间，发送requestVote RPC,得到多数投票就变成leader</li>\n<li>Candidate收到其他的AppendEntry的RPC就变成follower</li>\n<li>Candidate在选举超时时间内没有完成选举就重新再来一轮</li>\n<li>Leader在位时会不间断的发送心跳抑制Follower选举</li>\n<li>Leader接收来自client的命令，然后走共识层进行</li>\n<li>Leader的logIndex大于nextIndex就开始进行发送AppendEntry的RPC,如果匹配成功就更新Leader的matchIndex和nextIndex,如果没成功就增加nextIndex然后重试</li>\n<li>如果存在一个整数N&gt;commitIndex,然后大部分matchIndex[i]&gt;&#x3D;N，那么log[N]&#x3D;&#x3D;currentTerm，然后将Leader设置commitIndex&#x3D;N</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"5-1-raft基础\"><a href=\"#5-1-raft基础\" class=\"headerlink\" title=\"5.1 raft基础\"></a>5.1 raft基础</h2><ol>\n<li>五台服务器是一个典型的最小集群，它最多允许两台服务器宕机，并且每台服务器有三种状态分别是<code>leader</code>,<code>candidate</code>,<code>follower</code>,follower是被动的不发送任何的请求(RPC),只是简单的回leader和candidate的请求，如果follower接收到来自client的请求，也要路由给leader。Figure 4描述了三种状态的转换关系和条件</li>\n<li>raft主要将时间定义为任意长度的term,是连续且单调递增的,在某些情况下,会出现多个candidate同时竞选leader的情况，这时候或会出现<code>瓜分投票</code>的情况，这是整个raft系统就无法继续前进通过引入随机选举超时解决这个问题，如果一个follower没有在选举超时实践之内接收到leader的heartbeat就会开始选举</li>\n<li>不同的服务器可能在不同的时间观察到term之间的转换。而在某些情况下，一个服务器<br>可能观察不到一次选举，甚至是整个任期(candidate在一个term时间内无法完成选举)，term在Raft中充当逻辑时钟[14]，它们允许服务器检测过时的信息，如过时的leader。每个服务器存储一个当前的currentTerm，该currentTerm随着时间的推移单调地随时间增加。每当服务器进行通信时，就会交换currentTerm。如果一个服务器的currentTerm小于另一个服务器的currentTerm，那么它就会更新自己的currentTerm，那么它就将其currentTerm更新为较大的值。如果一个candidate或leader发现它的currenTerm已经过时，它就会变成follower。如果follower收到一个过时的term的请求，它将拒绝该请求。<br><img src=\"/./../../picture/mit6.824/raft_figure_6.png\" alt=\"feature 6\"></li>\n</ol>\n<h2 id=\"5-2-Leader-election\"><a href=\"#5-2-Leader-election\" class=\"headerlink\" title=\"5.2  Leader election\"></a>5.2  Leader election</h2><ol>\n<li><p>Raft使用心跳机制来触发领导者选举。当服务器启动时，它们开始作为跟随者。A 服务器只要收到有效的RPC从leader或者候选人,领导者定期发送 心跳（AppendEntries RPCs，不携带任何日志条目）。到所有追随者，以维持他们的权威。 如果一个 跟随者在一段时间内没有收到通信，称为选举超时。称为选举超时，那么它就认为没有可行的领导者，并开始选举，想成为一个新的领导者。</p>\n</li>\n<li><p>在开始选举，candidate递增其当前term并过渡到候选状态。然后,它为自己投票 并向集群中的每个服务器发出RequestVote RPCs。candidate继续处于 这个状态，直到发生以下三种情况之一: (a) 它赢得选举. (b) 另一个服务器确立了自己的领导地位，或者 (c) 一段时间内没有赢家。这些结果将在下面的段落中分别讨论</p>\n</li>\n<li><p>如果一个候选人在选举中获得了来自整个集群中大多数服务器的投票，那么它就赢得了的大多数服务器的投票选举。每台服务器在给定的任期内最多只能为一名候选人投票。以先来后到为原则（注意:第<a href=\"#54-%E5%AE%89%E5%85%A8%E6%80%A7\">5.4安全性</a> 节对投票增加了一个额外的限制）。多数规则确保最多只有一名candidate能在某届选举中获胜（选举）。一旦一个candidate在选举中获胜，他就成为leader。然后它将心跳信息发送给所有的其他服务器，以建立其权威并防止新的选举。</p>\n</li>\n<li><p>在等待投票的过程中，候选人可能会收到一个来自另一个leader的AppendEntries RPC，该RPC来自另一服务器，声称自己是leader。如果leader的任期(包括在其RPC中)至少是与Candidate的当前任期一样大,那么candidate承认该leader是合法的，并返回到Follower状态。如果RPC中的term小于candidate的term,那么Candidate就拒绝RPC(被拒绝的RPC变成follower)，继续处于候选状态。</p>\n</li>\n<li><p>第三个可能的结果是，一个candidate既没有赢得选举，也没有失去选举：如果许多Follower同时成为候选人，选票可能被分割，因此没有候选人获得多数。当这种情况发生时，每个candidate都会超时，并通过增加其任期和启动新一轮的RequestVote RPC来开始新的选举。然而，如果没有额外的措施，分裂的投票 可以无限期地重复.(使用随即超时时间来解决follower同时变成candidate,也防止了candidate同时请求投票投票窘境)</p>\n</li>\n<li><p>Raft使用随机的选举超时来确保分歧票的情况很少出现，而且能迅速解决。为了从一开始就防止分裂投票，从一个固定的时间间隔中随机选择选举超时（例如，150-300ms）。因此在大多数情况下,在分散服务器中，只有一个服务器会超时。它赢得了选举，并在其他服务器超时之前发送了在其他服务器超时前发送心跳。同样的机制被用来处理<code>分裂的投票</code>。每个candidate在选举开始时重新启动其随机的<code>选举超时</code>。并等待该超时过后再开始下一次选举。这减少了在新的选举中出现新的选举再次出现分裂票的可能性。第9.3节显示这种方法可以迅速选出一个领导者</p>\n</li>\n<li><p>选举是一个例子，说明可理解性如何指导我们对设计方案的选择。最初我们计划使用一个排名系统:每个candidate被分配一个独特的排名，用来在竞争的candidate之间进行选择。如果一个candidate发现了另一个排名更高的candidate，它就会回到follower的状态，这样排名更高的候选人就能更容易地赢得下一次选举。我们发现，这种方法在可用性方面产生了一些微妙的问题(一个排名较低的服务器可能需要超时，并成为一个新的服务器）。如果一个排名较高的服务器失败了，一个排名较低的服务器可能需要超时并再次成为候选人，但如果它过早地这样做，它可能会重置选举领导者的进展)。我们对算法进行了多次调整，但每次调整后都会出现新的corner cases。最终我们得出结论，随机重试的方法更加明显和容易理解。</p>\n</li>\n</ol>\n<h2 id=\"5-3-Log-replication\"><a href=\"#5-3-Log-replication\" class=\"headerlink\" title=\"5.3 Log replication\"></a>5.3 Log replication</h2><ol>\n<li><p>一旦一个领导者被选出，它就开始为客户端请求。每个客户请求都包含一个命令，由复制的状态机执行。leader将该命令作为一个新条目附加到它的日志中，然后向其他每个服务器并行地发出AppendEntries RPCs来复制该条目。当该条目已经被安全复制后（如下所述），leader将该条目应用于其状态机并返回，并将执行的结果返回给客户端。如果跟随者崩溃或运行缓慢。或者网络数据包丢失，领导者会无限期地重试AppendEntries RPCs甚至在它已经响应了直到所有跟随者最终存储了所有的日志条目。</p>\n</li>\n<li><p>日志的组织方式如图figure 6所示。每个日志条目都存储了一条状态机命令，以及领导者收到该条目时的term编号。日志条目中的term被用来检测日志之间的不一致，并确保图figure 3中的一些属性。每个日志条目也有一个整数索引，用来识别它在日志中的位置</p>\n</li>\n<li><p>leader决定何时将日志条目应用于状态机是安全的；这样的条目被称为<code>commited</code>。Raft保证所提交的logEntry是持久的并且最终会被所有可用的状态机执行。一旦创建日志条目的leader创建该条目的领导者将其复制到大多数的服务器上(例如，图6中的第7条)，包括之前leader创建的logEntry包括由以前的领导者创建的条目。第<a href=\"#54-%E5%AE%89%E5%85%A8%E6%80%A7\">5.4节</a>它还表明，这种<code>commited</code>的定义是安全。领导者跟踪它所知道的最高<code>commited</code>的最高索引，并将该索引包括在未来的 AppendEntries RPCs（包括心跳）中，以便其他服务器最终发现。其他服务器最终会发现。一旦一个跟随者知道 一旦跟随者得知一个日志条目被提交，它就会将该条目应用到其本地状态机（按日志顺序).</p>\n</li>\n<li><p>我们设计的Raft日志机制在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更具可预测性，而且是确保安全的重要组成部分。Raft维护以下属性，它们共同构成了日志匹配属性在figure 3中.</p>\n</li>\n</ol>\n<ul>\n<li>如果不同服务器日志中的两个条目具有相同的索引和term，那么它们存储的是同一个命令。</li>\n<li>如果不同服务器日志中的两个条目具有相同的索引和term，那么这些日志在所有前面的条目相同。</li>\n</ul>\n<ol>\n<li><p>第一个属性：一个leader在一个给定的term中最多创建一个具有给定日志索引的logEntry，而logEntry永远不会改变它们在日志中的位置。第二个属性由AppendEntries执行的简单一致性检查来保证。当发送一个AppendEntries RPC时，leader在其日志中包括条目的索引以及紧接在其日志中的条目的索引和term。如果follower在其日志中没有找到具有相同索引和术语的条目它的日志中没有找到具有相同索引和term的条目，那么它就会拒绝这些logEntry。一致性检查充当了一个归纳步骤：日志的初始空状态满足了日志的匹配属性，而一致性检查则保留了只要日志被扩展，一致性检查就会保留日志匹配属性。因此，只要AppendEntries成功返回。领导者知道跟随者的logEntry与它的自己的logEntry相同的,直到新的条目。</p>\n</li>\n<li><p>在正常运行期间，领导者和跟随者的日志保持一致，因此AppendEntries一致性检查不会失败。然而，leader崩溃会使日志不一致（老leader可能没有完全复制其日志中的所有条目）。这些不一致会在一系列的领导者和追随者崩溃中加剧。figure 7说明了追随者的日志可能与新领导者的日志不同的方式。跟随者可能会缺少领导者的条目，可能会有领导者没有的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个term。</p>\n</li>\n<li><p>在Raft中，领导者通过强迫跟随者重复自己的日志来处理不一致的问题。跟随者的日志与自己的日志重复。这意味着 跟随者日志中的冲突条目将被领导者日志中的条目覆盖。第5.4节将表明这就是安全的 如果再加上一个限制。</p>\n</li>\n<li><p>为了使追随者的日志与自己的日志保持一致，领导者必须找到两个日志一致的最新日志条目，删除追随者日志中此后的所有条目，并向追随者发送此后领导者的所有条目。所有这些动作都是为了响应AppendEntries RPCs所进行的一致性检查而发生的。leader为每个follower维护一个nextIndex，它是领导将发送给该跟随者的下一个日志条目的索引。当一个领导者第一次上台时。它将所有的<code>nextIndex</code>值初始化为其日志中最后一条的索引（feature 7中的11）。如果跟随者的日志与领导者的日志不一致，在下一个AppendEntries RPC中，AppendEntries一致性检查将失败。在拒绝之后，领导者会减少<code>nextIndex</code>并重试 AppendEntries RPC。最终，<code>nextIndex</code>将达到 一个领导者和追随者日志匹配的点。当这种情况发生时，AppendEntries就会成功，这就删除了移除跟随者日志中任何冲突的条目，并从领导者日志中添加 从领导者的日志中添加条目（如果有的话）。一旦AppendEntries 成功后，跟随者的日志就与领导者的一致了。并且在余下的时间里保持这种状态。</p>\n</li>\n<li><p>如果需要，该协议可以被优化以减少被拒绝的AppendEntries RPC的数量。例如，当拒绝一个AppendEntries请求时，跟随者包括冲突条目的term和它为该term存储的第一个索引。有了这些信息，领导者可以递减 <code>nextIndex</code>以绕过该term中的所有冲突条目；每个有冲突条目的term将需要一个AppendEntries RPC而不是每个logEntry的RPC。在实践中，我们怀疑这种优化是否有必要，因为故障发生的频率很低而且不太可能有很多不一致的条目。</p>\n</li>\n<li><p>有了这种机制，领导者不需要采取任何特别的行动来恢复日志的一致性。它只是开始正常运行，而日志会自动收敛，以应Append-Entries一致性检查的失败。一个领导者从不覆盖或删除自己日志中的条目（figure 3中的 仅领导者append logEntry属性）。</p>\n</li>\n<li><p>这种日志复制机制表现出了第2节中所描述的理想的共识属性：只要大多数服务器都在运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目可以通过单轮RPCs复制到集群的大部分；而且一个缓慢的跟随者也不会影响性能。</p>\n</li>\n</ol>\n<h2 id=\"5-4-安全性\"><a href=\"#5-4-安全性\" class=\"headerlink\" title=\"5.4 安全性\"></a>5.4 安全性</h2><p>目前来说已经说明raft是如何选举和复制日志的，但是这并不能保证不同的状态机执行不同的log，还是会因为follower进入不可用状态然后恢复活性并竞选为leader，这时候leader的日志就会不一致</p>\n<h3 id=\"5-4-1-选举限制\"><a href=\"#5-4-1-选举限制\" class=\"headerlink\" title=\"5.4.1 选举限制\"></a>5.4.1 选举限制</h3><p>VSR算法一开始日志不全的情况下成为leader，然后当某台服务器成为leader之后会额外的同步这些未同步的日志，而raft则会检查candidate和follower的日志，因为如果集群保证半数node提交日志，那么就会有半数服务器是拥有最新的日志的，两份日志，任期号大的比较新，任期号相同，索引大的比较新</p>\n<h3 id=\"5-4-2-提交之前任期内的日志条目\"><a href=\"#5-4-2-提交之前任期内的日志条目\" class=\"headerlink\" title=\"5.4.2 提交之前任期内的日志条目\"></a>5.4.2 提交之前任期内的日志条目</h3><p>熟读figure 8 的图，为了消除figure 8的情况，raft不会通过计算副本数量来提交日志，只有当前任期的日志会通过计算副本数量来进行提交日志，而raft使用了一种更加保守办法，为每个logEntry都保留任期号，想提交之前日志，leader必须使用当前任期号，与其他算法相比，raft只需要发送更少的日志条目</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-可理解的一致性算法研究-论文\"><a href=\"#一-可理解的一致性算法研究-论文\" class=\"headerlink\" title=\"一.可理解的一致性算法研究-论文\"></a>一.可理解的一致性算法研究-论文</h1><h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ul>\n<li>raft比paxos更容易理解,在构建大型系统的时候方便实现</li>\n</ul>\n<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1 介绍\"></a>1 介绍</h1><ol>\n<li>什么叫一致性算法，一致性算法就是协调多台机器有序工作，允许成员失败</li>\n<li>天下苦paxos久矣，需要个更简单理解和实现的一致性算法，方便程序员理解什么是一致性算法</li>\n<li>raft将问题分解，减少raft不确定性，在实际的教学当中，raft要比paxos容易理解</li>\n<li>raft与Oki，VSR很像，但有如下新特性<ul>\n<li>强leader ： 日志只从领导流向follower</li>\n<li>leader选举 ： raft使用随机定时器来选举领导人。</li>\n<li>成员变更 ： raft使用了一种新的<code>联合共识</code>的方法，多数两种不同的配置在转换过程中重叠在一起</li>\n</ul>\n</li>\n<li>使劲吹raft多么多么牛逼，算法性能与其他一致性算法差不多，本文的其余部分介绍了复制的状态机问题（第2节），讨论了Paxos的优点和缺点（第3节），描述了我们对可理解性的一般方法（第4节），提出了Raft共识算法（第5-8节），评估了Paxos，Raft共识算法（第5-8节），评估了Raft（第9节），并讨论了相关工作（第10节）。</li>\n</ol>\n<h1 id=\"2-复制状态机\"><a href=\"#2-复制状态机\" class=\"headerlink\" title=\"2. 复制状态机\"></a>2. 复制状态机</h1><ol>\n<li><p>共识通常出现在状态机背景下，冗余状态机通常被用来解决分布式系统中的容错问题，例如，诸如GFS [8], HDFS [38],和RAM云[33]通常使用一个状态机管理leader选举，存储相关重要的配置信息复制状态机的例子包括Chubby[2] 和 ZooKeeper [11]</p>\n<p> <img src=\"/./../../picture/mit6.824/raft_figure_1.png\" alt=\"raft_figure_1\"></p>\n</li>\n<li><p>因为两台状态机按顺序执行相同的<code>日志</code>x&#x3D;1.y&#x3D;3等等,那么这两个状态机计算的状态和输出的结果也是一样的，所以共识算法要保证日志的一致性是非常重要的工作。即使一些状态机因为机械故障导致宕机(少于raft规定的数量)，但是这些服务器看起来还是像一个整体一样对外提供服务。</p>\n<ul>\n<li>它们确保在所有非拜占庭条件下的安全性（永远不会返回错误的结果），包括网络延迟、分区、以及数据包丢失、重复和重新排序</li>\n<li>只要有任何一台服务器在运行，它们就能完全发挥可用作用。大部分的服务器都在运行，并能与其他服务器和客户进行通信。彼此之间以及与客户端之间进行通信因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器的故障,假设服务器的故障是通过停止；它们后来可能从稳定的存储中恢复状态并重新加入集群。</li>\n<li>它们并不依赖时间来确保日志的一致性：时钟故障和极端的消息延迟在最坏的情况下会导致可用性问题。延迟，在最坏的情况下，会导致可用性问题。</li>\n<li>在通常情况下，只要集群中的大多数follower响应了命令，命令就以完成。一旦集群中的大多数follower对单轮RPC作出反应，一个命令就已经完成。少数缓慢的务器不影响整个系统的性能。</li>\n</ul>\n<p> 总结 : 第二节主要是引入状态机的太粘，并给出raft与状态机交互的大致流程</p>\n</li>\n</ol>\n<h1 id=\"3-Paxos怎么了？\"><a href=\"#3-Paxos怎么了？\" class=\"headerlink\" title=\"3 Paxos怎么了？\"></a>3 Paxos怎么了？</h1><ol>\n<li><p>Leslie Lamport创造了paxos共识算法，paxos被证明是安全的(能够达到一致)，有效的。但是paxos有两个明显的缺点(ps:什么是多paxos,single-decree子集)</p>\n<ul>\n<li>paxos非常难以理解，专业人士也很难理解全面，Paxos的不透明性来自于它选择了(单法令)子集作为其基础</li>\n<li>构建实际系统时候也很难去实现，并验证，，Paxos使用的是对称的对等方法为核心（尽管它最终建议采用一种弱的领导形式作为性能优化）。这在简化问题上是有意义的.但很少有实际的系统使用这种方法</li>\n</ul>\n</li>\n<li><p>构建一个paxos为基础的分布式系统很难，理解paxos算法也很难(ps:下面引用来自于Chubby系统的总结)。所以作者认为paxos没有为构建一个分布式系统提供一个很好的基础，所以作者提出了新的一致性算法 – 容易理解，对构建大型分布式系统也有帮助。在设计raft算法的时候，作者使用问题分解方法，将问题分解为，选举，日志复制，安全和成员变更等主要子问题。</p>\n<blockquote>\n<p>Paxos算法的描述与现实世界的需求之间存在着巨大的差距。最终的系统将基于一个未经证实的协议[4]。</p>\n</blockquote>\n</li>\n<li><p>第二个简化的地方是简化了状态空间，使系统连贯，作者努力消除不确定性，日志不允许有洞，并且Raft限制了日志可能变得彼此不一致的方式，但在某些情况下，不确定性实际上提高了可理解性。特别是，随机化方法引入了不确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (“选择什么,这并不重要”)。我们使用随机化来简化Raft领袖选举算法</p>\n</li>\n</ol>\n<p>总结 : 第三节只是阐述了paxos的<code>问题</code>,比如难理解，很难实现在构建大型系统的。</p>\n<h1 id=\"4-设计的可理解性\"><a href=\"#4-设计的可理解性\" class=\"headerlink\" title=\"4. 设计的可理解性\"></a>4. 设计的可理解性</h1><ol>\n<li>在设计raft之初就设置了如下目标<ul>\n<li>提供正确的理论基础，方便理解</li>\n<li>减少开发时间，并易于扩展</li>\n<li>在斟酌备选方案时，主要是从可理解性，会不会raft(状态空间，系统)变得复杂，但是这种分析是很主观的(想想作者与我们的硬实力差距)，所以作者选择了两种研究方式。<ul>\n<li>问题分解，将共识分解为独立的子问题，分别为选举，日志复制，安全和成员变成。</li>\n<li>减少状态空间(只有leader,candidate,follower,以及优化提到的prevote&#x2F;vote&#x2F;appendentry),不允许日志有漏洞(index1和3之间是空的日志)，raft通过冲突检测来矫正不一致情况。随机化的方法引入了非确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (“选择什么；这并不重要”)。我们使用随机化 来简化Raft领袖选举算法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"5-raft一致性算法\"><a href=\"#5-raft一致性算法\" class=\"headerlink\" title=\"5. raft一致性算法\"></a>5. raft一致性算法</h1><ol>\n<li>leader接受来自客户端的日志条目，将其复制到其他服务器上，并告诉服务器何时可以将日志条目应用到他们的状态机上。有一个领导者可以简化对复制日志的管理。例如只允许数据从领导者流向其他服务器。一个领导者可能失败或与其他服务器断开连接，在这种情况下 选举一个新的领导者</li>\n</ol>\n<p><img src=\"/./../../picture/mit6.824/raft_figure_2.png\" alt=\"raft_figure_2\"><br>考虑到领导者的方法，Raft将共识问题分解为三个相对独立的子问题，这将在后面的小节中讨论.</p>\n<ul>\n<li>leader选举 : 现任领导人失败,必须选择新的领导人</li>\n<li>Log replication : 领导者必须接受日志条目从client,并在整个集群中复制它们。迫使其他日志与自己的日志一致（第5.3节）。</li>\n<li>Safety : Raft的关键安全属性是图中的状态机安全属性。图3中的状态机安全属性：如果任何服务器 在其状态机上应用了一个特定的日志条目。 那么其他服务器就不能对相同的日志索引应用不同命令 对相同的日志索引应用不同的命令。第5.4节描述了如何Raft如何确保这一特性；该解决方案涉及到一个 第5.2节中描述的选举机制的额外限制。</li>\n</ul>\n<p><img src=\"/./../../picture/mit6.824/raft_figure_3.png\" alt=\"raft_figure_3\"></p>\n<ul>\n<li>Election Safety: 一届任期内最多可以选出一位领导人</li>\n<li>Leader Append-Only : 领导者从不覆盖或删除其日志中的的条目；它只添加新的条目</li>\n<li>Log Matching : 如果两个日志包含一个具有相同的索引和术语，那么这两份日志的所有条目都是相同的。直到给定的索引为止</li>\n<li>Leader Completeness : 如果在一个给定的term中提交了一个日志条目，那么该日志将出现在所有更高编号的术语的领导人的日志中。</li>\n<li>State Machine Safety : 如果一个服务器在它的状态机上应用了一个日志条目 在它的状态机中应用了一个给定的索引，那么其他服务器将永远不会在同一索引应用不同的日志条目.</li>\n<li>Raft保证这些属性中的每一个都是真的,在任何时候都是真实的。节号表示每个属性的讨论位置。</li>\n</ul>\n<p><img src=\"/./../../picture/mit6.824/raft_figure_4_5.png\" alt=\"raft_figure_3\"></p>\n<p>总结</p>\n<ol>\n<li>所有节点都需要持久化的参数<ul>\n<li><code>currentTerm</code>持久化参数，第一次初始化为0然后单调递增</li>\n<li><code>voteFor</code>当前term记录投票的candidateId</li>\n<li><code>commitIndex</code>记录当前节点可以提交的日志index</li>\n<li><code>lastApplied</code>记录当前节点可以提交给上层状态机的index</li>\n<li><code>nextIndex[]</code>当leader被选出时需要初始化的参数，且是leader最新log+1的位置</li>\n<li><code>matchIndex[]</code>初始化为0，表示leader与follower匹配的日志位置</li>\n</ul>\n</li>\n<li>reqeustVote RPC细节<ol>\n<li>requestVote的请求参数<ul>\n<li><code>term</code>请求的term</li>\n<li><code>candidateId</code></li>\n<li><code>lastLogIndex</code>candidate最新的log</li>\n<li><code>lastLogTerm</code>candidate最新的term</li>\n</ul>\n</li>\n<li>reqeustVote response参数<ul>\n<li><code>term</code>投票时候的term</li>\n<li><code>voteGranted</code>布尔类型，true说明follower同意投票</li>\n</ul>\n</li>\n<li>重要交互逻辑<ul>\n<li>如果rpc的term小于follower的current term，follower拒绝投票</li>\n<li>如果voteFor是空或者为candaditeID,并且candaidate的log至少与follower是一样，也可以比Follower多，新</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>AppendEntry RPC细节<ol>\n<li>AppendEntry请求参数<ul>\n<li><code>term</code>post RPC时的term</li>\n<li><code>leaderID</code></li>\n<li><code>preLogIndex</code>leader进行一致性检测日志的index</li>\n<li><code>preLogTerm</code>leader进行一致性检测时日志的term</li>\n<li><code>entries</code>搬运的日志</li>\n<li><code>leaderCommit</code>leader的commitIndex</li>\n</ul>\n</li>\n<li>AppendEntry的response参数<ul>\n<li><code>term</code>RPC的当前term</li>\n<li><code>success</code>布尔类型返回true说明preLogIndex和preLogTerm是匹配的</li>\n</ul>\n</li>\n<li>AppendEntry RPC的实现<ul>\n<li>rpc’s term小于follower’s的term则返回false</li>\n<li>如果preLogIndex，preLogTerm不匹配返回false</li>\n<li>preLogIndex匹配但是preLogTerm不匹配则删掉后面所有的存在的log</li>\n<li>append新log</li>\n<li>leaderCommit大于follower的commitIndex时候要把follower的commitIndex设置为min(leaderCommit,len(logs))</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>提交给状态机的规则<ol>\n<li>如果follower节点的commitIndex大于lastApplied 那么就可以将log提交给状态机</li>\n<li>如果发现有大的term,那么一定要更新RPC中term参数,RPC term  &gt; currentTerm,然后candidate或者leader转变为follower</li>\n<li>Follower收不到心跳就进行选举</li>\n<li>Follower负责响应candidate和leader,言外之意就是处理requestVote RPC和AppendEntry RPC</li>\n<li>Candadite会增加自己的term,给自己投票，重置选举超时时间，发送requestVote RPC,得到多数投票就变成leader</li>\n<li>Candidate收到其他的AppendEntry的RPC就变成follower</li>\n<li>Candidate在选举超时时间内没有完成选举就重新再来一轮</li>\n<li>Leader在位时会不间断的发送心跳抑制Follower选举</li>\n<li>Leader接收来自client的命令，然后走共识层进行</li>\n<li>Leader的logIndex大于nextIndex就开始进行发送AppendEntry的RPC,如果匹配成功就更新Leader的matchIndex和nextIndex,如果没成功就增加nextIndex然后重试</li>\n<li>如果存在一个整数N&gt;commitIndex,然后大部分matchIndex[i]&gt;&#x3D;N，那么log[N]&#x3D;&#x3D;currentTerm，然后将Leader设置commitIndex&#x3D;N</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"5-1-raft基础\"><a href=\"#5-1-raft基础\" class=\"headerlink\" title=\"5.1 raft基础\"></a>5.1 raft基础</h2><ol>\n<li>五台服务器是一个典型的最小集群，它最多允许两台服务器宕机，并且每台服务器有三种状态分别是<code>leader</code>,<code>candidate</code>,<code>follower</code>,follower是被动的不发送任何的请求(RPC),只是简单的回leader和candidate的请求，如果follower接收到来自client的请求，也要路由给leader。Figure 4描述了三种状态的转换关系和条件</li>\n<li>raft主要将时间定义为任意长度的term,是连续且单调递增的,在某些情况下,会出现多个candidate同时竞选leader的情况，这时候或会出现<code>瓜分投票</code>的情况，这是整个raft系统就无法继续前进通过引入随机选举超时解决这个问题，如果一个follower没有在选举超时实践之内接收到leader的heartbeat就会开始选举</li>\n<li>不同的服务器可能在不同的时间观察到term之间的转换。而在某些情况下，一个服务器<br>可能观察不到一次选举，甚至是整个任期(candidate在一个term时间内无法完成选举)，term在Raft中充当逻辑时钟[14]，它们允许服务器检测过时的信息，如过时的leader。每个服务器存储一个当前的currentTerm，该currentTerm随着时间的推移单调地随时间增加。每当服务器进行通信时，就会交换currentTerm。如果一个服务器的currentTerm小于另一个服务器的currentTerm，那么它就会更新自己的currentTerm，那么它就将其currentTerm更新为较大的值。如果一个candidate或leader发现它的currenTerm已经过时，它就会变成follower。如果follower收到一个过时的term的请求，它将拒绝该请求。<br><img src=\"/./../../picture/mit6.824/raft_figure_6.png\" alt=\"feature 6\"></li>\n</ol>\n<h2 id=\"5-2-Leader-election\"><a href=\"#5-2-Leader-election\" class=\"headerlink\" title=\"5.2  Leader election\"></a>5.2  Leader election</h2><ol>\n<li><p>Raft使用心跳机制来触发领导者选举。当服务器启动时，它们开始作为跟随者。A 服务器只要收到有效的RPC从leader或者候选人,领导者定期发送 心跳（AppendEntries RPCs，不携带任何日志条目）。到所有追随者，以维持他们的权威。 如果一个 跟随者在一段时间内没有收到通信，称为选举超时。称为选举超时，那么它就认为没有可行的领导者，并开始选举，想成为一个新的领导者。</p>\n</li>\n<li><p>在开始选举，candidate递增其当前term并过渡到候选状态。然后,它为自己投票 并向集群中的每个服务器发出RequestVote RPCs。candidate继续处于 这个状态，直到发生以下三种情况之一: (a) 它赢得选举. (b) 另一个服务器确立了自己的领导地位，或者 (c) 一段时间内没有赢家。这些结果将在下面的段落中分别讨论</p>\n</li>\n<li><p>如果一个候选人在选举中获得了来自整个集群中大多数服务器的投票，那么它就赢得了的大多数服务器的投票选举。每台服务器在给定的任期内最多只能为一名候选人投票。以先来后到为原则（注意:第<a href=\"#54-%E5%AE%89%E5%85%A8%E6%80%A7\">5.4安全性</a> 节对投票增加了一个额外的限制）。多数规则确保最多只有一名candidate能在某届选举中获胜（选举）。一旦一个candidate在选举中获胜，他就成为leader。然后它将心跳信息发送给所有的其他服务器，以建立其权威并防止新的选举。</p>\n</li>\n<li><p>在等待投票的过程中，候选人可能会收到一个来自另一个leader的AppendEntries RPC，该RPC来自另一服务器，声称自己是leader。如果leader的任期(包括在其RPC中)至少是与Candidate的当前任期一样大,那么candidate承认该leader是合法的，并返回到Follower状态。如果RPC中的term小于candidate的term,那么Candidate就拒绝RPC(被拒绝的RPC变成follower)，继续处于候选状态。</p>\n</li>\n<li><p>第三个可能的结果是，一个candidate既没有赢得选举，也没有失去选举：如果许多Follower同时成为候选人，选票可能被分割，因此没有候选人获得多数。当这种情况发生时，每个candidate都会超时，并通过增加其任期和启动新一轮的RequestVote RPC来开始新的选举。然而，如果没有额外的措施，分裂的投票 可以无限期地重复.(使用随即超时时间来解决follower同时变成candidate,也防止了candidate同时请求投票投票窘境)</p>\n</li>\n<li><p>Raft使用随机的选举超时来确保分歧票的情况很少出现，而且能迅速解决。为了从一开始就防止分裂投票，从一个固定的时间间隔中随机选择选举超时（例如，150-300ms）。因此在大多数情况下,在分散服务器中，只有一个服务器会超时。它赢得了选举，并在其他服务器超时之前发送了在其他服务器超时前发送心跳。同样的机制被用来处理<code>分裂的投票</code>。每个candidate在选举开始时重新启动其随机的<code>选举超时</code>。并等待该超时过后再开始下一次选举。这减少了在新的选举中出现新的选举再次出现分裂票的可能性。第9.3节显示这种方法可以迅速选出一个领导者</p>\n</li>\n<li><p>选举是一个例子，说明可理解性如何指导我们对设计方案的选择。最初我们计划使用一个排名系统:每个candidate被分配一个独特的排名，用来在竞争的candidate之间进行选择。如果一个candidate发现了另一个排名更高的candidate，它就会回到follower的状态，这样排名更高的候选人就能更容易地赢得下一次选举。我们发现，这种方法在可用性方面产生了一些微妙的问题(一个排名较低的服务器可能需要超时，并成为一个新的服务器）。如果一个排名较高的服务器失败了，一个排名较低的服务器可能需要超时并再次成为候选人，但如果它过早地这样做，它可能会重置选举领导者的进展)。我们对算法进行了多次调整，但每次调整后都会出现新的corner cases。最终我们得出结论，随机重试的方法更加明显和容易理解。</p>\n</li>\n</ol>\n<h2 id=\"5-3-Log-replication\"><a href=\"#5-3-Log-replication\" class=\"headerlink\" title=\"5.3 Log replication\"></a>5.3 Log replication</h2><ol>\n<li><p>一旦一个领导者被选出，它就开始为客户端请求。每个客户请求都包含一个命令，由复制的状态机执行。leader将该命令作为一个新条目附加到它的日志中，然后向其他每个服务器并行地发出AppendEntries RPCs来复制该条目。当该条目已经被安全复制后（如下所述），leader将该条目应用于其状态机并返回，并将执行的结果返回给客户端。如果跟随者崩溃或运行缓慢。或者网络数据包丢失，领导者会无限期地重试AppendEntries RPCs甚至在它已经响应了直到所有跟随者最终存储了所有的日志条目。</p>\n</li>\n<li><p>日志的组织方式如图figure 6所示。每个日志条目都存储了一条状态机命令，以及领导者收到该条目时的term编号。日志条目中的term被用来检测日志之间的不一致，并确保图figure 3中的一些属性。每个日志条目也有一个整数索引，用来识别它在日志中的位置</p>\n</li>\n<li><p>leader决定何时将日志条目应用于状态机是安全的；这样的条目被称为<code>commited</code>。Raft保证所提交的logEntry是持久的并且最终会被所有可用的状态机执行。一旦创建日志条目的leader创建该条目的领导者将其复制到大多数的服务器上(例如，图6中的第7条)，包括之前leader创建的logEntry包括由以前的领导者创建的条目。第<a href=\"#54-%E5%AE%89%E5%85%A8%E6%80%A7\">5.4节</a>它还表明，这种<code>commited</code>的定义是安全。领导者跟踪它所知道的最高<code>commited</code>的最高索引，并将该索引包括在未来的 AppendEntries RPCs（包括心跳）中，以便其他服务器最终发现。其他服务器最终会发现。一旦一个跟随者知道 一旦跟随者得知一个日志条目被提交，它就会将该条目应用到其本地状态机（按日志顺序).</p>\n</li>\n<li><p>我们设计的Raft日志机制在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更具可预测性，而且是确保安全的重要组成部分。Raft维护以下属性，它们共同构成了日志匹配属性在figure 3中.</p>\n</li>\n</ol>\n<ul>\n<li>如果不同服务器日志中的两个条目具有相同的索引和term，那么它们存储的是同一个命令。</li>\n<li>如果不同服务器日志中的两个条目具有相同的索引和term，那么这些日志在所有前面的条目相同。</li>\n</ul>\n<ol>\n<li><p>第一个属性：一个leader在一个给定的term中最多创建一个具有给定日志索引的logEntry，而logEntry永远不会改变它们在日志中的位置。第二个属性由AppendEntries执行的简单一致性检查来保证。当发送一个AppendEntries RPC时，leader在其日志中包括条目的索引以及紧接在其日志中的条目的索引和term。如果follower在其日志中没有找到具有相同索引和术语的条目它的日志中没有找到具有相同索引和term的条目，那么它就会拒绝这些logEntry。一致性检查充当了一个归纳步骤：日志的初始空状态满足了日志的匹配属性，而一致性检查则保留了只要日志被扩展，一致性检查就会保留日志匹配属性。因此，只要AppendEntries成功返回。领导者知道跟随者的logEntry与它的自己的logEntry相同的,直到新的条目。</p>\n</li>\n<li><p>在正常运行期间，领导者和跟随者的日志保持一致，因此AppendEntries一致性检查不会失败。然而，leader崩溃会使日志不一致（老leader可能没有完全复制其日志中的所有条目）。这些不一致会在一系列的领导者和追随者崩溃中加剧。figure 7说明了追随者的日志可能与新领导者的日志不同的方式。跟随者可能会缺少领导者的条目，可能会有领导者没有的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个term。</p>\n</li>\n<li><p>在Raft中，领导者通过强迫跟随者重复自己的日志来处理不一致的问题。跟随者的日志与自己的日志重复。这意味着 跟随者日志中的冲突条目将被领导者日志中的条目覆盖。第5.4节将表明这就是安全的 如果再加上一个限制。</p>\n</li>\n<li><p>为了使追随者的日志与自己的日志保持一致，领导者必须找到两个日志一致的最新日志条目，删除追随者日志中此后的所有条目，并向追随者发送此后领导者的所有条目。所有这些动作都是为了响应AppendEntries RPCs所进行的一致性检查而发生的。leader为每个follower维护一个nextIndex，它是领导将发送给该跟随者的下一个日志条目的索引。当一个领导者第一次上台时。它将所有的<code>nextIndex</code>值初始化为其日志中最后一条的索引（feature 7中的11）。如果跟随者的日志与领导者的日志不一致，在下一个AppendEntries RPC中，AppendEntries一致性检查将失败。在拒绝之后，领导者会减少<code>nextIndex</code>并重试 AppendEntries RPC。最终，<code>nextIndex</code>将达到 一个领导者和追随者日志匹配的点。当这种情况发生时，AppendEntries就会成功，这就删除了移除跟随者日志中任何冲突的条目，并从领导者日志中添加 从领导者的日志中添加条目（如果有的话）。一旦AppendEntries 成功后，跟随者的日志就与领导者的一致了。并且在余下的时间里保持这种状态。</p>\n</li>\n<li><p>如果需要，该协议可以被优化以减少被拒绝的AppendEntries RPC的数量。例如，当拒绝一个AppendEntries请求时，跟随者包括冲突条目的term和它为该term存储的第一个索引。有了这些信息，领导者可以递减 <code>nextIndex</code>以绕过该term中的所有冲突条目；每个有冲突条目的term将需要一个AppendEntries RPC而不是每个logEntry的RPC。在实践中，我们怀疑这种优化是否有必要，因为故障发生的频率很低而且不太可能有很多不一致的条目。</p>\n</li>\n<li><p>有了这种机制，领导者不需要采取任何特别的行动来恢复日志的一致性。它只是开始正常运行，而日志会自动收敛，以应Append-Entries一致性检查的失败。一个领导者从不覆盖或删除自己日志中的条目（figure 3中的 仅领导者append logEntry属性）。</p>\n</li>\n<li><p>这种日志复制机制表现出了第2节中所描述的理想的共识属性：只要大多数服务器都在运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目可以通过单轮RPCs复制到集群的大部分；而且一个缓慢的跟随者也不会影响性能。</p>\n</li>\n</ol>\n<h2 id=\"5-4-安全性\"><a href=\"#5-4-安全性\" class=\"headerlink\" title=\"5.4 安全性\"></a>5.4 安全性</h2><p>目前来说已经说明raft是如何选举和复制日志的，但是这并不能保证不同的状态机执行不同的log，还是会因为follower进入不可用状态然后恢复活性并竞选为leader，这时候leader的日志就会不一致</p>\n<h3 id=\"5-4-1-选举限制\"><a href=\"#5-4-1-选举限制\" class=\"headerlink\" title=\"5.4.1 选举限制\"></a>5.4.1 选举限制</h3><p>VSR算法一开始日志不全的情况下成为leader，然后当某台服务器成为leader之后会额外的同步这些未同步的日志，而raft则会检查candidate和follower的日志，因为如果集群保证半数node提交日志，那么就会有半数服务器是拥有最新的日志的，两份日志，任期号大的比较新，任期号相同，索引大的比较新</p>\n<h3 id=\"5-4-2-提交之前任期内的日志条目\"><a href=\"#5-4-2-提交之前任期内的日志条目\" class=\"headerlink\" title=\"5.4.2 提交之前任期内的日志条目\"></a>5.4.2 提交之前任期内的日志条目</h3><p>熟读figure 8 的图，为了消除figure 8的情况，raft不会通过计算副本数量来提交日志，只有当前任期的日志会通过计算副本数量来进行提交日志，而raft使用了一种更加保守办法，为每个logEntry都保留任期号，想提交之前日志，leader必须使用当前任期号，与其他算法相比，raft只需要发送更少的日志条目</p>\n"},{"title":"MIT6.824之lab2_raft_structure_guide","_content":"\nRaft Structure Advice\n\nA Raft instance has to deal with the arrival of external events\n(Start() calls, AppendEntries and RequestVote RPCs, and RPC replies),\nand it has to execute periodic tasks (elections and heart-beats).\nThere are many ways to structure your Raft code to manage these\nactivities; this document outlines a few ideas.\n\nEach Raft instance has a bunch of state (the log, the current index,\n&c) which must be updated in response to events arising in concurrent\ngoroutines. The Go documentation points out that the goroutines can\nperform the updates directly using shared data structures and locks,\nor by passing messages on channels. Experience suggests that for Raft\nit is most straightforward to use shared data and locks.\n\nA Raft instance has two time-driven activities: the leader must send\nheart-beats, and others must start an election if too much time has\npassed since hearing from the leader. **It's probably best to drive each\nof these activities with a dedicated long-running goroutine**, rather\nthan combining multiple activities into a single goroutine.\n> It's probably best to drive each of these activities \n> with a dedicated long-running goroutine\n\nThe management of the election timeout is a common source of\nheadaches. Perhaps the simplest plan is to maintain a variable in the\nRaft struct containing the last time at which the peer heard from the\nleader, and to have the election timeout goroutine periodically check\nto see whether the time since then is greater than the timeout period.\nIt's easiest to use time.Sleep() with a small constant argument to\ndrive the periodic checks. Don't use time.Ticker and time.Timer;\nthey are tricky to use correctly.\n> using hashicorp struct\n\nYou'll want to have a separate long-running goroutine that sends\ncommitted log entries in order on the applyCh. It must be separate,\nsince sending on the applyCh can block; and it must be a single\ngoroutine, since otherwise it may be hard to ensure that you send log\nentries in log order. The code that advances commitIndex will need to\nkick the apply goroutine; it's probably easiest to use a condition\nvariable (Go's sync.Cond) for this.\n> using a seperate applier channel\n\nEach RPC should probably be sent (and its reply processed) in its own\ngoroutine, for two reasons: so that unreachable peers don't delay the\ncollection of a majority of replies, and so that the heartbeat and\nelection timers can continue to tick at all times. It's easiest to do\nthe RPC reply processing in the same goroutine, rather than sending\nreply information over a channel.\n> easy to unstand , using two different channels to send and process\n> reply of RPC\n\nKeep in mind that the network can delay RPCs and RPC replies, and when\nyou send concurrent RPCs, the network can re-order requests and\nreplies. Figure 2 is pretty good about pointing out places where RPC\nhandlers have to be careful about this (e.g. an RPC handler should\nignore RPCs with old terms). Figure 2 is not always explicit about RPC\nreply processing. The leader has to be careful when processing\nreplies; it must check that the term hasn't changed since sending the\nRPC, and must account for the possibility that replies from concurrent\nRPCs to the same follower have changed the leader's state (e.g.\nnextIndex).\n> this part we should put eyes on checking reply of concurrent RPC, like \n> election and heartbeat","source":"_posts/MIT6.824/lab2_raft_struct_guide.md","raw":"---\ntitle: MIT6.824之lab2_raft_structure_guide\ncategories:\n- 分布式\n- MIT6.824\n---\n\nRaft Structure Advice\n\nA Raft instance has to deal with the arrival of external events\n(Start() calls, AppendEntries and RequestVote RPCs, and RPC replies),\nand it has to execute periodic tasks (elections and heart-beats).\nThere are many ways to structure your Raft code to manage these\nactivities; this document outlines a few ideas.\n\nEach Raft instance has a bunch of state (the log, the current index,\n&c) which must be updated in response to events arising in concurrent\ngoroutines. The Go documentation points out that the goroutines can\nperform the updates directly using shared data structures and locks,\nor by passing messages on channels. Experience suggests that for Raft\nit is most straightforward to use shared data and locks.\n\nA Raft instance has two time-driven activities: the leader must send\nheart-beats, and others must start an election if too much time has\npassed since hearing from the leader. **It's probably best to drive each\nof these activities with a dedicated long-running goroutine**, rather\nthan combining multiple activities into a single goroutine.\n> It's probably best to drive each of these activities \n> with a dedicated long-running goroutine\n\nThe management of the election timeout is a common source of\nheadaches. Perhaps the simplest plan is to maintain a variable in the\nRaft struct containing the last time at which the peer heard from the\nleader, and to have the election timeout goroutine periodically check\nto see whether the time since then is greater than the timeout period.\nIt's easiest to use time.Sleep() with a small constant argument to\ndrive the periodic checks. Don't use time.Ticker and time.Timer;\nthey are tricky to use correctly.\n> using hashicorp struct\n\nYou'll want to have a separate long-running goroutine that sends\ncommitted log entries in order on the applyCh. It must be separate,\nsince sending on the applyCh can block; and it must be a single\ngoroutine, since otherwise it may be hard to ensure that you send log\nentries in log order. The code that advances commitIndex will need to\nkick the apply goroutine; it's probably easiest to use a condition\nvariable (Go's sync.Cond) for this.\n> using a seperate applier channel\n\nEach RPC should probably be sent (and its reply processed) in its own\ngoroutine, for two reasons: so that unreachable peers don't delay the\ncollection of a majority of replies, and so that the heartbeat and\nelection timers can continue to tick at all times. It's easiest to do\nthe RPC reply processing in the same goroutine, rather than sending\nreply information over a channel.\n> easy to unstand , using two different channels to send and process\n> reply of RPC\n\nKeep in mind that the network can delay RPCs and RPC replies, and when\nyou send concurrent RPCs, the network can re-order requests and\nreplies. Figure 2 is pretty good about pointing out places where RPC\nhandlers have to be careful about this (e.g. an RPC handler should\nignore RPCs with old terms). Figure 2 is not always explicit about RPC\nreply processing. The leader has to be careful when processing\nreplies; it must check that the term hasn't changed since sending the\nRPC, and must account for the possibility that replies from concurrent\nRPCs to the same follower have changed the leader's state (e.g.\nnextIndex).\n> this part we should put eyes on checking reply of concurrent RPC, like \n> election and heartbeat","slug":"MIT6.824/lab2_raft_struct_guide","published":1,"date":"2022-10-07T00:40:25.771Z","updated":"2022-10-07T01:25:47.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5m000ml1dbfqn29b6n","content":"<p>Raft Structure Advice</p>\n<p>A Raft instance has to deal with the arrival of external events<br>(Start() calls, AppendEntries and RequestVote RPCs, and RPC replies),<br>and it has to execute periodic tasks (elections and heart-beats).<br>There are many ways to structure your Raft code to manage these<br>activities; this document outlines a few ideas.</p>\n<p>Each Raft instance has a bunch of state (the log, the current index,<br>&amp;c) which must be updated in response to events arising in concurrent<br>goroutines. The Go documentation points out that the goroutines can<br>perform the updates directly using shared data structures and locks,<br>or by passing messages on channels. Experience suggests that for Raft<br>it is most straightforward to use shared data and locks.</p>\n<p>A Raft instance has two time-driven activities: the leader must send<br>heart-beats, and others must start an election if too much time has<br>passed since hearing from the leader. <strong>It’s probably best to drive each<br>of these activities with a dedicated long-running goroutine</strong>, rather<br>than combining multiple activities into a single goroutine.</p>\n<blockquote>\n<p>It’s probably best to drive each of these activities<br>with a dedicated long-running goroutine</p>\n</blockquote>\n<p>The management of the election timeout is a common source of<br>headaches. Perhaps the simplest plan is to maintain a variable in the<br>Raft struct containing the last time at which the peer heard from the<br>leader, and to have the election timeout goroutine periodically check<br>to see whether the time since then is greater than the timeout period.<br>It’s easiest to use time.Sleep() with a small constant argument to<br>drive the periodic checks. Don’t use time.Ticker and time.Timer;<br>they are tricky to use correctly.</p>\n<blockquote>\n<p>using hashicorp struct</p>\n</blockquote>\n<p>You’ll want to have a separate long-running goroutine that sends<br>committed log entries in order on the applyCh. It must be separate,<br>since sending on the applyCh can block; and it must be a single<br>goroutine, since otherwise it may be hard to ensure that you send log<br>entries in log order. The code that advances commitIndex will need to<br>kick the apply goroutine; it’s probably easiest to use a condition<br>variable (Go’s sync.Cond) for this.</p>\n<blockquote>\n<p>using a seperate applier channel</p>\n</blockquote>\n<p>Each RPC should probably be sent (and its reply processed) in its own<br>goroutine, for two reasons: so that unreachable peers don’t delay the<br>collection of a majority of replies, and so that the heartbeat and<br>election timers can continue to tick at all times. It’s easiest to do<br>the RPC reply processing in the same goroutine, rather than sending<br>reply information over a channel.</p>\n<blockquote>\n<p>easy to unstand , using two different channels to send and process<br>reply of RPC</p>\n</blockquote>\n<p>Keep in mind that the network can delay RPCs and RPC replies, and when<br>you send concurrent RPCs, the network can re-order requests and<br>replies. Figure 2 is pretty good about pointing out places where RPC<br>handlers have to be careful about this (e.g. an RPC handler should<br>ignore RPCs with old terms). Figure 2 is not always explicit about RPC<br>reply processing. The leader has to be careful when processing<br>replies; it must check that the term hasn’t changed since sending the<br>RPC, and must account for the possibility that replies from concurrent<br>RPCs to the same follower have changed the leader’s state (e.g.<br>nextIndex).</p>\n<blockquote>\n<p>this part we should put eyes on checking reply of concurrent RPC, like<br>election and heartbeat</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>Raft Structure Advice</p>\n<p>A Raft instance has to deal with the arrival of external events<br>(Start() calls, AppendEntries and RequestVote RPCs, and RPC replies),<br>and it has to execute periodic tasks (elections and heart-beats).<br>There are many ways to structure your Raft code to manage these<br>activities; this document outlines a few ideas.</p>\n<p>Each Raft instance has a bunch of state (the log, the current index,<br>&amp;c) which must be updated in response to events arising in concurrent<br>goroutines. The Go documentation points out that the goroutines can<br>perform the updates directly using shared data structures and locks,<br>or by passing messages on channels. Experience suggests that for Raft<br>it is most straightforward to use shared data and locks.</p>\n<p>A Raft instance has two time-driven activities: the leader must send<br>heart-beats, and others must start an election if too much time has<br>passed since hearing from the leader. <strong>It’s probably best to drive each<br>of these activities with a dedicated long-running goroutine</strong>, rather<br>than combining multiple activities into a single goroutine.</p>\n<blockquote>\n<p>It’s probably best to drive each of these activities<br>with a dedicated long-running goroutine</p>\n</blockquote>\n<p>The management of the election timeout is a common source of<br>headaches. Perhaps the simplest plan is to maintain a variable in the<br>Raft struct containing the last time at which the peer heard from the<br>leader, and to have the election timeout goroutine periodically check<br>to see whether the time since then is greater than the timeout period.<br>It’s easiest to use time.Sleep() with a small constant argument to<br>drive the periodic checks. Don’t use time.Ticker and time.Timer;<br>they are tricky to use correctly.</p>\n<blockquote>\n<p>using hashicorp struct</p>\n</blockquote>\n<p>You’ll want to have a separate long-running goroutine that sends<br>committed log entries in order on the applyCh. It must be separate,<br>since sending on the applyCh can block; and it must be a single<br>goroutine, since otherwise it may be hard to ensure that you send log<br>entries in log order. The code that advances commitIndex will need to<br>kick the apply goroutine; it’s probably easiest to use a condition<br>variable (Go’s sync.Cond) for this.</p>\n<blockquote>\n<p>using a seperate applier channel</p>\n</blockquote>\n<p>Each RPC should probably be sent (and its reply processed) in its own<br>goroutine, for two reasons: so that unreachable peers don’t delay the<br>collection of a majority of replies, and so that the heartbeat and<br>election timers can continue to tick at all times. It’s easiest to do<br>the RPC reply processing in the same goroutine, rather than sending<br>reply information over a channel.</p>\n<blockquote>\n<p>easy to unstand , using two different channels to send and process<br>reply of RPC</p>\n</blockquote>\n<p>Keep in mind that the network can delay RPCs and RPC replies, and when<br>you send concurrent RPCs, the network can re-order requests and<br>replies. Figure 2 is pretty good about pointing out places where RPC<br>handlers have to be careful about this (e.g. an RPC handler should<br>ignore RPCs with old terms). Figure 2 is not always explicit about RPC<br>reply processing. The leader has to be careful when processing<br>replies; it must check that the term hasn’t changed since sending the<br>RPC, and must account for the possibility that replies from concurrent<br>RPCs to the same follower have changed the leader’s state (e.g.<br>nextIndex).</p>\n<blockquote>\n<p>this part we should put eyes on checking reply of concurrent RPC, like<br>election and heartbeat</p>\n</blockquote>\n"},{"title":"MIT6.824之lab2_raft_students_guide","_content":"\n- [二.Students' Guide to Raf文档](#二students-guide-to-raf文档)\n  - [背景](#背景)\n  - [实现raft](#实现raft)\n    - [重要的细节](#重要的细节)\n  - [Debugging Raft](#debugging-raft)\n    - [活锁](#活锁)\n    - [不正确的RPC](#不正确的rpc)\n    - [没有按照论文的理论实现raft](#没有按照论文的理论实现raft)\n    - [term混乱(term不稳定)](#term混乱term不稳定)\n    - [优化](#优化)\n  - [Applications on top of Raft](#applications-on-top-of-raft)\n  - [AppendIndex](#appendindex)\n\n\n# 二.Students' Guide to Raf文档\n\n> https://thesquareplanet.com/blog/students-guide-to-raft/ 原文链接\n\n在过去几个月里，我成为了MIT6.824的一名助教.以往这门课程的实验都是基于paxos实现一致性算法,然后今年(2016),我们决定使用raft,raft的设计理念是\"理解门槛低\"，并且我们也希望这项决定使同学们的生活更简单[在过去的几个月里，我一直是麻省理工学院6.824分布式系统课的教学助理。这门课传统上有一些建立在Paxos共识算法上的实验，但今年，我们决定改用Raft。Raft是 \"设计成易于理解的\"，我们希望这一改变能使学生的生活更轻松]\n\n这篇实验指南,对应着\"教师教学指南\"，印证着我们实验室与raft的journey，也希望对学生更好的理解raft内部运行机制，实现raft分布式协议起到帮助,如果你正在寻找Raft和Paxos的对比，或者raft的教学(pedagogical)分析,请前去阅读《教师教学指南》.文章底部包含一些学生提问的关于raft的共性问题的问题列表。如果你遇到的问题不在那些问题之内，请前去检查Q&A系统，这篇文章非常的长,但是它提出的所有点，都是现实中学生(助教)碰到过的问题，这是一篇值得阅读的文章。\n\n\n## 背景\n\n开始深入研究raft之前,一些前情提要或许是有用的，6.824过去有一些基于用golang实现的Paxos实验，之所以选择go是因为它易于理解和学习的，它非常适合实现高并发，分布式应用(goroutine是特别便利的)，通过这门课程的四门实验课程，学生构建一个容错的，共享key-value存储系统，第一个实验让你构建一个基于log的一致性算法库,第二门实验在一致性算法库上添加了key-value的存储，第三们实验课是实验构建共享的key-value容错集群,使用共享master节点解决集群成员变更，同时第四们实验,学生不得不实现失败和恢复机制，包括磁盘完整和磁盘不完整的情况这个实现曾作为学生默认的最后实验\n\n这些年我们决定使用raft重写所有mit6.824的实验，前三个实验跟以前是相同的,但是删除了第四个已经在raft中实现了关于失败与持久化的实验,这篇文章主要讨论了我们第一个实验的经验，一个直接跟raft相关的的实验，虽然我们也会接触到构建raft之上的应用层,(第二门实验)。\n\n如果想了解raft的简单的运行逻辑，这个[web site](https://raft.github.io/)网站演示的raft协议是最好的文字材料.\n\nraft是一种被设计为容易理解的一致性算法,在容错,性能方面等价于paxos算法,他们的不同点是raft将问题解耦为相对独立的问题,它也在实际的系统中清晰的解决了很多实际问题.我们也希望跟多的读者实现raft,以及构建更多的基于raft一致性系统\n\n这个网站的可视化raft协议提供了很好的主要组件的概括,论文提供了更直观的说明为什么需要这些组件,如果你还没有阅读raft extend 论文,请有限阅读那篇论文然后再阅读这份<<raft指南>>,由于我假设你对raft有了个大致的了解(ps:这段要翻译成\"你对raft有一定程度的熟悉\").\n\n正如其他的分布式一致性协议一样,协议细节有很多的\"坑\",在稳定的状态下,没有节点失效,raft协议就很好理解,可以很直观的理解,可以从上面的可视化网站了解其运行机制,假设没有节点失效,一个leader会最终被选出来,客户端所有发给raft的请求都会最终发送给follower,但是当网络出现通信延迟,网络分区,节点宕机等等假设发生,但是在特定情况下,我们看到有很多bugs一次次的重复出现,由于直接的错误理解和疏忽,当阅读论文的时候,这不是raft独有的,而是所有提出正确复杂分布式系统都存在的问题\n\n## 实现raft\n\nraft论文的figure2是最好的guide，figure2指定每个RPC的工作的方式，当你读完figure2就可以着手实现raft，但是问题也就接踵而至。实际上，figure2是极其严格的，论文中有些叙述是must而不是should，举个例子，你也会有理由重置election timer, 无论什么时候收到 Request vote and Append entry RPC,这两个RPC说明，其他的server其中一个是leader，另一个是candidate在尝试成为leader，这不允许人为干预或者推理。\n> If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate.\n\n他们之间是有很大区别的，之前的实现可能有某些特定场景下有严重的活性问题\n\n\n### 重要的细节\n\nraft会把没有entry的appendEntry的RPC视为hearbeat,很多同学假设AppendEntry RPC是某种特殊的RPC,尤其是很多人是指简单的reset计时器，然后返回success，而不进行任何的冲突检测，接受accept就承认follower承认没有冲突，leader根据返回的response来提交logEntry,另外一个问题就是，follower根据收到冲突的prevLogIndex，就会删掉那个点的log，然后吧entries直接进行复制。\n> If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.\n\n这里的if很关键。如果跟随者拥有领导者发送的所有条目，跟随者必须不截断其日志。任何跟随领导者发送的条目的元素都必须被保留。这是因为我们可能从领导者那里收到了一个过时的AppendEntries RPC，而截断日志将意味着 \"收回\"我们可能已经告诉领导者我们的日志中的条目。\n\n## Debugging Raft\n\n第一版的实现肯定是问题百出,我们需要慢慢的迭代实现,问题大致有如下几点，通常有如下四种主要的bugs`活锁`，`不正确或者不完整的RPC`,`fail_follow_rule`,`term confusion`,还有`死锁`\n\n### 活锁\n\n当你的系统活锁时，你系统中的每个节点都在做一些事情，但你的节点集体处于这样一种状态，没有任何进展。这种情况在Raft中很容易发生，尤其是当你没有虔诚地遵循图2时。有一种活锁情况特别经常出现；没有选举领导人，或者一旦选举了领导人，其他节点又开始选举，迫使最近当选的领导人立即退位。  \n\n出现这种情况的原因有很多，但有几个错误是我们看到无数学生犯的。\n\n- 确保你在图2说的时候准确地重置你的选举计时器。具体来说，你只应该在以下情况下重启你的选举计时器：a）你从当前的领导者那里得到一个AppendEntries RPC（即，如果AppendEntries参数中的term已经过时，你不应该重启你的计时器）；b）你正在开始一个选举；或者c）你授予另一个candidate(requestVote RPC)一个投票。最后一种情况在不可靠的网络中尤其重要，因为在这种网络中，跟随者很可能有不同的日志；在这些情况下，你最终往往只有少数服务器，而大多数服务器都愿意为其投票。如果你每当有人要求你为他投票时就重置选举计时器，这就使得一个有过时日志的服务器和一个有较长日志的服务器同样有可能站出来。事实上，由于具有足够最新的日志的服务器太少，这些服务器很不可能在正常的情况下举行选举而当选。如果按照图2的规则，拥有较多最新日志的服务器不会被过时的服务器的选举打断，因此更有可能完成选举，成为领导者。\n- 按照图2的指示，你应该何时开始选举。特别要注意的是，如果你是一个候选人（即，你目前正在进行选举），但选举计时器启动了，你应该开始另一次选举。这一点很重要，可以避免系统因RPC的延迟或放弃而停滞。\n- 在处理传入的RPC之前，请确保你遵循 \"服务器规则 \"中的第二条规则。第二条规则指出。\n\n> If RPC request or response contains term T > currentTerm: set currentTerm = T, convert to follower (§5.1)  \n\n例如，如果你已经在当前任期内投票，而传入的RequestVote RPC的任期比你高，你应该首先下台，采用他们的任期（从而重新设置 votedFor），然后处理RPC，这将导致你授予投票权\n\n### 不正确的RPC\n\n尽管图2清楚地说明了每个RPC处理程序应该做什么，但一些细微之处仍然容易被忽略。以下是我们反复看到的一些情况，你应该在你的实现中注意这些情况.  \n\n- 发现不对逻辑的RPC就尽快返回false\n- 发现follower比leader日志少了，follower就返回false，然后将最新index更新给leader的nextIndex\n- leader即使没有发送entry，也要检查prevLogIndex\n- AppendEntries的最后一步（#5）中的min是必要的，它需要用最后一个新条目的索引来计算。仅仅让应用lastApplied和commitIndex之间的日志内容的函数在到达日志的末尾时停止，是不够的。这因为你的日志中可能会有与领导者的日志不同的条目，在领导者发给你的条目之后（这些条目都与你的日志中的条目一致）。因为 #3 决定了你只在有冲突的条目时才截断你的日志，那些条目不会被除，如果 leaderCommit 超出了领导者发给你的条目，你可能会应用不正确的条目。发送高leader commit index和空的entry的RPC就会导致apply出现问题\n- 要完全按照第5.4节中描述的方式实现 \"最新日志\"检查。老老实实的实现，不要只只检查长度!\n\n### 没有按照论文的理论实现raft\n\n虽然Raft论文对如何实现每个RPC处理程序非常明确，但它也没有对一些规则和不变因素的实现进行说明。这些都列在图2右侧的 \"服务器规则 \"部分。虽然其中一些规则是不言自明的，但也有一些需要非常仔细地设计你的应用程序，使其不违反规则.\n\n- 在任何阶段`commitIndex>lastApplied`你都可以直接`apply`log到上层状态机,提交日志的时候不持有锁或者设置数据保护区，保证其他程序不apply日志\n- 将`commitIndex>lastApplied`解耦,每次sentout心跳的时候检查`commitIndex`你必须要等`appendlog`动作完成\n- `AppendEntries`RPC并不是因为log不一致被reject,应该立刻降级为follower,不要更新`nextIndex`，如果这个时候立刻选举你可能会面对数据竞争的问题\n- `commitIndex`不能设置为旧的term，你一定要checklog[N].Term ==currentTerm.这是因为leader不知道follower是否在当前任期提交了日志,Figure 8会详细阐述这个问题\n\n一个常见的混淆是`nextIndex`和`matchIndex`之间的区别。特别是，你可能会观察到`matchIndex` = `nextIndex` - 1，而干脆不实现`matchIndex`。这是不安全的。虽然nextIndex和matchIndex通常在同一时间被更新为类似的值（具体来说，nextIndex = matchIndex + 1），但两者的作用完全不同。它通常是乐观的（我们分享一切），并且只在消极的反应中向后移动。例如，当一个领导者刚刚当选时，`nextIndex`被设置为日志末尾的索引指数。在某种程度上，`nextIndex`是用于性能的--你只需要将这些东西发送给这个peer。  \n\n`matchIndex`是用于安全的。`matchIndex`不能被设置为一个太高的值，因为这可能会导致`commitIndex`被向前移动得太远。这就是为什么`matchIndex`被初始化为-1（也就是说，我们不同意任何前缀），并且只在跟随者肯定地确认AppendEntries RPC时才更新。  \n\n### term混乱(term不稳定)\n\n因为网络导致的RPC过期问题，term混淆是指服务器被来自旧term的RPC所迷惑。一般来说，在收到RPC时，因为图2中的规则确切地说明了当你看到一个旧term时你应该做什么。然而，图2一般没有讨论当你收到旧的RPC回复时你应该做什么。根据经验，我们发现，到目前为止，最简单的做法是首先记录回复中的term(它可能比你当前的term高),然后将当前term与你在原始RPC中发送的term进行比较。如果两者不同，就放弃回复并返回。只有当这两个术term相同时，你才应该继续处理回复。也许你可以通过一些巧妙的协议推理在这里做进一步的优化，但这种方法似乎很有效。而不这样做会导致一条漫长而曲折的血汗、泪水和绝望的道路。  \nNOTE:A节点无论是RV还是AE的RPC,在回复中都要进行与A节点的currenTerm进行比对,如果发现不对，就立即放弃回复并返回。\n\n### 优化\n\nRaft论文包括几个感兴趣的可选功能。在6.824中，我们要求学生实现其中的两个：日志压缩（第7节）和加速日志回溯（第8页的左上方）。前者对于避免日志无限制地增长是必要的，而后者对于使落后的追随者快速更新是有用的。  \n\n这些功能不是 \"核心Raft \"的一部分，因此在论文中没有得到像主要共识协议那样的关注。日志压缩的内容相当全面（在图13中），但遗漏了一些设计细节，如果你太随意地阅读，可能会错过。  \n\n- 当快照应用程序状态时，你需要确保应用程序状态与Raft日志中某个已知索引之后的状态相对应，这意味着应用程序要么需要向Raft传达快照所对应的索引，要么Raft需要推迟应用额外的日志条目，直到快照完成。\n- 该文本没有讨论当服务器崩溃并重新启动时的恢复协议，因为现在涉及到快照。特别是，如果Raft状态和快照是分开提交的，服务器可能会在坚持快照和坚持更新的Raft状态之间崩溃。这是一个问题，因为图13中的第7步决定了快照所覆盖的Raft日志必须被丢弃。如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是在Raft中引入一个持久化状态，记录Raft持久化日志中的第一个条目所对应的 \"真实 \"索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定在日志的头部有哪些元素需要丢弃.  \n-  如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是给Raft引入一个持久化状态，记录Raft持久化日志中的第一个条目对应的 \"真实 \"索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定要丢弃日志头部的哪些元素。  \n\n加速日志回溯的优化是非常不明确的，可能是因为作者认为这对大多数部署来说是不必要的。文本中并没有明确说明领导者应该如何使用从客户端发回的冲突索引和术语来决定使用哪一个NextIndex。我们认为作者可能希望你遵循的协议是。\n\n- 如果一个跟随者的日志中没有prevLogIndex，它应该以conflictIndex = len(log)和conflictTerm = None返回。\n- 如果一个跟随者在其日志中确实有prevLogIndex，但是术语不匹配，它应该返回conflictTerm = log[prevLogIndex].Term，然后在其日志中搜索其条目中术语等于conflictTerm的第一个索引。\n- 在收到冲突响应时，领导者应该首先搜索其日志中的conflictTerm。如果它在日志中找到一个具有该term的条目，它应该将nextIndex设置为其日志中该term的最后一个条目的索引之外的那个索引。\n- 如果它没有找到该术语的条目，它应该设置 nextIndex = conflictIndex。一个半途而废的解决方案是只使用conflictIndex（而忽略conflictTerm），这简化了实现，但这样一来，领导者有时会向跟随者发送更多的日志条目，而不是严格意义上所需要的，以使他们达到最新状态。\n\n## Applications on top of Raft\n\n## AppendIndex\n\n- 2022/08/21\n    etcd的raft模块难得不只是一点点，看来不能直接看它和etcd的整合，尝试着理解那个example开始。一个玩具的raftkv.\n","source":"_posts/MIT6.824/lab2_raft_students_guide.md","raw":"---\ntitle: MIT6.824之lab2_raft_students_guide\ncategories:\n- 分布式\n- MIT6.824\n---\n\n- [二.Students' Guide to Raf文档](#二students-guide-to-raf文档)\n  - [背景](#背景)\n  - [实现raft](#实现raft)\n    - [重要的细节](#重要的细节)\n  - [Debugging Raft](#debugging-raft)\n    - [活锁](#活锁)\n    - [不正确的RPC](#不正确的rpc)\n    - [没有按照论文的理论实现raft](#没有按照论文的理论实现raft)\n    - [term混乱(term不稳定)](#term混乱term不稳定)\n    - [优化](#优化)\n  - [Applications on top of Raft](#applications-on-top-of-raft)\n  - [AppendIndex](#appendindex)\n\n\n# 二.Students' Guide to Raf文档\n\n> https://thesquareplanet.com/blog/students-guide-to-raft/ 原文链接\n\n在过去几个月里，我成为了MIT6.824的一名助教.以往这门课程的实验都是基于paxos实现一致性算法,然后今年(2016),我们决定使用raft,raft的设计理念是\"理解门槛低\"，并且我们也希望这项决定使同学们的生活更简单[在过去的几个月里，我一直是麻省理工学院6.824分布式系统课的教学助理。这门课传统上有一些建立在Paxos共识算法上的实验，但今年，我们决定改用Raft。Raft是 \"设计成易于理解的\"，我们希望这一改变能使学生的生活更轻松]\n\n这篇实验指南,对应着\"教师教学指南\"，印证着我们实验室与raft的journey，也希望对学生更好的理解raft内部运行机制，实现raft分布式协议起到帮助,如果你正在寻找Raft和Paxos的对比，或者raft的教学(pedagogical)分析,请前去阅读《教师教学指南》.文章底部包含一些学生提问的关于raft的共性问题的问题列表。如果你遇到的问题不在那些问题之内，请前去检查Q&A系统，这篇文章非常的长,但是它提出的所有点，都是现实中学生(助教)碰到过的问题，这是一篇值得阅读的文章。\n\n\n## 背景\n\n开始深入研究raft之前,一些前情提要或许是有用的，6.824过去有一些基于用golang实现的Paxos实验，之所以选择go是因为它易于理解和学习的，它非常适合实现高并发，分布式应用(goroutine是特别便利的)，通过这门课程的四门实验课程，学生构建一个容错的，共享key-value存储系统，第一个实验让你构建一个基于log的一致性算法库,第二门实验在一致性算法库上添加了key-value的存储，第三们实验课是实验构建共享的key-value容错集群,使用共享master节点解决集群成员变更，同时第四们实验,学生不得不实现失败和恢复机制，包括磁盘完整和磁盘不完整的情况这个实现曾作为学生默认的最后实验\n\n这些年我们决定使用raft重写所有mit6.824的实验，前三个实验跟以前是相同的,但是删除了第四个已经在raft中实现了关于失败与持久化的实验,这篇文章主要讨论了我们第一个实验的经验，一个直接跟raft相关的的实验，虽然我们也会接触到构建raft之上的应用层,(第二门实验)。\n\n如果想了解raft的简单的运行逻辑，这个[web site](https://raft.github.io/)网站演示的raft协议是最好的文字材料.\n\nraft是一种被设计为容易理解的一致性算法,在容错,性能方面等价于paxos算法,他们的不同点是raft将问题解耦为相对独立的问题,它也在实际的系统中清晰的解决了很多实际问题.我们也希望跟多的读者实现raft,以及构建更多的基于raft一致性系统\n\n这个网站的可视化raft协议提供了很好的主要组件的概括,论文提供了更直观的说明为什么需要这些组件,如果你还没有阅读raft extend 论文,请有限阅读那篇论文然后再阅读这份<<raft指南>>,由于我假设你对raft有了个大致的了解(ps:这段要翻译成\"你对raft有一定程度的熟悉\").\n\n正如其他的分布式一致性协议一样,协议细节有很多的\"坑\",在稳定的状态下,没有节点失效,raft协议就很好理解,可以很直观的理解,可以从上面的可视化网站了解其运行机制,假设没有节点失效,一个leader会最终被选出来,客户端所有发给raft的请求都会最终发送给follower,但是当网络出现通信延迟,网络分区,节点宕机等等假设发生,但是在特定情况下,我们看到有很多bugs一次次的重复出现,由于直接的错误理解和疏忽,当阅读论文的时候,这不是raft独有的,而是所有提出正确复杂分布式系统都存在的问题\n\n## 实现raft\n\nraft论文的figure2是最好的guide，figure2指定每个RPC的工作的方式，当你读完figure2就可以着手实现raft，但是问题也就接踵而至。实际上，figure2是极其严格的，论文中有些叙述是must而不是should，举个例子，你也会有理由重置election timer, 无论什么时候收到 Request vote and Append entry RPC,这两个RPC说明，其他的server其中一个是leader，另一个是candidate在尝试成为leader，这不允许人为干预或者推理。\n> If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate.\n\n他们之间是有很大区别的，之前的实现可能有某些特定场景下有严重的活性问题\n\n\n### 重要的细节\n\nraft会把没有entry的appendEntry的RPC视为hearbeat,很多同学假设AppendEntry RPC是某种特殊的RPC,尤其是很多人是指简单的reset计时器，然后返回success，而不进行任何的冲突检测，接受accept就承认follower承认没有冲突，leader根据返回的response来提交logEntry,另外一个问题就是，follower根据收到冲突的prevLogIndex，就会删掉那个点的log，然后吧entries直接进行复制。\n> If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.\n\n这里的if很关键。如果跟随者拥有领导者发送的所有条目，跟随者必须不截断其日志。任何跟随领导者发送的条目的元素都必须被保留。这是因为我们可能从领导者那里收到了一个过时的AppendEntries RPC，而截断日志将意味着 \"收回\"我们可能已经告诉领导者我们的日志中的条目。\n\n## Debugging Raft\n\n第一版的实现肯定是问题百出,我们需要慢慢的迭代实现,问题大致有如下几点，通常有如下四种主要的bugs`活锁`，`不正确或者不完整的RPC`,`fail_follow_rule`,`term confusion`,还有`死锁`\n\n### 活锁\n\n当你的系统活锁时，你系统中的每个节点都在做一些事情，但你的节点集体处于这样一种状态，没有任何进展。这种情况在Raft中很容易发生，尤其是当你没有虔诚地遵循图2时。有一种活锁情况特别经常出现；没有选举领导人，或者一旦选举了领导人，其他节点又开始选举，迫使最近当选的领导人立即退位。  \n\n出现这种情况的原因有很多，但有几个错误是我们看到无数学生犯的。\n\n- 确保你在图2说的时候准确地重置你的选举计时器。具体来说，你只应该在以下情况下重启你的选举计时器：a）你从当前的领导者那里得到一个AppendEntries RPC（即，如果AppendEntries参数中的term已经过时，你不应该重启你的计时器）；b）你正在开始一个选举；或者c）你授予另一个candidate(requestVote RPC)一个投票。最后一种情况在不可靠的网络中尤其重要，因为在这种网络中，跟随者很可能有不同的日志；在这些情况下，你最终往往只有少数服务器，而大多数服务器都愿意为其投票。如果你每当有人要求你为他投票时就重置选举计时器，这就使得一个有过时日志的服务器和一个有较长日志的服务器同样有可能站出来。事实上，由于具有足够最新的日志的服务器太少，这些服务器很不可能在正常的情况下举行选举而当选。如果按照图2的规则，拥有较多最新日志的服务器不会被过时的服务器的选举打断，因此更有可能完成选举，成为领导者。\n- 按照图2的指示，你应该何时开始选举。特别要注意的是，如果你是一个候选人（即，你目前正在进行选举），但选举计时器启动了，你应该开始另一次选举。这一点很重要，可以避免系统因RPC的延迟或放弃而停滞。\n- 在处理传入的RPC之前，请确保你遵循 \"服务器规则 \"中的第二条规则。第二条规则指出。\n\n> If RPC request or response contains term T > currentTerm: set currentTerm = T, convert to follower (§5.1)  \n\n例如，如果你已经在当前任期内投票，而传入的RequestVote RPC的任期比你高，你应该首先下台，采用他们的任期（从而重新设置 votedFor），然后处理RPC，这将导致你授予投票权\n\n### 不正确的RPC\n\n尽管图2清楚地说明了每个RPC处理程序应该做什么，但一些细微之处仍然容易被忽略。以下是我们反复看到的一些情况，你应该在你的实现中注意这些情况.  \n\n- 发现不对逻辑的RPC就尽快返回false\n- 发现follower比leader日志少了，follower就返回false，然后将最新index更新给leader的nextIndex\n- leader即使没有发送entry，也要检查prevLogIndex\n- AppendEntries的最后一步（#5）中的min是必要的，它需要用最后一个新条目的索引来计算。仅仅让应用lastApplied和commitIndex之间的日志内容的函数在到达日志的末尾时停止，是不够的。这因为你的日志中可能会有与领导者的日志不同的条目，在领导者发给你的条目之后（这些条目都与你的日志中的条目一致）。因为 #3 决定了你只在有冲突的条目时才截断你的日志，那些条目不会被除，如果 leaderCommit 超出了领导者发给你的条目，你可能会应用不正确的条目。发送高leader commit index和空的entry的RPC就会导致apply出现问题\n- 要完全按照第5.4节中描述的方式实现 \"最新日志\"检查。老老实实的实现，不要只只检查长度!\n\n### 没有按照论文的理论实现raft\n\n虽然Raft论文对如何实现每个RPC处理程序非常明确，但它也没有对一些规则和不变因素的实现进行说明。这些都列在图2右侧的 \"服务器规则 \"部分。虽然其中一些规则是不言自明的，但也有一些需要非常仔细地设计你的应用程序，使其不违反规则.\n\n- 在任何阶段`commitIndex>lastApplied`你都可以直接`apply`log到上层状态机,提交日志的时候不持有锁或者设置数据保护区，保证其他程序不apply日志\n- 将`commitIndex>lastApplied`解耦,每次sentout心跳的时候检查`commitIndex`你必须要等`appendlog`动作完成\n- `AppendEntries`RPC并不是因为log不一致被reject,应该立刻降级为follower,不要更新`nextIndex`，如果这个时候立刻选举你可能会面对数据竞争的问题\n- `commitIndex`不能设置为旧的term，你一定要checklog[N].Term ==currentTerm.这是因为leader不知道follower是否在当前任期提交了日志,Figure 8会详细阐述这个问题\n\n一个常见的混淆是`nextIndex`和`matchIndex`之间的区别。特别是，你可能会观察到`matchIndex` = `nextIndex` - 1，而干脆不实现`matchIndex`。这是不安全的。虽然nextIndex和matchIndex通常在同一时间被更新为类似的值（具体来说，nextIndex = matchIndex + 1），但两者的作用完全不同。它通常是乐观的（我们分享一切），并且只在消极的反应中向后移动。例如，当一个领导者刚刚当选时，`nextIndex`被设置为日志末尾的索引指数。在某种程度上，`nextIndex`是用于性能的--你只需要将这些东西发送给这个peer。  \n\n`matchIndex`是用于安全的。`matchIndex`不能被设置为一个太高的值，因为这可能会导致`commitIndex`被向前移动得太远。这就是为什么`matchIndex`被初始化为-1（也就是说，我们不同意任何前缀），并且只在跟随者肯定地确认AppendEntries RPC时才更新。  \n\n### term混乱(term不稳定)\n\n因为网络导致的RPC过期问题，term混淆是指服务器被来自旧term的RPC所迷惑。一般来说，在收到RPC时，因为图2中的规则确切地说明了当你看到一个旧term时你应该做什么。然而，图2一般没有讨论当你收到旧的RPC回复时你应该做什么。根据经验，我们发现，到目前为止，最简单的做法是首先记录回复中的term(它可能比你当前的term高),然后将当前term与你在原始RPC中发送的term进行比较。如果两者不同，就放弃回复并返回。只有当这两个术term相同时，你才应该继续处理回复。也许你可以通过一些巧妙的协议推理在这里做进一步的优化，但这种方法似乎很有效。而不这样做会导致一条漫长而曲折的血汗、泪水和绝望的道路。  \nNOTE:A节点无论是RV还是AE的RPC,在回复中都要进行与A节点的currenTerm进行比对,如果发现不对，就立即放弃回复并返回。\n\n### 优化\n\nRaft论文包括几个感兴趣的可选功能。在6.824中，我们要求学生实现其中的两个：日志压缩（第7节）和加速日志回溯（第8页的左上方）。前者对于避免日志无限制地增长是必要的，而后者对于使落后的追随者快速更新是有用的。  \n\n这些功能不是 \"核心Raft \"的一部分，因此在论文中没有得到像主要共识协议那样的关注。日志压缩的内容相当全面（在图13中），但遗漏了一些设计细节，如果你太随意地阅读，可能会错过。  \n\n- 当快照应用程序状态时，你需要确保应用程序状态与Raft日志中某个已知索引之后的状态相对应，这意味着应用程序要么需要向Raft传达快照所对应的索引，要么Raft需要推迟应用额外的日志条目，直到快照完成。\n- 该文本没有讨论当服务器崩溃并重新启动时的恢复协议，因为现在涉及到快照。特别是，如果Raft状态和快照是分开提交的，服务器可能会在坚持快照和坚持更新的Raft状态之间崩溃。这是一个问题，因为图13中的第7步决定了快照所覆盖的Raft日志必须被丢弃。如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是在Raft中引入一个持久化状态，记录Raft持久化日志中的第一个条目所对应的 \"真实 \"索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定在日志的头部有哪些元素需要丢弃.  \n-  如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是给Raft引入一个持久化状态，记录Raft持久化日志中的第一个条目对应的 \"真实 \"索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定要丢弃日志头部的哪些元素。  \n\n加速日志回溯的优化是非常不明确的，可能是因为作者认为这对大多数部署来说是不必要的。文本中并没有明确说明领导者应该如何使用从客户端发回的冲突索引和术语来决定使用哪一个NextIndex。我们认为作者可能希望你遵循的协议是。\n\n- 如果一个跟随者的日志中没有prevLogIndex，它应该以conflictIndex = len(log)和conflictTerm = None返回。\n- 如果一个跟随者在其日志中确实有prevLogIndex，但是术语不匹配，它应该返回conflictTerm = log[prevLogIndex].Term，然后在其日志中搜索其条目中术语等于conflictTerm的第一个索引。\n- 在收到冲突响应时，领导者应该首先搜索其日志中的conflictTerm。如果它在日志中找到一个具有该term的条目，它应该将nextIndex设置为其日志中该term的最后一个条目的索引之外的那个索引。\n- 如果它没有找到该术语的条目，它应该设置 nextIndex = conflictIndex。一个半途而废的解决方案是只使用conflictIndex（而忽略conflictTerm），这简化了实现，但这样一来，领导者有时会向跟随者发送更多的日志条目，而不是严格意义上所需要的，以使他们达到最新状态。\n\n## Applications on top of Raft\n\n## AppendIndex\n\n- 2022/08/21\n    etcd的raft模块难得不只是一点点，看来不能直接看它和etcd的整合，尝试着理解那个example开始。一个玩具的raftkv.\n","slug":"MIT6.824/lab2_raft_students_guide","published":1,"date":"2022-10-05T12:21:56.280Z","updated":"2022-10-07T01:25:12.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5m000ol1dbdmxr6mlb","content":"<ul>\n<li><a href=\"#%E4%BA%8Cstudents-guide-to-raf%E6%96%87%E6%A1%A3\">二.Students’ Guide to Raf文档</a><ul>\n<li><a href=\"#%E8%83%8C%E6%99%AF\">背景</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0raft\">实现raft</a><ul>\n<li><a href=\"#%E9%87%8D%E8%A6%81%E7%9A%84%E7%BB%86%E8%8A%82\">重要的细节</a></li>\n</ul>\n</li>\n<li><a href=\"#debugging-raft\">Debugging Raft</a><ul>\n<li><a href=\"#%E6%B4%BB%E9%94%81\">活锁</a></li>\n<li><a href=\"#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84rpc\">不正确的RPC</a></li>\n<li><a href=\"#%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E8%AE%BA%E6%96%87%E7%9A%84%E7%90%86%E8%AE%BA%E5%AE%9E%E7%8E%B0raft\">没有按照论文的理论实现raft</a></li>\n<li><a href=\"#term%E6%B7%B7%E4%B9%B1term%E4%B8%8D%E7%A8%B3%E5%AE%9A\">term混乱(term不稳定)</a></li>\n<li><a href=\"#%E4%BC%98%E5%8C%96\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"#applications-on-top-of-raft\">Applications on top of Raft</a></li>\n<li><a href=\"#appendindex\">AppendIndex</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"二-Students’-Guide-to-Raf文档\"><a href=\"#二-Students’-Guide-to-Raf文档\" class=\"headerlink\" title=\"二.Students’ Guide to Raf文档\"></a>二.Students’ Guide to Raf文档</h1><blockquote>\n<p><a href=\"https://thesquareplanet.com/blog/students-guide-to-raft/\">https://thesquareplanet.com/blog/students-guide-to-raft/</a> 原文链接</p>\n</blockquote>\n<p>在过去几个月里，我成为了MIT6.824的一名助教.以往这门课程的实验都是基于paxos实现一致性算法,然后今年(2016),我们决定使用raft,raft的设计理念是”理解门槛低”，并且我们也希望这项决定使同学们的生活更简单[在过去的几个月里，我一直是麻省理工学院6.824分布式系统课的教学助理。这门课传统上有一些建立在Paxos共识算法上的实验，但今年，我们决定改用Raft。Raft是 “设计成易于理解的”，我们希望这一改变能使学生的生活更轻松]</p>\n<p>这篇实验指南,对应着”教师教学指南”，印证着我们实验室与raft的journey，也希望对学生更好的理解raft内部运行机制，实现raft分布式协议起到帮助,如果你正在寻找Raft和Paxos的对比，或者raft的教学(pedagogical)分析,请前去阅读《教师教学指南》.文章底部包含一些学生提问的关于raft的共性问题的问题列表。如果你遇到的问题不在那些问题之内，请前去检查Q&amp;A系统，这篇文章非常的长,但是它提出的所有点，都是现实中学生(助教)碰到过的问题，这是一篇值得阅读的文章。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>开始深入研究raft之前,一些前情提要或许是有用的，6.824过去有一些基于用golang实现的Paxos实验，之所以选择go是因为它易于理解和学习的，它非常适合实现高并发，分布式应用(goroutine是特别便利的)，通过这门课程的四门实验课程，学生构建一个容错的，共享key-value存储系统，第一个实验让你构建一个基于log的一致性算法库,第二门实验在一致性算法库上添加了key-value的存储，第三们实验课是实验构建共享的key-value容错集群,使用共享master节点解决集群成员变更，同时第四们实验,学生不得不实现失败和恢复机制，包括磁盘完整和磁盘不完整的情况这个实现曾作为学生默认的最后实验</p>\n<p>这些年我们决定使用raft重写所有mit6.824的实验，前三个实验跟以前是相同的,但是删除了第四个已经在raft中实现了关于失败与持久化的实验,这篇文章主要讨论了我们第一个实验的经验，一个直接跟raft相关的的实验，虽然我们也会接触到构建raft之上的应用层,(第二门实验)。</p>\n<p>如果想了解raft的简单的运行逻辑，这个<a href=\"https://raft.github.io/\">web site</a>网站演示的raft协议是最好的文字材料.</p>\n<p>raft是一种被设计为容易理解的一致性算法,在容错,性能方面等价于paxos算法,他们的不同点是raft将问题解耦为相对独立的问题,它也在实际的系统中清晰的解决了很多实际问题.我们也希望跟多的读者实现raft,以及构建更多的基于raft一致性系统</p>\n<p>这个网站的可视化raft协议提供了很好的主要组件的概括,论文提供了更直观的说明为什么需要这些组件,如果你还没有阅读raft extend 论文,请有限阅读那篇论文然后再阅读这份&lt;&lt;raft指南&gt;&gt;,由于我假设你对raft有了个大致的了解(ps:这段要翻译成”你对raft有一定程度的熟悉”).</p>\n<p>正如其他的分布式一致性协议一样,协议细节有很多的”坑”,在稳定的状态下,没有节点失效,raft协议就很好理解,可以很直观的理解,可以从上面的可视化网站了解其运行机制,假设没有节点失效,一个leader会最终被选出来,客户端所有发给raft的请求都会最终发送给follower,但是当网络出现通信延迟,网络分区,节点宕机等等假设发生,但是在特定情况下,我们看到有很多bugs一次次的重复出现,由于直接的错误理解和疏忽,当阅读论文的时候,这不是raft独有的,而是所有提出正确复杂分布式系统都存在的问题</p>\n<h2 id=\"实现raft\"><a href=\"#实现raft\" class=\"headerlink\" title=\"实现raft\"></a>实现raft</h2><p>raft论文的figure2是最好的guide，figure2指定每个RPC的工作的方式，当你读完figure2就可以着手实现raft，但是问题也就接踵而至。实际上，figure2是极其严格的，论文中有些叙述是must而不是should，举个例子，你也会有理由重置election timer, 无论什么时候收到 Request vote and Append entry RPC,这两个RPC说明，其他的server其中一个是leader，另一个是candidate在尝试成为leader，这不允许人为干预或者推理。</p>\n<blockquote>\n<p>If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate.</p>\n</blockquote>\n<p>他们之间是有很大区别的，之前的实现可能有某些特定场景下有严重的活性问题</p>\n<h3 id=\"重要的细节\"><a href=\"#重要的细节\" class=\"headerlink\" title=\"重要的细节\"></a>重要的细节</h3><p>raft会把没有entry的appendEntry的RPC视为hearbeat,很多同学假设AppendEntry RPC是某种特殊的RPC,尤其是很多人是指简单的reset计时器，然后返回success，而不进行任何的冲突检测，接受accept就承认follower承认没有冲突，leader根据返回的response来提交logEntry,另外一个问题就是，follower根据收到冲突的prevLogIndex，就会删掉那个点的log，然后吧entries直接进行复制。</p>\n<blockquote>\n<p>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</p>\n</blockquote>\n<p>这里的if很关键。如果跟随者拥有领导者发送的所有条目，跟随者必须不截断其日志。任何跟随领导者发送的条目的元素都必须被保留。这是因为我们可能从领导者那里收到了一个过时的AppendEntries RPC，而截断日志将意味着 “收回”我们可能已经告诉领导者我们的日志中的条目。</p>\n<h2 id=\"Debugging-Raft\"><a href=\"#Debugging-Raft\" class=\"headerlink\" title=\"Debugging Raft\"></a>Debugging Raft</h2><p>第一版的实现肯定是问题百出,我们需要慢慢的迭代实现,问题大致有如下几点，通常有如下四种主要的bugs<code>活锁</code>，<code>不正确或者不完整的RPC</code>,<code>fail_follow_rule</code>,<code>term confusion</code>,还有<code>死锁</code></p>\n<h3 id=\"活锁\"><a href=\"#活锁\" class=\"headerlink\" title=\"活锁\"></a>活锁</h3><p>当你的系统活锁时，你系统中的每个节点都在做一些事情，但你的节点集体处于这样一种状态，没有任何进展。这种情况在Raft中很容易发生，尤其是当你没有虔诚地遵循图2时。有一种活锁情况特别经常出现；没有选举领导人，或者一旦选举了领导人，其他节点又开始选举，迫使最近当选的领导人立即退位。  </p>\n<p>出现这种情况的原因有很多，但有几个错误是我们看到无数学生犯的。</p>\n<ul>\n<li>确保你在图2说的时候准确地重置你的选举计时器。具体来说，你只应该在以下情况下重启你的选举计时器：a）你从当前的领导者那里得到一个AppendEntries RPC（即，如果AppendEntries参数中的term已经过时，你不应该重启你的计时器）；b）你正在开始一个选举；或者c）你授予另一个candidate(requestVote RPC)一个投票。最后一种情况在不可靠的网络中尤其重要，因为在这种网络中，跟随者很可能有不同的日志；在这些情况下，你最终往往只有少数服务器，而大多数服务器都愿意为其投票。如果你每当有人要求你为他投票时就重置选举计时器，这就使得一个有过时日志的服务器和一个有较长日志的服务器同样有可能站出来。事实上，由于具有足够最新的日志的服务器太少，这些服务器很不可能在正常的情况下举行选举而当选。如果按照图2的规则，拥有较多最新日志的服务器不会被过时的服务器的选举打断，因此更有可能完成选举，成为领导者。</li>\n<li>按照图2的指示，你应该何时开始选举。特别要注意的是，如果你是一个候选人（即，你目前正在进行选举），但选举计时器启动了，你应该开始另一次选举。这一点很重要，可以避免系统因RPC的延迟或放弃而停滞。</li>\n<li>在处理传入的RPC之前，请确保你遵循 “服务器规则 “中的第二条规则。第二条规则指出。</li>\n</ul>\n<blockquote>\n<p>If RPC request or response contains term T &gt; currentTerm: set currentTerm &#x3D; T, convert to follower (§5.1)  </p>\n</blockquote>\n<p>例如，如果你已经在当前任期内投票，而传入的RequestVote RPC的任期比你高，你应该首先下台，采用他们的任期（从而重新设置 votedFor），然后处理RPC，这将导致你授予投票权</p>\n<h3 id=\"不正确的RPC\"><a href=\"#不正确的RPC\" class=\"headerlink\" title=\"不正确的RPC\"></a>不正确的RPC</h3><p>尽管图2清楚地说明了每个RPC处理程序应该做什么，但一些细微之处仍然容易被忽略。以下是我们反复看到的一些情况，你应该在你的实现中注意这些情况.  </p>\n<ul>\n<li>发现不对逻辑的RPC就尽快返回false</li>\n<li>发现follower比leader日志少了，follower就返回false，然后将最新index更新给leader的nextIndex</li>\n<li>leader即使没有发送entry，也要检查prevLogIndex</li>\n<li>AppendEntries的最后一步（#5）中的min是必要的，它需要用最后一个新条目的索引来计算。仅仅让应用lastApplied和commitIndex之间的日志内容的函数在到达日志的末尾时停止，是不够的。这因为你的日志中可能会有与领导者的日志不同的条目，在领导者发给你的条目之后（这些条目都与你的日志中的条目一致）。因为 #3 决定了你只在有冲突的条目时才截断你的日志，那些条目不会被除，如果 leaderCommit 超出了领导者发给你的条目，你可能会应用不正确的条目。发送高leader commit index和空的entry的RPC就会导致apply出现问题</li>\n<li>要完全按照第5.4节中描述的方式实现 “最新日志”检查。老老实实的实现，不要只只检查长度!</li>\n</ul>\n<h3 id=\"没有按照论文的理论实现raft\"><a href=\"#没有按照论文的理论实现raft\" class=\"headerlink\" title=\"没有按照论文的理论实现raft\"></a>没有按照论文的理论实现raft</h3><p>虽然Raft论文对如何实现每个RPC处理程序非常明确，但它也没有对一些规则和不变因素的实现进行说明。这些都列在图2右侧的 “服务器规则 “部分。虽然其中一些规则是不言自明的，但也有一些需要非常仔细地设计你的应用程序，使其不违反规则.</p>\n<ul>\n<li>在任何阶段<code>commitIndex&gt;lastApplied</code>你都可以直接<code>apply</code>log到上层状态机,提交日志的时候不持有锁或者设置数据保护区，保证其他程序不apply日志</li>\n<li>将<code>commitIndex&gt;lastApplied</code>解耦,每次sentout心跳的时候检查<code>commitIndex</code>你必须要等<code>appendlog</code>动作完成</li>\n<li><code>AppendEntries</code>RPC并不是因为log不一致被reject,应该立刻降级为follower,不要更新<code>nextIndex</code>，如果这个时候立刻选举你可能会面对数据竞争的问题</li>\n<li><code>commitIndex</code>不能设置为旧的term，你一定要checklog[N].Term &#x3D;&#x3D;currentTerm.这是因为leader不知道follower是否在当前任期提交了日志,Figure 8会详细阐述这个问题</li>\n</ul>\n<p>一个常见的混淆是<code>nextIndex</code>和<code>matchIndex</code>之间的区别。特别是，你可能会观察到<code>matchIndex</code> &#x3D; <code>nextIndex</code> - 1，而干脆不实现<code>matchIndex</code>。这是不安全的。虽然nextIndex和matchIndex通常在同一时间被更新为类似的值（具体来说，nextIndex &#x3D; matchIndex + 1），但两者的作用完全不同。它通常是乐观的（我们分享一切），并且只在消极的反应中向后移动。例如，当一个领导者刚刚当选时，<code>nextIndex</code>被设置为日志末尾的索引指数。在某种程度上，<code>nextIndex</code>是用于性能的–你只需要将这些东西发送给这个peer。  </p>\n<p><code>matchIndex</code>是用于安全的。<code>matchIndex</code>不能被设置为一个太高的值，因为这可能会导致<code>commitIndex</code>被向前移动得太远。这就是为什么<code>matchIndex</code>被初始化为-1（也就是说，我们不同意任何前缀），并且只在跟随者肯定地确认AppendEntries RPC时才更新。  </p>\n<h3 id=\"term混乱-term不稳定\"><a href=\"#term混乱-term不稳定\" class=\"headerlink\" title=\"term混乱(term不稳定)\"></a>term混乱(term不稳定)</h3><p>因为网络导致的RPC过期问题，term混淆是指服务器被来自旧term的RPC所迷惑。一般来说，在收到RPC时，因为图2中的规则确切地说明了当你看到一个旧term时你应该做什么。然而，图2一般没有讨论当你收到旧的RPC回复时你应该做什么。根据经验，我们发现，到目前为止，最简单的做法是首先记录回复中的term(它可能比你当前的term高),然后将当前term与你在原始RPC中发送的term进行比较。如果两者不同，就放弃回复并返回。只有当这两个术term相同时，你才应该继续处理回复。也许你可以通过一些巧妙的协议推理在这里做进一步的优化，但这种方法似乎很有效。而不这样做会导致一条漫长而曲折的血汗、泪水和绝望的道路。<br>NOTE:A节点无论是RV还是AE的RPC,在回复中都要进行与A节点的currenTerm进行比对,如果发现不对，就立即放弃回复并返回。</p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>Raft论文包括几个感兴趣的可选功能。在6.824中，我们要求学生实现其中的两个：日志压缩（第7节）和加速日志回溯（第8页的左上方）。前者对于避免日志无限制地增长是必要的，而后者对于使落后的追随者快速更新是有用的。  </p>\n<p>这些功能不是 “核心Raft “的一部分，因此在论文中没有得到像主要共识协议那样的关注。日志压缩的内容相当全面（在图13中），但遗漏了一些设计细节，如果你太随意地阅读，可能会错过。  </p>\n<ul>\n<li>当快照应用程序状态时，你需要确保应用程序状态与Raft日志中某个已知索引之后的状态相对应，这意味着应用程序要么需要向Raft传达快照所对应的索引，要么Raft需要推迟应用额外的日志条目，直到快照完成。</li>\n<li>该文本没有讨论当服务器崩溃并重新启动时的恢复协议，因为现在涉及到快照。特别是，如果Raft状态和快照是分开提交的，服务器可能会在坚持快照和坚持更新的Raft状态之间崩溃。这是一个问题，因为图13中的第7步决定了快照所覆盖的Raft日志必须被丢弃。如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是在Raft中引入一个持久化状态，记录Raft持久化日志中的第一个条目所对应的 “真实 “索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定在日志的头部有哪些元素需要丢弃.  </li>\n<li>如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是给Raft引入一个持久化状态，记录Raft持久化日志中的第一个条目对应的 “真实 “索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定要丢弃日志头部的哪些元素。</li>\n</ul>\n<p>加速日志回溯的优化是非常不明确的，可能是因为作者认为这对大多数部署来说是不必要的。文本中并没有明确说明领导者应该如何使用从客户端发回的冲突索引和术语来决定使用哪一个NextIndex。我们认为作者可能希望你遵循的协议是。</p>\n<ul>\n<li>如果一个跟随者的日志中没有prevLogIndex，它应该以conflictIndex &#x3D; len(log)和conflictTerm &#x3D; None返回。</li>\n<li>如果一个跟随者在其日志中确实有prevLogIndex，但是术语不匹配，它应该返回conflictTerm &#x3D; log[prevLogIndex].Term，然后在其日志中搜索其条目中术语等于conflictTerm的第一个索引。</li>\n<li>在收到冲突响应时，领导者应该首先搜索其日志中的conflictTerm。如果它在日志中找到一个具有该term的条目，它应该将nextIndex设置为其日志中该term的最后一个条目的索引之外的那个索引。</li>\n<li>如果它没有找到该术语的条目，它应该设置 nextIndex &#x3D; conflictIndex。一个半途而废的解决方案是只使用conflictIndex（而忽略conflictTerm），这简化了实现，但这样一来，领导者有时会向跟随者发送更多的日志条目，而不是严格意义上所需要的，以使他们达到最新状态。</li>\n</ul>\n<h2 id=\"Applications-on-top-of-Raft\"><a href=\"#Applications-on-top-of-Raft\" class=\"headerlink\" title=\"Applications on top of Raft\"></a>Applications on top of Raft</h2><h2 id=\"AppendIndex\"><a href=\"#AppendIndex\" class=\"headerlink\" title=\"AppendIndex\"></a>AppendIndex</h2><ul>\n<li>2022&#x2F;08&#x2F;21<br>  etcd的raft模块难得不只是一点点，看来不能直接看它和etcd的整合，尝试着理解那个example开始。一个玩具的raftkv.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"#%E4%BA%8Cstudents-guide-to-raf%E6%96%87%E6%A1%A3\">二.Students’ Guide to Raf文档</a><ul>\n<li><a href=\"#%E8%83%8C%E6%99%AF\">背景</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0raft\">实现raft</a><ul>\n<li><a href=\"#%E9%87%8D%E8%A6%81%E7%9A%84%E7%BB%86%E8%8A%82\">重要的细节</a></li>\n</ul>\n</li>\n<li><a href=\"#debugging-raft\">Debugging Raft</a><ul>\n<li><a href=\"#%E6%B4%BB%E9%94%81\">活锁</a></li>\n<li><a href=\"#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84rpc\">不正确的RPC</a></li>\n<li><a href=\"#%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E8%AE%BA%E6%96%87%E7%9A%84%E7%90%86%E8%AE%BA%E5%AE%9E%E7%8E%B0raft\">没有按照论文的理论实现raft</a></li>\n<li><a href=\"#term%E6%B7%B7%E4%B9%B1term%E4%B8%8D%E7%A8%B3%E5%AE%9A\">term混乱(term不稳定)</a></li>\n<li><a href=\"#%E4%BC%98%E5%8C%96\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"#applications-on-top-of-raft\">Applications on top of Raft</a></li>\n<li><a href=\"#appendindex\">AppendIndex</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"二-Students’-Guide-to-Raf文档\"><a href=\"#二-Students’-Guide-to-Raf文档\" class=\"headerlink\" title=\"二.Students’ Guide to Raf文档\"></a>二.Students’ Guide to Raf文档</h1><blockquote>\n<p><a href=\"https://thesquareplanet.com/blog/students-guide-to-raft/\">https://thesquareplanet.com/blog/students-guide-to-raft/</a> 原文链接</p>\n</blockquote>\n<p>在过去几个月里，我成为了MIT6.824的一名助教.以往这门课程的实验都是基于paxos实现一致性算法,然后今年(2016),我们决定使用raft,raft的设计理念是”理解门槛低”，并且我们也希望这项决定使同学们的生活更简单[在过去的几个月里，我一直是麻省理工学院6.824分布式系统课的教学助理。这门课传统上有一些建立在Paxos共识算法上的实验，但今年，我们决定改用Raft。Raft是 “设计成易于理解的”，我们希望这一改变能使学生的生活更轻松]</p>\n<p>这篇实验指南,对应着”教师教学指南”，印证着我们实验室与raft的journey，也希望对学生更好的理解raft内部运行机制，实现raft分布式协议起到帮助,如果你正在寻找Raft和Paxos的对比，或者raft的教学(pedagogical)分析,请前去阅读《教师教学指南》.文章底部包含一些学生提问的关于raft的共性问题的问题列表。如果你遇到的问题不在那些问题之内，请前去检查Q&amp;A系统，这篇文章非常的长,但是它提出的所有点，都是现实中学生(助教)碰到过的问题，这是一篇值得阅读的文章。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>开始深入研究raft之前,一些前情提要或许是有用的，6.824过去有一些基于用golang实现的Paxos实验，之所以选择go是因为它易于理解和学习的，它非常适合实现高并发，分布式应用(goroutine是特别便利的)，通过这门课程的四门实验课程，学生构建一个容错的，共享key-value存储系统，第一个实验让你构建一个基于log的一致性算法库,第二门实验在一致性算法库上添加了key-value的存储，第三们实验课是实验构建共享的key-value容错集群,使用共享master节点解决集群成员变更，同时第四们实验,学生不得不实现失败和恢复机制，包括磁盘完整和磁盘不完整的情况这个实现曾作为学生默认的最后实验</p>\n<p>这些年我们决定使用raft重写所有mit6.824的实验，前三个实验跟以前是相同的,但是删除了第四个已经在raft中实现了关于失败与持久化的实验,这篇文章主要讨论了我们第一个实验的经验，一个直接跟raft相关的的实验，虽然我们也会接触到构建raft之上的应用层,(第二门实验)。</p>\n<p>如果想了解raft的简单的运行逻辑，这个<a href=\"https://raft.github.io/\">web site</a>网站演示的raft协议是最好的文字材料.</p>\n<p>raft是一种被设计为容易理解的一致性算法,在容错,性能方面等价于paxos算法,他们的不同点是raft将问题解耦为相对独立的问题,它也在实际的系统中清晰的解决了很多实际问题.我们也希望跟多的读者实现raft,以及构建更多的基于raft一致性系统</p>\n<p>这个网站的可视化raft协议提供了很好的主要组件的概括,论文提供了更直观的说明为什么需要这些组件,如果你还没有阅读raft extend 论文,请有限阅读那篇论文然后再阅读这份&lt;&lt;raft指南&gt;&gt;,由于我假设你对raft有了个大致的了解(ps:这段要翻译成”你对raft有一定程度的熟悉”).</p>\n<p>正如其他的分布式一致性协议一样,协议细节有很多的”坑”,在稳定的状态下,没有节点失效,raft协议就很好理解,可以很直观的理解,可以从上面的可视化网站了解其运行机制,假设没有节点失效,一个leader会最终被选出来,客户端所有发给raft的请求都会最终发送给follower,但是当网络出现通信延迟,网络分区,节点宕机等等假设发生,但是在特定情况下,我们看到有很多bugs一次次的重复出现,由于直接的错误理解和疏忽,当阅读论文的时候,这不是raft独有的,而是所有提出正确复杂分布式系统都存在的问题</p>\n<h2 id=\"实现raft\"><a href=\"#实现raft\" class=\"headerlink\" title=\"实现raft\"></a>实现raft</h2><p>raft论文的figure2是最好的guide，figure2指定每个RPC的工作的方式，当你读完figure2就可以着手实现raft，但是问题也就接踵而至。实际上，figure2是极其严格的，论文中有些叙述是must而不是should，举个例子，你也会有理由重置election timer, 无论什么时候收到 Request vote and Append entry RPC,这两个RPC说明，其他的server其中一个是leader，另一个是candidate在尝试成为leader，这不允许人为干预或者推理。</p>\n<blockquote>\n<p>If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate.</p>\n</blockquote>\n<p>他们之间是有很大区别的，之前的实现可能有某些特定场景下有严重的活性问题</p>\n<h3 id=\"重要的细节\"><a href=\"#重要的细节\" class=\"headerlink\" title=\"重要的细节\"></a>重要的细节</h3><p>raft会把没有entry的appendEntry的RPC视为hearbeat,很多同学假设AppendEntry RPC是某种特殊的RPC,尤其是很多人是指简单的reset计时器，然后返回success，而不进行任何的冲突检测，接受accept就承认follower承认没有冲突，leader根据返回的response来提交logEntry,另外一个问题就是，follower根据收到冲突的prevLogIndex，就会删掉那个点的log，然后吧entries直接进行复制。</p>\n<blockquote>\n<p>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</p>\n</blockquote>\n<p>这里的if很关键。如果跟随者拥有领导者发送的所有条目，跟随者必须不截断其日志。任何跟随领导者发送的条目的元素都必须被保留。这是因为我们可能从领导者那里收到了一个过时的AppendEntries RPC，而截断日志将意味着 “收回”我们可能已经告诉领导者我们的日志中的条目。</p>\n<h2 id=\"Debugging-Raft\"><a href=\"#Debugging-Raft\" class=\"headerlink\" title=\"Debugging Raft\"></a>Debugging Raft</h2><p>第一版的实现肯定是问题百出,我们需要慢慢的迭代实现,问题大致有如下几点，通常有如下四种主要的bugs<code>活锁</code>，<code>不正确或者不完整的RPC</code>,<code>fail_follow_rule</code>,<code>term confusion</code>,还有<code>死锁</code></p>\n<h3 id=\"活锁\"><a href=\"#活锁\" class=\"headerlink\" title=\"活锁\"></a>活锁</h3><p>当你的系统活锁时，你系统中的每个节点都在做一些事情，但你的节点集体处于这样一种状态，没有任何进展。这种情况在Raft中很容易发生，尤其是当你没有虔诚地遵循图2时。有一种活锁情况特别经常出现；没有选举领导人，或者一旦选举了领导人，其他节点又开始选举，迫使最近当选的领导人立即退位。  </p>\n<p>出现这种情况的原因有很多，但有几个错误是我们看到无数学生犯的。</p>\n<ul>\n<li>确保你在图2说的时候准确地重置你的选举计时器。具体来说，你只应该在以下情况下重启你的选举计时器：a）你从当前的领导者那里得到一个AppendEntries RPC（即，如果AppendEntries参数中的term已经过时，你不应该重启你的计时器）；b）你正在开始一个选举；或者c）你授予另一个candidate(requestVote RPC)一个投票。最后一种情况在不可靠的网络中尤其重要，因为在这种网络中，跟随者很可能有不同的日志；在这些情况下，你最终往往只有少数服务器，而大多数服务器都愿意为其投票。如果你每当有人要求你为他投票时就重置选举计时器，这就使得一个有过时日志的服务器和一个有较长日志的服务器同样有可能站出来。事实上，由于具有足够最新的日志的服务器太少，这些服务器很不可能在正常的情况下举行选举而当选。如果按照图2的规则，拥有较多最新日志的服务器不会被过时的服务器的选举打断，因此更有可能完成选举，成为领导者。</li>\n<li>按照图2的指示，你应该何时开始选举。特别要注意的是，如果你是一个候选人（即，你目前正在进行选举），但选举计时器启动了，你应该开始另一次选举。这一点很重要，可以避免系统因RPC的延迟或放弃而停滞。</li>\n<li>在处理传入的RPC之前，请确保你遵循 “服务器规则 “中的第二条规则。第二条规则指出。</li>\n</ul>\n<blockquote>\n<p>If RPC request or response contains term T &gt; currentTerm: set currentTerm &#x3D; T, convert to follower (§5.1)  </p>\n</blockquote>\n<p>例如，如果你已经在当前任期内投票，而传入的RequestVote RPC的任期比你高，你应该首先下台，采用他们的任期（从而重新设置 votedFor），然后处理RPC，这将导致你授予投票权</p>\n<h3 id=\"不正确的RPC\"><a href=\"#不正确的RPC\" class=\"headerlink\" title=\"不正确的RPC\"></a>不正确的RPC</h3><p>尽管图2清楚地说明了每个RPC处理程序应该做什么，但一些细微之处仍然容易被忽略。以下是我们反复看到的一些情况，你应该在你的实现中注意这些情况.  </p>\n<ul>\n<li>发现不对逻辑的RPC就尽快返回false</li>\n<li>发现follower比leader日志少了，follower就返回false，然后将最新index更新给leader的nextIndex</li>\n<li>leader即使没有发送entry，也要检查prevLogIndex</li>\n<li>AppendEntries的最后一步（#5）中的min是必要的，它需要用最后一个新条目的索引来计算。仅仅让应用lastApplied和commitIndex之间的日志内容的函数在到达日志的末尾时停止，是不够的。这因为你的日志中可能会有与领导者的日志不同的条目，在领导者发给你的条目之后（这些条目都与你的日志中的条目一致）。因为 #3 决定了你只在有冲突的条目时才截断你的日志，那些条目不会被除，如果 leaderCommit 超出了领导者发给你的条目，你可能会应用不正确的条目。发送高leader commit index和空的entry的RPC就会导致apply出现问题</li>\n<li>要完全按照第5.4节中描述的方式实现 “最新日志”检查。老老实实的实现，不要只只检查长度!</li>\n</ul>\n<h3 id=\"没有按照论文的理论实现raft\"><a href=\"#没有按照论文的理论实现raft\" class=\"headerlink\" title=\"没有按照论文的理论实现raft\"></a>没有按照论文的理论实现raft</h3><p>虽然Raft论文对如何实现每个RPC处理程序非常明确，但它也没有对一些规则和不变因素的实现进行说明。这些都列在图2右侧的 “服务器规则 “部分。虽然其中一些规则是不言自明的，但也有一些需要非常仔细地设计你的应用程序，使其不违反规则.</p>\n<ul>\n<li>在任何阶段<code>commitIndex&gt;lastApplied</code>你都可以直接<code>apply</code>log到上层状态机,提交日志的时候不持有锁或者设置数据保护区，保证其他程序不apply日志</li>\n<li>将<code>commitIndex&gt;lastApplied</code>解耦,每次sentout心跳的时候检查<code>commitIndex</code>你必须要等<code>appendlog</code>动作完成</li>\n<li><code>AppendEntries</code>RPC并不是因为log不一致被reject,应该立刻降级为follower,不要更新<code>nextIndex</code>，如果这个时候立刻选举你可能会面对数据竞争的问题</li>\n<li><code>commitIndex</code>不能设置为旧的term，你一定要checklog[N].Term &#x3D;&#x3D;currentTerm.这是因为leader不知道follower是否在当前任期提交了日志,Figure 8会详细阐述这个问题</li>\n</ul>\n<p>一个常见的混淆是<code>nextIndex</code>和<code>matchIndex</code>之间的区别。特别是，你可能会观察到<code>matchIndex</code> &#x3D; <code>nextIndex</code> - 1，而干脆不实现<code>matchIndex</code>。这是不安全的。虽然nextIndex和matchIndex通常在同一时间被更新为类似的值（具体来说，nextIndex &#x3D; matchIndex + 1），但两者的作用完全不同。它通常是乐观的（我们分享一切），并且只在消极的反应中向后移动。例如，当一个领导者刚刚当选时，<code>nextIndex</code>被设置为日志末尾的索引指数。在某种程度上，<code>nextIndex</code>是用于性能的–你只需要将这些东西发送给这个peer。  </p>\n<p><code>matchIndex</code>是用于安全的。<code>matchIndex</code>不能被设置为一个太高的值，因为这可能会导致<code>commitIndex</code>被向前移动得太远。这就是为什么<code>matchIndex</code>被初始化为-1（也就是说，我们不同意任何前缀），并且只在跟随者肯定地确认AppendEntries RPC时才更新。  </p>\n<h3 id=\"term混乱-term不稳定\"><a href=\"#term混乱-term不稳定\" class=\"headerlink\" title=\"term混乱(term不稳定)\"></a>term混乱(term不稳定)</h3><p>因为网络导致的RPC过期问题，term混淆是指服务器被来自旧term的RPC所迷惑。一般来说，在收到RPC时，因为图2中的规则确切地说明了当你看到一个旧term时你应该做什么。然而，图2一般没有讨论当你收到旧的RPC回复时你应该做什么。根据经验，我们发现，到目前为止，最简单的做法是首先记录回复中的term(它可能比你当前的term高),然后将当前term与你在原始RPC中发送的term进行比较。如果两者不同，就放弃回复并返回。只有当这两个术term相同时，你才应该继续处理回复。也许你可以通过一些巧妙的协议推理在这里做进一步的优化，但这种方法似乎很有效。而不这样做会导致一条漫长而曲折的血汗、泪水和绝望的道路。<br>NOTE:A节点无论是RV还是AE的RPC,在回复中都要进行与A节点的currenTerm进行比对,如果发现不对，就立即放弃回复并返回。</p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>Raft论文包括几个感兴趣的可选功能。在6.824中，我们要求学生实现其中的两个：日志压缩（第7节）和加速日志回溯（第8页的左上方）。前者对于避免日志无限制地增长是必要的，而后者对于使落后的追随者快速更新是有用的。  </p>\n<p>这些功能不是 “核心Raft “的一部分，因此在论文中没有得到像主要共识协议那样的关注。日志压缩的内容相当全面（在图13中），但遗漏了一些设计细节，如果你太随意地阅读，可能会错过。  </p>\n<ul>\n<li>当快照应用程序状态时，你需要确保应用程序状态与Raft日志中某个已知索引之后的状态相对应，这意味着应用程序要么需要向Raft传达快照所对应的索引，要么Raft需要推迟应用额外的日志条目，直到快照完成。</li>\n<li>该文本没有讨论当服务器崩溃并重新启动时的恢复协议，因为现在涉及到快照。特别是，如果Raft状态和快照是分开提交的，服务器可能会在坚持快照和坚持更新的Raft状态之间崩溃。这是一个问题，因为图13中的第7步决定了快照所覆盖的Raft日志必须被丢弃。如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是在Raft中引入一个持久化状态，记录Raft持久化日志中的第一个条目所对应的 “真实 “索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定在日志的头部有哪些元素需要丢弃.  </li>\n<li>如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是给Raft引入一个持久化状态，记录Raft持久化日志中的第一个条目对应的 “真实 “索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定要丢弃日志头部的哪些元素。</li>\n</ul>\n<p>加速日志回溯的优化是非常不明确的，可能是因为作者认为这对大多数部署来说是不必要的。文本中并没有明确说明领导者应该如何使用从客户端发回的冲突索引和术语来决定使用哪一个NextIndex。我们认为作者可能希望你遵循的协议是。</p>\n<ul>\n<li>如果一个跟随者的日志中没有prevLogIndex，它应该以conflictIndex &#x3D; len(log)和conflictTerm &#x3D; None返回。</li>\n<li>如果一个跟随者在其日志中确实有prevLogIndex，但是术语不匹配，它应该返回conflictTerm &#x3D; log[prevLogIndex].Term，然后在其日志中搜索其条目中术语等于conflictTerm的第一个索引。</li>\n<li>在收到冲突响应时，领导者应该首先搜索其日志中的conflictTerm。如果它在日志中找到一个具有该term的条目，它应该将nextIndex设置为其日志中该term的最后一个条目的索引之外的那个索引。</li>\n<li>如果它没有找到该术语的条目，它应该设置 nextIndex &#x3D; conflictIndex。一个半途而废的解决方案是只使用conflictIndex（而忽略conflictTerm），这简化了实现，但这样一来，领导者有时会向跟随者发送更多的日志条目，而不是严格意义上所需要的，以使他们达到最新状态。</li>\n</ul>\n<h2 id=\"Applications-on-top-of-Raft\"><a href=\"#Applications-on-top-of-Raft\" class=\"headerlink\" title=\"Applications on top of Raft\"></a>Applications on top of Raft</h2><h2 id=\"AppendIndex\"><a href=\"#AppendIndex\" class=\"headerlink\" title=\"AppendIndex\"></a>AppendIndex</h2><ul>\n<li>2022&#x2F;08&#x2F;21<br>  etcd的raft模块难得不只是一点点，看来不能直接看它和etcd的整合，尝试着理解那个example开始。一个玩具的raftkv.</li>\n</ul>\n"},{"title":"如何提高专注力-How to Get Your Brain to Focus-TED","_content":"\nA few years ago, I began to observe\n几年前 我开始意识到\nsomething in my own behavior\n我的某些行为\nthat made me a bit uncomfortable.\n让我有点不舒服\nAnd that was that from the moment that I woke up\n那就是从我起床的那一刻开始\nto the morning then to the end of the day\n到一天结束\nmy life was a series of screens.\n我的生活充斥着各种屏幕\nI started the day with the thing that woke me up\n早晨第一个叫醒我的是我的手机\nfirst thing in the morning – my phone.\n我的一天就这么开始了\nAnd so I sat there in bed,\n然后我就坐在床上\nwatching various cooking videos on Instagram\n在ins上看各种各样的美食视频\nand bouncing around between a bunch of different applications.\n在不同的APP之间切换\nBut then, it was time to get out of bed and cook breakfast.\n接着 我该起床做早饭了\nAnd so the thing that I focused then on,\n于是我关注的对象\nin addition to the omelette in the pan\n除了锅里的煎鸡蛋\nwas the iPad that was right next to the oven.\n还有烤箱边上的iPad\nAnd then it was time to do some work.\n接下来我该去工作了\nAnd so I went to a different screen,\n我又到了另一个设备前\nwhich was attached to another screen itself.\n这个设备也自带一个屏幕\nAll the while this little devil on my wrist was tapping,\n与此同时 我手腕上的这个小玩意儿 也一直在滴滴答答地响\nand beeping, and blooping, and distracting me\n分散着我的注意力\nas I was trying to get important stuff done.\n让我无法专心完成重要的工作\nBut there was one particular offender\n但是在所有的这些设备中\nout of all of these different devices\n有一样最烦人\nthat I wasted more time on than anything else\n浪费我时间最多\nthat was this dastardly thing – my phone.\n那就是我的手机\nI can spend hours on this thing every single day,\n我每天要在上面耗费好几个小时\nand so I decided to essentially for all intents and purposes\n因此我决定 无论如何\nget rid of the thing for a month.\n要远离手机一个月\nAs an experiment, I thought I’m gonna live on this thing\n作为试验 我把手机使用时间\nfor just 30 minutes every single day at a maximum.\n设置为每天最多30分钟\nAnd so this is the amount of time I have for maps,\n每天就最多用这么多时间来查地图\nthis is the amout of time to call my mother,\n给妈妈打电话\nthis is the amount of time that I have for everything that I could possibly wanna do.\n这就是做所有我需要做的事情的时间\nTo listen to music, to listen to podcast.\n听音乐 听广播\nAnd I obsevered what happened during this time.\n然后我观察这段时间发生的事情\nIt took about a week\n我用了一个星期\nto adjust downward into a new lower level of stimulation.\n才把我的大脑调整到这个低刺激状态\nBut once I did,\n但是我做到了之后\nI noticed that three curious things began to happen.\n三件神奇的事情发生了\nFirst, my attention span grew.\n首先 我的注意力持续时间增加了\nIt was like I could focus on things\n也就是说我能更容易地进入专注状态了\nnot effortlessly but with much more ease\n不说毫不费劲吧 但的确是比\nthan I could before this experiment started.\n试验开始前更容易了\nIn addition to this though, as I was going about the world\n除此之外 当我探索世界时\nand especially when my mind wandered a bit,\n特别是大脑有点走神的时候\nI have more ideas that my mind arrived at.\n我脑海里会涌现出更多的想法\nAnd on top of this\n而且\nI had more plans and thoughts about the future.\n我对未来有了更多的规划和思考\nGetting rid of one simple device led to these three effects.\n远离一个设备 就能带来这三点效果\nWhy?\n为什么呢\nNoticing this, a few years back led me on this long journey\n从几年前注意到这点开始 我花了很长时间\nto get to the bottom of what it takes to focus in a world of distraction.\n研究如何才能专注 避免被其他事物分散注意力\nI poured over hundreds of research papers\n我把成百上千份研究报告铺开\nfrom front to back of my office.\n摊满了我的办公室\nI don’t know if you’ve ever watched one of those crime shows\n不知道大家看没看过刑侦节目\nwhere somebody’s solving a murder\n警察在破解谋杀案时\nand so they have this big bristled board\n他们在一块巨大的 透明板上系着绳子\nand their string attached to papers,\n贴着纸\nattached to memos, attached to newspaper,\n备忘录和报纸\nbut this is like what the state of my office was.\n我的办公室就像那个样子\nI flew out to meet experts around the world who study focus.\n我飞到世界各地 去见研究专注力的专家们\nI conducted more experiments on myself and tell the point.\n我在自己身上做了更多试验 都指向同一点\nI have 25,000 words of research notes about\n我记了两万五千字的研究笔记\nwhy this is the case.\n来分析原因\nHow does technology influence our attention and our ability to focus?\n科技是如何影响我们的注意力和专注力的\nI want to start with the attention spans that we have.\n首先我想讲一讲我们的注意力持续时间\nThis is how we pay attention to the world around us\n也就是我们如何关注身边的世界\nand how much control we have over our focus.\n我们能在多大程度上控制自己的注意力\nThe research around this particular area is fascinating.\n这个领域的研究令人惊叹\nIt turns out that when we to work in front of a computer\n原来 当我们在电脑前工作时\nespecially when our phone is nearby,\n尤其是手机在旁边的时候\nwe focus on one thing for just 40 seconds\n我们专心做一件事的时间只有40秒\nbefore we switch to doing something else.\n然后就会被其它东西转移注意力\nAnd when we have things like Slack open as we are doing some work,\n而如果我们工作时开着Slack软件\nthis lowers to 35 seconds.\n专注时间则会下降到35秒\nBut the reason that this is the case is not\n但是通过这个研究\nwhat we might think after looking at the research.\n我发现原因并不是我们所想的那样\nWe think the problem is that our brains are distracted.\n我们以为是大脑被分散了注意力\nBut after looking at the research this is what I’ve come to know as a symptom\n但在读完研究报告后 我认识到这其实是一种征兆\nfor the deeper problem which runs much more deeply.\n在更深层次的原因之下\nIt’s the root cause of this distraction.\n有一个关键的问题\nIt’s not that we are distracted. It’s that our brains are over stimulated.\n我们的大脑并不是被分散了注意力 而是被过度刺激了\nIt’s that we crave distraction in the first place.\n我们一开始就渴望分心\nOur brains love these tiny little nuggets of\n我们的大脑喜欢这些小想法\ninformation, and social media, and e-mail,\n信息 社交媒体 邮件\nand these things that we do over the course of the day.\n以及一天里我们所做的所有事情\nThere is even a mechanism in our mind called the “novelty bias”\n我们大脑里甚至还有一种机制叫做“新奇偏见”\nby which our mind rewards us with a hit of dopamine,\n大脑会释放多巴胺\none of those wonderful pleasure chemicals,\n一种令人愉悦的化学物质\nthe same one that we get when we eat and order a whole medium pizza from Domino’s,\n我们在吃一整块中份披萨\nthat you know the same one that we get when we make love.\n或者做爱时大脑也会释放同样的多巴胺\nWe get that same stimulation when we check Facebook.\n我们在刷Facebook时也会得到同样的刺激\nWe get these dopamine coursing through our mind and so we not only crave distraction\n这些多巴胺在我们大脑中流动 所以我们不仅想要分神\nbut our mind rewards us for seeking out\n我们大脑还会因为我们的探索而奖励我们\nand finding distraction in the first place.\n并且在第一时间找到让我们分神的东西\nSo this is the state of our minds today.\n这是今天我们大脑的状态\nWe are at these hyper-stimulated state\n在这样一个超级刺激状态下\nwhere we bounce around between this bunch of different objects of attention\n我们的注意力在不同的对象上不断跳跃\nthat are very very stimulating for our mind.\n这对我们大脑刺激很大\nSo I thought, OK, if the phone had this impact on my attention span,\n那么 鉴于手机对我们的注意力有如此大的影响\nwhat if I lowered how stimulated I was even more still.\n如果减少刺激会怎么样呢\nAnd so, you know, this feeling that we experience\n想象一下这种感觉\nwhen we go from being in a state of high stimulation to a state of low stimulation,\n当我们从高刺激状态进入低刺激状态时\nit has a name. That name is called “boredom”.\n这个过程有个名字 叫做厌倦\nYou know this is restlessness that we feel\n你知道这会令我们感到焦躁\nwhen we have this super busy week and then we were lying down a couch on a Sunday afternoon\n忙碌的工作日过后 在一个阳光明媚的下午 躺在沙发上\nand thinking, “What am I doing now?”\n然后想：“我接下来要干嘛呢？”\nSo I challenged to put out a call\n于是我鼓起勇气打了一个电话\nto the readers on my website and I asked them,\n打给我网站的读者 我问他们\n“What is the most boring thing that you can think of doing?\n“你认为你能想到的最无聊的事是什么\nI’m gonna make myself bored for an hour a day for a month.”\n我将在一个月里每天都让自己无聊一个小时”\nAnd so I did some stuff that\n所以接下来我做了这些事情\nI still upset about from my readers to this day.\n我到现在都觉得那天我不该问那些读者\nDay 1 I read the iTunes terms and conditions for one hour.\n第一天我阅读了一个小时iTunes的使用条款\nIt’s actually shorter and more readable than you might think.\n其实这个比你想象中更短 更有意思\nDay 4 I waited on hold of with Air Canada’s baggage claims department.\n第四天我给加拿大航空公司行李认领部门打了电话\nIt’s very easy this is a trick. If you wanna make yourself bored\n当你想要无聊的时候 去搞一个这样的恶作剧是很简单的\ndon’t call the reservations department, call the baggage claim people,\n注意不要打预订部门电话 要打行李认领部门电话\n‘coz you are gonna wait for hours if you ever get through it all.\n不然你将会等一个小时 要是你熬得住的话\nDay 19 I counted all the zeros that I could\n第19天我数了圆周率前一万位中\nin the first ten thousand digits of pi.\n所有零的个数\nDay 24 I watched a clock\n第24天我看一个闹钟\n“tick…tick…” for one hour.\n滴答……滴答……整整一个小时\nAnd 27 other activities this month.\n还有我这个月的其他27个活动\n‘Geeze.’ I still think that.\n现在回想起来都觉得 “哦 天呐”\nBut curiously, I noticed the exact same effects\n但是神奇的是\nas I did during the smartphone experiment.\n这竟和我当初做手机实验时的效果一样\nIt took about a week for my mind\n我花了一周时间\nto adjust downward into a newer lower level of stimulation.\n来把我的大脑调整到低刺激状态\nAnd this map curiously on top of research that shows\n这个实验很神奇的显示了\nthat it takes our mind about 8 days to fully calm down and rest,\n我们的大脑需要花费大约8天的时间才能平静下来\nlike when we are on a vacation as an example.\n就像在度假时一样\nOur vacations need to be longer than they are today.\n我们的假期应该更长一点\nBut I also noticed that my attention span expanded.\n我也发现我的注意力提高了\nI was able to focus even more effortlessly,\n我更容易集中注意力了\nbecause I wasn’t surrounded by fewer distractions,\n因为我不再被那些能使我分心的事物包围\nbut my mind was so much less stimulated\n我的大脑不再处于高刺激状态\nthat it did not seek the distraction in the first place.\n不再容易突然分神\nBut the fun part where these ideas and plans that struck me that didn’t before.\n有趣的是 我还有了之前没有过的一些想法和计划\nAnd the reason that this is the case is because my mind had a chance\n这是因为我的大脑有机会\nto wander more often.\n去思考更多了\nThere is a great quote that I love\n这里有一句我很喜欢的话\nthat you might be familiar with from J.R.R Tolkien,\n你们可能知道这句话 J.R.R.托尔金说的\nwhere he says that, “Not all those who wander are lost.”\n“不是所有踌躇的人都迷失了方向”\nAnd the exact same thing is true.\n确实如此\nIt turns out with regard to our focus with regard to our attention.\n这与我们注意力的集中有关\nIf you think back to when your best most brilliant ideas strike you,\n你回想一下 除非你有一个绝妙的想法\nyou rarely focused on something.\n否则你很少在某件事上集中注意力\nMaybe this morning you were taking a shower,\n可能你在今天早上洗了一个澡\nor maybe some morning in the past and\n或者可能在过去的某一个早晨\nthen your mind had a chance to connect several of the constellations of ideas\n你的脑海里出现了很多的想法\nthat were swirling around in your mind to create an idea\n它会在你思考的时候打乱你\nthat would never have materialized otherwise\n你将永远无法把这些主意具体化\nif you were focused on something else, on your phone, for example.\n如果你一直把你的注意力放在其他东西上 比如手机\nThis is a mode especially when we do this deliberately\n尤其在我们故意这样做的时候 这就变成了一种模式\nwhen we deliberately let our mind wander.\n我们故意让大脑去漫游\nI called this mode “Scatterfocus”.\n我将这种模式称为“分散注意力”\nAnd the research shows that it lets our mind come up with ideas.\n这个研究显示它能令你的大脑产生想法\nIt lets our mind plan because of where our mind wanders to.\n这也能让我们的大脑按我们所想的进行计划\nThis is fascinating.\n这很吸引人\nIt turns out that when we just let our attention at rest,\n它显示了当我们让自己的注意力放松时\nit goes to three main places.\n大脑会做三件事\nWe think about the past.\n回忆过去\nWe think about the present.\n考虑现在\nAnd we think about the future.\n以及思考未来\nBut we think about the past less than we might think,\n但是我们回忆过去的时间要比我们想象的短\nonly about 12% of the time.\n仅占我们所想时间的12%\nAnd often that time we were recalling ideas\n回忆过去通常只是\nin these thoughts wandering episodes.\n一个小插曲\nBut the present, which is a much more productive place to wander.\n因为现在更值得去思考\nWe wandered to think about the present 28% of the time,\n我们用28%的时间来思考现在\nand so this is, you know it’s something as simple as you’re typing up an e-mail.\n就像你在写邮件时\nAnd you can’t find a way to free something\n你找不到办法去放松\nbecause it’s very delicate maybe it’s political.\n因为你需要很小心 可能这封邮件是关于政治的\nYou go and walk to another room,\n你走到其他房间\nyou go to another room of the house, of the office.\n你走到家里或办公室里的其他房间\nThe solution hits you because your mind had a chance to approach it\n你突然就有了解决方法 因为你的大脑有机会\nand prod at that problem from different directions.\n去看到问题的不同方面\nBut here is the thing.\n但有一点\nOur minds wandered to think about the future\n我们的大脑想要思考更多关于未来的事\nmore than the past and the present combined.\n比关于过去和现在的事加起来还要多\nWhenever our mind is wandering we think about the future 48% of the time.\n无论什么时候 我们大脑所想的48%是关于未来的\nThis is why when we were taking a shower we plan out\n这就是为什么我们在洗澡的时候\nour entire day even though it hasn’t started yet.\n会做一整天的计划 尽管这天还没到来\nThis is called our mind’s “prospective bias”\n这叫做“预知偏见”\nand it occurs when our mind wanders.\n并且在我们神游的时候也会出现\nIf you are good with math, or maths I should say,\n如果你数学很好的话\nnot in Canada anymore,\n当然 在加拿大是不可能的\nthese numbers don’t add up to 100\n这些数字很难加到100\nbecause the rest of time our mind is dull.\n由于我们的大脑在某些时间是迟钝的\nIt’s blank or doesn’t have an idea inside of it that is rooted in time.\n所以有时候它会是空白的\nBut whatever it is for you that lets your mind wander,\n但是无论如何 让你的大脑去想\nsomething that is simple,\n一些简单的事情\nsomething that doesn’t consume your full attention.\n不会消耗你全部注意力的事情\nMine happens to be something that is not necessarily stereotypical\n对于我这个年龄和性别来说\nof my age, and gender, demographic.\n我有一些奇怪的癖好\nBut I love to knit.\n我喜欢织毛线\nKnitting is one of my favorite hobbies.\n这是我最大的爱好之一\nI knit in planes. I knit on trains. I knit in hotel rooms.\n我在飞机上 火车上 在宾馆 我都会织\nI was knitting in the hotel room before this event today\n这几天我在住的宾馆里就有织毛线\n‘coz it helps calm you down. It helps settle your nerves.\n因为这能让我平静 能减少焦虑\nAnd I come up with so many ideas when I knit.\n我的许多想法都是织毛线的时候想到的\nI have a notepad next to me.\n我会在旁边放一本记事本\nBut whatever it is for you,\n但对你来说可能是别的\nmight be taking an extra long shower, might be taking a bath,\n可能是洗个很久的淋浴 或是泡澡\nupgrading your shower to a bath,\n将淋浴升级为浴缸\nso you can soak not just with your body but with your ideas as well.\n你浸透的不仅是身体 还有你的思想\nCould be simple if you are at work walking from one room to another in the office.\n工作时从一间办公室走到另外一间\nVery simple change but if you don’t use your phone during that walk,\n虽然很简单 但如果你在走路时不使用手机\nyour mind will go to the meeting that you are about to attend.\n你的头脑将会更专注于即将参加的会议\nIt’ll go to the call that you are just on.\n它会转移到你刚刚接到的那通电话\nIt’ll wander to the ideas that are circulating.\n转移到刚刚盘旋在你脑中的想法\nAnd it’ll make you more creative in this way.\n这样你就变得更有创造力了\nIt could be something as simple as waiting in line,\n这就和排队等候一样简单\nand just, I don’t know, waiting in line.\n就像在排队\nIt could be getting a massage and whatever it is that lets your mind\n可以是做个按摩或者任何能让你大脑放松的事\nI love this picture so much [chuckle]\n我超喜欢这张图\nWhatever you love doing, here is a pro-tip.\n无论你喜欢做什么 给你一个提示\nAsk the masseuse to let you have a notepad in the session,\n在这段时间里叫按摩师给你一个便条\nbecause ideas always come to you and you are always incubating things,\n因为想法一直涌向你 并且你会不断产生新想法\nand so capture them so you can act upon them later.\n抓住它们 这样后面你就能行动起来\nBut I think after doing this deep dive into the research,\n但是在深入研究以后\nwe need to make two fundamental shifts\n我认为我们需要两个基本的转变\nwith regard to how we think about our intention.\n关于如何思考我们的目的\nWe think that we need to fit more in,\n我们认为自己应该更加适应\nyou know, there is all this talk about hustling.\n你知道很多演讲都是关于奋斗的\nI’m an anti-hustler.\n我是一个反对忙碌的人\nI’m one of the laziest people you’ll ever meet,\n我是你们见过最懒的人之一\nand I think that’s what gives me so many ideas to talk and write about.\n我认为这恰好给了我很多想法去说 去写\nWe don’t need to fit more in.\n我们不需要再去适应\nWe are doing enough. We are doing too much.\n我们做的足够了 够多了\nWe are doing so much that our mind never wanders anymore.\n我们做的如此之多 以至于我们的大脑不再漫游\nIt’s sad. This is when our best ideas and plans come to us.\n这很可惜 我们本来可以有更好的想法和计划\nWe need more space.\n我们需要更多空间\nIf you look at what allows traffic to move down the highway,\n看看高速公路 是什么让交通移动\nwhat allows it to move forward isn’t how fast cars are moving as you might expect.\n不是你以为的车在以多么快的速度前进\nIt’s how much spaces exists between the cars\n而是车辆之间存在的空间\nthat allows traffic to move forward.\n这才是让交通向前移动的原因\nOur work and our life are the same way.\n我们的工作和生活也是如此\nThe second shift.\n第二个转变\nWe like to think of distraction as the enemy of focus.\n我们喜欢把三心二意当做全神贯注的敌人\nIt is not.\n不是这样的\nIt is the symptom of why we find it difficult to focus,\n为什么我们很难集中注意力\nwhich is the fact that our mind is over stimulated.\n因为我们大脑被过度刺激了\nI have a challenge for you.\n我给你们一个挑战\nIt’s a two-week challenge,\n一个为期两周的挑战\nbut it’s a challenge to make your mind a bit less stimulated\n这是个能减少对你大脑的刺激\nand simply notice what happens to your attention,\n并且只关注对你注意力影响的挑战\nhow many ideas do you get,\n你有多少想法\nhow does your focus change,\n你的注意力是如何转变的\nhow many plans do you make.\n你制定了多少计划\nSo for two weeks, make your mind less stimulated.\n所以在两周里 让你的大脑少受刺激\nThere are so many great features on phones and devices\n在手机上和其他设备上有如此多的诱惑\nthat will let us eliminate a lot of the time we waste on our devices.\n这会让我们减少大量浪费在这些设备上的时间\nUse those features, not only to become aware of how you spend your time,\n使用这些方法 不仅能让你意识到 自己是如何利用时间的\nbut how you can spend less so you have more ideas.\n而且能让你知道如何产生更多的想法\nHave a disconnection ritual every evening.\n每天来个晚上断网仪式\nOne of my favorite daily rituals I disconnect from internet completely from 8pm to 8am.\n我最喜欢的日常仪式之一 就是晚上八点到早上八点的断网\nMy fiancee and I, we have a weekly disconnection ritual,\n我和我的未婚妻每周都有一个断网仪式\na technology sabbath every Sunday\n每个星期天的科技安息日\nso we can disconnect from the digital world\n这样我们就能与数字世界断开联系\nand reconnect with the physical world, the real actual world.\n与物理世界和现实世界重新连接\nRediscover boredom. You don’t have to do it for an hour.\n重新回归到无聊 你不一定要坚持断网满一个小时\nPlease don’t call our Canada, it’s just a world of help.\n请不要打电话给我们加拿大人 这是一个互相帮助的世界\nBut rediscover boredom, just for a few minutes.\n重新回归到无聊 即使只有几分钟\nLay on the couch and where does your mind go.\n躺在沙发上 跟着自己的想法走\nAnd scatter your attention.\n分散你的注意力\nYou’ll find some remarkably fruitful things, in that attentional zone.\n在那个专注的时间段里 你会收获很多\nIf there is one thing that I’ve found to be true\n在我探索这个世界 关于我们如何集中注意力之后\nafter doing this deep dive into this world on how we focus,\n如果有一件已经被我证实是正确的事情\nit’s that state of our attention is what determines the state of our lives.\n那就是我们注意力的状态决定我们的生活状态\nIf we are distracted in each moment,\n如果我们与每个瞬间断开联系\nthose moments of distraction and over-stimulation build up and accumulate\n这些分心和受到过度刺激的瞬间就会累积\nto create a life that feels more distracted and overwhelming,\n会制造一个更加容易分心并且疲惫的生活\nlike we don’t have a clear direction.\n就像我们失去了明确的方向\nBut, when we become less stimulated, when we make our mind more calm,\n但当我们受到更少的刺激 大脑更加冷静的时候\nwe get the benefits of added productivity and focus on ideas and creativity,\n我们就能够集中想法和创造力 从而得到益处\nbut we also live a better life because of it.\n我们也会因此生活的更好\nThank you so much!\n谢谢大家\n","source":"_posts/TED/如何提高专注力.md","raw":"---\ntitle: 如何提高专注力-How to Get Your Brain to Focus-TED\ncategories:\n- TED\n---\n\nA few years ago, I began to observe\n几年前 我开始意识到\nsomething in my own behavior\n我的某些行为\nthat made me a bit uncomfortable.\n让我有点不舒服\nAnd that was that from the moment that I woke up\n那就是从我起床的那一刻开始\nto the morning then to the end of the day\n到一天结束\nmy life was a series of screens.\n我的生活充斥着各种屏幕\nI started the day with the thing that woke me up\n早晨第一个叫醒我的是我的手机\nfirst thing in the morning – my phone.\n我的一天就这么开始了\nAnd so I sat there in bed,\n然后我就坐在床上\nwatching various cooking videos on Instagram\n在ins上看各种各样的美食视频\nand bouncing around between a bunch of different applications.\n在不同的APP之间切换\nBut then, it was time to get out of bed and cook breakfast.\n接着 我该起床做早饭了\nAnd so the thing that I focused then on,\n于是我关注的对象\nin addition to the omelette in the pan\n除了锅里的煎鸡蛋\nwas the iPad that was right next to the oven.\n还有烤箱边上的iPad\nAnd then it was time to do some work.\n接下来我该去工作了\nAnd so I went to a different screen,\n我又到了另一个设备前\nwhich was attached to another screen itself.\n这个设备也自带一个屏幕\nAll the while this little devil on my wrist was tapping,\n与此同时 我手腕上的这个小玩意儿 也一直在滴滴答答地响\nand beeping, and blooping, and distracting me\n分散着我的注意力\nas I was trying to get important stuff done.\n让我无法专心完成重要的工作\nBut there was one particular offender\n但是在所有的这些设备中\nout of all of these different devices\n有一样最烦人\nthat I wasted more time on than anything else\n浪费我时间最多\nthat was this dastardly thing – my phone.\n那就是我的手机\nI can spend hours on this thing every single day,\n我每天要在上面耗费好几个小时\nand so I decided to essentially for all intents and purposes\n因此我决定 无论如何\nget rid of the thing for a month.\n要远离手机一个月\nAs an experiment, I thought I’m gonna live on this thing\n作为试验 我把手机使用时间\nfor just 30 minutes every single day at a maximum.\n设置为每天最多30分钟\nAnd so this is the amount of time I have for maps,\n每天就最多用这么多时间来查地图\nthis is the amout of time to call my mother,\n给妈妈打电话\nthis is the amount of time that I have for everything that I could possibly wanna do.\n这就是做所有我需要做的事情的时间\nTo listen to music, to listen to podcast.\n听音乐 听广播\nAnd I obsevered what happened during this time.\n然后我观察这段时间发生的事情\nIt took about a week\n我用了一个星期\nto adjust downward into a new lower level of stimulation.\n才把我的大脑调整到这个低刺激状态\nBut once I did,\n但是我做到了之后\nI noticed that three curious things began to happen.\n三件神奇的事情发生了\nFirst, my attention span grew.\n首先 我的注意力持续时间增加了\nIt was like I could focus on things\n也就是说我能更容易地进入专注状态了\nnot effortlessly but with much more ease\n不说毫不费劲吧 但的确是比\nthan I could before this experiment started.\n试验开始前更容易了\nIn addition to this though, as I was going about the world\n除此之外 当我探索世界时\nand especially when my mind wandered a bit,\n特别是大脑有点走神的时候\nI have more ideas that my mind arrived at.\n我脑海里会涌现出更多的想法\nAnd on top of this\n而且\nI had more plans and thoughts about the future.\n我对未来有了更多的规划和思考\nGetting rid of one simple device led to these three effects.\n远离一个设备 就能带来这三点效果\nWhy?\n为什么呢\nNoticing this, a few years back led me on this long journey\n从几年前注意到这点开始 我花了很长时间\nto get to the bottom of what it takes to focus in a world of distraction.\n研究如何才能专注 避免被其他事物分散注意力\nI poured over hundreds of research papers\n我把成百上千份研究报告铺开\nfrom front to back of my office.\n摊满了我的办公室\nI don’t know if you’ve ever watched one of those crime shows\n不知道大家看没看过刑侦节目\nwhere somebody’s solving a murder\n警察在破解谋杀案时\nand so they have this big bristled board\n他们在一块巨大的 透明板上系着绳子\nand their string attached to papers,\n贴着纸\nattached to memos, attached to newspaper,\n备忘录和报纸\nbut this is like what the state of my office was.\n我的办公室就像那个样子\nI flew out to meet experts around the world who study focus.\n我飞到世界各地 去见研究专注力的专家们\nI conducted more experiments on myself and tell the point.\n我在自己身上做了更多试验 都指向同一点\nI have 25,000 words of research notes about\n我记了两万五千字的研究笔记\nwhy this is the case.\n来分析原因\nHow does technology influence our attention and our ability to focus?\n科技是如何影响我们的注意力和专注力的\nI want to start with the attention spans that we have.\n首先我想讲一讲我们的注意力持续时间\nThis is how we pay attention to the world around us\n也就是我们如何关注身边的世界\nand how much control we have over our focus.\n我们能在多大程度上控制自己的注意力\nThe research around this particular area is fascinating.\n这个领域的研究令人惊叹\nIt turns out that when we to work in front of a computer\n原来 当我们在电脑前工作时\nespecially when our phone is nearby,\n尤其是手机在旁边的时候\nwe focus on one thing for just 40 seconds\n我们专心做一件事的时间只有40秒\nbefore we switch to doing something else.\n然后就会被其它东西转移注意力\nAnd when we have things like Slack open as we are doing some work,\n而如果我们工作时开着Slack软件\nthis lowers to 35 seconds.\n专注时间则会下降到35秒\nBut the reason that this is the case is not\n但是通过这个研究\nwhat we might think after looking at the research.\n我发现原因并不是我们所想的那样\nWe think the problem is that our brains are distracted.\n我们以为是大脑被分散了注意力\nBut after looking at the research this is what I’ve come to know as a symptom\n但在读完研究报告后 我认识到这其实是一种征兆\nfor the deeper problem which runs much more deeply.\n在更深层次的原因之下\nIt’s the root cause of this distraction.\n有一个关键的问题\nIt’s not that we are distracted. It’s that our brains are over stimulated.\n我们的大脑并不是被分散了注意力 而是被过度刺激了\nIt’s that we crave distraction in the first place.\n我们一开始就渴望分心\nOur brains love these tiny little nuggets of\n我们的大脑喜欢这些小想法\ninformation, and social media, and e-mail,\n信息 社交媒体 邮件\nand these things that we do over the course of the day.\n以及一天里我们所做的所有事情\nThere is even a mechanism in our mind called the “novelty bias”\n我们大脑里甚至还有一种机制叫做“新奇偏见”\nby which our mind rewards us with a hit of dopamine,\n大脑会释放多巴胺\none of those wonderful pleasure chemicals,\n一种令人愉悦的化学物质\nthe same one that we get when we eat and order a whole medium pizza from Domino’s,\n我们在吃一整块中份披萨\nthat you know the same one that we get when we make love.\n或者做爱时大脑也会释放同样的多巴胺\nWe get that same stimulation when we check Facebook.\n我们在刷Facebook时也会得到同样的刺激\nWe get these dopamine coursing through our mind and so we not only crave distraction\n这些多巴胺在我们大脑中流动 所以我们不仅想要分神\nbut our mind rewards us for seeking out\n我们大脑还会因为我们的探索而奖励我们\nand finding distraction in the first place.\n并且在第一时间找到让我们分神的东西\nSo this is the state of our minds today.\n这是今天我们大脑的状态\nWe are at these hyper-stimulated state\n在这样一个超级刺激状态下\nwhere we bounce around between this bunch of different objects of attention\n我们的注意力在不同的对象上不断跳跃\nthat are very very stimulating for our mind.\n这对我们大脑刺激很大\nSo I thought, OK, if the phone had this impact on my attention span,\n那么 鉴于手机对我们的注意力有如此大的影响\nwhat if I lowered how stimulated I was even more still.\n如果减少刺激会怎么样呢\nAnd so, you know, this feeling that we experience\n想象一下这种感觉\nwhen we go from being in a state of high stimulation to a state of low stimulation,\n当我们从高刺激状态进入低刺激状态时\nit has a name. That name is called “boredom”.\n这个过程有个名字 叫做厌倦\nYou know this is restlessness that we feel\n你知道这会令我们感到焦躁\nwhen we have this super busy week and then we were lying down a couch on a Sunday afternoon\n忙碌的工作日过后 在一个阳光明媚的下午 躺在沙发上\nand thinking, “What am I doing now?”\n然后想：“我接下来要干嘛呢？”\nSo I challenged to put out a call\n于是我鼓起勇气打了一个电话\nto the readers on my website and I asked them,\n打给我网站的读者 我问他们\n“What is the most boring thing that you can think of doing?\n“你认为你能想到的最无聊的事是什么\nI’m gonna make myself bored for an hour a day for a month.”\n我将在一个月里每天都让自己无聊一个小时”\nAnd so I did some stuff that\n所以接下来我做了这些事情\nI still upset about from my readers to this day.\n我到现在都觉得那天我不该问那些读者\nDay 1 I read the iTunes terms and conditions for one hour.\n第一天我阅读了一个小时iTunes的使用条款\nIt’s actually shorter and more readable than you might think.\n其实这个比你想象中更短 更有意思\nDay 4 I waited on hold of with Air Canada’s baggage claims department.\n第四天我给加拿大航空公司行李认领部门打了电话\nIt’s very easy this is a trick. If you wanna make yourself bored\n当你想要无聊的时候 去搞一个这样的恶作剧是很简单的\ndon’t call the reservations department, call the baggage claim people,\n注意不要打预订部门电话 要打行李认领部门电话\n‘coz you are gonna wait for hours if you ever get through it all.\n不然你将会等一个小时 要是你熬得住的话\nDay 19 I counted all the zeros that I could\n第19天我数了圆周率前一万位中\nin the first ten thousand digits of pi.\n所有零的个数\nDay 24 I watched a clock\n第24天我看一个闹钟\n“tick…tick…” for one hour.\n滴答……滴答……整整一个小时\nAnd 27 other activities this month.\n还有我这个月的其他27个活动\n‘Geeze.’ I still think that.\n现在回想起来都觉得 “哦 天呐”\nBut curiously, I noticed the exact same effects\n但是神奇的是\nas I did during the smartphone experiment.\n这竟和我当初做手机实验时的效果一样\nIt took about a week for my mind\n我花了一周时间\nto adjust downward into a newer lower level of stimulation.\n来把我的大脑调整到低刺激状态\nAnd this map curiously on top of research that shows\n这个实验很神奇的显示了\nthat it takes our mind about 8 days to fully calm down and rest,\n我们的大脑需要花费大约8天的时间才能平静下来\nlike when we are on a vacation as an example.\n就像在度假时一样\nOur vacations need to be longer than they are today.\n我们的假期应该更长一点\nBut I also noticed that my attention span expanded.\n我也发现我的注意力提高了\nI was able to focus even more effortlessly,\n我更容易集中注意力了\nbecause I wasn’t surrounded by fewer distractions,\n因为我不再被那些能使我分心的事物包围\nbut my mind was so much less stimulated\n我的大脑不再处于高刺激状态\nthat it did not seek the distraction in the first place.\n不再容易突然分神\nBut the fun part where these ideas and plans that struck me that didn’t before.\n有趣的是 我还有了之前没有过的一些想法和计划\nAnd the reason that this is the case is because my mind had a chance\n这是因为我的大脑有机会\nto wander more often.\n去思考更多了\nThere is a great quote that I love\n这里有一句我很喜欢的话\nthat you might be familiar with from J.R.R Tolkien,\n你们可能知道这句话 J.R.R.托尔金说的\nwhere he says that, “Not all those who wander are lost.”\n“不是所有踌躇的人都迷失了方向”\nAnd the exact same thing is true.\n确实如此\nIt turns out with regard to our focus with regard to our attention.\n这与我们注意力的集中有关\nIf you think back to when your best most brilliant ideas strike you,\n你回想一下 除非你有一个绝妙的想法\nyou rarely focused on something.\n否则你很少在某件事上集中注意力\nMaybe this morning you were taking a shower,\n可能你在今天早上洗了一个澡\nor maybe some morning in the past and\n或者可能在过去的某一个早晨\nthen your mind had a chance to connect several of the constellations of ideas\n你的脑海里出现了很多的想法\nthat were swirling around in your mind to create an idea\n它会在你思考的时候打乱你\nthat would never have materialized otherwise\n你将永远无法把这些主意具体化\nif you were focused on something else, on your phone, for example.\n如果你一直把你的注意力放在其他东西上 比如手机\nThis is a mode especially when we do this deliberately\n尤其在我们故意这样做的时候 这就变成了一种模式\nwhen we deliberately let our mind wander.\n我们故意让大脑去漫游\nI called this mode “Scatterfocus”.\n我将这种模式称为“分散注意力”\nAnd the research shows that it lets our mind come up with ideas.\n这个研究显示它能令你的大脑产生想法\nIt lets our mind plan because of where our mind wanders to.\n这也能让我们的大脑按我们所想的进行计划\nThis is fascinating.\n这很吸引人\nIt turns out that when we just let our attention at rest,\n它显示了当我们让自己的注意力放松时\nit goes to three main places.\n大脑会做三件事\nWe think about the past.\n回忆过去\nWe think about the present.\n考虑现在\nAnd we think about the future.\n以及思考未来\nBut we think about the past less than we might think,\n但是我们回忆过去的时间要比我们想象的短\nonly about 12% of the time.\n仅占我们所想时间的12%\nAnd often that time we were recalling ideas\n回忆过去通常只是\nin these thoughts wandering episodes.\n一个小插曲\nBut the present, which is a much more productive place to wander.\n因为现在更值得去思考\nWe wandered to think about the present 28% of the time,\n我们用28%的时间来思考现在\nand so this is, you know it’s something as simple as you’re typing up an e-mail.\n就像你在写邮件时\nAnd you can’t find a way to free something\n你找不到办法去放松\nbecause it’s very delicate maybe it’s political.\n因为你需要很小心 可能这封邮件是关于政治的\nYou go and walk to another room,\n你走到其他房间\nyou go to another room of the house, of the office.\n你走到家里或办公室里的其他房间\nThe solution hits you because your mind had a chance to approach it\n你突然就有了解决方法 因为你的大脑有机会\nand prod at that problem from different directions.\n去看到问题的不同方面\nBut here is the thing.\n但有一点\nOur minds wandered to think about the future\n我们的大脑想要思考更多关于未来的事\nmore than the past and the present combined.\n比关于过去和现在的事加起来还要多\nWhenever our mind is wandering we think about the future 48% of the time.\n无论什么时候 我们大脑所想的48%是关于未来的\nThis is why when we were taking a shower we plan out\n这就是为什么我们在洗澡的时候\nour entire day even though it hasn’t started yet.\n会做一整天的计划 尽管这天还没到来\nThis is called our mind’s “prospective bias”\n这叫做“预知偏见”\nand it occurs when our mind wanders.\n并且在我们神游的时候也会出现\nIf you are good with math, or maths I should say,\n如果你数学很好的话\nnot in Canada anymore,\n当然 在加拿大是不可能的\nthese numbers don’t add up to 100\n这些数字很难加到100\nbecause the rest of time our mind is dull.\n由于我们的大脑在某些时间是迟钝的\nIt’s blank or doesn’t have an idea inside of it that is rooted in time.\n所以有时候它会是空白的\nBut whatever it is for you that lets your mind wander,\n但是无论如何 让你的大脑去想\nsomething that is simple,\n一些简单的事情\nsomething that doesn’t consume your full attention.\n不会消耗你全部注意力的事情\nMine happens to be something that is not necessarily stereotypical\n对于我这个年龄和性别来说\nof my age, and gender, demographic.\n我有一些奇怪的癖好\nBut I love to knit.\n我喜欢织毛线\nKnitting is one of my favorite hobbies.\n这是我最大的爱好之一\nI knit in planes. I knit on trains. I knit in hotel rooms.\n我在飞机上 火车上 在宾馆 我都会织\nI was knitting in the hotel room before this event today\n这几天我在住的宾馆里就有织毛线\n‘coz it helps calm you down. It helps settle your nerves.\n因为这能让我平静 能减少焦虑\nAnd I come up with so many ideas when I knit.\n我的许多想法都是织毛线的时候想到的\nI have a notepad next to me.\n我会在旁边放一本记事本\nBut whatever it is for you,\n但对你来说可能是别的\nmight be taking an extra long shower, might be taking a bath,\n可能是洗个很久的淋浴 或是泡澡\nupgrading your shower to a bath,\n将淋浴升级为浴缸\nso you can soak not just with your body but with your ideas as well.\n你浸透的不仅是身体 还有你的思想\nCould be simple if you are at work walking from one room to another in the office.\n工作时从一间办公室走到另外一间\nVery simple change but if you don’t use your phone during that walk,\n虽然很简单 但如果你在走路时不使用手机\nyour mind will go to the meeting that you are about to attend.\n你的头脑将会更专注于即将参加的会议\nIt’ll go to the call that you are just on.\n它会转移到你刚刚接到的那通电话\nIt’ll wander to the ideas that are circulating.\n转移到刚刚盘旋在你脑中的想法\nAnd it’ll make you more creative in this way.\n这样你就变得更有创造力了\nIt could be something as simple as waiting in line,\n这就和排队等候一样简单\nand just, I don’t know, waiting in line.\n就像在排队\nIt could be getting a massage and whatever it is that lets your mind\n可以是做个按摩或者任何能让你大脑放松的事\nI love this picture so much [chuckle]\n我超喜欢这张图\nWhatever you love doing, here is a pro-tip.\n无论你喜欢做什么 给你一个提示\nAsk the masseuse to let you have a notepad in the session,\n在这段时间里叫按摩师给你一个便条\nbecause ideas always come to you and you are always incubating things,\n因为想法一直涌向你 并且你会不断产生新想法\nand so capture them so you can act upon them later.\n抓住它们 这样后面你就能行动起来\nBut I think after doing this deep dive into the research,\n但是在深入研究以后\nwe need to make two fundamental shifts\n我认为我们需要两个基本的转变\nwith regard to how we think about our intention.\n关于如何思考我们的目的\nWe think that we need to fit more in,\n我们认为自己应该更加适应\nyou know, there is all this talk about hustling.\n你知道很多演讲都是关于奋斗的\nI’m an anti-hustler.\n我是一个反对忙碌的人\nI’m one of the laziest people you’ll ever meet,\n我是你们见过最懒的人之一\nand I think that’s what gives me so many ideas to talk and write about.\n我认为这恰好给了我很多想法去说 去写\nWe don’t need to fit more in.\n我们不需要再去适应\nWe are doing enough. We are doing too much.\n我们做的足够了 够多了\nWe are doing so much that our mind never wanders anymore.\n我们做的如此之多 以至于我们的大脑不再漫游\nIt’s sad. This is when our best ideas and plans come to us.\n这很可惜 我们本来可以有更好的想法和计划\nWe need more space.\n我们需要更多空间\nIf you look at what allows traffic to move down the highway,\n看看高速公路 是什么让交通移动\nwhat allows it to move forward isn’t how fast cars are moving as you might expect.\n不是你以为的车在以多么快的速度前进\nIt’s how much spaces exists between the cars\n而是车辆之间存在的空间\nthat allows traffic to move forward.\n这才是让交通向前移动的原因\nOur work and our life are the same way.\n我们的工作和生活也是如此\nThe second shift.\n第二个转变\nWe like to think of distraction as the enemy of focus.\n我们喜欢把三心二意当做全神贯注的敌人\nIt is not.\n不是这样的\nIt is the symptom of why we find it difficult to focus,\n为什么我们很难集中注意力\nwhich is the fact that our mind is over stimulated.\n因为我们大脑被过度刺激了\nI have a challenge for you.\n我给你们一个挑战\nIt’s a two-week challenge,\n一个为期两周的挑战\nbut it’s a challenge to make your mind a bit less stimulated\n这是个能减少对你大脑的刺激\nand simply notice what happens to your attention,\n并且只关注对你注意力影响的挑战\nhow many ideas do you get,\n你有多少想法\nhow does your focus change,\n你的注意力是如何转变的\nhow many plans do you make.\n你制定了多少计划\nSo for two weeks, make your mind less stimulated.\n所以在两周里 让你的大脑少受刺激\nThere are so many great features on phones and devices\n在手机上和其他设备上有如此多的诱惑\nthat will let us eliminate a lot of the time we waste on our devices.\n这会让我们减少大量浪费在这些设备上的时间\nUse those features, not only to become aware of how you spend your time,\n使用这些方法 不仅能让你意识到 自己是如何利用时间的\nbut how you can spend less so you have more ideas.\n而且能让你知道如何产生更多的想法\nHave a disconnection ritual every evening.\n每天来个晚上断网仪式\nOne of my favorite daily rituals I disconnect from internet completely from 8pm to 8am.\n我最喜欢的日常仪式之一 就是晚上八点到早上八点的断网\nMy fiancee and I, we have a weekly disconnection ritual,\n我和我的未婚妻每周都有一个断网仪式\na technology sabbath every Sunday\n每个星期天的科技安息日\nso we can disconnect from the digital world\n这样我们就能与数字世界断开联系\nand reconnect with the physical world, the real actual world.\n与物理世界和现实世界重新连接\nRediscover boredom. You don’t have to do it for an hour.\n重新回归到无聊 你不一定要坚持断网满一个小时\nPlease don’t call our Canada, it’s just a world of help.\n请不要打电话给我们加拿大人 这是一个互相帮助的世界\nBut rediscover boredom, just for a few minutes.\n重新回归到无聊 即使只有几分钟\nLay on the couch and where does your mind go.\n躺在沙发上 跟着自己的想法走\nAnd scatter your attention.\n分散你的注意力\nYou’ll find some remarkably fruitful things, in that attentional zone.\n在那个专注的时间段里 你会收获很多\nIf there is one thing that I’ve found to be true\n在我探索这个世界 关于我们如何集中注意力之后\nafter doing this deep dive into this world on how we focus,\n如果有一件已经被我证实是正确的事情\nit’s that state of our attention is what determines the state of our lives.\n那就是我们注意力的状态决定我们的生活状态\nIf we are distracted in each moment,\n如果我们与每个瞬间断开联系\nthose moments of distraction and over-stimulation build up and accumulate\n这些分心和受到过度刺激的瞬间就会累积\nto create a life that feels more distracted and overwhelming,\n会制造一个更加容易分心并且疲惫的生活\nlike we don’t have a clear direction.\n就像我们失去了明确的方向\nBut, when we become less stimulated, when we make our mind more calm,\n但当我们受到更少的刺激 大脑更加冷静的时候\nwe get the benefits of added productivity and focus on ideas and creativity,\n我们就能够集中想法和创造力 从而得到益处\nbut we also live a better life because of it.\n我们也会因此生活的更好\nThank you so much!\n谢谢大家\n","slug":"TED/如何提高专注力","published":1,"date":"2022-06-22T15:10:43.441Z","updated":"2022-09-10T06:17:58.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5n000ql1dbhedccz6b","content":"<p>A few years ago, I began to observe<br>几年前 我开始意识到<br>something in my own behavior<br>我的某些行为<br>that made me a bit uncomfortable.<br>让我有点不舒服<br>And that was that from the moment that I woke up<br>那就是从我起床的那一刻开始<br>to the morning then to the end of the day<br>到一天结束<br>my life was a series of screens.<br>我的生活充斥着各种屏幕<br>I started the day with the thing that woke me up<br>早晨第一个叫醒我的是我的手机<br>first thing in the morning – my phone.<br>我的一天就这么开始了<br>And so I sat there in bed,<br>然后我就坐在床上<br>watching various cooking videos on Instagram<br>在ins上看各种各样的美食视频<br>and bouncing around between a bunch of different applications.<br>在不同的APP之间切换<br>But then, it was time to get out of bed and cook breakfast.<br>接着 我该起床做早饭了<br>And so the thing that I focused then on,<br>于是我关注的对象<br>in addition to the omelette in the pan<br>除了锅里的煎鸡蛋<br>was the iPad that was right next to the oven.<br>还有烤箱边上的iPad<br>And then it was time to do some work.<br>接下来我该去工作了<br>And so I went to a different screen,<br>我又到了另一个设备前<br>which was attached to another screen itself.<br>这个设备也自带一个屏幕<br>All the while this little devil on my wrist was tapping,<br>与此同时 我手腕上的这个小玩意儿 也一直在滴滴答答地响<br>and beeping, and blooping, and distracting me<br>分散着我的注意力<br>as I was trying to get important stuff done.<br>让我无法专心完成重要的工作<br>But there was one particular offender<br>但是在所有的这些设备中<br>out of all of these different devices<br>有一样最烦人<br>that I wasted more time on than anything else<br>浪费我时间最多<br>that was this dastardly thing – my phone.<br>那就是我的手机<br>I can spend hours on this thing every single day,<br>我每天要在上面耗费好几个小时<br>and so I decided to essentially for all intents and purposes<br>因此我决定 无论如何<br>get rid of the thing for a month.<br>要远离手机一个月<br>As an experiment, I thought I’m gonna live on this thing<br>作为试验 我把手机使用时间<br>for just 30 minutes every single day at a maximum.<br>设置为每天最多30分钟<br>And so this is the amount of time I have for maps,<br>每天就最多用这么多时间来查地图<br>this is the amout of time to call my mother,<br>给妈妈打电话<br>this is the amount of time that I have for everything that I could possibly wanna do.<br>这就是做所有我需要做的事情的时间<br>To listen to music, to listen to podcast.<br>听音乐 听广播<br>And I obsevered what happened during this time.<br>然后我观察这段时间发生的事情<br>It took about a week<br>我用了一个星期<br>to adjust downward into a new lower level of stimulation.<br>才把我的大脑调整到这个低刺激状态<br>But once I did,<br>但是我做到了之后<br>I noticed that three curious things began to happen.<br>三件神奇的事情发生了<br>First, my attention span grew.<br>首先 我的注意力持续时间增加了<br>It was like I could focus on things<br>也就是说我能更容易地进入专注状态了<br>not effortlessly but with much more ease<br>不说毫不费劲吧 但的确是比<br>than I could before this experiment started.<br>试验开始前更容易了<br>In addition to this though, as I was going about the world<br>除此之外 当我探索世界时<br>and especially when my mind wandered a bit,<br>特别是大脑有点走神的时候<br>I have more ideas that my mind arrived at.<br>我脑海里会涌现出更多的想法<br>And on top of this<br>而且<br>I had more plans and thoughts about the future.<br>我对未来有了更多的规划和思考<br>Getting rid of one simple device led to these three effects.<br>远离一个设备 就能带来这三点效果<br>Why?<br>为什么呢<br>Noticing this, a few years back led me on this long journey<br>从几年前注意到这点开始 我花了很长时间<br>to get to the bottom of what it takes to focus in a world of distraction.<br>研究如何才能专注 避免被其他事物分散注意力<br>I poured over hundreds of research papers<br>我把成百上千份研究报告铺开<br>from front to back of my office.<br>摊满了我的办公室<br>I don’t know if you’ve ever watched one of those crime shows<br>不知道大家看没看过刑侦节目<br>where somebody’s solving a murder<br>警察在破解谋杀案时<br>and so they have this big bristled board<br>他们在一块巨大的 透明板上系着绳子<br>and their string attached to papers,<br>贴着纸<br>attached to memos, attached to newspaper,<br>备忘录和报纸<br>but this is like what the state of my office was.<br>我的办公室就像那个样子<br>I flew out to meet experts around the world who study focus.<br>我飞到世界各地 去见研究专注力的专家们<br>I conducted more experiments on myself and tell the point.<br>我在自己身上做了更多试验 都指向同一点<br>I have 25,000 words of research notes about<br>我记了两万五千字的研究笔记<br>why this is the case.<br>来分析原因<br>How does technology influence our attention and our ability to focus?<br>科技是如何影响我们的注意力和专注力的<br>I want to start with the attention spans that we have.<br>首先我想讲一讲我们的注意力持续时间<br>This is how we pay attention to the world around us<br>也就是我们如何关注身边的世界<br>and how much control we have over our focus.<br>我们能在多大程度上控制自己的注意力<br>The research around this particular area is fascinating.<br>这个领域的研究令人惊叹<br>It turns out that when we to work in front of a computer<br>原来 当我们在电脑前工作时<br>especially when our phone is nearby,<br>尤其是手机在旁边的时候<br>we focus on one thing for just 40 seconds<br>我们专心做一件事的时间只有40秒<br>before we switch to doing something else.<br>然后就会被其它东西转移注意力<br>And when we have things like Slack open as we are doing some work,<br>而如果我们工作时开着Slack软件<br>this lowers to 35 seconds.<br>专注时间则会下降到35秒<br>But the reason that this is the case is not<br>但是通过这个研究<br>what we might think after looking at the research.<br>我发现原因并不是我们所想的那样<br>We think the problem is that our brains are distracted.<br>我们以为是大脑被分散了注意力<br>But after looking at the research this is what I’ve come to know as a symptom<br>但在读完研究报告后 我认识到这其实是一种征兆<br>for the deeper problem which runs much more deeply.<br>在更深层次的原因之下<br>It’s the root cause of this distraction.<br>有一个关键的问题<br>It’s not that we are distracted. It’s that our brains are over stimulated.<br>我们的大脑并不是被分散了注意力 而是被过度刺激了<br>It’s that we crave distraction in the first place.<br>我们一开始就渴望分心<br>Our brains love these tiny little nuggets of<br>我们的大脑喜欢这些小想法<br>information, and social media, and e-mail,<br>信息 社交媒体 邮件<br>and these things that we do over the course of the day.<br>以及一天里我们所做的所有事情<br>There is even a mechanism in our mind called the “novelty bias”<br>我们大脑里甚至还有一种机制叫做“新奇偏见”<br>by which our mind rewards us with a hit of dopamine,<br>大脑会释放多巴胺<br>one of those wonderful pleasure chemicals,<br>一种令人愉悦的化学物质<br>the same one that we get when we eat and order a whole medium pizza from Domino’s,<br>我们在吃一整块中份披萨<br>that you know the same one that we get when we make love.<br>或者做爱时大脑也会释放同样的多巴胺<br>We get that same stimulation when we check Facebook.<br>我们在刷Facebook时也会得到同样的刺激<br>We get these dopamine coursing through our mind and so we not only crave distraction<br>这些多巴胺在我们大脑中流动 所以我们不仅想要分神<br>but our mind rewards us for seeking out<br>我们大脑还会因为我们的探索而奖励我们<br>and finding distraction in the first place.<br>并且在第一时间找到让我们分神的东西<br>So this is the state of our minds today.<br>这是今天我们大脑的状态<br>We are at these hyper-stimulated state<br>在这样一个超级刺激状态下<br>where we bounce around between this bunch of different objects of attention<br>我们的注意力在不同的对象上不断跳跃<br>that are very very stimulating for our mind.<br>这对我们大脑刺激很大<br>So I thought, OK, if the phone had this impact on my attention span,<br>那么 鉴于手机对我们的注意力有如此大的影响<br>what if I lowered how stimulated I was even more still.<br>如果减少刺激会怎么样呢<br>And so, you know, this feeling that we experience<br>想象一下这种感觉<br>when we go from being in a state of high stimulation to a state of low stimulation,<br>当我们从高刺激状态进入低刺激状态时<br>it has a name. That name is called “boredom”.<br>这个过程有个名字 叫做厌倦<br>You know this is restlessness that we feel<br>你知道这会令我们感到焦躁<br>when we have this super busy week and then we were lying down a couch on a Sunday afternoon<br>忙碌的工作日过后 在一个阳光明媚的下午 躺在沙发上<br>and thinking, “What am I doing now?”<br>然后想：“我接下来要干嘛呢？”<br>So I challenged to put out a call<br>于是我鼓起勇气打了一个电话<br>to the readers on my website and I asked them,<br>打给我网站的读者 我问他们<br>“What is the most boring thing that you can think of doing?<br>“你认为你能想到的最无聊的事是什么<br>I’m gonna make myself bored for an hour a day for a month.”<br>我将在一个月里每天都让自己无聊一个小时”<br>And so I did some stuff that<br>所以接下来我做了这些事情<br>I still upset about from my readers to this day.<br>我到现在都觉得那天我不该问那些读者<br>Day 1 I read the iTunes terms and conditions for one hour.<br>第一天我阅读了一个小时iTunes的使用条款<br>It’s actually shorter and more readable than you might think.<br>其实这个比你想象中更短 更有意思<br>Day 4 I waited on hold of with Air Canada’s baggage claims department.<br>第四天我给加拿大航空公司行李认领部门打了电话<br>It’s very easy this is a trick. If you wanna make yourself bored<br>当你想要无聊的时候 去搞一个这样的恶作剧是很简单的<br>don’t call the reservations department, call the baggage claim people,<br>注意不要打预订部门电话 要打行李认领部门电话<br>‘coz you are gonna wait for hours if you ever get through it all.<br>不然你将会等一个小时 要是你熬得住的话<br>Day 19 I counted all the zeros that I could<br>第19天我数了圆周率前一万位中<br>in the first ten thousand digits of pi.<br>所有零的个数<br>Day 24 I watched a clock<br>第24天我看一个闹钟<br>“tick…tick…” for one hour.<br>滴答……滴答……整整一个小时<br>And 27 other activities this month.<br>还有我这个月的其他27个活动<br>‘Geeze.’ I still think that.<br>现在回想起来都觉得 “哦 天呐”<br>But curiously, I noticed the exact same effects<br>但是神奇的是<br>as I did during the smartphone experiment.<br>这竟和我当初做手机实验时的效果一样<br>It took about a week for my mind<br>我花了一周时间<br>to adjust downward into a newer lower level of stimulation.<br>来把我的大脑调整到低刺激状态<br>And this map curiously on top of research that shows<br>这个实验很神奇的显示了<br>that it takes our mind about 8 days to fully calm down and rest,<br>我们的大脑需要花费大约8天的时间才能平静下来<br>like when we are on a vacation as an example.<br>就像在度假时一样<br>Our vacations need to be longer than they are today.<br>我们的假期应该更长一点<br>But I also noticed that my attention span expanded.<br>我也发现我的注意力提高了<br>I was able to focus even more effortlessly,<br>我更容易集中注意力了<br>because I wasn’t surrounded by fewer distractions,<br>因为我不再被那些能使我分心的事物包围<br>but my mind was so much less stimulated<br>我的大脑不再处于高刺激状态<br>that it did not seek the distraction in the first place.<br>不再容易突然分神<br>But the fun part where these ideas and plans that struck me that didn’t before.<br>有趣的是 我还有了之前没有过的一些想法和计划<br>And the reason that this is the case is because my mind had a chance<br>这是因为我的大脑有机会<br>to wander more often.<br>去思考更多了<br>There is a great quote that I love<br>这里有一句我很喜欢的话<br>that you might be familiar with from J.R.R Tolkien,<br>你们可能知道这句话 J.R.R.托尔金说的<br>where he says that, “Not all those who wander are lost.”<br>“不是所有踌躇的人都迷失了方向”<br>And the exact same thing is true.<br>确实如此<br>It turns out with regard to our focus with regard to our attention.<br>这与我们注意力的集中有关<br>If you think back to when your best most brilliant ideas strike you,<br>你回想一下 除非你有一个绝妙的想法<br>you rarely focused on something.<br>否则你很少在某件事上集中注意力<br>Maybe this morning you were taking a shower,<br>可能你在今天早上洗了一个澡<br>or maybe some morning in the past and<br>或者可能在过去的某一个早晨<br>then your mind had a chance to connect several of the constellations of ideas<br>你的脑海里出现了很多的想法<br>that were swirling around in your mind to create an idea<br>它会在你思考的时候打乱你<br>that would never have materialized otherwise<br>你将永远无法把这些主意具体化<br>if you were focused on something else, on your phone, for example.<br>如果你一直把你的注意力放在其他东西上 比如手机<br>This is a mode especially when we do this deliberately<br>尤其在我们故意这样做的时候 这就变成了一种模式<br>when we deliberately let our mind wander.<br>我们故意让大脑去漫游<br>I called this mode “Scatterfocus”.<br>我将这种模式称为“分散注意力”<br>And the research shows that it lets our mind come up with ideas.<br>这个研究显示它能令你的大脑产生想法<br>It lets our mind plan because of where our mind wanders to.<br>这也能让我们的大脑按我们所想的进行计划<br>This is fascinating.<br>这很吸引人<br>It turns out that when we just let our attention at rest,<br>它显示了当我们让自己的注意力放松时<br>it goes to three main places.<br>大脑会做三件事<br>We think about the past.<br>回忆过去<br>We think about the present.<br>考虑现在<br>And we think about the future.<br>以及思考未来<br>But we think about the past less than we might think,<br>但是我们回忆过去的时间要比我们想象的短<br>only about 12% of the time.<br>仅占我们所想时间的12%<br>And often that time we were recalling ideas<br>回忆过去通常只是<br>in these thoughts wandering episodes.<br>一个小插曲<br>But the present, which is a much more productive place to wander.<br>因为现在更值得去思考<br>We wandered to think about the present 28% of the time,<br>我们用28%的时间来思考现在<br>and so this is, you know it’s something as simple as you’re typing up an e-mail.<br>就像你在写邮件时<br>And you can’t find a way to free something<br>你找不到办法去放松<br>because it’s very delicate maybe it’s political.<br>因为你需要很小心 可能这封邮件是关于政治的<br>You go and walk to another room,<br>你走到其他房间<br>you go to another room of the house, of the office.<br>你走到家里或办公室里的其他房间<br>The solution hits you because your mind had a chance to approach it<br>你突然就有了解决方法 因为你的大脑有机会<br>and prod at that problem from different directions.<br>去看到问题的不同方面<br>But here is the thing.<br>但有一点<br>Our minds wandered to think about the future<br>我们的大脑想要思考更多关于未来的事<br>more than the past and the present combined.<br>比关于过去和现在的事加起来还要多<br>Whenever our mind is wandering we think about the future 48% of the time.<br>无论什么时候 我们大脑所想的48%是关于未来的<br>This is why when we were taking a shower we plan out<br>这就是为什么我们在洗澡的时候<br>our entire day even though it hasn’t started yet.<br>会做一整天的计划 尽管这天还没到来<br>This is called our mind’s “prospective bias”<br>这叫做“预知偏见”<br>and it occurs when our mind wanders.<br>并且在我们神游的时候也会出现<br>If you are good with math, or maths I should say,<br>如果你数学很好的话<br>not in Canada anymore,<br>当然 在加拿大是不可能的<br>these numbers don’t add up to 100<br>这些数字很难加到100<br>because the rest of time our mind is dull.<br>由于我们的大脑在某些时间是迟钝的<br>It’s blank or doesn’t have an idea inside of it that is rooted in time.<br>所以有时候它会是空白的<br>But whatever it is for you that lets your mind wander,<br>但是无论如何 让你的大脑去想<br>something that is simple,<br>一些简单的事情<br>something that doesn’t consume your full attention.<br>不会消耗你全部注意力的事情<br>Mine happens to be something that is not necessarily stereotypical<br>对于我这个年龄和性别来说<br>of my age, and gender, demographic.<br>我有一些奇怪的癖好<br>But I love to knit.<br>我喜欢织毛线<br>Knitting is one of my favorite hobbies.<br>这是我最大的爱好之一<br>I knit in planes. I knit on trains. I knit in hotel rooms.<br>我在飞机上 火车上 在宾馆 我都会织<br>I was knitting in the hotel room before this event today<br>这几天我在住的宾馆里就有织毛线<br>‘coz it helps calm you down. It helps settle your nerves.<br>因为这能让我平静 能减少焦虑<br>And I come up with so many ideas when I knit.<br>我的许多想法都是织毛线的时候想到的<br>I have a notepad next to me.<br>我会在旁边放一本记事本<br>But whatever it is for you,<br>但对你来说可能是别的<br>might be taking an extra long shower, might be taking a bath,<br>可能是洗个很久的淋浴 或是泡澡<br>upgrading your shower to a bath,<br>将淋浴升级为浴缸<br>so you can soak not just with your body but with your ideas as well.<br>你浸透的不仅是身体 还有你的思想<br>Could be simple if you are at work walking from one room to another in the office.<br>工作时从一间办公室走到另外一间<br>Very simple change but if you don’t use your phone during that walk,<br>虽然很简单 但如果你在走路时不使用手机<br>your mind will go to the meeting that you are about to attend.<br>你的头脑将会更专注于即将参加的会议<br>It’ll go to the call that you are just on.<br>它会转移到你刚刚接到的那通电话<br>It’ll wander to the ideas that are circulating.<br>转移到刚刚盘旋在你脑中的想法<br>And it’ll make you more creative in this way.<br>这样你就变得更有创造力了<br>It could be something as simple as waiting in line,<br>这就和排队等候一样简单<br>and just, I don’t know, waiting in line.<br>就像在排队<br>It could be getting a massage and whatever it is that lets your mind<br>可以是做个按摩或者任何能让你大脑放松的事<br>I love this picture so much [chuckle]<br>我超喜欢这张图<br>Whatever you love doing, here is a pro-tip.<br>无论你喜欢做什么 给你一个提示<br>Ask the masseuse to let you have a notepad in the session,<br>在这段时间里叫按摩师给你一个便条<br>because ideas always come to you and you are always incubating things,<br>因为想法一直涌向你 并且你会不断产生新想法<br>and so capture them so you can act upon them later.<br>抓住它们 这样后面你就能行动起来<br>But I think after doing this deep dive into the research,<br>但是在深入研究以后<br>we need to make two fundamental shifts<br>我认为我们需要两个基本的转变<br>with regard to how we think about our intention.<br>关于如何思考我们的目的<br>We think that we need to fit more in,<br>我们认为自己应该更加适应<br>you know, there is all this talk about hustling.<br>你知道很多演讲都是关于奋斗的<br>I’m an anti-hustler.<br>我是一个反对忙碌的人<br>I’m one of the laziest people you’ll ever meet,<br>我是你们见过最懒的人之一<br>and I think that’s what gives me so many ideas to talk and write about.<br>我认为这恰好给了我很多想法去说 去写<br>We don’t need to fit more in.<br>我们不需要再去适应<br>We are doing enough. We are doing too much.<br>我们做的足够了 够多了<br>We are doing so much that our mind never wanders anymore.<br>我们做的如此之多 以至于我们的大脑不再漫游<br>It’s sad. This is when our best ideas and plans come to us.<br>这很可惜 我们本来可以有更好的想法和计划<br>We need more space.<br>我们需要更多空间<br>If you look at what allows traffic to move down the highway,<br>看看高速公路 是什么让交通移动<br>what allows it to move forward isn’t how fast cars are moving as you might expect.<br>不是你以为的车在以多么快的速度前进<br>It’s how much spaces exists between the cars<br>而是车辆之间存在的空间<br>that allows traffic to move forward.<br>这才是让交通向前移动的原因<br>Our work and our life are the same way.<br>我们的工作和生活也是如此<br>The second shift.<br>第二个转变<br>We like to think of distraction as the enemy of focus.<br>我们喜欢把三心二意当做全神贯注的敌人<br>It is not.<br>不是这样的<br>It is the symptom of why we find it difficult to focus,<br>为什么我们很难集中注意力<br>which is the fact that our mind is over stimulated.<br>因为我们大脑被过度刺激了<br>I have a challenge for you.<br>我给你们一个挑战<br>It’s a two-week challenge,<br>一个为期两周的挑战<br>but it’s a challenge to make your mind a bit less stimulated<br>这是个能减少对你大脑的刺激<br>and simply notice what happens to your attention,<br>并且只关注对你注意力影响的挑战<br>how many ideas do you get,<br>你有多少想法<br>how does your focus change,<br>你的注意力是如何转变的<br>how many plans do you make.<br>你制定了多少计划<br>So for two weeks, make your mind less stimulated.<br>所以在两周里 让你的大脑少受刺激<br>There are so many great features on phones and devices<br>在手机上和其他设备上有如此多的诱惑<br>that will let us eliminate a lot of the time we waste on our devices.<br>这会让我们减少大量浪费在这些设备上的时间<br>Use those features, not only to become aware of how you spend your time,<br>使用这些方法 不仅能让你意识到 自己是如何利用时间的<br>but how you can spend less so you have more ideas.<br>而且能让你知道如何产生更多的想法<br>Have a disconnection ritual every evening.<br>每天来个晚上断网仪式<br>One of my favorite daily rituals I disconnect from internet completely from 8pm to 8am.<br>我最喜欢的日常仪式之一 就是晚上八点到早上八点的断网<br>My fiancee and I, we have a weekly disconnection ritual,<br>我和我的未婚妻每周都有一个断网仪式<br>a technology sabbath every Sunday<br>每个星期天的科技安息日<br>so we can disconnect from the digital world<br>这样我们就能与数字世界断开联系<br>and reconnect with the physical world, the real actual world.<br>与物理世界和现实世界重新连接<br>Rediscover boredom. You don’t have to do it for an hour.<br>重新回归到无聊 你不一定要坚持断网满一个小时<br>Please don’t call our Canada, it’s just a world of help.<br>请不要打电话给我们加拿大人 这是一个互相帮助的世界<br>But rediscover boredom, just for a few minutes.<br>重新回归到无聊 即使只有几分钟<br>Lay on the couch and where does your mind go.<br>躺在沙发上 跟着自己的想法走<br>And scatter your attention.<br>分散你的注意力<br>You’ll find some remarkably fruitful things, in that attentional zone.<br>在那个专注的时间段里 你会收获很多<br>If there is one thing that I’ve found to be true<br>在我探索这个世界 关于我们如何集中注意力之后<br>after doing this deep dive into this world on how we focus,<br>如果有一件已经被我证实是正确的事情<br>it’s that state of our attention is what determines the state of our lives.<br>那就是我们注意力的状态决定我们的生活状态<br>If we are distracted in each moment,<br>如果我们与每个瞬间断开联系<br>those moments of distraction and over-stimulation build up and accumulate<br>这些分心和受到过度刺激的瞬间就会累积<br>to create a life that feels more distracted and overwhelming,<br>会制造一个更加容易分心并且疲惫的生活<br>like we don’t have a clear direction.<br>就像我们失去了明确的方向<br>But, when we become less stimulated, when we make our mind more calm,<br>但当我们受到更少的刺激 大脑更加冷静的时候<br>we get the benefits of added productivity and focus on ideas and creativity,<br>我们就能够集中想法和创造力 从而得到益处<br>but we also live a better life because of it.<br>我们也会因此生活的更好<br>Thank you so much!<br>谢谢大家</p>\n","site":{"data":{}},"excerpt":"","more":"<p>A few years ago, I began to observe<br>几年前 我开始意识到<br>something in my own behavior<br>我的某些行为<br>that made me a bit uncomfortable.<br>让我有点不舒服<br>And that was that from the moment that I woke up<br>那就是从我起床的那一刻开始<br>to the morning then to the end of the day<br>到一天结束<br>my life was a series of screens.<br>我的生活充斥着各种屏幕<br>I started the day with the thing that woke me up<br>早晨第一个叫醒我的是我的手机<br>first thing in the morning – my phone.<br>我的一天就这么开始了<br>And so I sat there in bed,<br>然后我就坐在床上<br>watching various cooking videos on Instagram<br>在ins上看各种各样的美食视频<br>and bouncing around between a bunch of different applications.<br>在不同的APP之间切换<br>But then, it was time to get out of bed and cook breakfast.<br>接着 我该起床做早饭了<br>And so the thing that I focused then on,<br>于是我关注的对象<br>in addition to the omelette in the pan<br>除了锅里的煎鸡蛋<br>was the iPad that was right next to the oven.<br>还有烤箱边上的iPad<br>And then it was time to do some work.<br>接下来我该去工作了<br>And so I went to a different screen,<br>我又到了另一个设备前<br>which was attached to another screen itself.<br>这个设备也自带一个屏幕<br>All the while this little devil on my wrist was tapping,<br>与此同时 我手腕上的这个小玩意儿 也一直在滴滴答答地响<br>and beeping, and blooping, and distracting me<br>分散着我的注意力<br>as I was trying to get important stuff done.<br>让我无法专心完成重要的工作<br>But there was one particular offender<br>但是在所有的这些设备中<br>out of all of these different devices<br>有一样最烦人<br>that I wasted more time on than anything else<br>浪费我时间最多<br>that was this dastardly thing – my phone.<br>那就是我的手机<br>I can spend hours on this thing every single day,<br>我每天要在上面耗费好几个小时<br>and so I decided to essentially for all intents and purposes<br>因此我决定 无论如何<br>get rid of the thing for a month.<br>要远离手机一个月<br>As an experiment, I thought I’m gonna live on this thing<br>作为试验 我把手机使用时间<br>for just 30 minutes every single day at a maximum.<br>设置为每天最多30分钟<br>And so this is the amount of time I have for maps,<br>每天就最多用这么多时间来查地图<br>this is the amout of time to call my mother,<br>给妈妈打电话<br>this is the amount of time that I have for everything that I could possibly wanna do.<br>这就是做所有我需要做的事情的时间<br>To listen to music, to listen to podcast.<br>听音乐 听广播<br>And I obsevered what happened during this time.<br>然后我观察这段时间发生的事情<br>It took about a week<br>我用了一个星期<br>to adjust downward into a new lower level of stimulation.<br>才把我的大脑调整到这个低刺激状态<br>But once I did,<br>但是我做到了之后<br>I noticed that three curious things began to happen.<br>三件神奇的事情发生了<br>First, my attention span grew.<br>首先 我的注意力持续时间增加了<br>It was like I could focus on things<br>也就是说我能更容易地进入专注状态了<br>not effortlessly but with much more ease<br>不说毫不费劲吧 但的确是比<br>than I could before this experiment started.<br>试验开始前更容易了<br>In addition to this though, as I was going about the world<br>除此之外 当我探索世界时<br>and especially when my mind wandered a bit,<br>特别是大脑有点走神的时候<br>I have more ideas that my mind arrived at.<br>我脑海里会涌现出更多的想法<br>And on top of this<br>而且<br>I had more plans and thoughts about the future.<br>我对未来有了更多的规划和思考<br>Getting rid of one simple device led to these three effects.<br>远离一个设备 就能带来这三点效果<br>Why?<br>为什么呢<br>Noticing this, a few years back led me on this long journey<br>从几年前注意到这点开始 我花了很长时间<br>to get to the bottom of what it takes to focus in a world of distraction.<br>研究如何才能专注 避免被其他事物分散注意力<br>I poured over hundreds of research papers<br>我把成百上千份研究报告铺开<br>from front to back of my office.<br>摊满了我的办公室<br>I don’t know if you’ve ever watched one of those crime shows<br>不知道大家看没看过刑侦节目<br>where somebody’s solving a murder<br>警察在破解谋杀案时<br>and so they have this big bristled board<br>他们在一块巨大的 透明板上系着绳子<br>and their string attached to papers,<br>贴着纸<br>attached to memos, attached to newspaper,<br>备忘录和报纸<br>but this is like what the state of my office was.<br>我的办公室就像那个样子<br>I flew out to meet experts around the world who study focus.<br>我飞到世界各地 去见研究专注力的专家们<br>I conducted more experiments on myself and tell the point.<br>我在自己身上做了更多试验 都指向同一点<br>I have 25,000 words of research notes about<br>我记了两万五千字的研究笔记<br>why this is the case.<br>来分析原因<br>How does technology influence our attention and our ability to focus?<br>科技是如何影响我们的注意力和专注力的<br>I want to start with the attention spans that we have.<br>首先我想讲一讲我们的注意力持续时间<br>This is how we pay attention to the world around us<br>也就是我们如何关注身边的世界<br>and how much control we have over our focus.<br>我们能在多大程度上控制自己的注意力<br>The research around this particular area is fascinating.<br>这个领域的研究令人惊叹<br>It turns out that when we to work in front of a computer<br>原来 当我们在电脑前工作时<br>especially when our phone is nearby,<br>尤其是手机在旁边的时候<br>we focus on one thing for just 40 seconds<br>我们专心做一件事的时间只有40秒<br>before we switch to doing something else.<br>然后就会被其它东西转移注意力<br>And when we have things like Slack open as we are doing some work,<br>而如果我们工作时开着Slack软件<br>this lowers to 35 seconds.<br>专注时间则会下降到35秒<br>But the reason that this is the case is not<br>但是通过这个研究<br>what we might think after looking at the research.<br>我发现原因并不是我们所想的那样<br>We think the problem is that our brains are distracted.<br>我们以为是大脑被分散了注意力<br>But after looking at the research this is what I’ve come to know as a symptom<br>但在读完研究报告后 我认识到这其实是一种征兆<br>for the deeper problem which runs much more deeply.<br>在更深层次的原因之下<br>It’s the root cause of this distraction.<br>有一个关键的问题<br>It’s not that we are distracted. It’s that our brains are over stimulated.<br>我们的大脑并不是被分散了注意力 而是被过度刺激了<br>It’s that we crave distraction in the first place.<br>我们一开始就渴望分心<br>Our brains love these tiny little nuggets of<br>我们的大脑喜欢这些小想法<br>information, and social media, and e-mail,<br>信息 社交媒体 邮件<br>and these things that we do over the course of the day.<br>以及一天里我们所做的所有事情<br>There is even a mechanism in our mind called the “novelty bias”<br>我们大脑里甚至还有一种机制叫做“新奇偏见”<br>by which our mind rewards us with a hit of dopamine,<br>大脑会释放多巴胺<br>one of those wonderful pleasure chemicals,<br>一种令人愉悦的化学物质<br>the same one that we get when we eat and order a whole medium pizza from Domino’s,<br>我们在吃一整块中份披萨<br>that you know the same one that we get when we make love.<br>或者做爱时大脑也会释放同样的多巴胺<br>We get that same stimulation when we check Facebook.<br>我们在刷Facebook时也会得到同样的刺激<br>We get these dopamine coursing through our mind and so we not only crave distraction<br>这些多巴胺在我们大脑中流动 所以我们不仅想要分神<br>but our mind rewards us for seeking out<br>我们大脑还会因为我们的探索而奖励我们<br>and finding distraction in the first place.<br>并且在第一时间找到让我们分神的东西<br>So this is the state of our minds today.<br>这是今天我们大脑的状态<br>We are at these hyper-stimulated state<br>在这样一个超级刺激状态下<br>where we bounce around between this bunch of different objects of attention<br>我们的注意力在不同的对象上不断跳跃<br>that are very very stimulating for our mind.<br>这对我们大脑刺激很大<br>So I thought, OK, if the phone had this impact on my attention span,<br>那么 鉴于手机对我们的注意力有如此大的影响<br>what if I lowered how stimulated I was even more still.<br>如果减少刺激会怎么样呢<br>And so, you know, this feeling that we experience<br>想象一下这种感觉<br>when we go from being in a state of high stimulation to a state of low stimulation,<br>当我们从高刺激状态进入低刺激状态时<br>it has a name. That name is called “boredom”.<br>这个过程有个名字 叫做厌倦<br>You know this is restlessness that we feel<br>你知道这会令我们感到焦躁<br>when we have this super busy week and then we were lying down a couch on a Sunday afternoon<br>忙碌的工作日过后 在一个阳光明媚的下午 躺在沙发上<br>and thinking, “What am I doing now?”<br>然后想：“我接下来要干嘛呢？”<br>So I challenged to put out a call<br>于是我鼓起勇气打了一个电话<br>to the readers on my website and I asked them,<br>打给我网站的读者 我问他们<br>“What is the most boring thing that you can think of doing?<br>“你认为你能想到的最无聊的事是什么<br>I’m gonna make myself bored for an hour a day for a month.”<br>我将在一个月里每天都让自己无聊一个小时”<br>And so I did some stuff that<br>所以接下来我做了这些事情<br>I still upset about from my readers to this day.<br>我到现在都觉得那天我不该问那些读者<br>Day 1 I read the iTunes terms and conditions for one hour.<br>第一天我阅读了一个小时iTunes的使用条款<br>It’s actually shorter and more readable than you might think.<br>其实这个比你想象中更短 更有意思<br>Day 4 I waited on hold of with Air Canada’s baggage claims department.<br>第四天我给加拿大航空公司行李认领部门打了电话<br>It’s very easy this is a trick. If you wanna make yourself bored<br>当你想要无聊的时候 去搞一个这样的恶作剧是很简单的<br>don’t call the reservations department, call the baggage claim people,<br>注意不要打预订部门电话 要打行李认领部门电话<br>‘coz you are gonna wait for hours if you ever get through it all.<br>不然你将会等一个小时 要是你熬得住的话<br>Day 19 I counted all the zeros that I could<br>第19天我数了圆周率前一万位中<br>in the first ten thousand digits of pi.<br>所有零的个数<br>Day 24 I watched a clock<br>第24天我看一个闹钟<br>“tick…tick…” for one hour.<br>滴答……滴答……整整一个小时<br>And 27 other activities this month.<br>还有我这个月的其他27个活动<br>‘Geeze.’ I still think that.<br>现在回想起来都觉得 “哦 天呐”<br>But curiously, I noticed the exact same effects<br>但是神奇的是<br>as I did during the smartphone experiment.<br>这竟和我当初做手机实验时的效果一样<br>It took about a week for my mind<br>我花了一周时间<br>to adjust downward into a newer lower level of stimulation.<br>来把我的大脑调整到低刺激状态<br>And this map curiously on top of research that shows<br>这个实验很神奇的显示了<br>that it takes our mind about 8 days to fully calm down and rest,<br>我们的大脑需要花费大约8天的时间才能平静下来<br>like when we are on a vacation as an example.<br>就像在度假时一样<br>Our vacations need to be longer than they are today.<br>我们的假期应该更长一点<br>But I also noticed that my attention span expanded.<br>我也发现我的注意力提高了<br>I was able to focus even more effortlessly,<br>我更容易集中注意力了<br>because I wasn’t surrounded by fewer distractions,<br>因为我不再被那些能使我分心的事物包围<br>but my mind was so much less stimulated<br>我的大脑不再处于高刺激状态<br>that it did not seek the distraction in the first place.<br>不再容易突然分神<br>But the fun part where these ideas and plans that struck me that didn’t before.<br>有趣的是 我还有了之前没有过的一些想法和计划<br>And the reason that this is the case is because my mind had a chance<br>这是因为我的大脑有机会<br>to wander more often.<br>去思考更多了<br>There is a great quote that I love<br>这里有一句我很喜欢的话<br>that you might be familiar with from J.R.R Tolkien,<br>你们可能知道这句话 J.R.R.托尔金说的<br>where he says that, “Not all those who wander are lost.”<br>“不是所有踌躇的人都迷失了方向”<br>And the exact same thing is true.<br>确实如此<br>It turns out with regard to our focus with regard to our attention.<br>这与我们注意力的集中有关<br>If you think back to when your best most brilliant ideas strike you,<br>你回想一下 除非你有一个绝妙的想法<br>you rarely focused on something.<br>否则你很少在某件事上集中注意力<br>Maybe this morning you were taking a shower,<br>可能你在今天早上洗了一个澡<br>or maybe some morning in the past and<br>或者可能在过去的某一个早晨<br>then your mind had a chance to connect several of the constellations of ideas<br>你的脑海里出现了很多的想法<br>that were swirling around in your mind to create an idea<br>它会在你思考的时候打乱你<br>that would never have materialized otherwise<br>你将永远无法把这些主意具体化<br>if you were focused on something else, on your phone, for example.<br>如果你一直把你的注意力放在其他东西上 比如手机<br>This is a mode especially when we do this deliberately<br>尤其在我们故意这样做的时候 这就变成了一种模式<br>when we deliberately let our mind wander.<br>我们故意让大脑去漫游<br>I called this mode “Scatterfocus”.<br>我将这种模式称为“分散注意力”<br>And the research shows that it lets our mind come up with ideas.<br>这个研究显示它能令你的大脑产生想法<br>It lets our mind plan because of where our mind wanders to.<br>这也能让我们的大脑按我们所想的进行计划<br>This is fascinating.<br>这很吸引人<br>It turns out that when we just let our attention at rest,<br>它显示了当我们让自己的注意力放松时<br>it goes to three main places.<br>大脑会做三件事<br>We think about the past.<br>回忆过去<br>We think about the present.<br>考虑现在<br>And we think about the future.<br>以及思考未来<br>But we think about the past less than we might think,<br>但是我们回忆过去的时间要比我们想象的短<br>only about 12% of the time.<br>仅占我们所想时间的12%<br>And often that time we were recalling ideas<br>回忆过去通常只是<br>in these thoughts wandering episodes.<br>一个小插曲<br>But the present, which is a much more productive place to wander.<br>因为现在更值得去思考<br>We wandered to think about the present 28% of the time,<br>我们用28%的时间来思考现在<br>and so this is, you know it’s something as simple as you’re typing up an e-mail.<br>就像你在写邮件时<br>And you can’t find a way to free something<br>你找不到办法去放松<br>because it’s very delicate maybe it’s political.<br>因为你需要很小心 可能这封邮件是关于政治的<br>You go and walk to another room,<br>你走到其他房间<br>you go to another room of the house, of the office.<br>你走到家里或办公室里的其他房间<br>The solution hits you because your mind had a chance to approach it<br>你突然就有了解决方法 因为你的大脑有机会<br>and prod at that problem from different directions.<br>去看到问题的不同方面<br>But here is the thing.<br>但有一点<br>Our minds wandered to think about the future<br>我们的大脑想要思考更多关于未来的事<br>more than the past and the present combined.<br>比关于过去和现在的事加起来还要多<br>Whenever our mind is wandering we think about the future 48% of the time.<br>无论什么时候 我们大脑所想的48%是关于未来的<br>This is why when we were taking a shower we plan out<br>这就是为什么我们在洗澡的时候<br>our entire day even though it hasn’t started yet.<br>会做一整天的计划 尽管这天还没到来<br>This is called our mind’s “prospective bias”<br>这叫做“预知偏见”<br>and it occurs when our mind wanders.<br>并且在我们神游的时候也会出现<br>If you are good with math, or maths I should say,<br>如果你数学很好的话<br>not in Canada anymore,<br>当然 在加拿大是不可能的<br>these numbers don’t add up to 100<br>这些数字很难加到100<br>because the rest of time our mind is dull.<br>由于我们的大脑在某些时间是迟钝的<br>It’s blank or doesn’t have an idea inside of it that is rooted in time.<br>所以有时候它会是空白的<br>But whatever it is for you that lets your mind wander,<br>但是无论如何 让你的大脑去想<br>something that is simple,<br>一些简单的事情<br>something that doesn’t consume your full attention.<br>不会消耗你全部注意力的事情<br>Mine happens to be something that is not necessarily stereotypical<br>对于我这个年龄和性别来说<br>of my age, and gender, demographic.<br>我有一些奇怪的癖好<br>But I love to knit.<br>我喜欢织毛线<br>Knitting is one of my favorite hobbies.<br>这是我最大的爱好之一<br>I knit in planes. I knit on trains. I knit in hotel rooms.<br>我在飞机上 火车上 在宾馆 我都会织<br>I was knitting in the hotel room before this event today<br>这几天我在住的宾馆里就有织毛线<br>‘coz it helps calm you down. It helps settle your nerves.<br>因为这能让我平静 能减少焦虑<br>And I come up with so many ideas when I knit.<br>我的许多想法都是织毛线的时候想到的<br>I have a notepad next to me.<br>我会在旁边放一本记事本<br>But whatever it is for you,<br>但对你来说可能是别的<br>might be taking an extra long shower, might be taking a bath,<br>可能是洗个很久的淋浴 或是泡澡<br>upgrading your shower to a bath,<br>将淋浴升级为浴缸<br>so you can soak not just with your body but with your ideas as well.<br>你浸透的不仅是身体 还有你的思想<br>Could be simple if you are at work walking from one room to another in the office.<br>工作时从一间办公室走到另外一间<br>Very simple change but if you don’t use your phone during that walk,<br>虽然很简单 但如果你在走路时不使用手机<br>your mind will go to the meeting that you are about to attend.<br>你的头脑将会更专注于即将参加的会议<br>It’ll go to the call that you are just on.<br>它会转移到你刚刚接到的那通电话<br>It’ll wander to the ideas that are circulating.<br>转移到刚刚盘旋在你脑中的想法<br>And it’ll make you more creative in this way.<br>这样你就变得更有创造力了<br>It could be something as simple as waiting in line,<br>这就和排队等候一样简单<br>and just, I don’t know, waiting in line.<br>就像在排队<br>It could be getting a massage and whatever it is that lets your mind<br>可以是做个按摩或者任何能让你大脑放松的事<br>I love this picture so much [chuckle]<br>我超喜欢这张图<br>Whatever you love doing, here is a pro-tip.<br>无论你喜欢做什么 给你一个提示<br>Ask the masseuse to let you have a notepad in the session,<br>在这段时间里叫按摩师给你一个便条<br>because ideas always come to you and you are always incubating things,<br>因为想法一直涌向你 并且你会不断产生新想法<br>and so capture them so you can act upon them later.<br>抓住它们 这样后面你就能行动起来<br>But I think after doing this deep dive into the research,<br>但是在深入研究以后<br>we need to make two fundamental shifts<br>我认为我们需要两个基本的转变<br>with regard to how we think about our intention.<br>关于如何思考我们的目的<br>We think that we need to fit more in,<br>我们认为自己应该更加适应<br>you know, there is all this talk about hustling.<br>你知道很多演讲都是关于奋斗的<br>I’m an anti-hustler.<br>我是一个反对忙碌的人<br>I’m one of the laziest people you’ll ever meet,<br>我是你们见过最懒的人之一<br>and I think that’s what gives me so many ideas to talk and write about.<br>我认为这恰好给了我很多想法去说 去写<br>We don’t need to fit more in.<br>我们不需要再去适应<br>We are doing enough. We are doing too much.<br>我们做的足够了 够多了<br>We are doing so much that our mind never wanders anymore.<br>我们做的如此之多 以至于我们的大脑不再漫游<br>It’s sad. This is when our best ideas and plans come to us.<br>这很可惜 我们本来可以有更好的想法和计划<br>We need more space.<br>我们需要更多空间<br>If you look at what allows traffic to move down the highway,<br>看看高速公路 是什么让交通移动<br>what allows it to move forward isn’t how fast cars are moving as you might expect.<br>不是你以为的车在以多么快的速度前进<br>It’s how much spaces exists between the cars<br>而是车辆之间存在的空间<br>that allows traffic to move forward.<br>这才是让交通向前移动的原因<br>Our work and our life are the same way.<br>我们的工作和生活也是如此<br>The second shift.<br>第二个转变<br>We like to think of distraction as the enemy of focus.<br>我们喜欢把三心二意当做全神贯注的敌人<br>It is not.<br>不是这样的<br>It is the symptom of why we find it difficult to focus,<br>为什么我们很难集中注意力<br>which is the fact that our mind is over stimulated.<br>因为我们大脑被过度刺激了<br>I have a challenge for you.<br>我给你们一个挑战<br>It’s a two-week challenge,<br>一个为期两周的挑战<br>but it’s a challenge to make your mind a bit less stimulated<br>这是个能减少对你大脑的刺激<br>and simply notice what happens to your attention,<br>并且只关注对你注意力影响的挑战<br>how many ideas do you get,<br>你有多少想法<br>how does your focus change,<br>你的注意力是如何转变的<br>how many plans do you make.<br>你制定了多少计划<br>So for two weeks, make your mind less stimulated.<br>所以在两周里 让你的大脑少受刺激<br>There are so many great features on phones and devices<br>在手机上和其他设备上有如此多的诱惑<br>that will let us eliminate a lot of the time we waste on our devices.<br>这会让我们减少大量浪费在这些设备上的时间<br>Use those features, not only to become aware of how you spend your time,<br>使用这些方法 不仅能让你意识到 自己是如何利用时间的<br>but how you can spend less so you have more ideas.<br>而且能让你知道如何产生更多的想法<br>Have a disconnection ritual every evening.<br>每天来个晚上断网仪式<br>One of my favorite daily rituals I disconnect from internet completely from 8pm to 8am.<br>我最喜欢的日常仪式之一 就是晚上八点到早上八点的断网<br>My fiancee and I, we have a weekly disconnection ritual,<br>我和我的未婚妻每周都有一个断网仪式<br>a technology sabbath every Sunday<br>每个星期天的科技安息日<br>so we can disconnect from the digital world<br>这样我们就能与数字世界断开联系<br>and reconnect with the physical world, the real actual world.<br>与物理世界和现实世界重新连接<br>Rediscover boredom. You don’t have to do it for an hour.<br>重新回归到无聊 你不一定要坚持断网满一个小时<br>Please don’t call our Canada, it’s just a world of help.<br>请不要打电话给我们加拿大人 这是一个互相帮助的世界<br>But rediscover boredom, just for a few minutes.<br>重新回归到无聊 即使只有几分钟<br>Lay on the couch and where does your mind go.<br>躺在沙发上 跟着自己的想法走<br>And scatter your attention.<br>分散你的注意力<br>You’ll find some remarkably fruitful things, in that attentional zone.<br>在那个专注的时间段里 你会收获很多<br>If there is one thing that I’ve found to be true<br>在我探索这个世界 关于我们如何集中注意力之后<br>after doing this deep dive into this world on how we focus,<br>如果有一件已经被我证实是正确的事情<br>it’s that state of our attention is what determines the state of our lives.<br>那就是我们注意力的状态决定我们的生活状态<br>If we are distracted in each moment,<br>如果我们与每个瞬间断开联系<br>those moments of distraction and over-stimulation build up and accumulate<br>这些分心和受到过度刺激的瞬间就会累积<br>to create a life that feels more distracted and overwhelming,<br>会制造一个更加容易分心并且疲惫的生活<br>like we don’t have a clear direction.<br>就像我们失去了明确的方向<br>But, when we become less stimulated, when we make our mind more calm,<br>但当我们受到更少的刺激 大脑更加冷静的时候<br>we get the benefits of added productivity and focus on ideas and creativity,<br>我们就能够集中想法和创造力 从而得到益处<br>but we also live a better life because of it.<br>我们也会因此生活的更好<br>Thank you so much!<br>谢谢大家</p>\n"},{"title":"如何阅读-TED","_content":"\n1.做笔记\n\n2.费曼学习法\n\n​ 写下假设找出知识上的差距。\n3.存档你的笔记\n\n​ 理清框架，并起一个标题\n","source":"_posts/TED/如何阅读.md","raw":"---\ntitle: 如何阅读-TED\ncategories:\n- TED\n---\n\n1.做笔记\n\n2.费曼学习法\n\n​ 写下假设找出知识上的差距。\n3.存档你的笔记\n\n​ 理清框架，并起一个标题\n","slug":"TED/如何阅读","published":1,"date":"2022-06-22T14:05:35.721Z","updated":"2022-06-22T14:56:24.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5o000sl1db7ublg526","content":"<p>1.做笔记</p>\n<p>2.费曼学习法</p>\n<p>​ 写下假设找出知识上的差距。<br>3.存档你的笔记</p>\n<p>​ 理清框架，并起一个标题</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.做笔记</p>\n<p>2.费曼学习法</p>\n<p>​ 写下假设找出知识上的差距。<br>3.存档你的笔记</p>\n<p>​ 理清框架，并起一个标题</p>\n"},{"title":"API数据自动入库","_content":"\n\n> 原文链接 : https://blog.csdn.net/weixin_44723724/article/details/125600165\n\n\n## 场景\n\n将不同渠道的api日志入库，方便日后分析和检查系统行为\n\n## 挑战\n\n1. api返回数据格式多样。需要确定以什么样的形式呈现数据，定义表结构.\n2. json格式的嵌套问题.通过额外定义表进行关联.\n    1. 单表形式\n        - json字段就是表字段\n    2. 多表详细存储\n        - 关联字段通过外层表名拼接内层表名\n        - 解析 json 的时候，需要把关联键和关联键的值传递进去，关联键的值传递的就是外层表当前行数据的 md5 值，这样就生成了多表之间行数据关联的依据\n3. 本地多种数据源(不同种数据库).\n4. 通过md5值解决幂等问题，如果导入同一批数据就只是更新导入时间\n\n## 代码设计\n\n1. 工厂模式 : 适配不同种数据源\n2. 抽象sql构建模型 : 将构建sql时公共的代码进行抽象,定义抽象类.\n    - 固定表名\n    - 列信息\n    - 关联键\n    - 数据集合","source":"_posts/archive/Api数据自动入库.md","raw":"---\ntitle: API数据自动入库\ncategories: \n- archive\n---\n\n\n> 原文链接 : https://blog.csdn.net/weixin_44723724/article/details/125600165\n\n\n## 场景\n\n将不同渠道的api日志入库，方便日后分析和检查系统行为\n\n## 挑战\n\n1. api返回数据格式多样。需要确定以什么样的形式呈现数据，定义表结构.\n2. json格式的嵌套问题.通过额外定义表进行关联.\n    1. 单表形式\n        - json字段就是表字段\n    2. 多表详细存储\n        - 关联字段通过外层表名拼接内层表名\n        - 解析 json 的时候，需要把关联键和关联键的值传递进去，关联键的值传递的就是外层表当前行数据的 md5 值，这样就生成了多表之间行数据关联的依据\n3. 本地多种数据源(不同种数据库).\n4. 通过md5值解决幂等问题，如果导入同一批数据就只是更新导入时间\n\n## 代码设计\n\n1. 工厂模式 : 适配不同种数据源\n2. 抽象sql构建模型 : 将构建sql时公共的代码进行抽象,定义抽象类.\n    - 固定表名\n    - 列信息\n    - 关联键\n    - 数据集合","slug":"archive/Api数据自动入库","published":1,"date":"2022-08-27T05:35:51.409Z","updated":"2022-08-27T08:39:39.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5o000tl1db9beq3cnu","content":"<blockquote>\n<p>原文链接 : <a href=\"https://blog.csdn.net/weixin_44723724/article/details/125600165\">https://blog.csdn.net/weixin_44723724/article/details/125600165</a></p>\n</blockquote>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>将不同渠道的api日志入库，方便日后分析和检查系统行为</p>\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><ol>\n<li>api返回数据格式多样。需要确定以什么样的形式呈现数据，定义表结构.</li>\n<li>json格式的嵌套问题.通过额外定义表进行关联.<ol>\n<li>单表形式<ul>\n<li>json字段就是表字段</li>\n</ul>\n</li>\n<li>多表详细存储<ul>\n<li>关联字段通过外层表名拼接内层表名</li>\n<li>解析 json 的时候，需要把关联键和关联键的值传递进去，关联键的值传递的就是外层表当前行数据的 md5 值，这样就生成了多表之间行数据关联的依据</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>本地多种数据源(不同种数据库).</li>\n<li>通过md5值解决幂等问题，如果导入同一批数据就只是更新导入时间</li>\n</ol>\n<h2 id=\"代码设计\"><a href=\"#代码设计\" class=\"headerlink\" title=\"代码设计\"></a>代码设计</h2><ol>\n<li>工厂模式 : 适配不同种数据源</li>\n<li>抽象sql构建模型 : 将构建sql时公共的代码进行抽象,定义抽象类.<ul>\n<li>固定表名</li>\n<li>列信息</li>\n<li>关联键</li>\n<li>数据集合</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文链接 : <a href=\"https://blog.csdn.net/weixin_44723724/article/details/125600165\">https://blog.csdn.net/weixin_44723724/article/details/125600165</a></p>\n</blockquote>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>将不同渠道的api日志入库，方便日后分析和检查系统行为</p>\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><ol>\n<li>api返回数据格式多样。需要确定以什么样的形式呈现数据，定义表结构.</li>\n<li>json格式的嵌套问题.通过额外定义表进行关联.<ol>\n<li>单表形式<ul>\n<li>json字段就是表字段</li>\n</ul>\n</li>\n<li>多表详细存储<ul>\n<li>关联字段通过外层表名拼接内层表名</li>\n<li>解析 json 的时候，需要把关联键和关联键的值传递进去，关联键的值传递的就是外层表当前行数据的 md5 值，这样就生成了多表之间行数据关联的依据</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>本地多种数据源(不同种数据库).</li>\n<li>通过md5值解决幂等问题，如果导入同一批数据就只是更新导入时间</li>\n</ol>\n<h2 id=\"代码设计\"><a href=\"#代码设计\" class=\"headerlink\" title=\"代码设计\"></a>代码设计</h2><ol>\n<li>工厂模式 : 适配不同种数据源</li>\n<li>抽象sql构建模型 : 将构建sql时公共的代码进行抽象,定义抽象类.<ul>\n<li>固定表名</li>\n<li>列信息</li>\n<li>关联键</li>\n<li>数据集合</li>\n</ul>\n</li>\n</ol>\n"},{"title":"手册阅读归档","_content":"\n|文章标题|文档地址|学到什么|\n|---|---|---|\n|为什么使用rust而非C++构建流数据库|https://www.singularity-data.com/blog/building-a-cloud-database-from-scratch-why-we-moved-from-cpp-to-rust/|[优点]易于使用,内存安全的,学习简单,可管理的不安全性，[缺点]碎片化的异步子系统,笨重的error处理机制,缺少泛型. [学习到的经验] 用新的语言或者新的架构成为必然.有相关方面的专家.快速壮大自己的队伍。[总结]底层编程,性能,内存安全,友好的包管理工具是你项目主要考虑的问题。有没有专家帮到你,时间时间时间上的安排,有没有内部自用的培训程序在rust上|\n|避免内存泄漏在java|https://medium.com/javarevisited/memory-leak-in-java-how-to-detect-and-avoid-dea648fba770|NULL|\n|内存高效，CPU优化的golang代码|https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick|结构体的数据类型的排布会影响到内存的分配，这部分主要是编译器的字段对齐概念|\n|markdown文章中使用html达到折叠代码块| ```     <details> <summary><font size=\"4\" color=\"orange\">Show Code</font></summary> <pre><code class=\"language-cpp\">这里填充代码</code></pre> </details>```|\n|安装pyspark和spark|pyspark=3.2.2,spark=3.2.2,jdk=11,python3=3.8,scala=2.11.12.最重要的是版本保持一致|\n|英语中in which 用法|in which 是relative pronoun(关系代词)，用来引导定语从句,在which前加介词显得正式，省去which就不正式.[1] This is the car in which I travelled to Beijing. [2] This is the house in which I grew up. [3] This is the pitch on which I played football all those years ago. [4] ack at school, the name by which I was known was Charlie. [5] And these are the friends with whom I played every day. 这里的frinends是指代后面从句的宾语，故用whome|\n|iso8583简介|https://garlicspace.com/2022/03/19/iso8583%E5%8D%8F%E8%AE%AE/|![iso8583报文](https://i0.wp.com/garlicspace.com/wp-content/uploads/2022/03/MTI.png?w=1082&ssl=1)0xxx → version of ISO 8583 (0 = 1987 version) x1xx → class of the message (1 = authorization message) xx1x → function of the message (1 = response) xxx0 → who began the communication (0 = acquirer)|","source":"_posts/archive/archive.md","raw":"---\ntitle: 手册阅读归档\ncategories: \n- archive\n\n---\n\n|文章标题|文档地址|学到什么|\n|---|---|---|\n|为什么使用rust而非C++构建流数据库|https://www.singularity-data.com/blog/building-a-cloud-database-from-scratch-why-we-moved-from-cpp-to-rust/|[优点]易于使用,内存安全的,学习简单,可管理的不安全性，[缺点]碎片化的异步子系统,笨重的error处理机制,缺少泛型. [学习到的经验] 用新的语言或者新的架构成为必然.有相关方面的专家.快速壮大自己的队伍。[总结]底层编程,性能,内存安全,友好的包管理工具是你项目主要考虑的问题。有没有专家帮到你,时间时间时间上的安排,有没有内部自用的培训程序在rust上|\n|避免内存泄漏在java|https://medium.com/javarevisited/memory-leak-in-java-how-to-detect-and-avoid-dea648fba770|NULL|\n|内存高效，CPU优化的golang代码|https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick|结构体的数据类型的排布会影响到内存的分配，这部分主要是编译器的字段对齐概念|\n|markdown文章中使用html达到折叠代码块| ```     <details> <summary><font size=\"4\" color=\"orange\">Show Code</font></summary> <pre><code class=\"language-cpp\">这里填充代码</code></pre> </details>```|\n|安装pyspark和spark|pyspark=3.2.2,spark=3.2.2,jdk=11,python3=3.8,scala=2.11.12.最重要的是版本保持一致|\n|英语中in which 用法|in which 是relative pronoun(关系代词)，用来引导定语从句,在which前加介词显得正式，省去which就不正式.[1] This is the car in which I travelled to Beijing. [2] This is the house in which I grew up. [3] This is the pitch on which I played football all those years ago. [4] ack at school, the name by which I was known was Charlie. [5] And these are the friends with whom I played every day. 这里的frinends是指代后面从句的宾语，故用whome|\n|iso8583简介|https://garlicspace.com/2022/03/19/iso8583%E5%8D%8F%E8%AE%AE/|![iso8583报文](https://i0.wp.com/garlicspace.com/wp-content/uploads/2022/03/MTI.png?w=1082&ssl=1)0xxx → version of ISO 8583 (0 = 1987 version) x1xx → class of the message (1 = authorization message) xx1x → function of the message (1 = response) xxx0 → who began the communication (0 = acquirer)|","slug":"archive/archive","published":1,"date":"2022-06-23T22:54:11.375Z","updated":"2022-09-18T16:33:05.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5p000wl1db702scjbi","content":"<table>\n<thead>\n<tr>\n<th>文章标题</th>\n<th>文档地址</th>\n<th>学到什么</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>为什么使用rust而非C++构建流数据库</td>\n<td><a href=\"https://www.singularity-data.com/blog/building-a-cloud-database-from-scratch-why-we-moved-from-cpp-to-rust/\">https://www.singularity-data.com/blog/building-a-cloud-database-from-scratch-why-we-moved-from-cpp-to-rust/</a></td>\n<td>[优点]易于使用,内存安全的,学习简单,可管理的不安全性，[缺点]碎片化的异步子系统,笨重的error处理机制,缺少泛型. [学习到的经验] 用新的语言或者新的架构成为必然.有相关方面的专家.快速壮大自己的队伍。[总结]底层编程,性能,内存安全,友好的包管理工具是你项目主要考虑的问题。有没有专家帮到你,时间时间时间上的安排,有没有内部自用的培训程序在rust上</td>\n</tr>\n<tr>\n<td>避免内存泄漏在java</td>\n<td><a href=\"https://medium.com/javarevisited/memory-leak-in-java-how-to-detect-and-avoid-dea648fba770\">https://medium.com/javarevisited/memory-leak-in-java-how-to-detect-and-avoid-dea648fba770</a></td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>内存高效，CPU优化的golang代码</td>\n<td><a href=\"https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick\">https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick</a></td>\n<td>结构体的数据类型的排布会影响到内存的分配，这部分主要是编译器的字段对齐概念</td>\n</tr>\n<tr>\n<td>markdown文章中使用html达到折叠代码块</td>\n<td><code>     &lt;details&gt; &lt;summary&gt;&lt;font size=&quot;4&quot; color=&quot;orange&quot;&gt;Show Code&lt;/font&gt;&lt;/summary&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;这里填充代码&lt;/code&gt;&lt;/pre&gt; &lt;/details&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>安装pyspark和spark</td>\n<td>pyspark&#x3D;3.2.2,spark&#x3D;3.2.2,jdk&#x3D;11,python3&#x3D;3.8,scala&#x3D;2.11.12.最重要的是版本保持一致</td>\n<td></td>\n</tr>\n<tr>\n<td>英语中in which 用法</td>\n<td>in which 是relative pronoun(关系代词)，用来引导定语从句,在which前加介词显得正式，省去which就不正式.[1] This is the car in which I travelled to Beijing. [2] This is the house in which I grew up. [3] This is the pitch on which I played football all those years ago. [4] ack at school, the name by which I was known was Charlie. [5] And these are the friends with whom I played every day. 这里的frinends是指代后面从句的宾语，故用whome</td>\n<td></td>\n</tr>\n<tr>\n<td>iso8583简介</td>\n<td><a href=\"https://garlicspace.com/2022/03/19/iso8583%E5%8D%8F%E8%AE%AE/\">https://garlicspace.com/2022/03/19/iso8583%E5%8D%8F%E8%AE%AE/</a></td>\n<td><img src=\"https://i0.wp.com/garlicspace.com/wp-content/uploads/2022/03/MTI.png?w=1082&ssl=1\" alt=\"iso8583报文\">0xxx → version of ISO 8583 (0 &#x3D; 1987 version) x1xx → class of the message (1 &#x3D; authorization message) xx1x → function of the message (1 &#x3D; response) xxx0 → who began the communication (0 &#x3D; acquirer)</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>文章标题</th>\n<th>文档地址</th>\n<th>学到什么</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>为什么使用rust而非C++构建流数据库</td>\n<td><a href=\"https://www.singularity-data.com/blog/building-a-cloud-database-from-scratch-why-we-moved-from-cpp-to-rust/\">https://www.singularity-data.com/blog/building-a-cloud-database-from-scratch-why-we-moved-from-cpp-to-rust/</a></td>\n<td>[优点]易于使用,内存安全的,学习简单,可管理的不安全性，[缺点]碎片化的异步子系统,笨重的error处理机制,缺少泛型. [学习到的经验] 用新的语言或者新的架构成为必然.有相关方面的专家.快速壮大自己的队伍。[总结]底层编程,性能,内存安全,友好的包管理工具是你项目主要考虑的问题。有没有专家帮到你,时间时间时间上的安排,有没有内部自用的培训程序在rust上</td>\n</tr>\n<tr>\n<td>避免内存泄漏在java</td>\n<td><a href=\"https://medium.com/javarevisited/memory-leak-in-java-how-to-detect-and-avoid-dea648fba770\">https://medium.com/javarevisited/memory-leak-in-java-how-to-detect-and-avoid-dea648fba770</a></td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>内存高效，CPU优化的golang代码</td>\n<td><a href=\"https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick\">https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick</a></td>\n<td>结构体的数据类型的排布会影响到内存的分配，这部分主要是编译器的字段对齐概念</td>\n</tr>\n<tr>\n<td>markdown文章中使用html达到折叠代码块</td>\n<td><code>     &lt;details&gt; &lt;summary&gt;&lt;font size=&quot;4&quot; color=&quot;orange&quot;&gt;Show Code&lt;/font&gt;&lt;/summary&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;这里填充代码&lt;/code&gt;&lt;/pre&gt; &lt;/details&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>安装pyspark和spark</td>\n<td>pyspark&#x3D;3.2.2,spark&#x3D;3.2.2,jdk&#x3D;11,python3&#x3D;3.8,scala&#x3D;2.11.12.最重要的是版本保持一致</td>\n<td></td>\n</tr>\n<tr>\n<td>英语中in which 用法</td>\n<td>in which 是relative pronoun(关系代词)，用来引导定语从句,在which前加介词显得正式，省去which就不正式.[1] This is the car in which I travelled to Beijing. [2] This is the house in which I grew up. [3] This is the pitch on which I played football all those years ago. [4] ack at school, the name by which I was known was Charlie. [5] And these are the friends with whom I played every day. 这里的frinends是指代后面从句的宾语，故用whome</td>\n<td></td>\n</tr>\n<tr>\n<td>iso8583简介</td>\n<td><a href=\"https://garlicspace.com/2022/03/19/iso8583%E5%8D%8F%E8%AE%AE/\">https://garlicspace.com/2022/03/19/iso8583%E5%8D%8F%E8%AE%AE/</a></td>\n<td><img src=\"https://i0.wp.com/garlicspace.com/wp-content/uploads/2022/03/MTI.png?w=1082&ssl=1\" alt=\"iso8583报文\">0xxx → version of ISO 8583 (0 &#x3D; 1987 version) x1xx → class of the message (1 &#x3D; authorization message) xx1x → function of the message (1 &#x3D; response) xxx0 → who began the communication (0 &#x3D; acquirer)</td>\n</tr>\n</tbody></table>\n"},{"title":"压缩wsl2的磁盘","_content":"\n\n1. shuwdown wsl\n```bash\nwsl --shutdown\n```\n\n2. find out wsl file location\n一般情况下wsl文件位于：C:\\Users\\Administrator\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\ext4.vhdx\n\n3. 备份wsl\n```bash\nwsl --export name target_file\n\n```\nname可以通过`wsl -l`命令进行查看\n\n4. 运行diskpart\n```bash\nselect vdisk file=\"your location\"\ncompact vdisk\n\n```\n","source":"_posts/archive/compact_wsl2.md","raw":"---\ntitle: 压缩wsl2的磁盘\ncategories:\n- archive\n---\n\n\n1. shuwdown wsl\n```bash\nwsl --shutdown\n```\n\n2. find out wsl file location\n一般情况下wsl文件位于：C:\\Users\\Administrator\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\ext4.vhdx\n\n3. 备份wsl\n```bash\nwsl --export name target_file\n\n```\nname可以通过`wsl -l`命令进行查看\n\n4. 运行diskpart\n```bash\nselect vdisk file=\"your location\"\ncompact vdisk\n\n```\n","slug":"archive/compact_wsl2","published":1,"date":"2022-10-07T07:33:59.268Z","updated":"2022-10-07T08:14:01.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5p000xl1dbcnns5loh","content":"<ol>\n<li><p>shuwdown wsl</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">wsl --shutdown</code></pre>\n</li>\n<li><p>find out wsl file location<br>一般情况下wsl文件位于：C:\\Users\\Administrator\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\ext4.vhdx</p>\n</li>\n<li><p>备份wsl</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">wsl --export name target_file\n</code></pre>\n<p>name可以通过<code>wsl -l</code>命令进行查看</p>\n</li>\n<li><p>运行diskpart</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">select</span> vdisk <span class=\"token assign-left variable\">file</span><span class=\"token operator\">=</span><span class=\"token string\">\"your location\"</span>\ncompact vdisk\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>shuwdown wsl</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">wsl --shutdown</code></pre>\n</li>\n<li><p>find out wsl file location<br>一般情况下wsl文件位于：C:\\Users\\Administrator\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\ext4.vhdx</p>\n</li>\n<li><p>备份wsl</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">wsl --export name target_file\n</code></pre>\n<p>name可以通过<code>wsl -l</code>命令进行查看</p>\n</li>\n<li><p>运行diskpart</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">select</span> vdisk <span class=\"token assign-left variable\">file</span><span class=\"token operator\">=</span><span class=\"token string\">\"your location\"</span>\ncompact vdisk\n</code></pre></li>\n</ol>\n"},{"title":"concurreny-map代码阅读","_content":"\n## 摘要\n学习下别人如何写的golang的concurrent map实现并于官方版本的进行对比。接下来的内容来自于作者的readme----在Go 1.9之前，go语言标准库中并没有实现并发`map`。在Go 1.9中，引入了`sync.Map`。新的`sync.Map`与此`concurrent-map`有几个关键区别。标准库中的`sync.Map`是专为`append-only`场景设计的。因此，如果您想将`Map`用于一个类似内存数据库，那么使用我们的版本可能会受益。你可以在golang repo上读到更多，[这里](https://github.com/golang/go/issues/21035) and [这里](https://stackoverflow.com/questions/11063473/map-with-concurrent-access)\n***译注:`sync.Map`在读多写少性能比较好，否则并发性能很差***\n\n## 第三方conrrency map理解\n> 源代码地址 : https://github.com/orcaman/concurrent-map\n\n\n<details>\n<summary>golang-concurrency-map</summary>\n\n```golang\npackage cmap\n\nimport (\n\t\"encoding/json\"\n\t\"sync\"\n)\n\nvar SHARD_COUNT = 32\n\n\n// A \"thread\" safe string to anything map.\ntype ConcurrentMapShared[V any] struct {\n\titems        map[string]V\n\tsync.RWMutex // Read Write mutex, guards access to internal \n\n}\n\n// A \"thread\" safe map of type string:Anything.\n// To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.\ntype ConcurrentMap[V any] []*ConcurrentMapShared[V]\n\n\n// 创建了一个长度32的切片\n// Creates a new concurrent map.\nfunc New[V any]() ConcurrentMap[V] {\n\tm := make(ConcurrentMap[V], SHARD_COUNT)\n\tfor i := 0; i < SHARD_COUNT; i++ {\n\t\tm[i] = &ConcurrentMapShared[V]{items: make(map[string]V)}\n\t}\n\treturn m\n}\n\n// GetShard returns shard under given key\nfunc (m ConcurrentMap[V]) GetShard(key string) *ConcurrentMapShared[V] {\n\treturn m[uint(fnv32(key))%uint(SHARD_COUNT)]\n}\n// batch赋值数据\nfunc (m ConcurrentMap[V]) MSet(data map[string]V) {\n\tfor key, value := range data {\n\t\tshard := m.GetShard(key)\n\t\tshard.Lock()\n\t\tshard.items[key] = value\n\t\tshard.Unlock()\n\t}\n}\n\n// Sets the given value under the specified key.\nfunc (m ConcurrentMap[V]) Set(key string, value V) {\n\t// Get map shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tshard.items[key] = value\n\tshard.Unlock()\n}\n\n// Callback to return new element to be inserted into the map\n// It is called while lock is held, therefore it MUST NOT\n// try to access other keys in same map, as it can lead to deadlock since\n// Go sync.RWLock is not reentrant\ntype UpsertCb[V any] func(exist bool, valueInMap V, newValue V) V\n\n// Insert or Update - updates existing element or inserts a new one using UpsertCb\n// 有就更新，没有就插入\nfunc (m ConcurrentMap[V]) Upsert(key string, value V, cb UpsertCb[V]) (res V) {\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, ok := shard.items[key]\n\tres = cb(ok, v, value)\n\tshard.items[key] = res\n\tshard.Unlock()\n\treturn res\n}\n\n// Sets the given value under the specified key if no value was associated with it.\nfunc (m ConcurrentMap[V]) SetIfAbsent(key string, value V) bool {\n\t// Get map shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\t_, ok := shard.items[key]\n\tif !ok {\n\t\tshard.items[key] = value\n\t}\n\tshard.Unlock()\n\treturn !ok\n}\n\n// Get retrieves an element from map under given key.\nfunc (m ConcurrentMap[V]) Get(key string) (V, bool) {\n\t// Get shard\n\tshard := m.GetShard(key)\n\tshard.RLock()\n\t// Get item from shard.\n\tval, ok := shard.items[key]\n\tshard.RUnlock()\n\treturn val, ok\n}\n\n// Count returns the number of elements within the map.\nfunc (m ConcurrentMap[V]) Count() int {\n\tcount := 0\n\tfor i := 0; i < SHARD_COUNT; i++ {\n\t\tshard := m[i]\n\t\tshard.RLock()\n\t\tcount += len(shard.items)\n\t\tshard.RUnlock()\n\t}\n\treturn count\n}\n\n// Looks up an item under specified key\nfunc (m ConcurrentMap[V]) Has(key string) bool {\n\t// Get shard\n\tshard := m.GetShard(key)\n\tshard.RLock()\n\t// See if element is within shard.\n\t_, ok := shard.items[key]\n\tshard.RUnlock()\n\treturn ok\n}\n\n// Remove removes an element from the map.\nfunc (m ConcurrentMap[V]) Remove(key string) {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tdelete(shard.items, key)\n\tshard.Unlock()\n}\n\n// RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held\n// If returns true, the element will be removed from the map\ntype RemoveCb[V any] func(key string, v V, exists bool) bool\n\n// RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params\n// If callback returns true and element exists, it will remove it from the map\n// Returns the value returned by the callback (even if element was not present in the map)\nfunc (m ConcurrentMap[V]) RemoveCb(key string, cb RemoveCb[V]) bool {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, ok := shard.items[key]\n\tremove := cb(key, v, ok)\n\tif remove && ok {\n\t\tdelete(shard.items, key)\n\t}\n\tshard.Unlock()\n\treturn remove\n}\n\n// Pop removes an element from the map and returns it\nfunc (m ConcurrentMap[V]) Pop(key string) (v V, exists bool) {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, exists = shard.items[key]\n\tdelete(shard.items, key)\n\tshard.Unlock()\n\treturn v, exists\n}\n\n// IsEmpty checks if map is empty.\nfunc (m ConcurrentMap[V]) IsEmpty() bool {\n\treturn m.Count() == 0\n}\n\n// Used by the Iter & IterBuffered functions to wrap two variables together over a channel,\ntype Tuple[V any] struct {\n\tKey string\n\tVal V\n}\n\n// Iter returns an iterator which could be used in a for range loop.\n//\n// Deprecated: using IterBuffered() will get a better performence\nfunc (m ConcurrentMap[V]) Iter() <-chan Tuple[V] {\n\tchans := snapshot(m)\n\tch := make(chan Tuple[V])\n\tgo fanIn(chans, ch)\n\treturn ch\n}\n\n// IterBuffered returns a buffered iterator which could be used in a for range loop.\nfunc (m ConcurrentMap[V]) IterBuffered() <-chan Tuple[V] {\n\tchans := snapshot(m)\n\ttotal := 0\n\tfor _, c := range chans {\n\t\ttotal += cap(c)\n\t}\n\tch := make(chan Tuple[V], total)\n\tgo fanIn(chans, ch)\n\treturn ch\n}\n\n// Clear removes all items from map.\nfunc (m ConcurrentMap[V]) Clear() {\n\tfor item := range m.IterBuffered() {\n\t\tm.Remove(item.Key)\n\t}\n}\n\n// Returns a array of channels that contains elements in each shard,\n// which likely takes a snapshot of `m`.\n// It returns once the size of each buffered channel is determined,\n// before all the channels are populated using goroutines.\nfunc snapshot[V any](m ConcurrentMap[V]) (chans []chan Tuple[V]) {\n\t//When you access map items before initializing.\n\tif len(m) == 0 {\n\t\tpanic(`cmap.ConcurrentMap is not initialized. Should run New() before usage.`)\n\t}\n\tchans = make([]chan Tuple[V], SHARD_COUNT)\n\twg := sync.WaitGroup{}\n\twg.Add(SHARD_COUNT)\n\t// Foreach shard.\n\tfor index, shard := range m {\n\t\tgo func(index int, shard *ConcurrentMapShared[V]) {\n\t\t\t// Foreach key, value pair.\n\t\t\tshard.RLock()\n\t\t\tchans[index] = make(chan Tuple[V], len(shard.items))\n\t\t\twg.Done()\n\t\t\tfor key, val := range shard.items {\n\t\t\t\tchans[index] <- Tuple[V]{key, val}\n\t\t\t}\n\t\t\tshard.RUnlock()\n\t\t\tclose(chans[index])\n\t\t}(index, shard)\n\t}\n\twg.Wait()\n\treturn chans\n}\n\n// fanIn reads elements from channels `chans` into channel `out`\nfunc fanIn[V any](chans []chan Tuple[V], out chan Tuple[V]) {\n\twg := sync.WaitGroup{}\n\twg.Add(len(chans))\n\tfor _, ch := range chans {\n\t\tgo func(ch chan Tuple[V]) {\n\t\t\tfor t := range ch {\n\t\t\t\tout <- t\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(ch)\n\t}\n\twg.Wait()\n\tclose(out)\n}\n\n// Items returns all items as map[string]V\nfunc (m ConcurrentMap[V]) Items() map[string]V {\n\ttmp := make(map[string]V)\n\n\t// Insert items to temporary map.\n\tfor item := range m.IterBuffered() {\n\t\ttmp[item.Key] = item.Val\n\t}\n\n\treturn tmp\n}\n\n// Iterator callbacalled for every key,value found in\n// maps. RLock is held for all calls for a given shard\n// therefore callback sess consistent view of a shard,\n// but not across the shards\ntype IterCb[V any] func(key string, v V)\n\n// Callback based iterator, cheapest way to read\n// all elements in a map.\nfunc (m ConcurrentMap[V]) IterCb(fn IterCb[V]) {\n\tfor idx := range m {\n\t\tshard := (m)[idx]\n\t\tshard.RLock()\n\t\tfor key, value := range shard.items {\n\t\t\tfn(key, value)\n\t\t}\n\t\tshard.RUnlock()\n\t}\n}\n\n// Keys returns all keys as []string\nfunc (m ConcurrentMap[V]) Keys() []string {\n\tcount := m.Count()\n\tch := make(chan string, count)\n\tgo func() {\n\t\t// Foreach shard.\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(SHARD_COUNT)\n\t\tfor _, shard := range m {\n\t\t\tgo func(shard *ConcurrentMapShared[V]) {\n\t\t\t\t// Foreach key, value pair.\n\t\t\t\tshard.RLock()\n\t\t\t\tfor key := range shard.items {\n\t\t\t\t\tch <- key\n\t\t\t\t}\n\t\t\t\tshard.RUnlock()\n\t\t\t\twg.Done()\n\t\t\t}(shard)\n\t\t}\n\t\twg.Wait()\n\t\tclose(ch)\n\t}()\n\n\t// Generate keys\n\tkeys := make([]string, 0, count)\n\tfor k := range ch {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\n//Reviles ConcurrentMap \"private\" variables to json marshal.\nfunc (m ConcurrentMap[V]) MarshalJSON() ([]byte, error) {\n\t// Create a temporary map, which will hold all item spread across shards.\n\ttmp := make(map[string]V)\n\n\t// Insert items to temporary map.\n\tfor item := range m.IterBuffered() {\n\t\ttmp[item.Key] = item.Val\n\t}\n\treturn json.Marshal(tmp)\n}\n\nfunc fnv32(key string) uint32 {\n\thash := uint32(2166136261)\n\tconst prime32 = uint32(16777619)\n\tkeyLength := len(key)\n\tfor i := 0; i < keyLength; i++ {\n\t\thash *= prime32\n\t\thash ^= uint32(key[i])\n\t}\n\treturn hash\n}\n\n// Reverse process of Marshal.\nfunc (m *ConcurrentMap[V]) UnmarshalJSON(b []byte) (err error) {\n \ttmp := make(map[string]V)\n\n \t// Unmarshal into a single map.\n \tif err := json.Unmarshal(b, &tmp); err != nil {\n \t\treturn err\n \t}\n\n \t// foreach key,value pair in temporary map insert into our concurrent map.\n \tfor key, val := range tmp {\n \t\tm.Set(key, val)\n \t}\n\treturn nil\n}\n```\n\n</details>\n\n总结\n- 通过这个concurrency-map学习了golang的泛型，golang具体泛型内容可以阅读对应的笔记\n- 说实话作者这种数据结构还是没太理解，不理解why，但是能看懂代码。应该先尝试试着了解数据结构","source":"_posts/archive/golang_concurrency_map.md","raw":"---\ntitle: concurreny-map代码阅读 \ncategories: \n- archive\n- golang\n---\n\n## 摘要\n学习下别人如何写的golang的concurrent map实现并于官方版本的进行对比。接下来的内容来自于作者的readme----在Go 1.9之前，go语言标准库中并没有实现并发`map`。在Go 1.9中，引入了`sync.Map`。新的`sync.Map`与此`concurrent-map`有几个关键区别。标准库中的`sync.Map`是专为`append-only`场景设计的。因此，如果您想将`Map`用于一个类似内存数据库，那么使用我们的版本可能会受益。你可以在golang repo上读到更多，[这里](https://github.com/golang/go/issues/21035) and [这里](https://stackoverflow.com/questions/11063473/map-with-concurrent-access)\n***译注:`sync.Map`在读多写少性能比较好，否则并发性能很差***\n\n## 第三方conrrency map理解\n> 源代码地址 : https://github.com/orcaman/concurrent-map\n\n\n<details>\n<summary>golang-concurrency-map</summary>\n\n```golang\npackage cmap\n\nimport (\n\t\"encoding/json\"\n\t\"sync\"\n)\n\nvar SHARD_COUNT = 32\n\n\n// A \"thread\" safe string to anything map.\ntype ConcurrentMapShared[V any] struct {\n\titems        map[string]V\n\tsync.RWMutex // Read Write mutex, guards access to internal \n\n}\n\n// A \"thread\" safe map of type string:Anything.\n// To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.\ntype ConcurrentMap[V any] []*ConcurrentMapShared[V]\n\n\n// 创建了一个长度32的切片\n// Creates a new concurrent map.\nfunc New[V any]() ConcurrentMap[V] {\n\tm := make(ConcurrentMap[V], SHARD_COUNT)\n\tfor i := 0; i < SHARD_COUNT; i++ {\n\t\tm[i] = &ConcurrentMapShared[V]{items: make(map[string]V)}\n\t}\n\treturn m\n}\n\n// GetShard returns shard under given key\nfunc (m ConcurrentMap[V]) GetShard(key string) *ConcurrentMapShared[V] {\n\treturn m[uint(fnv32(key))%uint(SHARD_COUNT)]\n}\n// batch赋值数据\nfunc (m ConcurrentMap[V]) MSet(data map[string]V) {\n\tfor key, value := range data {\n\t\tshard := m.GetShard(key)\n\t\tshard.Lock()\n\t\tshard.items[key] = value\n\t\tshard.Unlock()\n\t}\n}\n\n// Sets the given value under the specified key.\nfunc (m ConcurrentMap[V]) Set(key string, value V) {\n\t// Get map shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tshard.items[key] = value\n\tshard.Unlock()\n}\n\n// Callback to return new element to be inserted into the map\n// It is called while lock is held, therefore it MUST NOT\n// try to access other keys in same map, as it can lead to deadlock since\n// Go sync.RWLock is not reentrant\ntype UpsertCb[V any] func(exist bool, valueInMap V, newValue V) V\n\n// Insert or Update - updates existing element or inserts a new one using UpsertCb\n// 有就更新，没有就插入\nfunc (m ConcurrentMap[V]) Upsert(key string, value V, cb UpsertCb[V]) (res V) {\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, ok := shard.items[key]\n\tres = cb(ok, v, value)\n\tshard.items[key] = res\n\tshard.Unlock()\n\treturn res\n}\n\n// Sets the given value under the specified key if no value was associated with it.\nfunc (m ConcurrentMap[V]) SetIfAbsent(key string, value V) bool {\n\t// Get map shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\t_, ok := shard.items[key]\n\tif !ok {\n\t\tshard.items[key] = value\n\t}\n\tshard.Unlock()\n\treturn !ok\n}\n\n// Get retrieves an element from map under given key.\nfunc (m ConcurrentMap[V]) Get(key string) (V, bool) {\n\t// Get shard\n\tshard := m.GetShard(key)\n\tshard.RLock()\n\t// Get item from shard.\n\tval, ok := shard.items[key]\n\tshard.RUnlock()\n\treturn val, ok\n}\n\n// Count returns the number of elements within the map.\nfunc (m ConcurrentMap[V]) Count() int {\n\tcount := 0\n\tfor i := 0; i < SHARD_COUNT; i++ {\n\t\tshard := m[i]\n\t\tshard.RLock()\n\t\tcount += len(shard.items)\n\t\tshard.RUnlock()\n\t}\n\treturn count\n}\n\n// Looks up an item under specified key\nfunc (m ConcurrentMap[V]) Has(key string) bool {\n\t// Get shard\n\tshard := m.GetShard(key)\n\tshard.RLock()\n\t// See if element is within shard.\n\t_, ok := shard.items[key]\n\tshard.RUnlock()\n\treturn ok\n}\n\n// Remove removes an element from the map.\nfunc (m ConcurrentMap[V]) Remove(key string) {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tdelete(shard.items, key)\n\tshard.Unlock()\n}\n\n// RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held\n// If returns true, the element will be removed from the map\ntype RemoveCb[V any] func(key string, v V, exists bool) bool\n\n// RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params\n// If callback returns true and element exists, it will remove it from the map\n// Returns the value returned by the callback (even if element was not present in the map)\nfunc (m ConcurrentMap[V]) RemoveCb(key string, cb RemoveCb[V]) bool {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, ok := shard.items[key]\n\tremove := cb(key, v, ok)\n\tif remove && ok {\n\t\tdelete(shard.items, key)\n\t}\n\tshard.Unlock()\n\treturn remove\n}\n\n// Pop removes an element from the map and returns it\nfunc (m ConcurrentMap[V]) Pop(key string) (v V, exists bool) {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, exists = shard.items[key]\n\tdelete(shard.items, key)\n\tshard.Unlock()\n\treturn v, exists\n}\n\n// IsEmpty checks if map is empty.\nfunc (m ConcurrentMap[V]) IsEmpty() bool {\n\treturn m.Count() == 0\n}\n\n// Used by the Iter & IterBuffered functions to wrap two variables together over a channel,\ntype Tuple[V any] struct {\n\tKey string\n\tVal V\n}\n\n// Iter returns an iterator which could be used in a for range loop.\n//\n// Deprecated: using IterBuffered() will get a better performence\nfunc (m ConcurrentMap[V]) Iter() <-chan Tuple[V] {\n\tchans := snapshot(m)\n\tch := make(chan Tuple[V])\n\tgo fanIn(chans, ch)\n\treturn ch\n}\n\n// IterBuffered returns a buffered iterator which could be used in a for range loop.\nfunc (m ConcurrentMap[V]) IterBuffered() <-chan Tuple[V] {\n\tchans := snapshot(m)\n\ttotal := 0\n\tfor _, c := range chans {\n\t\ttotal += cap(c)\n\t}\n\tch := make(chan Tuple[V], total)\n\tgo fanIn(chans, ch)\n\treturn ch\n}\n\n// Clear removes all items from map.\nfunc (m ConcurrentMap[V]) Clear() {\n\tfor item := range m.IterBuffered() {\n\t\tm.Remove(item.Key)\n\t}\n}\n\n// Returns a array of channels that contains elements in each shard,\n// which likely takes a snapshot of `m`.\n// It returns once the size of each buffered channel is determined,\n// before all the channels are populated using goroutines.\nfunc snapshot[V any](m ConcurrentMap[V]) (chans []chan Tuple[V]) {\n\t//When you access map items before initializing.\n\tif len(m) == 0 {\n\t\tpanic(`cmap.ConcurrentMap is not initialized. Should run New() before usage.`)\n\t}\n\tchans = make([]chan Tuple[V], SHARD_COUNT)\n\twg := sync.WaitGroup{}\n\twg.Add(SHARD_COUNT)\n\t// Foreach shard.\n\tfor index, shard := range m {\n\t\tgo func(index int, shard *ConcurrentMapShared[V]) {\n\t\t\t// Foreach key, value pair.\n\t\t\tshard.RLock()\n\t\t\tchans[index] = make(chan Tuple[V], len(shard.items))\n\t\t\twg.Done()\n\t\t\tfor key, val := range shard.items {\n\t\t\t\tchans[index] <- Tuple[V]{key, val}\n\t\t\t}\n\t\t\tshard.RUnlock()\n\t\t\tclose(chans[index])\n\t\t}(index, shard)\n\t}\n\twg.Wait()\n\treturn chans\n}\n\n// fanIn reads elements from channels `chans` into channel `out`\nfunc fanIn[V any](chans []chan Tuple[V], out chan Tuple[V]) {\n\twg := sync.WaitGroup{}\n\twg.Add(len(chans))\n\tfor _, ch := range chans {\n\t\tgo func(ch chan Tuple[V]) {\n\t\t\tfor t := range ch {\n\t\t\t\tout <- t\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(ch)\n\t}\n\twg.Wait()\n\tclose(out)\n}\n\n// Items returns all items as map[string]V\nfunc (m ConcurrentMap[V]) Items() map[string]V {\n\ttmp := make(map[string]V)\n\n\t// Insert items to temporary map.\n\tfor item := range m.IterBuffered() {\n\t\ttmp[item.Key] = item.Val\n\t}\n\n\treturn tmp\n}\n\n// Iterator callbacalled for every key,value found in\n// maps. RLock is held for all calls for a given shard\n// therefore callback sess consistent view of a shard,\n// but not across the shards\ntype IterCb[V any] func(key string, v V)\n\n// Callback based iterator, cheapest way to read\n// all elements in a map.\nfunc (m ConcurrentMap[V]) IterCb(fn IterCb[V]) {\n\tfor idx := range m {\n\t\tshard := (m)[idx]\n\t\tshard.RLock()\n\t\tfor key, value := range shard.items {\n\t\t\tfn(key, value)\n\t\t}\n\t\tshard.RUnlock()\n\t}\n}\n\n// Keys returns all keys as []string\nfunc (m ConcurrentMap[V]) Keys() []string {\n\tcount := m.Count()\n\tch := make(chan string, count)\n\tgo func() {\n\t\t// Foreach shard.\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(SHARD_COUNT)\n\t\tfor _, shard := range m {\n\t\t\tgo func(shard *ConcurrentMapShared[V]) {\n\t\t\t\t// Foreach key, value pair.\n\t\t\t\tshard.RLock()\n\t\t\t\tfor key := range shard.items {\n\t\t\t\t\tch <- key\n\t\t\t\t}\n\t\t\t\tshard.RUnlock()\n\t\t\t\twg.Done()\n\t\t\t}(shard)\n\t\t}\n\t\twg.Wait()\n\t\tclose(ch)\n\t}()\n\n\t// Generate keys\n\tkeys := make([]string, 0, count)\n\tfor k := range ch {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\n//Reviles ConcurrentMap \"private\" variables to json marshal.\nfunc (m ConcurrentMap[V]) MarshalJSON() ([]byte, error) {\n\t// Create a temporary map, which will hold all item spread across shards.\n\ttmp := make(map[string]V)\n\n\t// Insert items to temporary map.\n\tfor item := range m.IterBuffered() {\n\t\ttmp[item.Key] = item.Val\n\t}\n\treturn json.Marshal(tmp)\n}\n\nfunc fnv32(key string) uint32 {\n\thash := uint32(2166136261)\n\tconst prime32 = uint32(16777619)\n\tkeyLength := len(key)\n\tfor i := 0; i < keyLength; i++ {\n\t\thash *= prime32\n\t\thash ^= uint32(key[i])\n\t}\n\treturn hash\n}\n\n// Reverse process of Marshal.\nfunc (m *ConcurrentMap[V]) UnmarshalJSON(b []byte) (err error) {\n \ttmp := make(map[string]V)\n\n \t// Unmarshal into a single map.\n \tif err := json.Unmarshal(b, &tmp); err != nil {\n \t\treturn err\n \t}\n\n \t// foreach key,value pair in temporary map insert into our concurrent map.\n \tfor key, val := range tmp {\n \t\tm.Set(key, val)\n \t}\n\treturn nil\n}\n```\n\n</details>\n\n总结\n- 通过这个concurrency-map学习了golang的泛型，golang具体泛型内容可以阅读对应的笔记\n- 说实话作者这种数据结构还是没太理解，不理解why，但是能看懂代码。应该先尝试试着了解数据结构","slug":"archive/golang_concurrency_map","published":1,"date":"2022-09-09T08:43:34.983Z","updated":"2022-09-10T06:18:57.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5q0010l1dbcsg4h7gl","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>学习下别人如何写的golang的concurrent map实现并于官方版本的进行对比。接下来的内容来自于作者的readme—-在Go 1.9之前，go语言标准库中并没有实现并发<code>map</code>。在Go 1.9中，引入了<code>sync.Map</code>。新的<code>sync.Map</code>与此<code>concurrent-map</code>有几个关键区别。标准库中的<code>sync.Map</code>是专为<code>append-only</code>场景设计的。因此，如果您想将<code>Map</code>用于一个类似内存数据库，那么使用我们的版本可能会受益。你可以在golang repo上读到更多，<a href=\"https://github.com/golang/go/issues/21035\">这里</a> and <a href=\"https://stackoverflow.com/questions/11063473/map-with-concurrent-access\">这里</a><br><em><strong>译注:<code>sync.Map</code>在读多写少性能比较好，否则并发性能很差</strong></em></p>\n<h2 id=\"第三方conrrency-map理解\"><a href=\"#第三方conrrency-map理解\" class=\"headerlink\" title=\"第三方conrrency map理解\"></a>第三方conrrency map理解</h2><blockquote>\n<p>源代码地址 : <a href=\"https://github.com/orcaman/concurrent-map\">https://github.com/orcaman/concurrent-map</a></p>\n</blockquote>\n<details>\n<summary>golang-concurrency-map</summary>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package cmap\n\nimport (\n\t&quot;encoding&#x2F;json&quot;\n\t&quot;sync&quot;\n)\n\nvar SHARD_COUNT &#x3D; 32\n\n\n&#x2F;&#x2F; A &quot;thread&quot; safe string to anything map.\ntype ConcurrentMapShared[V any] struct &#123;\n\titems        map[string]V\n\tsync.RWMutex &#x2F;&#x2F; Read Write mutex, guards access to internal \n\n&#125;\n\n&#x2F;&#x2F; A &quot;thread&quot; safe map of type string:Anything.\n&#x2F;&#x2F; To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.\ntype ConcurrentMap[V any] []*ConcurrentMapShared[V]\n\n\n&#x2F;&#x2F; 创建了一个长度32的切片\n&#x2F;&#x2F; Creates a new concurrent map.\nfunc New[V any]() ConcurrentMap[V] &#123;\n\tm :&#x3D; make(ConcurrentMap[V], SHARD_COUNT)\n\tfor i :&#x3D; 0; i &lt; SHARD_COUNT; i++ &#123;\n\t\tm[i] &#x3D; &amp;ConcurrentMapShared[V]&#123;items: make(map[string]V)&#125;\n\t&#125;\n\treturn m\n&#125;\n\n&#x2F;&#x2F; GetShard returns shard under given key\nfunc (m ConcurrentMap[V]) GetShard(key string) *ConcurrentMapShared[V] &#123;\n\treturn m[uint(fnv32(key))%uint(SHARD_COUNT)]\n&#125;\n&#x2F;&#x2F; batch赋值数据\nfunc (m ConcurrentMap[V]) MSet(data map[string]V) &#123;\n\tfor key, value :&#x3D; range data &#123;\n\t\tshard :&#x3D; m.GetShard(key)\n\t\tshard.Lock()\n\t\tshard.items[key] &#x3D; value\n\t\tshard.Unlock()\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; Sets the given value under the specified key.\nfunc (m ConcurrentMap[V]) Set(key string, value V) &#123;\n\t&#x2F;&#x2F; Get map shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tshard.items[key] &#x3D; value\n\tshard.Unlock()\n&#125;\n\n&#x2F;&#x2F; Callback to return new element to be inserted into the map\n&#x2F;&#x2F; It is called while lock is held, therefore it MUST NOT\n&#x2F;&#x2F; try to access other keys in same map, as it can lead to deadlock since\n&#x2F;&#x2F; Go sync.RWLock is not reentrant\ntype UpsertCb[V any] func(exist bool, valueInMap V, newValue V) V\n\n&#x2F;&#x2F; Insert or Update - updates existing element or inserts a new one using UpsertCb\n&#x2F;&#x2F; 有就更新，没有就插入\nfunc (m ConcurrentMap[V]) Upsert(key string, value V, cb UpsertCb[V]) (res V) &#123;\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tv, ok :&#x3D; shard.items[key]\n\tres &#x3D; cb(ok, v, value)\n\tshard.items[key] &#x3D; res\n\tshard.Unlock()\n\treturn res\n&#125;\n\n&#x2F;&#x2F; Sets the given value under the specified key if no value was associated with it.\nfunc (m ConcurrentMap[V]) SetIfAbsent(key string, value V) bool &#123;\n\t&#x2F;&#x2F; Get map shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\t_, ok :&#x3D; shard.items[key]\n\tif !ok &#123;\n\t\tshard.items[key] &#x3D; value\n\t&#125;\n\tshard.Unlock()\n\treturn !ok\n&#125;\n\n&#x2F;&#x2F; Get retrieves an element from map under given key.\nfunc (m ConcurrentMap[V]) Get(key string) (V, bool) &#123;\n\t&#x2F;&#x2F; Get shard\n\tshard :&#x3D; m.GetShard(key)\n\tshard.RLock()\n\t&#x2F;&#x2F; Get item from shard.\n\tval, ok :&#x3D; shard.items[key]\n\tshard.RUnlock()\n\treturn val, ok\n&#125;\n\n&#x2F;&#x2F; Count returns the number of elements within the map.\nfunc (m ConcurrentMap[V]) Count() int &#123;\n\tcount :&#x3D; 0\n\tfor i :&#x3D; 0; i &lt; SHARD_COUNT; i++ &#123;\n\t\tshard :&#x3D; m[i]\n\t\tshard.RLock()\n\t\tcount +&#x3D; len(shard.items)\n\t\tshard.RUnlock()\n\t&#125;\n\treturn count\n&#125;\n\n&#x2F;&#x2F; Looks up an item under specified key\nfunc (m ConcurrentMap[V]) Has(key string) bool &#123;\n\t&#x2F;&#x2F; Get shard\n\tshard :&#x3D; m.GetShard(key)\n\tshard.RLock()\n\t&#x2F;&#x2F; See if element is within shard.\n\t_, ok :&#x3D; shard.items[key]\n\tshard.RUnlock()\n\treturn ok\n&#125;\n\n&#x2F;&#x2F; Remove removes an element from the map.\nfunc (m ConcurrentMap[V]) Remove(key string) &#123;\n\t&#x2F;&#x2F; Try to get shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tdelete(shard.items, key)\n\tshard.Unlock()\n&#125;\n\n&#x2F;&#x2F; RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held\n&#x2F;&#x2F; If returns true, the element will be removed from the map\ntype RemoveCb[V any] func(key string, v V, exists bool) bool\n\n&#x2F;&#x2F; RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params\n&#x2F;&#x2F; If callback returns true and element exists, it will remove it from the map\n&#x2F;&#x2F; Returns the value returned by the callback (even if element was not present in the map)\nfunc (m ConcurrentMap[V]) RemoveCb(key string, cb RemoveCb[V]) bool &#123;\n\t&#x2F;&#x2F; Try to get shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tv, ok :&#x3D; shard.items[key]\n\tremove :&#x3D; cb(key, v, ok)\n\tif remove &amp;&amp; ok &#123;\n\t\tdelete(shard.items, key)\n\t&#125;\n\tshard.Unlock()\n\treturn remove\n&#125;\n\n&#x2F;&#x2F; Pop removes an element from the map and returns it\nfunc (m ConcurrentMap[V]) Pop(key string) (v V, exists bool) &#123;\n\t&#x2F;&#x2F; Try to get shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tv, exists &#x3D; shard.items[key]\n\tdelete(shard.items, key)\n\tshard.Unlock()\n\treturn v, exists\n&#125;\n\n&#x2F;&#x2F; IsEmpty checks if map is empty.\nfunc (m ConcurrentMap[V]) IsEmpty() bool &#123;\n\treturn m.Count() &#x3D;&#x3D; 0\n&#125;\n\n&#x2F;&#x2F; Used by the Iter &amp; IterBuffered functions to wrap two variables together over a channel,\ntype Tuple[V any] struct &#123;\n\tKey string\n\tVal V\n&#125;\n\n&#x2F;&#x2F; Iter returns an iterator which could be used in a for range loop.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Deprecated: using IterBuffered() will get a better performence\nfunc (m ConcurrentMap[V]) Iter() &lt;-chan Tuple[V] &#123;\n\tchans :&#x3D; snapshot(m)\n\tch :&#x3D; make(chan Tuple[V])\n\tgo fanIn(chans, ch)\n\treturn ch\n&#125;\n\n&#x2F;&#x2F; IterBuffered returns a buffered iterator which could be used in a for range loop.\nfunc (m ConcurrentMap[V]) IterBuffered() &lt;-chan Tuple[V] &#123;\n\tchans :&#x3D; snapshot(m)\n\ttotal :&#x3D; 0\n\tfor _, c :&#x3D; range chans &#123;\n\t\ttotal +&#x3D; cap(c)\n\t&#125;\n\tch :&#x3D; make(chan Tuple[V], total)\n\tgo fanIn(chans, ch)\n\treturn ch\n&#125;\n\n&#x2F;&#x2F; Clear removes all items from map.\nfunc (m ConcurrentMap[V]) Clear() &#123;\n\tfor item :&#x3D; range m.IterBuffered() &#123;\n\t\tm.Remove(item.Key)\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; Returns a array of channels that contains elements in each shard,\n&#x2F;&#x2F; which likely takes a snapshot of &#96;m&#96;.\n&#x2F;&#x2F; It returns once the size of each buffered channel is determined,\n&#x2F;&#x2F; before all the channels are populated using goroutines.\nfunc snapshot[V any](m ConcurrentMap[V]) (chans []chan Tuple[V]) &#123;\n\t&#x2F;&#x2F;When you access map items before initializing.\n\tif len(m) &#x3D;&#x3D; 0 &#123;\n\t\tpanic(&#96;cmap.ConcurrentMap is not initialized. Should run New() before usage.&#96;)\n\t&#125;\n\tchans &#x3D; make([]chan Tuple[V], SHARD_COUNT)\n\twg :&#x3D; sync.WaitGroup&#123;&#125;\n\twg.Add(SHARD_COUNT)\n\t&#x2F;&#x2F; Foreach shard.\n\tfor index, shard :&#x3D; range m &#123;\n\t\tgo func(index int, shard *ConcurrentMapShared[V]) &#123;\n\t\t\t&#x2F;&#x2F; Foreach key, value pair.\n\t\t\tshard.RLock()\n\t\t\tchans[index] &#x3D; make(chan Tuple[V], len(shard.items))\n\t\t\twg.Done()\n\t\t\tfor key, val :&#x3D; range shard.items &#123;\n\t\t\t\tchans[index] &lt;- Tuple[V]&#123;key, val&#125;\n\t\t\t&#125;\n\t\t\tshard.RUnlock()\n\t\t\tclose(chans[index])\n\t\t&#125;(index, shard)\n\t&#125;\n\twg.Wait()\n\treturn chans\n&#125;\n\n&#x2F;&#x2F; fanIn reads elements from channels &#96;chans&#96; into channel &#96;out&#96;\nfunc fanIn[V any](chans []chan Tuple[V], out chan Tuple[V]) &#123;\n\twg :&#x3D; sync.WaitGroup&#123;&#125;\n\twg.Add(len(chans))\n\tfor _, ch :&#x3D; range chans &#123;\n\t\tgo func(ch chan Tuple[V]) &#123;\n\t\t\tfor t :&#x3D; range ch &#123;\n\t\t\t\tout &lt;- t\n\t\t\t&#125;\n\t\t\twg.Done()\n\t\t&#125;(ch)\n\t&#125;\n\twg.Wait()\n\tclose(out)\n&#125;\n\n&#x2F;&#x2F; Items returns all items as map[string]V\nfunc (m ConcurrentMap[V]) Items() map[string]V &#123;\n\ttmp :&#x3D; make(map[string]V)\n\n\t&#x2F;&#x2F; Insert items to temporary map.\n\tfor item :&#x3D; range m.IterBuffered() &#123;\n\t\ttmp[item.Key] &#x3D; item.Val\n\t&#125;\n\n\treturn tmp\n&#125;\n\n&#x2F;&#x2F; Iterator callbacalled for every key,value found in\n&#x2F;&#x2F; maps. RLock is held for all calls for a given shard\n&#x2F;&#x2F; therefore callback sess consistent view of a shard,\n&#x2F;&#x2F; but not across the shards\ntype IterCb[V any] func(key string, v V)\n\n&#x2F;&#x2F; Callback based iterator, cheapest way to read\n&#x2F;&#x2F; all elements in a map.\nfunc (m ConcurrentMap[V]) IterCb(fn IterCb[V]) &#123;\n\tfor idx :&#x3D; range m &#123;\n\t\tshard :&#x3D; (m)[idx]\n\t\tshard.RLock()\n\t\tfor key, value :&#x3D; range shard.items &#123;\n\t\t\tfn(key, value)\n\t\t&#125;\n\t\tshard.RUnlock()\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; Keys returns all keys as []string\nfunc (m ConcurrentMap[V]) Keys() []string &#123;\n\tcount :&#x3D; m.Count()\n\tch :&#x3D; make(chan string, count)\n\tgo func() &#123;\n\t\t&#x2F;&#x2F; Foreach shard.\n\t\twg :&#x3D; sync.WaitGroup&#123;&#125;\n\t\twg.Add(SHARD_COUNT)\n\t\tfor _, shard :&#x3D; range m &#123;\n\t\t\tgo func(shard *ConcurrentMapShared[V]) &#123;\n\t\t\t\t&#x2F;&#x2F; Foreach key, value pair.\n\t\t\t\tshard.RLock()\n\t\t\t\tfor key :&#x3D; range shard.items &#123;\n\t\t\t\t\tch &lt;- key\n\t\t\t\t&#125;\n\t\t\t\tshard.RUnlock()\n\t\t\t\twg.Done()\n\t\t\t&#125;(shard)\n\t\t&#125;\n\t\twg.Wait()\n\t\tclose(ch)\n\t&#125;()\n\n\t&#x2F;&#x2F; Generate keys\n\tkeys :&#x3D; make([]string, 0, count)\n\tfor k :&#x3D; range ch &#123;\n\t\tkeys &#x3D; append(keys, k)\n\t&#125;\n\treturn keys\n&#125;\n\n&#x2F;&#x2F;Reviles ConcurrentMap &quot;private&quot; variables to json marshal.\nfunc (m ConcurrentMap[V]) MarshalJSON() ([]byte, error) &#123;\n\t&#x2F;&#x2F; Create a temporary map, which will hold all item spread across shards.\n\ttmp :&#x3D; make(map[string]V)\n\n\t&#x2F;&#x2F; Insert items to temporary map.\n\tfor item :&#x3D; range m.IterBuffered() &#123;\n\t\ttmp[item.Key] &#x3D; item.Val\n\t&#125;\n\treturn json.Marshal(tmp)\n&#125;\n\nfunc fnv32(key string) uint32 &#123;\n\thash :&#x3D; uint32(2166136261)\n\tconst prime32 &#x3D; uint32(16777619)\n\tkeyLength :&#x3D; len(key)\n\tfor i :&#x3D; 0; i &lt; keyLength; i++ &#123;\n\t\thash *&#x3D; prime32\n\t\thash ^&#x3D; uint32(key[i])\n\t&#125;\n\treturn hash\n&#125;\n\n&#x2F;&#x2F; Reverse process of Marshal.\nfunc (m *ConcurrentMap[V]) UnmarshalJSON(b []byte) (err error) &#123;\n \ttmp :&#x3D; make(map[string]V)\n\n \t&#x2F;&#x2F; Unmarshal into a single map.\n \tif err :&#x3D; json.Unmarshal(b, &amp;tmp); err !&#x3D; nil &#123;\n \t\treturn err\n \t&#125;\n\n \t&#x2F;&#x2F; foreach key,value pair in temporary map insert into our concurrent map.\n \tfor key, val :&#x3D; range tmp &#123;\n \t\tm.Set(key, val)\n \t&#125;\n\treturn nil\n&#125;</code></pre>\n\n</details>\n\n<p>总结</p>\n<ul>\n<li>通过这个concurrency-map学习了golang的泛型，golang具体泛型内容可以阅读对应的笔记</li>\n<li>说实话作者这种数据结构还是没太理解，不理解why，但是能看懂代码。应该先尝试试着了解数据结构</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>学习下别人如何写的golang的concurrent map实现并于官方版本的进行对比。接下来的内容来自于作者的readme—-在Go 1.9之前，go语言标准库中并没有实现并发<code>map</code>。在Go 1.9中，引入了<code>sync.Map</code>。新的<code>sync.Map</code>与此<code>concurrent-map</code>有几个关键区别。标准库中的<code>sync.Map</code>是专为<code>append-only</code>场景设计的。因此，如果您想将<code>Map</code>用于一个类似内存数据库，那么使用我们的版本可能会受益。你可以在golang repo上读到更多，<a href=\"https://github.com/golang/go/issues/21035\">这里</a> and <a href=\"https://stackoverflow.com/questions/11063473/map-with-concurrent-access\">这里</a><br><em><strong>译注:<code>sync.Map</code>在读多写少性能比较好，否则并发性能很差</strong></em></p>\n<h2 id=\"第三方conrrency-map理解\"><a href=\"#第三方conrrency-map理解\" class=\"headerlink\" title=\"第三方conrrency map理解\"></a>第三方conrrency map理解</h2><blockquote>\n<p>源代码地址 : <a href=\"https://github.com/orcaman/concurrent-map\">https://github.com/orcaman/concurrent-map</a></p>\n</blockquote>\n<details>\n<summary>golang-concurrency-map</summary>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package cmap\n\nimport (\n\t&quot;encoding&#x2F;json&quot;\n\t&quot;sync&quot;\n)\n\nvar SHARD_COUNT &#x3D; 32\n\n\n&#x2F;&#x2F; A &quot;thread&quot; safe string to anything map.\ntype ConcurrentMapShared[V any] struct &#123;\n\titems        map[string]V\n\tsync.RWMutex &#x2F;&#x2F; Read Write mutex, guards access to internal \n\n&#125;\n\n&#x2F;&#x2F; A &quot;thread&quot; safe map of type string:Anything.\n&#x2F;&#x2F; To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.\ntype ConcurrentMap[V any] []*ConcurrentMapShared[V]\n\n\n&#x2F;&#x2F; 创建了一个长度32的切片\n&#x2F;&#x2F; Creates a new concurrent map.\nfunc New[V any]() ConcurrentMap[V] &#123;\n\tm :&#x3D; make(ConcurrentMap[V], SHARD_COUNT)\n\tfor i :&#x3D; 0; i &lt; SHARD_COUNT; i++ &#123;\n\t\tm[i] &#x3D; &amp;ConcurrentMapShared[V]&#123;items: make(map[string]V)&#125;\n\t&#125;\n\treturn m\n&#125;\n\n&#x2F;&#x2F; GetShard returns shard under given key\nfunc (m ConcurrentMap[V]) GetShard(key string) *ConcurrentMapShared[V] &#123;\n\treturn m[uint(fnv32(key))%uint(SHARD_COUNT)]\n&#125;\n&#x2F;&#x2F; batch赋值数据\nfunc (m ConcurrentMap[V]) MSet(data map[string]V) &#123;\n\tfor key, value :&#x3D; range data &#123;\n\t\tshard :&#x3D; m.GetShard(key)\n\t\tshard.Lock()\n\t\tshard.items[key] &#x3D; value\n\t\tshard.Unlock()\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; Sets the given value under the specified key.\nfunc (m ConcurrentMap[V]) Set(key string, value V) &#123;\n\t&#x2F;&#x2F; Get map shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tshard.items[key] &#x3D; value\n\tshard.Unlock()\n&#125;\n\n&#x2F;&#x2F; Callback to return new element to be inserted into the map\n&#x2F;&#x2F; It is called while lock is held, therefore it MUST NOT\n&#x2F;&#x2F; try to access other keys in same map, as it can lead to deadlock since\n&#x2F;&#x2F; Go sync.RWLock is not reentrant\ntype UpsertCb[V any] func(exist bool, valueInMap V, newValue V) V\n\n&#x2F;&#x2F; Insert or Update - updates existing element or inserts a new one using UpsertCb\n&#x2F;&#x2F; 有就更新，没有就插入\nfunc (m ConcurrentMap[V]) Upsert(key string, value V, cb UpsertCb[V]) (res V) &#123;\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tv, ok :&#x3D; shard.items[key]\n\tres &#x3D; cb(ok, v, value)\n\tshard.items[key] &#x3D; res\n\tshard.Unlock()\n\treturn res\n&#125;\n\n&#x2F;&#x2F; Sets the given value under the specified key if no value was associated with it.\nfunc (m ConcurrentMap[V]) SetIfAbsent(key string, value V) bool &#123;\n\t&#x2F;&#x2F; Get map shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\t_, ok :&#x3D; shard.items[key]\n\tif !ok &#123;\n\t\tshard.items[key] &#x3D; value\n\t&#125;\n\tshard.Unlock()\n\treturn !ok\n&#125;\n\n&#x2F;&#x2F; Get retrieves an element from map under given key.\nfunc (m ConcurrentMap[V]) Get(key string) (V, bool) &#123;\n\t&#x2F;&#x2F; Get shard\n\tshard :&#x3D; m.GetShard(key)\n\tshard.RLock()\n\t&#x2F;&#x2F; Get item from shard.\n\tval, ok :&#x3D; shard.items[key]\n\tshard.RUnlock()\n\treturn val, ok\n&#125;\n\n&#x2F;&#x2F; Count returns the number of elements within the map.\nfunc (m ConcurrentMap[V]) Count() int &#123;\n\tcount :&#x3D; 0\n\tfor i :&#x3D; 0; i &lt; SHARD_COUNT; i++ &#123;\n\t\tshard :&#x3D; m[i]\n\t\tshard.RLock()\n\t\tcount +&#x3D; len(shard.items)\n\t\tshard.RUnlock()\n\t&#125;\n\treturn count\n&#125;\n\n&#x2F;&#x2F; Looks up an item under specified key\nfunc (m ConcurrentMap[V]) Has(key string) bool &#123;\n\t&#x2F;&#x2F; Get shard\n\tshard :&#x3D; m.GetShard(key)\n\tshard.RLock()\n\t&#x2F;&#x2F; See if element is within shard.\n\t_, ok :&#x3D; shard.items[key]\n\tshard.RUnlock()\n\treturn ok\n&#125;\n\n&#x2F;&#x2F; Remove removes an element from the map.\nfunc (m ConcurrentMap[V]) Remove(key string) &#123;\n\t&#x2F;&#x2F; Try to get shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tdelete(shard.items, key)\n\tshard.Unlock()\n&#125;\n\n&#x2F;&#x2F; RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held\n&#x2F;&#x2F; If returns true, the element will be removed from the map\ntype RemoveCb[V any] func(key string, v V, exists bool) bool\n\n&#x2F;&#x2F; RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params\n&#x2F;&#x2F; If callback returns true and element exists, it will remove it from the map\n&#x2F;&#x2F; Returns the value returned by the callback (even if element was not present in the map)\nfunc (m ConcurrentMap[V]) RemoveCb(key string, cb RemoveCb[V]) bool &#123;\n\t&#x2F;&#x2F; Try to get shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tv, ok :&#x3D; shard.items[key]\n\tremove :&#x3D; cb(key, v, ok)\n\tif remove &amp;&amp; ok &#123;\n\t\tdelete(shard.items, key)\n\t&#125;\n\tshard.Unlock()\n\treturn remove\n&#125;\n\n&#x2F;&#x2F; Pop removes an element from the map and returns it\nfunc (m ConcurrentMap[V]) Pop(key string) (v V, exists bool) &#123;\n\t&#x2F;&#x2F; Try to get shard.\n\tshard :&#x3D; m.GetShard(key)\n\tshard.Lock()\n\tv, exists &#x3D; shard.items[key]\n\tdelete(shard.items, key)\n\tshard.Unlock()\n\treturn v, exists\n&#125;\n\n&#x2F;&#x2F; IsEmpty checks if map is empty.\nfunc (m ConcurrentMap[V]) IsEmpty() bool &#123;\n\treturn m.Count() &#x3D;&#x3D; 0\n&#125;\n\n&#x2F;&#x2F; Used by the Iter &amp; IterBuffered functions to wrap two variables together over a channel,\ntype Tuple[V any] struct &#123;\n\tKey string\n\tVal V\n&#125;\n\n&#x2F;&#x2F; Iter returns an iterator which could be used in a for range loop.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Deprecated: using IterBuffered() will get a better performence\nfunc (m ConcurrentMap[V]) Iter() &lt;-chan Tuple[V] &#123;\n\tchans :&#x3D; snapshot(m)\n\tch :&#x3D; make(chan Tuple[V])\n\tgo fanIn(chans, ch)\n\treturn ch\n&#125;\n\n&#x2F;&#x2F; IterBuffered returns a buffered iterator which could be used in a for range loop.\nfunc (m ConcurrentMap[V]) IterBuffered() &lt;-chan Tuple[V] &#123;\n\tchans :&#x3D; snapshot(m)\n\ttotal :&#x3D; 0\n\tfor _, c :&#x3D; range chans &#123;\n\t\ttotal +&#x3D; cap(c)\n\t&#125;\n\tch :&#x3D; make(chan Tuple[V], total)\n\tgo fanIn(chans, ch)\n\treturn ch\n&#125;\n\n&#x2F;&#x2F; Clear removes all items from map.\nfunc (m ConcurrentMap[V]) Clear() &#123;\n\tfor item :&#x3D; range m.IterBuffered() &#123;\n\t\tm.Remove(item.Key)\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; Returns a array of channels that contains elements in each shard,\n&#x2F;&#x2F; which likely takes a snapshot of &#96;m&#96;.\n&#x2F;&#x2F; It returns once the size of each buffered channel is determined,\n&#x2F;&#x2F; before all the channels are populated using goroutines.\nfunc snapshot[V any](m ConcurrentMap[V]) (chans []chan Tuple[V]) &#123;\n\t&#x2F;&#x2F;When you access map items before initializing.\n\tif len(m) &#x3D;&#x3D; 0 &#123;\n\t\tpanic(&#96;cmap.ConcurrentMap is not initialized. Should run New() before usage.&#96;)\n\t&#125;\n\tchans &#x3D; make([]chan Tuple[V], SHARD_COUNT)\n\twg :&#x3D; sync.WaitGroup&#123;&#125;\n\twg.Add(SHARD_COUNT)\n\t&#x2F;&#x2F; Foreach shard.\n\tfor index, shard :&#x3D; range m &#123;\n\t\tgo func(index int, shard *ConcurrentMapShared[V]) &#123;\n\t\t\t&#x2F;&#x2F; Foreach key, value pair.\n\t\t\tshard.RLock()\n\t\t\tchans[index] &#x3D; make(chan Tuple[V], len(shard.items))\n\t\t\twg.Done()\n\t\t\tfor key, val :&#x3D; range shard.items &#123;\n\t\t\t\tchans[index] &lt;- Tuple[V]&#123;key, val&#125;\n\t\t\t&#125;\n\t\t\tshard.RUnlock()\n\t\t\tclose(chans[index])\n\t\t&#125;(index, shard)\n\t&#125;\n\twg.Wait()\n\treturn chans\n&#125;\n\n&#x2F;&#x2F; fanIn reads elements from channels &#96;chans&#96; into channel &#96;out&#96;\nfunc fanIn[V any](chans []chan Tuple[V], out chan Tuple[V]) &#123;\n\twg :&#x3D; sync.WaitGroup&#123;&#125;\n\twg.Add(len(chans))\n\tfor _, ch :&#x3D; range chans &#123;\n\t\tgo func(ch chan Tuple[V]) &#123;\n\t\t\tfor t :&#x3D; range ch &#123;\n\t\t\t\tout &lt;- t\n\t\t\t&#125;\n\t\t\twg.Done()\n\t\t&#125;(ch)\n\t&#125;\n\twg.Wait()\n\tclose(out)\n&#125;\n\n&#x2F;&#x2F; Items returns all items as map[string]V\nfunc (m ConcurrentMap[V]) Items() map[string]V &#123;\n\ttmp :&#x3D; make(map[string]V)\n\n\t&#x2F;&#x2F; Insert items to temporary map.\n\tfor item :&#x3D; range m.IterBuffered() &#123;\n\t\ttmp[item.Key] &#x3D; item.Val\n\t&#125;\n\n\treturn tmp\n&#125;\n\n&#x2F;&#x2F; Iterator callbacalled for every key,value found in\n&#x2F;&#x2F; maps. RLock is held for all calls for a given shard\n&#x2F;&#x2F; therefore callback sess consistent view of a shard,\n&#x2F;&#x2F; but not across the shards\ntype IterCb[V any] func(key string, v V)\n\n&#x2F;&#x2F; Callback based iterator, cheapest way to read\n&#x2F;&#x2F; all elements in a map.\nfunc (m ConcurrentMap[V]) IterCb(fn IterCb[V]) &#123;\n\tfor idx :&#x3D; range m &#123;\n\t\tshard :&#x3D; (m)[idx]\n\t\tshard.RLock()\n\t\tfor key, value :&#x3D; range shard.items &#123;\n\t\t\tfn(key, value)\n\t\t&#125;\n\t\tshard.RUnlock()\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; Keys returns all keys as []string\nfunc (m ConcurrentMap[V]) Keys() []string &#123;\n\tcount :&#x3D; m.Count()\n\tch :&#x3D; make(chan string, count)\n\tgo func() &#123;\n\t\t&#x2F;&#x2F; Foreach shard.\n\t\twg :&#x3D; sync.WaitGroup&#123;&#125;\n\t\twg.Add(SHARD_COUNT)\n\t\tfor _, shard :&#x3D; range m &#123;\n\t\t\tgo func(shard *ConcurrentMapShared[V]) &#123;\n\t\t\t\t&#x2F;&#x2F; Foreach key, value pair.\n\t\t\t\tshard.RLock()\n\t\t\t\tfor key :&#x3D; range shard.items &#123;\n\t\t\t\t\tch &lt;- key\n\t\t\t\t&#125;\n\t\t\t\tshard.RUnlock()\n\t\t\t\twg.Done()\n\t\t\t&#125;(shard)\n\t\t&#125;\n\t\twg.Wait()\n\t\tclose(ch)\n\t&#125;()\n\n\t&#x2F;&#x2F; Generate keys\n\tkeys :&#x3D; make([]string, 0, count)\n\tfor k :&#x3D; range ch &#123;\n\t\tkeys &#x3D; append(keys, k)\n\t&#125;\n\treturn keys\n&#125;\n\n&#x2F;&#x2F;Reviles ConcurrentMap &quot;private&quot; variables to json marshal.\nfunc (m ConcurrentMap[V]) MarshalJSON() ([]byte, error) &#123;\n\t&#x2F;&#x2F; Create a temporary map, which will hold all item spread across shards.\n\ttmp :&#x3D; make(map[string]V)\n\n\t&#x2F;&#x2F; Insert items to temporary map.\n\tfor item :&#x3D; range m.IterBuffered() &#123;\n\t\ttmp[item.Key] &#x3D; item.Val\n\t&#125;\n\treturn json.Marshal(tmp)\n&#125;\n\nfunc fnv32(key string) uint32 &#123;\n\thash :&#x3D; uint32(2166136261)\n\tconst prime32 &#x3D; uint32(16777619)\n\tkeyLength :&#x3D; len(key)\n\tfor i :&#x3D; 0; i &lt; keyLength; i++ &#123;\n\t\thash *&#x3D; prime32\n\t\thash ^&#x3D; uint32(key[i])\n\t&#125;\n\treturn hash\n&#125;\n\n&#x2F;&#x2F; Reverse process of Marshal.\nfunc (m *ConcurrentMap[V]) UnmarshalJSON(b []byte) (err error) &#123;\n \ttmp :&#x3D; make(map[string]V)\n\n \t&#x2F;&#x2F; Unmarshal into a single map.\n \tif err :&#x3D; json.Unmarshal(b, &amp;tmp); err !&#x3D; nil &#123;\n \t\treturn err\n \t&#125;\n\n \t&#x2F;&#x2F; foreach key,value pair in temporary map insert into our concurrent map.\n \tfor key, val :&#x3D; range tmp &#123;\n \t\tm.Set(key, val)\n \t&#125;\n\treturn nil\n&#125;</code></pre>\n\n</details>\n\n<p>总结</p>\n<ul>\n<li>通过这个concurrency-map学习了golang的泛型，golang具体泛型内容可以阅读对应的笔记</li>\n<li>说实话作者这种数据结构还是没太理解，不理解why，但是能看懂代码。应该先尝试试着了解数据结构</li>\n</ul>\n"},{"title":"更新origin 和upstream url链接","_content":"\n## 背景\n本地想更改项目代码的绑定的github链接，但是repo的url变了。\n`remote: This repository moved. Please use the new location [new location]` 的警示。因為你的git連結位置有變動因此要修改本機端的git remote位置。另外一种场景下载别人的代码库，并做修改最后推到自己的github，这个github repo\n\n## 解决办法\n- 绑定本地origin仓库\n    ```bash\n    git remote set-url origin https://XXX.git\n    ```\n- 绑定upstream仓库\n    ```bash\n    $ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git\n    ```","source":"_posts/archive/remote_github.md","raw":"---\ntitle: 更新origin 和upstream url链接\ncategories: \n- archive\n---\n\n## 背景\n本地想更改项目代码的绑定的github链接，但是repo的url变了。\n`remote: This repository moved. Please use the new location [new location]` 的警示。因為你的git連結位置有變動因此要修改本機端的git remote位置。另外一种场景下载别人的代码库，并做修改最后推到自己的github，这个github repo\n\n## 解决办法\n- 绑定本地origin仓库\n    ```bash\n    git remote set-url origin https://XXX.git\n    ```\n- 绑定upstream仓库\n    ```bash\n    $ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git\n    ```","slug":"archive/remote_github","published":1,"date":"2022-08-26T13:14:30.506Z","updated":"2022-09-09T11:07:29.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5q0011l1db1bz6hksk","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>本地想更改项目代码的绑定的github链接，但是repo的url变了。<br><code>remote: This repository moved. Please use the new location [new location]</code> 的警示。因為你的git連結位置有變動因此要修改本機端的git remote位置。另外一种场景下载别人的代码库，并做修改最后推到自己的github，这个github repo</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><ul>\n<li>绑定本地origin仓库  <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> remote set-url origin https://XXX.git</code></pre></li>\n<li>绑定upstream仓库  <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> remote <span class=\"token function\">add</span> upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>本地想更改项目代码的绑定的github链接，但是repo的url变了。<br><code>remote: This repository moved. Please use the new location [new location]</code> 的警示。因為你的git連結位置有變動因此要修改本機端的git remote位置。另外一种场景下载别人的代码库，并做修改最后推到自己的github，这个github repo</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><ul>\n<li>绑定本地origin仓库  <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> remote set-url origin https://XXX.git</code></pre></li>\n<li>绑定upstream仓库  <pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> remote <span class=\"token function\">add</span> upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</code></pre></li>\n</ul>\n"},{"title":"内存高效golang","_content":"\n> 原文链接 : https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick\n\n# Golang编写内存高效和CPU优化的Go结构\n\n结构是一个类型化的field集合，对于将数据分组记录非常有用。这使得与一个`strcut`有关的所有数据都被整齐地封装在一个轻量级的类型定义中，然后可以通过定义结构类型上的函数来实现行为。\n\n这篇博客我将尝试解释我们如何在内存使用和CPU周期方面有效地编写结构。\n\n让我们考虑下面这个结构，为我的一些奇怪的用例定义畸形资源类型。\n\n```golang\ntype TerraformResource struct {\n  Cloud                string                       // 16 bytes\n  Name                 string                       // 16 bytes\n  HaveDSL              bool                         //  1 byte\n  PluginVersion        string                       // 16 bytes\n  IsVersionControlled  bool                         //  1 byte\n  TerraformVersion     string                       // 16 bytes\n  ModuleVersionMajor   int32                        //  4 bytes\n}\n\n```\n让我们用下面的代码看看TerraformResource结构需要多少内存分配。\n```golang\n\npackage main\n\nimport \"fmt\"\nimport \"unsafe\"\n\ntype TerraformResource struct {\n  Cloud                string                       // 16 bytes\n  Name                 string                       // 16 bytes\n  HaveDSL              bool                         //  1 byte\n  PluginVersion        string                       // 16 bytes\n  IsVersionControlled  bool                         //  1 byte\n  TerraformVersion     string                       // 16 bytes\n  ModuleVersionMajor   int32                        //  4 bytes\n}\n\nfunc main() {\n    var d TerraformResource\n    d.Cloud = \"aws\"\n    d.Name = \"ec2\"\n    d.HaveDSL = true\n    d.PluginVersion = \"3.64\"\n    d.TerraformVersion = \"1.1\"\n    d.ModuleVersionMajor = 1\n    d.IsVersionControlled = true\n    fmt.Println(\"==============================================================\")\n    fmt.Printf(\"Total Memory Usage StructType:d %T => [%d]\\n\", d, unsafe.Sizeof(d))\n    fmt.Println(\"==============================================================\")\n    fmt.Printf(\"Cloud Field StructType:d.Cloud %T => [%d]\\n\", d.Cloud, unsafe.Sizeof(d.Cloud))\n    fmt.Printf(\"Name Field StructType:d.Name %T => [%d]\\n\", d.Name, unsafe.Sizeof(d.Name))\n    fmt.Printf(\"HaveDSL Field StructType:d.HaveDSL %T => [%d]\\n\", d.HaveDSL, unsafe.Sizeof(d.HaveDSL))\n    fmt.Printf(\"PluginVersion Field StructType:d.PluginVersion %T => [%d]\\n\", d.PluginVersion, unsafe.Sizeof(d.PluginVersion))\n    fmt.Printf(\"ModuleVersionMajor Field StructType:d.IsVersionControlled %T => [%d]\\n\", d.IsVersionControlled, unsafe.Sizeof(d.IsVersionControlled))\n    fmt.Printf(\"TerraformVersion Field StructType:d.TerraformVersion %T => [%d]\\n\", d.TerraformVersion, unsafe.Sizeof(d.TerraformVersion))\n    fmt.Printf(\"ModuleVersionMajor Field StructType:d.ModuleVersionMajor %T => [%d]\\n\", d.ModuleVersionMajor, unsafe.Sizeof(d.ModuleVersionMajor))  \n}\n```\noutput如下\n```golang\n==============================================================\nTotal Memory Usage StructType:d main.TerraformResource => [88]\n==============================================================\nCloud Field StructType:d.Cloud string => [16]\nName Field StructType:d.Name string => [16]\nHaveDSL Field StructType:d.HaveDSL bool => [1]\nPluginVersion Field StructType:d.PluginVersion string => [16]\nModuleVersionMajor Field StructType:d.IsVersionControlled bool => [1]\nTerraformVersion Field StructType:d.TerraformVersion string => [16]\nModuleVersionMajor Field StructType:d.ModuleVersionMajor int32 => [4]\n```\n所以TerraformResource结构需要的总内存分配是88字节。这就是TerraformResource类型的内存分配情况\n![TerraformResource类型的内存分配情况](https://res.cloudinary.com/practicaldev/image/fetch/s--HubwVUeX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/01-golang-struct-memory-map.jpeg)\n\n但为什么会有88个字节，16+16+1+16+1+16+4=70个字节，这额外的18个字节从何而来？\n\n当涉及到结构体的内存分配时，它们总是被分配为连续的、字节对齐的内存块，并且字段是按照它们被定义的顺序分配和存储的。在这种情况下，**字节对齐**的概念意味着连续的内存块以与平台字大小相同的偏移量对齐。\n![](https://res.cloudinary.com/practicaldev/image/fetch/s--S_4mkd0a--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/02-golang-struct-memory-map.jpeg)\n\n我们可以清楚地看到，TerraformResource.HaveDSL , TerraformResource.isVersionControlled和TerraformResource.ModuleVersionMajor分别只占用了1个字节、1个字节和4个字节。其余的空间都是用空的焊盘字节填充的。\n\n所以回到同样的数学问题上\n\n> 分配字节=16字节+16字节+1字节+16字节+1字节+16字节+4字节  \n空垫字节=7字节+7字节+4字节=18字节  \n总字节数=分配字节数+空垫字节数=70字节+18字节=88字节\n\n那么，我们该如何解决这个问题呢？通过适当的数据结构调整，如果我们重新定义我们的结构，就像这样\n```golang\ntype TerraformResource struct {\n  Cloud                string                       // 16 bytes\n  Name                 string                       // 16 bytes\n  PluginVersion        string                       // 16 bytes\n  TerraformVersion     string                       // 16 bytes\n  ModuleVersionMajor   int32                        //  4 bytes\n  HaveDSL              bool                         //  1 byte\n  IsVersionControlled  bool                         //  1 byte\n}\n\n```\n测试代码如下\n```golang\npackage main\n\nimport \"fmt\"\nimport \"unsafe\"\n\ntype TerraformResource struct {\n  Cloud                string                       // 16 bytes\n  Name                 string                       // 16 bytes\n  PluginVersion        string                       // 16 bytes\n  TerraformVersion     string                       // 16 bytes\n  ModuleVersionMajor   int32                        //  4 bytes\n  HaveDSL              bool                         //  1 byte\n  IsVersionControlled  bool                         //  1 byte\n}\n\nfunc main() {\n    var d TerraformResource\n    d.Cloud = \"aws\"\n    d.Name = \"ec2\"\n    d.HaveDSL = true\n    d.PluginVersion = \"3.64\"\n    d.TerraformVersion = \"1.1\"\n    d.ModuleVersionMajor = 1\n    d.IsVersionControlled = true\n    fmt.Println(\"==============================================================\")\n    fmt.Printf(\"Total Memory Usage StructType:d %T => [%d]\\n\", d, unsafe.Sizeof(d))\n    fmt.Println(\"==============================================================\")\n    fmt.Printf(\"Cloud Field StructType:d.Cloud %T => [%d]\\n\", d.Cloud, unsafe.Sizeof(d.Cloud))\n    fmt.Printf(\"Name Field StructType:d.Name %T => [%d]\\n\", d.Name, unsafe.Sizeof(d.Name))\n    fmt.Printf(\"HaveDSL Field StructType:d.HaveDSL %T => [%d]\\n\", d.HaveDSL, unsafe.Sizeof(d.HaveDSL))\n    fmt.Printf(\"PluginVersion Field StructType:d.PluginVersion %T => [%d]\\n\", d.PluginVersion, unsafe.Sizeof(d.PluginVersion))\n    fmt.Printf(\"ModuleVersionMajor Field StructType:d.IsVersionControlled %T => [%d]\\n\", d.IsVersionControlled, unsafe.Sizeof(d.IsVersionControlled))\n    fmt.Printf(\"TerraformVersion Field StructType:d.TerraformVersion %T => [%d]\\n\", d.TerraformVersion, unsafe.Sizeof(d.TerraformVersion))\n    fmt.Printf(\"ModuleVersionMajor Field StructType:d.ModuleVersionMajor %T => [%d]\\n\", d.ModuleVersionMajor, unsafe.Sizeof(d.ModuleVersionMajor))\n}\n\n\n```\noutput如下\n\n```golang\ngo run golang-struct-memory-allocation-optimized.go\n\n==============================================================\nTotal Memory Usage StructType:d main.TerraformResource => [72]\n==============================================================\nCloud Field StructType:d.Cloud string => [16]\nName Field StructType:d.Name string => [16]\nHaveDSL Field StructType:d.HaveDSL bool => [1]\nPluginVersion Field StructType:d.PluginVersion string => [16]\nModuleVersionMajor Field StructType:d.IsVersionControlled bool => [1]\nTerraformVersion Field StructType:d.TerraformVersion string => [16]\nModuleVersionMajor Field StructType:d.ModuleVersionMajor int32 => [4]\n\n```\n现在TerraformResource类型的总内存分配是72字节。让我们看看内存的排列方式是什么样子的\n\n![](https://res.cloudinary.com/practicaldev/image/fetch/s--V9hRLdR1--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/03-golang-struct-memory-map.jpeg)\n\n仅仅通过对结构元素进行适当的数据结构对齐，我们就能够将内存占用从88字节减少到72字节....，很好!\n\n让我们检查一下数学运算\n\n> 分配字节=16字节+16字节+16字节+16字节+4字节+1字节+1字节=70字节\n空垫字节=2字节  \n总字节数=分配字节数+空垫字节数=70字节+2字节=72字节\n\n适当的数据结构排列不仅可以帮助我们有效地使用内存，还可以帮助CPU读取周期....，如何？\n\nCPU以字为单位读取内存，32位系统为4字节，64位系统为8字节。现在，我们的第一个结构类型TerraformResource的声明将需要11个字来让CPU读取所有内容。\n\n![](https://res.cloudinary.com/practicaldev/image/fetch/s--YxrCrSAs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/01-golang-struct-word-length.jpeg)\n\n然而，优化后的结构只需要9个字，如下图所示\n![](https://res.cloudinary.com/practicaldev/image/fetch/s--_N8r3Z9U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/02-golang-struct-word-length.jpeg)\n\n通过正确定义结构体的数据结构，我们能够有效地使用内存分配，并使结构体在CPU读取方面也变得快速有效。\n\n这只是一个小例子，想想一个有20或30个不同类型字段的大型结构。对数据结构进行深思熟虑的调整真的很有价值......🤩\n\n希望这篇博客能够对结构的内部结构、其内存分配和所需的CPU读取周期有一些启发。希望这对你有帮助！!","source":"_posts/archive/内存高效golang.md","raw":"---\ntitle: 内存高效golang\ncategories: \n- archive\n- golang\n\n---\n\n> 原文链接 : https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick\n\n# Golang编写内存高效和CPU优化的Go结构\n\n结构是一个类型化的field集合，对于将数据分组记录非常有用。这使得与一个`strcut`有关的所有数据都被整齐地封装在一个轻量级的类型定义中，然后可以通过定义结构类型上的函数来实现行为。\n\n这篇博客我将尝试解释我们如何在内存使用和CPU周期方面有效地编写结构。\n\n让我们考虑下面这个结构，为我的一些奇怪的用例定义畸形资源类型。\n\n```golang\ntype TerraformResource struct {\n  Cloud                string                       // 16 bytes\n  Name                 string                       // 16 bytes\n  HaveDSL              bool                         //  1 byte\n  PluginVersion        string                       // 16 bytes\n  IsVersionControlled  bool                         //  1 byte\n  TerraformVersion     string                       // 16 bytes\n  ModuleVersionMajor   int32                        //  4 bytes\n}\n\n```\n让我们用下面的代码看看TerraformResource结构需要多少内存分配。\n```golang\n\npackage main\n\nimport \"fmt\"\nimport \"unsafe\"\n\ntype TerraformResource struct {\n  Cloud                string                       // 16 bytes\n  Name                 string                       // 16 bytes\n  HaveDSL              bool                         //  1 byte\n  PluginVersion        string                       // 16 bytes\n  IsVersionControlled  bool                         //  1 byte\n  TerraformVersion     string                       // 16 bytes\n  ModuleVersionMajor   int32                        //  4 bytes\n}\n\nfunc main() {\n    var d TerraformResource\n    d.Cloud = \"aws\"\n    d.Name = \"ec2\"\n    d.HaveDSL = true\n    d.PluginVersion = \"3.64\"\n    d.TerraformVersion = \"1.1\"\n    d.ModuleVersionMajor = 1\n    d.IsVersionControlled = true\n    fmt.Println(\"==============================================================\")\n    fmt.Printf(\"Total Memory Usage StructType:d %T => [%d]\\n\", d, unsafe.Sizeof(d))\n    fmt.Println(\"==============================================================\")\n    fmt.Printf(\"Cloud Field StructType:d.Cloud %T => [%d]\\n\", d.Cloud, unsafe.Sizeof(d.Cloud))\n    fmt.Printf(\"Name Field StructType:d.Name %T => [%d]\\n\", d.Name, unsafe.Sizeof(d.Name))\n    fmt.Printf(\"HaveDSL Field StructType:d.HaveDSL %T => [%d]\\n\", d.HaveDSL, unsafe.Sizeof(d.HaveDSL))\n    fmt.Printf(\"PluginVersion Field StructType:d.PluginVersion %T => [%d]\\n\", d.PluginVersion, unsafe.Sizeof(d.PluginVersion))\n    fmt.Printf(\"ModuleVersionMajor Field StructType:d.IsVersionControlled %T => [%d]\\n\", d.IsVersionControlled, unsafe.Sizeof(d.IsVersionControlled))\n    fmt.Printf(\"TerraformVersion Field StructType:d.TerraformVersion %T => [%d]\\n\", d.TerraformVersion, unsafe.Sizeof(d.TerraformVersion))\n    fmt.Printf(\"ModuleVersionMajor Field StructType:d.ModuleVersionMajor %T => [%d]\\n\", d.ModuleVersionMajor, unsafe.Sizeof(d.ModuleVersionMajor))  \n}\n```\noutput如下\n```golang\n==============================================================\nTotal Memory Usage StructType:d main.TerraformResource => [88]\n==============================================================\nCloud Field StructType:d.Cloud string => [16]\nName Field StructType:d.Name string => [16]\nHaveDSL Field StructType:d.HaveDSL bool => [1]\nPluginVersion Field StructType:d.PluginVersion string => [16]\nModuleVersionMajor Field StructType:d.IsVersionControlled bool => [1]\nTerraformVersion Field StructType:d.TerraformVersion string => [16]\nModuleVersionMajor Field StructType:d.ModuleVersionMajor int32 => [4]\n```\n所以TerraformResource结构需要的总内存分配是88字节。这就是TerraformResource类型的内存分配情况\n![TerraformResource类型的内存分配情况](https://res.cloudinary.com/practicaldev/image/fetch/s--HubwVUeX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/01-golang-struct-memory-map.jpeg)\n\n但为什么会有88个字节，16+16+1+16+1+16+4=70个字节，这额外的18个字节从何而来？\n\n当涉及到结构体的内存分配时，它们总是被分配为连续的、字节对齐的内存块，并且字段是按照它们被定义的顺序分配和存储的。在这种情况下，**字节对齐**的概念意味着连续的内存块以与平台字大小相同的偏移量对齐。\n![](https://res.cloudinary.com/practicaldev/image/fetch/s--S_4mkd0a--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/02-golang-struct-memory-map.jpeg)\n\n我们可以清楚地看到，TerraformResource.HaveDSL , TerraformResource.isVersionControlled和TerraformResource.ModuleVersionMajor分别只占用了1个字节、1个字节和4个字节。其余的空间都是用空的焊盘字节填充的。\n\n所以回到同样的数学问题上\n\n> 分配字节=16字节+16字节+1字节+16字节+1字节+16字节+4字节  \n空垫字节=7字节+7字节+4字节=18字节  \n总字节数=分配字节数+空垫字节数=70字节+18字节=88字节\n\n那么，我们该如何解决这个问题呢？通过适当的数据结构调整，如果我们重新定义我们的结构，就像这样\n```golang\ntype TerraformResource struct {\n  Cloud                string                       // 16 bytes\n  Name                 string                       // 16 bytes\n  PluginVersion        string                       // 16 bytes\n  TerraformVersion     string                       // 16 bytes\n  ModuleVersionMajor   int32                        //  4 bytes\n  HaveDSL              bool                         //  1 byte\n  IsVersionControlled  bool                         //  1 byte\n}\n\n```\n测试代码如下\n```golang\npackage main\n\nimport \"fmt\"\nimport \"unsafe\"\n\ntype TerraformResource struct {\n  Cloud                string                       // 16 bytes\n  Name                 string                       // 16 bytes\n  PluginVersion        string                       // 16 bytes\n  TerraformVersion     string                       // 16 bytes\n  ModuleVersionMajor   int32                        //  4 bytes\n  HaveDSL              bool                         //  1 byte\n  IsVersionControlled  bool                         //  1 byte\n}\n\nfunc main() {\n    var d TerraformResource\n    d.Cloud = \"aws\"\n    d.Name = \"ec2\"\n    d.HaveDSL = true\n    d.PluginVersion = \"3.64\"\n    d.TerraformVersion = \"1.1\"\n    d.ModuleVersionMajor = 1\n    d.IsVersionControlled = true\n    fmt.Println(\"==============================================================\")\n    fmt.Printf(\"Total Memory Usage StructType:d %T => [%d]\\n\", d, unsafe.Sizeof(d))\n    fmt.Println(\"==============================================================\")\n    fmt.Printf(\"Cloud Field StructType:d.Cloud %T => [%d]\\n\", d.Cloud, unsafe.Sizeof(d.Cloud))\n    fmt.Printf(\"Name Field StructType:d.Name %T => [%d]\\n\", d.Name, unsafe.Sizeof(d.Name))\n    fmt.Printf(\"HaveDSL Field StructType:d.HaveDSL %T => [%d]\\n\", d.HaveDSL, unsafe.Sizeof(d.HaveDSL))\n    fmt.Printf(\"PluginVersion Field StructType:d.PluginVersion %T => [%d]\\n\", d.PluginVersion, unsafe.Sizeof(d.PluginVersion))\n    fmt.Printf(\"ModuleVersionMajor Field StructType:d.IsVersionControlled %T => [%d]\\n\", d.IsVersionControlled, unsafe.Sizeof(d.IsVersionControlled))\n    fmt.Printf(\"TerraformVersion Field StructType:d.TerraformVersion %T => [%d]\\n\", d.TerraformVersion, unsafe.Sizeof(d.TerraformVersion))\n    fmt.Printf(\"ModuleVersionMajor Field StructType:d.ModuleVersionMajor %T => [%d]\\n\", d.ModuleVersionMajor, unsafe.Sizeof(d.ModuleVersionMajor))\n}\n\n\n```\noutput如下\n\n```golang\ngo run golang-struct-memory-allocation-optimized.go\n\n==============================================================\nTotal Memory Usage StructType:d main.TerraformResource => [72]\n==============================================================\nCloud Field StructType:d.Cloud string => [16]\nName Field StructType:d.Name string => [16]\nHaveDSL Field StructType:d.HaveDSL bool => [1]\nPluginVersion Field StructType:d.PluginVersion string => [16]\nModuleVersionMajor Field StructType:d.IsVersionControlled bool => [1]\nTerraformVersion Field StructType:d.TerraformVersion string => [16]\nModuleVersionMajor Field StructType:d.ModuleVersionMajor int32 => [4]\n\n```\n现在TerraformResource类型的总内存分配是72字节。让我们看看内存的排列方式是什么样子的\n\n![](https://res.cloudinary.com/practicaldev/image/fetch/s--V9hRLdR1--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/03-golang-struct-memory-map.jpeg)\n\n仅仅通过对结构元素进行适当的数据结构对齐，我们就能够将内存占用从88字节减少到72字节....，很好!\n\n让我们检查一下数学运算\n\n> 分配字节=16字节+16字节+16字节+16字节+4字节+1字节+1字节=70字节\n空垫字节=2字节  \n总字节数=分配字节数+空垫字节数=70字节+2字节=72字节\n\n适当的数据结构排列不仅可以帮助我们有效地使用内存，还可以帮助CPU读取周期....，如何？\n\nCPU以字为单位读取内存，32位系统为4字节，64位系统为8字节。现在，我们的第一个结构类型TerraformResource的声明将需要11个字来让CPU读取所有内容。\n\n![](https://res.cloudinary.com/practicaldev/image/fetch/s--YxrCrSAs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/01-golang-struct-word-length.jpeg)\n\n然而，优化后的结构只需要9个字，如下图所示\n![](https://res.cloudinary.com/practicaldev/image/fetch/s--_N8r3Z9U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/02-golang-struct-word-length.jpeg)\n\n通过正确定义结构体的数据结构，我们能够有效地使用内存分配，并使结构体在CPU读取方面也变得快速有效。\n\n这只是一个小例子，想想一个有20或30个不同类型字段的大型结构。对数据结构进行深思熟虑的调整真的很有价值......🤩\n\n希望这篇博客能够对结构的内部结构、其内存分配和所需的CPU读取周期有一些启发。希望这对你有帮助！!","slug":"archive/内存高效golang","published":1,"date":"2022-08-26T13:18:06.856Z","updated":"2022-08-27T03:42:39.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5r0014l1db5tooef1v","content":"<blockquote>\n<p>原文链接 : <a href=\"https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick\">https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick</a></p>\n</blockquote>\n<h1 id=\"Golang编写内存高效和CPU优化的Go结构\"><a href=\"#Golang编写内存高效和CPU优化的Go结构\" class=\"headerlink\" title=\"Golang编写内存高效和CPU优化的Go结构\"></a>Golang编写内存高效和CPU优化的Go结构</h1><p>结构是一个类型化的field集合，对于将数据分组记录非常有用。这使得与一个<code>strcut</code>有关的所有数据都被整齐地封装在一个轻量级的类型定义中，然后可以通过定义结构类型上的函数来实现行为。</p>\n<p>这篇博客我将尝试解释我们如何在内存使用和CPU周期方面有效地编写结构。</p>\n<p>让我们考虑下面这个结构，为我的一些奇怪的用例定义畸形资源类型。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type TerraformResource struct &#123;\n  Cloud                string                       &#x2F;&#x2F; 16 bytes\n  Name                 string                       &#x2F;&#x2F; 16 bytes\n  HaveDSL              bool                         &#x2F;&#x2F;  1 byte\n  PluginVersion        string                       &#x2F;&#x2F; 16 bytes\n  IsVersionControlled  bool                         &#x2F;&#x2F;  1 byte\n  TerraformVersion     string                       &#x2F;&#x2F; 16 bytes\n  ModuleVersionMajor   int32                        &#x2F;&#x2F;  4 bytes\n&#125;\n</code></pre>\n<p>让我们用下面的代码看看TerraformResource结构需要多少内存分配。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage main\n\nimport &quot;fmt&quot;\nimport &quot;unsafe&quot;\n\ntype TerraformResource struct &#123;\n  Cloud                string                       &#x2F;&#x2F; 16 bytes\n  Name                 string                       &#x2F;&#x2F; 16 bytes\n  HaveDSL              bool                         &#x2F;&#x2F;  1 byte\n  PluginVersion        string                       &#x2F;&#x2F; 16 bytes\n  IsVersionControlled  bool                         &#x2F;&#x2F;  1 byte\n  TerraformVersion     string                       &#x2F;&#x2F; 16 bytes\n  ModuleVersionMajor   int32                        &#x2F;&#x2F;  4 bytes\n&#125;\n\nfunc main() &#123;\n    var d TerraformResource\n    d.Cloud &#x3D; &quot;aws&quot;\n    d.Name &#x3D; &quot;ec2&quot;\n    d.HaveDSL &#x3D; true\n    d.PluginVersion &#x3D; &quot;3.64&quot;\n    d.TerraformVersion &#x3D; &quot;1.1&quot;\n    d.ModuleVersionMajor &#x3D; 1\n    d.IsVersionControlled &#x3D; true\n    fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    fmt.Printf(&quot;Total Memory Usage StructType:d %T &#x3D;&gt; [%d]\\n&quot;, d, unsafe.Sizeof(d))\n    fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    fmt.Printf(&quot;Cloud Field StructType:d.Cloud %T &#x3D;&gt; [%d]\\n&quot;, d.Cloud, unsafe.Sizeof(d.Cloud))\n    fmt.Printf(&quot;Name Field StructType:d.Name %T &#x3D;&gt; [%d]\\n&quot;, d.Name, unsafe.Sizeof(d.Name))\n    fmt.Printf(&quot;HaveDSL Field StructType:d.HaveDSL %T &#x3D;&gt; [%d]\\n&quot;, d.HaveDSL, unsafe.Sizeof(d.HaveDSL))\n    fmt.Printf(&quot;PluginVersion Field StructType:d.PluginVersion %T &#x3D;&gt; [%d]\\n&quot;, d.PluginVersion, unsafe.Sizeof(d.PluginVersion))\n    fmt.Printf(&quot;ModuleVersionMajor Field StructType:d.IsVersionControlled %T &#x3D;&gt; [%d]\\n&quot;, d.IsVersionControlled, unsafe.Sizeof(d.IsVersionControlled))\n    fmt.Printf(&quot;TerraformVersion Field StructType:d.TerraformVersion %T &#x3D;&gt; [%d]\\n&quot;, d.TerraformVersion, unsafe.Sizeof(d.TerraformVersion))\n    fmt.Printf(&quot;ModuleVersionMajor Field StructType:d.ModuleVersionMajor %T &#x3D;&gt; [%d]\\n&quot;, d.ModuleVersionMajor, unsafe.Sizeof(d.ModuleVersionMajor))  \n&#125;</code></pre>\n<p>output如下</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nTotal Memory Usage StructType:d main.TerraformResource &#x3D;&gt; [88]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nCloud Field StructType:d.Cloud string &#x3D;&gt; [16]\nName Field StructType:d.Name string &#x3D;&gt; [16]\nHaveDSL Field StructType:d.HaveDSL bool &#x3D;&gt; [1]\nPluginVersion Field StructType:d.PluginVersion string &#x3D;&gt; [16]\nModuleVersionMajor Field StructType:d.IsVersionControlled bool &#x3D;&gt; [1]\nTerraformVersion Field StructType:d.TerraformVersion string &#x3D;&gt; [16]\nModuleVersionMajor Field StructType:d.ModuleVersionMajor int32 &#x3D;&gt; [4]</code></pre>\n<p>所以TerraformResource结构需要的总内存分配是88字节。这就是TerraformResource类型的内存分配情况<br><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--HubwVUeX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/01-golang-struct-memory-map.jpeg\" alt=\"TerraformResource类型的内存分配情况\"></p>\n<p>但为什么会有88个字节，16+16+1+16+1+16+4&#x3D;70个字节，这额外的18个字节从何而来？</p>\n<p>当涉及到结构体的内存分配时，它们总是被分配为连续的、字节对齐的内存块，并且字段是按照它们被定义的顺序分配和存储的。在这种情况下，<strong>字节对齐</strong>的概念意味着连续的内存块以与平台字大小相同的偏移量对齐。<br><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--S_4mkd0a--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/02-golang-struct-memory-map.jpeg\"></p>\n<p>我们可以清楚地看到，TerraformResource.HaveDSL , TerraformResource.isVersionControlled和TerraformResource.ModuleVersionMajor分别只占用了1个字节、1个字节和4个字节。其余的空间都是用空的焊盘字节填充的。</p>\n<p>所以回到同样的数学问题上</p>\n<blockquote>\n<p>分配字节&#x3D;16字节+16字节+1字节+16字节+1字节+16字节+4字节<br>空垫字节&#x3D;7字节+7字节+4字节&#x3D;18字节<br>总字节数&#x3D;分配字节数+空垫字节数&#x3D;70字节+18字节&#x3D;88字节</p>\n</blockquote>\n<p>那么，我们该如何解决这个问题呢？通过适当的数据结构调整，如果我们重新定义我们的结构，就像这样</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type TerraformResource struct &#123;\n  Cloud                string                       &#x2F;&#x2F; 16 bytes\n  Name                 string                       &#x2F;&#x2F; 16 bytes\n  PluginVersion        string                       &#x2F;&#x2F; 16 bytes\n  TerraformVersion     string                       &#x2F;&#x2F; 16 bytes\n  ModuleVersionMajor   int32                        &#x2F;&#x2F;  4 bytes\n  HaveDSL              bool                         &#x2F;&#x2F;  1 byte\n  IsVersionControlled  bool                         &#x2F;&#x2F;  1 byte\n&#125;\n</code></pre>\n<p>测试代码如下</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;fmt&quot;\nimport &quot;unsafe&quot;\n\ntype TerraformResource struct &#123;\n  Cloud                string                       &#x2F;&#x2F; 16 bytes\n  Name                 string                       &#x2F;&#x2F; 16 bytes\n  PluginVersion        string                       &#x2F;&#x2F; 16 bytes\n  TerraformVersion     string                       &#x2F;&#x2F; 16 bytes\n  ModuleVersionMajor   int32                        &#x2F;&#x2F;  4 bytes\n  HaveDSL              bool                         &#x2F;&#x2F;  1 byte\n  IsVersionControlled  bool                         &#x2F;&#x2F;  1 byte\n&#125;\n\nfunc main() &#123;\n    var d TerraformResource\n    d.Cloud &#x3D; &quot;aws&quot;\n    d.Name &#x3D; &quot;ec2&quot;\n    d.HaveDSL &#x3D; true\n    d.PluginVersion &#x3D; &quot;3.64&quot;\n    d.TerraformVersion &#x3D; &quot;1.1&quot;\n    d.ModuleVersionMajor &#x3D; 1\n    d.IsVersionControlled &#x3D; true\n    fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    fmt.Printf(&quot;Total Memory Usage StructType:d %T &#x3D;&gt; [%d]\\n&quot;, d, unsafe.Sizeof(d))\n    fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    fmt.Printf(&quot;Cloud Field StructType:d.Cloud %T &#x3D;&gt; [%d]\\n&quot;, d.Cloud, unsafe.Sizeof(d.Cloud))\n    fmt.Printf(&quot;Name Field StructType:d.Name %T &#x3D;&gt; [%d]\\n&quot;, d.Name, unsafe.Sizeof(d.Name))\n    fmt.Printf(&quot;HaveDSL Field StructType:d.HaveDSL %T &#x3D;&gt; [%d]\\n&quot;, d.HaveDSL, unsafe.Sizeof(d.HaveDSL))\n    fmt.Printf(&quot;PluginVersion Field StructType:d.PluginVersion %T &#x3D;&gt; [%d]\\n&quot;, d.PluginVersion, unsafe.Sizeof(d.PluginVersion))\n    fmt.Printf(&quot;ModuleVersionMajor Field StructType:d.IsVersionControlled %T &#x3D;&gt; [%d]\\n&quot;, d.IsVersionControlled, unsafe.Sizeof(d.IsVersionControlled))\n    fmt.Printf(&quot;TerraformVersion Field StructType:d.TerraformVersion %T &#x3D;&gt; [%d]\\n&quot;, d.TerraformVersion, unsafe.Sizeof(d.TerraformVersion))\n    fmt.Printf(&quot;ModuleVersionMajor Field StructType:d.ModuleVersionMajor %T &#x3D;&gt; [%d]\\n&quot;, d.ModuleVersionMajor, unsafe.Sizeof(d.ModuleVersionMajor))\n&#125;\n\n</code></pre>\n<p>output如下</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">go run golang-struct-memory-allocation-optimized.go\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nTotal Memory Usage StructType:d main.TerraformResource &#x3D;&gt; [72]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nCloud Field StructType:d.Cloud string &#x3D;&gt; [16]\nName Field StructType:d.Name string &#x3D;&gt; [16]\nHaveDSL Field StructType:d.HaveDSL bool &#x3D;&gt; [1]\nPluginVersion Field StructType:d.PluginVersion string &#x3D;&gt; [16]\nModuleVersionMajor Field StructType:d.IsVersionControlled bool &#x3D;&gt; [1]\nTerraformVersion Field StructType:d.TerraformVersion string &#x3D;&gt; [16]\nModuleVersionMajor Field StructType:d.ModuleVersionMajor int32 &#x3D;&gt; [4]\n</code></pre>\n<p>现在TerraformResource类型的总内存分配是72字节。让我们看看内存的排列方式是什么样子的</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--V9hRLdR1--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/03-golang-struct-memory-map.jpeg\"></p>\n<p>仅仅通过对结构元素进行适当的数据结构对齐，我们就能够将内存占用从88字节减少到72字节….，很好!</p>\n<p>让我们检查一下数学运算</p>\n<blockquote>\n<p>分配字节&#x3D;16字节+16字节+16字节+16字节+4字节+1字节+1字节&#x3D;70字节<br>空垫字节&#x3D;2字节<br>总字节数&#x3D;分配字节数+空垫字节数&#x3D;70字节+2字节&#x3D;72字节</p>\n</blockquote>\n<p>适当的数据结构排列不仅可以帮助我们有效地使用内存，还可以帮助CPU读取周期….，如何？</p>\n<p>CPU以字为单位读取内存，32位系统为4字节，64位系统为8字节。现在，我们的第一个结构类型TerraformResource的声明将需要11个字来让CPU读取所有内容。</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--YxrCrSAs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/01-golang-struct-word-length.jpeg\"></p>\n<p>然而，优化后的结构只需要9个字，如下图所示<br><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--_N8r3Z9U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/02-golang-struct-word-length.jpeg\"></p>\n<p>通过正确定义结构体的数据结构，我们能够有效地使用内存分配，并使结构体在CPU读取方面也变得快速有效。</p>\n<p>这只是一个小例子，想想一个有20或30个不同类型字段的大型结构。对数据结构进行深思熟虑的调整真的很有价值……🤩</p>\n<p>希望这篇博客能够对结构的内部结构、其内存分配和所需的CPU读取周期有一些启发。希望这对你有帮助！!</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文链接 : <a href=\"https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick\">https://dev.to/deadlock/golang-writing-memory-efficient-and-cpu-optimized-go-structs-2ick</a></p>\n</blockquote>\n<h1 id=\"Golang编写内存高效和CPU优化的Go结构\"><a href=\"#Golang编写内存高效和CPU优化的Go结构\" class=\"headerlink\" title=\"Golang编写内存高效和CPU优化的Go结构\"></a>Golang编写内存高效和CPU优化的Go结构</h1><p>结构是一个类型化的field集合，对于将数据分组记录非常有用。这使得与一个<code>strcut</code>有关的所有数据都被整齐地封装在一个轻量级的类型定义中，然后可以通过定义结构类型上的函数来实现行为。</p>\n<p>这篇博客我将尝试解释我们如何在内存使用和CPU周期方面有效地编写结构。</p>\n<p>让我们考虑下面这个结构，为我的一些奇怪的用例定义畸形资源类型。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type TerraformResource struct &#123;\n  Cloud                string                       &#x2F;&#x2F; 16 bytes\n  Name                 string                       &#x2F;&#x2F; 16 bytes\n  HaveDSL              bool                         &#x2F;&#x2F;  1 byte\n  PluginVersion        string                       &#x2F;&#x2F; 16 bytes\n  IsVersionControlled  bool                         &#x2F;&#x2F;  1 byte\n  TerraformVersion     string                       &#x2F;&#x2F; 16 bytes\n  ModuleVersionMajor   int32                        &#x2F;&#x2F;  4 bytes\n&#125;\n</code></pre>\n<p>让我们用下面的代码看看TerraformResource结构需要多少内存分配。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage main\n\nimport &quot;fmt&quot;\nimport &quot;unsafe&quot;\n\ntype TerraformResource struct &#123;\n  Cloud                string                       &#x2F;&#x2F; 16 bytes\n  Name                 string                       &#x2F;&#x2F; 16 bytes\n  HaveDSL              bool                         &#x2F;&#x2F;  1 byte\n  PluginVersion        string                       &#x2F;&#x2F; 16 bytes\n  IsVersionControlled  bool                         &#x2F;&#x2F;  1 byte\n  TerraformVersion     string                       &#x2F;&#x2F; 16 bytes\n  ModuleVersionMajor   int32                        &#x2F;&#x2F;  4 bytes\n&#125;\n\nfunc main() &#123;\n    var d TerraformResource\n    d.Cloud &#x3D; &quot;aws&quot;\n    d.Name &#x3D; &quot;ec2&quot;\n    d.HaveDSL &#x3D; true\n    d.PluginVersion &#x3D; &quot;3.64&quot;\n    d.TerraformVersion &#x3D; &quot;1.1&quot;\n    d.ModuleVersionMajor &#x3D; 1\n    d.IsVersionControlled &#x3D; true\n    fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    fmt.Printf(&quot;Total Memory Usage StructType:d %T &#x3D;&gt; [%d]\\n&quot;, d, unsafe.Sizeof(d))\n    fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    fmt.Printf(&quot;Cloud Field StructType:d.Cloud %T &#x3D;&gt; [%d]\\n&quot;, d.Cloud, unsafe.Sizeof(d.Cloud))\n    fmt.Printf(&quot;Name Field StructType:d.Name %T &#x3D;&gt; [%d]\\n&quot;, d.Name, unsafe.Sizeof(d.Name))\n    fmt.Printf(&quot;HaveDSL Field StructType:d.HaveDSL %T &#x3D;&gt; [%d]\\n&quot;, d.HaveDSL, unsafe.Sizeof(d.HaveDSL))\n    fmt.Printf(&quot;PluginVersion Field StructType:d.PluginVersion %T &#x3D;&gt; [%d]\\n&quot;, d.PluginVersion, unsafe.Sizeof(d.PluginVersion))\n    fmt.Printf(&quot;ModuleVersionMajor Field StructType:d.IsVersionControlled %T &#x3D;&gt; [%d]\\n&quot;, d.IsVersionControlled, unsafe.Sizeof(d.IsVersionControlled))\n    fmt.Printf(&quot;TerraformVersion Field StructType:d.TerraformVersion %T &#x3D;&gt; [%d]\\n&quot;, d.TerraformVersion, unsafe.Sizeof(d.TerraformVersion))\n    fmt.Printf(&quot;ModuleVersionMajor Field StructType:d.ModuleVersionMajor %T &#x3D;&gt; [%d]\\n&quot;, d.ModuleVersionMajor, unsafe.Sizeof(d.ModuleVersionMajor))  \n&#125;</code></pre>\n<p>output如下</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nTotal Memory Usage StructType:d main.TerraformResource &#x3D;&gt; [88]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nCloud Field StructType:d.Cloud string &#x3D;&gt; [16]\nName Field StructType:d.Name string &#x3D;&gt; [16]\nHaveDSL Field StructType:d.HaveDSL bool &#x3D;&gt; [1]\nPluginVersion Field StructType:d.PluginVersion string &#x3D;&gt; [16]\nModuleVersionMajor Field StructType:d.IsVersionControlled bool &#x3D;&gt; [1]\nTerraformVersion Field StructType:d.TerraformVersion string &#x3D;&gt; [16]\nModuleVersionMajor Field StructType:d.ModuleVersionMajor int32 &#x3D;&gt; [4]</code></pre>\n<p>所以TerraformResource结构需要的总内存分配是88字节。这就是TerraformResource类型的内存分配情况<br><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--HubwVUeX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/01-golang-struct-memory-map.jpeg\" alt=\"TerraformResource类型的内存分配情况\"></p>\n<p>但为什么会有88个字节，16+16+1+16+1+16+4&#x3D;70个字节，这额外的18个字节从何而来？</p>\n<p>当涉及到结构体的内存分配时，它们总是被分配为连续的、字节对齐的内存块，并且字段是按照它们被定义的顺序分配和存储的。在这种情况下，<strong>字节对齐</strong>的概念意味着连续的内存块以与平台字大小相同的偏移量对齐。<br><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--S_4mkd0a--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/02-golang-struct-memory-map.jpeg\"></p>\n<p>我们可以清楚地看到，TerraformResource.HaveDSL , TerraformResource.isVersionControlled和TerraformResource.ModuleVersionMajor分别只占用了1个字节、1个字节和4个字节。其余的空间都是用空的焊盘字节填充的。</p>\n<p>所以回到同样的数学问题上</p>\n<blockquote>\n<p>分配字节&#x3D;16字节+16字节+1字节+16字节+1字节+16字节+4字节<br>空垫字节&#x3D;7字节+7字节+4字节&#x3D;18字节<br>总字节数&#x3D;分配字节数+空垫字节数&#x3D;70字节+18字节&#x3D;88字节</p>\n</blockquote>\n<p>那么，我们该如何解决这个问题呢？通过适当的数据结构调整，如果我们重新定义我们的结构，就像这样</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type TerraformResource struct &#123;\n  Cloud                string                       &#x2F;&#x2F; 16 bytes\n  Name                 string                       &#x2F;&#x2F; 16 bytes\n  PluginVersion        string                       &#x2F;&#x2F; 16 bytes\n  TerraformVersion     string                       &#x2F;&#x2F; 16 bytes\n  ModuleVersionMajor   int32                        &#x2F;&#x2F;  4 bytes\n  HaveDSL              bool                         &#x2F;&#x2F;  1 byte\n  IsVersionControlled  bool                         &#x2F;&#x2F;  1 byte\n&#125;\n</code></pre>\n<p>测试代码如下</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;fmt&quot;\nimport &quot;unsafe&quot;\n\ntype TerraformResource struct &#123;\n  Cloud                string                       &#x2F;&#x2F; 16 bytes\n  Name                 string                       &#x2F;&#x2F; 16 bytes\n  PluginVersion        string                       &#x2F;&#x2F; 16 bytes\n  TerraformVersion     string                       &#x2F;&#x2F; 16 bytes\n  ModuleVersionMajor   int32                        &#x2F;&#x2F;  4 bytes\n  HaveDSL              bool                         &#x2F;&#x2F;  1 byte\n  IsVersionControlled  bool                         &#x2F;&#x2F;  1 byte\n&#125;\n\nfunc main() &#123;\n    var d TerraformResource\n    d.Cloud &#x3D; &quot;aws&quot;\n    d.Name &#x3D; &quot;ec2&quot;\n    d.HaveDSL &#x3D; true\n    d.PluginVersion &#x3D; &quot;3.64&quot;\n    d.TerraformVersion &#x3D; &quot;1.1&quot;\n    d.ModuleVersionMajor &#x3D; 1\n    d.IsVersionControlled &#x3D; true\n    fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    fmt.Printf(&quot;Total Memory Usage StructType:d %T &#x3D;&gt; [%d]\\n&quot;, d, unsafe.Sizeof(d))\n    fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    fmt.Printf(&quot;Cloud Field StructType:d.Cloud %T &#x3D;&gt; [%d]\\n&quot;, d.Cloud, unsafe.Sizeof(d.Cloud))\n    fmt.Printf(&quot;Name Field StructType:d.Name %T &#x3D;&gt; [%d]\\n&quot;, d.Name, unsafe.Sizeof(d.Name))\n    fmt.Printf(&quot;HaveDSL Field StructType:d.HaveDSL %T &#x3D;&gt; [%d]\\n&quot;, d.HaveDSL, unsafe.Sizeof(d.HaveDSL))\n    fmt.Printf(&quot;PluginVersion Field StructType:d.PluginVersion %T &#x3D;&gt; [%d]\\n&quot;, d.PluginVersion, unsafe.Sizeof(d.PluginVersion))\n    fmt.Printf(&quot;ModuleVersionMajor Field StructType:d.IsVersionControlled %T &#x3D;&gt; [%d]\\n&quot;, d.IsVersionControlled, unsafe.Sizeof(d.IsVersionControlled))\n    fmt.Printf(&quot;TerraformVersion Field StructType:d.TerraformVersion %T &#x3D;&gt; [%d]\\n&quot;, d.TerraformVersion, unsafe.Sizeof(d.TerraformVersion))\n    fmt.Printf(&quot;ModuleVersionMajor Field StructType:d.ModuleVersionMajor %T &#x3D;&gt; [%d]\\n&quot;, d.ModuleVersionMajor, unsafe.Sizeof(d.ModuleVersionMajor))\n&#125;\n\n</code></pre>\n<p>output如下</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">go run golang-struct-memory-allocation-optimized.go\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nTotal Memory Usage StructType:d main.TerraformResource &#x3D;&gt; [72]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nCloud Field StructType:d.Cloud string &#x3D;&gt; [16]\nName Field StructType:d.Name string &#x3D;&gt; [16]\nHaveDSL Field StructType:d.HaveDSL bool &#x3D;&gt; [1]\nPluginVersion Field StructType:d.PluginVersion string &#x3D;&gt; [16]\nModuleVersionMajor Field StructType:d.IsVersionControlled bool &#x3D;&gt; [1]\nTerraformVersion Field StructType:d.TerraformVersion string &#x3D;&gt; [16]\nModuleVersionMajor Field StructType:d.ModuleVersionMajor int32 &#x3D;&gt; [4]\n</code></pre>\n<p>现在TerraformResource类型的总内存分配是72字节。让我们看看内存的排列方式是什么样子的</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--V9hRLdR1--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/03-golang-struct-memory-map.jpeg\"></p>\n<p>仅仅通过对结构元素进行适当的数据结构对齐，我们就能够将内存占用从88字节减少到72字节….，很好!</p>\n<p>让我们检查一下数学运算</p>\n<blockquote>\n<p>分配字节&#x3D;16字节+16字节+16字节+16字节+4字节+1字节+1字节&#x3D;70字节<br>空垫字节&#x3D;2字节<br>总字节数&#x3D;分配字节数+空垫字节数&#x3D;70字节+2字节&#x3D;72字节</p>\n</blockquote>\n<p>适当的数据结构排列不仅可以帮助我们有效地使用内存，还可以帮助CPU读取周期….，如何？</p>\n<p>CPU以字为单位读取内存，32位系统为4字节，64位系统为8字节。现在，我们的第一个结构类型TerraformResource的声明将需要11个字来让CPU读取所有内容。</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--YxrCrSAs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/01-golang-struct-word-length.jpeg\"></p>\n<p>然而，优化后的结构只需要9个字，如下图所示<br><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--_N8r3Z9U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/kodelint/blog-assets/raw/main/images/02-golang-struct-word-length.jpeg\"></p>\n<p>通过正确定义结构体的数据结构，我们能够有效地使用内存分配，并使结构体在CPU读取方面也变得快速有效。</p>\n<p>这只是一个小例子，想想一个有20或30个不同类型字段的大型结构。对数据结构进行深思熟虑的调整真的很有价值……🤩</p>\n<p>希望这篇博客能够对结构的内部结构、其内存分配和所需的CPU读取周期有一些启发。希望这对你有帮助！!</p>\n"},{"title":"费曼:任何伟大的科学成就，都源于思想自由","_content":"\n\n# 费曼：任何伟大的科学成就，都源于思想自由\n> 原文地址 : https://mp.weixin.qq.com/s/p_l9_Z54jewLN6SEjio1Tw\n\n![费曼](./../../picture/微信图片_20220926005909.jpg)\n\n## 科学的价值\n当我年轻的时候，我认为科学会有利于每个人。科学显然很有用，也是很有益的。在第二次世界大战中，我参与了原子弹的制造工作。科学的发展导致了原子弹的产生，这显然是一个具有极其严肃意味的事件：它代表着对人类的毁灭。\n\n战后，我对原子弹忧心忡忡，既不知未来会怎样，也更不敢肯定人类一定会延存。自然地，一个问题会这样被提出：科学是不是包含着邪恶的成分？\n\n这个问题也可以这样来问：当我们看到科学也可以带来灾难时，那么我如此热爱，并且毕生孜孜为之的科学事业的价值究竟何在？这是我无法回避的问题。\n\n这篇“科学的价值”，你们可以把它看成是我在探索这个问题时的所思所悟。\n\n——理查德·费曼\n\n时常，人们对我提出，科学家应该多多关心社会问题，特别是要考虑科学对于社会的影响。人们似乎相当普遍地认为，只要科学家们对于错综复杂的社会问题加以关注，而不是成天钻在枝尾末节的科学研究之中，那么巨大的成功就会自然到来。\n\n我以为，我们科学家是很关注这些社会问题的，只不过我们不是把它们当作自己的全职而已。其原因是，对于这些比科学研究复杂千百倍的社会问题，我们也是百思不得其解，绝无灵丹妙药。\n\n我认为当科学家思考非科学问题时，他和所有的人一样无知；当他要对非科学问题发表见解时，他和所有的门外汉一样幼稚。今天我的讲演“科学的价值”所针对的并不是一个科学课题，而是价值评判；这样看来，我下面将要讲的大概也是粗浅不堪的了。\n\n## 01\n**科学的价值的第一点是众所周知的。科学知识使人们能制造许多产品、做许多事业**。当然，当人们运用科学做了善事的时候，功劳不仅归于科学本身，而且也归于指导着我们的道德选择。科学知识给予人们能力去行善，也可以作恶，它本身可并没有附带着使用说明。这种能力显然是有价值的，尽管好坏决定于如何使用它。\n\n在一次去夏威夷的路途中，我学会了一种方法来表达上述问题——一个佛堂的主持向游客们谈及佛学，最后他说他的临别赠言将使游客们永不忘却（我是真的从未忘却）。这赠言是佛经中的一句箴语：“每个人都掌握着一把开启天堂之门的钥匙，这把钥匙也同样能打开地狱之门。”\n\n如此说来，开启天堂之门的钥匙又有什么价值呢？如果我们没有办法分辨一扇门是通向天堂还是地狱，那么手中的钥匙可是个危险的玩艺儿。\n\n可是这钥匙又确实有它的价值——没有它，我们无法开启天堂之门；没有它，我们即使明辨了天堂与地狱，也还是束手无策。这样推论下来，尽管科学知识可能被误用以导致灾难，它的这种产生巨大影响的能力本身是一种价值。\n\n```text\n这里的钥匙可以理解为科学知识,或者利用科学知识创造的产品,这一段主要阐述科学的其中一个价值\n```\n## 02\n**科学的另一个价值是提供智慧与思辨的享受**。这种享受一些人可以从阅读、学习、思考中得到，而另一些人则要从真正的深入研究中方能满足。这种智慧思辨享受的重要性往往被人们忽视，特别是那些喋喋不休地教导我们科学家要承担社会责任的先生们。\n\n我当然不是说个人在智慧思辨中的享受是科学的全部价值所在。不过，**如果我们社会进步的最终目标正是为了让各种人能享受他想做的事，那么科学家们思辨求知的享受也就和其他事具有同等的重要性了。**\n\n**另外一个不容低估的科学的价值是它改变了人们对世界的概念**。由于科学的发展，我们今天可以想象无穷奇妙的东西，比诗人和梦想者的想象丰富离奇千万倍。自然的想象和多姿比人类要高明得多。比如吧，诗人想象巨大的海龟驮着大象到海里旅行；而科学给了我们一幅图画——天宇中一个巨大的球在旋转；在它的表面，人们被神奇的引力吸住，并附着它在旋转。\n\n我常常想这些奇妙的东西，这些从前人们根本不可想象，而如今科学知识使我们可以想象的东西。\n\n曾经，我站在海边的沙滩上，陷入了这样的深思：\n\n> 潮起潮落  \n>无法计数的分子各自孤独地运行  \n>相距遥远却又息息相关  \n>泛起和谐的白浪  \n>旷代久远  \n>  \n>在尚无生物的上古  \n>眼睛还未出现  \n>年复一年  \n>惊涛拍岸如今  \n>为了谁，为了什么？  \n>在一个死寂的星球  \n>没有为之欣悦的生命   \n>  \n>永无休止  \n>骄阳弥散着能量  \n>射向无垠的宇宙  \n>掀动着大海的波浪  \n>大洋深处  \n>分子重复不变  \n>忽然，萌生新的组合  \n>它们会复制自身  \n>由此演出了全新的一幕  \n>  \n>愈变愈大  \n>愈变愈复杂  \n>生物，DNA，蛋白质  \n>它们的舞蹈愈加神奇  \n>  \n>跃出海洋  \n>走向陆地  \n>站立着  \n>具有认知力的原子  \n>具有好奇心的物质  \n>  \n>凭海向洋  \n>一个好奇者在好奇  \n>我——  \n>一个原子的宇宙  \n>一个宇宙中的原子  \n\n这样的激动、惊叹和神秘，在我们研究问题时一次又一次地出现。**知识的进步总是带来更深、更美妙的神秘，吸引着我们去更深一层地探索**。有时探索的结果令人失望，可这又有什么关系？我们总是兴致勃勃而自信地深钻下去，发现无法想象的奇妙和随之而来的更深更美妙的神秘。这难道不是最激动人心的探索么！\n\n诚然，没有过科学研究经历的人大概不会有这种近似宗教的感受。诗人不会写它，艺术家也无法描述这种奇妙的感受。我很是不解——难道他们都不为我们所发现的宇宙所激动吗？歌唱家现在还不会歌唱科学带来的神奇美妙，科学对于人们来说还是在讲课中接受的，而不是在诗与歌之中。这说明我们还没有进入一个科学的时代。\n\n这种沉默无歌的原因之一，大概是人们必须懂得如何读这种音乐的乐谱才能歌唱。比如，一篇科学论文说，“鼠的脑中放射标记的磷在两周中减了一半。”这是什么意思呢？\n\n它的意思是鼠脑中（你、我的脑子也没什么差别）的磷有一半已经不是两周前的原子了，它们已被替换了。那么我要问：“究竟什么是载有意识的分子呢？子虚乌有么？这些全新的分子能承载一年前在我脑中的记忆，可当时发生记忆的分子却早已被置换了！这个发现就像是说我这个体仅仅是一个舞蹈的编排。分子们进入我的大脑，跳了一场舞就离开了；新的分子又进来，还是跳和昨天一模一样的舞蹈——它们能记住！”\n\n有时我们会从报纸上念到这样的话：“科学家认为这项发现对于治疗肿瘤是十分重要的……”。**看，这报道只注重那项发现有什么可利用之处，而完全丢开了它本身的意义。而实际上它是多么奇妙啊！偶尔，小孩子反倒会意识到那些意义；此时，一个科学家的苗子出现了。如果当他们上大学时我们才教他们这些，那就太晚了。我们必须从孩童教起。**\n```text\n科学本身的为什么着实让人着迷\n```\n## 03\n现在，我来谈谈科学的第三个价值——它稍稍有些间接，不过并不牵强。**科学家们成天经历的就是无知、疑惑、不确定，这种经历是极其重要的**。当科学家不知道答案时，他是无知的；当他心中大概有了猜测时，他是不确定的；即便他满有把握时，他也会永远留下质疑的余地。承认自己的无知，留下质疑的余地，这两者对于任何发展都必不可少。科学知识本身是一个具有不同层次可信度的集合体：有的根本不确定，有的比较确定，但没有什么是完全确定的。\n\n科学家们对上述情形习以为常，他们自然地由于不确定而质疑，而且承认自己无知。但是我认为大多数人并不明白这一点。在历史上科学与专制权威进行了反复的斗争才渐渐赢得了我们质疑的自由。那是一场多么艰辛、旷日持久的战斗啊！它终于使我们可以提问、可以质疑、可以不确定。我们绝不应该忘记历史，以致丢失千辛万苦争来的自由。这，是我们科学家对社会的责任。\n\n人类的潜能之大、成就之小，令人想起来未免神伤，总觉得人类可以更好。先人在恶魇中梦想未来；我们（正是他们的未来）则看到他们的梦想有些已经成真，大多却仍然是梦想，一如往日。\n\n有人说教育的不普及是人类不能前行的原因。可是难道教育普及了，所有的人就都能成为伏尔泰吗？坏的和好的是同样可以被传授的；教育同样拥有趋善或趋恶的巨大能力。\n\n另一个梦想是国与国之间的充分交流一定会增加互相理解。可是交流的工具是可以被操纵的。如此说来所交流的既可以是真实，也可以是谎言。交流也具有趋善和趋恶双重可能。\n\n应用科学可以解决人们的物资需求，医药可以控制疾病——看上去总算尽善尽美了吧？可偏偏有不少人在专心致志地制造可怖的毒物、细菌，为化学生物战争做准备。\n\n几乎谁都不喜欢战争，和平是人类的梦想——人们尽可能地发挥潜能。可没准儿未来的人们发现和平也可好可坏。没准儿和平时代的人因没有挑战而厌倦不堪，于是终日痛饮不止，而醉熏熏的人并不能发挥潜能、成就大业。\n和平显然是一个很大的力量，如同严谨、物资发展、交流，教育、诚实和先人的梦想。与先人相比，我们确实进步了，有更多的能力了。可与我们能够成就的相比，所达到的就相形见绌。\n\n原因何在？为什么我们就无法战胜自己？\n\n因为我们发现，巨大的潜能和力量并没有带着如何使用它们的说明书。譬如，对物质世界认识愈多，人们就愈觉得世界真是毫无目的意义可言。科学并无法指导行善或行恶。  \n```text\n科学并不会指导善与恶\n```\n\n## 04\n有史以来，人们一直都在探究生命的意义。他们想：如果有某种意义和方向来指导，人的伟大潜能定会充分发挥。于是有了许多种对生命意义的阐述和教义。这些各自不同的教义有着自己的信徒，而某一种教义的信徒总是怀着恐惧的心情看待其余教义的信徒。这种恐惧来自于信念的互不相容，致使原本良好的出发点都汇入了一条死胡同。**事实上，正是从这些历史上错误信仰所制造的巨大谬误中，哲学思考者们慢慢发现了人类美妙无限的能力。人们梦想能发现一条通途**。\n\n那么，这些又有什么意义呢？我们如何来解开存在之谜呢？\n\n如果把所有的加以考量——不仅是先人所知，而且他们不知而我们今天所知的——那么我认为我们必须坦率地承认，我们还是知之甚微。\n\n不过，正当我们如此承认的时候，我们便开始找到了通途。\n\n这并非一个新观念，它是理性时代的观念，也正是它指导着先贤们缔造了我们今日享用的民主制度。正因为相信没有一个人绝对懂得如何管理政府，我们才有这样一个制度来保证新的想法可以产生发展、被尝试运用、并在必要的时候被抛弃；更新的想法又可以如此地轮回运行。这是—种尝试——纠偏的系统方法。这种系统方法的建立，正是因为在18世纪末，科学已经成功地证明了它的可行性。在那时，关注社会的人们已经意识到：**对各种可能性持开明态度便带来机会；质疑和讨论是探索未知的关键，如果我们想解决以前未能解决的问题，那我们就必须这样地把通向未知的门开启**。\n\n**人类还处在初始阶段，因此我们遇上各种问题是毫不奇怪的。好在未来还有千千万万年。我们的责任是学所能学、为所可为、探索更好的办法，并传给下一代。我们的责任是给未来的人们一双没有束缚自由的双手**。在人类鲁莽冲动的青年期，人们常会制造巨大的错误而导致长久的停滞。倘若我们自以为对众多的问题都已有了明白的答案，年轻而无知的我们一定会犯这样的错误。如果我们压制批评，不许讨论，大声宣称“看哪，同胞们，这便是正确的答案，人类得救啦！”我们必然会把人类限制在权威的桎梏和现有想象力之中。这种错误在历史上屡见不鲜。\n\n**作为科学家，我们知道伟大的进展都源于承认无知，源于思想的自由。那么这是我们的责任——宣扬思想自由的价值，教育人们不要惧怕质疑而应该欢迎它、讨论它，而且毫不妥协地坚持拥有这种自由——这是我们对未来千秋万代所负有的责任。**","source":"_posts/archive/费曼:任何伟大的科学成就都源于思想自由.md","raw":"---\ntitle: 费曼:任何伟大的科学成就，都源于思想自由\ncategories: \n- archive\n- 非技术类\n---\n\n\n# 费曼：任何伟大的科学成就，都源于思想自由\n> 原文地址 : https://mp.weixin.qq.com/s/p_l9_Z54jewLN6SEjio1Tw\n\n![费曼](./../../picture/微信图片_20220926005909.jpg)\n\n## 科学的价值\n当我年轻的时候，我认为科学会有利于每个人。科学显然很有用，也是很有益的。在第二次世界大战中，我参与了原子弹的制造工作。科学的发展导致了原子弹的产生，这显然是一个具有极其严肃意味的事件：它代表着对人类的毁灭。\n\n战后，我对原子弹忧心忡忡，既不知未来会怎样，也更不敢肯定人类一定会延存。自然地，一个问题会这样被提出：科学是不是包含着邪恶的成分？\n\n这个问题也可以这样来问：当我们看到科学也可以带来灾难时，那么我如此热爱，并且毕生孜孜为之的科学事业的价值究竟何在？这是我无法回避的问题。\n\n这篇“科学的价值”，你们可以把它看成是我在探索这个问题时的所思所悟。\n\n——理查德·费曼\n\n时常，人们对我提出，科学家应该多多关心社会问题，特别是要考虑科学对于社会的影响。人们似乎相当普遍地认为，只要科学家们对于错综复杂的社会问题加以关注，而不是成天钻在枝尾末节的科学研究之中，那么巨大的成功就会自然到来。\n\n我以为，我们科学家是很关注这些社会问题的，只不过我们不是把它们当作自己的全职而已。其原因是，对于这些比科学研究复杂千百倍的社会问题，我们也是百思不得其解，绝无灵丹妙药。\n\n我认为当科学家思考非科学问题时，他和所有的人一样无知；当他要对非科学问题发表见解时，他和所有的门外汉一样幼稚。今天我的讲演“科学的价值”所针对的并不是一个科学课题，而是价值评判；这样看来，我下面将要讲的大概也是粗浅不堪的了。\n\n## 01\n**科学的价值的第一点是众所周知的。科学知识使人们能制造许多产品、做许多事业**。当然，当人们运用科学做了善事的时候，功劳不仅归于科学本身，而且也归于指导着我们的道德选择。科学知识给予人们能力去行善，也可以作恶，它本身可并没有附带着使用说明。这种能力显然是有价值的，尽管好坏决定于如何使用它。\n\n在一次去夏威夷的路途中，我学会了一种方法来表达上述问题——一个佛堂的主持向游客们谈及佛学，最后他说他的临别赠言将使游客们永不忘却（我是真的从未忘却）。这赠言是佛经中的一句箴语：“每个人都掌握着一把开启天堂之门的钥匙，这把钥匙也同样能打开地狱之门。”\n\n如此说来，开启天堂之门的钥匙又有什么价值呢？如果我们没有办法分辨一扇门是通向天堂还是地狱，那么手中的钥匙可是个危险的玩艺儿。\n\n可是这钥匙又确实有它的价值——没有它，我们无法开启天堂之门；没有它，我们即使明辨了天堂与地狱，也还是束手无策。这样推论下来，尽管科学知识可能被误用以导致灾难，它的这种产生巨大影响的能力本身是一种价值。\n\n```text\n这里的钥匙可以理解为科学知识,或者利用科学知识创造的产品,这一段主要阐述科学的其中一个价值\n```\n## 02\n**科学的另一个价值是提供智慧与思辨的享受**。这种享受一些人可以从阅读、学习、思考中得到，而另一些人则要从真正的深入研究中方能满足。这种智慧思辨享受的重要性往往被人们忽视，特别是那些喋喋不休地教导我们科学家要承担社会责任的先生们。\n\n我当然不是说个人在智慧思辨中的享受是科学的全部价值所在。不过，**如果我们社会进步的最终目标正是为了让各种人能享受他想做的事，那么科学家们思辨求知的享受也就和其他事具有同等的重要性了。**\n\n**另外一个不容低估的科学的价值是它改变了人们对世界的概念**。由于科学的发展，我们今天可以想象无穷奇妙的东西，比诗人和梦想者的想象丰富离奇千万倍。自然的想象和多姿比人类要高明得多。比如吧，诗人想象巨大的海龟驮着大象到海里旅行；而科学给了我们一幅图画——天宇中一个巨大的球在旋转；在它的表面，人们被神奇的引力吸住，并附着它在旋转。\n\n我常常想这些奇妙的东西，这些从前人们根本不可想象，而如今科学知识使我们可以想象的东西。\n\n曾经，我站在海边的沙滩上，陷入了这样的深思：\n\n> 潮起潮落  \n>无法计数的分子各自孤独地运行  \n>相距遥远却又息息相关  \n>泛起和谐的白浪  \n>旷代久远  \n>  \n>在尚无生物的上古  \n>眼睛还未出现  \n>年复一年  \n>惊涛拍岸如今  \n>为了谁，为了什么？  \n>在一个死寂的星球  \n>没有为之欣悦的生命   \n>  \n>永无休止  \n>骄阳弥散着能量  \n>射向无垠的宇宙  \n>掀动着大海的波浪  \n>大洋深处  \n>分子重复不变  \n>忽然，萌生新的组合  \n>它们会复制自身  \n>由此演出了全新的一幕  \n>  \n>愈变愈大  \n>愈变愈复杂  \n>生物，DNA，蛋白质  \n>它们的舞蹈愈加神奇  \n>  \n>跃出海洋  \n>走向陆地  \n>站立着  \n>具有认知力的原子  \n>具有好奇心的物质  \n>  \n>凭海向洋  \n>一个好奇者在好奇  \n>我——  \n>一个原子的宇宙  \n>一个宇宙中的原子  \n\n这样的激动、惊叹和神秘，在我们研究问题时一次又一次地出现。**知识的进步总是带来更深、更美妙的神秘，吸引着我们去更深一层地探索**。有时探索的结果令人失望，可这又有什么关系？我们总是兴致勃勃而自信地深钻下去，发现无法想象的奇妙和随之而来的更深更美妙的神秘。这难道不是最激动人心的探索么！\n\n诚然，没有过科学研究经历的人大概不会有这种近似宗教的感受。诗人不会写它，艺术家也无法描述这种奇妙的感受。我很是不解——难道他们都不为我们所发现的宇宙所激动吗？歌唱家现在还不会歌唱科学带来的神奇美妙，科学对于人们来说还是在讲课中接受的，而不是在诗与歌之中。这说明我们还没有进入一个科学的时代。\n\n这种沉默无歌的原因之一，大概是人们必须懂得如何读这种音乐的乐谱才能歌唱。比如，一篇科学论文说，“鼠的脑中放射标记的磷在两周中减了一半。”这是什么意思呢？\n\n它的意思是鼠脑中（你、我的脑子也没什么差别）的磷有一半已经不是两周前的原子了，它们已被替换了。那么我要问：“究竟什么是载有意识的分子呢？子虚乌有么？这些全新的分子能承载一年前在我脑中的记忆，可当时发生记忆的分子却早已被置换了！这个发现就像是说我这个体仅仅是一个舞蹈的编排。分子们进入我的大脑，跳了一场舞就离开了；新的分子又进来，还是跳和昨天一模一样的舞蹈——它们能记住！”\n\n有时我们会从报纸上念到这样的话：“科学家认为这项发现对于治疗肿瘤是十分重要的……”。**看，这报道只注重那项发现有什么可利用之处，而完全丢开了它本身的意义。而实际上它是多么奇妙啊！偶尔，小孩子反倒会意识到那些意义；此时，一个科学家的苗子出现了。如果当他们上大学时我们才教他们这些，那就太晚了。我们必须从孩童教起。**\n```text\n科学本身的为什么着实让人着迷\n```\n## 03\n现在，我来谈谈科学的第三个价值——它稍稍有些间接，不过并不牵强。**科学家们成天经历的就是无知、疑惑、不确定，这种经历是极其重要的**。当科学家不知道答案时，他是无知的；当他心中大概有了猜测时，他是不确定的；即便他满有把握时，他也会永远留下质疑的余地。承认自己的无知，留下质疑的余地，这两者对于任何发展都必不可少。科学知识本身是一个具有不同层次可信度的集合体：有的根本不确定，有的比较确定，但没有什么是完全确定的。\n\n科学家们对上述情形习以为常，他们自然地由于不确定而质疑，而且承认自己无知。但是我认为大多数人并不明白这一点。在历史上科学与专制权威进行了反复的斗争才渐渐赢得了我们质疑的自由。那是一场多么艰辛、旷日持久的战斗啊！它终于使我们可以提问、可以质疑、可以不确定。我们绝不应该忘记历史，以致丢失千辛万苦争来的自由。这，是我们科学家对社会的责任。\n\n人类的潜能之大、成就之小，令人想起来未免神伤，总觉得人类可以更好。先人在恶魇中梦想未来；我们（正是他们的未来）则看到他们的梦想有些已经成真，大多却仍然是梦想，一如往日。\n\n有人说教育的不普及是人类不能前行的原因。可是难道教育普及了，所有的人就都能成为伏尔泰吗？坏的和好的是同样可以被传授的；教育同样拥有趋善或趋恶的巨大能力。\n\n另一个梦想是国与国之间的充分交流一定会增加互相理解。可是交流的工具是可以被操纵的。如此说来所交流的既可以是真实，也可以是谎言。交流也具有趋善和趋恶双重可能。\n\n应用科学可以解决人们的物资需求，医药可以控制疾病——看上去总算尽善尽美了吧？可偏偏有不少人在专心致志地制造可怖的毒物、细菌，为化学生物战争做准备。\n\n几乎谁都不喜欢战争，和平是人类的梦想——人们尽可能地发挥潜能。可没准儿未来的人们发现和平也可好可坏。没准儿和平时代的人因没有挑战而厌倦不堪，于是终日痛饮不止，而醉熏熏的人并不能发挥潜能、成就大业。\n和平显然是一个很大的力量，如同严谨、物资发展、交流，教育、诚实和先人的梦想。与先人相比，我们确实进步了，有更多的能力了。可与我们能够成就的相比，所达到的就相形见绌。\n\n原因何在？为什么我们就无法战胜自己？\n\n因为我们发现，巨大的潜能和力量并没有带着如何使用它们的说明书。譬如，对物质世界认识愈多，人们就愈觉得世界真是毫无目的意义可言。科学并无法指导行善或行恶。  \n```text\n科学并不会指导善与恶\n```\n\n## 04\n有史以来，人们一直都在探究生命的意义。他们想：如果有某种意义和方向来指导，人的伟大潜能定会充分发挥。于是有了许多种对生命意义的阐述和教义。这些各自不同的教义有着自己的信徒，而某一种教义的信徒总是怀着恐惧的心情看待其余教义的信徒。这种恐惧来自于信念的互不相容，致使原本良好的出发点都汇入了一条死胡同。**事实上，正是从这些历史上错误信仰所制造的巨大谬误中，哲学思考者们慢慢发现了人类美妙无限的能力。人们梦想能发现一条通途**。\n\n那么，这些又有什么意义呢？我们如何来解开存在之谜呢？\n\n如果把所有的加以考量——不仅是先人所知，而且他们不知而我们今天所知的——那么我认为我们必须坦率地承认，我们还是知之甚微。\n\n不过，正当我们如此承认的时候，我们便开始找到了通途。\n\n这并非一个新观念，它是理性时代的观念，也正是它指导着先贤们缔造了我们今日享用的民主制度。正因为相信没有一个人绝对懂得如何管理政府，我们才有这样一个制度来保证新的想法可以产生发展、被尝试运用、并在必要的时候被抛弃；更新的想法又可以如此地轮回运行。这是—种尝试——纠偏的系统方法。这种系统方法的建立，正是因为在18世纪末，科学已经成功地证明了它的可行性。在那时，关注社会的人们已经意识到：**对各种可能性持开明态度便带来机会；质疑和讨论是探索未知的关键，如果我们想解决以前未能解决的问题，那我们就必须这样地把通向未知的门开启**。\n\n**人类还处在初始阶段，因此我们遇上各种问题是毫不奇怪的。好在未来还有千千万万年。我们的责任是学所能学、为所可为、探索更好的办法，并传给下一代。我们的责任是给未来的人们一双没有束缚自由的双手**。在人类鲁莽冲动的青年期，人们常会制造巨大的错误而导致长久的停滞。倘若我们自以为对众多的问题都已有了明白的答案，年轻而无知的我们一定会犯这样的错误。如果我们压制批评，不许讨论，大声宣称“看哪，同胞们，这便是正确的答案，人类得救啦！”我们必然会把人类限制在权威的桎梏和现有想象力之中。这种错误在历史上屡见不鲜。\n\n**作为科学家，我们知道伟大的进展都源于承认无知，源于思想的自由。那么这是我们的责任——宣扬思想自由的价值，教育人们不要惧怕质疑而应该欢迎它、讨论它，而且毫不妥协地坚持拥有这种自由——这是我们对未来千秋万代所负有的责任。**","slug":"archive/费曼:任何伟大的科学成就都源于思想自由","published":1,"date":"2022-09-25T16:05:55.165Z","updated":"2022-09-25T17:12:37.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5r0015l1dbhztp9z78","content":"<h1 id=\"费曼：任何伟大的科学成就，都源于思想自由\"><a href=\"#费曼：任何伟大的科学成就，都源于思想自由\" class=\"headerlink\" title=\"费曼：任何伟大的科学成就，都源于思想自由\"></a>费曼：任何伟大的科学成就，都源于思想自由</h1><blockquote>\n<p>原文地址 : <a href=\"https://mp.weixin.qq.com/s/p_l9_Z54jewLN6SEjio1Tw\">https://mp.weixin.qq.com/s/p_l9_Z54jewLN6SEjio1Tw</a></p>\n</blockquote>\n<p><img src=\"/./../../picture/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220926005909.jpg\" alt=\"费曼\"></p>\n<h2 id=\"科学的价值\"><a href=\"#科学的价值\" class=\"headerlink\" title=\"科学的价值\"></a>科学的价值</h2><p>当我年轻的时候，我认为科学会有利于每个人。科学显然很有用，也是很有益的。在第二次世界大战中，我参与了原子弹的制造工作。科学的发展导致了原子弹的产生，这显然是一个具有极其严肃意味的事件：它代表着对人类的毁灭。</p>\n<p>战后，我对原子弹忧心忡忡，既不知未来会怎样，也更不敢肯定人类一定会延存。自然地，一个问题会这样被提出：科学是不是包含着邪恶的成分？</p>\n<p>这个问题也可以这样来问：当我们看到科学也可以带来灾难时，那么我如此热爱，并且毕生孜孜为之的科学事业的价值究竟何在？这是我无法回避的问题。</p>\n<p>这篇“科学的价值”，你们可以把它看成是我在探索这个问题时的所思所悟。</p>\n<p>——理查德·费曼</p>\n<p>时常，人们对我提出，科学家应该多多关心社会问题，特别是要考虑科学对于社会的影响。人们似乎相当普遍地认为，只要科学家们对于错综复杂的社会问题加以关注，而不是成天钻在枝尾末节的科学研究之中，那么巨大的成功就会自然到来。</p>\n<p>我以为，我们科学家是很关注这些社会问题的，只不过我们不是把它们当作自己的全职而已。其原因是，对于这些比科学研究复杂千百倍的社会问题，我们也是百思不得其解，绝无灵丹妙药。</p>\n<p>我认为当科学家思考非科学问题时，他和所有的人一样无知；当他要对非科学问题发表见解时，他和所有的门外汉一样幼稚。今天我的讲演“科学的价值”所针对的并不是一个科学课题，而是价值评判；这样看来，我下面将要讲的大概也是粗浅不堪的了。</p>\n<h2 id=\"01\"><a href=\"#01\" class=\"headerlink\" title=\"01\"></a>01</h2><p><strong>科学的价值的第一点是众所周知的。科学知识使人们能制造许多产品、做许多事业</strong>。当然，当人们运用科学做了善事的时候，功劳不仅归于科学本身，而且也归于指导着我们的道德选择。科学知识给予人们能力去行善，也可以作恶，它本身可并没有附带着使用说明。这种能力显然是有价值的，尽管好坏决定于如何使用它。</p>\n<p>在一次去夏威夷的路途中，我学会了一种方法来表达上述问题——一个佛堂的主持向游客们谈及佛学，最后他说他的临别赠言将使游客们永不忘却（我是真的从未忘却）。这赠言是佛经中的一句箴语：“每个人都掌握着一把开启天堂之门的钥匙，这把钥匙也同样能打开地狱之门。”</p>\n<p>如此说来，开启天堂之门的钥匙又有什么价值呢？如果我们没有办法分辨一扇门是通向天堂还是地狱，那么手中的钥匙可是个危险的玩艺儿。</p>\n<p>可是这钥匙又确实有它的价值——没有它，我们无法开启天堂之门；没有它，我们即使明辨了天堂与地狱，也还是束手无策。这样推论下来，尽管科学知识可能被误用以导致灾难，它的这种产生巨大影响的能力本身是一种价值。</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">这里的钥匙可以理解为科学知识,或者利用科学知识创造的产品,这一段主要阐述科学的其中一个价值</code></pre>\n<h2 id=\"02\"><a href=\"#02\" class=\"headerlink\" title=\"02\"></a>02</h2><p><strong>科学的另一个价值是提供智慧与思辨的享受</strong>。这种享受一些人可以从阅读、学习、思考中得到，而另一些人则要从真正的深入研究中方能满足。这种智慧思辨享受的重要性往往被人们忽视，特别是那些喋喋不休地教导我们科学家要承担社会责任的先生们。</p>\n<p>我当然不是说个人在智慧思辨中的享受是科学的全部价值所在。不过，<strong>如果我们社会进步的最终目标正是为了让各种人能享受他想做的事，那么科学家们思辨求知的享受也就和其他事具有同等的重要性了。</strong></p>\n<p><strong>另外一个不容低估的科学的价值是它改变了人们对世界的概念</strong>。由于科学的发展，我们今天可以想象无穷奇妙的东西，比诗人和梦想者的想象丰富离奇千万倍。自然的想象和多姿比人类要高明得多。比如吧，诗人想象巨大的海龟驮着大象到海里旅行；而科学给了我们一幅图画——天宇中一个巨大的球在旋转；在它的表面，人们被神奇的引力吸住，并附着它在旋转。</p>\n<p>我常常想这些奇妙的东西，这些从前人们根本不可想象，而如今科学知识使我们可以想象的东西。</p>\n<p>曾经，我站在海边的沙滩上，陷入了这样的深思：</p>\n<blockquote>\n<p>潮起潮落<br>无法计数的分子各自孤独地运行<br>相距遥远却又息息相关<br>泛起和谐的白浪<br>旷代久远  </p>\n<p>在尚无生物的上古<br>眼睛还未出现<br>年复一年<br>惊涛拍岸如今<br>为了谁，为了什么？<br>在一个死寂的星球<br>没有为之欣悦的生命   </p>\n<p>永无休止<br>骄阳弥散着能量<br>射向无垠的宇宙<br>掀动着大海的波浪<br>大洋深处<br>分子重复不变<br>忽然，萌生新的组合<br>它们会复制自身<br>由此演出了全新的一幕  </p>\n<p>愈变愈大<br>愈变愈复杂<br>生物，DNA，蛋白质<br>它们的舞蹈愈加神奇  </p>\n<p>跃出海洋<br>走向陆地<br>站立着<br>具有认知力的原子<br>具有好奇心的物质  </p>\n<p>凭海向洋<br>一个好奇者在好奇<br>我——<br>一个原子的宇宙<br>一个宇宙中的原子  </p>\n</blockquote>\n<p>这样的激动、惊叹和神秘，在我们研究问题时一次又一次地出现。<strong>知识的进步总是带来更深、更美妙的神秘，吸引着我们去更深一层地探索</strong>。有时探索的结果令人失望，可这又有什么关系？我们总是兴致勃勃而自信地深钻下去，发现无法想象的奇妙和随之而来的更深更美妙的神秘。这难道不是最激动人心的探索么！</p>\n<p>诚然，没有过科学研究经历的人大概不会有这种近似宗教的感受。诗人不会写它，艺术家也无法描述这种奇妙的感受。我很是不解——难道他们都不为我们所发现的宇宙所激动吗？歌唱家现在还不会歌唱科学带来的神奇美妙，科学对于人们来说还是在讲课中接受的，而不是在诗与歌之中。这说明我们还没有进入一个科学的时代。</p>\n<p>这种沉默无歌的原因之一，大概是人们必须懂得如何读这种音乐的乐谱才能歌唱。比如，一篇科学论文说，“鼠的脑中放射标记的磷在两周中减了一半。”这是什么意思呢？</p>\n<p>它的意思是鼠脑中（你、我的脑子也没什么差别）的磷有一半已经不是两周前的原子了，它们已被替换了。那么我要问：“究竟什么是载有意识的分子呢？子虚乌有么？这些全新的分子能承载一年前在我脑中的记忆，可当时发生记忆的分子却早已被置换了！这个发现就像是说我这个体仅仅是一个舞蹈的编排。分子们进入我的大脑，跳了一场舞就离开了；新的分子又进来，还是跳和昨天一模一样的舞蹈——它们能记住！”</p>\n<p>有时我们会从报纸上念到这样的话：“科学家认为这项发现对于治疗肿瘤是十分重要的……”。<strong>看，这报道只注重那项发现有什么可利用之处，而完全丢开了它本身的意义。而实际上它是多么奇妙啊！偶尔，小孩子反倒会意识到那些意义；此时，一个科学家的苗子出现了。如果当他们上大学时我们才教他们这些，那就太晚了。我们必须从孩童教起。</strong></p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">科学本身的为什么着实让人着迷</code></pre>\n<h2 id=\"03\"><a href=\"#03\" class=\"headerlink\" title=\"03\"></a>03</h2><p>现在，我来谈谈科学的第三个价值——它稍稍有些间接，不过并不牵强。<strong>科学家们成天经历的就是无知、疑惑、不确定，这种经历是极其重要的</strong>。当科学家不知道答案时，他是无知的；当他心中大概有了猜测时，他是不确定的；即便他满有把握时，他也会永远留下质疑的余地。承认自己的无知，留下质疑的余地，这两者对于任何发展都必不可少。科学知识本身是一个具有不同层次可信度的集合体：有的根本不确定，有的比较确定，但没有什么是完全确定的。</p>\n<p>科学家们对上述情形习以为常，他们自然地由于不确定而质疑，而且承认自己无知。但是我认为大多数人并不明白这一点。在历史上科学与专制权威进行了反复的斗争才渐渐赢得了我们质疑的自由。那是一场多么艰辛、旷日持久的战斗啊！它终于使我们可以提问、可以质疑、可以不确定。我们绝不应该忘记历史，以致丢失千辛万苦争来的自由。这，是我们科学家对社会的责任。</p>\n<p>人类的潜能之大、成就之小，令人想起来未免神伤，总觉得人类可以更好。先人在恶魇中梦想未来；我们（正是他们的未来）则看到他们的梦想有些已经成真，大多却仍然是梦想，一如往日。</p>\n<p>有人说教育的不普及是人类不能前行的原因。可是难道教育普及了，所有的人就都能成为伏尔泰吗？坏的和好的是同样可以被传授的；教育同样拥有趋善或趋恶的巨大能力。</p>\n<p>另一个梦想是国与国之间的充分交流一定会增加互相理解。可是交流的工具是可以被操纵的。如此说来所交流的既可以是真实，也可以是谎言。交流也具有趋善和趋恶双重可能。</p>\n<p>应用科学可以解决人们的物资需求，医药可以控制疾病——看上去总算尽善尽美了吧？可偏偏有不少人在专心致志地制造可怖的毒物、细菌，为化学生物战争做准备。</p>\n<p>几乎谁都不喜欢战争，和平是人类的梦想——人们尽可能地发挥潜能。可没准儿未来的人们发现和平也可好可坏。没准儿和平时代的人因没有挑战而厌倦不堪，于是终日痛饮不止，而醉熏熏的人并不能发挥潜能、成就大业。<br>和平显然是一个很大的力量，如同严谨、物资发展、交流，教育、诚实和先人的梦想。与先人相比，我们确实进步了，有更多的能力了。可与我们能够成就的相比，所达到的就相形见绌。</p>\n<p>原因何在？为什么我们就无法战胜自己？</p>\n<p>因为我们发现，巨大的潜能和力量并没有带着如何使用它们的说明书。譬如，对物质世界认识愈多，人们就愈觉得世界真是毫无目的意义可言。科学并无法指导行善或行恶。  </p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">科学并不会指导善与恶</code></pre>\n\n<h2 id=\"04\"><a href=\"#04\" class=\"headerlink\" title=\"04\"></a>04</h2><p>有史以来，人们一直都在探究生命的意义。他们想：如果有某种意义和方向来指导，人的伟大潜能定会充分发挥。于是有了许多种对生命意义的阐述和教义。这些各自不同的教义有着自己的信徒，而某一种教义的信徒总是怀着恐惧的心情看待其余教义的信徒。这种恐惧来自于信念的互不相容，致使原本良好的出发点都汇入了一条死胡同。<strong>事实上，正是从这些历史上错误信仰所制造的巨大谬误中，哲学思考者们慢慢发现了人类美妙无限的能力。人们梦想能发现一条通途</strong>。</p>\n<p>那么，这些又有什么意义呢？我们如何来解开存在之谜呢？</p>\n<p>如果把所有的加以考量——不仅是先人所知，而且他们不知而我们今天所知的——那么我认为我们必须坦率地承认，我们还是知之甚微。</p>\n<p>不过，正当我们如此承认的时候，我们便开始找到了通途。</p>\n<p>这并非一个新观念，它是理性时代的观念，也正是它指导着先贤们缔造了我们今日享用的民主制度。正因为相信没有一个人绝对懂得如何管理政府，我们才有这样一个制度来保证新的想法可以产生发展、被尝试运用、并在必要的时候被抛弃；更新的想法又可以如此地轮回运行。这是—种尝试——纠偏的系统方法。这种系统方法的建立，正是因为在18世纪末，科学已经成功地证明了它的可行性。在那时，关注社会的人们已经意识到：<strong>对各种可能性持开明态度便带来机会；质疑和讨论是探索未知的关键，如果我们想解决以前未能解决的问题，那我们就必须这样地把通向未知的门开启</strong>。</p>\n<p><strong>人类还处在初始阶段，因此我们遇上各种问题是毫不奇怪的。好在未来还有千千万万年。我们的责任是学所能学、为所可为、探索更好的办法，并传给下一代。我们的责任是给未来的人们一双没有束缚自由的双手</strong>。在人类鲁莽冲动的青年期，人们常会制造巨大的错误而导致长久的停滞。倘若我们自以为对众多的问题都已有了明白的答案，年轻而无知的我们一定会犯这样的错误。如果我们压制批评，不许讨论，大声宣称“看哪，同胞们，这便是正确的答案，人类得救啦！”我们必然会把人类限制在权威的桎梏和现有想象力之中。这种错误在历史上屡见不鲜。</p>\n<p><strong>作为科学家，我们知道伟大的进展都源于承认无知，源于思想的自由。那么这是我们的责任——宣扬思想自由的价值，教育人们不要惧怕质疑而应该欢迎它、讨论它，而且毫不妥协地坚持拥有这种自由——这是我们对未来千秋万代所负有的责任。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"费曼：任何伟大的科学成就，都源于思想自由\"><a href=\"#费曼：任何伟大的科学成就，都源于思想自由\" class=\"headerlink\" title=\"费曼：任何伟大的科学成就，都源于思想自由\"></a>费曼：任何伟大的科学成就，都源于思想自由</h1><blockquote>\n<p>原文地址 : <a href=\"https://mp.weixin.qq.com/s/p_l9_Z54jewLN6SEjio1Tw\">https://mp.weixin.qq.com/s/p_l9_Z54jewLN6SEjio1Tw</a></p>\n</blockquote>\n<p><img src=\"/./../../picture/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220926005909.jpg\" alt=\"费曼\"></p>\n<h2 id=\"科学的价值\"><a href=\"#科学的价值\" class=\"headerlink\" title=\"科学的价值\"></a>科学的价值</h2><p>当我年轻的时候，我认为科学会有利于每个人。科学显然很有用，也是很有益的。在第二次世界大战中，我参与了原子弹的制造工作。科学的发展导致了原子弹的产生，这显然是一个具有极其严肃意味的事件：它代表着对人类的毁灭。</p>\n<p>战后，我对原子弹忧心忡忡，既不知未来会怎样，也更不敢肯定人类一定会延存。自然地，一个问题会这样被提出：科学是不是包含着邪恶的成分？</p>\n<p>这个问题也可以这样来问：当我们看到科学也可以带来灾难时，那么我如此热爱，并且毕生孜孜为之的科学事业的价值究竟何在？这是我无法回避的问题。</p>\n<p>这篇“科学的价值”，你们可以把它看成是我在探索这个问题时的所思所悟。</p>\n<p>——理查德·费曼</p>\n<p>时常，人们对我提出，科学家应该多多关心社会问题，特别是要考虑科学对于社会的影响。人们似乎相当普遍地认为，只要科学家们对于错综复杂的社会问题加以关注，而不是成天钻在枝尾末节的科学研究之中，那么巨大的成功就会自然到来。</p>\n<p>我以为，我们科学家是很关注这些社会问题的，只不过我们不是把它们当作自己的全职而已。其原因是，对于这些比科学研究复杂千百倍的社会问题，我们也是百思不得其解，绝无灵丹妙药。</p>\n<p>我认为当科学家思考非科学问题时，他和所有的人一样无知；当他要对非科学问题发表见解时，他和所有的门外汉一样幼稚。今天我的讲演“科学的价值”所针对的并不是一个科学课题，而是价值评判；这样看来，我下面将要讲的大概也是粗浅不堪的了。</p>\n<h2 id=\"01\"><a href=\"#01\" class=\"headerlink\" title=\"01\"></a>01</h2><p><strong>科学的价值的第一点是众所周知的。科学知识使人们能制造许多产品、做许多事业</strong>。当然，当人们运用科学做了善事的时候，功劳不仅归于科学本身，而且也归于指导着我们的道德选择。科学知识给予人们能力去行善，也可以作恶，它本身可并没有附带着使用说明。这种能力显然是有价值的，尽管好坏决定于如何使用它。</p>\n<p>在一次去夏威夷的路途中，我学会了一种方法来表达上述问题——一个佛堂的主持向游客们谈及佛学，最后他说他的临别赠言将使游客们永不忘却（我是真的从未忘却）。这赠言是佛经中的一句箴语：“每个人都掌握着一把开启天堂之门的钥匙，这把钥匙也同样能打开地狱之门。”</p>\n<p>如此说来，开启天堂之门的钥匙又有什么价值呢？如果我们没有办法分辨一扇门是通向天堂还是地狱，那么手中的钥匙可是个危险的玩艺儿。</p>\n<p>可是这钥匙又确实有它的价值——没有它，我们无法开启天堂之门；没有它，我们即使明辨了天堂与地狱，也还是束手无策。这样推论下来，尽管科学知识可能被误用以导致灾难，它的这种产生巨大影响的能力本身是一种价值。</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">这里的钥匙可以理解为科学知识,或者利用科学知识创造的产品,这一段主要阐述科学的其中一个价值</code></pre>\n<h2 id=\"02\"><a href=\"#02\" class=\"headerlink\" title=\"02\"></a>02</h2><p><strong>科学的另一个价值是提供智慧与思辨的享受</strong>。这种享受一些人可以从阅读、学习、思考中得到，而另一些人则要从真正的深入研究中方能满足。这种智慧思辨享受的重要性往往被人们忽视，特别是那些喋喋不休地教导我们科学家要承担社会责任的先生们。</p>\n<p>我当然不是说个人在智慧思辨中的享受是科学的全部价值所在。不过，<strong>如果我们社会进步的最终目标正是为了让各种人能享受他想做的事，那么科学家们思辨求知的享受也就和其他事具有同等的重要性了。</strong></p>\n<p><strong>另外一个不容低估的科学的价值是它改变了人们对世界的概念</strong>。由于科学的发展，我们今天可以想象无穷奇妙的东西，比诗人和梦想者的想象丰富离奇千万倍。自然的想象和多姿比人类要高明得多。比如吧，诗人想象巨大的海龟驮着大象到海里旅行；而科学给了我们一幅图画——天宇中一个巨大的球在旋转；在它的表面，人们被神奇的引力吸住，并附着它在旋转。</p>\n<p>我常常想这些奇妙的东西，这些从前人们根本不可想象，而如今科学知识使我们可以想象的东西。</p>\n<p>曾经，我站在海边的沙滩上，陷入了这样的深思：</p>\n<blockquote>\n<p>潮起潮落<br>无法计数的分子各自孤独地运行<br>相距遥远却又息息相关<br>泛起和谐的白浪<br>旷代久远  </p>\n<p>在尚无生物的上古<br>眼睛还未出现<br>年复一年<br>惊涛拍岸如今<br>为了谁，为了什么？<br>在一个死寂的星球<br>没有为之欣悦的生命   </p>\n<p>永无休止<br>骄阳弥散着能量<br>射向无垠的宇宙<br>掀动着大海的波浪<br>大洋深处<br>分子重复不变<br>忽然，萌生新的组合<br>它们会复制自身<br>由此演出了全新的一幕  </p>\n<p>愈变愈大<br>愈变愈复杂<br>生物，DNA，蛋白质<br>它们的舞蹈愈加神奇  </p>\n<p>跃出海洋<br>走向陆地<br>站立着<br>具有认知力的原子<br>具有好奇心的物质  </p>\n<p>凭海向洋<br>一个好奇者在好奇<br>我——<br>一个原子的宇宙<br>一个宇宙中的原子  </p>\n</blockquote>\n<p>这样的激动、惊叹和神秘，在我们研究问题时一次又一次地出现。<strong>知识的进步总是带来更深、更美妙的神秘，吸引着我们去更深一层地探索</strong>。有时探索的结果令人失望，可这又有什么关系？我们总是兴致勃勃而自信地深钻下去，发现无法想象的奇妙和随之而来的更深更美妙的神秘。这难道不是最激动人心的探索么！</p>\n<p>诚然，没有过科学研究经历的人大概不会有这种近似宗教的感受。诗人不会写它，艺术家也无法描述这种奇妙的感受。我很是不解——难道他们都不为我们所发现的宇宙所激动吗？歌唱家现在还不会歌唱科学带来的神奇美妙，科学对于人们来说还是在讲课中接受的，而不是在诗与歌之中。这说明我们还没有进入一个科学的时代。</p>\n<p>这种沉默无歌的原因之一，大概是人们必须懂得如何读这种音乐的乐谱才能歌唱。比如，一篇科学论文说，“鼠的脑中放射标记的磷在两周中减了一半。”这是什么意思呢？</p>\n<p>它的意思是鼠脑中（你、我的脑子也没什么差别）的磷有一半已经不是两周前的原子了，它们已被替换了。那么我要问：“究竟什么是载有意识的分子呢？子虚乌有么？这些全新的分子能承载一年前在我脑中的记忆，可当时发生记忆的分子却早已被置换了！这个发现就像是说我这个体仅仅是一个舞蹈的编排。分子们进入我的大脑，跳了一场舞就离开了；新的分子又进来，还是跳和昨天一模一样的舞蹈——它们能记住！”</p>\n<p>有时我们会从报纸上念到这样的话：“科学家认为这项发现对于治疗肿瘤是十分重要的……”。<strong>看，这报道只注重那项发现有什么可利用之处，而完全丢开了它本身的意义。而实际上它是多么奇妙啊！偶尔，小孩子反倒会意识到那些意义；此时，一个科学家的苗子出现了。如果当他们上大学时我们才教他们这些，那就太晚了。我们必须从孩童教起。</strong></p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">科学本身的为什么着实让人着迷</code></pre>\n<h2 id=\"03\"><a href=\"#03\" class=\"headerlink\" title=\"03\"></a>03</h2><p>现在，我来谈谈科学的第三个价值——它稍稍有些间接，不过并不牵强。<strong>科学家们成天经历的就是无知、疑惑、不确定，这种经历是极其重要的</strong>。当科学家不知道答案时，他是无知的；当他心中大概有了猜测时，他是不确定的；即便他满有把握时，他也会永远留下质疑的余地。承认自己的无知，留下质疑的余地，这两者对于任何发展都必不可少。科学知识本身是一个具有不同层次可信度的集合体：有的根本不确定，有的比较确定，但没有什么是完全确定的。</p>\n<p>科学家们对上述情形习以为常，他们自然地由于不确定而质疑，而且承认自己无知。但是我认为大多数人并不明白这一点。在历史上科学与专制权威进行了反复的斗争才渐渐赢得了我们质疑的自由。那是一场多么艰辛、旷日持久的战斗啊！它终于使我们可以提问、可以质疑、可以不确定。我们绝不应该忘记历史，以致丢失千辛万苦争来的自由。这，是我们科学家对社会的责任。</p>\n<p>人类的潜能之大、成就之小，令人想起来未免神伤，总觉得人类可以更好。先人在恶魇中梦想未来；我们（正是他们的未来）则看到他们的梦想有些已经成真，大多却仍然是梦想，一如往日。</p>\n<p>有人说教育的不普及是人类不能前行的原因。可是难道教育普及了，所有的人就都能成为伏尔泰吗？坏的和好的是同样可以被传授的；教育同样拥有趋善或趋恶的巨大能力。</p>\n<p>另一个梦想是国与国之间的充分交流一定会增加互相理解。可是交流的工具是可以被操纵的。如此说来所交流的既可以是真实，也可以是谎言。交流也具有趋善和趋恶双重可能。</p>\n<p>应用科学可以解决人们的物资需求，医药可以控制疾病——看上去总算尽善尽美了吧？可偏偏有不少人在专心致志地制造可怖的毒物、细菌，为化学生物战争做准备。</p>\n<p>几乎谁都不喜欢战争，和平是人类的梦想——人们尽可能地发挥潜能。可没准儿未来的人们发现和平也可好可坏。没准儿和平时代的人因没有挑战而厌倦不堪，于是终日痛饮不止，而醉熏熏的人并不能发挥潜能、成就大业。<br>和平显然是一个很大的力量，如同严谨、物资发展、交流，教育、诚实和先人的梦想。与先人相比，我们确实进步了，有更多的能力了。可与我们能够成就的相比，所达到的就相形见绌。</p>\n<p>原因何在？为什么我们就无法战胜自己？</p>\n<p>因为我们发现，巨大的潜能和力量并没有带着如何使用它们的说明书。譬如，对物质世界认识愈多，人们就愈觉得世界真是毫无目的意义可言。科学并无法指导行善或行恶。  </p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">科学并不会指导善与恶</code></pre>\n\n<h2 id=\"04\"><a href=\"#04\" class=\"headerlink\" title=\"04\"></a>04</h2><p>有史以来，人们一直都在探究生命的意义。他们想：如果有某种意义和方向来指导，人的伟大潜能定会充分发挥。于是有了许多种对生命意义的阐述和教义。这些各自不同的教义有着自己的信徒，而某一种教义的信徒总是怀着恐惧的心情看待其余教义的信徒。这种恐惧来自于信念的互不相容，致使原本良好的出发点都汇入了一条死胡同。<strong>事实上，正是从这些历史上错误信仰所制造的巨大谬误中，哲学思考者们慢慢发现了人类美妙无限的能力。人们梦想能发现一条通途</strong>。</p>\n<p>那么，这些又有什么意义呢？我们如何来解开存在之谜呢？</p>\n<p>如果把所有的加以考量——不仅是先人所知，而且他们不知而我们今天所知的——那么我认为我们必须坦率地承认，我们还是知之甚微。</p>\n<p>不过，正当我们如此承认的时候，我们便开始找到了通途。</p>\n<p>这并非一个新观念，它是理性时代的观念，也正是它指导着先贤们缔造了我们今日享用的民主制度。正因为相信没有一个人绝对懂得如何管理政府，我们才有这样一个制度来保证新的想法可以产生发展、被尝试运用、并在必要的时候被抛弃；更新的想法又可以如此地轮回运行。这是—种尝试——纠偏的系统方法。这种系统方法的建立，正是因为在18世纪末，科学已经成功地证明了它的可行性。在那时，关注社会的人们已经意识到：<strong>对各种可能性持开明态度便带来机会；质疑和讨论是探索未知的关键，如果我们想解决以前未能解决的问题，那我们就必须这样地把通向未知的门开启</strong>。</p>\n<p><strong>人类还处在初始阶段，因此我们遇上各种问题是毫不奇怪的。好在未来还有千千万万年。我们的责任是学所能学、为所可为、探索更好的办法，并传给下一代。我们的责任是给未来的人们一双没有束缚自由的双手</strong>。在人类鲁莽冲动的青年期，人们常会制造巨大的错误而导致长久的停滞。倘若我们自以为对众多的问题都已有了明白的答案，年轻而无知的我们一定会犯这样的错误。如果我们压制批评，不许讨论，大声宣称“看哪，同胞们，这便是正确的答案，人类得救啦！”我们必然会把人类限制在权威的桎梏和现有想象力之中。这种错误在历史上屡见不鲜。</p>\n<p><strong>作为科学家，我们知道伟大的进展都源于承认无知，源于思想的自由。那么这是我们的责任——宣扬思想自由的价值，教育人们不要惧怕质疑而应该欢迎它、讨论它，而且毫不妥协地坚持拥有这种自由——这是我们对未来千秋万代所负有的责任。</strong></p>\n"},{"title":"go标准库解析","_content":"# 1. tar\n\n## Constants\n\n  ```golang\n  const (\n    // Type '0' indicates a regular file.\n    TypeReg  = '0'\n    TypeRegA = '\\x00' // Deprecated: Use TypeReg instead.\n\n    // Type '1' to '6' are header-only flags and may not have a data body.\n    TypeLink    = '1' // Hard link\n    TypeSymlink = '2' // Symbolic link\n    TypeChar    = '3' // Character device node\n    TypeBlock   = '4' // Block device node\n    TypeDir     = '5' // Directory\n    TypeFifo    = '6' // FIFO node\n\n    // Type '7' is reserved.\n    TypeCont = '7'\n\n    // Type 'x' is used by the PAX format to store key-value records that\n    // are only relevant to the next file.\n    // This package transparently handles these types.\n    TypeXHeader = 'x'\n\n    // Type 'g' is used by the PAX format to store key-value records that\n    // are relevant to all subsequent files.\n    // This package only supports parsing and composing such headers,\n    // but does not currently support persisting the global state across files.\n    TypeXGlobalHeader = 'g'\n\n    // Type 'S' indicates a sparse file in the GNU format.\n    TypeGNUSparse = 'S'\n\n    // Types 'L' and 'K' are used by the GNU format for a meta file\n    // used to store the path or link name for the next file.\n    // This package transparently handles these types.\n    TypeGNULongName = 'L'\n    TypeGNULongLink = 'K'\n  )\n  ```\n\n## Variables\n\n  ```golang\n  var (\n    ErrHeader          = errors.New(\"archive/tar: invalid tar header\")\n    ErrWriteTooLong    = errors.New(\"archive/tar: write too long\")\n    ErrFieldTooLong    = errors.New(\"archive/tar: header field too long\")\n    ErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n  )\n  ```\n\n## type Format\n\n### func (f Format) String() string\n\n## type Header\n### func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)\n### func (h *Header) FileInfo() fs.FileInfo\n## type Reader\n### func NewReader(r io.Reader) *Reader\n### func (tr *Reader) Next() (*Header, error)\n### func (tr *Reader) Read(b []byte) (int, error)\n## type Writer\n### func NewWriter(w io.Writer) *Writer\n### func (tw *Writer) Close() error\n### func (tw *Writer) Flush() error\n### func (tw *Writer) Write(b []byte) (int, error)\n### func (tw *Writer) WriteHeader(hdr *Header) error\n\n# 2. zip\n\n## Constants\n\n  ```golang\n  const (\n    Store   uint16 = 0 // no compression\n    Deflate uint16 = 8 // DEFLATE compressed\n  )\n  ```\n\n## Variables\n\n  ```golang\n  var (\n    ErrFormat    = errors.New(\"zip: not a valid zip file\")\n    ErrAlgorithm = errors.New(\"zip: unsupported compression algorithm\")\n    ErrChecksum  = errors.New(\"zip: checksum error\")\n  )\n\n  ```\n\n### func RegisterCompressor(method uint16, comp Compressor)\n### func RegisterDecompressor(method uint16, dcomp Decompressor)\n## type Compressor\n## type Decompressor\n## type File\n### func (f *File) DataOffset() (offset int64, err error)\n### func (f *File) Open() (io.ReadCloser, error)\n### func (f *File) OpenRaw() (io.Reader, error)\n## type FileHeader\n### func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)\n### func (h *FileHeader) FileInfo() fs.FileInfo\n### func (h *FileHeader) ModTime() time.TimeDEPRECATED\n### func (h *FileHeader) Mode() (mode fs.FileMode)\n### func (h *FileHeader) SetModTime(t time.Time)DEPRECATED\n### func (h *FileHeader) SetMode(mode fs.FileMode)\n## type ReadCloser\n### func OpenReader(name string) (*ReadCloser, error)\n### func (rc *ReadCloser) Close() error\n## type Reader\n### func NewReader(r io.ReaderAt, size int64) (*Reader, error)\n### func (r *Reader) Open(name string) (fs.File, error)\n### func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)\n## type Writer\n### func NewWriter(w io.Writer) *Writer\n### func (w *Writer) Close() error\n### func (w *Writer) Copy(f *File) error\n### func (w *Writer) Create(name string) (io.Writer, error)\n### func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)\n### func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)\n### func (w *Writer) Flush() error\n### func (w *Writer) RegisterCompressor(method uint16, comp Compressor)\n### func (w *Writer) SetComment(comment string) error\n### func (w *Writer) SetOffset(n int64)\n\n\n# rand\n\n## function not method of rand\n### func ExpFloat64() float64\n### func Float32() float32\n### func Float64() float64\n### func Int() int\n### func Int31() int32\n### func Int31n(n int32) int32\n### func Int63() int64\n### func Int63n(n int64) int64\n### func Intn(n int) int\n### func NormFloat64() float64\n### func Perm(n int) []int\n### func Read(p []byte) (n int, err error)\n### func Seed(seed int64)\n### func Shuffle(n int, swap func(i, j int))\n### func Uint32() uint32\n### func Uint64() uint64\n## type Rand\n### func New(src Source) *Rand\n### func (r *Rand) ExpFloat64() float64\n### func (r *Rand) Float32() float32\n### func (r *Rand) Float64() float64\n### func (r *Rand) Int() int\n### func (r *Rand) Int31() int32\n### func (r *Rand) Int31n(n int32) int32\n### func (r *Rand) Int63() int64\n### func (r *Rand) Int63n(n int64) int64\n### func (r *Rand) Intn(n int) int\n### func (r *Rand) NormFloat64() float64\n### func (r *Rand) Perm(n int) []int\n### func (r *Rand) Read(p []byte) (n int, err error)\n### func (r *Rand) Seed(seed int64)\nSeed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。\n\n### func (r *Rand) Shuffle(n int, swap func(i, j int))\n### func (r *Rand) Uint32() uint32\n### func (r *Rand) Uint64() uint64\n## type Source\n\n### func NewSource(seed int64) Source\n\nNewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。\n\n```golang\nrandomSource := NewSource(time.Now().UnixNano())\nrandSeed := New(randomSource) //这时候就可以使用rand的method\nrandomInt := randSeed.Intn(300)//[0,300)的整数\n\n```\n\n\n## type Source64\n\nSource64是一个也可以直接生成[0, 1<<64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。  \nSource64的结构\n\n```golang\ntype Source64 interface {\n    Source\n    Uint64() uint64\n}\n```\n\n## type Zipf\n### func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf\n### func (z *Zipf) Uint64() uint64\n\n\n","source":"_posts/golang/go标准文档.md","raw":"---\ntitle: go标准库解析\ncategories:\n- golang\ntag: golang\n---\n# 1. tar\n\n## Constants\n\n  ```golang\n  const (\n    // Type '0' indicates a regular file.\n    TypeReg  = '0'\n    TypeRegA = '\\x00' // Deprecated: Use TypeReg instead.\n\n    // Type '1' to '6' are header-only flags and may not have a data body.\n    TypeLink    = '1' // Hard link\n    TypeSymlink = '2' // Symbolic link\n    TypeChar    = '3' // Character device node\n    TypeBlock   = '4' // Block device node\n    TypeDir     = '5' // Directory\n    TypeFifo    = '6' // FIFO node\n\n    // Type '7' is reserved.\n    TypeCont = '7'\n\n    // Type 'x' is used by the PAX format to store key-value records that\n    // are only relevant to the next file.\n    // This package transparently handles these types.\n    TypeXHeader = 'x'\n\n    // Type 'g' is used by the PAX format to store key-value records that\n    // are relevant to all subsequent files.\n    // This package only supports parsing and composing such headers,\n    // but does not currently support persisting the global state across files.\n    TypeXGlobalHeader = 'g'\n\n    // Type 'S' indicates a sparse file in the GNU format.\n    TypeGNUSparse = 'S'\n\n    // Types 'L' and 'K' are used by the GNU format for a meta file\n    // used to store the path or link name for the next file.\n    // This package transparently handles these types.\n    TypeGNULongName = 'L'\n    TypeGNULongLink = 'K'\n  )\n  ```\n\n## Variables\n\n  ```golang\n  var (\n    ErrHeader          = errors.New(\"archive/tar: invalid tar header\")\n    ErrWriteTooLong    = errors.New(\"archive/tar: write too long\")\n    ErrFieldTooLong    = errors.New(\"archive/tar: header field too long\")\n    ErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n  )\n  ```\n\n## type Format\n\n### func (f Format) String() string\n\n## type Header\n### func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)\n### func (h *Header) FileInfo() fs.FileInfo\n## type Reader\n### func NewReader(r io.Reader) *Reader\n### func (tr *Reader) Next() (*Header, error)\n### func (tr *Reader) Read(b []byte) (int, error)\n## type Writer\n### func NewWriter(w io.Writer) *Writer\n### func (tw *Writer) Close() error\n### func (tw *Writer) Flush() error\n### func (tw *Writer) Write(b []byte) (int, error)\n### func (tw *Writer) WriteHeader(hdr *Header) error\n\n# 2. zip\n\n## Constants\n\n  ```golang\n  const (\n    Store   uint16 = 0 // no compression\n    Deflate uint16 = 8 // DEFLATE compressed\n  )\n  ```\n\n## Variables\n\n  ```golang\n  var (\n    ErrFormat    = errors.New(\"zip: not a valid zip file\")\n    ErrAlgorithm = errors.New(\"zip: unsupported compression algorithm\")\n    ErrChecksum  = errors.New(\"zip: checksum error\")\n  )\n\n  ```\n\n### func RegisterCompressor(method uint16, comp Compressor)\n### func RegisterDecompressor(method uint16, dcomp Decompressor)\n## type Compressor\n## type Decompressor\n## type File\n### func (f *File) DataOffset() (offset int64, err error)\n### func (f *File) Open() (io.ReadCloser, error)\n### func (f *File) OpenRaw() (io.Reader, error)\n## type FileHeader\n### func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)\n### func (h *FileHeader) FileInfo() fs.FileInfo\n### func (h *FileHeader) ModTime() time.TimeDEPRECATED\n### func (h *FileHeader) Mode() (mode fs.FileMode)\n### func (h *FileHeader) SetModTime(t time.Time)DEPRECATED\n### func (h *FileHeader) SetMode(mode fs.FileMode)\n## type ReadCloser\n### func OpenReader(name string) (*ReadCloser, error)\n### func (rc *ReadCloser) Close() error\n## type Reader\n### func NewReader(r io.ReaderAt, size int64) (*Reader, error)\n### func (r *Reader) Open(name string) (fs.File, error)\n### func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)\n## type Writer\n### func NewWriter(w io.Writer) *Writer\n### func (w *Writer) Close() error\n### func (w *Writer) Copy(f *File) error\n### func (w *Writer) Create(name string) (io.Writer, error)\n### func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)\n### func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)\n### func (w *Writer) Flush() error\n### func (w *Writer) RegisterCompressor(method uint16, comp Compressor)\n### func (w *Writer) SetComment(comment string) error\n### func (w *Writer) SetOffset(n int64)\n\n\n# rand\n\n## function not method of rand\n### func ExpFloat64() float64\n### func Float32() float32\n### func Float64() float64\n### func Int() int\n### func Int31() int32\n### func Int31n(n int32) int32\n### func Int63() int64\n### func Int63n(n int64) int64\n### func Intn(n int) int\n### func NormFloat64() float64\n### func Perm(n int) []int\n### func Read(p []byte) (n int, err error)\n### func Seed(seed int64)\n### func Shuffle(n int, swap func(i, j int))\n### func Uint32() uint32\n### func Uint64() uint64\n## type Rand\n### func New(src Source) *Rand\n### func (r *Rand) ExpFloat64() float64\n### func (r *Rand) Float32() float32\n### func (r *Rand) Float64() float64\n### func (r *Rand) Int() int\n### func (r *Rand) Int31() int32\n### func (r *Rand) Int31n(n int32) int32\n### func (r *Rand) Int63() int64\n### func (r *Rand) Int63n(n int64) int64\n### func (r *Rand) Intn(n int) int\n### func (r *Rand) NormFloat64() float64\n### func (r *Rand) Perm(n int) []int\n### func (r *Rand) Read(p []byte) (n int, err error)\n### func (r *Rand) Seed(seed int64)\nSeed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。\n\n### func (r *Rand) Shuffle(n int, swap func(i, j int))\n### func (r *Rand) Uint32() uint32\n### func (r *Rand) Uint64() uint64\n## type Source\n\n### func NewSource(seed int64) Source\n\nNewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。\n\n```golang\nrandomSource := NewSource(time.Now().UnixNano())\nrandSeed := New(randomSource) //这时候就可以使用rand的method\nrandomInt := randSeed.Intn(300)//[0,300)的整数\n\n```\n\n\n## type Source64\n\nSource64是一个也可以直接生成[0, 1<<64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。  \nSource64的结构\n\n```golang\ntype Source64 interface {\n    Source\n    Uint64() uint64\n}\n```\n\n## type Zipf\n### func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf\n### func (z *Zipf) Uint64() uint64\n\n\n","slug":"golang/go标准文档","published":1,"date":"2022-10-07T23:48:06.892Z","updated":"2022-10-08T05:58:13.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5r0018l1db2chg7euc","content":"<h1 id=\"1-tar\"><a href=\"#1-tar\" class=\"headerlink\" title=\"1. tar\"></a>1. tar</h1><h2 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">const (\n  &#x2F;&#x2F; Type &#39;0&#39; indicates a regular file.\n  TypeReg  &#x3D; &#39;0&#39;\n  TypeRegA &#x3D; &#39;\\x00&#39; &#x2F;&#x2F; Deprecated: Use TypeReg instead.\n\n  &#x2F;&#x2F; Type &#39;1&#39; to &#39;6&#39; are header-only flags and may not have a data body.\n  TypeLink    &#x3D; &#39;1&#39; &#x2F;&#x2F; Hard link\n  TypeSymlink &#x3D; &#39;2&#39; &#x2F;&#x2F; Symbolic link\n  TypeChar    &#x3D; &#39;3&#39; &#x2F;&#x2F; Character device node\n  TypeBlock   &#x3D; &#39;4&#39; &#x2F;&#x2F; Block device node\n  TypeDir     &#x3D; &#39;5&#39; &#x2F;&#x2F; Directory\n  TypeFifo    &#x3D; &#39;6&#39; &#x2F;&#x2F; FIFO node\n\n  &#x2F;&#x2F; Type &#39;7&#39; is reserved.\n  TypeCont &#x3D; &#39;7&#39;\n\n  &#x2F;&#x2F; Type &#39;x&#39; is used by the PAX format to store key-value records that\n  &#x2F;&#x2F; are only relevant to the next file.\n  &#x2F;&#x2F; This package transparently handles these types.\n  TypeXHeader &#x3D; &#39;x&#39;\n\n  &#x2F;&#x2F; Type &#39;g&#39; is used by the PAX format to store key-value records that\n  &#x2F;&#x2F; are relevant to all subsequent files.\n  &#x2F;&#x2F; This package only supports parsing and composing such headers,\n  &#x2F;&#x2F; but does not currently support persisting the global state across files.\n  TypeXGlobalHeader &#x3D; &#39;g&#39;\n\n  &#x2F;&#x2F; Type &#39;S&#39; indicates a sparse file in the GNU format.\n  TypeGNUSparse &#x3D; &#39;S&#39;\n\n  &#x2F;&#x2F; Types &#39;L&#39; and &#39;K&#39; are used by the GNU format for a meta file\n  &#x2F;&#x2F; used to store the path or link name for the next file.\n  &#x2F;&#x2F; This package transparently handles these types.\n  TypeGNULongName &#x3D; &#39;L&#39;\n  TypeGNULongLink &#x3D; &#39;K&#39;\n)</code></pre>\n\n<h2 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var (\n  ErrHeader          &#x3D; errors.New(&quot;archive&#x2F;tar: invalid tar header&quot;)\n  ErrWriteTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: write too long&quot;)\n  ErrFieldTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: header field too long&quot;)\n  ErrWriteAfterClose &#x3D; errors.New(&quot;archive&#x2F;tar: write after close&quot;)\n)</code></pre>\n\n<h2 id=\"type-Format\"><a href=\"#type-Format\" class=\"headerlink\" title=\"type Format\"></a>type Format</h2><h3 id=\"func-f-Format-String-string\"><a href=\"#func-f-Format-String-string\" class=\"headerlink\" title=\"func (f Format) String() string\"></a>func (f Format) String() string</h3><h2 id=\"type-Header\"><a href=\"#type-Header\" class=\"headerlink\" title=\"type Header\"></a>type Header</h2><h3 id=\"func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error\"><a href=\"#func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error\" class=\"headerlink\" title=\"func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)\"></a>func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)</h3><h3 id=\"func-h-Header-FileInfo-fs-FileInfo\"><a href=\"#func-h-Header-FileInfo-fs-FileInfo\" class=\"headerlink\" title=\"func (h *Header) FileInfo() fs.FileInfo\"></a>func (h *Header) FileInfo() fs.FileInfo</h3><h2 id=\"type-Reader\"><a href=\"#type-Reader\" class=\"headerlink\" title=\"type Reader\"></a>type Reader</h2><h3 id=\"func-NewReader-r-io-Reader-Reader\"><a href=\"#func-NewReader-r-io-Reader-Reader\" class=\"headerlink\" title=\"func NewReader(r io.Reader) *Reader\"></a>func NewReader(r io.Reader) *Reader</h3><h3 id=\"func-tr-Reader-Next-Header-error\"><a href=\"#func-tr-Reader-Next-Header-error\" class=\"headerlink\" title=\"func (tr *Reader) Next() (*Header, error)\"></a>func (tr *Reader) Next() (*Header, error)</h3><h3 id=\"func-tr-Reader-Read-b-byte-int-error\"><a href=\"#func-tr-Reader-Read-b-byte-int-error\" class=\"headerlink\" title=\"func (tr *Reader) Read(b []byte) (int, error)\"></a>func (tr *Reader) Read(b []byte) (int, error)</h3><h2 id=\"type-Writer\"><a href=\"#type-Writer\" class=\"headerlink\" title=\"type Writer\"></a>type Writer</h2><h3 id=\"func-NewWriter-w-io-Writer-Writer\"><a href=\"#func-NewWriter-w-io-Writer-Writer\" class=\"headerlink\" title=\"func NewWriter(w io.Writer) *Writer\"></a>func NewWriter(w io.Writer) *Writer</h3><h3 id=\"func-tw-Writer-Close-error\"><a href=\"#func-tw-Writer-Close-error\" class=\"headerlink\" title=\"func (tw *Writer) Close() error\"></a>func (tw *Writer) Close() error</h3><h3 id=\"func-tw-Writer-Flush-error\"><a href=\"#func-tw-Writer-Flush-error\" class=\"headerlink\" title=\"func (tw *Writer) Flush() error\"></a>func (tw *Writer) Flush() error</h3><h3 id=\"func-tw-Writer-Write-b-byte-int-error\"><a href=\"#func-tw-Writer-Write-b-byte-int-error\" class=\"headerlink\" title=\"func (tw *Writer) Write(b []byte) (int, error)\"></a>func (tw *Writer) Write(b []byte) (int, error)</h3><h3 id=\"func-tw-Writer-WriteHeader-hdr-Header-error\"><a href=\"#func-tw-Writer-WriteHeader-hdr-Header-error\" class=\"headerlink\" title=\"func (tw *Writer) WriteHeader(hdr *Header) error\"></a>func (tw *Writer) WriteHeader(hdr *Header) error</h3><h1 id=\"2-zip\"><a href=\"#2-zip\" class=\"headerlink\" title=\"2. zip\"></a>2. zip</h1><h2 id=\"Constants-1\"><a href=\"#Constants-1\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">const (\n  Store   uint16 &#x3D; 0 &#x2F;&#x2F; no compression\n  Deflate uint16 &#x3D; 8 &#x2F;&#x2F; DEFLATE compressed\n)</code></pre>\n\n<h2 id=\"Variables-1\"><a href=\"#Variables-1\" class=\"headerlink\" title=\"Variables\"></a>Variables</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var (\n  ErrFormat    &#x3D; errors.New(&quot;zip: not a valid zip file&quot;)\n  ErrAlgorithm &#x3D; errors.New(&quot;zip: unsupported compression algorithm&quot;)\n  ErrChecksum  &#x3D; errors.New(&quot;zip: checksum error&quot;)\n)\n</code></pre>\n\n<h3 id=\"func-RegisterCompressor-method-uint16-comp-Compressor\"><a href=\"#func-RegisterCompressor-method-uint16-comp-Compressor\" class=\"headerlink\" title=\"func RegisterCompressor(method uint16, comp Compressor)\"></a>func RegisterCompressor(method uint16, comp Compressor)</h3><h3 id=\"func-RegisterDecompressor-method-uint16-dcomp-Decompressor\"><a href=\"#func-RegisterDecompressor-method-uint16-dcomp-Decompressor\" class=\"headerlink\" title=\"func RegisterDecompressor(method uint16, dcomp Decompressor)\"></a>func RegisterDecompressor(method uint16, dcomp Decompressor)</h3><h2 id=\"type-Compressor\"><a href=\"#type-Compressor\" class=\"headerlink\" title=\"type Compressor\"></a>type Compressor</h2><h2 id=\"type-Decompressor\"><a href=\"#type-Decompressor\" class=\"headerlink\" title=\"type Decompressor\"></a>type Decompressor</h2><h2 id=\"type-File\"><a href=\"#type-File\" class=\"headerlink\" title=\"type File\"></a>type File</h2><h3 id=\"func-f-File-DataOffset-offset-int64-err-error\"><a href=\"#func-f-File-DataOffset-offset-int64-err-error\" class=\"headerlink\" title=\"func (f *File) DataOffset() (offset int64, err error)\"></a>func (f *File) DataOffset() (offset int64, err error)</h3><h3 id=\"func-f-File-Open-io-ReadCloser-error\"><a href=\"#func-f-File-Open-io-ReadCloser-error\" class=\"headerlink\" title=\"func (f *File) Open() (io.ReadCloser, error)\"></a>func (f *File) Open() (io.ReadCloser, error)</h3><h3 id=\"func-f-File-OpenRaw-io-Reader-error\"><a href=\"#func-f-File-OpenRaw-io-Reader-error\" class=\"headerlink\" title=\"func (f *File) OpenRaw() (io.Reader, error)\"></a>func (f *File) OpenRaw() (io.Reader, error)</h3><h2 id=\"type-FileHeader\"><a href=\"#type-FileHeader\" class=\"headerlink\" title=\"type FileHeader\"></a>type FileHeader</h2><h3 id=\"func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error\"><a href=\"#func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error\" class=\"headerlink\" title=\"func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)\"></a>func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</h3><h3 id=\"func-h-FileHeader-FileInfo-fs-FileInfo\"><a href=\"#func-h-FileHeader-FileInfo-fs-FileInfo\" class=\"headerlink\" title=\"func (h *FileHeader) FileInfo() fs.FileInfo\"></a>func (h *FileHeader) FileInfo() fs.FileInfo</h3><h3 id=\"func-h-FileHeader-ModTime-time-TimeDEPRECATED\"><a href=\"#func-h-FileHeader-ModTime-time-TimeDEPRECATED\" class=\"headerlink\" title=\"func (h *FileHeader) ModTime() time.TimeDEPRECATED\"></a>func (h *FileHeader) ModTime() time.TimeDEPRECATED</h3><h3 id=\"func-h-FileHeader-Mode-mode-fs-FileMode\"><a href=\"#func-h-FileHeader-Mode-mode-fs-FileMode\" class=\"headerlink\" title=\"func (h *FileHeader) Mode() (mode fs.FileMode)\"></a>func (h *FileHeader) Mode() (mode fs.FileMode)</h3><h3 id=\"func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED\"><a href=\"#func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED\" class=\"headerlink\" title=\"func (h *FileHeader) SetModTime(t time.Time)DEPRECATED\"></a>func (h *FileHeader) SetModTime(t time.Time)DEPRECATED</h3><h3 id=\"func-h-FileHeader-SetMode-mode-fs-FileMode\"><a href=\"#func-h-FileHeader-SetMode-mode-fs-FileMode\" class=\"headerlink\" title=\"func (h *FileHeader) SetMode(mode fs.FileMode)\"></a>func (h *FileHeader) SetMode(mode fs.FileMode)</h3><h2 id=\"type-ReadCloser\"><a href=\"#type-ReadCloser\" class=\"headerlink\" title=\"type ReadCloser\"></a>type ReadCloser</h2><h3 id=\"func-OpenReader-name-string-ReadCloser-error\"><a href=\"#func-OpenReader-name-string-ReadCloser-error\" class=\"headerlink\" title=\"func OpenReader(name string) (*ReadCloser, error)\"></a>func OpenReader(name string) (*ReadCloser, error)</h3><h3 id=\"func-rc-ReadCloser-Close-error\"><a href=\"#func-rc-ReadCloser-Close-error\" class=\"headerlink\" title=\"func (rc *ReadCloser) Close() error\"></a>func (rc *ReadCloser) Close() error</h3><h2 id=\"type-Reader-1\"><a href=\"#type-Reader-1\" class=\"headerlink\" title=\"type Reader\"></a>type Reader</h2><h3 id=\"func-NewReader-r-io-ReaderAt-size-int64-Reader-error\"><a href=\"#func-NewReader-r-io-ReaderAt-size-int64-Reader-error\" class=\"headerlink\" title=\"func NewReader(r io.ReaderAt, size int64) (*Reader, error)\"></a>func NewReader(r io.ReaderAt, size int64) (*Reader, error)</h3><h3 id=\"func-r-Reader-Open-name-string-fs-File-error\"><a href=\"#func-r-Reader-Open-name-string-fs-File-error\" class=\"headerlink\" title=\"func (r *Reader) Open(name string) (fs.File, error)\"></a>func (r *Reader) Open(name string) (fs.File, error)</h3><h3 id=\"func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor\"><a href=\"#func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor\" class=\"headerlink\" title=\"func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)\"></a>func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</h3><h2 id=\"type-Writer-1\"><a href=\"#type-Writer-1\" class=\"headerlink\" title=\"type Writer\"></a>type Writer</h2><h3 id=\"func-NewWriter-w-io-Writer-Writer-1\"><a href=\"#func-NewWriter-w-io-Writer-Writer-1\" class=\"headerlink\" title=\"func NewWriter(w io.Writer) *Writer\"></a>func NewWriter(w io.Writer) *Writer</h3><h3 id=\"func-w-Writer-Close-error\"><a href=\"#func-w-Writer-Close-error\" class=\"headerlink\" title=\"func (w *Writer) Close() error\"></a>func (w *Writer) Close() error</h3><h3 id=\"func-w-Writer-Copy-f-File-error\"><a href=\"#func-w-Writer-Copy-f-File-error\" class=\"headerlink\" title=\"func (w *Writer) Copy(f *File) error\"></a>func (w *Writer) Copy(f *File) error</h3><h3 id=\"func-w-Writer-Create-name-string-io-Writer-error\"><a href=\"#func-w-Writer-Create-name-string-io-Writer-error\" class=\"headerlink\" title=\"func (w *Writer) Create(name string) (io.Writer, error)\"></a>func (w *Writer) Create(name string) (io.Writer, error)</h3><h3 id=\"func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error\"><a href=\"#func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error\" class=\"headerlink\" title=\"func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)\"></a>func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)</h3><h3 id=\"func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error\"><a href=\"#func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error\" class=\"headerlink\" title=\"func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)\"></a>func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)</h3><h3 id=\"func-w-Writer-Flush-error\"><a href=\"#func-w-Writer-Flush-error\" class=\"headerlink\" title=\"func (w *Writer) Flush() error\"></a>func (w *Writer) Flush() error</h3><h3 id=\"func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor\"><a href=\"#func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor\" class=\"headerlink\" title=\"func (w *Writer) RegisterCompressor(method uint16, comp Compressor)\"></a>func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</h3><h3 id=\"func-w-Writer-SetComment-comment-string-error\"><a href=\"#func-w-Writer-SetComment-comment-string-error\" class=\"headerlink\" title=\"func (w *Writer) SetComment(comment string) error\"></a>func (w *Writer) SetComment(comment string) error</h3><h3 id=\"func-w-Writer-SetOffset-n-int64\"><a href=\"#func-w-Writer-SetOffset-n-int64\" class=\"headerlink\" title=\"func (w *Writer) SetOffset(n int64)\"></a>func (w *Writer) SetOffset(n int64)</h3><h1 id=\"rand\"><a href=\"#rand\" class=\"headerlink\" title=\"rand\"></a>rand</h1><h2 id=\"function-not-method-of-rand\"><a href=\"#function-not-method-of-rand\" class=\"headerlink\" title=\"function not method of rand\"></a>function not method of rand</h2><h3 id=\"func-ExpFloat64-float64\"><a href=\"#func-ExpFloat64-float64\" class=\"headerlink\" title=\"func ExpFloat64() float64\"></a>func ExpFloat64() float64</h3><h3 id=\"func-Float32-float32\"><a href=\"#func-Float32-float32\" class=\"headerlink\" title=\"func Float32() float32\"></a>func Float32() float32</h3><h3 id=\"func-Float64-float64\"><a href=\"#func-Float64-float64\" class=\"headerlink\" title=\"func Float64() float64\"></a>func Float64() float64</h3><h3 id=\"func-Int-int\"><a href=\"#func-Int-int\" class=\"headerlink\" title=\"func Int() int\"></a>func Int() int</h3><h3 id=\"func-Int31-int32\"><a href=\"#func-Int31-int32\" class=\"headerlink\" title=\"func Int31() int32\"></a>func Int31() int32</h3><h3 id=\"func-Int31n-n-int32-int32\"><a href=\"#func-Int31n-n-int32-int32\" class=\"headerlink\" title=\"func Int31n(n int32) int32\"></a>func Int31n(n int32) int32</h3><h3 id=\"func-Int63-int64\"><a href=\"#func-Int63-int64\" class=\"headerlink\" title=\"func Int63() int64\"></a>func Int63() int64</h3><h3 id=\"func-Int63n-n-int64-int64\"><a href=\"#func-Int63n-n-int64-int64\" class=\"headerlink\" title=\"func Int63n(n int64) int64\"></a>func Int63n(n int64) int64</h3><h3 id=\"func-Intn-n-int-int\"><a href=\"#func-Intn-n-int-int\" class=\"headerlink\" title=\"func Intn(n int) int\"></a>func Intn(n int) int</h3><h3 id=\"func-NormFloat64-float64\"><a href=\"#func-NormFloat64-float64\" class=\"headerlink\" title=\"func NormFloat64() float64\"></a>func NormFloat64() float64</h3><h3 id=\"func-Perm-n-int-int\"><a href=\"#func-Perm-n-int-int\" class=\"headerlink\" title=\"func Perm(n int) []int\"></a>func Perm(n int) []int</h3><h3 id=\"func-Read-p-byte-n-int-err-error\"><a href=\"#func-Read-p-byte-n-int-err-error\" class=\"headerlink\" title=\"func Read(p []byte) (n int, err error)\"></a>func Read(p []byte) (n int, err error)</h3><h3 id=\"func-Seed-seed-int64\"><a href=\"#func-Seed-seed-int64\" class=\"headerlink\" title=\"func Seed(seed int64)\"></a>func Seed(seed int64)</h3><h3 id=\"func-Shuffle-n-int-swap-func-i-j-int\"><a href=\"#func-Shuffle-n-int-swap-func-i-j-int\" class=\"headerlink\" title=\"func Shuffle(n int, swap func(i, j int))\"></a>func Shuffle(n int, swap func(i, j int))</h3><h3 id=\"func-Uint32-uint32\"><a href=\"#func-Uint32-uint32\" class=\"headerlink\" title=\"func Uint32() uint32\"></a>func Uint32() uint32</h3><h3 id=\"func-Uint64-uint64\"><a href=\"#func-Uint64-uint64\" class=\"headerlink\" title=\"func Uint64() uint64\"></a>func Uint64() uint64</h3><h2 id=\"type-Rand\"><a href=\"#type-Rand\" class=\"headerlink\" title=\"type Rand\"></a>type Rand</h2><h3 id=\"func-New-src-Source-Rand\"><a href=\"#func-New-src-Source-Rand\" class=\"headerlink\" title=\"func New(src Source) *Rand\"></a>func New(src Source) *Rand</h3><h3 id=\"func-r-Rand-ExpFloat64-float64\"><a href=\"#func-r-Rand-ExpFloat64-float64\" class=\"headerlink\" title=\"func (r *Rand) ExpFloat64() float64\"></a>func (r *Rand) ExpFloat64() float64</h3><h3 id=\"func-r-Rand-Float32-float32\"><a href=\"#func-r-Rand-Float32-float32\" class=\"headerlink\" title=\"func (r *Rand) Float32() float32\"></a>func (r *Rand) Float32() float32</h3><h3 id=\"func-r-Rand-Float64-float64\"><a href=\"#func-r-Rand-Float64-float64\" class=\"headerlink\" title=\"func (r *Rand) Float64() float64\"></a>func (r *Rand) Float64() float64</h3><h3 id=\"func-r-Rand-Int-int\"><a href=\"#func-r-Rand-Int-int\" class=\"headerlink\" title=\"func (r *Rand) Int() int\"></a>func (r *Rand) Int() int</h3><h3 id=\"func-r-Rand-Int31-int32\"><a href=\"#func-r-Rand-Int31-int32\" class=\"headerlink\" title=\"func (r *Rand) Int31() int32\"></a>func (r *Rand) Int31() int32</h3><h3 id=\"func-r-Rand-Int31n-n-int32-int32\"><a href=\"#func-r-Rand-Int31n-n-int32-int32\" class=\"headerlink\" title=\"func (r *Rand) Int31n(n int32) int32\"></a>func (r *Rand) Int31n(n int32) int32</h3><h3 id=\"func-r-Rand-Int63-int64\"><a href=\"#func-r-Rand-Int63-int64\" class=\"headerlink\" title=\"func (r *Rand) Int63() int64\"></a>func (r *Rand) Int63() int64</h3><h3 id=\"func-r-Rand-Int63n-n-int64-int64\"><a href=\"#func-r-Rand-Int63n-n-int64-int64\" class=\"headerlink\" title=\"func (r *Rand) Int63n(n int64) int64\"></a>func (r *Rand) Int63n(n int64) int64</h3><h3 id=\"func-r-Rand-Intn-n-int-int\"><a href=\"#func-r-Rand-Intn-n-int-int\" class=\"headerlink\" title=\"func (r *Rand) Intn(n int) int\"></a>func (r *Rand) Intn(n int) int</h3><h3 id=\"func-r-Rand-NormFloat64-float64\"><a href=\"#func-r-Rand-NormFloat64-float64\" class=\"headerlink\" title=\"func (r *Rand) NormFloat64() float64\"></a>func (r *Rand) NormFloat64() float64</h3><h3 id=\"func-r-Rand-Perm-n-int-int\"><a href=\"#func-r-Rand-Perm-n-int-int\" class=\"headerlink\" title=\"func (r *Rand) Perm(n int) []int\"></a>func (r *Rand) Perm(n int) []int</h3><h3 id=\"func-r-Rand-Read-p-byte-n-int-err-error\"><a href=\"#func-r-Rand-Read-p-byte-n-int-err-error\" class=\"headerlink\" title=\"func (r *Rand) Read(p []byte) (n int, err error)\"></a>func (r *Rand) Read(p []byte) (n int, err error)</h3><h3 id=\"func-r-Rand-Seed-seed-int64\"><a href=\"#func-r-Rand-Seed-seed-int64\" class=\"headerlink\" title=\"func (r *Rand) Seed(seed int64)\"></a>func (r *Rand) Seed(seed int64)</h3><p>Seed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。</p>\n<h3 id=\"func-r-Rand-Shuffle-n-int-swap-func-i-j-int\"><a href=\"#func-r-Rand-Shuffle-n-int-swap-func-i-j-int\" class=\"headerlink\" title=\"func (r *Rand) Shuffle(n int, swap func(i, j int))\"></a>func (r *Rand) Shuffle(n int, swap func(i, j int))</h3><h3 id=\"func-r-Rand-Uint32-uint32\"><a href=\"#func-r-Rand-Uint32-uint32\" class=\"headerlink\" title=\"func (r *Rand) Uint32() uint32\"></a>func (r *Rand) Uint32() uint32</h3><h3 id=\"func-r-Rand-Uint64-uint64\"><a href=\"#func-r-Rand-Uint64-uint64\" class=\"headerlink\" title=\"func (r *Rand) Uint64() uint64\"></a>func (r *Rand) Uint64() uint64</h3><h2 id=\"type-Source\"><a href=\"#type-Source\" class=\"headerlink\" title=\"type Source\"></a>type Source</h2><h3 id=\"func-NewSource-seed-int64-Source\"><a href=\"#func-NewSource-seed-int64-Source\" class=\"headerlink\" title=\"func NewSource(seed int64) Source\"></a>func NewSource(seed int64) Source</h3><p>NewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">randomSource :&#x3D; NewSource(time.Now().UnixNano())\nrandSeed :&#x3D; New(randomSource) &#x2F;&#x2F;这时候就可以使用rand的method\nrandomInt :&#x3D; randSeed.Intn(300)&#x2F;&#x2F;[0,300)的整数\n</code></pre>\n\n\n<h2 id=\"type-Source64\"><a href=\"#type-Source64\" class=\"headerlink\" title=\"type Source64\"></a>type Source64</h2><p>Source64是一个也可以直接生成[0, 1&lt;&lt;64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。<br>Source64的结构</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Source64 interface &#123;\n    Source\n    Uint64() uint64\n&#125;</code></pre>\n\n<h2 id=\"type-Zipf\"><a href=\"#type-Zipf\" class=\"headerlink\" title=\"type Zipf\"></a>type Zipf</h2><h3 id=\"func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf\"><a href=\"#func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf\" class=\"headerlink\" title=\"func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf\"></a>func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf</h3><h3 id=\"func-z-Zipf-Uint64-uint64\"><a href=\"#func-z-Zipf-Uint64-uint64\" class=\"headerlink\" title=\"func (z *Zipf) Uint64() uint64\"></a>func (z *Zipf) Uint64() uint64</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-tar\"><a href=\"#1-tar\" class=\"headerlink\" title=\"1. tar\"></a>1. tar</h1><h2 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">const (\n  &#x2F;&#x2F; Type &#39;0&#39; indicates a regular file.\n  TypeReg  &#x3D; &#39;0&#39;\n  TypeRegA &#x3D; &#39;\\x00&#39; &#x2F;&#x2F; Deprecated: Use TypeReg instead.\n\n  &#x2F;&#x2F; Type &#39;1&#39; to &#39;6&#39; are header-only flags and may not have a data body.\n  TypeLink    &#x3D; &#39;1&#39; &#x2F;&#x2F; Hard link\n  TypeSymlink &#x3D; &#39;2&#39; &#x2F;&#x2F; Symbolic link\n  TypeChar    &#x3D; &#39;3&#39; &#x2F;&#x2F; Character device node\n  TypeBlock   &#x3D; &#39;4&#39; &#x2F;&#x2F; Block device node\n  TypeDir     &#x3D; &#39;5&#39; &#x2F;&#x2F; Directory\n  TypeFifo    &#x3D; &#39;6&#39; &#x2F;&#x2F; FIFO node\n\n  &#x2F;&#x2F; Type &#39;7&#39; is reserved.\n  TypeCont &#x3D; &#39;7&#39;\n\n  &#x2F;&#x2F; Type &#39;x&#39; is used by the PAX format to store key-value records that\n  &#x2F;&#x2F; are only relevant to the next file.\n  &#x2F;&#x2F; This package transparently handles these types.\n  TypeXHeader &#x3D; &#39;x&#39;\n\n  &#x2F;&#x2F; Type &#39;g&#39; is used by the PAX format to store key-value records that\n  &#x2F;&#x2F; are relevant to all subsequent files.\n  &#x2F;&#x2F; This package only supports parsing and composing such headers,\n  &#x2F;&#x2F; but does not currently support persisting the global state across files.\n  TypeXGlobalHeader &#x3D; &#39;g&#39;\n\n  &#x2F;&#x2F; Type &#39;S&#39; indicates a sparse file in the GNU format.\n  TypeGNUSparse &#x3D; &#39;S&#39;\n\n  &#x2F;&#x2F; Types &#39;L&#39; and &#39;K&#39; are used by the GNU format for a meta file\n  &#x2F;&#x2F; used to store the path or link name for the next file.\n  &#x2F;&#x2F; This package transparently handles these types.\n  TypeGNULongName &#x3D; &#39;L&#39;\n  TypeGNULongLink &#x3D; &#39;K&#39;\n)</code></pre>\n\n<h2 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var (\n  ErrHeader          &#x3D; errors.New(&quot;archive&#x2F;tar: invalid tar header&quot;)\n  ErrWriteTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: write too long&quot;)\n  ErrFieldTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: header field too long&quot;)\n  ErrWriteAfterClose &#x3D; errors.New(&quot;archive&#x2F;tar: write after close&quot;)\n)</code></pre>\n\n<h2 id=\"type-Format\"><a href=\"#type-Format\" class=\"headerlink\" title=\"type Format\"></a>type Format</h2><h3 id=\"func-f-Format-String-string\"><a href=\"#func-f-Format-String-string\" class=\"headerlink\" title=\"func (f Format) String() string\"></a>func (f Format) String() string</h3><h2 id=\"type-Header\"><a href=\"#type-Header\" class=\"headerlink\" title=\"type Header\"></a>type Header</h2><h3 id=\"func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error\"><a href=\"#func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error\" class=\"headerlink\" title=\"func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)\"></a>func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)</h3><h3 id=\"func-h-Header-FileInfo-fs-FileInfo\"><a href=\"#func-h-Header-FileInfo-fs-FileInfo\" class=\"headerlink\" title=\"func (h *Header) FileInfo() fs.FileInfo\"></a>func (h *Header) FileInfo() fs.FileInfo</h3><h2 id=\"type-Reader\"><a href=\"#type-Reader\" class=\"headerlink\" title=\"type Reader\"></a>type Reader</h2><h3 id=\"func-NewReader-r-io-Reader-Reader\"><a href=\"#func-NewReader-r-io-Reader-Reader\" class=\"headerlink\" title=\"func NewReader(r io.Reader) *Reader\"></a>func NewReader(r io.Reader) *Reader</h3><h3 id=\"func-tr-Reader-Next-Header-error\"><a href=\"#func-tr-Reader-Next-Header-error\" class=\"headerlink\" title=\"func (tr *Reader) Next() (*Header, error)\"></a>func (tr *Reader) Next() (*Header, error)</h3><h3 id=\"func-tr-Reader-Read-b-byte-int-error\"><a href=\"#func-tr-Reader-Read-b-byte-int-error\" class=\"headerlink\" title=\"func (tr *Reader) Read(b []byte) (int, error)\"></a>func (tr *Reader) Read(b []byte) (int, error)</h3><h2 id=\"type-Writer\"><a href=\"#type-Writer\" class=\"headerlink\" title=\"type Writer\"></a>type Writer</h2><h3 id=\"func-NewWriter-w-io-Writer-Writer\"><a href=\"#func-NewWriter-w-io-Writer-Writer\" class=\"headerlink\" title=\"func NewWriter(w io.Writer) *Writer\"></a>func NewWriter(w io.Writer) *Writer</h3><h3 id=\"func-tw-Writer-Close-error\"><a href=\"#func-tw-Writer-Close-error\" class=\"headerlink\" title=\"func (tw *Writer) Close() error\"></a>func (tw *Writer) Close() error</h3><h3 id=\"func-tw-Writer-Flush-error\"><a href=\"#func-tw-Writer-Flush-error\" class=\"headerlink\" title=\"func (tw *Writer) Flush() error\"></a>func (tw *Writer) Flush() error</h3><h3 id=\"func-tw-Writer-Write-b-byte-int-error\"><a href=\"#func-tw-Writer-Write-b-byte-int-error\" class=\"headerlink\" title=\"func (tw *Writer) Write(b []byte) (int, error)\"></a>func (tw *Writer) Write(b []byte) (int, error)</h3><h3 id=\"func-tw-Writer-WriteHeader-hdr-Header-error\"><a href=\"#func-tw-Writer-WriteHeader-hdr-Header-error\" class=\"headerlink\" title=\"func (tw *Writer) WriteHeader(hdr *Header) error\"></a>func (tw *Writer) WriteHeader(hdr *Header) error</h3><h1 id=\"2-zip\"><a href=\"#2-zip\" class=\"headerlink\" title=\"2. zip\"></a>2. zip</h1><h2 id=\"Constants-1\"><a href=\"#Constants-1\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">const (\n  Store   uint16 &#x3D; 0 &#x2F;&#x2F; no compression\n  Deflate uint16 &#x3D; 8 &#x2F;&#x2F; DEFLATE compressed\n)</code></pre>\n\n<h2 id=\"Variables-1\"><a href=\"#Variables-1\" class=\"headerlink\" title=\"Variables\"></a>Variables</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var (\n  ErrFormat    &#x3D; errors.New(&quot;zip: not a valid zip file&quot;)\n  ErrAlgorithm &#x3D; errors.New(&quot;zip: unsupported compression algorithm&quot;)\n  ErrChecksum  &#x3D; errors.New(&quot;zip: checksum error&quot;)\n)\n</code></pre>\n\n<h3 id=\"func-RegisterCompressor-method-uint16-comp-Compressor\"><a href=\"#func-RegisterCompressor-method-uint16-comp-Compressor\" class=\"headerlink\" title=\"func RegisterCompressor(method uint16, comp Compressor)\"></a>func RegisterCompressor(method uint16, comp Compressor)</h3><h3 id=\"func-RegisterDecompressor-method-uint16-dcomp-Decompressor\"><a href=\"#func-RegisterDecompressor-method-uint16-dcomp-Decompressor\" class=\"headerlink\" title=\"func RegisterDecompressor(method uint16, dcomp Decompressor)\"></a>func RegisterDecompressor(method uint16, dcomp Decompressor)</h3><h2 id=\"type-Compressor\"><a href=\"#type-Compressor\" class=\"headerlink\" title=\"type Compressor\"></a>type Compressor</h2><h2 id=\"type-Decompressor\"><a href=\"#type-Decompressor\" class=\"headerlink\" title=\"type Decompressor\"></a>type Decompressor</h2><h2 id=\"type-File\"><a href=\"#type-File\" class=\"headerlink\" title=\"type File\"></a>type File</h2><h3 id=\"func-f-File-DataOffset-offset-int64-err-error\"><a href=\"#func-f-File-DataOffset-offset-int64-err-error\" class=\"headerlink\" title=\"func (f *File) DataOffset() (offset int64, err error)\"></a>func (f *File) DataOffset() (offset int64, err error)</h3><h3 id=\"func-f-File-Open-io-ReadCloser-error\"><a href=\"#func-f-File-Open-io-ReadCloser-error\" class=\"headerlink\" title=\"func (f *File) Open() (io.ReadCloser, error)\"></a>func (f *File) Open() (io.ReadCloser, error)</h3><h3 id=\"func-f-File-OpenRaw-io-Reader-error\"><a href=\"#func-f-File-OpenRaw-io-Reader-error\" class=\"headerlink\" title=\"func (f *File) OpenRaw() (io.Reader, error)\"></a>func (f *File) OpenRaw() (io.Reader, error)</h3><h2 id=\"type-FileHeader\"><a href=\"#type-FileHeader\" class=\"headerlink\" title=\"type FileHeader\"></a>type FileHeader</h2><h3 id=\"func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error\"><a href=\"#func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error\" class=\"headerlink\" title=\"func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)\"></a>func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</h3><h3 id=\"func-h-FileHeader-FileInfo-fs-FileInfo\"><a href=\"#func-h-FileHeader-FileInfo-fs-FileInfo\" class=\"headerlink\" title=\"func (h *FileHeader) FileInfo() fs.FileInfo\"></a>func (h *FileHeader) FileInfo() fs.FileInfo</h3><h3 id=\"func-h-FileHeader-ModTime-time-TimeDEPRECATED\"><a href=\"#func-h-FileHeader-ModTime-time-TimeDEPRECATED\" class=\"headerlink\" title=\"func (h *FileHeader) ModTime() time.TimeDEPRECATED\"></a>func (h *FileHeader) ModTime() time.TimeDEPRECATED</h3><h3 id=\"func-h-FileHeader-Mode-mode-fs-FileMode\"><a href=\"#func-h-FileHeader-Mode-mode-fs-FileMode\" class=\"headerlink\" title=\"func (h *FileHeader) Mode() (mode fs.FileMode)\"></a>func (h *FileHeader) Mode() (mode fs.FileMode)</h3><h3 id=\"func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED\"><a href=\"#func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED\" class=\"headerlink\" title=\"func (h *FileHeader) SetModTime(t time.Time)DEPRECATED\"></a>func (h *FileHeader) SetModTime(t time.Time)DEPRECATED</h3><h3 id=\"func-h-FileHeader-SetMode-mode-fs-FileMode\"><a href=\"#func-h-FileHeader-SetMode-mode-fs-FileMode\" class=\"headerlink\" title=\"func (h *FileHeader) SetMode(mode fs.FileMode)\"></a>func (h *FileHeader) SetMode(mode fs.FileMode)</h3><h2 id=\"type-ReadCloser\"><a href=\"#type-ReadCloser\" class=\"headerlink\" title=\"type ReadCloser\"></a>type ReadCloser</h2><h3 id=\"func-OpenReader-name-string-ReadCloser-error\"><a href=\"#func-OpenReader-name-string-ReadCloser-error\" class=\"headerlink\" title=\"func OpenReader(name string) (*ReadCloser, error)\"></a>func OpenReader(name string) (*ReadCloser, error)</h3><h3 id=\"func-rc-ReadCloser-Close-error\"><a href=\"#func-rc-ReadCloser-Close-error\" class=\"headerlink\" title=\"func (rc *ReadCloser) Close() error\"></a>func (rc *ReadCloser) Close() error</h3><h2 id=\"type-Reader-1\"><a href=\"#type-Reader-1\" class=\"headerlink\" title=\"type Reader\"></a>type Reader</h2><h3 id=\"func-NewReader-r-io-ReaderAt-size-int64-Reader-error\"><a href=\"#func-NewReader-r-io-ReaderAt-size-int64-Reader-error\" class=\"headerlink\" title=\"func NewReader(r io.ReaderAt, size int64) (*Reader, error)\"></a>func NewReader(r io.ReaderAt, size int64) (*Reader, error)</h3><h3 id=\"func-r-Reader-Open-name-string-fs-File-error\"><a href=\"#func-r-Reader-Open-name-string-fs-File-error\" class=\"headerlink\" title=\"func (r *Reader) Open(name string) (fs.File, error)\"></a>func (r *Reader) Open(name string) (fs.File, error)</h3><h3 id=\"func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor\"><a href=\"#func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor\" class=\"headerlink\" title=\"func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)\"></a>func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</h3><h2 id=\"type-Writer-1\"><a href=\"#type-Writer-1\" class=\"headerlink\" title=\"type Writer\"></a>type Writer</h2><h3 id=\"func-NewWriter-w-io-Writer-Writer-1\"><a href=\"#func-NewWriter-w-io-Writer-Writer-1\" class=\"headerlink\" title=\"func NewWriter(w io.Writer) *Writer\"></a>func NewWriter(w io.Writer) *Writer</h3><h3 id=\"func-w-Writer-Close-error\"><a href=\"#func-w-Writer-Close-error\" class=\"headerlink\" title=\"func (w *Writer) Close() error\"></a>func (w *Writer) Close() error</h3><h3 id=\"func-w-Writer-Copy-f-File-error\"><a href=\"#func-w-Writer-Copy-f-File-error\" class=\"headerlink\" title=\"func (w *Writer) Copy(f *File) error\"></a>func (w *Writer) Copy(f *File) error</h3><h3 id=\"func-w-Writer-Create-name-string-io-Writer-error\"><a href=\"#func-w-Writer-Create-name-string-io-Writer-error\" class=\"headerlink\" title=\"func (w *Writer) Create(name string) (io.Writer, error)\"></a>func (w *Writer) Create(name string) (io.Writer, error)</h3><h3 id=\"func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error\"><a href=\"#func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error\" class=\"headerlink\" title=\"func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)\"></a>func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)</h3><h3 id=\"func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error\"><a href=\"#func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error\" class=\"headerlink\" title=\"func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)\"></a>func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)</h3><h3 id=\"func-w-Writer-Flush-error\"><a href=\"#func-w-Writer-Flush-error\" class=\"headerlink\" title=\"func (w *Writer) Flush() error\"></a>func (w *Writer) Flush() error</h3><h3 id=\"func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor\"><a href=\"#func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor\" class=\"headerlink\" title=\"func (w *Writer) RegisterCompressor(method uint16, comp Compressor)\"></a>func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</h3><h3 id=\"func-w-Writer-SetComment-comment-string-error\"><a href=\"#func-w-Writer-SetComment-comment-string-error\" class=\"headerlink\" title=\"func (w *Writer) SetComment(comment string) error\"></a>func (w *Writer) SetComment(comment string) error</h3><h3 id=\"func-w-Writer-SetOffset-n-int64\"><a href=\"#func-w-Writer-SetOffset-n-int64\" class=\"headerlink\" title=\"func (w *Writer) SetOffset(n int64)\"></a>func (w *Writer) SetOffset(n int64)</h3><h1 id=\"rand\"><a href=\"#rand\" class=\"headerlink\" title=\"rand\"></a>rand</h1><h2 id=\"function-not-method-of-rand\"><a href=\"#function-not-method-of-rand\" class=\"headerlink\" title=\"function not method of rand\"></a>function not method of rand</h2><h3 id=\"func-ExpFloat64-float64\"><a href=\"#func-ExpFloat64-float64\" class=\"headerlink\" title=\"func ExpFloat64() float64\"></a>func ExpFloat64() float64</h3><h3 id=\"func-Float32-float32\"><a href=\"#func-Float32-float32\" class=\"headerlink\" title=\"func Float32() float32\"></a>func Float32() float32</h3><h3 id=\"func-Float64-float64\"><a href=\"#func-Float64-float64\" class=\"headerlink\" title=\"func Float64() float64\"></a>func Float64() float64</h3><h3 id=\"func-Int-int\"><a href=\"#func-Int-int\" class=\"headerlink\" title=\"func Int() int\"></a>func Int() int</h3><h3 id=\"func-Int31-int32\"><a href=\"#func-Int31-int32\" class=\"headerlink\" title=\"func Int31() int32\"></a>func Int31() int32</h3><h3 id=\"func-Int31n-n-int32-int32\"><a href=\"#func-Int31n-n-int32-int32\" class=\"headerlink\" title=\"func Int31n(n int32) int32\"></a>func Int31n(n int32) int32</h3><h3 id=\"func-Int63-int64\"><a href=\"#func-Int63-int64\" class=\"headerlink\" title=\"func Int63() int64\"></a>func Int63() int64</h3><h3 id=\"func-Int63n-n-int64-int64\"><a href=\"#func-Int63n-n-int64-int64\" class=\"headerlink\" title=\"func Int63n(n int64) int64\"></a>func Int63n(n int64) int64</h3><h3 id=\"func-Intn-n-int-int\"><a href=\"#func-Intn-n-int-int\" class=\"headerlink\" title=\"func Intn(n int) int\"></a>func Intn(n int) int</h3><h3 id=\"func-NormFloat64-float64\"><a href=\"#func-NormFloat64-float64\" class=\"headerlink\" title=\"func NormFloat64() float64\"></a>func NormFloat64() float64</h3><h3 id=\"func-Perm-n-int-int\"><a href=\"#func-Perm-n-int-int\" class=\"headerlink\" title=\"func Perm(n int) []int\"></a>func Perm(n int) []int</h3><h3 id=\"func-Read-p-byte-n-int-err-error\"><a href=\"#func-Read-p-byte-n-int-err-error\" class=\"headerlink\" title=\"func Read(p []byte) (n int, err error)\"></a>func Read(p []byte) (n int, err error)</h3><h3 id=\"func-Seed-seed-int64\"><a href=\"#func-Seed-seed-int64\" class=\"headerlink\" title=\"func Seed(seed int64)\"></a>func Seed(seed int64)</h3><h3 id=\"func-Shuffle-n-int-swap-func-i-j-int\"><a href=\"#func-Shuffle-n-int-swap-func-i-j-int\" class=\"headerlink\" title=\"func Shuffle(n int, swap func(i, j int))\"></a>func Shuffle(n int, swap func(i, j int))</h3><h3 id=\"func-Uint32-uint32\"><a href=\"#func-Uint32-uint32\" class=\"headerlink\" title=\"func Uint32() uint32\"></a>func Uint32() uint32</h3><h3 id=\"func-Uint64-uint64\"><a href=\"#func-Uint64-uint64\" class=\"headerlink\" title=\"func Uint64() uint64\"></a>func Uint64() uint64</h3><h2 id=\"type-Rand\"><a href=\"#type-Rand\" class=\"headerlink\" title=\"type Rand\"></a>type Rand</h2><h3 id=\"func-New-src-Source-Rand\"><a href=\"#func-New-src-Source-Rand\" class=\"headerlink\" title=\"func New(src Source) *Rand\"></a>func New(src Source) *Rand</h3><h3 id=\"func-r-Rand-ExpFloat64-float64\"><a href=\"#func-r-Rand-ExpFloat64-float64\" class=\"headerlink\" title=\"func (r *Rand) ExpFloat64() float64\"></a>func (r *Rand) ExpFloat64() float64</h3><h3 id=\"func-r-Rand-Float32-float32\"><a href=\"#func-r-Rand-Float32-float32\" class=\"headerlink\" title=\"func (r *Rand) Float32() float32\"></a>func (r *Rand) Float32() float32</h3><h3 id=\"func-r-Rand-Float64-float64\"><a href=\"#func-r-Rand-Float64-float64\" class=\"headerlink\" title=\"func (r *Rand) Float64() float64\"></a>func (r *Rand) Float64() float64</h3><h3 id=\"func-r-Rand-Int-int\"><a href=\"#func-r-Rand-Int-int\" class=\"headerlink\" title=\"func (r *Rand) Int() int\"></a>func (r *Rand) Int() int</h3><h3 id=\"func-r-Rand-Int31-int32\"><a href=\"#func-r-Rand-Int31-int32\" class=\"headerlink\" title=\"func (r *Rand) Int31() int32\"></a>func (r *Rand) Int31() int32</h3><h3 id=\"func-r-Rand-Int31n-n-int32-int32\"><a href=\"#func-r-Rand-Int31n-n-int32-int32\" class=\"headerlink\" title=\"func (r *Rand) Int31n(n int32) int32\"></a>func (r *Rand) Int31n(n int32) int32</h3><h3 id=\"func-r-Rand-Int63-int64\"><a href=\"#func-r-Rand-Int63-int64\" class=\"headerlink\" title=\"func (r *Rand) Int63() int64\"></a>func (r *Rand) Int63() int64</h3><h3 id=\"func-r-Rand-Int63n-n-int64-int64\"><a href=\"#func-r-Rand-Int63n-n-int64-int64\" class=\"headerlink\" title=\"func (r *Rand) Int63n(n int64) int64\"></a>func (r *Rand) Int63n(n int64) int64</h3><h3 id=\"func-r-Rand-Intn-n-int-int\"><a href=\"#func-r-Rand-Intn-n-int-int\" class=\"headerlink\" title=\"func (r *Rand) Intn(n int) int\"></a>func (r *Rand) Intn(n int) int</h3><h3 id=\"func-r-Rand-NormFloat64-float64\"><a href=\"#func-r-Rand-NormFloat64-float64\" class=\"headerlink\" title=\"func (r *Rand) NormFloat64() float64\"></a>func (r *Rand) NormFloat64() float64</h3><h3 id=\"func-r-Rand-Perm-n-int-int\"><a href=\"#func-r-Rand-Perm-n-int-int\" class=\"headerlink\" title=\"func (r *Rand) Perm(n int) []int\"></a>func (r *Rand) Perm(n int) []int</h3><h3 id=\"func-r-Rand-Read-p-byte-n-int-err-error\"><a href=\"#func-r-Rand-Read-p-byte-n-int-err-error\" class=\"headerlink\" title=\"func (r *Rand) Read(p []byte) (n int, err error)\"></a>func (r *Rand) Read(p []byte) (n int, err error)</h3><h3 id=\"func-r-Rand-Seed-seed-int64\"><a href=\"#func-r-Rand-Seed-seed-int64\" class=\"headerlink\" title=\"func (r *Rand) Seed(seed int64)\"></a>func (r *Rand) Seed(seed int64)</h3><p>Seed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。</p>\n<h3 id=\"func-r-Rand-Shuffle-n-int-swap-func-i-j-int\"><a href=\"#func-r-Rand-Shuffle-n-int-swap-func-i-j-int\" class=\"headerlink\" title=\"func (r *Rand) Shuffle(n int, swap func(i, j int))\"></a>func (r *Rand) Shuffle(n int, swap func(i, j int))</h3><h3 id=\"func-r-Rand-Uint32-uint32\"><a href=\"#func-r-Rand-Uint32-uint32\" class=\"headerlink\" title=\"func (r *Rand) Uint32() uint32\"></a>func (r *Rand) Uint32() uint32</h3><h3 id=\"func-r-Rand-Uint64-uint64\"><a href=\"#func-r-Rand-Uint64-uint64\" class=\"headerlink\" title=\"func (r *Rand) Uint64() uint64\"></a>func (r *Rand) Uint64() uint64</h3><h2 id=\"type-Source\"><a href=\"#type-Source\" class=\"headerlink\" title=\"type Source\"></a>type Source</h2><h3 id=\"func-NewSource-seed-int64-Source\"><a href=\"#func-NewSource-seed-int64-Source\" class=\"headerlink\" title=\"func NewSource(seed int64) Source\"></a>func NewSource(seed int64) Source</h3><p>NewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">randomSource :&#x3D; NewSource(time.Now().UnixNano())\nrandSeed :&#x3D; New(randomSource) &#x2F;&#x2F;这时候就可以使用rand的method\nrandomInt :&#x3D; randSeed.Intn(300)&#x2F;&#x2F;[0,300)的整数\n</code></pre>\n\n\n<h2 id=\"type-Source64\"><a href=\"#type-Source64\" class=\"headerlink\" title=\"type Source64\"></a>type Source64</h2><p>Source64是一个也可以直接生成[0, 1&lt;&lt;64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。<br>Source64的结构</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Source64 interface &#123;\n    Source\n    Uint64() uint64\n&#125;</code></pre>\n\n<h2 id=\"type-Zipf\"><a href=\"#type-Zipf\" class=\"headerlink\" title=\"type Zipf\"></a>type Zipf</h2><h3 id=\"func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf\"><a href=\"#func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf\" class=\"headerlink\" title=\"func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf\"></a>func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf</h3><h3 id=\"func-z-Zipf-Uint64-uint64\"><a href=\"#func-z-Zipf-Uint64-uint64\" class=\"headerlink\" title=\"func (z *Zipf) Uint64() uint64\"></a>func (z *Zipf) Uint64() uint64</h3>"},{"title":"13.罗马数字转整数","_content":"```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=13 lang=golang\n *\n * [13] 罗马数字转整数\n\n 2. I X C 也是写成从大到小\n 3. 左高位，右低位\n 4. 输入: s = \"MC MX CI V\"\n             1100 1010 101 5\n\t输出: 1994\n\t解释: M = 1000, CM = 900, XC = 90, IV = 4.\n\n\tMMMCCCXXXIII\n\t1000+1000+1000 -100-100-100-10-10-10+1+1+1\n\tCXCIX\n\t100 -10 +100-1+10\n*/\n\n// @lc code=start\nfunc romanToInt(s string) int {\n\n\tvar intSum int\n\tfor i := 0; i < len(s)-1; i++ {\n\t\tif char2Int(string(s[i])) > char2Int(string(s[i+1])) {\n\t\t\tintSum = intSum + char2Int(string(s[i]))\n\t\t} else if char2Int(string(s[i])) < char2Int(string(s[i+1])) {\n\t\t\tintSum = intSum - char2Int(string(s[i]))\n\t\t} else {\n\t\t\tintSum = intSum + char2Int(string(s[i]))\n\t\t}\n\t}\n\tintSum = intSum + char2Int(string(s[len(s)-1]))\n\n\treturn intSum\n\n}\nfunc char2Int(c string) int {\n\tswitch c {\n\tcase \"I\":\n\t\treturn 1\n\tcase \"V\":\n\t\treturn 5\n\tcase \"X\":\n\t\treturn 10\n\tcase \"L\":\n\t\treturn 50\n\tcase \"C\":\n\t\treturn 100\n\tcase \"D\":\n\t\treturn 500\n\tcase \"M\":\n\t\treturn 1000\n\t}\n\tpanic(\"excep I V X L C D M\")\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/13.罗马数字转整数.md","raw":"---\ntitle: 13.罗马数字转整数\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=13 lang=golang\n *\n * [13] 罗马数字转整数\n\n 2. I X C 也是写成从大到小\n 3. 左高位，右低位\n 4. 输入: s = \"MC MX CI V\"\n             1100 1010 101 5\n\t输出: 1994\n\t解释: M = 1000, CM = 900, XC = 90, IV = 4.\n\n\tMMMCCCXXXIII\n\t1000+1000+1000 -100-100-100-10-10-10+1+1+1\n\tCXCIX\n\t100 -10 +100-1+10\n*/\n\n// @lc code=start\nfunc romanToInt(s string) int {\n\n\tvar intSum int\n\tfor i := 0; i < len(s)-1; i++ {\n\t\tif char2Int(string(s[i])) > char2Int(string(s[i+1])) {\n\t\t\tintSum = intSum + char2Int(string(s[i]))\n\t\t} else if char2Int(string(s[i])) < char2Int(string(s[i+1])) {\n\t\t\tintSum = intSum - char2Int(string(s[i]))\n\t\t} else {\n\t\t\tintSum = intSum + char2Int(string(s[i]))\n\t\t}\n\t}\n\tintSum = intSum + char2Int(string(s[len(s)-1]))\n\n\treturn intSum\n\n}\nfunc char2Int(c string) int {\n\tswitch c {\n\tcase \"I\":\n\t\treturn 1\n\tcase \"V\":\n\t\treturn 5\n\tcase \"X\":\n\t\treturn 10\n\tcase \"L\":\n\t\treturn 50\n\tcase \"C\":\n\t\treturn 100\n\tcase \"D\":\n\t\treturn 500\n\tcase \"M\":\n\t\treturn 1000\n\t}\n\tpanic(\"excep I V X L C D M\")\n}\n\n// @lc code=end\n```","slug":"leetcode/13.罗马数字转整数","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5s0019l1db1ebmh8n3","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;13 lang&#x3D;golang\n *\n * [13] 罗马数字转整数\n\n 2. I X C 也是写成从大到小\n 3. 左高位，右低位\n 4. 输入: s &#x3D; &quot;MC MX CI V&quot;\n             1100 1010 101 5\n\t输出: 1994\n\t解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.\n\n\tMMMCCCXXXIII\n\t1000+1000+1000 -100-100-100-10-10-10+1+1+1\n\tCXCIX\n\t100 -10 +100-1+10\n*&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc romanToInt(s string) int &#123;\n\n\tvar intSum int\n\tfor i :&#x3D; 0; i &lt; len(s)-1; i++ &#123;\n\t\tif char2Int(string(s[i])) &gt; char2Int(string(s[i+1])) &#123;\n\t\t\tintSum &#x3D; intSum + char2Int(string(s[i]))\n\t\t&#125; else if char2Int(string(s[i])) &lt; char2Int(string(s[i+1])) &#123;\n\t\t\tintSum &#x3D; intSum - char2Int(string(s[i]))\n\t\t&#125; else &#123;\n\t\t\tintSum &#x3D; intSum + char2Int(string(s[i]))\n\t\t&#125;\n\t&#125;\n\tintSum &#x3D; intSum + char2Int(string(s[len(s)-1]))\n\n\treturn intSum\n\n&#125;\nfunc char2Int(c string) int &#123;\n\tswitch c &#123;\n\tcase &quot;I&quot;:\n\t\treturn 1\n\tcase &quot;V&quot;:\n\t\treturn 5\n\tcase &quot;X&quot;:\n\t\treturn 10\n\tcase &quot;L&quot;:\n\t\treturn 50\n\tcase &quot;C&quot;:\n\t\treturn 100\n\tcase &quot;D&quot;:\n\t\treturn 500\n\tcase &quot;M&quot;:\n\t\treturn 1000\n\t&#125;\n\tpanic(&quot;excep I V X L C D M&quot;)\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;13 lang&#x3D;golang\n *\n * [13] 罗马数字转整数\n\n 2. I X C 也是写成从大到小\n 3. 左高位，右低位\n 4. 输入: s &#x3D; &quot;MC MX CI V&quot;\n             1100 1010 101 5\n\t输出: 1994\n\t解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.\n\n\tMMMCCCXXXIII\n\t1000+1000+1000 -100-100-100-10-10-10+1+1+1\n\tCXCIX\n\t100 -10 +100-1+10\n*&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc romanToInt(s string) int &#123;\n\n\tvar intSum int\n\tfor i :&#x3D; 0; i &lt; len(s)-1; i++ &#123;\n\t\tif char2Int(string(s[i])) &gt; char2Int(string(s[i+1])) &#123;\n\t\t\tintSum &#x3D; intSum + char2Int(string(s[i]))\n\t\t&#125; else if char2Int(string(s[i])) &lt; char2Int(string(s[i+1])) &#123;\n\t\t\tintSum &#x3D; intSum - char2Int(string(s[i]))\n\t\t&#125; else &#123;\n\t\t\tintSum &#x3D; intSum + char2Int(string(s[i]))\n\t\t&#125;\n\t&#125;\n\tintSum &#x3D; intSum + char2Int(string(s[len(s)-1]))\n\n\treturn intSum\n\n&#125;\nfunc char2Int(c string) int &#123;\n\tswitch c &#123;\n\tcase &quot;I&quot;:\n\t\treturn 1\n\tcase &quot;V&quot;:\n\t\treturn 5\n\tcase &quot;X&quot;:\n\t\treturn 10\n\tcase &quot;L&quot;:\n\t\treturn 50\n\tcase &quot;C&quot;:\n\t\treturn 100\n\tcase &quot;D&quot;:\n\t\treturn 500\n\tcase &quot;M&quot;:\n\t\treturn 1000\n\t&#125;\n\tpanic(&quot;excep I V X L C D M&quot;)\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"14.最长公共前缀","_content":"```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n/*\n * @lc app=leetcode.cn id=14 lang=golang\n *\n * [14] 最长公共前缀\n */\n\n// @lc code=start\nfunc longestCommonPrefix(strs []string) string {\n\tsort.Strings(strs)\n\tfmt.Printf(\"min = %s , max = %s\", strs[0], strs[len(strs)-1])\n\n\tminStrs, maxStrs := strs[0], strs[len(strs)-1]\n\tcommonStrs := make([]byte, 0)\n\tfor i := 0; i < len(minStrs); i++ {\n\t\tif minStrs[i] == maxStrs[i] {\n\t\t\tcommonStrs = append(commonStrs, minStrs[i])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(commonStrs)\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/14.最长公共前缀.md","raw":"---\ntitle: 14.最长公共前缀\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n/*\n * @lc app=leetcode.cn id=14 lang=golang\n *\n * [14] 最长公共前缀\n */\n\n// @lc code=start\nfunc longestCommonPrefix(strs []string) string {\n\tsort.Strings(strs)\n\tfmt.Printf(\"min = %s , max = %s\", strs[0], strs[len(strs)-1])\n\n\tminStrs, maxStrs := strs[0], strs[len(strs)-1]\n\tcommonStrs := make([]byte, 0)\n\tfor i := 0; i < len(minStrs); i++ {\n\t\tif minStrs[i] == maxStrs[i] {\n\t\t\tcommonStrs = append(commonStrs, minStrs[i])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(commonStrs)\n}\n\n// @lc code=end\n```","slug":"leetcode/14.最长公共前缀","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5t001dl1db1c1ohsrt","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sort&quot;\n)\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;14 lang&#x3D;golang\n *\n * [14] 最长公共前缀\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc longestCommonPrefix(strs []string) string &#123;\n\tsort.Strings(strs)\n\tfmt.Printf(&quot;min &#x3D; %s , max &#x3D; %s&quot;, strs[0], strs[len(strs)-1])\n\n\tminStrs, maxStrs :&#x3D; strs[0], strs[len(strs)-1]\n\tcommonStrs :&#x3D; make([]byte, 0)\n\tfor i :&#x3D; 0; i &lt; len(minStrs); i++ &#123;\n\t\tif minStrs[i] &#x3D;&#x3D; maxStrs[i] &#123;\n\t\t\tcommonStrs &#x3D; append(commonStrs, minStrs[i])\n\t\t&#125; else &#123;\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n\treturn string(commonStrs)\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sort&quot;\n)\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;14 lang&#x3D;golang\n *\n * [14] 最长公共前缀\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc longestCommonPrefix(strs []string) string &#123;\n\tsort.Strings(strs)\n\tfmt.Printf(&quot;min &#x3D; %s , max &#x3D; %s&quot;, strs[0], strs[len(strs)-1])\n\n\tminStrs, maxStrs :&#x3D; strs[0], strs[len(strs)-1]\n\tcommonStrs :&#x3D; make([]byte, 0)\n\tfor i :&#x3D; 0; i &lt; len(minStrs); i++ &#123;\n\t\tif minStrs[i] &#x3D;&#x3D; maxStrs[i] &#123;\n\t\t\tcommonStrs &#x3D; append(commonStrs, minStrs[i])\n\t\t&#125; else &#123;\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n\treturn string(commonStrs)\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"20.有效的括号","_content":"```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=20 lang=golang\n *\n * [20] 有效的括号\n */\n\n// @lc code=start\ntype (\n\tStack struct {\n\t\ttop    *node\n\t\tlength int\n\t}\n\tnode struct {\n\t\tvalue int\n\t\tprev  *node\n\t}\n)\n\n// Create a new stack\nfunc New() *Stack {\n\treturn &Stack{nil, 0}\n}\n\n// Return the number of items in the stack\nfunc (this *Stack) Len() int {\n\treturn this.length\n}\n\n// View the top item on the stack\nfunc (this *Stack) Peek() int {\n\tif this.length == 0 {\n\t\treturn 0\n\t}\n\treturn this.top.value\n}\n\n// Pop the top item of the stack and return it\nfunc (this *Stack) Pop() int {\n\tif this.length == 0 {\n\t\treturn 0\n\t}\n\n\tn := this.top\n\tthis.top = n.prev\n\tthis.length--\n\treturn n.value\n}\n\n// Push a value onto the top of the stack\nfunc (this *Stack) Push(value int) {\n\tn := &node{value, this.top}\n\tthis.top = n\n\tthis.length++\n}\n\n// 123 {\n// 91  [\n// 40  (\n// 41\t)\n// 93\t]\n// 125\t}\n//主函数\nfunc isValid(s string) bool {\n\tbracket := New()\n\n\tfor _, v := range s {\n\t\tswitch v {\n\t\tcase 123:\n\t\t\tbracket.Push(int(v))\n\t\tcase 91:\n\t\t\tbracket.Push(int(v))\n\t\tcase 40:\n\t\t\tbracket.Push(int(v))\n\t\tcase 41:\n\t\t\ttopValue := bracket.Pop()\n\t\t\tif (int(v) - topValue) != 1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase 93:\n\t\t\ttopValue := bracket.Pop()\n\t\t\tif (int(v) - topValue) != 2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase 125:\n\t\t\ttopValue := bracket.Pop()\n\t\t\tif (int(v) - topValue) != 2 {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t}\n\t}\n\tif bracket.Len() != 0 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/20.有效的括号.md","raw":"---\ntitle: 20.有效的括号\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=20 lang=golang\n *\n * [20] 有效的括号\n */\n\n// @lc code=start\ntype (\n\tStack struct {\n\t\ttop    *node\n\t\tlength int\n\t}\n\tnode struct {\n\t\tvalue int\n\t\tprev  *node\n\t}\n)\n\n// Create a new stack\nfunc New() *Stack {\n\treturn &Stack{nil, 0}\n}\n\n// Return the number of items in the stack\nfunc (this *Stack) Len() int {\n\treturn this.length\n}\n\n// View the top item on the stack\nfunc (this *Stack) Peek() int {\n\tif this.length == 0 {\n\t\treturn 0\n\t}\n\treturn this.top.value\n}\n\n// Pop the top item of the stack and return it\nfunc (this *Stack) Pop() int {\n\tif this.length == 0 {\n\t\treturn 0\n\t}\n\n\tn := this.top\n\tthis.top = n.prev\n\tthis.length--\n\treturn n.value\n}\n\n// Push a value onto the top of the stack\nfunc (this *Stack) Push(value int) {\n\tn := &node{value, this.top}\n\tthis.top = n\n\tthis.length++\n}\n\n// 123 {\n// 91  [\n// 40  (\n// 41\t)\n// 93\t]\n// 125\t}\n//主函数\nfunc isValid(s string) bool {\n\tbracket := New()\n\n\tfor _, v := range s {\n\t\tswitch v {\n\t\tcase 123:\n\t\t\tbracket.Push(int(v))\n\t\tcase 91:\n\t\t\tbracket.Push(int(v))\n\t\tcase 40:\n\t\t\tbracket.Push(int(v))\n\t\tcase 41:\n\t\t\ttopValue := bracket.Pop()\n\t\t\tif (int(v) - topValue) != 1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase 93:\n\t\t\ttopValue := bracket.Pop()\n\t\t\tif (int(v) - topValue) != 2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase 125:\n\t\t\ttopValue := bracket.Pop()\n\t\t\tif (int(v) - topValue) != 2 {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t}\n\t}\n\tif bracket.Len() != 0 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// @lc code=end\n```","slug":"leetcode/20.有效的括号","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5t001fl1db7p718mgy","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;20 lang&#x3D;golang\n *\n * [20] 有效的括号\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\ntype (\n\tStack struct &#123;\n\t\ttop    *node\n\t\tlength int\n\t&#125;\n\tnode struct &#123;\n\t\tvalue int\n\t\tprev  *node\n\t&#125;\n)\n\n&#x2F;&#x2F; Create a new stack\nfunc New() *Stack &#123;\n\treturn &amp;Stack&#123;nil, 0&#125;\n&#125;\n\n&#x2F;&#x2F; Return the number of items in the stack\nfunc (this *Stack) Len() int &#123;\n\treturn this.length\n&#125;\n\n&#x2F;&#x2F; View the top item on the stack\nfunc (this *Stack) Peek() int &#123;\n\tif this.length &#x3D;&#x3D; 0 &#123;\n\t\treturn 0\n\t&#125;\n\treturn this.top.value\n&#125;\n\n&#x2F;&#x2F; Pop the top item of the stack and return it\nfunc (this *Stack) Pop() int &#123;\n\tif this.length &#x3D;&#x3D; 0 &#123;\n\t\treturn 0\n\t&#125;\n\n\tn :&#x3D; this.top\n\tthis.top &#x3D; n.prev\n\tthis.length--\n\treturn n.value\n&#125;\n\n&#x2F;&#x2F; Push a value onto the top of the stack\nfunc (this *Stack) Push(value int) &#123;\n\tn :&#x3D; &amp;node&#123;value, this.top&#125;\n\tthis.top &#x3D; n\n\tthis.length++\n&#125;\n\n&#x2F;&#x2F; 123 &#123;\n&#x2F;&#x2F; 91  [\n&#x2F;&#x2F; 40  (\n&#x2F;&#x2F; 41\t)\n&#x2F;&#x2F; 93\t]\n&#x2F;&#x2F; 125\t&#125;\n&#x2F;&#x2F;主函数\nfunc isValid(s string) bool &#123;\n\tbracket :&#x3D; New()\n\n\tfor _, v :&#x3D; range s &#123;\n\t\tswitch v &#123;\n\t\tcase 123:\n\t\t\tbracket.Push(int(v))\n\t\tcase 91:\n\t\t\tbracket.Push(int(v))\n\t\tcase 40:\n\t\t\tbracket.Push(int(v))\n\t\tcase 41:\n\t\t\ttopValue :&#x3D; bracket.Pop()\n\t\t\tif (int(v) - topValue) !&#x3D; 1 &#123;\n\t\t\t\treturn false\n\t\t\t&#125;\n\t\tcase 93:\n\t\t\ttopValue :&#x3D; bracket.Pop()\n\t\t\tif (int(v) - topValue) !&#x3D; 2 &#123;\n\t\t\t\treturn false\n\t\t\t&#125;\n\t\tcase 125:\n\t\t\ttopValue :&#x3D; bracket.Pop()\n\t\t\tif (int(v) - topValue) !&#x3D; 2 &#123;\n\t\t\t\treturn false\n\t\t\t&#125;\n\n\t\t&#125;\n\t&#125;\n\tif bracket.Len() !&#x3D; 0 &#123;\n\t\treturn false\n\t&#125;\n\n\treturn true\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;20 lang&#x3D;golang\n *\n * [20] 有效的括号\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\ntype (\n\tStack struct &#123;\n\t\ttop    *node\n\t\tlength int\n\t&#125;\n\tnode struct &#123;\n\t\tvalue int\n\t\tprev  *node\n\t&#125;\n)\n\n&#x2F;&#x2F; Create a new stack\nfunc New() *Stack &#123;\n\treturn &amp;Stack&#123;nil, 0&#125;\n&#125;\n\n&#x2F;&#x2F; Return the number of items in the stack\nfunc (this *Stack) Len() int &#123;\n\treturn this.length\n&#125;\n\n&#x2F;&#x2F; View the top item on the stack\nfunc (this *Stack) Peek() int &#123;\n\tif this.length &#x3D;&#x3D; 0 &#123;\n\t\treturn 0\n\t&#125;\n\treturn this.top.value\n&#125;\n\n&#x2F;&#x2F; Pop the top item of the stack and return it\nfunc (this *Stack) Pop() int &#123;\n\tif this.length &#x3D;&#x3D; 0 &#123;\n\t\treturn 0\n\t&#125;\n\n\tn :&#x3D; this.top\n\tthis.top &#x3D; n.prev\n\tthis.length--\n\treturn n.value\n&#125;\n\n&#x2F;&#x2F; Push a value onto the top of the stack\nfunc (this *Stack) Push(value int) &#123;\n\tn :&#x3D; &amp;node&#123;value, this.top&#125;\n\tthis.top &#x3D; n\n\tthis.length++\n&#125;\n\n&#x2F;&#x2F; 123 &#123;\n&#x2F;&#x2F; 91  [\n&#x2F;&#x2F; 40  (\n&#x2F;&#x2F; 41\t)\n&#x2F;&#x2F; 93\t]\n&#x2F;&#x2F; 125\t&#125;\n&#x2F;&#x2F;主函数\nfunc isValid(s string) bool &#123;\n\tbracket :&#x3D; New()\n\n\tfor _, v :&#x3D; range s &#123;\n\t\tswitch v &#123;\n\t\tcase 123:\n\t\t\tbracket.Push(int(v))\n\t\tcase 91:\n\t\t\tbracket.Push(int(v))\n\t\tcase 40:\n\t\t\tbracket.Push(int(v))\n\t\tcase 41:\n\t\t\ttopValue :&#x3D; bracket.Pop()\n\t\t\tif (int(v) - topValue) !&#x3D; 1 &#123;\n\t\t\t\treturn false\n\t\t\t&#125;\n\t\tcase 93:\n\t\t\ttopValue :&#x3D; bracket.Pop()\n\t\t\tif (int(v) - topValue) !&#x3D; 2 &#123;\n\t\t\t\treturn false\n\t\t\t&#125;\n\t\tcase 125:\n\t\t\ttopValue :&#x3D; bracket.Pop()\n\t\t\tif (int(v) - topValue) !&#x3D; 2 &#123;\n\t\t\t\treturn false\n\t\t\t&#125;\n\n\t\t&#125;\n\t&#125;\n\tif bracket.Len() !&#x3D; 0 &#123;\n\t\treturn false\n\t&#125;\n\n\treturn true\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"21.合并两个有序链表","_content":"```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=21 lang=golang\n *\n * [21] 合并两个有序链表\n */\n\n// @lc code=start\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n\n\tif list1 == nil {\n\n\t\treturn list2\n\t}\n\tif list2 == nil {\n\t\treturn list1\n\t}\n\thead := &ListNode{0, nil}\n\tpre := head\n\tc1 := list1\n\tc2 := list2\n\n\tfor {\n\t\tif c1.Val > c2.Val {\n\t\t\tpre.Next = c2\n\t\t\tc2 = c2.Next\n\t\t\tpre = pre.Next\n\t\t\t// pre.Next = c1\n\t\t\t// c1 = c1.Next\n\t\t\t// pre = pre.Next\n\t\t} else if c1.Val <= c2.Val {\n\t\t\tpre.Next = c1\n\t\t\tc1 = c1.Next\n\t\t\tpre = pre.Next\n\t\t\t// pre.Next = c2\n\t\t\t// c2 = c2.Next\n\t\t\t// pre = pre.Next\n\t\t}\n\t\tif c1 == nil {\n\t\t\tpre.Next = c2\n\t\t\tbreak\n\t\t}\n\t\tif c2 == nil {\n\t\t\tpre.Next = c1\n\n\t\t\tbreak\n\t\t}\n\n\t}\n\thead = head.Next\n\treturn head\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/21.合并两个有序链表.md","raw":"---\ntitle: 21.合并两个有序链表\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=21 lang=golang\n *\n * [21] 合并两个有序链表\n */\n\n// @lc code=start\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n\n\tif list1 == nil {\n\n\t\treturn list2\n\t}\n\tif list2 == nil {\n\t\treturn list1\n\t}\n\thead := &ListNode{0, nil}\n\tpre := head\n\tc1 := list1\n\tc2 := list2\n\n\tfor {\n\t\tif c1.Val > c2.Val {\n\t\t\tpre.Next = c2\n\t\t\tc2 = c2.Next\n\t\t\tpre = pre.Next\n\t\t\t// pre.Next = c1\n\t\t\t// c1 = c1.Next\n\t\t\t// pre = pre.Next\n\t\t} else if c1.Val <= c2.Val {\n\t\t\tpre.Next = c1\n\t\t\tc1 = c1.Next\n\t\t\tpre = pre.Next\n\t\t\t// pre.Next = c2\n\t\t\t// c2 = c2.Next\n\t\t\t// pre = pre.Next\n\t\t}\n\t\tif c1 == nil {\n\t\t\tpre.Next = c2\n\t\t\tbreak\n\t\t}\n\t\tif c2 == nil {\n\t\t\tpre.Next = c1\n\n\t\t\tbreak\n\t\t}\n\n\t}\n\thead = head.Next\n\treturn head\n}\n\n// @lc code=end\n```","slug":"leetcode/21.合并两个有序链表","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5u001il1dbegjv1bjg","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;21 lang&#x3D;golang\n *\n * [21] 合并两个有序链表\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode &#123;\n\n\tif list1 &#x3D;&#x3D; nil &#123;\n\n\t\treturn list2\n\t&#125;\n\tif list2 &#x3D;&#x3D; nil &#123;\n\t\treturn list1\n\t&#125;\n\thead :&#x3D; &amp;ListNode&#123;0, nil&#125;\n\tpre :&#x3D; head\n\tc1 :&#x3D; list1\n\tc2 :&#x3D; list2\n\n\tfor &#123;\n\t\tif c1.Val &gt; c2.Val &#123;\n\t\t\tpre.Next &#x3D; c2\n\t\t\tc2 &#x3D; c2.Next\n\t\t\tpre &#x3D; pre.Next\n\t\t\t&#x2F;&#x2F; pre.Next &#x3D; c1\n\t\t\t&#x2F;&#x2F; c1 &#x3D; c1.Next\n\t\t\t&#x2F;&#x2F; pre &#x3D; pre.Next\n\t\t&#125; else if c1.Val &lt;&#x3D; c2.Val &#123;\n\t\t\tpre.Next &#x3D; c1\n\t\t\tc1 &#x3D; c1.Next\n\t\t\tpre &#x3D; pre.Next\n\t\t\t&#x2F;&#x2F; pre.Next &#x3D; c2\n\t\t\t&#x2F;&#x2F; c2 &#x3D; c2.Next\n\t\t\t&#x2F;&#x2F; pre &#x3D; pre.Next\n\t\t&#125;\n\t\tif c1 &#x3D;&#x3D; nil &#123;\n\t\t\tpre.Next &#x3D; c2\n\t\t\tbreak\n\t\t&#125;\n\t\tif c2 &#x3D;&#x3D; nil &#123;\n\t\t\tpre.Next &#x3D; c1\n\n\t\t\tbreak\n\t\t&#125;\n\n\t&#125;\n\thead &#x3D; head.Next\n\treturn head\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;21 lang&#x3D;golang\n *\n * [21] 合并两个有序链表\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode &#123;\n\n\tif list1 &#x3D;&#x3D; nil &#123;\n\n\t\treturn list2\n\t&#125;\n\tif list2 &#x3D;&#x3D; nil &#123;\n\t\treturn list1\n\t&#125;\n\thead :&#x3D; &amp;ListNode&#123;0, nil&#125;\n\tpre :&#x3D; head\n\tc1 :&#x3D; list1\n\tc2 :&#x3D; list2\n\n\tfor &#123;\n\t\tif c1.Val &gt; c2.Val &#123;\n\t\t\tpre.Next &#x3D; c2\n\t\t\tc2 &#x3D; c2.Next\n\t\t\tpre &#x3D; pre.Next\n\t\t\t&#x2F;&#x2F; pre.Next &#x3D; c1\n\t\t\t&#x2F;&#x2F; c1 &#x3D; c1.Next\n\t\t\t&#x2F;&#x2F; pre &#x3D; pre.Next\n\t\t&#125; else if c1.Val &lt;&#x3D; c2.Val &#123;\n\t\t\tpre.Next &#x3D; c1\n\t\t\tc1 &#x3D; c1.Next\n\t\t\tpre &#x3D; pre.Next\n\t\t\t&#x2F;&#x2F; pre.Next &#x3D; c2\n\t\t\t&#x2F;&#x2F; c2 &#x3D; c2.Next\n\t\t\t&#x2F;&#x2F; pre &#x3D; pre.Next\n\t\t&#125;\n\t\tif c1 &#x3D;&#x3D; nil &#123;\n\t\t\tpre.Next &#x3D; c2\n\t\t\tbreak\n\t\t&#125;\n\t\tif c2 &#x3D;&#x3D; nil &#123;\n\t\t\tpre.Next &#x3D; c1\n\n\t\t\tbreak\n\t\t&#125;\n\n\t&#125;\n\thead &#x3D; head.Next\n\treturn head\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"27.移除元素","_content":"```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=27 lang=golang\n *\n * [27] 移除元素\n */\n\n// @lc code=start\nfunc removeElement(nums []int, val int) int {\n\tslow, fast := 0, 0\n\tfor fast < len(nums) {\n\t\tif val != nums[fast] {\n\t\t\tnums[slow] = nums[fast]\n\t\t\tslow++\n\t\t}\n\t\tfast++\n\n\t}\n\treturn len(nums[:slow])\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/27.移除元素.md","raw":"---\ntitle: 27.移除元素\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=27 lang=golang\n *\n * [27] 移除元素\n */\n\n// @lc code=start\nfunc removeElement(nums []int, val int) int {\n\tslow, fast := 0, 0\n\tfor fast < len(nums) {\n\t\tif val != nums[fast] {\n\t\t\tnums[slow] = nums[fast]\n\t\t\tslow++\n\t\t}\n\t\tfast++\n\n\t}\n\treturn len(nums[:slow])\n}\n\n// @lc code=end\n```","slug":"leetcode/27.移除元素","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5u001ll1db58473rqd","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;27 lang&#x3D;golang\n *\n * [27] 移除元素\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc removeElement(nums []int, val int) int &#123;\n\tslow, fast :&#x3D; 0, 0\n\tfor fast &lt; len(nums) &#123;\n\t\tif val !&#x3D; nums[fast] &#123;\n\t\t\tnums[slow] &#x3D; nums[fast]\n\t\t\tslow++\n\t\t&#125;\n\t\tfast++\n\n\t&#125;\n\treturn len(nums[:slow])\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;27 lang&#x3D;golang\n *\n * [27] 移除元素\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc removeElement(nums []int, val int) int &#123;\n\tslow, fast :&#x3D; 0, 0\n\tfor fast &lt; len(nums) &#123;\n\t\tif val !&#x3D; nums[fast] &#123;\n\t\t\tnums[slow] &#x3D; nums[fast]\n\t\t\tslow++\n\t\t&#125;\n\t\tfast++\n\n\t&#125;\n\treturn len(nums[:slow])\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"28.实现 strStr()","_content":"```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=28 lang=golang\n *\n * [28] 实现 strStr()\n */\n\n// hellabcelp\n//  elp\n\n// @lc code=start\nfunc strStr(haystack string, needle string) int {\n\tif len(needle) == 0 {\n\t\treturn 0\n\t}\n\ti, j := 0, 0\n\tfor j < len(haystack) {\n\n\t\tc := needle[i]\n\t\tch := haystack[j]\n\t\tif c == ch {\n\t\t\ti++\n\t\t\tj++\n\t\t} else {\n\t\t\tj = j - i + 1\n\t\t\ti = 0\n\t\t}\n\t\tif i == len(needle) {\n\t\t\treturn j - i\n\t\t}\n\n\t}\n\treturn -1\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/28.实现-str-str.md","raw":"---\ntitle: 28.实现 strStr()\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=28 lang=golang\n *\n * [28] 实现 strStr()\n */\n\n// hellabcelp\n//  elp\n\n// @lc code=start\nfunc strStr(haystack string, needle string) int {\n\tif len(needle) == 0 {\n\t\treturn 0\n\t}\n\ti, j := 0, 0\n\tfor j < len(haystack) {\n\n\t\tc := needle[i]\n\t\tch := haystack[j]\n\t\tif c == ch {\n\t\t\ti++\n\t\t\tj++\n\t\t} else {\n\t\t\tj = j - i + 1\n\t\t\ti = 0\n\t\t}\n\t\tif i == len(needle) {\n\t\t\treturn j - i\n\t\t}\n\n\t}\n\treturn -1\n}\n\n// @lc code=end\n```","slug":"leetcode/28.实现-str-str","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5v001ol1db7rb9928v","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;28 lang&#x3D;golang\n *\n * [28] 实现 strStr()\n *&#x2F;\n\n&#x2F;&#x2F; hellabcelp\n&#x2F;&#x2F;  elp\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc strStr(haystack string, needle string) int &#123;\n\tif len(needle) &#x3D;&#x3D; 0 &#123;\n\t\treturn 0\n\t&#125;\n\ti, j :&#x3D; 0, 0\n\tfor j &lt; len(haystack) &#123;\n\n\t\tc :&#x3D; needle[i]\n\t\tch :&#x3D; haystack[j]\n\t\tif c &#x3D;&#x3D; ch &#123;\n\t\t\ti++\n\t\t\tj++\n\t\t&#125; else &#123;\n\t\t\tj &#x3D; j - i + 1\n\t\t\ti &#x3D; 0\n\t\t&#125;\n\t\tif i &#x3D;&#x3D; len(needle) &#123;\n\t\t\treturn j - i\n\t\t&#125;\n\n\t&#125;\n\treturn -1\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;28 lang&#x3D;golang\n *\n * [28] 实现 strStr()\n *&#x2F;\n\n&#x2F;&#x2F; hellabcelp\n&#x2F;&#x2F;  elp\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc strStr(haystack string, needle string) int &#123;\n\tif len(needle) &#x3D;&#x3D; 0 &#123;\n\t\treturn 0\n\t&#125;\n\ti, j :&#x3D; 0, 0\n\tfor j &lt; len(haystack) &#123;\n\n\t\tc :&#x3D; needle[i]\n\t\tch :&#x3D; haystack[j]\n\t\tif c &#x3D;&#x3D; ch &#123;\n\t\t\ti++\n\t\t\tj++\n\t\t&#125; else &#123;\n\t\t\tj &#x3D; j - i + 1\n\t\t\ti &#x3D; 0\n\t\t&#125;\n\t\tif i &#x3D;&#x3D; len(needle) &#123;\n\t\t\treturn j - i\n\t\t&#125;\n\n\t&#125;\n\treturn -1\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"35.搜索插入位置","_content":"```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=35 lang=golang\n *\n * [35] 搜索插入位置\n */\n//  [1,3,5,6]\n// @lc code=start\nfunc searchInsert(nums []int, target int) int {\n\tlow := 0\n\thigh := len(nums) - 1\n\tfor low <= high {\n\t\t// midIndex := low + ((high - low) / 2)\n\t\tmidIndex := (high - low) / 2\n\n\t\tmidValue := nums[midIndex]\n\t\tif target == midValue {\n\t\t\treturn midIndex\n\t\t} else if target < midValue {\n\t\t\thigh = midIndex - 1\n\t\t} else {\n\t\t\tlow = midIndex + 1\n\t\t}\n\t}\n\treturn high + 1\n\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/35.搜索插入位置.md","raw":"---\ntitle: 35.搜索插入位置\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=35 lang=golang\n *\n * [35] 搜索插入位置\n */\n//  [1,3,5,6]\n// @lc code=start\nfunc searchInsert(nums []int, target int) int {\n\tlow := 0\n\thigh := len(nums) - 1\n\tfor low <= high {\n\t\t// midIndex := low + ((high - low) / 2)\n\t\tmidIndex := (high - low) / 2\n\n\t\tmidValue := nums[midIndex]\n\t\tif target == midValue {\n\t\t\treturn midIndex\n\t\t} else if target < midValue {\n\t\t\thigh = midIndex - 1\n\t\t} else {\n\t\t\tlow = midIndex + 1\n\t\t}\n\t}\n\treturn high + 1\n\n}\n\n// @lc code=end\n```","slug":"leetcode/35.搜索插入位置","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5v001ql1db3emqacy9","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;35 lang&#x3D;golang\n *\n * [35] 搜索插入位置\n *&#x2F;\n&#x2F;&#x2F;  [1,3,5,6]\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc searchInsert(nums []int, target int) int &#123;\n\tlow :&#x3D; 0\n\thigh :&#x3D; len(nums) - 1\n\tfor low &lt;&#x3D; high &#123;\n\t\t&#x2F;&#x2F; midIndex :&#x3D; low + ((high - low) &#x2F; 2)\n\t\tmidIndex :&#x3D; (high - low) &#x2F; 2\n\n\t\tmidValue :&#x3D; nums[midIndex]\n\t\tif target &#x3D;&#x3D; midValue &#123;\n\t\t\treturn midIndex\n\t\t&#125; else if target &lt; midValue &#123;\n\t\t\thigh &#x3D; midIndex - 1\n\t\t&#125; else &#123;\n\t\t\tlow &#x3D; midIndex + 1\n\t\t&#125;\n\t&#125;\n\treturn high + 1\n\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;35 lang&#x3D;golang\n *\n * [35] 搜索插入位置\n *&#x2F;\n&#x2F;&#x2F;  [1,3,5,6]\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc searchInsert(nums []int, target int) int &#123;\n\tlow :&#x3D; 0\n\thigh :&#x3D; len(nums) - 1\n\tfor low &lt;&#x3D; high &#123;\n\t\t&#x2F;&#x2F; midIndex :&#x3D; low + ((high - low) &#x2F; 2)\n\t\tmidIndex :&#x3D; (high - low) &#x2F; 2\n\n\t\tmidValue :&#x3D; nums[midIndex]\n\t\tif target &#x3D;&#x3D; midValue &#123;\n\t\t\treturn midIndex\n\t\t&#125; else if target &lt; midValue &#123;\n\t\t\thigh &#x3D; midIndex - 1\n\t\t&#125; else &#123;\n\t\t\tlow &#x3D; midIndex + 1\n\t\t&#125;\n\t&#125;\n\treturn high + 1\n\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"53.最大子数组和","_content":"```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=53 lang=golang\n *\n * [53] 最大子数组和\n */\n\n// @lc code=start\n\nfunc maxSubArray(nums []int) int {\n\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\tres := -32768\n\tf_n := -1\n\t// {-2, 1, -3, 4, -1, 2, 1, -5, 4}\n\tfor i := 0; i < len(nums); i++ {\n\t\tf_n = Max(nums[i], f_n+nums[i])\n\t\tres = Max(f_n, res)\n\t}\n\treturn res\n}\n\nfunc Max(a int, b int) int {\n\n\tif a >= b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/53.最大子数组和.md","raw":"---\ntitle: 53.最大子数组和\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=53 lang=golang\n *\n * [53] 最大子数组和\n */\n\n// @lc code=start\n\nfunc maxSubArray(nums []int) int {\n\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\tres := -32768\n\tf_n := -1\n\t// {-2, 1, -3, 4, -1, 2, 1, -5, 4}\n\tfor i := 0; i < len(nums); i++ {\n\t\tf_n = Max(nums[i], f_n+nums[i])\n\t\tres = Max(f_n, res)\n\t}\n\treturn res\n}\n\nfunc Max(a int, b int) int {\n\n\tif a >= b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// @lc code=end\n```","slug":"leetcode/53.最大子数组和","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5w001sl1db71yhh1at","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;53 lang&#x3D;golang\n *\n * [53] 最大子数组和\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\n\nfunc maxSubArray(nums []int) int &#123;\n\n\tif len(nums) &#x3D;&#x3D; 0 &#123;\n\t\treturn 0\n\t&#125;\n\tres :&#x3D; -32768\n\tf_n :&#x3D; -1\n\t&#x2F;&#x2F; &#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;\n\tfor i :&#x3D; 0; i &lt; len(nums); i++ &#123;\n\t\tf_n &#x3D; Max(nums[i], f_n+nums[i])\n\t\tres &#x3D; Max(f_n, res)\n\t&#125;\n\treturn res\n&#125;\n\nfunc Max(a int, b int) int &#123;\n\n\tif a &gt;&#x3D; b &#123;\n\t\treturn a\n\t&#125;\n\treturn b\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;53 lang&#x3D;golang\n *\n * [53] 最大子数组和\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\n\nfunc maxSubArray(nums []int) int &#123;\n\n\tif len(nums) &#x3D;&#x3D; 0 &#123;\n\t\treturn 0\n\t&#125;\n\tres :&#x3D; -32768\n\tf_n :&#x3D; -1\n\t&#x2F;&#x2F; &#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;\n\tfor i :&#x3D; 0; i &lt; len(nums); i++ &#123;\n\t\tf_n &#x3D; Max(nums[i], f_n+nums[i])\n\t\tres &#x3D; Max(f_n, res)\n\t&#125;\n\treturn res\n&#125;\n\nfunc Max(a int, b int) int &#123;\n\n\tif a &gt;&#x3D; b &#123;\n\t\treturn a\n\t&#125;\n\treturn b\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"58.最后一个单词的长度","_content":"```golang\npackage main\n\nimport \"strings\"\n\n/*\n * @lc app=leetcode.cn id=58 lang=golang\n *\n * [58] 最后一个单词的长度\n */\n\n// @lc code=start\nfunc lengthOfLastWord(s string) int {\n\twords := strings.Split(strings.TrimSpace(s), \" \")\n\n\treturn len(words[len(words)-1])\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/58.最后一个单词的长度.md","raw":"---\ntitle: 58.最后一个单词的长度\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\nimport \"strings\"\n\n/*\n * @lc app=leetcode.cn id=58 lang=golang\n *\n * [58] 最后一个单词的长度\n */\n\n// @lc code=start\nfunc lengthOfLastWord(s string) int {\n\twords := strings.Split(strings.TrimSpace(s), \" \")\n\n\treturn len(words[len(words)-1])\n}\n\n// @lc code=end\n```","slug":"leetcode/58.最后一个单词的长度","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:27.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5w001vl1db5458ffmh","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;strings&quot;\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;58 lang&#x3D;golang\n *\n * [58] 最后一个单词的长度\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc lengthOfLastWord(s string) int &#123;\n\twords :&#x3D; strings.Split(strings.TrimSpace(s), &quot; &quot;)\n\n\treturn len(words[len(words)-1])\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;strings&quot;\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;58 lang&#x3D;golang\n *\n * [58] 最后一个单词的长度\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc lengthOfLastWord(s string) int &#123;\n\twords :&#x3D; strings.Split(strings.TrimSpace(s), &quot; &quot;)\n\n\treturn len(words[len(words)-1])\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"66.加一","_content":"```golang\n\npackage main\n\nimport \"fmt\"\n\n/*\n * @lc app=leetcode.cn id=66 lang=golang\n *\n * [66] 加一\n */\n//  9 9 9 9 9\n// @lc code=start\nfunc plusOne(digits []int) []int {\n\n\tl := len(digits)\n\t//遍历数组\n\tfor i := l - 1; i >= 0; i-- {\n\t\tdigits[i] = (digits[i] + 1) % 10\n\t\tfmt.Println(digits[i])\n\t\t//判断取模10是否等于零\n\t\tif digits[i] != 0 {\n\t\t\treturn digits\n\t\t}\n\t}\n\t//new一个新数组\n\tnewArr := make([]int, l+1)\n\t// digits= new int[l + 1];\n\t//设定第一位为1\n\tnewArr[0] = 1\n\treturn newArr\n\n}\n\n// @lc code=end\n```\n","source":"_posts/leetcode/66.加一.md","raw":"---\ntitle: 66.加一\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\n\npackage main\n\nimport \"fmt\"\n\n/*\n * @lc app=leetcode.cn id=66 lang=golang\n *\n * [66] 加一\n */\n//  9 9 9 9 9\n// @lc code=start\nfunc plusOne(digits []int) []int {\n\n\tl := len(digits)\n\t//遍历数组\n\tfor i := l - 1; i >= 0; i-- {\n\t\tdigits[i] = (digits[i] + 1) % 10\n\t\tfmt.Println(digits[i])\n\t\t//判断取模10是否等于零\n\t\tif digits[i] != 0 {\n\t\t\treturn digits\n\t\t}\n\t}\n\t//new一个新数组\n\tnewArr := make([]int, l+1)\n\t// digits= new int[l + 1];\n\t//设定第一位为1\n\tnewArr[0] = 1\n\treturn newArr\n\n}\n\n// @lc code=end\n```\n","slug":"leetcode/66.加一","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:40:42.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5x001wl1db5s5tfsjy","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;66 lang&#x3D;golang\n *\n * [66] 加一\n *&#x2F;\n&#x2F;&#x2F;  9 9 9 9 9\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc plusOne(digits []int) []int &#123;\n\n\tl :&#x3D; len(digits)\n\t&#x2F;&#x2F;遍历数组\n\tfor i :&#x3D; l - 1; i &gt;&#x3D; 0; i-- &#123;\n\t\tdigits[i] &#x3D; (digits[i] + 1) % 10\n\t\tfmt.Println(digits[i])\n\t\t&#x2F;&#x2F;判断取模10是否等于零\n\t\tif digits[i] !&#x3D; 0 &#123;\n\t\t\treturn digits\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;new一个新数组\n\tnewArr :&#x3D; make([]int, l+1)\n\t&#x2F;&#x2F; digits&#x3D; new int[l + 1];\n\t&#x2F;&#x2F;设定第一位为1\n\tnewArr[0] &#x3D; 1\n\treturn newArr\n\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;66 lang&#x3D;golang\n *\n * [66] 加一\n *&#x2F;\n&#x2F;&#x2F;  9 9 9 9 9\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc plusOne(digits []int) []int &#123;\n\n\tl :&#x3D; len(digits)\n\t&#x2F;&#x2F;遍历数组\n\tfor i :&#x3D; l - 1; i &gt;&#x3D; 0; i-- &#123;\n\t\tdigits[i] &#x3D; (digits[i] + 1) % 10\n\t\tfmt.Println(digits[i])\n\t\t&#x2F;&#x2F;判断取模10是否等于零\n\t\tif digits[i] !&#x3D; 0 &#123;\n\t\t\treturn digits\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;new一个新数组\n\tnewArr :&#x3D; make([]int, l+1)\n\t&#x2F;&#x2F; digits&#x3D; new int[l + 1];\n\t&#x2F;&#x2F;设定第一位为1\n\tnewArr[0] &#x3D; 1\n\treturn newArr\n\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>\n"},{"title":"67.二进制的求和","_content":"```golang\n\npackage main\n\n/*\n * @lc app=leetcode.cn id=67 lang=golang\n *\n * [67] 二进制求和\n */\n\n// @lc code=start\nfunc addBinary(a string, b string) string {\n\tvar carry, sum int\n\ti, j := len(a), len(b)\n\tif i < j {\n\t\ti, j = j, i\n\t\ta, b = b, a\n\t}\n\n\tres := make([]byte, i+1)\n\n\tfor j > 0 {\n\t\tj--\n\t\ti--\n\t\tsum = int(a[i]-'0') + int(b[j]-'0') + carry\n\t\tcarry = sum / 2\n\t\tsum = sum % 2\n\t\tres[i+1] = byte(sum + '0')\n\t}\n\n\tfor i > 0 {\n\t\ti--\n\t\tsum = int(a[i]-'0') + carry\n\t\tcarry = sum / 2\n\t\tsum = sum % 2\n\t\tres[i+1] = byte(sum + '0')\n\t}\n\n\tres[0] = byte(carry + '0')\n\n\tfor i < len(res)-1 {\n\t\tif res[i] == '0' {\n\t\t\ti++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(res[i:])\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/67.二进制求和.md","raw":"---\ntitle: 67.二进制的求和\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\n\npackage main\n\n/*\n * @lc app=leetcode.cn id=67 lang=golang\n *\n * [67] 二进制求和\n */\n\n// @lc code=start\nfunc addBinary(a string, b string) string {\n\tvar carry, sum int\n\ti, j := len(a), len(b)\n\tif i < j {\n\t\ti, j = j, i\n\t\ta, b = b, a\n\t}\n\n\tres := make([]byte, i+1)\n\n\tfor j > 0 {\n\t\tj--\n\t\ti--\n\t\tsum = int(a[i]-'0') + int(b[j]-'0') + carry\n\t\tcarry = sum / 2\n\t\tsum = sum % 2\n\t\tres[i+1] = byte(sum + '0')\n\t}\n\n\tfor i > 0 {\n\t\ti--\n\t\tsum = int(a[i]-'0') + carry\n\t\tcarry = sum / 2\n\t\tsum = sum % 2\n\t\tres[i+1] = byte(sum + '0')\n\t}\n\n\tres[0] = byte(carry + '0')\n\n\tfor i < len(res)-1 {\n\t\tif res[i] == '0' {\n\t\t\ti++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(res[i:])\n}\n\n// @lc code=end\n```","slug":"leetcode/67.二进制求和","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:40:37.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5x001zl1dbg4s02c6i","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;67 lang&#x3D;golang\n *\n * [67] 二进制求和\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc addBinary(a string, b string) string &#123;\n\tvar carry, sum int\n\ti, j :&#x3D; len(a), len(b)\n\tif i &lt; j &#123;\n\t\ti, j &#x3D; j, i\n\t\ta, b &#x3D; b, a\n\t&#125;\n\n\tres :&#x3D; make([]byte, i+1)\n\n\tfor j &gt; 0 &#123;\n\t\tj--\n\t\ti--\n\t\tsum &#x3D; int(a[i]-&#39;0&#39;) + int(b[j]-&#39;0&#39;) + carry\n\t\tcarry &#x3D; sum &#x2F; 2\n\t\tsum &#x3D; sum % 2\n\t\tres[i+1] &#x3D; byte(sum + &#39;0&#39;)\n\t&#125;\n\n\tfor i &gt; 0 &#123;\n\t\ti--\n\t\tsum &#x3D; int(a[i]-&#39;0&#39;) + carry\n\t\tcarry &#x3D; sum &#x2F; 2\n\t\tsum &#x3D; sum % 2\n\t\tres[i+1] &#x3D; byte(sum + &#39;0&#39;)\n\t&#125;\n\n\tres[0] &#x3D; byte(carry + &#39;0&#39;)\n\n\tfor i &lt; len(res)-1 &#123;\n\t\tif res[i] &#x3D;&#x3D; &#39;0&#39; &#123;\n\t\t\ti++\n\t\t&#125; else &#123;\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n\treturn string(res[i:])\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;67 lang&#x3D;golang\n *\n * [67] 二进制求和\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc addBinary(a string, b string) string &#123;\n\tvar carry, sum int\n\ti, j :&#x3D; len(a), len(b)\n\tif i &lt; j &#123;\n\t\ti, j &#x3D; j, i\n\t\ta, b &#x3D; b, a\n\t&#125;\n\n\tres :&#x3D; make([]byte, i+1)\n\n\tfor j &gt; 0 &#123;\n\t\tj--\n\t\ti--\n\t\tsum &#x3D; int(a[i]-&#39;0&#39;) + int(b[j]-&#39;0&#39;) + carry\n\t\tcarry &#x3D; sum &#x2F; 2\n\t\tsum &#x3D; sum % 2\n\t\tres[i+1] &#x3D; byte(sum + &#39;0&#39;)\n\t&#125;\n\n\tfor i &gt; 0 &#123;\n\t\ti--\n\t\tsum &#x3D; int(a[i]-&#39;0&#39;) + carry\n\t\tcarry &#x3D; sum &#x2F; 2\n\t\tsum &#x3D; sum % 2\n\t\tres[i+1] &#x3D; byte(sum + &#39;0&#39;)\n\t&#125;\n\n\tres[0] &#x3D; byte(carry + &#39;0&#39;)\n\n\tfor i &lt; len(res)-1 &#123;\n\t\tif res[i] &#x3D;&#x3D; &#39;0&#39; &#123;\n\t\t\ti++\n\t\t&#125; else &#123;\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n\treturn string(res[i:])\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"69.x-的平方根","_content":"```golang\npackage main\n\nimport \"math\"\n\n/*\n * @lc app=leetcode.cn id=69 lang=golang\n *\n * [69] x 的平方根\n */\n\n// @lc code=start\n\nfunc mySqrt(x int) int {\n\n\treturn int(math.Sqrt(float64(x)))\n\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/69.x-的平方根.md","raw":"---\ntitle: 69.x-的平方根\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\nimport \"math\"\n\n/*\n * @lc app=leetcode.cn id=69 lang=golang\n *\n * [69] x 的平方根\n */\n\n// @lc code=start\n\nfunc mySqrt(x int) int {\n\n\treturn int(math.Sqrt(float64(x)))\n\n}\n\n// @lc code=end\n```","slug":"leetcode/69.x-的平方根","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:40:30.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5y0020l1db741h340x","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;math&quot;\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;69 lang&#x3D;golang\n *\n * [69] x 的平方根\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\n\nfunc mySqrt(x int) int &#123;\n\n\treturn int(math.Sqrt(float64(x)))\n\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;math&quot;\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;69 lang&#x3D;golang\n *\n * [69] x 的平方根\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\n\nfunc mySqrt(x int) int &#123;\n\n\treturn int(math.Sqrt(float64(x)))\n\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"70.爬楼梯","_content":"```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=70 lang=golang\n *\n * [70] 爬楼梯\n */\n\n// @lc code=start\n// int BottomUpCutRod(const std::vector<int> &p, const int &n)\n// {\n//     std::vector<int> r{0};\n//     for (auto j = 1; j <= n; ++j)\n//     {\n//         int q = INT8_MIN;\n//         for (auto i = 1; i <= j; ++i)\n//         {\n//             q = std::max(q, p.at(i) + r.at(j - i));\n//         }\n//         r.push_back(q);\n//     }\n//     return r.at(n);\n// }\n// 1 1 2 3 5 8\n//   1 2 3 4 5\nfunc climbStairs(n int) int {\n\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn 1\n\t}\n\tif n == 2 {\n\t\treturn 2\n\t}\n\tdp := []int{1, 2}\n\tfor i := 3; i <= n; i++ {\n\t\tSum(dp)\n\t}\n\n\treturn dp[1]\n}\nfunc Sum(dp []int) {\n\tpre := dp[0]\n\tdp[0] = dp[1]\n\tdp[1] = pre + dp[1]\n}\n\n// @lc code=end\n```","source":"_posts/leetcode/70.爬楼梯.md","raw":"---\ntitle: 70.爬楼梯\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\n/*\n * @lc app=leetcode.cn id=70 lang=golang\n *\n * [70] 爬楼梯\n */\n\n// @lc code=start\n// int BottomUpCutRod(const std::vector<int> &p, const int &n)\n// {\n//     std::vector<int> r{0};\n//     for (auto j = 1; j <= n; ++j)\n//     {\n//         int q = INT8_MIN;\n//         for (auto i = 1; i <= j; ++i)\n//         {\n//             q = std::max(q, p.at(i) + r.at(j - i));\n//         }\n//         r.push_back(q);\n//     }\n//     return r.at(n);\n// }\n// 1 1 2 3 5 8\n//   1 2 3 4 5\nfunc climbStairs(n int) int {\n\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn 1\n\t}\n\tif n == 2 {\n\t\treturn 2\n\t}\n\tdp := []int{1, 2}\n\tfor i := 3; i <= n; i++ {\n\t\tSum(dp)\n\t}\n\n\treturn dp[1]\n}\nfunc Sum(dp []int) {\n\tpre := dp[0]\n\tdp[0] = dp[1]\n\tdp[1] = pre + dp[1]\n}\n\n// @lc code=end\n```","slug":"leetcode/70.爬楼梯","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:40:24.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5z0023l1dbcih43hdo","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;70 lang&#x3D;golang\n *\n * [70] 爬楼梯\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\n&#x2F;&#x2F; int BottomUpCutRod(const std::vector&lt;int&gt; &amp;p, const int &amp;n)\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     std::vector&lt;int&gt; r&#123;0&#125;;\n&#x2F;&#x2F;     for (auto j &#x3D; 1; j &lt;&#x3D; n; ++j)\n&#x2F;&#x2F;     &#123;\n&#x2F;&#x2F;         int q &#x3D; INT8_MIN;\n&#x2F;&#x2F;         for (auto i &#x3D; 1; i &lt;&#x3D; j; ++i)\n&#x2F;&#x2F;         &#123;\n&#x2F;&#x2F;             q &#x3D; std::max(q, p.at(i) + r.at(j - i));\n&#x2F;&#x2F;         &#125;\n&#x2F;&#x2F;         r.push_back(q);\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F;     return r.at(n);\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; 1 1 2 3 5 8\n&#x2F;&#x2F;   1 2 3 4 5\nfunc climbStairs(n int) int &#123;\n\n\tif n &#x3D;&#x3D; 0 &#123;\n\t\treturn 1\n\t&#125;\n\tif n &#x3D;&#x3D; 1 &#123;\n\t\treturn 1\n\t&#125;\n\tif n &#x3D;&#x3D; 2 &#123;\n\t\treturn 2\n\t&#125;\n\tdp :&#x3D; []int&#123;1, 2&#125;\n\tfor i :&#x3D; 3; i &lt;&#x3D; n; i++ &#123;\n\t\tSum(dp)\n\t&#125;\n\n\treturn dp[1]\n&#125;\nfunc Sum(dp []int) &#123;\n\tpre :&#x3D; dp[0]\n\tdp[0] &#x3D; dp[1]\n\tdp[1] &#x3D; pre + dp[1]\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;70 lang&#x3D;golang\n *\n * [70] 爬楼梯\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\n&#x2F;&#x2F; int BottomUpCutRod(const std::vector&lt;int&gt; &amp;p, const int &amp;n)\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     std::vector&lt;int&gt; r&#123;0&#125;;\n&#x2F;&#x2F;     for (auto j &#x3D; 1; j &lt;&#x3D; n; ++j)\n&#x2F;&#x2F;     &#123;\n&#x2F;&#x2F;         int q &#x3D; INT8_MIN;\n&#x2F;&#x2F;         for (auto i &#x3D; 1; i &lt;&#x3D; j; ++i)\n&#x2F;&#x2F;         &#123;\n&#x2F;&#x2F;             q &#x3D; std::max(q, p.at(i) + r.at(j - i));\n&#x2F;&#x2F;         &#125;\n&#x2F;&#x2F;         r.push_back(q);\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F;     return r.at(n);\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; 1 1 2 3 5 8\n&#x2F;&#x2F;   1 2 3 4 5\nfunc climbStairs(n int) int &#123;\n\n\tif n &#x3D;&#x3D; 0 &#123;\n\t\treturn 1\n\t&#125;\n\tif n &#x3D;&#x3D; 1 &#123;\n\t\treturn 1\n\t&#125;\n\tif n &#x3D;&#x3D; 2 &#123;\n\t\treturn 2\n\t&#125;\n\tdp :&#x3D; []int&#123;1, 2&#125;\n\tfor i :&#x3D; 3; i &lt;&#x3D; n; i++ &#123;\n\t\tSum(dp)\n\t&#125;\n\n\treturn dp[1]\n&#125;\nfunc Sum(dp []int) &#123;\n\tpre :&#x3D; dp[0]\n\tdp[0] &#x3D; dp[1]\n\tdp[1] &#x3D; pre + dp[1]\n&#125;\n\n&#x2F;&#x2F; @lc code&#x3D;end</code></pre>"},{"title":"83.删除排序链表中的重复元素","_content":"```c++\n#include <iostream>\n \nusing namespace std;\n\nstruct ListNode {\n      int val;\n      ListNode *next;\n      ListNode() : val(0), next(nullptr) {}\n      ListNode(int x) : val(x), next(nullptr) {}\n      ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n/*\n * @lc app=leetcode.cn id=83 lang=cpp\n *\n * [83] 删除排序链表中的重复元素\n */\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n    ListNode *cur = head;\n    if (head == NULL){\n        return head;\n    } \n\n    while (cur && cur->next  ){\n        ListNode *next = cur->next;\n        if (cur->val == next->val){\n            cur->next = next->next;\n        } else {\n            cur = next;\n            \n        }\n    }\n\n        return head;\n    }\n};\n// @lc code=end\n\n```","source":"_posts/leetcode/83.删除排序链表中的重复元素.md","raw":"---\ntitle: 83.删除排序链表中的重复元素\ncategories:\n- leetcode\n- leetcode题解\n---\n```c++\n#include <iostream>\n \nusing namespace std;\n\nstruct ListNode {\n      int val;\n      ListNode *next;\n      ListNode() : val(0), next(nullptr) {}\n      ListNode(int x) : val(x), next(nullptr) {}\n      ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n/*\n * @lc app=leetcode.cn id=83 lang=cpp\n *\n * [83] 删除排序链表中的重复元素\n */\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n    ListNode *cur = head;\n    if (head == NULL){\n        return head;\n    } \n\n    while (cur && cur->next  ){\n        ListNode *next = cur->next;\n        if (cur->val == next->val){\n            cur->next = next->next;\n        } else {\n            cur = next;\n            \n        }\n    }\n\n        return head;\n    }\n};\n// @lc code=end\n\n```","slug":"leetcode/83.删除排序链表中的重复元素","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:40:19.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu5z0024l1dbdxn0h52z","content":"<pre class=\"language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n \nusing namespace std;\n\nstruct ListNode &#123;\n      int val;\n      ListNode *next;\n      ListNode() : val(0), next(nullptr) &#123;&#125;\n      ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n      ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n&#125;;\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;83 lang&#x3D;cpp\n *\n * [83] 删除排序链表中的重复元素\n *&#x2F;\n&#x2F;&#x2F; @lc code&#x3D;start\n&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\n\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n    ListNode *cur &#x3D; head;\n    if (head &#x3D;&#x3D; NULL)&#123;\n        return head;\n    &#125; \n\n    while (cur &amp;&amp; cur-&gt;next  )&#123;\n        ListNode *next &#x3D; cur-&gt;next;\n        if (cur-&gt;val &#x3D;&#x3D; next-&gt;val)&#123;\n            cur-&gt;next &#x3D; next-&gt;next;\n        &#125; else &#123;\n            cur &#x3D; next;\n            \n        &#125;\n    &#125;\n\n        return head;\n    &#125;\n&#125;;\n&#x2F;&#x2F; @lc code&#x3D;end\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n \nusing namespace std;\n\nstruct ListNode &#123;\n      int val;\n      ListNode *next;\n      ListNode() : val(0), next(nullptr) &#123;&#125;\n      ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n      ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n&#125;;\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;83 lang&#x3D;cpp\n *\n * [83] 删除排序链表中的重复元素\n *&#x2F;\n&#x2F;&#x2F; @lc code&#x3D;start\n&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\n\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n    ListNode *cur &#x3D; head;\n    if (head &#x3D;&#x3D; NULL)&#123;\n        return head;\n    &#125; \n\n    while (cur &amp;&amp; cur-&gt;next  )&#123;\n        ListNode *next &#x3D; cur-&gt;next;\n        if (cur-&gt;val &#x3D;&#x3D; next-&gt;val)&#123;\n            cur-&gt;next &#x3D; next-&gt;next;\n        &#125; else &#123;\n            cur &#x3D; next;\n            \n        &#125;\n    &#125;\n\n        return head;\n    &#125;\n&#125;;\n&#x2F;&#x2F; @lc code&#x3D;end\n</code></pre>"},{"title":"88.合并两个有序数组","_content":"\n#include<vector>\n\nusing namespace std;\n/*\n * @lc app=leetcode.cn id=88 lang=cpp\n *\n * [88] 合并两个有序数组\n *\n * https://leetcode.cn/problems/merge-sorted-array/description/\n *\n * algorithms\n * Easy (52.34%)\n * Likes:    1452\n * Dislikes: 0\n * Total Accepted:    680.7K\n * Total Submissions: 1.3M\n * Testcase Example:  '[1,2,3,0,0,0]\\n3\\n[2,5,6]\\n3'\n *\n * 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n * \n * 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n * \n * 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m\n * 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n * \n * \n * \n * 示例 1：\n * \n * \n * 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n * 输出：[1,2,2,3,5,6]\n * 解释：需要合并 [1,2,3] 和 [2,5,6] 。\n * 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n * \n * \n * 示例 2：\n * \n * \n * 输入：nums1 = [1], m = 1, nums2 = [], n = 0\n * 输出：[1]\n * 解释：需要合并 [1] 和 [] 。\n * 合并结果是 [1] 。\n * \n * \n * 示例 3：\n * \n * \n * 输入：nums1 = [0], m = 0, nums2 = [1], n = 1\n * 输出：[1]\n * 解释：需要合并的数组是 [] 和 [1] 。\n * 合并结果是 [1] 。\n * 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n * \n * \n * \n * \n * 提示：\n * \n * \n * nums1.length == m + n\n * nums2.length == n\n * 0 <= m, n <= 200\n * 1 <= m + n <= 200\n * -10^9 <= nums1[i], nums2[j] <= 10^9\n * \n * \n * \n * \n * 进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？\n * \n */\n```cpp\n// @lc code=start\nclass Solution {\npublic:\n    // nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1, j = n - 1, tar = m + n - 1;\n        while (j >= 0) {\n            nums1[tar--] = (i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--]);\n        }\n\n    }\n};\n\n\n// @lc code=end\n\n```","source":"_posts/leetcode/88.合并两个有序数组.md","raw":"---\ntitle: 88.合并两个有序数组\ncategories:\n- leetcode\n- leetcode题解\n---\n\n#include<vector>\n\nusing namespace std;\n/*\n * @lc app=leetcode.cn id=88 lang=cpp\n *\n * [88] 合并两个有序数组\n *\n * https://leetcode.cn/problems/merge-sorted-array/description/\n *\n * algorithms\n * Easy (52.34%)\n * Likes:    1452\n * Dislikes: 0\n * Total Accepted:    680.7K\n * Total Submissions: 1.3M\n * Testcase Example:  '[1,2,3,0,0,0]\\n3\\n[2,5,6]\\n3'\n *\n * 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n * \n * 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n * \n * 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m\n * 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n * \n * \n * \n * 示例 1：\n * \n * \n * 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n * 输出：[1,2,2,3,5,6]\n * 解释：需要合并 [1,2,3] 和 [2,5,6] 。\n * 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n * \n * \n * 示例 2：\n * \n * \n * 输入：nums1 = [1], m = 1, nums2 = [], n = 0\n * 输出：[1]\n * 解释：需要合并 [1] 和 [] 。\n * 合并结果是 [1] 。\n * \n * \n * 示例 3：\n * \n * \n * 输入：nums1 = [0], m = 0, nums2 = [1], n = 1\n * 输出：[1]\n * 解释：需要合并的数组是 [] 和 [1] 。\n * 合并结果是 [1] 。\n * 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n * \n * \n * \n * \n * 提示：\n * \n * \n * nums1.length == m + n\n * nums2.length == n\n * 0 <= m, n <= 200\n * 1 <= m + n <= 200\n * -10^9 <= nums1[i], nums2[j] <= 10^9\n * \n * \n * \n * \n * 进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？\n * \n */\n```cpp\n// @lc code=start\nclass Solution {\npublic:\n    // nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1, j = n - 1, tar = m + n - 1;\n        while (j >= 0) {\n            nums1[tar--] = (i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--]);\n        }\n\n    }\n};\n\n\n// @lc code=end\n\n```","slug":"leetcode/88.合并两个有序数组","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:40:14.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu600027l1dbbxe1a8is","content":"<p>#include<vector></p>\n<p>using namespace std;<br>&#x2F;*</p>\n<ul>\n<li>@lc app&#x3D;leetcode.cn id&#x3D;88 lang&#x3D;cpp</li>\n<li></li>\n<li>[88] 合并两个有序数组</li>\n<li></li>\n<li><a href=\"https://leetcode.cn/problems/merge-sorted-array/description/\">https://leetcode.cn/problems/merge-sorted-array/description/</a></li>\n<li></li>\n<li>algorithms</li>\n<li>Easy (52.34%)</li>\n<li>Likes:    1452</li>\n<li>Dislikes: 0</li>\n<li>Total Accepted:    680.7K</li>\n<li>Total Submissions: 1.3M</li>\n<li>Testcase Example:  ‘[1,2,3,0,0,0]\\n3\\n[2,5,6]\\n3’</li>\n<li></li>\n<li>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</li>\n<li></li>\n<li>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</li>\n<li></li>\n<li>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m</li>\n<li>个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</li>\n<li></li>\n<li></li>\n<li></li>\n<li>示例 1：</li>\n<li></li>\n<li></li>\n<li>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</li>\n<li>输出：[1,2,2,3,5,6]</li>\n<li>解释：需要合并 [1,2,3] 和 [2,5,6] 。</li>\n<li>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</li>\n<li></li>\n<li></li>\n<li>示例 2：</li>\n<li></li>\n<li></li>\n<li>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</li>\n<li>输出：[1]</li>\n<li>解释：需要合并 [1] 和 [] 。</li>\n<li>合并结果是 [1] 。</li>\n<li></li>\n<li></li>\n<li>示例 3：</li>\n<li></li>\n<li></li>\n<li>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1</li>\n<li>输出：[1]</li>\n<li>解释：需要合并的数组是 [] 和 [1] 。</li>\n<li>合并结果是 [1] 。</li>\n<li>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li>提示：</li>\n<li></li>\n<li></li>\n<li>nums1.length &#x3D;&#x3D; m + n</li>\n<li>nums2.length &#x3D;&#x3D; n</li>\n<li>0 &lt;&#x3D; m, n &lt;&#x3D; 200</li>\n<li>1 &lt;&#x3D; m + n &lt;&#x3D; 200</li>\n<li>-10^9 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 10^9</li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</li>\n<li> *&#x2F;<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// @lc code=start</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\">// nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> tar <span class=\"token operator\">=</span> m <span class=\"token operator\">+</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            nums1<span class=\"token punctuation\">[</span>tar<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums2<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> nums1<span class=\"token punctuation\">[</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> nums2<span class=\"token punctuation\">[</span>j<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">// @lc code=end</span>\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>#include<vector></p>\n<p>using namespace std;<br>&#x2F;*</p>\n<ul>\n<li>@lc app&#x3D;leetcode.cn id&#x3D;88 lang&#x3D;cpp</li>\n<li></li>\n<li>[88] 合并两个有序数组</li>\n<li></li>\n<li><a href=\"https://leetcode.cn/problems/merge-sorted-array/description/\">https://leetcode.cn/problems/merge-sorted-array/description/</a></li>\n<li></li>\n<li>algorithms</li>\n<li>Easy (52.34%)</li>\n<li>Likes:    1452</li>\n<li>Dislikes: 0</li>\n<li>Total Accepted:    680.7K</li>\n<li>Total Submissions: 1.3M</li>\n<li>Testcase Example:  ‘[1,2,3,0,0,0]\\n3\\n[2,5,6]\\n3’</li>\n<li></li>\n<li>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</li>\n<li></li>\n<li>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</li>\n<li></li>\n<li>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m</li>\n<li>个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</li>\n<li></li>\n<li></li>\n<li></li>\n<li>示例 1：</li>\n<li></li>\n<li></li>\n<li>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</li>\n<li>输出：[1,2,2,3,5,6]</li>\n<li>解释：需要合并 [1,2,3] 和 [2,5,6] 。</li>\n<li>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</li>\n<li></li>\n<li></li>\n<li>示例 2：</li>\n<li></li>\n<li></li>\n<li>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</li>\n<li>输出：[1]</li>\n<li>解释：需要合并 [1] 和 [] 。</li>\n<li>合并结果是 [1] 。</li>\n<li></li>\n<li></li>\n<li>示例 3：</li>\n<li></li>\n<li></li>\n<li>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1</li>\n<li>输出：[1]</li>\n<li>解释：需要合并的数组是 [] 和 [1] 。</li>\n<li>合并结果是 [1] 。</li>\n<li>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li>提示：</li>\n<li></li>\n<li></li>\n<li>nums1.length &#x3D;&#x3D; m + n</li>\n<li>nums2.length &#x3D;&#x3D; n</li>\n<li>0 &lt;&#x3D; m, n &lt;&#x3D; 200</li>\n<li>1 &lt;&#x3D; m + n &lt;&#x3D; 200</li>\n<li>-10^9 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 10^9</li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</li>\n<li> *&#x2F;<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// @lc code=start</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\">// nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> tar <span class=\"token operator\">=</span> m <span class=\"token operator\">+</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            nums1<span class=\"token punctuation\">[</span>tar<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums2<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> nums1<span class=\"token punctuation\">[</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> nums2<span class=\"token punctuation\">[</span>j<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">// @lc code=end</span>\n</code></pre></li>\n</ul>\n"},{"title":"9.回文数","_content":"```golang\npackage main\n\nimport \"strconv\"\n\n/*\n * @lc app=leetcode.cn id=9 lang=golang\n *\n * [9] 回文数\n */\n\n// @lc code=start\nfunc isPalindrome(x int) bool {\n\n\tbigString := strconv.Itoa(x)\n\tfor i := 0; i <= len(bigString)/2; i++ {\n\t\tif bigString[i] == bigString[len(bigString)-1-i] {\n\t\t\tcontinue\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\n\t}\n\treturn true\n\n\n\n// @lc code=end\n}\n```","source":"_posts/leetcode/9.回文数.md","raw":"---\ntitle: 9.回文数\ncategories:\n- leetcode\n- leetcode题解\n---\n```golang\npackage main\n\nimport \"strconv\"\n\n/*\n * @lc app=leetcode.cn id=9 lang=golang\n *\n * [9] 回文数\n */\n\n// @lc code=start\nfunc isPalindrome(x int) bool {\n\n\tbigString := strconv.Itoa(x)\n\tfor i := 0; i <= len(bigString)/2; i++ {\n\t\tif bigString[i] == bigString[len(bigString)-1-i] {\n\t\t\tcontinue\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\n\t}\n\treturn true\n\n\n\n// @lc code=end\n}\n```","slug":"leetcode/9.回文数","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:42:15.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu600028l1db17cjayg0","content":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;strconv&quot;\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;9 lang&#x3D;golang\n *\n * [9] 回文数\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc isPalindrome(x int) bool &#123;\n\n\tbigString :&#x3D; strconv.Itoa(x)\n\tfor i :&#x3D; 0; i &lt;&#x3D; len(bigString)&#x2F;2; i++ &#123;\n\t\tif bigString[i] &#x3D;&#x3D; bigString[len(bigString)-1-i] &#123;\n\t\t\tcontinue\n\t\t&#125; else &#123;\n\t\t\treturn false\n\t\t&#125;\n\n\t&#125;\n\treturn true\n\n\n\n&#x2F;&#x2F; @lc code&#x3D;end\n&#125;</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;strconv&quot;\n\n&#x2F;*\n * @lc app&#x3D;leetcode.cn id&#x3D;9 lang&#x3D;golang\n *\n * [9] 回文数\n *&#x2F;\n\n&#x2F;&#x2F; @lc code&#x3D;start\nfunc isPalindrome(x int) bool &#123;\n\n\tbigString :&#x3D; strconv.Itoa(x)\n\tfor i :&#x3D; 0; i &lt;&#x3D; len(bigString)&#x2F;2; i++ &#123;\n\t\tif bigString[i] &#x3D;&#x3D; bigString[len(bigString)-1-i] &#123;\n\t\t\tcontinue\n\t\t&#125; else &#123;\n\t\t\treturn false\n\t\t&#125;\n\n\t&#125;\n\treturn true\n\n\n\n&#x2F;&#x2F; @lc code&#x3D;end\n&#125;</code></pre>"},{"title":"94.二叉树的中序排序","_content":"\n\n\n```text\n/*\n * @lc app=leetcode.cn id=94 lang=cpp\n *\n * [94] 二叉树的中序遍历\n *\n * https://leetcode.cn/problems/binary-tree-inorder-traversal/description/\n *\n * algorithms\n * Easy (75.91%)\n * Likes:    1465\n * Dislikes: 0\n * Total Accepted:    855.6K\n * Total Submissions: 1.1M\n * Testcase Example:  '[1,null,2,3]'\n *\n * 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n * \n * \n * \n * 示例 1：\n * \n * \n * 输入：root = [1,null,2,3]\n * 输出：[1,3,2]\n * \n * \n * 示例 2：\n * \n * \n * 输入：root = []\n * 输出：[]\n * \n * \n * 示例 3：\n * \n * \n * 输入：root = [1]\n * 输出：[1]\n * \n * \n * \n * \n * 提示：\n * \n * \n * 树中节点数目在范围 [0, 100] 内\n * -100 <= Node.val <= 100\n * \n * \n * \n * \n * 进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n * \n */\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n```\n\n```cpp\n#include<stack>\n#include<vector>\n\n struct TreeNode {\n    int val;\n      TreeNode *left; \n      TreeNode *right;\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n };\n\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        std::stack<TreeNode*>  treeStack ;\n        std::vector<int> nodes;\n\n        while (root || !treeStack.empty()){\n            if (root){\n                treeStack.push(root);\n                root = root->left;\n\n            }else {\n                root = treeStack.top();\n                treeStack.pop();\n                nodes.push_back(root -> val);\n                root = root -> right;\n\n            }\n        }\n        return nodes;\n\n    }\n};\n\n// @lc code=end\n```","source":"_posts/leetcode/94.二叉树的中序遍历.md","raw":"---\ntitle: 94.二叉树的中序排序\ncategories: \n  - leetcode\n  - leetcode题解\n---\n\n\n\n```text\n/*\n * @lc app=leetcode.cn id=94 lang=cpp\n *\n * [94] 二叉树的中序遍历\n *\n * https://leetcode.cn/problems/binary-tree-inorder-traversal/description/\n *\n * algorithms\n * Easy (75.91%)\n * Likes:    1465\n * Dislikes: 0\n * Total Accepted:    855.6K\n * Total Submissions: 1.1M\n * Testcase Example:  '[1,null,2,3]'\n *\n * 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n * \n * \n * \n * 示例 1：\n * \n * \n * 输入：root = [1,null,2,3]\n * 输出：[1,3,2]\n * \n * \n * 示例 2：\n * \n * \n * 输入：root = []\n * 输出：[]\n * \n * \n * 示例 3：\n * \n * \n * 输入：root = [1]\n * 输出：[1]\n * \n * \n * \n * \n * 提示：\n * \n * \n * 树中节点数目在范围 [0, 100] 内\n * -100 <= Node.val <= 100\n * \n * \n * \n * \n * 进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n * \n */\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n```\n\n```cpp\n#include<stack>\n#include<vector>\n\n struct TreeNode {\n    int val;\n      TreeNode *left; \n      TreeNode *right;\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n };\n\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        std::stack<TreeNode*>  treeStack ;\n        std::vector<int> nodes;\n\n        while (root || !treeStack.empty()){\n            if (root){\n                treeStack.push(root);\n                root = root->left;\n\n            }else {\n                root = treeStack.top();\n                treeStack.pop();\n                nodes.push_back(root -> val);\n                root = root -> right;\n\n            }\n        }\n        return nodes;\n\n    }\n};\n\n// @lc code=end\n```","slug":"leetcode/94.二叉树的中序遍历","published":1,"date":"2022-06-22T16:10:00.241Z","updated":"2022-06-23T23:40:09.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu61002bl1db3shnh1vk","content":"<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">/*\n * @lc app=leetcode.cn id=94 lang=cpp\n *\n * [94] 二叉树的中序遍历\n *\n * https://leetcode.cn/problems/binary-tree-inorder-traversal/description/\n *\n * algorithms\n * Easy (75.91%)\n * Likes:    1465\n * Dislikes: 0\n * Total Accepted:    855.6K\n * Total Submissions: 1.1M\n * Testcase Example:  '[1,null,2,3]'\n *\n * 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n * \n * \n * \n * 示例 1：\n * \n * \n * 输入：root = [1,null,2,3]\n * 输出：[1,3,2]\n * \n * \n * 示例 2：\n * \n * \n * 输入：root = []\n * 输出：[]\n * \n * \n * 示例 3：\n * \n * \n * 输入：root = [1]\n * 输出：[1]\n * \n * \n * \n * \n * 提示：\n * \n * \n * 树中节点数目在范围 [0, 100] 内\n * -100 &lt;= Node.val &lt;= 100\n * \n * \n * \n * \n * 进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n * \n */\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n */\n</code></pre>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stack></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;vector></span></span>\n\n <span class=\"token keyword\">struct</span> <span class=\"token class-name\">TreeNode</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n      TreeNode <span class=\"token operator\">*</span>left<span class=\"token punctuation\">;</span> \n      TreeNode <span class=\"token operator\">*</span>right<span class=\"token punctuation\">;</span>\n      <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">left</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">right</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n      <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">left</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">right</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n      <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> TreeNode <span class=\"token operator\">*</span>left<span class=\"token punctuation\">,</span> TreeNode <span class=\"token operator\">*</span>right<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">left</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">right</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">inorderTraversal</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        std<span class=\"token double-colon punctuation\">::</span>stack<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span>  treeStack <span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nodes<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>treeStack<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                treeStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                root <span class=\"token operator\">=</span> root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                root <span class=\"token operator\">=</span> treeStack<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                treeStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                nodes<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>root <span class=\"token operator\">-></span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                root <span class=\"token operator\">=</span> root <span class=\"token operator\">-></span> right<span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> nodes<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// @lc code=end</span></code></pre>","site":{"data":{}},"excerpt":"","more":"<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">/*\n * @lc app=leetcode.cn id=94 lang=cpp\n *\n * [94] 二叉树的中序遍历\n *\n * https://leetcode.cn/problems/binary-tree-inorder-traversal/description/\n *\n * algorithms\n * Easy (75.91%)\n * Likes:    1465\n * Dislikes: 0\n * Total Accepted:    855.6K\n * Total Submissions: 1.1M\n * Testcase Example:  '[1,null,2,3]'\n *\n * 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n * \n * \n * \n * 示例 1：\n * \n * \n * 输入：root = [1,null,2,3]\n * 输出：[1,3,2]\n * \n * \n * 示例 2：\n * \n * \n * 输入：root = []\n * 输出：[]\n * \n * \n * 示例 3：\n * \n * \n * 输入：root = [1]\n * 输出：[1]\n * \n * \n * \n * \n * 提示：\n * \n * \n * 树中节点数目在范围 [0, 100] 内\n * -100 &lt;= Node.val &lt;= 100\n * \n * \n * \n * \n * 进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n * \n */\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n */\n</code></pre>\n\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stack></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;vector></span></span>\n\n <span class=\"token keyword\">struct</span> <span class=\"token class-name\">TreeNode</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n      TreeNode <span class=\"token operator\">*</span>left<span class=\"token punctuation\">;</span> \n      TreeNode <span class=\"token operator\">*</span>right<span class=\"token punctuation\">;</span>\n      <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">left</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">right</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n      <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">left</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">right</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n      <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> TreeNode <span class=\"token operator\">*</span>left<span class=\"token punctuation\">,</span> TreeNode <span class=\"token operator\">*</span>right<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">left</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">right</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">inorderTraversal</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        std<span class=\"token double-colon punctuation\">::</span>stack<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span>  treeStack <span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nodes<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>treeStack<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                treeStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                root <span class=\"token operator\">=</span> root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                root <span class=\"token operator\">=</span> treeStack<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                treeStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                nodes<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>root <span class=\"token operator\">-></span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                root <span class=\"token operator\">=</span> root <span class=\"token operator\">-></span> right<span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> nodes<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// @lc code=end</span></code></pre>"},{"title":"深入浅出_Oracle_DBA_入门_进阶与诊断案例","_content":"\n\n# 1. 数据库额启动与关闭\n\noracle server分为两部分(database: 这部分是指文件系统上的数据，instance则是指后台运行的线程和部分共享内存)。  \n并且数据启动分为三部分：1. `nomount`  2. `mount`  3. `open` 状态\n\n1. 启动到nomount状态","source":"_posts/oracle/深入浅出_Oracle_DBA_入门_进阶与诊断案例.md","raw":"---\ntitle: 深入浅出_Oracle_DBA_入门_进阶与诊断案例\ncategories:\n- Oracle\ntag: Oracle\n---\n\n\n# 1. 数据库额启动与关闭\n\noracle server分为两部分(database: 这部分是指文件系统上的数据，instance则是指后台运行的线程和部分共享内存)。  \n并且数据启动分为三部分：1. `nomount`  2. `mount`  3. `open` 状态\n\n1. 启动到nomount状态","slug":"oracle/深入浅出_Oracle_DBA_入门_进阶与诊断案例","published":1,"date":"2022-08-31T09:35:04.687Z","updated":"2022-08-31T09:44:50.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu62002cl1db6mfwbfrb","content":"<h1 id=\"1-数据库额启动与关闭\"><a href=\"#1-数据库额启动与关闭\" class=\"headerlink\" title=\"1. 数据库额启动与关闭\"></a>1. 数据库额启动与关闭</h1><p>oracle server分为两部分(database: 这部分是指文件系统上的数据，instance则是指后台运行的线程和部分共享内存)。<br>并且数据启动分为三部分：1. <code>nomount</code>  2. <code>mount</code>  3. <code>open</code> 状态</p>\n<ol>\n<li>启动到nomount状态</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-数据库额启动与关闭\"><a href=\"#1-数据库额启动与关闭\" class=\"headerlink\" title=\"1. 数据库额启动与关闭\"></a>1. 数据库额启动与关闭</h1><p>oracle server分为两部分(database: 这部分是指文件系统上的数据，instance则是指后台运行的线程和部分共享内存)。<br>并且数据启动分为三部分：1. <code>nomount</code>  2. <code>mount</code>  3. <code>open</code> 状态</p>\n<ol>\n<li>启动到nomount状态</li>\n</ol>\n"},{"title":"从0到1:开启商业与未来的秘密","_content":"\n\n## 第八章:秘密\n\n还记得我们的反主流问题吗：在什么重要问题上你与其他人有不同看法？如果我们今天对自然的了解已经达到未来才能达到的程度，如果今天所有的真理已被领悟，如果再无秘密可探索，那么这个问题就寻不到好答案。除非世界上还有秘密有待发现，否则与众不同的想法就毫无意义。 如果世界上还有很多秘密，那就还可能出现很多有望改变世界的企业.\n\n```text\n作者提出一个模型。 尝试（不是秘密） 困难（有秘密要探索）不可能（验证弦理论），\n人们可以完成困难的事情，但是不能完成不可能的事情\n```\n\n## 8.1 为什么人们不探索发现秘密\n\n因为人类都愿意悲观的思考问题。四种社会趋势使人们不愿相信秘密\n\n1. 渐进主义：从小被教育只要学习考试规定的内容就可以了。不要做“出格”的事情\n2. 风险规避： 人之常情，探索秘密就会经历错误的选择。会花费时间思考和纠正。经受制度带来的压力。\n3. 自满：既然能享受现有成果，为什么还要探索秘密？\n4. 地球的扁平化：人们认为世界是平的，是高度一至的。如果发现新事物，难道世界其他地方的人就没发现吗？鉴于此想法，导致人不愿意去探索\n\n我们可以用一种乐观的方式来描述以上这些趋势带来的结果：创立任何狂热教派在今天看来都异想天开。而在40年前，人们更加认同这样一个观点——并不是所有知识都是众所周知的。从共产党到印度教克利须纳派，大多数人认为他们可以加入先锋觉醒组织，以得到一条指引自己前进的道路。如今极少有人对非正统观念持严肃认真的态度，主流认为这是进步的标志。现在，疯狂的异端教派越来越少，我们应该为之感到高兴，但是为了这一收获，我们付出了沉重的代价：丧失了对等待被挖掘的秘密的好奇之心。\n> 上面内容更像是作者对非主流思想的一种趋向，因为人们认为主流思想才是进步思想，二而对于非正统思想持一种抵触。这样的好处是，疯狂的异教徒少了，但也丢了挖掘秘密的好奇心\n\n## 8.2 恪守常规的世界\n\n不去发现秘密让人们的思想，认识，得不到良序的发展，没有人权，没有更多的自由。世界在发展，还有很多秘密仍需要发展。\n\n例如：在经济学上，因为人们过度相信市场经济，认为市场经济可以调控一切经济活动。但是2008年的经济危机。说明过度相信市场经济，市场泡沫会在某个阶段爆发出来。\n当一个公司不思进取就会慢慢像惠普一样，慢慢的被时代，环境，对手淘汰掉。\n\n## 8.3 相信秘密\n\n事实上还是有很多秘密存在，人们相信秘密的存在。因为这个世界还有很多问题存在，因为问题的存在，以及人们追求高效，简单，快捷处理问题的速求，以及这背后带来的巨大财富，促使人们去寻找解决问题的出路，并坚定的选择去探索秘密。\n在工程，科学还有很多事情要去做，商业也是如此，它建立在这个世界的开放未知的秘密之上，这个秘密关乎世界如何运作，也是因为相信秘密的存在促成很多大公司的建立，以及源源不断的新公司的成立\n\n## 8.4 发现秘密\n\n- 自然的密码\n- 人的秘密\n\n当你要创建公司的时候要问自己两个秘密，哪些自然秘密还是未知的，哪些人的秘密是未知的。作者举了个物理学博士面试工程师的故事来说明，不要以为自己理解专业知识丰富而忽略了人的因素.\n\n```text\n不记得在哪里看到过一句话，做成事情，要满足明面的规则，也要满足潜规则。硬性技能和软技能，都要把握住。\n```\n\n## 8.5 秘密的作用\n\n所有伟大的公司都是都是基于鲜为人知的秘密创立的。当你与人分享你的秘密的时候就会招来竞争者\n\n```text\n当你想阐述的答案与大众价值观相左，就不要人人皆知，和不告诉别人之间有个平衡点，这个平衡点会将帮助你达成目标------ 发现秘密\n```\n\n秘密能将你引向鲜花和掌声，以及带来荣誉，将你带向耀眼月亮。选择那条崎岖，隐晦的路吧。\n\n## 第九章:基础决定命运\n\n最近有个想法一直浮现在脑海中“在世界上的所有知识当中，抑或是自己选择的道路所需要的知识，都应该是有个‘根’知识，这个‘根’知识很重要，它是学习其他知识的基础，影响着你吸取其他知识”。一开始就要打好基础，一个一个的过，不要有侥幸心理，在开始做的时候就要做到尽善尽美\n\n## 9.1 初创时的“联姻”\n\n如果个人能力不行，就需要与其他人合作，这话说起来简单，但有诸多细节需要探讨，比如这个人的脾气，性格等等。随时都可能导致某人与团队不和，进而使工作无法推荐所以作者在投资一家公司时候会看领导层的硬实力，也就是专业技能，和他们之间的默契程度，他们要有深厚交情.\n\n## 9.2 所有权，股权，控制权\n\n要做好这三个权力的分配。如果想控制公司，要保证董事会人数尽可能的少\n\n## 9.3 要么上车，要么下车\n\n作者的这个观点我不太认同，那跨国公司，不同国家间不同人群的协同工作，有些公司也可做的很好\n\n## 9.4 现金奖励不是王道\n\n这点作者的意思在初创时候，不要给太多的现金来捆绑住员工的忠诚度。因为给的钱多，很可能会将公司掏空.\n\n## 9.5 股票激励才能使员工全力以赴\n\n股票流通差，站在员工角度其实就是在赌这个公司的运气，因为公司破产股票就一文不值。站在老板角度就是在让员工与公司共成长。进而也减少现金开销\n\n## 9.6 让创业延续\n\n最有价值的公司始终鼓励发明创造，之前度过相关的文章是说微创新，在企业内部创业。如果每次创业实际恰当，使公司向着创新道路发展。进而无限创业下去。  \n> 居家办公或者在办公室办公也好。大家都会产生些许许摩擦，如何团结团队凝聚力这也是个关键问题，就像是实际工作中，如果把team给你管理，你是否可以推动工作前进呢？需要后面学习别人如何处理团队人事相关问题。别指望少付出还能持续创收，管理会碰到麻烦，但不应害怕，专注解决人，和工作上的问题\n","source":"_posts/随笔/从0到1_开启商业与未来的秘密.md","raw":"---\ntitle: 从0到1:开启商业与未来的秘密\ncategories:\n- 非技术类\ntag: 非技术类\n---\n\n\n## 第八章:秘密\n\n还记得我们的反主流问题吗：在什么重要问题上你与其他人有不同看法？如果我们今天对自然的了解已经达到未来才能达到的程度，如果今天所有的真理已被领悟，如果再无秘密可探索，那么这个问题就寻不到好答案。除非世界上还有秘密有待发现，否则与众不同的想法就毫无意义。 如果世界上还有很多秘密，那就还可能出现很多有望改变世界的企业.\n\n```text\n作者提出一个模型。 尝试（不是秘密） 困难（有秘密要探索）不可能（验证弦理论），\n人们可以完成困难的事情，但是不能完成不可能的事情\n```\n\n## 8.1 为什么人们不探索发现秘密\n\n因为人类都愿意悲观的思考问题。四种社会趋势使人们不愿相信秘密\n\n1. 渐进主义：从小被教育只要学习考试规定的内容就可以了。不要做“出格”的事情\n2. 风险规避： 人之常情，探索秘密就会经历错误的选择。会花费时间思考和纠正。经受制度带来的压力。\n3. 自满：既然能享受现有成果，为什么还要探索秘密？\n4. 地球的扁平化：人们认为世界是平的，是高度一至的。如果发现新事物，难道世界其他地方的人就没发现吗？鉴于此想法，导致人不愿意去探索\n\n我们可以用一种乐观的方式来描述以上这些趋势带来的结果：创立任何狂热教派在今天看来都异想天开。而在40年前，人们更加认同这样一个观点——并不是所有知识都是众所周知的。从共产党到印度教克利须纳派，大多数人认为他们可以加入先锋觉醒组织，以得到一条指引自己前进的道路。如今极少有人对非正统观念持严肃认真的态度，主流认为这是进步的标志。现在，疯狂的异端教派越来越少，我们应该为之感到高兴，但是为了这一收获，我们付出了沉重的代价：丧失了对等待被挖掘的秘密的好奇之心。\n> 上面内容更像是作者对非主流思想的一种趋向，因为人们认为主流思想才是进步思想，二而对于非正统思想持一种抵触。这样的好处是，疯狂的异教徒少了，但也丢了挖掘秘密的好奇心\n\n## 8.2 恪守常规的世界\n\n不去发现秘密让人们的思想，认识，得不到良序的发展，没有人权，没有更多的自由。世界在发展，还有很多秘密仍需要发展。\n\n例如：在经济学上，因为人们过度相信市场经济，认为市场经济可以调控一切经济活动。但是2008年的经济危机。说明过度相信市场经济，市场泡沫会在某个阶段爆发出来。\n当一个公司不思进取就会慢慢像惠普一样，慢慢的被时代，环境，对手淘汰掉。\n\n## 8.3 相信秘密\n\n事实上还是有很多秘密存在，人们相信秘密的存在。因为这个世界还有很多问题存在，因为问题的存在，以及人们追求高效，简单，快捷处理问题的速求，以及这背后带来的巨大财富，促使人们去寻找解决问题的出路，并坚定的选择去探索秘密。\n在工程，科学还有很多事情要去做，商业也是如此，它建立在这个世界的开放未知的秘密之上，这个秘密关乎世界如何运作，也是因为相信秘密的存在促成很多大公司的建立，以及源源不断的新公司的成立\n\n## 8.4 发现秘密\n\n- 自然的密码\n- 人的秘密\n\n当你要创建公司的时候要问自己两个秘密，哪些自然秘密还是未知的，哪些人的秘密是未知的。作者举了个物理学博士面试工程师的故事来说明，不要以为自己理解专业知识丰富而忽略了人的因素.\n\n```text\n不记得在哪里看到过一句话，做成事情，要满足明面的规则，也要满足潜规则。硬性技能和软技能，都要把握住。\n```\n\n## 8.5 秘密的作用\n\n所有伟大的公司都是都是基于鲜为人知的秘密创立的。当你与人分享你的秘密的时候就会招来竞争者\n\n```text\n当你想阐述的答案与大众价值观相左，就不要人人皆知，和不告诉别人之间有个平衡点，这个平衡点会将帮助你达成目标------ 发现秘密\n```\n\n秘密能将你引向鲜花和掌声，以及带来荣誉，将你带向耀眼月亮。选择那条崎岖，隐晦的路吧。\n\n## 第九章:基础决定命运\n\n最近有个想法一直浮现在脑海中“在世界上的所有知识当中，抑或是自己选择的道路所需要的知识，都应该是有个‘根’知识，这个‘根’知识很重要，它是学习其他知识的基础，影响着你吸取其他知识”。一开始就要打好基础，一个一个的过，不要有侥幸心理，在开始做的时候就要做到尽善尽美\n\n## 9.1 初创时的“联姻”\n\n如果个人能力不行，就需要与其他人合作，这话说起来简单，但有诸多细节需要探讨，比如这个人的脾气，性格等等。随时都可能导致某人与团队不和，进而使工作无法推荐所以作者在投资一家公司时候会看领导层的硬实力，也就是专业技能，和他们之间的默契程度，他们要有深厚交情.\n\n## 9.2 所有权，股权，控制权\n\n要做好这三个权力的分配。如果想控制公司，要保证董事会人数尽可能的少\n\n## 9.3 要么上车，要么下车\n\n作者的这个观点我不太认同，那跨国公司，不同国家间不同人群的协同工作，有些公司也可做的很好\n\n## 9.4 现金奖励不是王道\n\n这点作者的意思在初创时候，不要给太多的现金来捆绑住员工的忠诚度。因为给的钱多，很可能会将公司掏空.\n\n## 9.5 股票激励才能使员工全力以赴\n\n股票流通差，站在员工角度其实就是在赌这个公司的运气，因为公司破产股票就一文不值。站在老板角度就是在让员工与公司共成长。进而也减少现金开销\n\n## 9.6 让创业延续\n\n最有价值的公司始终鼓励发明创造，之前度过相关的文章是说微创新，在企业内部创业。如果每次创业实际恰当，使公司向着创新道路发展。进而无限创业下去。  \n> 居家办公或者在办公室办公也好。大家都会产生些许许摩擦，如何团结团队凝聚力这也是个关键问题，就像是实际工作中，如果把team给你管理，你是否可以推动工作前进呢？需要后面学习别人如何处理团队人事相关问题。别指望少付出还能持续创收，管理会碰到麻烦，但不应害怕，专注解决人，和工作上的问题\n","slug":"随笔/从0到1_开启商业与未来的秘密","published":1,"date":"2022-06-22T12:51:26.461Z","updated":"2022-06-22T13:57:12.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu62002fl1db9cq5hxxw","content":"<h2 id=\"第八章-秘密\"><a href=\"#第八章-秘密\" class=\"headerlink\" title=\"第八章:秘密\"></a>第八章:秘密</h2><p>还记得我们的反主流问题吗：在什么重要问题上你与其他人有不同看法？如果我们今天对自然的了解已经达到未来才能达到的程度，如果今天所有的真理已被领悟，如果再无秘密可探索，那么这个问题就寻不到好答案。除非世界上还有秘密有待发现，否则与众不同的想法就毫无意义。 如果世界上还有很多秘密，那就还可能出现很多有望改变世界的企业.</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">作者提出一个模型。 尝试（不是秘密） 困难（有秘密要探索）不可能（验证弦理论），\n人们可以完成困难的事情，但是不能完成不可能的事情</code></pre>\n\n<h2 id=\"8-1-为什么人们不探索发现秘密\"><a href=\"#8-1-为什么人们不探索发现秘密\" class=\"headerlink\" title=\"8.1 为什么人们不探索发现秘密\"></a>8.1 为什么人们不探索发现秘密</h2><p>因为人类都愿意悲观的思考问题。四种社会趋势使人们不愿相信秘密</p>\n<ol>\n<li>渐进主义：从小被教育只要学习考试规定的内容就可以了。不要做“出格”的事情</li>\n<li>风险规避： 人之常情，探索秘密就会经历错误的选择。会花费时间思考和纠正。经受制度带来的压力。</li>\n<li>自满：既然能享受现有成果，为什么还要探索秘密？</li>\n<li>地球的扁平化：人们认为世界是平的，是高度一至的。如果发现新事物，难道世界其他地方的人就没发现吗？鉴于此想法，导致人不愿意去探索</li>\n</ol>\n<p>我们可以用一种乐观的方式来描述以上这些趋势带来的结果：创立任何狂热教派在今天看来都异想天开。而在40年前，人们更加认同这样一个观点——并不是所有知识都是众所周知的。从共产党到印度教克利须纳派，大多数人认为他们可以加入先锋觉醒组织，以得到一条指引自己前进的道路。如今极少有人对非正统观念持严肃认真的态度，主流认为这是进步的标志。现在，疯狂的异端教派越来越少，我们应该为之感到高兴，但是为了这一收获，我们付出了沉重的代价：丧失了对等待被挖掘的秘密的好奇之心。</p>\n<blockquote>\n<p>上面内容更像是作者对非主流思想的一种趋向，因为人们认为主流思想才是进步思想，二而对于非正统思想持一种抵触。这样的好处是，疯狂的异教徒少了，但也丢了挖掘秘密的好奇心</p>\n</blockquote>\n<h2 id=\"8-2-恪守常规的世界\"><a href=\"#8-2-恪守常规的世界\" class=\"headerlink\" title=\"8.2 恪守常规的世界\"></a>8.2 恪守常规的世界</h2><p>不去发现秘密让人们的思想，认识，得不到良序的发展，没有人权，没有更多的自由。世界在发展，还有很多秘密仍需要发展。</p>\n<p>例如：在经济学上，因为人们过度相信市场经济，认为市场经济可以调控一切经济活动。但是2008年的经济危机。说明过度相信市场经济，市场泡沫会在某个阶段爆发出来。<br>当一个公司不思进取就会慢慢像惠普一样，慢慢的被时代，环境，对手淘汰掉。</p>\n<h2 id=\"8-3-相信秘密\"><a href=\"#8-3-相信秘密\" class=\"headerlink\" title=\"8.3 相信秘密\"></a>8.3 相信秘密</h2><p>事实上还是有很多秘密存在，人们相信秘密的存在。因为这个世界还有很多问题存在，因为问题的存在，以及人们追求高效，简单，快捷处理问题的速求，以及这背后带来的巨大财富，促使人们去寻找解决问题的出路，并坚定的选择去探索秘密。<br>在工程，科学还有很多事情要去做，商业也是如此，它建立在这个世界的开放未知的秘密之上，这个秘密关乎世界如何运作，也是因为相信秘密的存在促成很多大公司的建立，以及源源不断的新公司的成立</p>\n<h2 id=\"8-4-发现秘密\"><a href=\"#8-4-发现秘密\" class=\"headerlink\" title=\"8.4 发现秘密\"></a>8.4 发现秘密</h2><ul>\n<li>自然的密码</li>\n<li>人的秘密</li>\n</ul>\n<p>当你要创建公司的时候要问自己两个秘密，哪些自然秘密还是未知的，哪些人的秘密是未知的。作者举了个物理学博士面试工程师的故事来说明，不要以为自己理解专业知识丰富而忽略了人的因素.</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">不记得在哪里看到过一句话，做成事情，要满足明面的规则，也要满足潜规则。硬性技能和软技能，都要把握住。</code></pre>\n\n<h2 id=\"8-5-秘密的作用\"><a href=\"#8-5-秘密的作用\" class=\"headerlink\" title=\"8.5 秘密的作用\"></a>8.5 秘密的作用</h2><p>所有伟大的公司都是都是基于鲜为人知的秘密创立的。当你与人分享你的秘密的时候就会招来竞争者</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">当你想阐述的答案与大众价值观相左，就不要人人皆知，和不告诉别人之间有个平衡点，这个平衡点会将帮助你达成目标------ 发现秘密</code></pre>\n\n<p>秘密能将你引向鲜花和掌声，以及带来荣誉，将你带向耀眼月亮。选择那条崎岖，隐晦的路吧。</p>\n<h2 id=\"第九章-基础决定命运\"><a href=\"#第九章-基础决定命运\" class=\"headerlink\" title=\"第九章:基础决定命运\"></a>第九章:基础决定命运</h2><p>最近有个想法一直浮现在脑海中“在世界上的所有知识当中，抑或是自己选择的道路所需要的知识，都应该是有个‘根’知识，这个‘根’知识很重要，它是学习其他知识的基础，影响着你吸取其他知识”。一开始就要打好基础，一个一个的过，不要有侥幸心理，在开始做的时候就要做到尽善尽美</p>\n<h2 id=\"9-1-初创时的“联姻”\"><a href=\"#9-1-初创时的“联姻”\" class=\"headerlink\" title=\"9.1 初创时的“联姻”\"></a>9.1 初创时的“联姻”</h2><p>如果个人能力不行，就需要与其他人合作，这话说起来简单，但有诸多细节需要探讨，比如这个人的脾气，性格等等。随时都可能导致某人与团队不和，进而使工作无法推荐所以作者在投资一家公司时候会看领导层的硬实力，也就是专业技能，和他们之间的默契程度，他们要有深厚交情.</p>\n<h2 id=\"9-2-所有权，股权，控制权\"><a href=\"#9-2-所有权，股权，控制权\" class=\"headerlink\" title=\"9.2 所有权，股权，控制权\"></a>9.2 所有权，股权，控制权</h2><p>要做好这三个权力的分配。如果想控制公司，要保证董事会人数尽可能的少</p>\n<h2 id=\"9-3-要么上车，要么下车\"><a href=\"#9-3-要么上车，要么下车\" class=\"headerlink\" title=\"9.3 要么上车，要么下车\"></a>9.3 要么上车，要么下车</h2><p>作者的这个观点我不太认同，那跨国公司，不同国家间不同人群的协同工作，有些公司也可做的很好</p>\n<h2 id=\"9-4-现金奖励不是王道\"><a href=\"#9-4-现金奖励不是王道\" class=\"headerlink\" title=\"9.4 现金奖励不是王道\"></a>9.4 现金奖励不是王道</h2><p>这点作者的意思在初创时候，不要给太多的现金来捆绑住员工的忠诚度。因为给的钱多，很可能会将公司掏空.</p>\n<h2 id=\"9-5-股票激励才能使员工全力以赴\"><a href=\"#9-5-股票激励才能使员工全力以赴\" class=\"headerlink\" title=\"9.5 股票激励才能使员工全力以赴\"></a>9.5 股票激励才能使员工全力以赴</h2><p>股票流通差，站在员工角度其实就是在赌这个公司的运气，因为公司破产股票就一文不值。站在老板角度就是在让员工与公司共成长。进而也减少现金开销</p>\n<h2 id=\"9-6-让创业延续\"><a href=\"#9-6-让创业延续\" class=\"headerlink\" title=\"9.6 让创业延续\"></a>9.6 让创业延续</h2><p>最有价值的公司始终鼓励发明创造，之前度过相关的文章是说微创新，在企业内部创业。如果每次创业实际恰当，使公司向着创新道路发展。进而无限创业下去。  </p>\n<blockquote>\n<p>居家办公或者在办公室办公也好。大家都会产生些许许摩擦，如何团结团队凝聚力这也是个关键问题，就像是实际工作中，如果把team给你管理，你是否可以推动工作前进呢？需要后面学习别人如何处理团队人事相关问题。别指望少付出还能持续创收，管理会碰到麻烦，但不应害怕，专注解决人，和工作上的问题</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第八章-秘密\"><a href=\"#第八章-秘密\" class=\"headerlink\" title=\"第八章:秘密\"></a>第八章:秘密</h2><p>还记得我们的反主流问题吗：在什么重要问题上你与其他人有不同看法？如果我们今天对自然的了解已经达到未来才能达到的程度，如果今天所有的真理已被领悟，如果再无秘密可探索，那么这个问题就寻不到好答案。除非世界上还有秘密有待发现，否则与众不同的想法就毫无意义。 如果世界上还有很多秘密，那就还可能出现很多有望改变世界的企业.</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">作者提出一个模型。 尝试（不是秘密） 困难（有秘密要探索）不可能（验证弦理论），\n人们可以完成困难的事情，但是不能完成不可能的事情</code></pre>\n\n<h2 id=\"8-1-为什么人们不探索发现秘密\"><a href=\"#8-1-为什么人们不探索发现秘密\" class=\"headerlink\" title=\"8.1 为什么人们不探索发现秘密\"></a>8.1 为什么人们不探索发现秘密</h2><p>因为人类都愿意悲观的思考问题。四种社会趋势使人们不愿相信秘密</p>\n<ol>\n<li>渐进主义：从小被教育只要学习考试规定的内容就可以了。不要做“出格”的事情</li>\n<li>风险规避： 人之常情，探索秘密就会经历错误的选择。会花费时间思考和纠正。经受制度带来的压力。</li>\n<li>自满：既然能享受现有成果，为什么还要探索秘密？</li>\n<li>地球的扁平化：人们认为世界是平的，是高度一至的。如果发现新事物，难道世界其他地方的人就没发现吗？鉴于此想法，导致人不愿意去探索</li>\n</ol>\n<p>我们可以用一种乐观的方式来描述以上这些趋势带来的结果：创立任何狂热教派在今天看来都异想天开。而在40年前，人们更加认同这样一个观点——并不是所有知识都是众所周知的。从共产党到印度教克利须纳派，大多数人认为他们可以加入先锋觉醒组织，以得到一条指引自己前进的道路。如今极少有人对非正统观念持严肃认真的态度，主流认为这是进步的标志。现在，疯狂的异端教派越来越少，我们应该为之感到高兴，但是为了这一收获，我们付出了沉重的代价：丧失了对等待被挖掘的秘密的好奇之心。</p>\n<blockquote>\n<p>上面内容更像是作者对非主流思想的一种趋向，因为人们认为主流思想才是进步思想，二而对于非正统思想持一种抵触。这样的好处是，疯狂的异教徒少了，但也丢了挖掘秘密的好奇心</p>\n</blockquote>\n<h2 id=\"8-2-恪守常规的世界\"><a href=\"#8-2-恪守常规的世界\" class=\"headerlink\" title=\"8.2 恪守常规的世界\"></a>8.2 恪守常规的世界</h2><p>不去发现秘密让人们的思想，认识，得不到良序的发展，没有人权，没有更多的自由。世界在发展，还有很多秘密仍需要发展。</p>\n<p>例如：在经济学上，因为人们过度相信市场经济，认为市场经济可以调控一切经济活动。但是2008年的经济危机。说明过度相信市场经济，市场泡沫会在某个阶段爆发出来。<br>当一个公司不思进取就会慢慢像惠普一样，慢慢的被时代，环境，对手淘汰掉。</p>\n<h2 id=\"8-3-相信秘密\"><a href=\"#8-3-相信秘密\" class=\"headerlink\" title=\"8.3 相信秘密\"></a>8.3 相信秘密</h2><p>事实上还是有很多秘密存在，人们相信秘密的存在。因为这个世界还有很多问题存在，因为问题的存在，以及人们追求高效，简单，快捷处理问题的速求，以及这背后带来的巨大财富，促使人们去寻找解决问题的出路，并坚定的选择去探索秘密。<br>在工程，科学还有很多事情要去做，商业也是如此，它建立在这个世界的开放未知的秘密之上，这个秘密关乎世界如何运作，也是因为相信秘密的存在促成很多大公司的建立，以及源源不断的新公司的成立</p>\n<h2 id=\"8-4-发现秘密\"><a href=\"#8-4-发现秘密\" class=\"headerlink\" title=\"8.4 发现秘密\"></a>8.4 发现秘密</h2><ul>\n<li>自然的密码</li>\n<li>人的秘密</li>\n</ul>\n<p>当你要创建公司的时候要问自己两个秘密，哪些自然秘密还是未知的，哪些人的秘密是未知的。作者举了个物理学博士面试工程师的故事来说明，不要以为自己理解专业知识丰富而忽略了人的因素.</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">不记得在哪里看到过一句话，做成事情，要满足明面的规则，也要满足潜规则。硬性技能和软技能，都要把握住。</code></pre>\n\n<h2 id=\"8-5-秘密的作用\"><a href=\"#8-5-秘密的作用\" class=\"headerlink\" title=\"8.5 秘密的作用\"></a>8.5 秘密的作用</h2><p>所有伟大的公司都是都是基于鲜为人知的秘密创立的。当你与人分享你的秘密的时候就会招来竞争者</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">当你想阐述的答案与大众价值观相左，就不要人人皆知，和不告诉别人之间有个平衡点，这个平衡点会将帮助你达成目标------ 发现秘密</code></pre>\n\n<p>秘密能将你引向鲜花和掌声，以及带来荣誉，将你带向耀眼月亮。选择那条崎岖，隐晦的路吧。</p>\n<h2 id=\"第九章-基础决定命运\"><a href=\"#第九章-基础决定命运\" class=\"headerlink\" title=\"第九章:基础决定命运\"></a>第九章:基础决定命运</h2><p>最近有个想法一直浮现在脑海中“在世界上的所有知识当中，抑或是自己选择的道路所需要的知识，都应该是有个‘根’知识，这个‘根’知识很重要，它是学习其他知识的基础，影响着你吸取其他知识”。一开始就要打好基础，一个一个的过，不要有侥幸心理，在开始做的时候就要做到尽善尽美</p>\n<h2 id=\"9-1-初创时的“联姻”\"><a href=\"#9-1-初创时的“联姻”\" class=\"headerlink\" title=\"9.1 初创时的“联姻”\"></a>9.1 初创时的“联姻”</h2><p>如果个人能力不行，就需要与其他人合作，这话说起来简单，但有诸多细节需要探讨，比如这个人的脾气，性格等等。随时都可能导致某人与团队不和，进而使工作无法推荐所以作者在投资一家公司时候会看领导层的硬实力，也就是专业技能，和他们之间的默契程度，他们要有深厚交情.</p>\n<h2 id=\"9-2-所有权，股权，控制权\"><a href=\"#9-2-所有权，股权，控制权\" class=\"headerlink\" title=\"9.2 所有权，股权，控制权\"></a>9.2 所有权，股权，控制权</h2><p>要做好这三个权力的分配。如果想控制公司，要保证董事会人数尽可能的少</p>\n<h2 id=\"9-3-要么上车，要么下车\"><a href=\"#9-3-要么上车，要么下车\" class=\"headerlink\" title=\"9.3 要么上车，要么下车\"></a>9.3 要么上车，要么下车</h2><p>作者的这个观点我不太认同，那跨国公司，不同国家间不同人群的协同工作，有些公司也可做的很好</p>\n<h2 id=\"9-4-现金奖励不是王道\"><a href=\"#9-4-现金奖励不是王道\" class=\"headerlink\" title=\"9.4 现金奖励不是王道\"></a>9.4 现金奖励不是王道</h2><p>这点作者的意思在初创时候，不要给太多的现金来捆绑住员工的忠诚度。因为给的钱多，很可能会将公司掏空.</p>\n<h2 id=\"9-5-股票激励才能使员工全力以赴\"><a href=\"#9-5-股票激励才能使员工全力以赴\" class=\"headerlink\" title=\"9.5 股票激励才能使员工全力以赴\"></a>9.5 股票激励才能使员工全力以赴</h2><p>股票流通差，站在员工角度其实就是在赌这个公司的运气，因为公司破产股票就一文不值。站在老板角度就是在让员工与公司共成长。进而也减少现金开销</p>\n<h2 id=\"9-6-让创业延续\"><a href=\"#9-6-让创业延续\" class=\"headerlink\" title=\"9.6 让创业延续\"></a>9.6 让创业延续</h2><p>最有价值的公司始终鼓励发明创造，之前度过相关的文章是说微创新，在企业内部创业。如果每次创业实际恰当，使公司向着创新道路发展。进而无限创业下去。  </p>\n<blockquote>\n<p>居家办公或者在办公室办公也好。大家都会产生些许许摩擦，如何团结团队凝聚力这也是个关键问题，就像是实际工作中，如果把team给你管理，你是否可以推动工作前进呢？需要后面学习别人如何处理团队人事相关问题。别指望少付出还能持续创收，管理会碰到麻烦，但不应害怕，专注解决人，和工作上的问题</p>\n</blockquote>\n"},{"title":"多巴胺戒断","_content":"\n1. 主动，有意识的阶段多巴胺,确定量化目标\n2. 放下过去,向前看.\n3. 刻意练习，但是需要有笔记(康纳尔笔记)，有总结。大脑是可塑的就像，那片TED演讲那样(回头找找理清楚里面都讲了什么)。\n4. 冥想\n5. 动态调整,只专注做好几件事,任务是完成\n6. 关注自我,关注自我成长,多看到自己的进步,多做有价值的付出,多自我反馈，带来持续动力。","source":"_posts/随笔/多巴胺戒断.md","raw":"---\ntitle: 多巴胺戒断\ncategories:\n- 非技术类\ntag: 非技术类\n---\n\n1. 主动，有意识的阶段多巴胺,确定量化目标\n2. 放下过去,向前看.\n3. 刻意练习，但是需要有笔记(康纳尔笔记)，有总结。大脑是可塑的就像，那片TED演讲那样(回头找找理清楚里面都讲了什么)。\n4. 冥想\n5. 动态调整,只专注做好几件事,任务是完成\n6. 关注自我,关注自我成长,多看到自己的进步,多做有价值的付出,多自我反馈，带来持续动力。","slug":"随笔/多巴胺戒断","published":1,"date":"2022-08-04T15:08:38.548Z","updated":"2022-08-04T15:19:26.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu63002hl1db4rvdhcsq","content":"<ol>\n<li>主动，有意识的阶段多巴胺,确定量化目标</li>\n<li>放下过去,向前看.</li>\n<li>刻意练习，但是需要有笔记(康纳尔笔记)，有总结。大脑是可塑的就像，那片TED演讲那样(回头找找理清楚里面都讲了什么)。</li>\n<li>冥想</li>\n<li>动态调整,只专注做好几件事,任务是完成</li>\n<li>关注自我,关注自我成长,多看到自己的进步,多做有价值的付出,多自我反馈，带来持续动力。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>主动，有意识的阶段多巴胺,确定量化目标</li>\n<li>放下过去,向前看.</li>\n<li>刻意练习，但是需要有笔记(康纳尔笔记)，有总结。大脑是可塑的就像，那片TED演讲那样(回头找找理清楚里面都讲了什么)。</li>\n<li>冥想</li>\n<li>动态调整,只专注做好几件事,任务是完成</li>\n<li>关注自我,关注自我成长,多看到自己的进步,多做有价值的付出,多自我反馈，带来持续动力。</li>\n</ol>\n"},{"title":"如何在读研的道路上快速失败","_content":"原创:陈怡然 陈老师有话说\n\n1.  为自己找出一堆把其他个人兴趣爱好或者其他事情放在学习之上的理由：比如人活着就是为了享受生活，要事业家庭平衡之类（说真的，这是人生观问题。也许一开始你就根本不需要/不应该读研）；\n1.  认为很多必须要做的事情或者要解决的问题拖到最后会不了了之、奇迹般迎刃而解、或者导师会忘（这怎么可能）；\n1.  为导师不经常找自己而沾沾自喜（其实大部分时候那只是因为他觉得不值得在你身上瞎耽误功夫）；\n1.  花很多时间计算到底怎么做才能快速达到最低毕业要求赶紧毕业（易经：取法乎上，仅得其中；取法乎中，仅得其下）；\n1.  每次都指望从师兄师姐那里临时榨点什么以混过和导师的1-on-1（以为导师和师兄师姐傻啊？）；\n1.  总觉得别人做的东西简单容易上手好发文章，不断在不同的题目中跳来跳去（世上那有什么容易的东西，只有你看不到的努力）；\n1.  对导师和同学的建议与帮助出于本能的拒绝并试图证明别人是错的（自尊/自信/自负/自卑大多数时候其实我们自己不是那么容易分的清楚，但别人的善心只会offer一次）；\n1.  总觉得自己比别人聪明，研究做不出来或者文章总不中只是一时粗心或者运气不好（不断重复发生的事情其实就是规律）；\n1.  在每次觉得做不出来、或者做不完的时候玩消失，或者对更大、更复杂的任务说No（盖章：此人难当大任）；\n1.  每次都刚刚做到最低要求，把剩余的工作扔给导师或者合作的同学，并为自己节省下的时间和努力沾沾自喜（你可能还没认识到别人对你的支持永远和你自己的付出成正比这一事实）；\n1.  觉得自己很努力了，但是却怎么也达不到目标或者导师要求（如果确实不是你还有没有挤出来的时间，而你也不愿意承认自己确实不行，那么就多花点时间观察别人学习的方法和效率吧）；\n1.  开始承认自己确实不行，并把全部精力放在劝说老师降低标准放自己毕业上（你可能没理解这件事情的难度在于你要求他降低的是对所有人的标准，而不单单是对你自己的）；\n1.  觉得导师是个傻X（这个其实也不是没有可能。强扭的瓜不甜，我支持你用脚投票。或许到时双方都会大大的松了一口气，多年以后江湖再见还能把酒言欢).","source":"_posts/随笔/如何在读研的道路上快速失败.md","raw":"---\ntitle: 如何在读研的道路上快速失败\ncategories:\n- 非技术类\ntag: 非技术类\n---\n原创:陈怡然 陈老师有话说\n\n1.  为自己找出一堆把其他个人兴趣爱好或者其他事情放在学习之上的理由：比如人活着就是为了享受生活，要事业家庭平衡之类（说真的，这是人生观问题。也许一开始你就根本不需要/不应该读研）；\n1.  认为很多必须要做的事情或者要解决的问题拖到最后会不了了之、奇迹般迎刃而解、或者导师会忘（这怎么可能）；\n1.  为导师不经常找自己而沾沾自喜（其实大部分时候那只是因为他觉得不值得在你身上瞎耽误功夫）；\n1.  花很多时间计算到底怎么做才能快速达到最低毕业要求赶紧毕业（易经：取法乎上，仅得其中；取法乎中，仅得其下）；\n1.  每次都指望从师兄师姐那里临时榨点什么以混过和导师的1-on-1（以为导师和师兄师姐傻啊？）；\n1.  总觉得别人做的东西简单容易上手好发文章，不断在不同的题目中跳来跳去（世上那有什么容易的东西，只有你看不到的努力）；\n1.  对导师和同学的建议与帮助出于本能的拒绝并试图证明别人是错的（自尊/自信/自负/自卑大多数时候其实我们自己不是那么容易分的清楚，但别人的善心只会offer一次）；\n1.  总觉得自己比别人聪明，研究做不出来或者文章总不中只是一时粗心或者运气不好（不断重复发生的事情其实就是规律）；\n1.  在每次觉得做不出来、或者做不完的时候玩消失，或者对更大、更复杂的任务说No（盖章：此人难当大任）；\n1.  每次都刚刚做到最低要求，把剩余的工作扔给导师或者合作的同学，并为自己节省下的时间和努力沾沾自喜（你可能还没认识到别人对你的支持永远和你自己的付出成正比这一事实）；\n1.  觉得自己很努力了，但是却怎么也达不到目标或者导师要求（如果确实不是你还有没有挤出来的时间，而你也不愿意承认自己确实不行，那么就多花点时间观察别人学习的方法和效率吧）；\n1.  开始承认自己确实不行，并把全部精力放在劝说老师降低标准放自己毕业上（你可能没理解这件事情的难度在于你要求他降低的是对所有人的标准，而不单单是对你自己的）；\n1.  觉得导师是个傻X（这个其实也不是没有可能。强扭的瓜不甜，我支持你用脚投票。或许到时双方都会大大的松了一口气，多年以后江湖再见还能把酒言欢).","slug":"随笔/如何在读研的道路上快速失败","published":1,"date":"2022-06-22T13:14:38.581Z","updated":"2022-06-22T14:06:46.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu65002jl1dbbitj2075","content":"<p>原创:陈怡然 陈老师有话说</p>\n<ol>\n<li>为自己找出一堆把其他个人兴趣爱好或者其他事情放在学习之上的理由：比如人活着就是为了享受生活，要事业家庭平衡之类（说真的，这是人生观问题。也许一开始你就根本不需要&#x2F;不应该读研）；</li>\n<li>认为很多必须要做的事情或者要解决的问题拖到最后会不了了之、奇迹般迎刃而解、或者导师会忘（这怎么可能）；</li>\n<li>为导师不经常找自己而沾沾自喜（其实大部分时候那只是因为他觉得不值得在你身上瞎耽误功夫）；</li>\n<li>花很多时间计算到底怎么做才能快速达到最低毕业要求赶紧毕业（易经：取法乎上，仅得其中；取法乎中，仅得其下）；</li>\n<li>每次都指望从师兄师姐那里临时榨点什么以混过和导师的1-on-1（以为导师和师兄师姐傻啊？）；</li>\n<li>总觉得别人做的东西简单容易上手好发文章，不断在不同的题目中跳来跳去（世上那有什么容易的东西，只有你看不到的努力）；</li>\n<li>对导师和同学的建议与帮助出于本能的拒绝并试图证明别人是错的（自尊&#x2F;自信&#x2F;自负&#x2F;自卑大多数时候其实我们自己不是那么容易分的清楚，但别人的善心只会offer一次）；</li>\n<li>总觉得自己比别人聪明，研究做不出来或者文章总不中只是一时粗心或者运气不好（不断重复发生的事情其实就是规律）；</li>\n<li>在每次觉得做不出来、或者做不完的时候玩消失，或者对更大、更复杂的任务说No（盖章：此人难当大任）；</li>\n<li>每次都刚刚做到最低要求，把剩余的工作扔给导师或者合作的同学，并为自己节省下的时间和努力沾沾自喜（你可能还没认识到别人对你的支持永远和你自己的付出成正比这一事实）；</li>\n<li>觉得自己很努力了，但是却怎么也达不到目标或者导师要求（如果确实不是你还有没有挤出来的时间，而你也不愿意承认自己确实不行，那么就多花点时间观察别人学习的方法和效率吧）；</li>\n<li>开始承认自己确实不行，并把全部精力放在劝说老师降低标准放自己毕业上（你可能没理解这件事情的难度在于你要求他降低的是对所有人的标准，而不单单是对你自己的）；</li>\n<li>觉得导师是个傻X（这个其实也不是没有可能。强扭的瓜不甜，我支持你用脚投票。或许到时双方都会大大的松了一口气，多年以后江湖再见还能把酒言欢).</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>原创:陈怡然 陈老师有话说</p>\n<ol>\n<li>为自己找出一堆把其他个人兴趣爱好或者其他事情放在学习之上的理由：比如人活着就是为了享受生活，要事业家庭平衡之类（说真的，这是人生观问题。也许一开始你就根本不需要&#x2F;不应该读研）；</li>\n<li>认为很多必须要做的事情或者要解决的问题拖到最后会不了了之、奇迹般迎刃而解、或者导师会忘（这怎么可能）；</li>\n<li>为导师不经常找自己而沾沾自喜（其实大部分时候那只是因为他觉得不值得在你身上瞎耽误功夫）；</li>\n<li>花很多时间计算到底怎么做才能快速达到最低毕业要求赶紧毕业（易经：取法乎上，仅得其中；取法乎中，仅得其下）；</li>\n<li>每次都指望从师兄师姐那里临时榨点什么以混过和导师的1-on-1（以为导师和师兄师姐傻啊？）；</li>\n<li>总觉得别人做的东西简单容易上手好发文章，不断在不同的题目中跳来跳去（世上那有什么容易的东西，只有你看不到的努力）；</li>\n<li>对导师和同学的建议与帮助出于本能的拒绝并试图证明别人是错的（自尊&#x2F;自信&#x2F;自负&#x2F;自卑大多数时候其实我们自己不是那么容易分的清楚，但别人的善心只会offer一次）；</li>\n<li>总觉得自己比别人聪明，研究做不出来或者文章总不中只是一时粗心或者运气不好（不断重复发生的事情其实就是规律）；</li>\n<li>在每次觉得做不出来、或者做不完的时候玩消失，或者对更大、更复杂的任务说No（盖章：此人难当大任）；</li>\n<li>每次都刚刚做到最低要求，把剩余的工作扔给导师或者合作的同学，并为自己节省下的时间和努力沾沾自喜（你可能还没认识到别人对你的支持永远和你自己的付出成正比这一事实）；</li>\n<li>觉得自己很努力了，但是却怎么也达不到目标或者导师要求（如果确实不是你还有没有挤出来的时间，而你也不愿意承认自己确实不行，那么就多花点时间观察别人学习的方法和效率吧）；</li>\n<li>开始承认自己确实不行，并把全部精力放在劝说老师降低标准放自己毕业上（你可能没理解这件事情的难度在于你要求他降低的是对所有人的标准，而不单单是对你自己的）；</li>\n<li>觉得导师是个傻X（这个其实也不是没有可能。强扭的瓜不甜，我支持你用脚投票。或许到时双方都会大大的松了一口气，多年以后江湖再见还能把酒言欢).</li>\n</ol>\n"},{"title":"禅与摩托车维修艺术","_content":"\n# 第一部分\n\n1. \n\n- > 只要我一谈到摩托车维修的问题，他就会坐立不安。这样一来只会使我想更进一步地探索下去。并不是故意要激怒他，而是因为他的不安似乎象征了某些隐而未显的问题.当你谈到节育的时候，横亘在你们中间的并不是人口多寡的问题，那只是表象，真正起冲突的是信念。基督教看重的是实际的社会问题，而天主教徒则认为那是亵渎天主的权威。你可以滔滔不绝地阐述计划生育的重要性，一直到你自己都听烦了，却仍无法说服对方，因为他并不认为符合社会的实际需要有何好处，他自有比实用更重要的价值观\n\n    根本原因是价值观的问题。作者比较看重实际价值，而约翰是浪漫主义\n\n- > 在摩托车维修方面我并不同意他们的看法，并不是我不能理解他们对科技的感受，而是我认为他们的逃避和厌恶只是一种自欺的行为。佛陀或是耶稣坐在电脑和变速器的齿轮旁修行，会像坐在山顶和莲花座上一样自在。如果你认为不是如此，那无异于亵渎了佛陀——也就是亵渎了你自己.\n\n    约翰避免谈及一些自己不懂的事务，比如修理摩托车。\n","source":"_posts/随笔/禅与摩托车维修艺术.md","raw":"---\ntitle: 禅与摩托车维修艺术\ncategories:\n- 非技术类\ntag: 非技术类\n---\n\n# 第一部分\n\n1. \n\n- > 只要我一谈到摩托车维修的问题，他就会坐立不安。这样一来只会使我想更进一步地探索下去。并不是故意要激怒他，而是因为他的不安似乎象征了某些隐而未显的问题.当你谈到节育的时候，横亘在你们中间的并不是人口多寡的问题，那只是表象，真正起冲突的是信念。基督教看重的是实际的社会问题，而天主教徒则认为那是亵渎天主的权威。你可以滔滔不绝地阐述计划生育的重要性，一直到你自己都听烦了，却仍无法说服对方，因为他并不认为符合社会的实际需要有何好处，他自有比实用更重要的价值观\n\n    根本原因是价值观的问题。作者比较看重实际价值，而约翰是浪漫主义\n\n- > 在摩托车维修方面我并不同意他们的看法，并不是我不能理解他们对科技的感受，而是我认为他们的逃避和厌恶只是一种自欺的行为。佛陀或是耶稣坐在电脑和变速器的齿轮旁修行，会像坐在山顶和莲花座上一样自在。如果你认为不是如此，那无异于亵渎了佛陀——也就是亵渎了你自己.\n\n    约翰避免谈及一些自己不懂的事务，比如修理摩托车。\n","slug":"随笔/禅与摩托车维修艺术","published":1,"date":"2022-07-14T00:37:05.336Z","updated":"2022-08-04T15:15:19.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu65002kl1dbeglt5vyh","content":"<h1 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h1><p>1. </p>\n<ul>\n<li><blockquote>\n<p>只要我一谈到摩托车维修的问题，他就会坐立不安。这样一来只会使我想更进一步地探索下去。并不是故意要激怒他，而是因为他的不安似乎象征了某些隐而未显的问题.当你谈到节育的时候，横亘在你们中间的并不是人口多寡的问题，那只是表象，真正起冲突的是信念。基督教看重的是实际的社会问题，而天主教徒则认为那是亵渎天主的权威。你可以滔滔不绝地阐述计划生育的重要性，一直到你自己都听烦了，却仍无法说服对方，因为他并不认为符合社会的实际需要有何好处，他自有比实用更重要的价值观</p>\n</blockquote>\n<p>  根本原因是价值观的问题。作者比较看重实际价值，而约翰是浪漫主义</p>\n</li>\n<li><blockquote>\n<p>在摩托车维修方面我并不同意他们的看法，并不是我不能理解他们对科技的感受，而是我认为他们的逃避和厌恶只是一种自欺的行为。佛陀或是耶稣坐在电脑和变速器的齿轮旁修行，会像坐在山顶和莲花座上一样自在。如果你认为不是如此，那无异于亵渎了佛陀——也就是亵渎了你自己.</p>\n</blockquote>\n<p>  约翰避免谈及一些自己不懂的事务，比如修理摩托车。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h1><p>1. </p>\n<ul>\n<li><blockquote>\n<p>只要我一谈到摩托车维修的问题，他就会坐立不安。这样一来只会使我想更进一步地探索下去。并不是故意要激怒他，而是因为他的不安似乎象征了某些隐而未显的问题.当你谈到节育的时候，横亘在你们中间的并不是人口多寡的问题，那只是表象，真正起冲突的是信念。基督教看重的是实际的社会问题，而天主教徒则认为那是亵渎天主的权威。你可以滔滔不绝地阐述计划生育的重要性，一直到你自己都听烦了，却仍无法说服对方，因为他并不认为符合社会的实际需要有何好处，他自有比实用更重要的价值观</p>\n</blockquote>\n<p>  根本原因是价值观的问题。作者比较看重实际价值，而约翰是浪漫主义</p>\n</li>\n<li><blockquote>\n<p>在摩托车维修方面我并不同意他们的看法，并不是我不能理解他们对科技的感受，而是我认为他们的逃避和厌恶只是一种自欺的行为。佛陀或是耶稣坐在电脑和变速器的齿轮旁修行，会像坐在山顶和莲花座上一样自在。如果你认为不是如此，那无异于亵渎了佛陀——也就是亵渎了你自己.</p>\n</blockquote>\n<p>  约翰避免谈及一些自己不懂的事务，比如修理摩托车。</p>\n</li>\n</ul>\n"},{"title":"go语言圣经","_content":"\n- [1. 入门](#1-入门)\n- [2. 程序结构](#2-程序结构)\n  - [2.1 命名](#21-命名)\n  - [2.2 声明](#22-声明)\n  - [2.3 变量](#23-变量)\n    - [2.3.1 简短变量声明](#231-简短变量声明)\n    - [2.3.2 指针](#232-指针)\n    - [2.3.3 new函数](#233-new函数)\n    - [2.3.4. 变量的生命周期](#234-变量的生命周期)\n  - [2.4 赋值](#24-赋值)\n    - [2.4.1 元组赋值](#241-元组赋值)\n  - [2.5 类型](#25-类型)\n  - [2.6 包和文件](#26-包和文件)\n  - [2.7. 作用域](#27-作用域)\n- [3.基础数据类型](#3基础数据类型)\n  - [3.1 整型](#31-整型)\n  - [3.2 浮点数](#32-浮点数)\n  - [3.3 复数](#33-复数)\n  - [3.4 布尔类型](#34-布尔类型)\n  - [3.5 字符串](#35-字符串)\n- [4. 复合数据类型](#4-复合数据类型)\n  - [4.1 数组](#41-数组)\n  - [4.2 slice](#42-slice)\n    - [4.2.1 append函数](#421-append函数)\n  - [4.3 Map](#43-map)\n  - [4.4 结构体](#44-结构体)\n    - [4.4.1 结构体字面值](#441-结构体字面值)\n    - [4.4.2 结构体的比较](#442-结构体的比较)\n    - [4.4.3 结构体嵌入和匿名成员](#443-结构体嵌入和匿名成员)\n  - [4.5 json字符串](#45-json字符串)\n  - [4.6 文本和HTML模板](#46-文本和html模板)\n- [5. 函数](#5-函数)\n  - [5.1 错误](#51-错误)\n  - [5.2 函数值](#52-函数值)\n  - [5.3 匿名函数](#53-匿名函数)\n  - [5.4 可变参数](#54-可变参数)\n  - [5.5 defer函数](#55-defer函数)\n  - [5.6 panic异常](#56-panic异常)\n  - [5.7 Recovery捕获异常](#57-recovery捕获异常)\n- [6. 方法](#6-方法)\n  - [6.1 方法声明](#61-方法声明)\n  - [6.2 基于指针对象的方法](#62-基于指针对象的方法)\n  - [6.3. 通过嵌入结构体来扩展类型](#63-通过嵌入结构体来扩展类型)\n  - [6.4 封装](#64-封装)\n- [7. 接口](#7-接口)\n  - [7.1. 接口约定](#71-接口约定)\n  - [7.2 接口类型](#72-接口类型)\n  - [7.3 实现接口的条件](#73-实现接口的条件)\n  - [7.4 flag.Value接口](#74-flagvalue接口)\n  - [7.5 接口值](#75-接口值)\n  - [7.6. sort.Interface接口](#76-sortinterface接口)\n  - [7.7. http.Handler接口](#77-httphandler接口)\n  - [7.8. error接口](#78-error接口)\n  - [7.9. 类型断言](#79-类型断言)\n  - [7.10. 基于类型断言区别错误类型](#710-基于类型断言区别错误类型)\n  - [7.11. any关键字与泛型](#711-any关键字与泛型)\n- [8. Goroutines和Channels](#8-goroutines和channels)\n  - [8.1 goroutine](#81-goroutine)\n  - [8.2 channel](#82-channel)\n  - [8.3 基于select的多路复用](#83-基于select的多路复用)\n  - [8.4. 并发的退出](#84-并发的退出)\n- [9. 基于共享变量的并发](#9-基于共享变量的并发)\n  - [9.1 sync.Mutex与sync.RMutex互斥锁](#91-syncmutex与syncrmutex互斥锁)\n  - [9.2 sync.Once惰性初始化](#92-synconce惰性初始化)\n  - [9.3 sync.Cond的使用](#93-synccond的使用)\n  - [9.4. Goroutines和线程](#94-goroutines和线程)\n- [10. 包和工具](#10-包和工具)\n- [11. 测试](#11-测试)\n  - [11.1 go test](#111-go-test)\n  - [11.2 测试覆盖率](#112-测试覆盖率)\n  - [11.3 基准测试](#113-基准测试)\n  - [11.4 刨析](#114-刨析)\n  - [11.5 示例函数](#115-示例函数)\n- [12. appendIndex](#12-appendindex)\n\n# 1. 入门\n\n\n# 2. 程序结构\n## 2.1 命名\n\n|功能性关键字|描述|\n|---|---|\n|break||\n|case||\n|chan||\n|const||\n|continue||\n|default||\n|defer||\n|else||\n|fallthrough||\n|for||\n|func||\n|go||\n|if||\n|import||\n|interface||\n|map||\n|package||\n|range||\n|return||\n|select||\n|struct||\n|switch||\n|type||\n|var||\n\n\n|内建常量|关键字|\n|---|---|\n|true ||\n|false ||\n|iota||\n| nil||\n\n|内建类型| 关键字|\n|---|---|\n|int ||\n|int8 ||\n|int16 ||\n|int32 ||\n|int64 ||\n|uint ||\n|uint8 ||\n|uint16 ||\n|uint32 ||\n|uint64 ||\n|uintptr ||\n|float32 ||\n|float64 ||\n|complex128 ||\n|complex64 ||\n|bool ||\n|byte ||\n|rune ||\n|string ||\n|error||\n\n|内建函数| 关键字|\n|---|---|\n|make||\n|len||\n|cap||\n|new||\n|append ||\n|copy ||\n|close ||\n|delete ||\n|complex ||\n|real ||\n|imag ||\n|panic ||\n|recover||\n\nGo推荐使用`驼峰式`命名:\n\n- 一个名字必须以一个字母（Unicode字母）或下划线开头,下划线开头可能表示`私有的`\n- 后面可以跟任意数量的字母、数字或下划线。\n- 名字的开头字母的大小写决定了名字在包外的可见性.如果一个名字是大写字母开头的(译注必须是 在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将是导出的,也就是说可以被外部的包访问,例如`fmt.Printf`,就可以在包外访问\n\n\n## 2.2 声明\nGo语言主要有四种类型的声明语句:\n  \n- var\n- const\n- type\n- func\n\n```golang\n  package main\n\n  import \"fmt\"\n\n  const boilingF = 212.0\n  const var a = 0\n\n  func main() {\n      var f = boilingF\n      var c = (f - 32) * 5 / 9\n      fmt.Printf(\"boiling point = %g°F or %g°C\\n\", f, c)\n      // Output:\n      // boiling point = 212°F or 100°C\n  }\n```\n\n`boilingF`是包一级的变量在包内可以访问。如果函数没有返回值，那么返回值列表是省略的。函数顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者\n\n## 2.3 变量\n\n常规声明变量\n\n```golang\n  var 变量名字 类型 = 表达式\n```\n\n```golang\n  var i ,j , k int // 都是int类型\n  var b,f,s =true , 2.3 ,\"four\" //bool , float 64,string\n  var f, err = os.Open(name) // os.Open returns a file and an error\n```\n\n- 在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。\n- `类型`和`表达式`都可以缺省,如果是`类型`缺省那么就可以通过`表达式`进行推断,如果是表达式缺省那么就会赋类型的`零`值,如果是自定义类型或者是引用类型就是内部各个字段都是`零`值.Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态\n\n### 2.3.1 简短变量声明\n\n  ```golang\n  anim := gif.GIF{LoopCount: nframes} //聚合类型,引用类型\n  freq := rand.Float64() * 3.0 // float\n  t := 0.0  //float\n  f, err := os.Open(name) //通过函数进行声明，并初始化\n  if err != nil {\n      return err\n  }\n  ```\n\n  -  例子1中声明的err是重复,第二个简短声明符的err就是赋值操作，注意该操作是在变量相同作用例子2中这种情况编译不通过,至少有一个是新声明的.[ 实际工程中尽量不要出现例子2 ]\n\n  ```golang\n  //例子1\n  in, err := os.Open(infile)\n  // ...\n  out, err := os.Create(outfile)\n  //例子2\n  f, err := os.Open(infile)\n  // ...\n  f, err := os.Create(outfile) // compile error: no new variables\n  ```\n\n\n### 2.3.2 指针\n\n  - `任何类型`的指针的`零值`都是`nil`。如果p指向某个有效变量，那么`p != nil`测试为`真`。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。\n  - 返回局部变量地址也是安全的。\n\n    ```golang\n    func incr(p *int) int {\n        *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！\n        return *p\n    }\n    v := 1\n    incr(&v)              // side effect: v is now 2\n    fmt.Println(incr(&v)) // \"3\" (and v is 3)\n    ```\n\n  - 在flag包中,应用到了`指针`技术\n\n    ```golang\n    package main\n    import (\n        \"flag\"\n        \"fmt\"\n        \"strings\"\n    )\n    var n = flag.Bool(\"n\", false, \"omit trailing newline\")\n    var sep = flag.String(\"s\", \" \", \"separator\")\n\n    func main() {\n        flag.Parse() //解析标志性参数位\n        fmt.Print(strings.Join(flag.Args(), *sep)) //flag.Args() 解析非标志参数位\n        if !*n {\n            fmt.Println()\n        }\n    }\n    ```\n    - 在此代码例子中使用`flag.Args()`解析非标志参数位,`flag.Parse()`解析标志性参数位,to be continue\n\n### 2.3.3 new函数\n  表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T(返回的是指针)\n  - 每次new()返回新的变量地址,比如new(int)\n### 2.3.4. 变量的生命周期\n\n  - 包一级的声明会伴随程序整个声明周期,但是函数内部则是动态,会被GC回收\n  - 函数的`参数变量`(参数列表)和`返回值变量`都是`局部变量`。它们在函数每次被调用的时候创建,下面循环的`变量t`就是动态创建,用完就扔\n  ```golang\n  for t := 0.0; t < cycles*2*math.Pi; t += res {\n    x := math.Sin(t)\n    y := math.Sin(t*freq + phase)\n    img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),\n        blackIndex)\n  }\n  ```\n\n  下面也是合法的\n\n  ```golang\n  for t := 0.0; t < cycles*2*math.Pi; t += res {\n    x := math.Sin(t)\n    y := math.Sin(t*freq + phase)\n    img.SetColorIndex(\n        size+int(x*size+0.5), size+int(y*size+0.5),\n        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性\n    )               // 小括弧另起一行缩进，和大括弧的风格保存一致\n  }\n  ```\n\n  - `局部变量逃逸`.因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。`编译器`会自动选择在`栈`上还是在`堆`上分配局部变量的存储空间,代码如下,`f`函数里的`x变量`必须在`堆`上分配,因为它在函数退出后依然可以通过包一级的`global变量`找到,`g`函数在栈上分配`*y`内存空间\n  ```golang\n  var global *int\n\n  func f() {\n      var x int\n      x = 1\n      global = &x\n  }\n\n  func g() {\n      y := new(int)\n      *y = 1\n  }\n\n  ```\n  - Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期,比如,如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。\n\n\n\n## 2.4 赋值\n  ```golang\n  x = 1                       // 命名变量的赋值\n  *p = true                   // 通过指针间接赋值\n  person.name = \"bob\"         // 结构体字段赋值\n  count[x] = count[x] * scale // 数组、slice或map的元素赋值\n\n  ```\n\n### 2.4.1 元组赋值\n\n  ```golang\n  x,y = y,x; //不限制数量\n  a[i], a[j] = a[j], a[i];\n  //额外的布尔类型表达某种错误类型\n  v, ok = m[key]             // map lookup\n  v, ok = x.(T)              // type assertion\n  v, ok = <-ch               // channel receive\n  //只做检查\n  v = m[key]                // map查找，失败时返回零值\n  v = x.(T)                 // type断言，失败时panic异常\n  v = <-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）\n\n  _, ok = m[key]            // map返回2个值\n  _, ok = mm[\"\"], false     // map返回1个值\n  _ = mm[\"\"]                // map返回1个值\n  //复合类型隐式赋值\n  medals := []string{\"gold\", \"silver\", \"bronze\"}\n  //等价写法\n  medals[0] = \"gold\"\n  medals[1] = \"silver\"\n  medals[2] = \"bronze\"\n  ```\n  - 对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系\n\n## 2.5 类型\n  ```golang\n  package tempconv\n\n  import \"fmt\"\n\n  type Celsius float64    // 摄氏温度\n  type Fahrenheit float64 // 华氏温度\n\n  const (\n      AbsoluteZeroC Celsius = -273.15 // 绝对零度\n      FreezingC     Celsius = 0       // 结冰点温度\n      BoilingC      Celsius = 100     // 沸水温度\n  )\n\n  func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }\n\n  func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }\n\n  ```\n\n  - 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用\n  - `Celsius`和`Fahrenheit`是两种不同类型,`Celsius(t)`或`Fahrenheit(t)`形式的显式转型,`整数`->`小数`回省略小数部分(CPP在这部分有很详细的讨论)\n  - 如果两个值有着不同的类型，则不能直接进行比较\n  - 命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集后面详细讨论\n\n## 2.6 包和文件\n\n  - `名字空间`每个包都对应一个独立的名字空间,例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问\n  - `包的导入`Go语言的规范并没有定义这些源代码的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。\n  - `包的初始化`。包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的。例如`func init() { /* ... */ }`,`init`不能被调用，也不能被声明。包会按照声明的顺序初始化。\n  - `包的初始化顺序`。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了\n\n    复杂初始化可以用以下方式\n    ```golang\n    //可以使用匿名函数处理\n    var pc [256]byte = func() (pc [256]byte) {\n      for i := range pc {\n          pc[i] = pc[i/2] + byte(i&1)\n      }\n      return\n    }()\n\n    ```\n  \n## 2.7. 作用域\n\n  - 不要将作用域和生命周期混为一谈，作用域是指文本域，而生命周期是指运行有效时段\n  - 任何在`函数`外部（也就是包级语法域）声明的名字可以在同一个`包`的任何源文件中访问的\n  - 对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包\n  - 控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是\n    函数级的作用域\n\n几种常见作用域例子\n\n  - 正常情况下作用域例子\n\n    ```golang\n    func f() {}\n\n    var g = \"g\"\n\n    func main() {\n        f := \"f\"\n        fmt.Println(f) // \"f\"; local var f shadows package-level func f\n        fmt.Println(g) // \"g\"; package-level var\n        fmt.Println(h) // compile error: undefined: h\n    }\n    ```\n  - 作用域嵌套,函数中可以进行词法域嵌套\n    ```golang\n    func main() {\n      x := \"hello!\"\n      for i := 0; i < len(x); i++ {\n          x := x[i]\n          if x != '!' {\n              x := x + 'A' - 'a'\n              fmt.Printf(\"%c\", x) // \"HELLO\" (one letter per iteration)\n            }\n        }\n    }\n    //上述代码`x[]`和`x + 'A' - 'a'`都是引用了外部作用域声明的x变量。\n    //再比如下面的例子,有三个不同的x变量，\n    ```\n\n    ```golang\n    //每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化\n    //词法域，一个在for循环体词法域；只有两个块是显式创建的：\n    func main() {\n      x := \"hello\"\n      for _, x := range x {\n          x := x + 'A' - 'a'\n          fmt.Printf(\"%c\", x) // \"HELLO\" (one letter per iteration)\n      }\n    }\n    ```\n  - 建隐式词法域,隐式作用域\n  if和switch语句也会在条件部分创建隐式词法域，代码例子如下.第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问\n    ```golang\n    if x := f(); x == 0 {\n      fmt.Println(x)\n    } else if y := g(x); x == y {\n        fmt.Println(x, y)\n    } else {\n        fmt.Println(x, y)\n    }\n    fmt.Println(x, y) // compile error: x and y are not visible here\n    ```\n    如果不想提前声明变量还可以选择如下方式，但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回\n    ```golang\n    if f, err := os.Open(fname); err != nil {\n      return err\n    } else {\n        // f and err are visible here too\n        f.ReadByte()\n        f.Close()\n    }\n    ```\n  - 屏蔽其他作用域变暗亮\n    cwd在外部已经声明的包级变量，但是:=语句还是将cwd和err重新声明为新的局部变量\n    ```golang\n    var cwd string\n\n    func init() {\n        cwd, err := os.Getwd() // compile error: unused: cwd\n        if err != nil {\n            log.Fatalf(\"os.Getwd failed: %v\", err)\n        }\n    }\n    ```\n    可以用赋值运算符，就不会屏蔽`cwd`变量\n\n    ```golang\n    var cwd string\n\n    func init() {\n        var err error //因为是赋值运算符所以需要定义error变量\n        cwd, err = os.Getwd()\n        if err != nil {\n            log.Fatalf(\"os.Getwd failed: %v\", err)\n        }\n    }\n    ```\n\n# 3.基础数据类型\n\n- 整型格式控制符\n    |格 式\t| 描 述|\n    |---|---|\n    |%b\t| 整型以二进制方式显示|\n    |%o\t| 整型以八进制方式显示|\n    |%d\t| 整型以十进制方式显示|\n    |%x\t| 整型以十六进制方式显示|\n    |%X\t| 整型以十六进制、字母大写方式显示|\n    |%c\t| 相应Unicode码点所表示的字符|\n    |%U\t| Unicode 字符, Unicode格式：123，等同于 \"U+007B\"|\n\n- 浮点数格式控制\n    |格 式\t| 描 述|\n    |---|---|\n    |%e\t|科学计数法,例如 -1234.456e+78|\n    |%E\t|科学计数法,例如 -1234.456E+78|\n    |%f\t|有小数点而无指数,例如 123.456|\n    |%g\t|根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出|\n    |%G\t|根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出|\n\n- 字符串格式化\n    |格 式\t|描 述|\n    |---|---|\n    |%s| 字符串或切片的无解译字节|\n    |%q| 双引号围绕的字符串，由Go语法安全地转义|\n    |%x| 十六进制，小写字母，每字节两个字符|\n    |%X| 十六进制，大写字母，每字节两个字符|\n\n- 指针格式化\n    |格 式\t|描 述|\n    |---|---|\n    |%p|十六进制表示，前缀 0x|\n- 通用的占位符\n    |格 式|\t描 述|\n    |---|---|\n    |%v\t|   值的默认格式。|\n    |%+v|   类似%v，但输出结构体时会添加字段名|\n    |%#v|   相应值的Go语法表示|\n    |%T\t|   相应值的类型的Go语法表示|\n    |%%\t|   百分号,字面上的%,非占位符含义|\n\n- 控制宽度\n    宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐\n    - 字符串控制\n\n        ```golang\n        fmt.Printf(\"|%s|\", \"aa\") // 不设置宽度\n        fmt.Printf(\"|%5s|\", \"aa\") // 5个宽度,  默认+， 右对齐\n        fmt.Printf(\"|%-5s|\", \"aa\") // 5个宽度, 左对齐\n\n        fmt.Printf(\"|%05s|\", \"aa\") // |000aa|\n\n        ```\n\n    - 浮点控制\n\n        ```golang\n        a := 54.123456\n        fmt.Printf(\"|%f|\", a)  // |54.123456|\n        fmt.Printf(\"|%5.1f|\", a)  // | 54.1|\n        fmt.Printf(\"|%-5.1f|\", a) // |54.1 |\n        fmt.Printf(\"|%05.1f|\", a) // |054.1|\n        ```\n\n\n\n## 3.1 整型\n\n1. 因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节\n2. Unicode和rune类型是个`int32`等价的类型,通常用于表示一个Unicode码点\n3. 同样byte也是`uint8`类型的等价类型\n4. 还有一种无符号的整数类型`uintptr`，没有指定具体的bit大小但是足以容纳指针。`uintptr`类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方\n5. `int`、`uint`和`uintptr`是不同类型的兄弟类型。其中`int`和`int32`也是不同的类型，即使`int`的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然\n6. 位元素符号\n7. `int32`和`int64`无法直接四则运算\n8. `fmt.Printf(\"%d %[1]o %#[1]o\\n\", o) // \"438 666 0666\"`中的`fmt`两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀\n\n## 3.2 浮点数\n\n1. 一个`float32`类型的浮点数可以提供大约`6`个十进制数的精度，而`float64`则可以提供约`15`个十进制数的精度；通常应该优先使用`float64`类型，因为`float32`类型的累计计算误差很容易扩散，并且`float32`能精确表示的正整数并不是很大\n2. 浮点数字面量可以直接书写\n3. 很大或者很小的数都可以用科学计数法来书写\n4. `fmt.Printf(\"x = %d e^x = %8.3f\\n\", x, math.Exp(float64(x)))`8.3是指三个小数精度，8个字符宽度,`%g %e %f`.\n\n## 3.3 复数\n\n复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:\n```golang\nvar x complex128 = complex(1, 2) // 1+2i\nvar y complex128 = complex(3, 4) // 3+4i\nfmt.Println(x*y)                 // \"(-5+10i)\"\nfmt.Println(real(x*y))           // \"-5\"\nfmt.Println(imag(x*y))           // \"10\"\n\n```\n\n## 3.4 布尔类型\n\n布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:\n\n```golang\ni := 0\nif b {\n    i = 1\n}\n```\n\n## 3.5 字符串\n\n- 字符串可以用==和<进行比较；比较通过逐个字节比较完成的\n- 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故`s[0] = 'L' // compile error: cannot assign to s[0]`\n\n  - 因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中\n  - 可在字符串面值中写`十六进制`和`八进制`数字进行码点转义\n  - 原生字面值用反引号(`)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.\n  - 通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思\n  - UTF-8 [to be continue]\n  - `bytes`、`strings`、`strconv`和`unicode`包,四个包对字符串处理尤为重要,`strings`包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能\n  - 字符串和数字的转换,`strconv`包提供这类转换功能\n\n# 4. 复合数据类型\n\n## 4.1 数组\n数组代码示例\n```golang\nvar a [3]int             // array of 3 integers\nfmt.Println(a[0])        // print the first element\nfmt.Println(a[len(a)-1]) // print the last element, a[2]\n\n// Print the indices and elements.\nfor i, v := range a {\n    fmt.Printf(\"%d %d\\n\", i, v)\n}\n\n// Print the elements only.\nfor _, v := range a {\n    fmt.Printf(\"%d\\n\", v)\n}\n```\n\n如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算\n```golang\nq := [...]int{1, 2, 3}\nfmt.Printf(\"%T\\n\", q) // \"[3]int\"\n```\n上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化\n```golang\ntype Currency int\n\nconst (\n    USD Currency = iota // 美元\n    EUR                 // 欧元\n    GBP                 // 英镑\n    RMB                 // 人民币\n)\n\nsymbol := [...]string{USD: \"$\", EUR: \"€\", GBP: \"￡\", RMB: \"￥\"}\n\nfmt.Println(RMB, symbol[RMB]) // \"3 ￥\"\n```\n定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。\n```golang\nr := [...]int{99: -1}\n```\n数组进行比较是比较所有元素是否相等\n## 4.2 slice\n创建slice变量\n```golang\nv_len := make([]T, len)\nv_len_cap := make([]T, len, cap) // same as make([]T, cap)[:len]\ns := []int{0, 1, 2, 3, 4, 5}\n```\n`slice`和`数组`典型的不同就是`slice`不指定长度\n`bytes.Equal`函数来判断两个字节型slice是否相等（[]byte)\n```golang\nfunc equal(x, y []string) bool {\n    if len(x) != len(y) {\n        return false\n    }\n    for i := range x {\n        if x[i] != y[i] {\n            return false\n        }\n    }\n    return true\n}\n```\n\nslice的nil值\n\n```golang\nvar s []int    // len(s) == 0, s == nil\ns = nil        // len(s) == 0, s == nil\ns = []int(nil) // len(s) == 0, s == nil\ns = []int{}    // len(s) == 0, s != nil\n```\n\n### 4.2.1 append函数\n(留着放些API东西)\n\n\n## 4.3 Map\n其中K对应的key必须是支持==比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在  \n创建map\n```golang\nages := make(map[string]int) // mapping from strings to ints\nages := map[string]int{\n    \"alice\":   31,\n    \"charlie\": 34,\n}\n//访问map数据，也是put操作\nages[\"alice\"] = 32\n//删除元素\ndelete(ages, \"alice\") // remove element ages[\"alice\"]\n//map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：\n_ = &ages[\"bob\"] // compile error: cannot take address of map element\n\n```\nMap的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序\n\n```golang\nimport \"sort\"\n\nvar names []string\nfor name := range ages {\n    names = append(names, name)\n}\nsort.Strings(names)\nfor _, name := range names {\n    fmt.Printf(\"%s\\t%d\\n\", name, ages[name])\n}\n```\n\nmap返回两个值，第一个值是bool类型,false则说明不存在这个key。\nmap的key要求必须是可比较类型，那么如果想用slice作为key就需要写小改动\n\n```golang\nvar m = make(map[string]int)\n\nfunc k(list []string) string { return fmt.Sprintf(\"%q\", list) }\n\nfunc Add(list []string)       { m[k(list)]++ }\nfunc Count(list []string) int { return m[k(list)] }\n```\n\n## 4.4 结构体\n\n```golang\nseen := make(map[string]struct{}) // set of strings\n// ...\nif _, ok := seen[s]; !ok {\n    seen[s] = struct{}{}\n    // ...first time seeing s...\n}\n```\n\n### 4.4.1 结构体字面值\n\n```golang\ntype Point struct{ X, Y int }\n//第一种类型初始化方式\np := Point{1, 2}\n//第二种初始化方式,如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要\np :=Point{x:1,y:2}\n```\n\n非导出结构体或者字段，不能在其他包中进行赋值\n\n```golang\npackage p\ntype T struct{ a, b int } // a and b are not exported\n\npackage q\nimport \"p\"\nvar _ = p.T{a: 1, b: 2} // compile error: can't reference a, b\nvar _ = p.T{1, 2}       // compile error: can't reference a, b\n```\n\n如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，\n\n```golang\n\nfunc Bonus(e *Employee, percent int) int {\n    return e.Salary * percent / 100\n}\n```\n\n可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：\n\n```golang\npp := &Point{1, 2}\n```\n\n它和下面的语句是等价的\n\n```golang\npp := new(Point)\n*pp = Point{1, 2}\n```\n\n### 4.4.2 结构体的比较\n\n首先结构体是可比较类型\n\n```golang\n\ntype Point struct{ X, Y int }\n\np := Point{1, 2}\nq := Point{2, 1}\nfmt.Println(p.X == q.X && p.Y == q.Y) // \"false\"\nfmt.Println(p == q)                   // \"false\"\n\n```\n\n### 4.4.3 结构体嵌入和匿名成员\n\n```golang\n\ntype Point struct {\n    X, Y int\n}\n\ntype Circle struct {\n    Center Point\n    Radius int\n}\n\ntype Wheel struct {\n    Circle Circle\n    Spokes int\n}\n\nvar w Wheel\nw.Circle.Center.X = 8\nw.Circle.Center.Y = 8\nw.Circle.Radius = 5\nw.Spokes = 20\n```\n\n匿名成员，说白了就是只写类型不写名字.\n\n```golang\ntype Circle struct {\n    Point\n    Radius int\n}\n\ntype Wheel struct {\n    Circle\n    Spokes int\n}\n\nvar w Wheel\nw.X = 8            // equivalent to w.Circle.Point.X = 8\nw.Y = 8            // equivalent to w.Circle.Point.Y = 8\nw.Radius = 5       // equivalent to w.Circle.Radius = 5\nw.Spokes = 20\n//以下初始化是错误的\nw = Wheel{8, 8, 5, 20}                       // compile error: unknown fields\nw = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields\n```\n\n所以我们只能用下面两种方式进行初始化\n\n```golang\n\nw = Wheel{Circle{Point{8, 8}, 5}, 20}\n\nw = Wheel{\n    Circle: Circle{\n        Point:  Point{X: 8, Y: 8},\n        Radius: 5,\n    },\n    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)\n}\n\nfmt.Printf(\"%#v\\n\", w)\n// Output:\n// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}\n\nw.X = 42\n\nfmt.Printf(\"%#v\\n\", w)\n// Output:\n// Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}\n\n```\n需要注意，但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。\n\n## 4.5 json字符串\n\n`json.Marshal`包\n代码例子\n```golang\ntype Movie struct {\n    Title  string\n    Year   int  `json:\"released\"` // 这个tag指定生成json名字\n    Color  bool `json:\"color,omitempty\"`\n    Actors []string\n}\n\nvar movies = []Movie{\n    {Title: \"Casablanca\", Year: 1942, Color: false,\n        Actors: []string{\"Humphrey Bogart\", \"Ingrid Bergman\"}},\n    {Title: \"Cool Hand Luke\", Year: 1967, Color: true,\n        Actors: []string{\"Paul Newman\"}},\n    {Title: \"Bullitt\", Year: 1968, Color: true,\n        Actors: []string{\"Steve McQueen\", \"Jacqueline Bisset\"}},\n    // ...\n}\n```\n\n## 4.6 文本和HTML模板\n(后面需要时候着重的看)\n`text/template和html/template`,们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。模板语言支持流程控制语句\n模板语言demo\n\n```golang\nconst templ = `{{.TotalCount}} issues:\n{{range .Items}}----------------------------------------\nNumber: {{.Number}}\nUser:   {{.User.Login}}\nTitle:  {{.Title | printf \"%.64s\"}}\nAge:    {{.CreatedAt | daysAgo}} days\n{{end}}`\n```\n\n`|` 操作符表示将前一个表达式的结果作为后一个函数的输入.  \n生成模板的输出需要两个处理步骤\n\n```golang\nvar report = template.Must(template.New(\"issuelist\").\n    Funcs(template.FuncMap{\"daysAgo\": daysAgo}).\n    Parse(templ))\n\nfunc main() {\n    result, err := github.SearchIssues(os.Args[1:])\n    if err != nil {\n        log.Fatal(err)\n    }\n    if err := report.Execute(os.Stdout, result); err != nil {\n        log.Fatal(err)\n    }\n}\n```\n如果想转化为html则需要编写如下代码\n```golang\n\nimport \"html/template\"\n\nvar issueList = template.Must(template.New(\"issuelist\").Parse(`\n<h1>{{.TotalCount}} issues</h1>\n<table>\n<tr style='text-align: left'>\n  <th>#</th>\n  <th>State</th>\n  <th>User</th>\n  <th>Title</th>\n</tr>\n{{range .Items}}\n<tr>\n  <td><a href='{{.HTMLURL}}'>{{.Number}}</a></td>\n  <td>{{.State}}</td>\n  <td><a href='{{.User.HTMLURL}}'>{{.User.Login}}</a></td>\n  <td><a href='{{.HTMLURL}}'>{{.Title}}</a></td>\n</tr>\n{{end}}\n</table>\n`))\n```\n注意，html/template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text/template包的话，这2个issue将会产生错误，其中“&lt;”四个字符将会被当作小于字符“<”处理，同时“<link>”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。\n\n# 5. 函数\n\n声明和定义\n- switch 控制语句\n\n  ```golang\n  switch cond{\n    case a :\n        fmt.Printf()\n    case b :\n        fmt.Printf()\n    case c :\n        fmt.Printf()\n  }\n  ```\n\n## 5.1 错误\n通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。\n\n我们有几种处理错误的策略\n1. 发生错误时的解析器\n\n  发生解析错误后,findLinks 函数构造了一个新的异常信息,既包含了自定义的，也包含了底层解析出错的信息\n\n  ```golang\n  doc, err := html.Parse(resp.Body)\n  resp.Body.Close()\n  if err != nil {\n      return nil, fmt.Errorf(\"parsing %s as HTML: %v\", url,err)\n  }\n  ```\n\n  参考宇航局事故调查\n2. 重试\n  我们需要限制重试的时间间隔或重试的次数，防止无限制的重试.\n3. 输出错误信息并结束程序\n  输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行,对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序\n  ```golang\n  if err := WaitForServer(url); err != nil {\n    log.Fatalf(\"Site is down: %v\\n\", err)\n  }\n  ```\n  `log.Fatalf`代码更简洁，并输出自定义格式信息\n\n4. 只是输出错误信息就可以\n\n  ```golang\n  if err := Ping(); err != nil {\n    log.Printf(\"ping failed: %v; networking disabled\",err)\n  }\n  //或者标准错误流输出错误信息。\n\n  if err := Ping(); err != nil {\n      fmt.Fprintf(os.Stderr, \"ping failed: %v; networking disabled\\n\", err)\n  }\n  ```\n\n5. 直接忽略掉错误\n\n  ```golang\n  dir, err := ioutil.TempDir(\"\", \"scratch\")\n  if err != nil {\n      return fmt.Errorf(\"failed to create temp dir: %v\",err)\n  }\n  // ...use temp dir…\n  os.RemoveAll(dir) // ignore errors; $TMPDIR is cleaned periodically\n  ```\n  尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响\n\n6. 文件结尾错误\n\nio包保证任何由文件结束引起的读取失败都返\n```golang\npackage io\n\nimport \"errors\"\n\n// EOF is the error returned by Read when no more input is available.\nvar EOF = errors.New(\"EOF\")\n\nin := bufio.NewReader(os.Stdin)\nfor {\n    r, _, err := in.ReadRune()\n    if err == io.EOF {\n        break // finished reading\n    }\n    if err != nil {\n        return fmt.Errorf(\"read failed:%v\", err)\n    }\n    // ...use r…\n}\n```\n\n## 5.2 函数值\n\n- 函数在golang中也是一种类型，可以被复制给其他变量。  \n- 很熟类型的`零`值是`nil`,调用值为nil会引起`panic`错误  \n- 函数值之间是不可以比较的,也不能用函数值作为map的key\n- strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者\n  \n  ```golang\n  func add1(r rune) rune { return r + 1 }\n\n  fmt.Println(strings.Map(add1, \"HAL-9000\")) // \"IBM.:111\"\n  fmt.Println(strings.Map(add1, \"VMS\"))      // \"WNT\"\n  fmt.Println(strings.Map(add1, \"Admix\"))    // \"Benjy\"\n  ```\n\ndemo示例\n\n```golang\n//值得学习\n// forEachNode针对每个结点x，都会调用pre(x)和post(x)。\n// pre和post都是可选的。\n// 遍历孩子结点之前，pre被调用\n// 遍历孩子结点之后，post被调用\nfunc forEachNode(n *html.Node, pre, post func(n *html.Node)) {\n    if pre != nil {\n        pre(n)\n    }\n    for c := n.FirstChild; c != nil; c = c.NextSibling {\n        forEachNode(c, pre, post)\n    }\n    if post != nil {\n        post(n)\n    }\n}\n```\n\n## 5.3 匿名函数\n函数内部定义的函数可以访问整个词法环境，言外之意就是嵌套的函数可以访问外层函数的变量\n```golang\n// squares返回一个匿名函数。\n// 该匿名函数每次被调用时都会返回下一个数的平方。\n//squares 函数每次都返回一个函数类型-func()int{}\nfunc squares() func() int {\n    var x int\n    return func() int { // 匿名函数\n        x++\n        return x * x\n    }\n}\nfunc main() {\n    f := squares()\n    fmt.Println(f()) // \"1\"\n    fmt.Println(f()) // \"4\"\n    fmt.Println(f()) // \"9\"\n    fmt.Println(f()) // \"16\"\n}\n//通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。\n```\n\n> 网页抓取的核心问题就是如何遍历图\n\n警告:捕获迭代变量\n```golang\nvar rmdirs []func()\nfor _, d := range tempDirs() {\n    dir := d // NOTE: necessary!\n    os.MkdirAll(dir, 0755) // creates parent directories too\n    rmdirs = append(rmdirs, func() {\n        os.RemoveAll(dir)\n    })\n}\n// ...do some work…\nfor _, rmdir := range rmdirs {\n    rmdir() // clean up\n}\n// \nvar rmdirs []func()\nfor _, dir := range tempDirs() {\n    os.MkdirAll(dir, 0755)\n    rmdirs = append(rmdirs, func() {\n        os.RemoveAll(dir) // NOTE: incorrect!\n    })\n}\n\n```\n问题出在了循环变量的作用域,循环变量dir在这个词法块中被声明，每一次迭代都是会不断地更新这个值，被`range`语句，解决这个问题的办法就是引入同名变量来覆盖其作用域。\n\n## 5.4 可变参数\n简单的可变参数例子,其实`可变参数`就是个切片的值传递,`interface{}`表示函数的最后一个参数可以接收任意类型\n```golang\nfunc sum(vals ...int) int {\n    total := 0\n    for _, val := range vals {\n        total += val\n    }\n    return total\n}\n```\n如果原参数就是切片该怎么传递？可以直接在`实参`后面加省略号\n\n## 5.5 defer函数\n\n在函数执行完成之后，不管是正常退出还是异常退出函数，最后都会被执行\n\n## 5.6 panic异常\n\n当panic发生时会在该goroutine上执行defer函数，打印对应的栈信息\n`regexp`包的使用\n为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。\n```golang\nfunc main() {\n    defer printStack()\n    f(3)\n}\nfunc printStack() {\n    var buf [4096]byte\n    n := runtime.Stack(buf[:], false)\n    os.Stdout.Write(buf[:n])\n}\n\n```\n将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。\n\n\n## 5.7 Recovery捕获异常\n\n通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所\n\n- 语言解析器为例\n说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误\n\n```golang\nfunc Parse(input string) (s *Syntax, err error) {\n    defer func() {\n        if p := recover(); p != nil {\n            err = fmt.Errorf(\"internal error: %v\", p)\n        }\n    }()\n    // ...parser...\n}\n```\n\n\n- 虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。  \n- 有时我们很难完全遵循规范，举个例子，net/http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。\n\n```golang\n// soleTitle returns the text of the first non-empty title element\n// in doc, and an error if there was not exactly one.\n//防御性panic代码\nfunc soleTitle(doc *html.Node) (title string, err error) {\n    type bailout struct{}\n    defer func() {\n        switch p := recover(); p {\n        case nil:       // no panic\n        case bailout{}: // \"expected\" panic\n            err = fmt.Errorf(\"multiple title elements\")\n        default:\n            panic(p) // unexpected panic; carry on panicking\n        }\n    }()\n    // Bail out of recursion if we find more than one nonempty title.\n    forEachNode(doc, func(n *html.Node) {\n        if n.Type == html.ElementNode && n.Data == \"title\" &&\n            n.FirstChild != nil {\n            if title != \"\" {\n                panic(bailout{}) // multiple titleelements\n            }\n            title = n.FirstChild.Data\n        }\n    }, nil)\n    if title == \"\" {\n        return \"\", fmt.Errorf(\"no title element\")\n    }\n    return title, nil\n}\n```\n\n# 6. 方法\n\n## 6.1 方法声明\n\n- 普通函数与接收器方法\n`接收器`因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。对于一个给定的类型，其内部的方法都必须有唯一的方法名\n\n## 6.2 基于指针对象的方法\n\n- 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。\n- 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。\n- 当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们下面例子里做的这样\n    ```golang\n    func (list *IntList) Sum() int {\n    if list == nil {\n        return 0\n    }\n    return list.Value + list.Tail.Sum()\n    }\n    ```\n    如果此时结构体是`nil`调用对象可能会发生类似于空指针异常的错误\n\n## 6.3. 通过嵌入结构体来扩展类型\n\n- 方法值\n    在go语言中，方法是第一公民，这一点在函数式编程中非常实用(maybe)\n\n    ```golang\n    //方法值demo\n    p := Point{1, 2}\n    q := Point{4, 6}\n\n    distanceFromP := p.Distance        // method value,Distance是结构体方法\n    fmt.Println(distanceFromP(q))      // \"5\"\n    var origin Point                   // {0, 0}\n    fmt.Println(distanceFromP(origin)) // \"2.23606797749979\", sqrt(5)\n\n    scaleP := p.ScaleBy // method value\n    scaleP(2)           // p becomes (2, 4)\n    scaleP(3)           //      then (6, 12)\n    scaleP(10)          //      then (60, 120)\n    ```\n\n- 方法表达式\n    在面向对象中，当根据哪一个变量来决定调用哪个函数时候,方法表达式就很有用了.\n\n    ```golang\n    p := Point{1, 2}\n    q := Point{4, 6}\n\n    distance := Point.Distance   // method expression\n    fmt.Println(distance(p, q))  // \"5\"\n    fmt.Printf(\"%T\\n\", distance) // \"func(Point, Point) float64\"\n\n    scale := (*Point).ScaleBy\n    scale(&p, 2)\n    fmt.Println(p)            // \"{2 4}\"\n    fmt.Printf(\"%T\\n\", scale) // \"func(*Point, float64)\"\n\n    ```\n\npractice demo\n\n```golang\ntype Point struct{ X, Y float64 }\n\nfunc (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }\nfunc (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }\n\ntype Path []Point\n\nfunc (path Path) TranslateBy(offset Point, add bool) {\n    var op func(p, q Point) Point\n    if add {\n        op = Point.Add\n    } else {\n        op = Point.Sub\n    }\n    for i := range path {\n        // Call either path[i].Add(offset) or path[i].Sub(offset).\n        path[i] = op(path[i], offset)\n    }\n}\n```\n\n## 6.4 封装\n\n封装提供了三方面的优点。\n1. 首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可.\n2. 第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由\n3. bytes.Buffer这个类型作为例子来考虑\n\n    ```golang\n\n    type Buffer struct {\n    buf     []byte\n    initial [64]byte\n    /* ... */\n    }\n\n    // Grow expands the buffer's capacity, if necessary,\n    // to guarantee space for another n bytes. [...]\n    func (b *Buffer) Grow(n int) {\n        if b.buf == nil {\n            b.buf = b.initial[:0] // use preallocated space initially\n        }\n        if len(b.buf)+n > cap(b.buf) {\n            buf := make([]byte, b.Len(), 2*cap(b.buf) + n)\n            copy(buf, b.buf)\n            b.buf = buf\n        }\n    }\n    // Grow()函数式导出类型，但是stuct的字段不是到处类型\n    ```\n\n4. 只暴漏关键信息给外部使用者\n\n\n# 7. 接口\n\n很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用  \n\n只要一个物体能像鸭子一样叫那我们就可以称它为鸭子；只要一个软件能存储和查询数据我们就可以称它为数据库；只要一台机器有洗衣服和甩干的功能我们就可以称它为洗衣机。  \n\n为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型\n\n## 7.1. 接口约定\n\n例如`fmt`包\n\n```golang\n    package fmt\n\n    func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)\n    //Printf 最后调用Fprintf 函数\n    func Printf(format string, args ...interface{}) (int, error) {\n        return Fprintf(os.Stdout, format, args...)\n    }\n    // Sprintf函数最后也是调用Fprintf\n    func Sprintf(format string, args ...interface{}) string {\n        var buf bytes.Buffer\n        Fprintf(&buf, format, args...)\n        return buf.String()\n    }\n```\n\n`Fprintf`函数的`F`说明了文件类型也说明了所有信息要被写入到文件当中，在`Printf`函数中的第一个参数`os.Stdout`是`*os.File`类型实现了`io.Writer`接口，在`Sprintf`函数中的第一个参数`&buf`是一个指向可以写入字节的内存缓冲区也该类型也是实现了`io.Writer`接口,用户可以自定义一个函数并实现`io.Writer`接口。  \n**LSP里氏替换** : `fmt.Fprintf`通过使用接口类型`io.Writer`使得只要调用者只要传入实现了该接口的类型就可以实现自由替换\n\n<details><summary>自定义bytecounter函数，实现计算int转byte长度</summary>\n\n```golang\n\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n//!+bytecounter\n\ntype ByteCounter int\n\nfunc (c *ByteCounter) Write(p []byte) (int, error) {\n\t*c += ByteCounter(len(p)) // convert int to ByteCounter\n\treturn len(p), nil\n}\n\n//!-bytecounter\n\nfunc main() {\n\t//!+main\n\tvar c ByteCounter\n\tc.Write([]byte(\"hello\"))\n\tfmt.Println(c) // \"5\", = len(\"hello\")\n\n\tc = 0 // reset the counter\n\tvar name = \"Dolly\"\n\tfmt.Fprintf(&c, \"hello, %s\", name)\n\tfmt.Println(c) // \"12\", = len(\"hello, Dolly\")\n\t//!-main\n}\n```\n\n</details>\n\n因为它实现了`writer`接口就可以传入到`Fprintf`函数中.总结来说，接口约定了包使用者的行为，但是使用者想创建什么样的实例需要他自己去实现。\n\n\n## 7.2 接口类型\n\n通过组合定义接口\n```golang\npackage io\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\ntype Closer interface {\n    Close() error\n}\n\ntype ReadWriter interface {\n    Reader\n    Writer\n}\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n// 另一种命名风格\ntype ReadWriter interface {\n    Read(p []byte) (n int, err error)\n    Write(p []byte) (n int, err error)\n}\n//或者甚至使用一种混合的风格：\n\ntype ReadWriter interface {\n    Read(p []byte) (n int, err error)\n    Writer\n}\n```\n\n## 7.3 实现接口的条件\n\n- 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口.\n\n    ```golang\n    var w io.Writer\n    //只实现了Write 方法\n    w = os.Stdout           // OK: *os.File has Write method\n    //只实现了Write方法\n    w = new(bytes.Buffer)   // OK: *bytes.Buffer has Write method\n    // time.Duration没有Write方法\n    w = time.Second         // compile error: time.Duration lacks Write method\n\n    var rwc io.ReadWriteCloser\n    rwc = os.Stdout         // OK: *os.File has Read, Write, Close methods\n    rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method\n    // 这个规则甚至适用于等式右边本身也是一个接口类型\n    // rwc io.ReadWriteCloser\n    w = rwc                 // OK: io.ReadWriteCloser has Write method\n    // w 只有Write方法\n    rwc = w                 // compile error: io.Writer lacks Close method\n    ```\n\n- \n\n\n## 7.4 flag.Value接口\n(翻译的太差劲，要去读原文)\n- 简单的`flag`包支持命令行的例子\n\n    ```golang\n    var period = flag.Duration(\"period\", 1*time.Second, \"sleep period\")\n\n    func main() {\n        flag.Parse()\n        fmt.Printf(\"Sleeping for %v...\", *period)\n        time.Sleep(*period)\n        fmt.Println()\n    }\n    ```\n\n- 自定义新的标记符号\n\n    ```golang\n    package tempconv\n\n    import (\n        \"flag\"\n        \"fmt\"\n    )\n\n    type Celsius float64\n    type Fahrenheit float64\n\n    func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9.0/5.0 + 32.0) }\n    func FToC(f Fahrenheit) Celsius { return Celsius((f - 32.0) * 5.0 / 9.0) }\n\n    func (c Celsius) String() string { return fmt.Sprintf(\"%g°C\", c) }\n\n    /*\n    //!+flagvalue\n    package flag\n\n    // Value is the interface to the value stored in a flag.\n    type Value interface {\n        String() string\n        Set(string) error\n    }\n    //!-flagvalue\n    */\n\n    //!+celsiusFlag\n    // *celsiusFlag satisfies the flag.Value interface.\n    type celsiusFlag struct{ Celsius }\n\n    func (f *celsiusFlag) Set(s string) error {\n        var unit string\n        var value float64\n        fmt.Sscanf(s, \"%f%s\", &value, &unit) // no error check needed\n        switch unit {\n        case \"C\", \"°C\":\n            f.Celsius = Celsius(value)\n            return nil\n        case \"F\", \"°F\":\n            f.Celsius = FToC(Fahrenheit(value))\n            return nil\n        }\n        return fmt.Errorf(\"invalid temperature %q\", s)\n    }\n\n    //!-celsiusFlag\n\n    //!+CelsiusFlag\n\n    // CelsiusFlag defines a Celsius flag with the specified name,\n    // default value, and usage, and returns the address of the flag variable.\n    // The flag argument must have a quantity and a unit, e.g., \"100C\".\n    func CelsiusFlag(name string, value Celsius, usage string) *Celsius {\n        f := celsiusFlag{value}\n        flag.CommandLine.Var(&f, name, usage)\n        return &f.Celsius\n    }\n    // main函数\n    var temp = tempconv.CelsiusFlag(\"temp\", 20.0, \"the temperature\")\n\n    func main() {\n        flag.Parse()\n        fmt.Println(*temp)\n    }\n    ```\n\n## 7.5 接口值\n\n下面语句中,`io.Writer`是接口类型值\n\n```golang\nvar w io.Writer\nw = os.Stdout\nw = new(bytes.Buffer)\nw = nil\n```\n- 对于接口的定义也不例外，`接口`的零值是它的类型和值的部分都是`nil`\n- 一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生`panic`: `w.Write([]byte(\"hello\")) // panic: nil pointer dereference`\n- 第二句statement，这个赋值过程调用了一个`具体类型`到`接口类型`的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的`os.File`类型变量的指针.接口值可以使用`==`和`!＝`来进行比较。两个接口值相等仅当它们都是nil值。\n    ```golang\n    w.Write([]byte(\"hello\")) // \"hello\"\n    os.Stdout.Write([]byte(\"hello\")) // \"hello\" \n    //上下两句是等价的\n    ```\n- 一个接口值可以持有任意大的动态值\n\n    ```golang\n    var x interface{} = time.Now()\n    ```\n\n    接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数,然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:\n\n    ```golang\n    var x interface{} = []int{1, 2, 3}\n    fmt.Println(x == x) // panic: comparing uncomparable type []int\n    ```\n\n\n考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值.\n\n\n\n- *警告*: 一个包含nil指针的接口不是nil接口\n\n一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。\n\n思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。\n\n```golang\nconst debug = true\n\nfunc main() {\n    var buf *bytes.Buffer\n    if debug {\n        buf = new(bytes.Buffer) // enable collection of output\n    }\n    f(buf) // NOTE: subtly incorrect!\n    if debug {\n        // ...use buf...\n    }\n}\n\n// If out is non-nil, output will be written to it.\nfunc f(out io.Writer) {\n    // ...do something...\n    if out != nil {\n        out.Write([]byte(\"done!\\n\"))\n    }\n}\n```\n我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：\n\n```golang\nif out != nil {\n    out.Write([]byte(\"done!\\n\")) // panic: nil pointer dereference\n}\n```\n当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!=nil的结果依然是true。\n\n![](https://user-images.githubusercontent.com/46363359/182982938-08d67c3f-7aa6-457d-88a5-02646c5e2735.png)\n\n动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者（§6.2.1），但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。\n\n问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：\n\n```golang\nvar buf io.Writer\nif debug {\n    buf = new(bytes.Buffer) // enable collection of output\n}\nf(buf) // OK\n```\n现在我们已经把接口值的技巧都讲完了，让我们来看更多的一些在Go标准库中的重要接口类型。在下面的三章中，我们会看到接口类型是怎样用在排序，web服务，错误处理中的。\n\n\n\n## 7.6. sort.Interface接口\ngolang提供了`sort`包帮助进行排序数据,实现排序需要自己实现对应的排序接口.\n```golang\ntype byArtist []*Track\nfunc (x byArtist) Len() int           { return len(x) }\nfunc (x byArtist) Less(i, j int) bool { return x[i].Artist < x[j].Artist }\nfunc (x byArtist) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }\n```\n对于自定义的排序，我们也需要实现排序函数.\n```golang\n//!+customcode\ntype customSort struct {\n\tt    []*Track\n\tless func(x, y *Track) bool\n}\n\nfunc (x customSort) Len() int           { return len(x.t) }\nfunc (x customSort) Less(i, j int) bool { return x.less(x.t[i], x.t[j]) }\nfunc (x customSort) Swap(i, j int)      { x.t[i], x.t[j] = x.t[j], x.t[i] }\n\nsort.Sort(customSort{tracks, func(x, y *Track) bool {\n\t\tif x.Title != y.Title {\n\t\t\treturn x.Title < y.Title\n\t\t}\n\t\tif x.Year != y.Year {\n\t\t\treturn x.Year < y.Year\n\t\t}\n\t\tif x.Length != y.Length {\n\t\t\treturn x.Length < y.Length\n\t\t}\n\t\treturn false\n\t}})\n```\n`IntsAreSorted(...interface{})` reports whether the slice x is sorted in increasing order.\n\n## 7.7. http.Handler接口\n\nhttp.Handler的实例\n\n## 7.8. error接口\n\n```golang\n\npackage errors_demo\n\nfunc New(text string) error { return &errorString{text} }\n\ntype errorString struct { text string }\n\nfunc (e *errorString) Error() string { return e.text }\n```\n调用`errors.New`函数是非常稀少的，因为有一个方便的封装函数`fmt.Errorf`它还会处理字符串格式化\n另一个error demo实例\n```golang\npackage syscall\n\ntype Errno uintptr // operating system error code\n\nvar errors = [...]string{\n    1:   \"operation not permitted\",   // EPERM\n    2:   \"no such file or directory\", // ENOENT\n    3:   \"no such process\",           // ESRCH\n    // ...\n}\n\nfunc (e Errno) Error() string {\n    if 0 <= int(e) && int(e) < len(errors) {\n        return errors[e]\n    }\n    return fmt.Sprintf(\"errno %d\", e)\n}\n\nvar err error = syscall.Errno(2)\nfmt.Println(err.Error()) // \"no such file or directory\"\nfmt.Println(err)         // \"no such file or directory\"\n```\n用有限几个进行描述，并且它满足标准错误接口\n\n## 7.9. 类型断言\n\n语法上它看起来像`x.(T)`被称为断言类型，这里`x`表示一个接口的类型和T表示一个类型,详细解释，一个类型断言检查它操作对象的动态类型是否和断言的类型是否匹配,分两种情况\n\n- (T传入的是具体类型，X是动态类型),然后类型断言检查`X`的动态类型是否和`T`相同.如果检查成功了类型断言的结果就是`X`的动态值\n\n- (T传入的是接口类型，X是动态类型),然后类型断言检查是否`x`的动态类型满足T,如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值\n    ```golang\n\n    var w io.Writer\n    w = os.Stdout   //能赋值说明os.Stdout 实现了Write()方法\n    rw := w.(io.ReadWriter) // success: *os.File has both Read and Write,断言w是否实现了接口(io.ReadWriter)的Read和Write接口\n    w = new(ByteCounter)\n    rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method\n    //如果对预期结果只是个判断就可以用第二个返回参数bool.\n    var w io.Writer = os.Stdout\n    f, ok := w.(*os.File)      // success:  ok, f == os.Stdout\n    b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil\n    // if 后面的w变量不会覆盖外层的w\n    if w, ok := w.(*os.File); ok {\n    // ...use w...\n    }\n    ```\n\n\n## 7.10. 基于类型断言区别错误类型\n对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，但是处理I/O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。\n\n一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：\n```golang\n\n\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n)\n\ntype PathError struct {\n\tOp   string\n\tPath string\n\tErr  error\n}\n\nfunc (e *PathError) Error() string {\n\treturn e.Op + \" \" + e.Path + \": \" + e.Err.Error()\n}\n\nvar ErrNotExist = errors.New(\"file does not exist\")\n\n// IsNotExist returns a boolean indicating whether the error is known to\n// report that a file or directory does not exist. It is satisfied by\n// ErrNotExist as well as some syscall errors.\nfunc IsNotExist(err error) bool {\n\tif pe, ok := err.(*PathError); ok {\n\t\terr = pe.Err\n\t}\n\treturn err == syscall.ENOENT || err == ErrNotExist\n}\n\nfunc main() {\n\t_, err := os.Open(\"/no/such/file\")\n\tfmt.Println(os.IsNotExist(err)) // \"true\"\n}\n```\n\n## 7.11. any关键字与泛型\n类型定义时不限制`形参类型`，在函数调用的时候再指定`具体类型`.  `any`其实是`interface{}`的别名\n泛型好处:  (1).在编译期间对类型进行检查以提高类型安全(2).通过指定类型消除强制类型转换(3).能够减少代码重复性，提供更通用的功能函数。\n\n- 类型泛型\n  ```golang\n    package main\n\n    import \"fmt\"\n\n    type ListType[T int | int32 | int64 | string] []T\n\n    type MapType[K int | int32, V int64 | string] map[K]V\n\n    func main() {\n        var intList ListType[int]\n        intList = []int{1, 2, 3}\n        fmt.Println(intList)\n        strList := ListType[string]{\"1\", \"2\", \"3\"}\n        fmt.Println(strList)\n\n        intMap := MapType[int, string]{1: \"1\", 2: \"2\"}\n        int32Map := MapType[int32, int64]{1: 2, 3: 4}\n        fmt.Println(intMap)\n        fmt.Println(int32Map)\n    }\n  ```\n  这里面的T,K,V都是占位符号,`ListType`只能在那三种类型中选择,同理`MapType`也是\n- 接口泛型\n  ```golang\n  type GenericStackInterface[T any] interface {\n    Push(element T)\n    Pop() T\n  }\n  ```\n- 泛型函数\n  ```golang\n    func minInt[T int | int8 | int16 | int32](a, b T) T {\n    if a < b {\n        return a\n    }\n        return b\n    }\n\n    func maxInt[T int | int8 | int16 | int32](a, b T) T {\n        if a > b {\n            return a\n        }\n        return b\n    }\n    func Mix(a any) any {\n\n    }\n    //还可以简化一下\n    type Numeric interface {\n        int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64\n    }\n    func min[T Numeric](a, b T) T {\n    if a < b {\n        return a\n    }\n        return b\n    }\n\n    func max[T Numeric](a, b T) T {\n        if a > b {\n            return a\n        }\n        return b\n    }\n    // go.18内置了数字类型的集合，故可以\n    import (\n    \"golang.org/x/exp/constraints\"\n    )\n\n    func minType[T constraints.Ordered](a, b T) T {\n        if a < b {\n            return a\n        }\n        return b\n    }\n\n    func maxType[T constraints.Ordered](a, b T) T {\n        if a > b {\n            return a\n        }\n        return b\n    }\n  ```\n  如果进入`constraints`源代码查看其具体代码的话，会发现在 Ordered 类型中也是有各种数字类型组合起来的。但是有一点奇怪的地方就是这里的类型集合中，各种类型前加了一个波浪线~, 表示衍生类型，即使用 type 自定义的类型也可以被识别到，只要底层类型一致即可。比如 ~int 可以包含 int 和 type MyInt int 等多种类型\n\n\n\n# 8. Goroutines和Channels\n(多看看本章代码)\n## 8.1 goroutine\n通过代码示例了解`goroutine`的使用\n```golang\nfunc main() {\n    go spinner(100 * time.Millisecond)\n    const n = 45\n    fibN := fib(n) // slow\n    fmt.Printf(\"\\rFibonacci(%d) = %d\\n\", n, fibN)\n}\n\nfunc spinner(delay time.Duration) {\n    for {\n        for _, r := range `-\\|/` {\n            fmt.Printf(\"\\r%c\", r)\n            time.Sleep(delay)\n        }\n    }\n}\n\nfunc fib(x int) int {\n    if x < 2 {\n        return x\n    }\n    return fib(x-1) + fib(x-2)\n}\n```\n## 8.2 channel\n\n这里应该还得看一下uber编码规范\n\n- 无缓冲channel\n    ```golang\n    ch <- x\n    x = <-chan //取出元素\n    <- ch //取出，舍弃\n    close(ch) // 关闭chan\n    ```\n\n    - 串联channel\n    \n    - 单方向channel\n\n- 缓冲channel\n    ```golang\n    ch = make(chan string, 3) //channel容量为3\n    ```\n## 8.3 基于select的多路复用\n\n<details>\n<summary>多路复用demo</summary>\n<pre>\n\n```golang\n// Copyright © 2016 Alan A. A. Donovan & Brian W. Kernighan.\n// License: https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// See page 246.\n\n// Countdown implements the countdown for a rocket launch.\npackage main\n\n// NOTE: the ticker goroutine never terminates if the launch is aborted.\n// This is a \"goroutine leak\".\n\nimport (\n        \"fmt\"\n        \"os\"\n        \"time\"\n)\n\n//!+\n\nfunc main() {\n        // ...create abort channel...\n\n        //!-\n\n        abort := make(chan struct{})\n        go func() {\n                os.Stdin.Read(make([]byte, 1)) // read a single byte\n                abort <- struct{}{}\n        }()\n\n        //!+\n        fmt.Println(\"Commencing countdown.  Press return to abort.\")\n        tick := time.Tick(1 * time.Second)\n        for countdown := 10; countdown > 0; countdown-- {\n                fmt.Println(countdown)\n                select {\n                case <-tick:\n                        // Do nothing.\n                case <-abort:\n                        fmt.Println(\"Launch aborted!\")\n                        return\n                }\n        }\n        launch()\n}\n//!-\nfunc launch() {\n        fmt.Println(\"Lift off!\")\n}\n```\n\n</pre>\n</details>\n\n- goroutine泄露 : 当for语句执行完后，程序已经跳转到其他部分，但是`time.Tick(1 * time.Second)`仍然会继续的网channel里面发送数据，这就会导致gotourine泄露，以上面为例，那么就需要合适的地方调用`tick.stop()`\n\n- channel的ready : 一定要等到channel准备完毕，开始接受或者发送消息\n\n- channel的轮询 : 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”\n\n  ```golang\n  select {\n    case <-abort:\n        fmt.Printf(\"Launch aborted!\\n\")\n        return\n    default:\n        // do nothing\n  }\n  ```\n\n## 8.4. 并发的退出\n\n这节主要讨论如何有效退出goroutines\n\n<details>\n<summary>\n<font size=\"3\" color=\"orange\">goroutines退出代码示例</font></summary>\n<pre>\n\n```golang\n//gopl.io/ch8/du4\n// Copyright © 2016 Alan A. A. Donovan & Brian W. Kernighan.\n// License: https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// See page 251.\n\n// The du4 command computes the disk usage of the files in a directory.\npackage main\n\n// The du4 variant includes cancellation:\n// it terminates quickly when the user hits return.\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"time\"\n)\n\n//!+1\nvar done = make(chan struct{})\n\nfunc cancelled() bool {\n\tselect {\n\tcase <-done:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n//!-1\n\nfunc main() {\n\t// Determine the initial directories.\n\troots := os.Args[1:]\n\tif len(roots) == 0 {\n\t\troots = []string{\".\"}\n\t}\n\n\t//!+2\n\t// Cancel traversal when input is detected.\n\tgo func() {\n\t\tos.Stdin.Read(make([]byte, 1)) // read a single byte\n\t\tclose(done)\n\t}()\n\t//!-2\n\n\t// Traverse each root of the file tree in parallel.\n\tfileSizes := make(chan int64)\n\tvar n sync.WaitGroup\n\tfor _, root := range roots {\n\t\tn.Add(1)\n\t\tgo walkDir(root, &n, fileSizes)\n\t}\n\tgo func() {\n\t\tn.Wait()\n\t\tclose(fileSizes)\n\t}()\n\n\t// Print the results periodically.\n\ttick := time.Tick(500 * time.Millisecond)\n\tvar nfiles, nbytes int64\nloop:\n\t//!+3\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\t// Drain fileSizes to allow existing goroutines to finish.\n\t\t\tfor range fileSizes {\n\t\t\t\t// Do nothing.\n\t\t\t}\n\t\t\treturn\n\t\tcase size, ok := <-fileSizes:\n\t\t\t// ...\n\t\t\t//!-3\n\t\t\tif !ok {\n\t\t\t\tbreak loop // fileSizes was closed\n\t\t\t}\n\t\t\tnfiles++\n\t\t\tnbytes += size\n\t\tcase <-tick:\n\t\t\tprintDiskUsage(nfiles, nbytes)\n\t\t}\n\t}\n\tprintDiskUsage(nfiles, nbytes) // final totals\n}\n\nfunc printDiskUsage(nfiles, nbytes int64) {\n\tfmt.Printf(\"%d files  %.1f GB\\n\", nfiles, float64(nbytes)/1e9)\n}\n\n// walkDir recursively walks the file tree rooted at dir\n// and sends the size of each found file on fileSizes.\n//!+4\nfunc walkDir(dir string, n *sync.WaitGroup, fileSizes chan<- int64) {\n\tdefer n.Done()\n\tif cancelled() {\n\t\treturn\n\t}\n\tfor _, entry := range dirents(dir) {\n\t\t// ...\n\t\t//!-4\n\t\tif entry.IsDir() {\n\t\t\tn.Add(1)\n\t\t\tsubdir := filepath.Join(dir, entry.Name())\n\t\t\tgo walkDir(subdir, n, fileSizes)\n\t\t} else {\n\t\t\tfileSizes <- entry.Size()\n\t\t}\n\t\t//!+4\n\t}\n}\n\n//!-4\n\nvar sema = make(chan struct{}, 20) // concurrency-limiting counting semaphore\n\n// dirents returns the entries of directory dir.\n//!+5\nfunc dirents(dir string) []os.FileInfo {\n\tselect {\n\tcase sema <- struct{}{}: // acquire token\n\tcase <-done:\n\t\treturn nil // cancelled\n\t}\n\tdefer func() { <-sema }() // release token\n\n\t// ...read directory...\n\t//!-5\n\n\tf, err := os.Open(dir)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"du: %v\\n\", err)\n\t\treturn nil\n\t}\n\tdefer f.Close()\n\n\tentries, err := f.Readdir(0) // 0 => no limit; read all entries\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"du: %v\\n\", err)\n\t\t// Don't return: Readdir may return partial results.\n\t}\n\treturn entries\n}\n```\n\n</pre>\n</details>\n\n# 9. 基于共享变量的并发\n(多看这章代码)\n避免数据竞争的三个方法\n- 并发读数据不会有数据竞争问题\n- 避免从多个goroutine中访问变量，使用独立变量\n- 临界区控制\n\n- 总结\n    - 数据竞争: 程序在多个goroutine交叉执行操作时，导致数据不一致.  \n    - `包级别`的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。\n    (多看看本章代码)\n\n## 9.1 sync.Mutex与sync.RMutex互斥锁\n比如银行存款查询余额的场景，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款(这句话很关键要没有)操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁\n- 总结\n    - 避免临界区中的变量在中途被其他的goroutine修改\n    - 使用mutex包进行互斥goroutine\n    - 一个deferred Unlock即使在临界区发生`panic`时依然会执行\n    - golang不支持重入锁\n    - sync.RWMutex.RLock()持锁，sync.RWMutex.Lock()会阻塞，相同的RWMutex.Lock()持锁，sync.RWMutex.RLock()阻塞，但是sync.RWMutex.RLock()阻塞之间不阻塞\n\n## 9.2 sync.Once惰性初始化\n如果初始化的成本太高，需要延迟的初始化对象。可考虑使用`sync.Once`\n<detials>\n<summary>sync.One的demo</summary>\n<pre>\n\n</pre>\n</details>\n\n\n## 9.3 sync.Cond的使用\n\n\n1. 使用场景: `sync.Cond` 经常用在多个goroutine等待，一个goroutine通知,如果是一读一等待使用`sync.Mutx`和`chan`就可以\n2. `sync.Cond`的[方法](https://pkg.go.dev/sync@go1.19#Cond)\n    ```golang\n    // Each Cond has an associated Locker L (often a *Mutex or *RWMutex),\n    // which must be held when changing the condition and\n    // when calling the Wait method.\n    //\n    // A Cond must not be copied after first use.\n    type Cond struct {\n            noCopy noCopy\n            // L is held while observing or changing the condition\n            L Locker\n            notify  notifyList\n            checker copyChecker\n    }\n\n    ```\n\n    Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁\n\n    ```golang\n    // Signal wakes one goroutine waiting on c, if there is any.\n    //\n    // It is allowed but not required for the caller to hold c.L\n    // during the call.\n    //Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护\n    func (c *Cond) Signal()\n    // Broadcast wakes all goroutines waiting on c.\n    //\n    // It is allowed but not required for the caller to hold c.L\n    // during the call.\n    func (c *Cond) Broadcast()\n\n    // Wait atomically unlocks c.L and suspends execution\n    // of the calling goroutine. After later resuming execution,\n    // Wait locks c.L before returning. Unlike in other systems,\n    // Wait cannot return unless awoken by Broadcast or Signal.\n    //\n    // Because c.L is not locked when Wait first resumes, the caller\n    // typically cannot assume that the condition is true when\n    // Wait returns. Instead, the caller should Wait in a loop:\n    //\n    //    c.L.Lock()\n    //    for !condition() {\n    //        c.Wait()\n    //    }\n    //    ... make use of condition ...\n    //    c.L.Unlock()\n    //挂起调用者所在的 goroutine,等待Broadcast或者Signal方法\n    func (c *Cond) Wait()\n        //代码片段\n        c.L.Lock()\n        for !condition() {\n            c.Wait()\n        }\n        ... make use of condition ...\n        c.L.Unlock()\n    \n\n\n\n    ```\n\n3. Cond代码示例\n    ```golang\n    var done = false\n\n    func read(name string, c *sync.Cond) {\n        c.L.Lock()\n        for !done {\n            c.Wait()\n        }\n        log.Println(name, \"starts reading\")\n        c.L.Unlock()\n    }\n\n    func write(name string, c *sync.Cond) {\n        log.Println(name, \"starts writing\")\n        time.Sleep(time.Second)\n        c.L.Lock()\n        done = true\n        c.L.Unlock()\n        log.Println(name, \"wakes all\")\n        c.Broadcast()\n    }\n\n    func main() {\n        cond := sync.NewCond(&sync.Mutex{})\n\n        go read(\"reader1\", cond)\n        go read(\"reader2\", cond)\n        go read(\"reader3\", cond)\n        write(\"writer\", cond)\n\n        time.Sleep(time.Second * 3)\n    }\n\n    ```\n\n## 9.4. Goroutines和线程\n\n- 每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量\n- 一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩\n- Go的`运行时`有自己的调度器，这个调度器比如m:n调度，n个操作系统线程调度m个gotoutine，例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。\n\n- GOMAXPROCS : 变量来决定会有多少个操作系统的线程同时执行Go的代码,其默认的值是运行机器上的CPU的核心数,`GOMAXPROCS`是前面说的m:n调度中的n.下面代码就可以简单的看出os线程调度代码的情况\n\n  ```golang\n\n    for {\n        go fmt.Print(0)\n        fmt.Print(1)\n    }\n\n    $ GOMAXPROCS=1 go run hacker-cliché.go\n    111111111111111111110000000000000000000011111...\n\n    $ GOMAXPROCS=2 go run hacker-cliché.go\n    010101010101010101011001100101011010010100110...\n  ```\n\n\n\n- 总结\n    - 通过广播机制来取消goroutines\n    - 确保主函数退出，routines也随即退出\n\n\n\n\n# 10. 包和工具\n互联网上已经发布了非常多的Go语言开源包，它们可以通过 http://godoc.org 检索\n\n- 包的声明 ： 通过`package.struct`的形式访问我们的下载的`package`,但是也有同名的例如`math/rand`和`crypto/rand`，这种要重新指定包名，只影响当前文件，同时也解决了那些又臭又长的包名\n- 文件开头以`_`和`.`的会被忽略\n- 以`_test`结尾的通常是测试包\n- 一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in/yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml\n- `包的匿名导入`:\n  - 解决包的依赖顺序\n  - 初始化包级声明的变量\n  - 按顺序初始化包中每个文件里的 init 函数\n  - 每个文件中可以包含多个 init 函数，按顺序执行(所以你导和不导包差距很大，匿名导入只是表明你无法使用相应包内函数)\n  - 包名和成员名要尽量的短，并且能见名知意\n- go的工具\n  - 工作区结构 : 当需要切换工作区的时候，只需要更新下GOPATH环境变量即可`src`保存源代码,`pkg`子目录用于保存编译后的包的目标文件,`bin`子目录用于保存编译后的可执行程序\n  - 下载包 : `go get`命令，`go get -u`命令只是简单地保证每个下载最新版本，实际工作中要对包版本做精细的管理，需要vendor目录管理不同版本的包,`go help gopath`查看vendor帮助文档,而go get 相当于获取的是远程仓库源代码的整个库，还可以看到仓库的版本信息，go支持导入远程github仓库的代码，`go get`下载的包保存在哪里呢？一般他会保存在这个目录：`GOPATH/src`\n  [goget详细介绍](https://www.cnblogs.com/mrbug/p/11990418.html#:~:text=go%20get%20%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8C%85,%E7%9A%84go%20%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E3%80%82)，`go get`是对模块代码的更新\n  - 构建包 : 可以使用相对路径和绝对路径进行构建项目，`go run`其实也可以偷懒，直接`go run *.go`,`go build -i`命令将安装每个目标所依赖的包,`// +build linux darwin`,在包声明和包注释的前面，该构建注释参数告诉`go build`只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件,`// +build ignore`这个构建注释则表示不编译这个文件。`go doc go/build`\n  - 包文档 : 专门用于保存包文档的源文件通常叫`doc.go`,例如 `go doc time` 某个具体成员结构`go doc time.Since`,或者具体函数`go doc time.Duration.Second` , 更简单的是`godoc -http :8000`包含了所有go包的索引，`-analysis=type`和`-analysis=pointer`命令行标志参数用于打开文档和代码中关于静态分析的结果\n  - 内部包 : 一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包\n  - 搜索包 : `go list`列出工作区相关包,还可以查看完整包的原信息,例如`hash`包`go list -json hash`\n    - 命令行参数-f则允许用户使用text/template包（§4.6）的模板语言定义输出文本的格式\n      ```golang\n      //windows环境下注意\n      go list -f '{{.ImportPath}} -> {{join .Imports \" \"}}' compress/...\n        compress/bzip2 -> bufio io sort\n        compress/flate -> bufio fmt io math sort strconv\n        compress/gzip -> bufio compress/flate errors fmt hash hash/crc32 io time\n        compress/lzw -> bufio errors fmt io\n        compress/zlib -> bufio compress/flate errors fmt hash hash/adler32 io\n      ```\n\n# 11. 测试\n\ngo test选项含义\n```bash\n\n-args 传递参数到test binary(到时候补一个demo)\n-c 编译test binary,但是不执行\n-exec xprog  运行test binary ,原理如同 go run\n-i 安装test binary的相关依赖\n-json 将测试输出转化为json为了自动化处理\n-c file   定义编译后的binary的文件名\n\n```\n\n\n## 11.1 go test\n一个测试函数是以`Test`为函数名前缀的函数\n一个基准测试函数是以`Benchmark`为函数名前缀的函数\n一个示例函数是以`Example`为函数名前缀的函数，提供一个由编译器保证正确性的示例文档\n```golang\n- `go test -v `会打印每个函数的名字和运行时间\n- `go test -run= `会去匹配正则表达式，只有被匹配到的才会被执行\n- `go test -v ./...` 执行所有当前目录下测试cases\n- `go test -v foo/...` 执行foo目录下所有cases\n- `go test -v foo...` 执行指定前缀的测试cases\n- `go test ...` gopath下所有测试cases\n- `go test -v hello_test.go` 执行某一文件下的测试cases,但是该文件中如果调用了其它文件中的模块会报错\n- `go test -v hello_test.go -test.run TestHello` 测试单个函数\n```\n- 组织多个测试用例\n  \n  即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息,可以使用`t.Fatal`或`t.Fatalf`停止当前测试函数\n    <details>\n    <summary>组织多测试用例</summary>\n    <pre>\n    \n    ```golang\n    func TestIsPalindrome(t *testing.T) {\n    var tests = []struct {\n        input string\n        want  bool\n    }{\n            {\"\", true},\n            {\"a\", true},\n            {\"aa\", true},\n            {\"ab\", false},\n            {\"kayak\", true},\n            {\"detartrated\", true},\n            {\"A man, a plan, a canal: Panama\", true},\n            {\"Evil I did dwell; lewd did I live.\", true},\n            {\"Able was I ere I saw Elba\", true},\n            {\"été\", true},\n            {\"Et se resservir, ivresse reste.\", true},\n            {\"palindrome\", false}, // non-palindrome\n            {\"desserts\", false},   // semi-palindrome\n        }\n        for _, test := range tests {\n            if got := IsPalindrome(test.input); got != test.want {\n                t.Errorf(\"IsPalindrome(%q) = %v\", test.input, got)\n            }\n        }\n    }\n    ```\n\n    </pre>\n    </details>\n\n- 随机测试\n  1. 编写对照函数，效率低下\n  2. 生成的随机输入的数据遵循特定的模式，然后就知道期望的输出\n\n  ```golang\n\n  import \"math/rand\"\n\n    // randomPalindrome returns a palindrome whose length and contents\n    // are derived from the pseudo-random number generator rng.\n    func randomPalindrome(rng *rand.Rand) string {\n        n := rng.Intn(25) // random length up to 24\n        runes := make([]rune, n)\n        for i := 0; i < (n+1)/2; i++ {\n            r := rune(rng.Intn(0x1000)) // random rune up to '\\u0999'\n            runes[i] = r\n            runes[n-1-i] = r\n        }\n        return string(runes)\n    }\n\n    func TestRandomPalindromes(t *testing.T) {\n        // Initialize a pseudo-random number generator.\n        seed := time.Now().UTC().UnixNano()\n        t.Logf(\"Random seed: %d\", seed)\n        rng := rand.New(rand.NewSource(seed))\n\n        for i := 0; i < 1000; i++ {\n            p := randomPalindrome(rng)\n            if !IsPalindrome(p) {\n                t.Errorf(\"IsPalindrome(%q) = false\", p)\n            }\n        }\n    }\n    // IsPalindrome reports whether s reads the same forward and backward.\n    // Letter case is ignored, as are non-letters.\n    func IsPalindrome(s string) bool {\n        var letters []rune\n        for _, r := range s {\n            if unicode.IsLetter(r) {\n                letters = append(letters, unicode.ToLower(r))\n            }\n        }\n        for i := range letters {\n            if letters[i] != letters[len(letters)-1-i] {\n                return false\n            }\n        }\n        return true\n    }\n\n    ```\n\n- 测试一个命令(测试内部未导出函数)\n\n  要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。要注意的是在测试代码中并没有调用`log.Fatal`或`os.Exit`，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理,如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理.导出内部函数,\n\n  ```golang\n  // src/bytes/export_test.go\n    package bytes\n    // Export func for testing\n    var IndexBytePortable = indexBytePortable // 赋值给包级可导出变量\n  ```\n  \n  然后通过外部包进行测试\n\n  ```golang\n\n  // src/bytes/bytes_test.go\n    package bytes_test\n\n    func TestIndexByte(t *testing.T) {\n        for _, tt := range indexTests {\n            ... 代码片段\n            posp := IndexBytePortable(a, b) // 导出的内部方法在这里被使用\n            if posp != tt.i {\n                t.Errorf(`indexBytePortable(%q, '%c') = %v`, tt.a, b, posp)\n            }\n        }\n    }\n  \n  ```\n  还有种方式就是不导出，直接在包名下写测试函数，然后进行测试源代码\n\n- 白盒测试\n\n  TBC,代码的内部实现对于测试人员来说是可见的，言外之意就是能看到内部实现,测试内部实现，这个实现可能是未导出的\n- 外部测试包\n  ```golang\n  package pprint_test\n    //这时候就可以在\n    import (\n        \"gott/hi\"\n        // 导入 要进行测试的 pprint 包本身\n        \"gott/pprint\"\n        \"testing\"\n    )\n\n    func TestPPrint(t *testing.T) {\n        pprint.PPrint()\n        hi.Say()\n        t.Log(\"expect call PPrint\")\n    }\n    \n  ```\n  使用 Go 官方的代码风格：pprint_test.go 文件，因为pprint_test在 pprint 目录下，通过在 import 时，使用` . `选项，可以直接调用PPrint()方法\n- 编写有效的测试\n  1. 一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息\n  2. 一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律\n  3. 现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试\n- 避免脆弱的测试\n  TBC\n\n## 11.2 测试覆盖率\n\n对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化(应该是有)\n\n1. go test -run=Coverage -coverprofile=c.out gopl.io/ch7/eval\n2. go test -run=Coverage -covermode=count gopl.io/ch7/eval\n\n## 11.3 基准测试\n\n1. `-bench`也是正则匹配,BenchmarkIsPalindrome-8,8表示的是GOMAXPROCS的值,`-benchmem`命令行标志参数将在报告中包含内存的分配数据统计\n2. 比较型的基准测试就是普通程序代码,它们通常是单参数的函数，由几个不同数量级的基准测试函数调用,通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。所有的测试cases都要保留，随着项目的发展，都需要做回归测试\n\n\n## 11.4 刨析\nTBC\n\n## 11.5 示例函数\n示例函数有三个用处。\n1. 最主要的一个是作为文档，根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。\n2. 在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的// Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配\n3. 提供一个真实的演练场，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数\n\n\n# 12. appendIndex\n1. 线程内再重启一个线程，然后就可以通过加锁，进行隔离开，但此时任然是两个线程的间的交替","source":"_posts/golang/go语言圣经/go语言圣经.md","raw":"---\ntitle: go语言圣经\ncategories:\n- golang\ntag: golang\n---\n\n- [1. 入门](#1-入门)\n- [2. 程序结构](#2-程序结构)\n  - [2.1 命名](#21-命名)\n  - [2.2 声明](#22-声明)\n  - [2.3 变量](#23-变量)\n    - [2.3.1 简短变量声明](#231-简短变量声明)\n    - [2.3.2 指针](#232-指针)\n    - [2.3.3 new函数](#233-new函数)\n    - [2.3.4. 变量的生命周期](#234-变量的生命周期)\n  - [2.4 赋值](#24-赋值)\n    - [2.4.1 元组赋值](#241-元组赋值)\n  - [2.5 类型](#25-类型)\n  - [2.6 包和文件](#26-包和文件)\n  - [2.7. 作用域](#27-作用域)\n- [3.基础数据类型](#3基础数据类型)\n  - [3.1 整型](#31-整型)\n  - [3.2 浮点数](#32-浮点数)\n  - [3.3 复数](#33-复数)\n  - [3.4 布尔类型](#34-布尔类型)\n  - [3.5 字符串](#35-字符串)\n- [4. 复合数据类型](#4-复合数据类型)\n  - [4.1 数组](#41-数组)\n  - [4.2 slice](#42-slice)\n    - [4.2.1 append函数](#421-append函数)\n  - [4.3 Map](#43-map)\n  - [4.4 结构体](#44-结构体)\n    - [4.4.1 结构体字面值](#441-结构体字面值)\n    - [4.4.2 结构体的比较](#442-结构体的比较)\n    - [4.4.3 结构体嵌入和匿名成员](#443-结构体嵌入和匿名成员)\n  - [4.5 json字符串](#45-json字符串)\n  - [4.6 文本和HTML模板](#46-文本和html模板)\n- [5. 函数](#5-函数)\n  - [5.1 错误](#51-错误)\n  - [5.2 函数值](#52-函数值)\n  - [5.3 匿名函数](#53-匿名函数)\n  - [5.4 可变参数](#54-可变参数)\n  - [5.5 defer函数](#55-defer函数)\n  - [5.6 panic异常](#56-panic异常)\n  - [5.7 Recovery捕获异常](#57-recovery捕获异常)\n- [6. 方法](#6-方法)\n  - [6.1 方法声明](#61-方法声明)\n  - [6.2 基于指针对象的方法](#62-基于指针对象的方法)\n  - [6.3. 通过嵌入结构体来扩展类型](#63-通过嵌入结构体来扩展类型)\n  - [6.4 封装](#64-封装)\n- [7. 接口](#7-接口)\n  - [7.1. 接口约定](#71-接口约定)\n  - [7.2 接口类型](#72-接口类型)\n  - [7.3 实现接口的条件](#73-实现接口的条件)\n  - [7.4 flag.Value接口](#74-flagvalue接口)\n  - [7.5 接口值](#75-接口值)\n  - [7.6. sort.Interface接口](#76-sortinterface接口)\n  - [7.7. http.Handler接口](#77-httphandler接口)\n  - [7.8. error接口](#78-error接口)\n  - [7.9. 类型断言](#79-类型断言)\n  - [7.10. 基于类型断言区别错误类型](#710-基于类型断言区别错误类型)\n  - [7.11. any关键字与泛型](#711-any关键字与泛型)\n- [8. Goroutines和Channels](#8-goroutines和channels)\n  - [8.1 goroutine](#81-goroutine)\n  - [8.2 channel](#82-channel)\n  - [8.3 基于select的多路复用](#83-基于select的多路复用)\n  - [8.4. 并发的退出](#84-并发的退出)\n- [9. 基于共享变量的并发](#9-基于共享变量的并发)\n  - [9.1 sync.Mutex与sync.RMutex互斥锁](#91-syncmutex与syncrmutex互斥锁)\n  - [9.2 sync.Once惰性初始化](#92-synconce惰性初始化)\n  - [9.3 sync.Cond的使用](#93-synccond的使用)\n  - [9.4. Goroutines和线程](#94-goroutines和线程)\n- [10. 包和工具](#10-包和工具)\n- [11. 测试](#11-测试)\n  - [11.1 go test](#111-go-test)\n  - [11.2 测试覆盖率](#112-测试覆盖率)\n  - [11.3 基准测试](#113-基准测试)\n  - [11.4 刨析](#114-刨析)\n  - [11.5 示例函数](#115-示例函数)\n- [12. appendIndex](#12-appendindex)\n\n# 1. 入门\n\n\n# 2. 程序结构\n## 2.1 命名\n\n|功能性关键字|描述|\n|---|---|\n|break||\n|case||\n|chan||\n|const||\n|continue||\n|default||\n|defer||\n|else||\n|fallthrough||\n|for||\n|func||\n|go||\n|if||\n|import||\n|interface||\n|map||\n|package||\n|range||\n|return||\n|select||\n|struct||\n|switch||\n|type||\n|var||\n\n\n|内建常量|关键字|\n|---|---|\n|true ||\n|false ||\n|iota||\n| nil||\n\n|内建类型| 关键字|\n|---|---|\n|int ||\n|int8 ||\n|int16 ||\n|int32 ||\n|int64 ||\n|uint ||\n|uint8 ||\n|uint16 ||\n|uint32 ||\n|uint64 ||\n|uintptr ||\n|float32 ||\n|float64 ||\n|complex128 ||\n|complex64 ||\n|bool ||\n|byte ||\n|rune ||\n|string ||\n|error||\n\n|内建函数| 关键字|\n|---|---|\n|make||\n|len||\n|cap||\n|new||\n|append ||\n|copy ||\n|close ||\n|delete ||\n|complex ||\n|real ||\n|imag ||\n|panic ||\n|recover||\n\nGo推荐使用`驼峰式`命名:\n\n- 一个名字必须以一个字母（Unicode字母）或下划线开头,下划线开头可能表示`私有的`\n- 后面可以跟任意数量的字母、数字或下划线。\n- 名字的开头字母的大小写决定了名字在包外的可见性.如果一个名字是大写字母开头的(译注必须是 在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将是导出的,也就是说可以被外部的包访问,例如`fmt.Printf`,就可以在包外访问\n\n\n## 2.2 声明\nGo语言主要有四种类型的声明语句:\n  \n- var\n- const\n- type\n- func\n\n```golang\n  package main\n\n  import \"fmt\"\n\n  const boilingF = 212.0\n  const var a = 0\n\n  func main() {\n      var f = boilingF\n      var c = (f - 32) * 5 / 9\n      fmt.Printf(\"boiling point = %g°F or %g°C\\n\", f, c)\n      // Output:\n      // boiling point = 212°F or 100°C\n  }\n```\n\n`boilingF`是包一级的变量在包内可以访问。如果函数没有返回值，那么返回值列表是省略的。函数顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者\n\n## 2.3 变量\n\n常规声明变量\n\n```golang\n  var 变量名字 类型 = 表达式\n```\n\n```golang\n  var i ,j , k int // 都是int类型\n  var b,f,s =true , 2.3 ,\"four\" //bool , float 64,string\n  var f, err = os.Open(name) // os.Open returns a file and an error\n```\n\n- 在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。\n- `类型`和`表达式`都可以缺省,如果是`类型`缺省那么就可以通过`表达式`进行推断,如果是表达式缺省那么就会赋类型的`零`值,如果是自定义类型或者是引用类型就是内部各个字段都是`零`值.Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态\n\n### 2.3.1 简短变量声明\n\n  ```golang\n  anim := gif.GIF{LoopCount: nframes} //聚合类型,引用类型\n  freq := rand.Float64() * 3.0 // float\n  t := 0.0  //float\n  f, err := os.Open(name) //通过函数进行声明，并初始化\n  if err != nil {\n      return err\n  }\n  ```\n\n  -  例子1中声明的err是重复,第二个简短声明符的err就是赋值操作，注意该操作是在变量相同作用例子2中这种情况编译不通过,至少有一个是新声明的.[ 实际工程中尽量不要出现例子2 ]\n\n  ```golang\n  //例子1\n  in, err := os.Open(infile)\n  // ...\n  out, err := os.Create(outfile)\n  //例子2\n  f, err := os.Open(infile)\n  // ...\n  f, err := os.Create(outfile) // compile error: no new variables\n  ```\n\n\n### 2.3.2 指针\n\n  - `任何类型`的指针的`零值`都是`nil`。如果p指向某个有效变量，那么`p != nil`测试为`真`。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。\n  - 返回局部变量地址也是安全的。\n\n    ```golang\n    func incr(p *int) int {\n        *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！\n        return *p\n    }\n    v := 1\n    incr(&v)              // side effect: v is now 2\n    fmt.Println(incr(&v)) // \"3\" (and v is 3)\n    ```\n\n  - 在flag包中,应用到了`指针`技术\n\n    ```golang\n    package main\n    import (\n        \"flag\"\n        \"fmt\"\n        \"strings\"\n    )\n    var n = flag.Bool(\"n\", false, \"omit trailing newline\")\n    var sep = flag.String(\"s\", \" \", \"separator\")\n\n    func main() {\n        flag.Parse() //解析标志性参数位\n        fmt.Print(strings.Join(flag.Args(), *sep)) //flag.Args() 解析非标志参数位\n        if !*n {\n            fmt.Println()\n        }\n    }\n    ```\n    - 在此代码例子中使用`flag.Args()`解析非标志参数位,`flag.Parse()`解析标志性参数位,to be continue\n\n### 2.3.3 new函数\n  表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T(返回的是指针)\n  - 每次new()返回新的变量地址,比如new(int)\n### 2.3.4. 变量的生命周期\n\n  - 包一级的声明会伴随程序整个声明周期,但是函数内部则是动态,会被GC回收\n  - 函数的`参数变量`(参数列表)和`返回值变量`都是`局部变量`。它们在函数每次被调用的时候创建,下面循环的`变量t`就是动态创建,用完就扔\n  ```golang\n  for t := 0.0; t < cycles*2*math.Pi; t += res {\n    x := math.Sin(t)\n    y := math.Sin(t*freq + phase)\n    img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),\n        blackIndex)\n  }\n  ```\n\n  下面也是合法的\n\n  ```golang\n  for t := 0.0; t < cycles*2*math.Pi; t += res {\n    x := math.Sin(t)\n    y := math.Sin(t*freq + phase)\n    img.SetColorIndex(\n        size+int(x*size+0.5), size+int(y*size+0.5),\n        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性\n    )               // 小括弧另起一行缩进，和大括弧的风格保存一致\n  }\n  ```\n\n  - `局部变量逃逸`.因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。`编译器`会自动选择在`栈`上还是在`堆`上分配局部变量的存储空间,代码如下,`f`函数里的`x变量`必须在`堆`上分配,因为它在函数退出后依然可以通过包一级的`global变量`找到,`g`函数在栈上分配`*y`内存空间\n  ```golang\n  var global *int\n\n  func f() {\n      var x int\n      x = 1\n      global = &x\n  }\n\n  func g() {\n      y := new(int)\n      *y = 1\n  }\n\n  ```\n  - Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期,比如,如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。\n\n\n\n## 2.4 赋值\n  ```golang\n  x = 1                       // 命名变量的赋值\n  *p = true                   // 通过指针间接赋值\n  person.name = \"bob\"         // 结构体字段赋值\n  count[x] = count[x] * scale // 数组、slice或map的元素赋值\n\n  ```\n\n### 2.4.1 元组赋值\n\n  ```golang\n  x,y = y,x; //不限制数量\n  a[i], a[j] = a[j], a[i];\n  //额外的布尔类型表达某种错误类型\n  v, ok = m[key]             // map lookup\n  v, ok = x.(T)              // type assertion\n  v, ok = <-ch               // channel receive\n  //只做检查\n  v = m[key]                // map查找，失败时返回零值\n  v = x.(T)                 // type断言，失败时panic异常\n  v = <-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）\n\n  _, ok = m[key]            // map返回2个值\n  _, ok = mm[\"\"], false     // map返回1个值\n  _ = mm[\"\"]                // map返回1个值\n  //复合类型隐式赋值\n  medals := []string{\"gold\", \"silver\", \"bronze\"}\n  //等价写法\n  medals[0] = \"gold\"\n  medals[1] = \"silver\"\n  medals[2] = \"bronze\"\n  ```\n  - 对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系\n\n## 2.5 类型\n  ```golang\n  package tempconv\n\n  import \"fmt\"\n\n  type Celsius float64    // 摄氏温度\n  type Fahrenheit float64 // 华氏温度\n\n  const (\n      AbsoluteZeroC Celsius = -273.15 // 绝对零度\n      FreezingC     Celsius = 0       // 结冰点温度\n      BoilingC      Celsius = 100     // 沸水温度\n  )\n\n  func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }\n\n  func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }\n\n  ```\n\n  - 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用\n  - `Celsius`和`Fahrenheit`是两种不同类型,`Celsius(t)`或`Fahrenheit(t)`形式的显式转型,`整数`->`小数`回省略小数部分(CPP在这部分有很详细的讨论)\n  - 如果两个值有着不同的类型，则不能直接进行比较\n  - 命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集后面详细讨论\n\n## 2.6 包和文件\n\n  - `名字空间`每个包都对应一个独立的名字空间,例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问\n  - `包的导入`Go语言的规范并没有定义这些源代码的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。\n  - `包的初始化`。包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的。例如`func init() { /* ... */ }`,`init`不能被调用，也不能被声明。包会按照声明的顺序初始化。\n  - `包的初始化顺序`。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了\n\n    复杂初始化可以用以下方式\n    ```golang\n    //可以使用匿名函数处理\n    var pc [256]byte = func() (pc [256]byte) {\n      for i := range pc {\n          pc[i] = pc[i/2] + byte(i&1)\n      }\n      return\n    }()\n\n    ```\n  \n## 2.7. 作用域\n\n  - 不要将作用域和生命周期混为一谈，作用域是指文本域，而生命周期是指运行有效时段\n  - 任何在`函数`外部（也就是包级语法域）声明的名字可以在同一个`包`的任何源文件中访问的\n  - 对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包\n  - 控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是\n    函数级的作用域\n\n几种常见作用域例子\n\n  - 正常情况下作用域例子\n\n    ```golang\n    func f() {}\n\n    var g = \"g\"\n\n    func main() {\n        f := \"f\"\n        fmt.Println(f) // \"f\"; local var f shadows package-level func f\n        fmt.Println(g) // \"g\"; package-level var\n        fmt.Println(h) // compile error: undefined: h\n    }\n    ```\n  - 作用域嵌套,函数中可以进行词法域嵌套\n    ```golang\n    func main() {\n      x := \"hello!\"\n      for i := 0; i < len(x); i++ {\n          x := x[i]\n          if x != '!' {\n              x := x + 'A' - 'a'\n              fmt.Printf(\"%c\", x) // \"HELLO\" (one letter per iteration)\n            }\n        }\n    }\n    //上述代码`x[]`和`x + 'A' - 'a'`都是引用了外部作用域声明的x变量。\n    //再比如下面的例子,有三个不同的x变量，\n    ```\n\n    ```golang\n    //每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化\n    //词法域，一个在for循环体词法域；只有两个块是显式创建的：\n    func main() {\n      x := \"hello\"\n      for _, x := range x {\n          x := x + 'A' - 'a'\n          fmt.Printf(\"%c\", x) // \"HELLO\" (one letter per iteration)\n      }\n    }\n    ```\n  - 建隐式词法域,隐式作用域\n  if和switch语句也会在条件部分创建隐式词法域，代码例子如下.第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问\n    ```golang\n    if x := f(); x == 0 {\n      fmt.Println(x)\n    } else if y := g(x); x == y {\n        fmt.Println(x, y)\n    } else {\n        fmt.Println(x, y)\n    }\n    fmt.Println(x, y) // compile error: x and y are not visible here\n    ```\n    如果不想提前声明变量还可以选择如下方式，但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回\n    ```golang\n    if f, err := os.Open(fname); err != nil {\n      return err\n    } else {\n        // f and err are visible here too\n        f.ReadByte()\n        f.Close()\n    }\n    ```\n  - 屏蔽其他作用域变暗亮\n    cwd在外部已经声明的包级变量，但是:=语句还是将cwd和err重新声明为新的局部变量\n    ```golang\n    var cwd string\n\n    func init() {\n        cwd, err := os.Getwd() // compile error: unused: cwd\n        if err != nil {\n            log.Fatalf(\"os.Getwd failed: %v\", err)\n        }\n    }\n    ```\n    可以用赋值运算符，就不会屏蔽`cwd`变量\n\n    ```golang\n    var cwd string\n\n    func init() {\n        var err error //因为是赋值运算符所以需要定义error变量\n        cwd, err = os.Getwd()\n        if err != nil {\n            log.Fatalf(\"os.Getwd failed: %v\", err)\n        }\n    }\n    ```\n\n# 3.基础数据类型\n\n- 整型格式控制符\n    |格 式\t| 描 述|\n    |---|---|\n    |%b\t| 整型以二进制方式显示|\n    |%o\t| 整型以八进制方式显示|\n    |%d\t| 整型以十进制方式显示|\n    |%x\t| 整型以十六进制方式显示|\n    |%X\t| 整型以十六进制、字母大写方式显示|\n    |%c\t| 相应Unicode码点所表示的字符|\n    |%U\t| Unicode 字符, Unicode格式：123，等同于 \"U+007B\"|\n\n- 浮点数格式控制\n    |格 式\t| 描 述|\n    |---|---|\n    |%e\t|科学计数法,例如 -1234.456e+78|\n    |%E\t|科学计数法,例如 -1234.456E+78|\n    |%f\t|有小数点而无指数,例如 123.456|\n    |%g\t|根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出|\n    |%G\t|根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出|\n\n- 字符串格式化\n    |格 式\t|描 述|\n    |---|---|\n    |%s| 字符串或切片的无解译字节|\n    |%q| 双引号围绕的字符串，由Go语法安全地转义|\n    |%x| 十六进制，小写字母，每字节两个字符|\n    |%X| 十六进制，大写字母，每字节两个字符|\n\n- 指针格式化\n    |格 式\t|描 述|\n    |---|---|\n    |%p|十六进制表示，前缀 0x|\n- 通用的占位符\n    |格 式|\t描 述|\n    |---|---|\n    |%v\t|   值的默认格式。|\n    |%+v|   类似%v，但输出结构体时会添加字段名|\n    |%#v|   相应值的Go语法表示|\n    |%T\t|   相应值的类型的Go语法表示|\n    |%%\t|   百分号,字面上的%,非占位符含义|\n\n- 控制宽度\n    宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐\n    - 字符串控制\n\n        ```golang\n        fmt.Printf(\"|%s|\", \"aa\") // 不设置宽度\n        fmt.Printf(\"|%5s|\", \"aa\") // 5个宽度,  默认+， 右对齐\n        fmt.Printf(\"|%-5s|\", \"aa\") // 5个宽度, 左对齐\n\n        fmt.Printf(\"|%05s|\", \"aa\") // |000aa|\n\n        ```\n\n    - 浮点控制\n\n        ```golang\n        a := 54.123456\n        fmt.Printf(\"|%f|\", a)  // |54.123456|\n        fmt.Printf(\"|%5.1f|\", a)  // | 54.1|\n        fmt.Printf(\"|%-5.1f|\", a) // |54.1 |\n        fmt.Printf(\"|%05.1f|\", a) // |054.1|\n        ```\n\n\n\n## 3.1 整型\n\n1. 因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节\n2. Unicode和rune类型是个`int32`等价的类型,通常用于表示一个Unicode码点\n3. 同样byte也是`uint8`类型的等价类型\n4. 还有一种无符号的整数类型`uintptr`，没有指定具体的bit大小但是足以容纳指针。`uintptr`类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方\n5. `int`、`uint`和`uintptr`是不同类型的兄弟类型。其中`int`和`int32`也是不同的类型，即使`int`的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然\n6. 位元素符号\n7. `int32`和`int64`无法直接四则运算\n8. `fmt.Printf(\"%d %[1]o %#[1]o\\n\", o) // \"438 666 0666\"`中的`fmt`两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀\n\n## 3.2 浮点数\n\n1. 一个`float32`类型的浮点数可以提供大约`6`个十进制数的精度，而`float64`则可以提供约`15`个十进制数的精度；通常应该优先使用`float64`类型，因为`float32`类型的累计计算误差很容易扩散，并且`float32`能精确表示的正整数并不是很大\n2. 浮点数字面量可以直接书写\n3. 很大或者很小的数都可以用科学计数法来书写\n4. `fmt.Printf(\"x = %d e^x = %8.3f\\n\", x, math.Exp(float64(x)))`8.3是指三个小数精度，8个字符宽度,`%g %e %f`.\n\n## 3.3 复数\n\n复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:\n```golang\nvar x complex128 = complex(1, 2) // 1+2i\nvar y complex128 = complex(3, 4) // 3+4i\nfmt.Println(x*y)                 // \"(-5+10i)\"\nfmt.Println(real(x*y))           // \"-5\"\nfmt.Println(imag(x*y))           // \"10\"\n\n```\n\n## 3.4 布尔类型\n\n布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:\n\n```golang\ni := 0\nif b {\n    i = 1\n}\n```\n\n## 3.5 字符串\n\n- 字符串可以用==和<进行比较；比较通过逐个字节比较完成的\n- 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故`s[0] = 'L' // compile error: cannot assign to s[0]`\n\n  - 因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中\n  - 可在字符串面值中写`十六进制`和`八进制`数字进行码点转义\n  - 原生字面值用反引号(`)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.\n  - 通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思\n  - UTF-8 [to be continue]\n  - `bytes`、`strings`、`strconv`和`unicode`包,四个包对字符串处理尤为重要,`strings`包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能\n  - 字符串和数字的转换,`strconv`包提供这类转换功能\n\n# 4. 复合数据类型\n\n## 4.1 数组\n数组代码示例\n```golang\nvar a [3]int             // array of 3 integers\nfmt.Println(a[0])        // print the first element\nfmt.Println(a[len(a)-1]) // print the last element, a[2]\n\n// Print the indices and elements.\nfor i, v := range a {\n    fmt.Printf(\"%d %d\\n\", i, v)\n}\n\n// Print the elements only.\nfor _, v := range a {\n    fmt.Printf(\"%d\\n\", v)\n}\n```\n\n如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算\n```golang\nq := [...]int{1, 2, 3}\nfmt.Printf(\"%T\\n\", q) // \"[3]int\"\n```\n上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化\n```golang\ntype Currency int\n\nconst (\n    USD Currency = iota // 美元\n    EUR                 // 欧元\n    GBP                 // 英镑\n    RMB                 // 人民币\n)\n\nsymbol := [...]string{USD: \"$\", EUR: \"€\", GBP: \"￡\", RMB: \"￥\"}\n\nfmt.Println(RMB, symbol[RMB]) // \"3 ￥\"\n```\n定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。\n```golang\nr := [...]int{99: -1}\n```\n数组进行比较是比较所有元素是否相等\n## 4.2 slice\n创建slice变量\n```golang\nv_len := make([]T, len)\nv_len_cap := make([]T, len, cap) // same as make([]T, cap)[:len]\ns := []int{0, 1, 2, 3, 4, 5}\n```\n`slice`和`数组`典型的不同就是`slice`不指定长度\n`bytes.Equal`函数来判断两个字节型slice是否相等（[]byte)\n```golang\nfunc equal(x, y []string) bool {\n    if len(x) != len(y) {\n        return false\n    }\n    for i := range x {\n        if x[i] != y[i] {\n            return false\n        }\n    }\n    return true\n}\n```\n\nslice的nil值\n\n```golang\nvar s []int    // len(s) == 0, s == nil\ns = nil        // len(s) == 0, s == nil\ns = []int(nil) // len(s) == 0, s == nil\ns = []int{}    // len(s) == 0, s != nil\n```\n\n### 4.2.1 append函数\n(留着放些API东西)\n\n\n## 4.3 Map\n其中K对应的key必须是支持==比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在  \n创建map\n```golang\nages := make(map[string]int) // mapping from strings to ints\nages := map[string]int{\n    \"alice\":   31,\n    \"charlie\": 34,\n}\n//访问map数据，也是put操作\nages[\"alice\"] = 32\n//删除元素\ndelete(ages, \"alice\") // remove element ages[\"alice\"]\n//map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：\n_ = &ages[\"bob\"] // compile error: cannot take address of map element\n\n```\nMap的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序\n\n```golang\nimport \"sort\"\n\nvar names []string\nfor name := range ages {\n    names = append(names, name)\n}\nsort.Strings(names)\nfor _, name := range names {\n    fmt.Printf(\"%s\\t%d\\n\", name, ages[name])\n}\n```\n\nmap返回两个值，第一个值是bool类型,false则说明不存在这个key。\nmap的key要求必须是可比较类型，那么如果想用slice作为key就需要写小改动\n\n```golang\nvar m = make(map[string]int)\n\nfunc k(list []string) string { return fmt.Sprintf(\"%q\", list) }\n\nfunc Add(list []string)       { m[k(list)]++ }\nfunc Count(list []string) int { return m[k(list)] }\n```\n\n## 4.4 结构体\n\n```golang\nseen := make(map[string]struct{}) // set of strings\n// ...\nif _, ok := seen[s]; !ok {\n    seen[s] = struct{}{}\n    // ...first time seeing s...\n}\n```\n\n### 4.4.1 结构体字面值\n\n```golang\ntype Point struct{ X, Y int }\n//第一种类型初始化方式\np := Point{1, 2}\n//第二种初始化方式,如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要\np :=Point{x:1,y:2}\n```\n\n非导出结构体或者字段，不能在其他包中进行赋值\n\n```golang\npackage p\ntype T struct{ a, b int } // a and b are not exported\n\npackage q\nimport \"p\"\nvar _ = p.T{a: 1, b: 2} // compile error: can't reference a, b\nvar _ = p.T{1, 2}       // compile error: can't reference a, b\n```\n\n如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，\n\n```golang\n\nfunc Bonus(e *Employee, percent int) int {\n    return e.Salary * percent / 100\n}\n```\n\n可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：\n\n```golang\npp := &Point{1, 2}\n```\n\n它和下面的语句是等价的\n\n```golang\npp := new(Point)\n*pp = Point{1, 2}\n```\n\n### 4.4.2 结构体的比较\n\n首先结构体是可比较类型\n\n```golang\n\ntype Point struct{ X, Y int }\n\np := Point{1, 2}\nq := Point{2, 1}\nfmt.Println(p.X == q.X && p.Y == q.Y) // \"false\"\nfmt.Println(p == q)                   // \"false\"\n\n```\n\n### 4.4.3 结构体嵌入和匿名成员\n\n```golang\n\ntype Point struct {\n    X, Y int\n}\n\ntype Circle struct {\n    Center Point\n    Radius int\n}\n\ntype Wheel struct {\n    Circle Circle\n    Spokes int\n}\n\nvar w Wheel\nw.Circle.Center.X = 8\nw.Circle.Center.Y = 8\nw.Circle.Radius = 5\nw.Spokes = 20\n```\n\n匿名成员，说白了就是只写类型不写名字.\n\n```golang\ntype Circle struct {\n    Point\n    Radius int\n}\n\ntype Wheel struct {\n    Circle\n    Spokes int\n}\n\nvar w Wheel\nw.X = 8            // equivalent to w.Circle.Point.X = 8\nw.Y = 8            // equivalent to w.Circle.Point.Y = 8\nw.Radius = 5       // equivalent to w.Circle.Radius = 5\nw.Spokes = 20\n//以下初始化是错误的\nw = Wheel{8, 8, 5, 20}                       // compile error: unknown fields\nw = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields\n```\n\n所以我们只能用下面两种方式进行初始化\n\n```golang\n\nw = Wheel{Circle{Point{8, 8}, 5}, 20}\n\nw = Wheel{\n    Circle: Circle{\n        Point:  Point{X: 8, Y: 8},\n        Radius: 5,\n    },\n    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)\n}\n\nfmt.Printf(\"%#v\\n\", w)\n// Output:\n// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}\n\nw.X = 42\n\nfmt.Printf(\"%#v\\n\", w)\n// Output:\n// Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}\n\n```\n需要注意，但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。\n\n## 4.5 json字符串\n\n`json.Marshal`包\n代码例子\n```golang\ntype Movie struct {\n    Title  string\n    Year   int  `json:\"released\"` // 这个tag指定生成json名字\n    Color  bool `json:\"color,omitempty\"`\n    Actors []string\n}\n\nvar movies = []Movie{\n    {Title: \"Casablanca\", Year: 1942, Color: false,\n        Actors: []string{\"Humphrey Bogart\", \"Ingrid Bergman\"}},\n    {Title: \"Cool Hand Luke\", Year: 1967, Color: true,\n        Actors: []string{\"Paul Newman\"}},\n    {Title: \"Bullitt\", Year: 1968, Color: true,\n        Actors: []string{\"Steve McQueen\", \"Jacqueline Bisset\"}},\n    // ...\n}\n```\n\n## 4.6 文本和HTML模板\n(后面需要时候着重的看)\n`text/template和html/template`,们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。模板语言支持流程控制语句\n模板语言demo\n\n```golang\nconst templ = `{{.TotalCount}} issues:\n{{range .Items}}----------------------------------------\nNumber: {{.Number}}\nUser:   {{.User.Login}}\nTitle:  {{.Title | printf \"%.64s\"}}\nAge:    {{.CreatedAt | daysAgo}} days\n{{end}}`\n```\n\n`|` 操作符表示将前一个表达式的结果作为后一个函数的输入.  \n生成模板的输出需要两个处理步骤\n\n```golang\nvar report = template.Must(template.New(\"issuelist\").\n    Funcs(template.FuncMap{\"daysAgo\": daysAgo}).\n    Parse(templ))\n\nfunc main() {\n    result, err := github.SearchIssues(os.Args[1:])\n    if err != nil {\n        log.Fatal(err)\n    }\n    if err := report.Execute(os.Stdout, result); err != nil {\n        log.Fatal(err)\n    }\n}\n```\n如果想转化为html则需要编写如下代码\n```golang\n\nimport \"html/template\"\n\nvar issueList = template.Must(template.New(\"issuelist\").Parse(`\n<h1>{{.TotalCount}} issues</h1>\n<table>\n<tr style='text-align: left'>\n  <th>#</th>\n  <th>State</th>\n  <th>User</th>\n  <th>Title</th>\n</tr>\n{{range .Items}}\n<tr>\n  <td><a href='{{.HTMLURL}}'>{{.Number}}</a></td>\n  <td>{{.State}}</td>\n  <td><a href='{{.User.HTMLURL}}'>{{.User.Login}}</a></td>\n  <td><a href='{{.HTMLURL}}'>{{.Title}}</a></td>\n</tr>\n{{end}}\n</table>\n`))\n```\n注意，html/template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text/template包的话，这2个issue将会产生错误，其中“&lt;”四个字符将会被当作小于字符“<”处理，同时“<link>”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。\n\n# 5. 函数\n\n声明和定义\n- switch 控制语句\n\n  ```golang\n  switch cond{\n    case a :\n        fmt.Printf()\n    case b :\n        fmt.Printf()\n    case c :\n        fmt.Printf()\n  }\n  ```\n\n## 5.1 错误\n通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。\n\n我们有几种处理错误的策略\n1. 发生错误时的解析器\n\n  发生解析错误后,findLinks 函数构造了一个新的异常信息,既包含了自定义的，也包含了底层解析出错的信息\n\n  ```golang\n  doc, err := html.Parse(resp.Body)\n  resp.Body.Close()\n  if err != nil {\n      return nil, fmt.Errorf(\"parsing %s as HTML: %v\", url,err)\n  }\n  ```\n\n  参考宇航局事故调查\n2. 重试\n  我们需要限制重试的时间间隔或重试的次数，防止无限制的重试.\n3. 输出错误信息并结束程序\n  输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行,对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序\n  ```golang\n  if err := WaitForServer(url); err != nil {\n    log.Fatalf(\"Site is down: %v\\n\", err)\n  }\n  ```\n  `log.Fatalf`代码更简洁，并输出自定义格式信息\n\n4. 只是输出错误信息就可以\n\n  ```golang\n  if err := Ping(); err != nil {\n    log.Printf(\"ping failed: %v; networking disabled\",err)\n  }\n  //或者标准错误流输出错误信息。\n\n  if err := Ping(); err != nil {\n      fmt.Fprintf(os.Stderr, \"ping failed: %v; networking disabled\\n\", err)\n  }\n  ```\n\n5. 直接忽略掉错误\n\n  ```golang\n  dir, err := ioutil.TempDir(\"\", \"scratch\")\n  if err != nil {\n      return fmt.Errorf(\"failed to create temp dir: %v\",err)\n  }\n  // ...use temp dir…\n  os.RemoveAll(dir) // ignore errors; $TMPDIR is cleaned periodically\n  ```\n  尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响\n\n6. 文件结尾错误\n\nio包保证任何由文件结束引起的读取失败都返\n```golang\npackage io\n\nimport \"errors\"\n\n// EOF is the error returned by Read when no more input is available.\nvar EOF = errors.New(\"EOF\")\n\nin := bufio.NewReader(os.Stdin)\nfor {\n    r, _, err := in.ReadRune()\n    if err == io.EOF {\n        break // finished reading\n    }\n    if err != nil {\n        return fmt.Errorf(\"read failed:%v\", err)\n    }\n    // ...use r…\n}\n```\n\n## 5.2 函数值\n\n- 函数在golang中也是一种类型，可以被复制给其他变量。  \n- 很熟类型的`零`值是`nil`,调用值为nil会引起`panic`错误  \n- 函数值之间是不可以比较的,也不能用函数值作为map的key\n- strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者\n  \n  ```golang\n  func add1(r rune) rune { return r + 1 }\n\n  fmt.Println(strings.Map(add1, \"HAL-9000\")) // \"IBM.:111\"\n  fmt.Println(strings.Map(add1, \"VMS\"))      // \"WNT\"\n  fmt.Println(strings.Map(add1, \"Admix\"))    // \"Benjy\"\n  ```\n\ndemo示例\n\n```golang\n//值得学习\n// forEachNode针对每个结点x，都会调用pre(x)和post(x)。\n// pre和post都是可选的。\n// 遍历孩子结点之前，pre被调用\n// 遍历孩子结点之后，post被调用\nfunc forEachNode(n *html.Node, pre, post func(n *html.Node)) {\n    if pre != nil {\n        pre(n)\n    }\n    for c := n.FirstChild; c != nil; c = c.NextSibling {\n        forEachNode(c, pre, post)\n    }\n    if post != nil {\n        post(n)\n    }\n}\n```\n\n## 5.3 匿名函数\n函数内部定义的函数可以访问整个词法环境，言外之意就是嵌套的函数可以访问外层函数的变量\n```golang\n// squares返回一个匿名函数。\n// 该匿名函数每次被调用时都会返回下一个数的平方。\n//squares 函数每次都返回一个函数类型-func()int{}\nfunc squares() func() int {\n    var x int\n    return func() int { // 匿名函数\n        x++\n        return x * x\n    }\n}\nfunc main() {\n    f := squares()\n    fmt.Println(f()) // \"1\"\n    fmt.Println(f()) // \"4\"\n    fmt.Println(f()) // \"9\"\n    fmt.Println(f()) // \"16\"\n}\n//通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。\n```\n\n> 网页抓取的核心问题就是如何遍历图\n\n警告:捕获迭代变量\n```golang\nvar rmdirs []func()\nfor _, d := range tempDirs() {\n    dir := d // NOTE: necessary!\n    os.MkdirAll(dir, 0755) // creates parent directories too\n    rmdirs = append(rmdirs, func() {\n        os.RemoveAll(dir)\n    })\n}\n// ...do some work…\nfor _, rmdir := range rmdirs {\n    rmdir() // clean up\n}\n// \nvar rmdirs []func()\nfor _, dir := range tempDirs() {\n    os.MkdirAll(dir, 0755)\n    rmdirs = append(rmdirs, func() {\n        os.RemoveAll(dir) // NOTE: incorrect!\n    })\n}\n\n```\n问题出在了循环变量的作用域,循环变量dir在这个词法块中被声明，每一次迭代都是会不断地更新这个值，被`range`语句，解决这个问题的办法就是引入同名变量来覆盖其作用域。\n\n## 5.4 可变参数\n简单的可变参数例子,其实`可变参数`就是个切片的值传递,`interface{}`表示函数的最后一个参数可以接收任意类型\n```golang\nfunc sum(vals ...int) int {\n    total := 0\n    for _, val := range vals {\n        total += val\n    }\n    return total\n}\n```\n如果原参数就是切片该怎么传递？可以直接在`实参`后面加省略号\n\n## 5.5 defer函数\n\n在函数执行完成之后，不管是正常退出还是异常退出函数，最后都会被执行\n\n## 5.6 panic异常\n\n当panic发生时会在该goroutine上执行defer函数，打印对应的栈信息\n`regexp`包的使用\n为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。\n```golang\nfunc main() {\n    defer printStack()\n    f(3)\n}\nfunc printStack() {\n    var buf [4096]byte\n    n := runtime.Stack(buf[:], false)\n    os.Stdout.Write(buf[:n])\n}\n\n```\n将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。\n\n\n## 5.7 Recovery捕获异常\n\n通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所\n\n- 语言解析器为例\n说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误\n\n```golang\nfunc Parse(input string) (s *Syntax, err error) {\n    defer func() {\n        if p := recover(); p != nil {\n            err = fmt.Errorf(\"internal error: %v\", p)\n        }\n    }()\n    // ...parser...\n}\n```\n\n\n- 虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。  \n- 有时我们很难完全遵循规范，举个例子，net/http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。\n\n```golang\n// soleTitle returns the text of the first non-empty title element\n// in doc, and an error if there was not exactly one.\n//防御性panic代码\nfunc soleTitle(doc *html.Node) (title string, err error) {\n    type bailout struct{}\n    defer func() {\n        switch p := recover(); p {\n        case nil:       // no panic\n        case bailout{}: // \"expected\" panic\n            err = fmt.Errorf(\"multiple title elements\")\n        default:\n            panic(p) // unexpected panic; carry on panicking\n        }\n    }()\n    // Bail out of recursion if we find more than one nonempty title.\n    forEachNode(doc, func(n *html.Node) {\n        if n.Type == html.ElementNode && n.Data == \"title\" &&\n            n.FirstChild != nil {\n            if title != \"\" {\n                panic(bailout{}) // multiple titleelements\n            }\n            title = n.FirstChild.Data\n        }\n    }, nil)\n    if title == \"\" {\n        return \"\", fmt.Errorf(\"no title element\")\n    }\n    return title, nil\n}\n```\n\n# 6. 方法\n\n## 6.1 方法声明\n\n- 普通函数与接收器方法\n`接收器`因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。对于一个给定的类型，其内部的方法都必须有唯一的方法名\n\n## 6.2 基于指针对象的方法\n\n- 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。\n- 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。\n- 当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们下面例子里做的这样\n    ```golang\n    func (list *IntList) Sum() int {\n    if list == nil {\n        return 0\n    }\n    return list.Value + list.Tail.Sum()\n    }\n    ```\n    如果此时结构体是`nil`调用对象可能会发生类似于空指针异常的错误\n\n## 6.3. 通过嵌入结构体来扩展类型\n\n- 方法值\n    在go语言中，方法是第一公民，这一点在函数式编程中非常实用(maybe)\n\n    ```golang\n    //方法值demo\n    p := Point{1, 2}\n    q := Point{4, 6}\n\n    distanceFromP := p.Distance        // method value,Distance是结构体方法\n    fmt.Println(distanceFromP(q))      // \"5\"\n    var origin Point                   // {0, 0}\n    fmt.Println(distanceFromP(origin)) // \"2.23606797749979\", sqrt(5)\n\n    scaleP := p.ScaleBy // method value\n    scaleP(2)           // p becomes (2, 4)\n    scaleP(3)           //      then (6, 12)\n    scaleP(10)          //      then (60, 120)\n    ```\n\n- 方法表达式\n    在面向对象中，当根据哪一个变量来决定调用哪个函数时候,方法表达式就很有用了.\n\n    ```golang\n    p := Point{1, 2}\n    q := Point{4, 6}\n\n    distance := Point.Distance   // method expression\n    fmt.Println(distance(p, q))  // \"5\"\n    fmt.Printf(\"%T\\n\", distance) // \"func(Point, Point) float64\"\n\n    scale := (*Point).ScaleBy\n    scale(&p, 2)\n    fmt.Println(p)            // \"{2 4}\"\n    fmt.Printf(\"%T\\n\", scale) // \"func(*Point, float64)\"\n\n    ```\n\npractice demo\n\n```golang\ntype Point struct{ X, Y float64 }\n\nfunc (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }\nfunc (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }\n\ntype Path []Point\n\nfunc (path Path) TranslateBy(offset Point, add bool) {\n    var op func(p, q Point) Point\n    if add {\n        op = Point.Add\n    } else {\n        op = Point.Sub\n    }\n    for i := range path {\n        // Call either path[i].Add(offset) or path[i].Sub(offset).\n        path[i] = op(path[i], offset)\n    }\n}\n```\n\n## 6.4 封装\n\n封装提供了三方面的优点。\n1. 首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可.\n2. 第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由\n3. bytes.Buffer这个类型作为例子来考虑\n\n    ```golang\n\n    type Buffer struct {\n    buf     []byte\n    initial [64]byte\n    /* ... */\n    }\n\n    // Grow expands the buffer's capacity, if necessary,\n    // to guarantee space for another n bytes. [...]\n    func (b *Buffer) Grow(n int) {\n        if b.buf == nil {\n            b.buf = b.initial[:0] // use preallocated space initially\n        }\n        if len(b.buf)+n > cap(b.buf) {\n            buf := make([]byte, b.Len(), 2*cap(b.buf) + n)\n            copy(buf, b.buf)\n            b.buf = buf\n        }\n    }\n    // Grow()函数式导出类型，但是stuct的字段不是到处类型\n    ```\n\n4. 只暴漏关键信息给外部使用者\n\n\n# 7. 接口\n\n很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用  \n\n只要一个物体能像鸭子一样叫那我们就可以称它为鸭子；只要一个软件能存储和查询数据我们就可以称它为数据库；只要一台机器有洗衣服和甩干的功能我们就可以称它为洗衣机。  \n\n为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型\n\n## 7.1. 接口约定\n\n例如`fmt`包\n\n```golang\n    package fmt\n\n    func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)\n    //Printf 最后调用Fprintf 函数\n    func Printf(format string, args ...interface{}) (int, error) {\n        return Fprintf(os.Stdout, format, args...)\n    }\n    // Sprintf函数最后也是调用Fprintf\n    func Sprintf(format string, args ...interface{}) string {\n        var buf bytes.Buffer\n        Fprintf(&buf, format, args...)\n        return buf.String()\n    }\n```\n\n`Fprintf`函数的`F`说明了文件类型也说明了所有信息要被写入到文件当中，在`Printf`函数中的第一个参数`os.Stdout`是`*os.File`类型实现了`io.Writer`接口，在`Sprintf`函数中的第一个参数`&buf`是一个指向可以写入字节的内存缓冲区也该类型也是实现了`io.Writer`接口,用户可以自定义一个函数并实现`io.Writer`接口。  \n**LSP里氏替换** : `fmt.Fprintf`通过使用接口类型`io.Writer`使得只要调用者只要传入实现了该接口的类型就可以实现自由替换\n\n<details><summary>自定义bytecounter函数，实现计算int转byte长度</summary>\n\n```golang\n\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n//!+bytecounter\n\ntype ByteCounter int\n\nfunc (c *ByteCounter) Write(p []byte) (int, error) {\n\t*c += ByteCounter(len(p)) // convert int to ByteCounter\n\treturn len(p), nil\n}\n\n//!-bytecounter\n\nfunc main() {\n\t//!+main\n\tvar c ByteCounter\n\tc.Write([]byte(\"hello\"))\n\tfmt.Println(c) // \"5\", = len(\"hello\")\n\n\tc = 0 // reset the counter\n\tvar name = \"Dolly\"\n\tfmt.Fprintf(&c, \"hello, %s\", name)\n\tfmt.Println(c) // \"12\", = len(\"hello, Dolly\")\n\t//!-main\n}\n```\n\n</details>\n\n因为它实现了`writer`接口就可以传入到`Fprintf`函数中.总结来说，接口约定了包使用者的行为，但是使用者想创建什么样的实例需要他自己去实现。\n\n\n## 7.2 接口类型\n\n通过组合定义接口\n```golang\npackage io\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\ntype Closer interface {\n    Close() error\n}\n\ntype ReadWriter interface {\n    Reader\n    Writer\n}\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n// 另一种命名风格\ntype ReadWriter interface {\n    Read(p []byte) (n int, err error)\n    Write(p []byte) (n int, err error)\n}\n//或者甚至使用一种混合的风格：\n\ntype ReadWriter interface {\n    Read(p []byte) (n int, err error)\n    Writer\n}\n```\n\n## 7.3 实现接口的条件\n\n- 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口.\n\n    ```golang\n    var w io.Writer\n    //只实现了Write 方法\n    w = os.Stdout           // OK: *os.File has Write method\n    //只实现了Write方法\n    w = new(bytes.Buffer)   // OK: *bytes.Buffer has Write method\n    // time.Duration没有Write方法\n    w = time.Second         // compile error: time.Duration lacks Write method\n\n    var rwc io.ReadWriteCloser\n    rwc = os.Stdout         // OK: *os.File has Read, Write, Close methods\n    rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method\n    // 这个规则甚至适用于等式右边本身也是一个接口类型\n    // rwc io.ReadWriteCloser\n    w = rwc                 // OK: io.ReadWriteCloser has Write method\n    // w 只有Write方法\n    rwc = w                 // compile error: io.Writer lacks Close method\n    ```\n\n- \n\n\n## 7.4 flag.Value接口\n(翻译的太差劲，要去读原文)\n- 简单的`flag`包支持命令行的例子\n\n    ```golang\n    var period = flag.Duration(\"period\", 1*time.Second, \"sleep period\")\n\n    func main() {\n        flag.Parse()\n        fmt.Printf(\"Sleeping for %v...\", *period)\n        time.Sleep(*period)\n        fmt.Println()\n    }\n    ```\n\n- 自定义新的标记符号\n\n    ```golang\n    package tempconv\n\n    import (\n        \"flag\"\n        \"fmt\"\n    )\n\n    type Celsius float64\n    type Fahrenheit float64\n\n    func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9.0/5.0 + 32.0) }\n    func FToC(f Fahrenheit) Celsius { return Celsius((f - 32.0) * 5.0 / 9.0) }\n\n    func (c Celsius) String() string { return fmt.Sprintf(\"%g°C\", c) }\n\n    /*\n    //!+flagvalue\n    package flag\n\n    // Value is the interface to the value stored in a flag.\n    type Value interface {\n        String() string\n        Set(string) error\n    }\n    //!-flagvalue\n    */\n\n    //!+celsiusFlag\n    // *celsiusFlag satisfies the flag.Value interface.\n    type celsiusFlag struct{ Celsius }\n\n    func (f *celsiusFlag) Set(s string) error {\n        var unit string\n        var value float64\n        fmt.Sscanf(s, \"%f%s\", &value, &unit) // no error check needed\n        switch unit {\n        case \"C\", \"°C\":\n            f.Celsius = Celsius(value)\n            return nil\n        case \"F\", \"°F\":\n            f.Celsius = FToC(Fahrenheit(value))\n            return nil\n        }\n        return fmt.Errorf(\"invalid temperature %q\", s)\n    }\n\n    //!-celsiusFlag\n\n    //!+CelsiusFlag\n\n    // CelsiusFlag defines a Celsius flag with the specified name,\n    // default value, and usage, and returns the address of the flag variable.\n    // The flag argument must have a quantity and a unit, e.g., \"100C\".\n    func CelsiusFlag(name string, value Celsius, usage string) *Celsius {\n        f := celsiusFlag{value}\n        flag.CommandLine.Var(&f, name, usage)\n        return &f.Celsius\n    }\n    // main函数\n    var temp = tempconv.CelsiusFlag(\"temp\", 20.0, \"the temperature\")\n\n    func main() {\n        flag.Parse()\n        fmt.Println(*temp)\n    }\n    ```\n\n## 7.5 接口值\n\n下面语句中,`io.Writer`是接口类型值\n\n```golang\nvar w io.Writer\nw = os.Stdout\nw = new(bytes.Buffer)\nw = nil\n```\n- 对于接口的定义也不例外，`接口`的零值是它的类型和值的部分都是`nil`\n- 一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生`panic`: `w.Write([]byte(\"hello\")) // panic: nil pointer dereference`\n- 第二句statement，这个赋值过程调用了一个`具体类型`到`接口类型`的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的`os.File`类型变量的指针.接口值可以使用`==`和`!＝`来进行比较。两个接口值相等仅当它们都是nil值。\n    ```golang\n    w.Write([]byte(\"hello\")) // \"hello\"\n    os.Stdout.Write([]byte(\"hello\")) // \"hello\" \n    //上下两句是等价的\n    ```\n- 一个接口值可以持有任意大的动态值\n\n    ```golang\n    var x interface{} = time.Now()\n    ```\n\n    接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数,然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:\n\n    ```golang\n    var x interface{} = []int{1, 2, 3}\n    fmt.Println(x == x) // panic: comparing uncomparable type []int\n    ```\n\n\n考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值.\n\n\n\n- *警告*: 一个包含nil指针的接口不是nil接口\n\n一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。\n\n思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。\n\n```golang\nconst debug = true\n\nfunc main() {\n    var buf *bytes.Buffer\n    if debug {\n        buf = new(bytes.Buffer) // enable collection of output\n    }\n    f(buf) // NOTE: subtly incorrect!\n    if debug {\n        // ...use buf...\n    }\n}\n\n// If out is non-nil, output will be written to it.\nfunc f(out io.Writer) {\n    // ...do something...\n    if out != nil {\n        out.Write([]byte(\"done!\\n\"))\n    }\n}\n```\n我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：\n\n```golang\nif out != nil {\n    out.Write([]byte(\"done!\\n\")) // panic: nil pointer dereference\n}\n```\n当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!=nil的结果依然是true。\n\n![](https://user-images.githubusercontent.com/46363359/182982938-08d67c3f-7aa6-457d-88a5-02646c5e2735.png)\n\n动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者（§6.2.1），但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。\n\n问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：\n\n```golang\nvar buf io.Writer\nif debug {\n    buf = new(bytes.Buffer) // enable collection of output\n}\nf(buf) // OK\n```\n现在我们已经把接口值的技巧都讲完了，让我们来看更多的一些在Go标准库中的重要接口类型。在下面的三章中，我们会看到接口类型是怎样用在排序，web服务，错误处理中的。\n\n\n\n## 7.6. sort.Interface接口\ngolang提供了`sort`包帮助进行排序数据,实现排序需要自己实现对应的排序接口.\n```golang\ntype byArtist []*Track\nfunc (x byArtist) Len() int           { return len(x) }\nfunc (x byArtist) Less(i, j int) bool { return x[i].Artist < x[j].Artist }\nfunc (x byArtist) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }\n```\n对于自定义的排序，我们也需要实现排序函数.\n```golang\n//!+customcode\ntype customSort struct {\n\tt    []*Track\n\tless func(x, y *Track) bool\n}\n\nfunc (x customSort) Len() int           { return len(x.t) }\nfunc (x customSort) Less(i, j int) bool { return x.less(x.t[i], x.t[j]) }\nfunc (x customSort) Swap(i, j int)      { x.t[i], x.t[j] = x.t[j], x.t[i] }\n\nsort.Sort(customSort{tracks, func(x, y *Track) bool {\n\t\tif x.Title != y.Title {\n\t\t\treturn x.Title < y.Title\n\t\t}\n\t\tif x.Year != y.Year {\n\t\t\treturn x.Year < y.Year\n\t\t}\n\t\tif x.Length != y.Length {\n\t\t\treturn x.Length < y.Length\n\t\t}\n\t\treturn false\n\t}})\n```\n`IntsAreSorted(...interface{})` reports whether the slice x is sorted in increasing order.\n\n## 7.7. http.Handler接口\n\nhttp.Handler的实例\n\n## 7.8. error接口\n\n```golang\n\npackage errors_demo\n\nfunc New(text string) error { return &errorString{text} }\n\ntype errorString struct { text string }\n\nfunc (e *errorString) Error() string { return e.text }\n```\n调用`errors.New`函数是非常稀少的，因为有一个方便的封装函数`fmt.Errorf`它还会处理字符串格式化\n另一个error demo实例\n```golang\npackage syscall\n\ntype Errno uintptr // operating system error code\n\nvar errors = [...]string{\n    1:   \"operation not permitted\",   // EPERM\n    2:   \"no such file or directory\", // ENOENT\n    3:   \"no such process\",           // ESRCH\n    // ...\n}\n\nfunc (e Errno) Error() string {\n    if 0 <= int(e) && int(e) < len(errors) {\n        return errors[e]\n    }\n    return fmt.Sprintf(\"errno %d\", e)\n}\n\nvar err error = syscall.Errno(2)\nfmt.Println(err.Error()) // \"no such file or directory\"\nfmt.Println(err)         // \"no such file or directory\"\n```\n用有限几个进行描述，并且它满足标准错误接口\n\n## 7.9. 类型断言\n\n语法上它看起来像`x.(T)`被称为断言类型，这里`x`表示一个接口的类型和T表示一个类型,详细解释，一个类型断言检查它操作对象的动态类型是否和断言的类型是否匹配,分两种情况\n\n- (T传入的是具体类型，X是动态类型),然后类型断言检查`X`的动态类型是否和`T`相同.如果检查成功了类型断言的结果就是`X`的动态值\n\n- (T传入的是接口类型，X是动态类型),然后类型断言检查是否`x`的动态类型满足T,如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值\n    ```golang\n\n    var w io.Writer\n    w = os.Stdout   //能赋值说明os.Stdout 实现了Write()方法\n    rw := w.(io.ReadWriter) // success: *os.File has both Read and Write,断言w是否实现了接口(io.ReadWriter)的Read和Write接口\n    w = new(ByteCounter)\n    rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method\n    //如果对预期结果只是个判断就可以用第二个返回参数bool.\n    var w io.Writer = os.Stdout\n    f, ok := w.(*os.File)      // success:  ok, f == os.Stdout\n    b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil\n    // if 后面的w变量不会覆盖外层的w\n    if w, ok := w.(*os.File); ok {\n    // ...use w...\n    }\n    ```\n\n\n## 7.10. 基于类型断言区别错误类型\n对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，但是处理I/O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。\n\n一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：\n```golang\n\n\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n)\n\ntype PathError struct {\n\tOp   string\n\tPath string\n\tErr  error\n}\n\nfunc (e *PathError) Error() string {\n\treturn e.Op + \" \" + e.Path + \": \" + e.Err.Error()\n}\n\nvar ErrNotExist = errors.New(\"file does not exist\")\n\n// IsNotExist returns a boolean indicating whether the error is known to\n// report that a file or directory does not exist. It is satisfied by\n// ErrNotExist as well as some syscall errors.\nfunc IsNotExist(err error) bool {\n\tif pe, ok := err.(*PathError); ok {\n\t\terr = pe.Err\n\t}\n\treturn err == syscall.ENOENT || err == ErrNotExist\n}\n\nfunc main() {\n\t_, err := os.Open(\"/no/such/file\")\n\tfmt.Println(os.IsNotExist(err)) // \"true\"\n}\n```\n\n## 7.11. any关键字与泛型\n类型定义时不限制`形参类型`，在函数调用的时候再指定`具体类型`.  `any`其实是`interface{}`的别名\n泛型好处:  (1).在编译期间对类型进行检查以提高类型安全(2).通过指定类型消除强制类型转换(3).能够减少代码重复性，提供更通用的功能函数。\n\n- 类型泛型\n  ```golang\n    package main\n\n    import \"fmt\"\n\n    type ListType[T int | int32 | int64 | string] []T\n\n    type MapType[K int | int32, V int64 | string] map[K]V\n\n    func main() {\n        var intList ListType[int]\n        intList = []int{1, 2, 3}\n        fmt.Println(intList)\n        strList := ListType[string]{\"1\", \"2\", \"3\"}\n        fmt.Println(strList)\n\n        intMap := MapType[int, string]{1: \"1\", 2: \"2\"}\n        int32Map := MapType[int32, int64]{1: 2, 3: 4}\n        fmt.Println(intMap)\n        fmt.Println(int32Map)\n    }\n  ```\n  这里面的T,K,V都是占位符号,`ListType`只能在那三种类型中选择,同理`MapType`也是\n- 接口泛型\n  ```golang\n  type GenericStackInterface[T any] interface {\n    Push(element T)\n    Pop() T\n  }\n  ```\n- 泛型函数\n  ```golang\n    func minInt[T int | int8 | int16 | int32](a, b T) T {\n    if a < b {\n        return a\n    }\n        return b\n    }\n\n    func maxInt[T int | int8 | int16 | int32](a, b T) T {\n        if a > b {\n            return a\n        }\n        return b\n    }\n    func Mix(a any) any {\n\n    }\n    //还可以简化一下\n    type Numeric interface {\n        int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64\n    }\n    func min[T Numeric](a, b T) T {\n    if a < b {\n        return a\n    }\n        return b\n    }\n\n    func max[T Numeric](a, b T) T {\n        if a > b {\n            return a\n        }\n        return b\n    }\n    // go.18内置了数字类型的集合，故可以\n    import (\n    \"golang.org/x/exp/constraints\"\n    )\n\n    func minType[T constraints.Ordered](a, b T) T {\n        if a < b {\n            return a\n        }\n        return b\n    }\n\n    func maxType[T constraints.Ordered](a, b T) T {\n        if a > b {\n            return a\n        }\n        return b\n    }\n  ```\n  如果进入`constraints`源代码查看其具体代码的话，会发现在 Ordered 类型中也是有各种数字类型组合起来的。但是有一点奇怪的地方就是这里的类型集合中，各种类型前加了一个波浪线~, 表示衍生类型，即使用 type 自定义的类型也可以被识别到，只要底层类型一致即可。比如 ~int 可以包含 int 和 type MyInt int 等多种类型\n\n\n\n# 8. Goroutines和Channels\n(多看看本章代码)\n## 8.1 goroutine\n通过代码示例了解`goroutine`的使用\n```golang\nfunc main() {\n    go spinner(100 * time.Millisecond)\n    const n = 45\n    fibN := fib(n) // slow\n    fmt.Printf(\"\\rFibonacci(%d) = %d\\n\", n, fibN)\n}\n\nfunc spinner(delay time.Duration) {\n    for {\n        for _, r := range `-\\|/` {\n            fmt.Printf(\"\\r%c\", r)\n            time.Sleep(delay)\n        }\n    }\n}\n\nfunc fib(x int) int {\n    if x < 2 {\n        return x\n    }\n    return fib(x-1) + fib(x-2)\n}\n```\n## 8.2 channel\n\n这里应该还得看一下uber编码规范\n\n- 无缓冲channel\n    ```golang\n    ch <- x\n    x = <-chan //取出元素\n    <- ch //取出，舍弃\n    close(ch) // 关闭chan\n    ```\n\n    - 串联channel\n    \n    - 单方向channel\n\n- 缓冲channel\n    ```golang\n    ch = make(chan string, 3) //channel容量为3\n    ```\n## 8.3 基于select的多路复用\n\n<details>\n<summary>多路复用demo</summary>\n<pre>\n\n```golang\n// Copyright © 2016 Alan A. A. Donovan & Brian W. Kernighan.\n// License: https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// See page 246.\n\n// Countdown implements the countdown for a rocket launch.\npackage main\n\n// NOTE: the ticker goroutine never terminates if the launch is aborted.\n// This is a \"goroutine leak\".\n\nimport (\n        \"fmt\"\n        \"os\"\n        \"time\"\n)\n\n//!+\n\nfunc main() {\n        // ...create abort channel...\n\n        //!-\n\n        abort := make(chan struct{})\n        go func() {\n                os.Stdin.Read(make([]byte, 1)) // read a single byte\n                abort <- struct{}{}\n        }()\n\n        //!+\n        fmt.Println(\"Commencing countdown.  Press return to abort.\")\n        tick := time.Tick(1 * time.Second)\n        for countdown := 10; countdown > 0; countdown-- {\n                fmt.Println(countdown)\n                select {\n                case <-tick:\n                        // Do nothing.\n                case <-abort:\n                        fmt.Println(\"Launch aborted!\")\n                        return\n                }\n        }\n        launch()\n}\n//!-\nfunc launch() {\n        fmt.Println(\"Lift off!\")\n}\n```\n\n</pre>\n</details>\n\n- goroutine泄露 : 当for语句执行完后，程序已经跳转到其他部分，但是`time.Tick(1 * time.Second)`仍然会继续的网channel里面发送数据，这就会导致gotourine泄露，以上面为例，那么就需要合适的地方调用`tick.stop()`\n\n- channel的ready : 一定要等到channel准备完毕，开始接受或者发送消息\n\n- channel的轮询 : 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”\n\n  ```golang\n  select {\n    case <-abort:\n        fmt.Printf(\"Launch aborted!\\n\")\n        return\n    default:\n        // do nothing\n  }\n  ```\n\n## 8.4. 并发的退出\n\n这节主要讨论如何有效退出goroutines\n\n<details>\n<summary>\n<font size=\"3\" color=\"orange\">goroutines退出代码示例</font></summary>\n<pre>\n\n```golang\n//gopl.io/ch8/du4\n// Copyright © 2016 Alan A. A. Donovan & Brian W. Kernighan.\n// License: https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// See page 251.\n\n// The du4 command computes the disk usage of the files in a directory.\npackage main\n\n// The du4 variant includes cancellation:\n// it terminates quickly when the user hits return.\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"time\"\n)\n\n//!+1\nvar done = make(chan struct{})\n\nfunc cancelled() bool {\n\tselect {\n\tcase <-done:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n//!-1\n\nfunc main() {\n\t// Determine the initial directories.\n\troots := os.Args[1:]\n\tif len(roots) == 0 {\n\t\troots = []string{\".\"}\n\t}\n\n\t//!+2\n\t// Cancel traversal when input is detected.\n\tgo func() {\n\t\tos.Stdin.Read(make([]byte, 1)) // read a single byte\n\t\tclose(done)\n\t}()\n\t//!-2\n\n\t// Traverse each root of the file tree in parallel.\n\tfileSizes := make(chan int64)\n\tvar n sync.WaitGroup\n\tfor _, root := range roots {\n\t\tn.Add(1)\n\t\tgo walkDir(root, &n, fileSizes)\n\t}\n\tgo func() {\n\t\tn.Wait()\n\t\tclose(fileSizes)\n\t}()\n\n\t// Print the results periodically.\n\ttick := time.Tick(500 * time.Millisecond)\n\tvar nfiles, nbytes int64\nloop:\n\t//!+3\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\t// Drain fileSizes to allow existing goroutines to finish.\n\t\t\tfor range fileSizes {\n\t\t\t\t// Do nothing.\n\t\t\t}\n\t\t\treturn\n\t\tcase size, ok := <-fileSizes:\n\t\t\t// ...\n\t\t\t//!-3\n\t\t\tif !ok {\n\t\t\t\tbreak loop // fileSizes was closed\n\t\t\t}\n\t\t\tnfiles++\n\t\t\tnbytes += size\n\t\tcase <-tick:\n\t\t\tprintDiskUsage(nfiles, nbytes)\n\t\t}\n\t}\n\tprintDiskUsage(nfiles, nbytes) // final totals\n}\n\nfunc printDiskUsage(nfiles, nbytes int64) {\n\tfmt.Printf(\"%d files  %.1f GB\\n\", nfiles, float64(nbytes)/1e9)\n}\n\n// walkDir recursively walks the file tree rooted at dir\n// and sends the size of each found file on fileSizes.\n//!+4\nfunc walkDir(dir string, n *sync.WaitGroup, fileSizes chan<- int64) {\n\tdefer n.Done()\n\tif cancelled() {\n\t\treturn\n\t}\n\tfor _, entry := range dirents(dir) {\n\t\t// ...\n\t\t//!-4\n\t\tif entry.IsDir() {\n\t\t\tn.Add(1)\n\t\t\tsubdir := filepath.Join(dir, entry.Name())\n\t\t\tgo walkDir(subdir, n, fileSizes)\n\t\t} else {\n\t\t\tfileSizes <- entry.Size()\n\t\t}\n\t\t//!+4\n\t}\n}\n\n//!-4\n\nvar sema = make(chan struct{}, 20) // concurrency-limiting counting semaphore\n\n// dirents returns the entries of directory dir.\n//!+5\nfunc dirents(dir string) []os.FileInfo {\n\tselect {\n\tcase sema <- struct{}{}: // acquire token\n\tcase <-done:\n\t\treturn nil // cancelled\n\t}\n\tdefer func() { <-sema }() // release token\n\n\t// ...read directory...\n\t//!-5\n\n\tf, err := os.Open(dir)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"du: %v\\n\", err)\n\t\treturn nil\n\t}\n\tdefer f.Close()\n\n\tentries, err := f.Readdir(0) // 0 => no limit; read all entries\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"du: %v\\n\", err)\n\t\t// Don't return: Readdir may return partial results.\n\t}\n\treturn entries\n}\n```\n\n</pre>\n</details>\n\n# 9. 基于共享变量的并发\n(多看这章代码)\n避免数据竞争的三个方法\n- 并发读数据不会有数据竞争问题\n- 避免从多个goroutine中访问变量，使用独立变量\n- 临界区控制\n\n- 总结\n    - 数据竞争: 程序在多个goroutine交叉执行操作时，导致数据不一致.  \n    - `包级别`的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。\n    (多看看本章代码)\n\n## 9.1 sync.Mutex与sync.RMutex互斥锁\n比如银行存款查询余额的场景，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款(这句话很关键要没有)操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁\n- 总结\n    - 避免临界区中的变量在中途被其他的goroutine修改\n    - 使用mutex包进行互斥goroutine\n    - 一个deferred Unlock即使在临界区发生`panic`时依然会执行\n    - golang不支持重入锁\n    - sync.RWMutex.RLock()持锁，sync.RWMutex.Lock()会阻塞，相同的RWMutex.Lock()持锁，sync.RWMutex.RLock()阻塞，但是sync.RWMutex.RLock()阻塞之间不阻塞\n\n## 9.2 sync.Once惰性初始化\n如果初始化的成本太高，需要延迟的初始化对象。可考虑使用`sync.Once`\n<detials>\n<summary>sync.One的demo</summary>\n<pre>\n\n</pre>\n</details>\n\n\n## 9.3 sync.Cond的使用\n\n\n1. 使用场景: `sync.Cond` 经常用在多个goroutine等待，一个goroutine通知,如果是一读一等待使用`sync.Mutx`和`chan`就可以\n2. `sync.Cond`的[方法](https://pkg.go.dev/sync@go1.19#Cond)\n    ```golang\n    // Each Cond has an associated Locker L (often a *Mutex or *RWMutex),\n    // which must be held when changing the condition and\n    // when calling the Wait method.\n    //\n    // A Cond must not be copied after first use.\n    type Cond struct {\n            noCopy noCopy\n            // L is held while observing or changing the condition\n            L Locker\n            notify  notifyList\n            checker copyChecker\n    }\n\n    ```\n\n    Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁\n\n    ```golang\n    // Signal wakes one goroutine waiting on c, if there is any.\n    //\n    // It is allowed but not required for the caller to hold c.L\n    // during the call.\n    //Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护\n    func (c *Cond) Signal()\n    // Broadcast wakes all goroutines waiting on c.\n    //\n    // It is allowed but not required for the caller to hold c.L\n    // during the call.\n    func (c *Cond) Broadcast()\n\n    // Wait atomically unlocks c.L and suspends execution\n    // of the calling goroutine. After later resuming execution,\n    // Wait locks c.L before returning. Unlike in other systems,\n    // Wait cannot return unless awoken by Broadcast or Signal.\n    //\n    // Because c.L is not locked when Wait first resumes, the caller\n    // typically cannot assume that the condition is true when\n    // Wait returns. Instead, the caller should Wait in a loop:\n    //\n    //    c.L.Lock()\n    //    for !condition() {\n    //        c.Wait()\n    //    }\n    //    ... make use of condition ...\n    //    c.L.Unlock()\n    //挂起调用者所在的 goroutine,等待Broadcast或者Signal方法\n    func (c *Cond) Wait()\n        //代码片段\n        c.L.Lock()\n        for !condition() {\n            c.Wait()\n        }\n        ... make use of condition ...\n        c.L.Unlock()\n    \n\n\n\n    ```\n\n3. Cond代码示例\n    ```golang\n    var done = false\n\n    func read(name string, c *sync.Cond) {\n        c.L.Lock()\n        for !done {\n            c.Wait()\n        }\n        log.Println(name, \"starts reading\")\n        c.L.Unlock()\n    }\n\n    func write(name string, c *sync.Cond) {\n        log.Println(name, \"starts writing\")\n        time.Sleep(time.Second)\n        c.L.Lock()\n        done = true\n        c.L.Unlock()\n        log.Println(name, \"wakes all\")\n        c.Broadcast()\n    }\n\n    func main() {\n        cond := sync.NewCond(&sync.Mutex{})\n\n        go read(\"reader1\", cond)\n        go read(\"reader2\", cond)\n        go read(\"reader3\", cond)\n        write(\"writer\", cond)\n\n        time.Sleep(time.Second * 3)\n    }\n\n    ```\n\n## 9.4. Goroutines和线程\n\n- 每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量\n- 一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩\n- Go的`运行时`有自己的调度器，这个调度器比如m:n调度，n个操作系统线程调度m个gotoutine，例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。\n\n- GOMAXPROCS : 变量来决定会有多少个操作系统的线程同时执行Go的代码,其默认的值是运行机器上的CPU的核心数,`GOMAXPROCS`是前面说的m:n调度中的n.下面代码就可以简单的看出os线程调度代码的情况\n\n  ```golang\n\n    for {\n        go fmt.Print(0)\n        fmt.Print(1)\n    }\n\n    $ GOMAXPROCS=1 go run hacker-cliché.go\n    111111111111111111110000000000000000000011111...\n\n    $ GOMAXPROCS=2 go run hacker-cliché.go\n    010101010101010101011001100101011010010100110...\n  ```\n\n\n\n- 总结\n    - 通过广播机制来取消goroutines\n    - 确保主函数退出，routines也随即退出\n\n\n\n\n# 10. 包和工具\n互联网上已经发布了非常多的Go语言开源包，它们可以通过 http://godoc.org 检索\n\n- 包的声明 ： 通过`package.struct`的形式访问我们的下载的`package`,但是也有同名的例如`math/rand`和`crypto/rand`，这种要重新指定包名，只影响当前文件，同时也解决了那些又臭又长的包名\n- 文件开头以`_`和`.`的会被忽略\n- 以`_test`结尾的通常是测试包\n- 一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in/yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml\n- `包的匿名导入`:\n  - 解决包的依赖顺序\n  - 初始化包级声明的变量\n  - 按顺序初始化包中每个文件里的 init 函数\n  - 每个文件中可以包含多个 init 函数，按顺序执行(所以你导和不导包差距很大，匿名导入只是表明你无法使用相应包内函数)\n  - 包名和成员名要尽量的短，并且能见名知意\n- go的工具\n  - 工作区结构 : 当需要切换工作区的时候，只需要更新下GOPATH环境变量即可`src`保存源代码,`pkg`子目录用于保存编译后的包的目标文件,`bin`子目录用于保存编译后的可执行程序\n  - 下载包 : `go get`命令，`go get -u`命令只是简单地保证每个下载最新版本，实际工作中要对包版本做精细的管理，需要vendor目录管理不同版本的包,`go help gopath`查看vendor帮助文档,而go get 相当于获取的是远程仓库源代码的整个库，还可以看到仓库的版本信息，go支持导入远程github仓库的代码，`go get`下载的包保存在哪里呢？一般他会保存在这个目录：`GOPATH/src`\n  [goget详细介绍](https://www.cnblogs.com/mrbug/p/11990418.html#:~:text=go%20get%20%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8C%85,%E7%9A%84go%20%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E3%80%82)，`go get`是对模块代码的更新\n  - 构建包 : 可以使用相对路径和绝对路径进行构建项目，`go run`其实也可以偷懒，直接`go run *.go`,`go build -i`命令将安装每个目标所依赖的包,`// +build linux darwin`,在包声明和包注释的前面，该构建注释参数告诉`go build`只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件,`// +build ignore`这个构建注释则表示不编译这个文件。`go doc go/build`\n  - 包文档 : 专门用于保存包文档的源文件通常叫`doc.go`,例如 `go doc time` 某个具体成员结构`go doc time.Since`,或者具体函数`go doc time.Duration.Second` , 更简单的是`godoc -http :8000`包含了所有go包的索引，`-analysis=type`和`-analysis=pointer`命令行标志参数用于打开文档和代码中关于静态分析的结果\n  - 内部包 : 一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包\n  - 搜索包 : `go list`列出工作区相关包,还可以查看完整包的原信息,例如`hash`包`go list -json hash`\n    - 命令行参数-f则允许用户使用text/template包（§4.6）的模板语言定义输出文本的格式\n      ```golang\n      //windows环境下注意\n      go list -f '{{.ImportPath}} -> {{join .Imports \" \"}}' compress/...\n        compress/bzip2 -> bufio io sort\n        compress/flate -> bufio fmt io math sort strconv\n        compress/gzip -> bufio compress/flate errors fmt hash hash/crc32 io time\n        compress/lzw -> bufio errors fmt io\n        compress/zlib -> bufio compress/flate errors fmt hash hash/adler32 io\n      ```\n\n# 11. 测试\n\ngo test选项含义\n```bash\n\n-args 传递参数到test binary(到时候补一个demo)\n-c 编译test binary,但是不执行\n-exec xprog  运行test binary ,原理如同 go run\n-i 安装test binary的相关依赖\n-json 将测试输出转化为json为了自动化处理\n-c file   定义编译后的binary的文件名\n\n```\n\n\n## 11.1 go test\n一个测试函数是以`Test`为函数名前缀的函数\n一个基准测试函数是以`Benchmark`为函数名前缀的函数\n一个示例函数是以`Example`为函数名前缀的函数，提供一个由编译器保证正确性的示例文档\n```golang\n- `go test -v `会打印每个函数的名字和运行时间\n- `go test -run= `会去匹配正则表达式，只有被匹配到的才会被执行\n- `go test -v ./...` 执行所有当前目录下测试cases\n- `go test -v foo/...` 执行foo目录下所有cases\n- `go test -v foo...` 执行指定前缀的测试cases\n- `go test ...` gopath下所有测试cases\n- `go test -v hello_test.go` 执行某一文件下的测试cases,但是该文件中如果调用了其它文件中的模块会报错\n- `go test -v hello_test.go -test.run TestHello` 测试单个函数\n```\n- 组织多个测试用例\n  \n  即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息,可以使用`t.Fatal`或`t.Fatalf`停止当前测试函数\n    <details>\n    <summary>组织多测试用例</summary>\n    <pre>\n    \n    ```golang\n    func TestIsPalindrome(t *testing.T) {\n    var tests = []struct {\n        input string\n        want  bool\n    }{\n            {\"\", true},\n            {\"a\", true},\n            {\"aa\", true},\n            {\"ab\", false},\n            {\"kayak\", true},\n            {\"detartrated\", true},\n            {\"A man, a plan, a canal: Panama\", true},\n            {\"Evil I did dwell; lewd did I live.\", true},\n            {\"Able was I ere I saw Elba\", true},\n            {\"été\", true},\n            {\"Et se resservir, ivresse reste.\", true},\n            {\"palindrome\", false}, // non-palindrome\n            {\"desserts\", false},   // semi-palindrome\n        }\n        for _, test := range tests {\n            if got := IsPalindrome(test.input); got != test.want {\n                t.Errorf(\"IsPalindrome(%q) = %v\", test.input, got)\n            }\n        }\n    }\n    ```\n\n    </pre>\n    </details>\n\n- 随机测试\n  1. 编写对照函数，效率低下\n  2. 生成的随机输入的数据遵循特定的模式，然后就知道期望的输出\n\n  ```golang\n\n  import \"math/rand\"\n\n    // randomPalindrome returns a palindrome whose length and contents\n    // are derived from the pseudo-random number generator rng.\n    func randomPalindrome(rng *rand.Rand) string {\n        n := rng.Intn(25) // random length up to 24\n        runes := make([]rune, n)\n        for i := 0; i < (n+1)/2; i++ {\n            r := rune(rng.Intn(0x1000)) // random rune up to '\\u0999'\n            runes[i] = r\n            runes[n-1-i] = r\n        }\n        return string(runes)\n    }\n\n    func TestRandomPalindromes(t *testing.T) {\n        // Initialize a pseudo-random number generator.\n        seed := time.Now().UTC().UnixNano()\n        t.Logf(\"Random seed: %d\", seed)\n        rng := rand.New(rand.NewSource(seed))\n\n        for i := 0; i < 1000; i++ {\n            p := randomPalindrome(rng)\n            if !IsPalindrome(p) {\n                t.Errorf(\"IsPalindrome(%q) = false\", p)\n            }\n        }\n    }\n    // IsPalindrome reports whether s reads the same forward and backward.\n    // Letter case is ignored, as are non-letters.\n    func IsPalindrome(s string) bool {\n        var letters []rune\n        for _, r := range s {\n            if unicode.IsLetter(r) {\n                letters = append(letters, unicode.ToLower(r))\n            }\n        }\n        for i := range letters {\n            if letters[i] != letters[len(letters)-1-i] {\n                return false\n            }\n        }\n        return true\n    }\n\n    ```\n\n- 测试一个命令(测试内部未导出函数)\n\n  要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。要注意的是在测试代码中并没有调用`log.Fatal`或`os.Exit`，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理,如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理.导出内部函数,\n\n  ```golang\n  // src/bytes/export_test.go\n    package bytes\n    // Export func for testing\n    var IndexBytePortable = indexBytePortable // 赋值给包级可导出变量\n  ```\n  \n  然后通过外部包进行测试\n\n  ```golang\n\n  // src/bytes/bytes_test.go\n    package bytes_test\n\n    func TestIndexByte(t *testing.T) {\n        for _, tt := range indexTests {\n            ... 代码片段\n            posp := IndexBytePortable(a, b) // 导出的内部方法在这里被使用\n            if posp != tt.i {\n                t.Errorf(`indexBytePortable(%q, '%c') = %v`, tt.a, b, posp)\n            }\n        }\n    }\n  \n  ```\n  还有种方式就是不导出，直接在包名下写测试函数，然后进行测试源代码\n\n- 白盒测试\n\n  TBC,代码的内部实现对于测试人员来说是可见的，言外之意就是能看到内部实现,测试内部实现，这个实现可能是未导出的\n- 外部测试包\n  ```golang\n  package pprint_test\n    //这时候就可以在\n    import (\n        \"gott/hi\"\n        // 导入 要进行测试的 pprint 包本身\n        \"gott/pprint\"\n        \"testing\"\n    )\n\n    func TestPPrint(t *testing.T) {\n        pprint.PPrint()\n        hi.Say()\n        t.Log(\"expect call PPrint\")\n    }\n    \n  ```\n  使用 Go 官方的代码风格：pprint_test.go 文件，因为pprint_test在 pprint 目录下，通过在 import 时，使用` . `选项，可以直接调用PPrint()方法\n- 编写有效的测试\n  1. 一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息\n  2. 一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律\n  3. 现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试\n- 避免脆弱的测试\n  TBC\n\n## 11.2 测试覆盖率\n\n对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化(应该是有)\n\n1. go test -run=Coverage -coverprofile=c.out gopl.io/ch7/eval\n2. go test -run=Coverage -covermode=count gopl.io/ch7/eval\n\n## 11.3 基准测试\n\n1. `-bench`也是正则匹配,BenchmarkIsPalindrome-8,8表示的是GOMAXPROCS的值,`-benchmem`命令行标志参数将在报告中包含内存的分配数据统计\n2. 比较型的基准测试就是普通程序代码,它们通常是单参数的函数，由几个不同数量级的基准测试函数调用,通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。所有的测试cases都要保留，随着项目的发展，都需要做回归测试\n\n\n## 11.4 刨析\nTBC\n\n## 11.5 示例函数\n示例函数有三个用处。\n1. 最主要的一个是作为文档，根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。\n2. 在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的// Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配\n3. 提供一个真实的演练场，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数\n\n\n# 12. appendIndex\n1. 线程内再重启一个线程，然后就可以通过加锁，进行隔离开，但此时任然是两个线程的间的交替","slug":"golang/go语言圣经/go语言圣经","published":1,"date":"2022-10-08T06:02:11.553Z","updated":"2022-10-08T06:05:25.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8ziiu6o005dl1dbf2di6rpv","content":"<ul>\n<li><a href=\"#1-%E5%85%A5%E9%97%A8\">1. 入门</a></li>\n<li><a href=\"#2-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84\">2. 程序结构</a><ul>\n<li><a href=\"#21-%E5%91%BD%E5%90%8D\">2.1 命名</a></li>\n<li><a href=\"#22-%E5%A3%B0%E6%98%8E\">2.2 声明</a></li>\n<li><a href=\"#23-%E5%8F%98%E9%87%8F\">2.3 变量</a><ul>\n<li><a href=\"#231-%E7%AE%80%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E\">2.3.1 简短变量声明</a></li>\n<li><a href=\"#232-%E6%8C%87%E9%92%88\">2.3.2 指针</a></li>\n<li><a href=\"#233-new%E5%87%BD%E6%95%B0\">2.3.3 new函数</a></li>\n<li><a href=\"#234-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">2.3.4. 变量的生命周期</a></li>\n</ul>\n</li>\n<li><a href=\"#24-%E8%B5%8B%E5%80%BC\">2.4 赋值</a><ul>\n<li><a href=\"#241-%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC\">2.4.1 元组赋值</a></li>\n</ul>\n</li>\n<li><a href=\"#25-%E7%B1%BB%E5%9E%8B\">2.5 类型</a></li>\n<li><a href=\"#26-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6\">2.6 包和文件</a></li>\n<li><a href=\"#27-%E4%BD%9C%E7%94%A8%E5%9F%9F\">2.7. 作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">3.基础数据类型</a><ul>\n<li><a href=\"#31-%E6%95%B4%E5%9E%8B\">3.1 整型</a></li>\n<li><a href=\"#32-%E6%B5%AE%E7%82%B9%E6%95%B0\">3.2 浮点数</a></li>\n<li><a href=\"#33-%E5%A4%8D%E6%95%B0\">3.3 复数</a></li>\n<li><a href=\"#34-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B\">3.4 布尔类型</a></li>\n<li><a href=\"#35-%E5%AD%97%E7%AC%A6%E4%B8%B2\">3.5 字符串</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">4. 复合数据类型</a><ul>\n<li><a href=\"#41-%E6%95%B0%E7%BB%84\">4.1 数组</a></li>\n<li><a href=\"#42-slice\">4.2 slice</a><ul>\n<li><a href=\"#421-append%E5%87%BD%E6%95%B0\">4.2.1 append函数</a></li>\n</ul>\n</li>\n<li><a href=\"#43-map\">4.3 Map</a></li>\n<li><a href=\"#44-%E7%BB%93%E6%9E%84%E4%BD%93\">4.4 结构体</a><ul>\n<li><a href=\"#441-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E5%80%BC\">4.4.1 结构体字面值</a></li>\n<li><a href=\"#442-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%AF%94%E8%BE%83\">4.4.2 结构体的比较</a></li>\n<li><a href=\"#443-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98\">4.4.3 结构体嵌入和匿名成员</a></li>\n</ul>\n</li>\n<li><a href=\"#45-json%E5%AD%97%E7%AC%A6%E4%B8%B2\">4.5 json字符串</a></li>\n<li><a href=\"#46-%E6%96%87%E6%9C%AC%E5%92%8Chtml%E6%A8%A1%E6%9D%BF\">4.6 文本和HTML模板</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E5%87%BD%E6%95%B0\">5. 函数</a><ul>\n<li><a href=\"#51-%E9%94%99%E8%AF%AF\">5.1 错误</a></li>\n<li><a href=\"#52-%E5%87%BD%E6%95%B0%E5%80%BC\">5.2 函数值</a></li>\n<li><a href=\"#53-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\">5.3 匿名函数</a></li>\n<li><a href=\"#54-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\">5.4 可变参数</a></li>\n<li><a href=\"#55-defer%E5%87%BD%E6%95%B0\">5.5 defer函数</a></li>\n<li><a href=\"#56-panic%E5%BC%82%E5%B8%B8\">5.6 panic异常</a></li>\n<li><a href=\"#57-recovery%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8\">5.7 Recovery捕获异常</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E6%96%B9%E6%B3%95\">6. 方法</a><ul>\n<li><a href=\"#61-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E\">6.1 方法声明</a></li>\n<li><a href=\"#62-%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95\">6.2 基于指针对象的方法</a></li>\n<li><a href=\"#63-%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B\">6.3. 通过嵌入结构体来扩展类型</a></li>\n<li><a href=\"#64-%E5%B0%81%E8%A3%85\">6.4 封装</a></li>\n</ul>\n</li>\n<li><a href=\"#7-%E6%8E%A5%E5%8F%A3\">7. 接口</a><ul>\n<li><a href=\"#71-%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A\">7.1. 接口约定</a></li>\n<li><a href=\"#72-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B\">7.2 接口类型</a></li>\n<li><a href=\"#73-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6\">7.3 实现接口的条件</a></li>\n<li><a href=\"#74-flagvalue%E6%8E%A5%E5%8F%A3\">7.4 flag.Value接口</a></li>\n<li><a href=\"#75-%E6%8E%A5%E5%8F%A3%E5%80%BC\">7.5 接口值</a></li>\n<li><a href=\"#76-sortinterface%E6%8E%A5%E5%8F%A3\">7.6. sort.Interface接口</a></li>\n<li><a href=\"#77-httphandler%E6%8E%A5%E5%8F%A3\">7.7. http.Handler接口</a></li>\n<li><a href=\"#78-error%E6%8E%A5%E5%8F%A3\">7.8. error接口</a></li>\n<li><a href=\"#79-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\">7.9. 类型断言</a></li>\n<li><a href=\"#710-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B\">7.10. 基于类型断言区别错误类型</a></li>\n<li><a href=\"#711-any%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%B3%9B%E5%9E%8B\">7.11. any关键字与泛型</a></li>\n</ul>\n</li>\n<li><a href=\"#8-goroutines%E5%92%8Cchannels\">8. Goroutines和Channels</a><ul>\n<li><a href=\"#81-goroutine\">8.1 goroutine</a></li>\n<li><a href=\"#82-channel\">8.2 channel</a></li>\n<li><a href=\"#83-%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\">8.3 基于select的多路复用</a></li>\n<li><a href=\"#84-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%80%E5%87%BA\">8.4. 并发的退出</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91\">9. 基于共享变量的并发</a><ul>\n<li><a href=\"#91-syncmutex%E4%B8%8Esyncrmutex%E4%BA%92%E6%96%A5%E9%94%81\">9.1 sync.Mutex与sync.RMutex互斥锁</a></li>\n<li><a href=\"#92-synconce%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96\">9.2 sync.Once惰性初始化</a></li>\n<li><a href=\"#93-synccond%E7%9A%84%E4%BD%BF%E7%94%A8\">9.3 sync.Cond的使用</a></li>\n<li><a href=\"#94-goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B\">9.4. Goroutines和线程</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7\">10. 包和工具</a></li>\n<li><a href=\"#11-%E6%B5%8B%E8%AF%95\">11. 测试</a><ul>\n<li><a href=\"#111-go-test\">11.1 go test</a></li>\n<li><a href=\"#112-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87\">11.2 测试覆盖率</a></li>\n<li><a href=\"#113-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\">11.3 基准测试</a></li>\n<li><a href=\"#114-%E5%88%A8%E6%9E%90\">11.4 刨析</a></li>\n<li><a href=\"#115-%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0\">11.5 示例函数</a></li>\n</ul>\n</li>\n<li><a href=\"#12-appendindex\">12. appendIndex</a></li>\n</ul>\n<h1 id=\"1-入门\"><a href=\"#1-入门\" class=\"headerlink\" title=\"1. 入门\"></a>1. 入门</h1><h1 id=\"2-程序结构\"><a href=\"#2-程序结构\" class=\"headerlink\" title=\"2. 程序结构\"></a>2. 程序结构</h1><h2 id=\"2-1-命名\"><a href=\"#2-1-命名\" class=\"headerlink\" title=\"2.1 命名\"></a>2.1 命名</h2><table>\n<thead>\n<tr>\n<th>功能性关键字</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break</td>\n<td></td>\n</tr>\n<tr>\n<td>case</td>\n<td></td>\n</tr>\n<tr>\n<td>chan</td>\n<td></td>\n</tr>\n<tr>\n<td>const</td>\n<td></td>\n</tr>\n<tr>\n<td>continue</td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n</tr>\n<tr>\n<td>defer</td>\n<td></td>\n</tr>\n<tr>\n<td>else</td>\n<td></td>\n</tr>\n<tr>\n<td>fallthrough</td>\n<td></td>\n</tr>\n<tr>\n<td>for</td>\n<td></td>\n</tr>\n<tr>\n<td>func</td>\n<td></td>\n</tr>\n<tr>\n<td>go</td>\n<td></td>\n</tr>\n<tr>\n<td>if</td>\n<td></td>\n</tr>\n<tr>\n<td>import</td>\n<td></td>\n</tr>\n<tr>\n<td>interface</td>\n<td></td>\n</tr>\n<tr>\n<td>map</td>\n<td></td>\n</tr>\n<tr>\n<td>package</td>\n<td></td>\n</tr>\n<tr>\n<td>range</td>\n<td></td>\n</tr>\n<tr>\n<td>return</td>\n<td></td>\n</tr>\n<tr>\n<td>select</td>\n<td></td>\n</tr>\n<tr>\n<td>struct</td>\n<td></td>\n</tr>\n<tr>\n<td>switch</td>\n<td></td>\n</tr>\n<tr>\n<td>type</td>\n<td></td>\n</tr>\n<tr>\n<td>var</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>内建常量</th>\n<th>关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>true</td>\n<td></td>\n</tr>\n<tr>\n<td>false</td>\n<td></td>\n</tr>\n<tr>\n<td>iota</td>\n<td></td>\n</tr>\n<tr>\n<td>nil</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>内建类型</th>\n<th>关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int</td>\n<td></td>\n</tr>\n<tr>\n<td>int8</td>\n<td></td>\n</tr>\n<tr>\n<td>int16</td>\n<td></td>\n</tr>\n<tr>\n<td>int32</td>\n<td></td>\n</tr>\n<tr>\n<td>int64</td>\n<td></td>\n</tr>\n<tr>\n<td>uint</td>\n<td></td>\n</tr>\n<tr>\n<td>uint8</td>\n<td></td>\n</tr>\n<tr>\n<td>uint16</td>\n<td></td>\n</tr>\n<tr>\n<td>uint32</td>\n<td></td>\n</tr>\n<tr>\n<td>uint64</td>\n<td></td>\n</tr>\n<tr>\n<td>uintptr</td>\n<td></td>\n</tr>\n<tr>\n<td>float32</td>\n<td></td>\n</tr>\n<tr>\n<td>float64</td>\n<td></td>\n</tr>\n<tr>\n<td>complex128</td>\n<td></td>\n</tr>\n<tr>\n<td>complex64</td>\n<td></td>\n</tr>\n<tr>\n<td>bool</td>\n<td></td>\n</tr>\n<tr>\n<td>byte</td>\n<td></td>\n</tr>\n<tr>\n<td>rune</td>\n<td></td>\n</tr>\n<tr>\n<td>string</td>\n<td></td>\n</tr>\n<tr>\n<td>error</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>内建函数</th>\n<th>关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>make</td>\n<td></td>\n</tr>\n<tr>\n<td>len</td>\n<td></td>\n</tr>\n<tr>\n<td>cap</td>\n<td></td>\n</tr>\n<tr>\n<td>new</td>\n<td></td>\n</tr>\n<tr>\n<td>append</td>\n<td></td>\n</tr>\n<tr>\n<td>copy</td>\n<td></td>\n</tr>\n<tr>\n<td>close</td>\n<td></td>\n</tr>\n<tr>\n<td>delete</td>\n<td></td>\n</tr>\n<tr>\n<td>complex</td>\n<td></td>\n</tr>\n<tr>\n<td>real</td>\n<td></td>\n</tr>\n<tr>\n<td>imag</td>\n<td></td>\n</tr>\n<tr>\n<td>panic</td>\n<td></td>\n</tr>\n<tr>\n<td>recover</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>Go推荐使用<code>驼峰式</code>命名:</p>\n<ul>\n<li>一个名字必须以一个字母（Unicode字母）或下划线开头,下划线开头可能表示<code>私有的</code></li>\n<li>后面可以跟任意数量的字母、数字或下划线。</li>\n<li>名字的开头字母的大小写决定了名字在包外的可见性.如果一个名字是大写字母开头的(译注必须是 在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将是导出的,也就是说可以被外部的包访问,例如<code>fmt.Printf</code>,就可以在包外访问</li>\n</ul>\n<h2 id=\"2-2-声明\"><a href=\"#2-2-声明\" class=\"headerlink\" title=\"2.2 声明\"></a>2.2 声明</h2><p>Go语言主要有四种类型的声明语句:</p>\n<ul>\n<li>var</li>\n<li>const</li>\n<li>type</li>\n<li>func</li>\n</ul>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;fmt&quot;\n\nconst boilingF &#x3D; 212.0\nconst var a &#x3D; 0\n\nfunc main() &#123;\n    var f &#x3D; boilingF\n    var c &#x3D; (f - 32) * 5 &#x2F; 9\n    fmt.Printf(&quot;boiling point &#x3D; %g°F or %g°C\\n&quot;, f, c)\n    &#x2F;&#x2F; Output:\n    &#x2F;&#x2F; boiling point &#x3D; 212°F or 100°C\n&#125;</code></pre>\n\n<p><code>boilingF</code>是包一级的变量在包内可以访问。如果函数没有返回值，那么返回值列表是省略的。函数顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者</p>\n<h2 id=\"2-3-变量\"><a href=\"#2-3-变量\" class=\"headerlink\" title=\"2.3 变量\"></a>2.3 变量</h2><p>常规声明变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var 变量名字 类型 &#x3D; 表达式</code></pre>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var i ,j , k int &#x2F;&#x2F; 都是int类型\nvar b,f,s &#x3D;true , 2.3 ,&quot;four&quot; &#x2F;&#x2F;bool , float 64,string\nvar f, err &#x3D; os.Open(name) &#x2F;&#x2F; os.Open returns a file and an error</code></pre>\n\n<ul>\n<li>在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。</li>\n<li><code>类型</code>和<code>表达式</code>都可以缺省,如果是<code>类型</code>缺省那么就可以通过<code>表达式</code>进行推断,如果是表达式缺省那么就会赋类型的<code>零</code>值,如果是自定义类型或者是引用类型就是内部各个字段都是<code>零</code>值.Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态</li>\n</ul>\n<h3 id=\"2-3-1-简短变量声明\"><a href=\"#2-3-1-简短变量声明\" class=\"headerlink\" title=\"2.3.1 简短变量声明\"></a>2.3.1 简短变量声明</h3>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">anim :&#x3D; gif.GIF&#123;LoopCount: nframes&#125; &#x2F;&#x2F;聚合类型,引用类型\nfreq :&#x3D; rand.Float64() * 3.0 &#x2F;&#x2F; float\nt :&#x3D; 0.0  &#x2F;&#x2F;float\nf, err :&#x3D; os.Open(name) &#x2F;&#x2F;通过函数进行声明，并初始化\nif err !&#x3D; nil &#123;\n    return err\n&#125;</code></pre>\n\n<ul>\n<li>例子1中声明的err是重复,第二个简短声明符的err就是赋值操作，注意该操作是在变量相同作用例子2中这种情况编译不通过,至少有一个是新声明的.[ 实际工程中尽量不要出现例子2 ]</li>\n</ul>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;例子1\nin, err :&#x3D; os.Open(infile)\n&#x2F;&#x2F; ...\nout, err :&#x3D; os.Create(outfile)\n&#x2F;&#x2F;例子2\nf, err :&#x3D; os.Open(infile)\n&#x2F;&#x2F; ...\nf, err :&#x3D; os.Create(outfile) &#x2F;&#x2F; compile error: no new variables</code></pre>\n\n\n<h3 id=\"2-3-2-指针\"><a href=\"#2-3-2-指针\" class=\"headerlink\" title=\"2.3.2 指针\"></a>2.3.2 指针</h3><ul>\n<li><p><code>任何类型</code>的指针的<code>零值</code>都是<code>nil</code>。如果p指向某个有效变量，那么<code>p != nil</code>测试为<code>真</code>。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>\n</li>\n<li><p>返回局部变量地址也是安全的。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func incr(p *int) int &#123;\n    *p++ &#x2F;&#x2F; 非常重要：只是增加p指向的变量的值，并不改变p指针！！！\n    return *p\n&#125;\nv :&#x3D; 1\nincr(&amp;v)              &#x2F;&#x2F; side effect: v is now 2\nfmt.Println(incr(&amp;v)) &#x2F;&#x2F; &quot;3&quot; (and v is 3)</code></pre>\n</li>\n<li><p>在flag包中,应用到了<code>指针</code>技术</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\nimport (\n    &quot;flag&quot;\n    &quot;fmt&quot;\n    &quot;strings&quot;\n)\nvar n &#x3D; flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)\nvar sep &#x3D; flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)\n\nfunc main() &#123;\n    flag.Parse() &#x2F;&#x2F;解析标志性参数位\n    fmt.Print(strings.Join(flag.Args(), *sep)) &#x2F;&#x2F;flag.Args() 解析非标志参数位\n    if !*n &#123;\n        fmt.Println()\n    &#125;\n&#125;</code></pre>\n<ul>\n<li>在此代码例子中使用<code>flag.Args()</code>解析非标志参数位,<code>flag.Parse()</code>解析标志性参数位,to be continue</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-3-new函数\"><a href=\"#2-3-3-new函数\" class=\"headerlink\" title=\"2.3.3 new函数\"></a>2.3.3 new函数</h3><p>  表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T(返回的是指针)</p>\n<ul>\n<li>每次new()返回新的变量地址,比如new(int)</li>\n</ul>\n<h3 id=\"2-3-4-变量的生命周期\"><a href=\"#2-3-4-变量的生命周期\" class=\"headerlink\" title=\"2.3.4. 变量的生命周期\"></a>2.3.4. 变量的生命周期</h3><ul>\n<li>包一级的声明会伴随程序整个声明周期,但是函数内部则是动态,会被GC回收</li>\n<li>函数的<code>参数变量</code>(参数列表)和<code>返回值变量</code>都是<code>局部变量</code>。它们在函数每次被调用的时候创建,下面循环的<code>变量t</code>就是动态创建,用完就扔  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;\n  x :&#x3D; math.Sin(t)\n  y :&#x3D; math.Sin(t*freq + phase)\n  img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),\n      blackIndex)\n&#125;</code></pre></li>\n</ul>\n<p>  下面也是合法的</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;\n  x :&#x3D; math.Sin(t)\n  y :&#x3D; math.Sin(t*freq + phase)\n  img.SetColorIndex(\n      size+int(x*size+0.5), size+int(y*size+0.5),\n      blackIndex, &#x2F;&#x2F; 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性\n  )               &#x2F;&#x2F; 小括弧另起一行缩进，和大括弧的风格保存一致\n&#125;</code></pre>\n\n<ul>\n<li><code>局部变量逃逸</code>.因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。<code>编译器</code>会自动选择在<code>栈</code>上还是在<code>堆</code>上分配局部变量的存储空间,代码如下,<code>f</code>函数里的<code>x变量</code>必须在<code>堆</code>上分配,因为它在函数退出后依然可以通过包一级的<code>global变量</code>找到,<code>g</code>函数在栈上分配<code>*y</code>内存空间  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var global *int\n\nfunc f() &#123;\n    var x int\n    x &#x3D; 1\n    global &#x3D; &amp;x\n&#125;\n\nfunc g() &#123;\n    y :&#x3D; new(int)\n    *y &#x3D; 1\n&#125;\n</code></pre></li>\n<li>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期,比如,如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。</li>\n</ul>\n<h2 id=\"2-4-赋值\"><a href=\"#2-4-赋值\" class=\"headerlink\" title=\"2.4 赋值\"></a>2.4 赋值</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">x &#x3D; 1                       &#x2F;&#x2F; 命名变量的赋值\n*p &#x3D; true                   &#x2F;&#x2F; 通过指针间接赋值\nperson.name &#x3D; &quot;bob&quot;         &#x2F;&#x2F; 结构体字段赋值\ncount[x] &#x3D; count[x] * scale &#x2F;&#x2F; 数组、slice或map的元素赋值\n</code></pre>\n\n<h3 id=\"2-4-1-元组赋值\"><a href=\"#2-4-1-元组赋值\" class=\"headerlink\" title=\"2.4.1 元组赋值\"></a>2.4.1 元组赋值</h3>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">x,y &#x3D; y,x; &#x2F;&#x2F;不限制数量\na[i], a[j] &#x3D; a[j], a[i];\n&#x2F;&#x2F;额外的布尔类型表达某种错误类型\nv, ok &#x3D; m[key]             &#x2F;&#x2F; map lookup\nv, ok &#x3D; x.(T)              &#x2F;&#x2F; type assertion\nv, ok &#x3D; &lt;-ch               &#x2F;&#x2F; channel receive\n&#x2F;&#x2F;只做检查\nv &#x3D; m[key]                &#x2F;&#x2F; map查找，失败时返回零值\nv &#x3D; x.(T)                 &#x2F;&#x2F; type断言，失败时panic异常\nv &#x3D; &lt;-ch                  &#x2F;&#x2F; 管道接收，失败时返回零值（阻塞不算是失败）\n\n_, ok &#x3D; m[key]            &#x2F;&#x2F; map返回2个值\n_, ok &#x3D; mm[&quot;&quot;], false     &#x2F;&#x2F; map返回1个值\n_ &#x3D; mm[&quot;&quot;]                &#x2F;&#x2F; map返回1个值\n&#x2F;&#x2F;复合类型隐式赋值\nmedals :&#x3D; []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125;\n&#x2F;&#x2F;等价写法\nmedals[0] &#x3D; &quot;gold&quot;\nmedals[1] &#x3D; &quot;silver&quot;\nmedals[2] &#x3D; &quot;bronze&quot;</code></pre>\n<ul>\n<li>对于两个值是否可以用&#x3D;&#x3D;或!&#x3D;进行相等比较的能力也和可赋值能力有关系</li>\n</ul>\n<h2 id=\"2-5-类型\"><a href=\"#2-5-类型\" class=\"headerlink\" title=\"2.5 类型\"></a>2.5 类型</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package tempconv\n\nimport &quot;fmt&quot;\n\ntype Celsius float64    &#x2F;&#x2F; 摄氏温度\ntype Fahrenheit float64 &#x2F;&#x2F; 华氏温度\n\nconst (\n    AbsoluteZeroC Celsius &#x3D; -273.15 &#x2F;&#x2F; 绝对零度\n    FreezingC     Celsius &#x3D; 0       &#x2F;&#x2F; 结冰点温度\n    BoilingC      Celsius &#x3D; 100     &#x2F;&#x2F; 沸水温度\n)\n\nfunc CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9&#x2F;5 + 32) &#125;\n\nfunc FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 &#x2F; 9) &#125;\n</code></pre>\n\n<ul>\n<li>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用</li>\n<li><code>Celsius</code>和<code>Fahrenheit</code>是两种不同类型,<code>Celsius(t)</code>或<code>Fahrenheit(t)</code>形式的显式转型,<code>整数</code>-&gt;<code>小数</code>回省略小数部分(CPP在这部分有很详细的讨论)</li>\n<li>如果两个值有着不同的类型，则不能直接进行比较</li>\n<li>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集后面详细讨论</li>\n</ul>\n<h2 id=\"2-6-包和文件\"><a href=\"#2-6-包和文件\" class=\"headerlink\" title=\"2.6 包和文件\"></a>2.6 包和文件</h2><ul>\n<li><p><code>名字空间</code>每个包都对应一个独立的名字空间,例如，在image包中的Decode函数和在unicode&#x2F;utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问</p>\n</li>\n<li><p><code>包的导入</code>Go语言的规范并没有定义这些源代码的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。</p>\n</li>\n<li><p><code>包的初始化</code>。包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的。例如<code>func init() &#123; /* ... */ &#125;</code>,<code>init</code>不能被调用，也不能被声明。包会按照声明的顺序初始化。</p>\n</li>\n<li><p><code>包的初始化顺序</code>。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了</p>\n<p>复杂初始化可以用以下方式</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;可以使用匿名函数处理\nvar pc [256]byte &#x3D; func() (pc [256]byte) &#123;\n  for i :&#x3D; range pc &#123;\n      pc[i] &#x3D; pc[i&#x2F;2] + byte(i&amp;1)\n  &#125;\n  return\n&#125;()\n</code></pre></li>\n</ul>\n<h2 id=\"2-7-作用域\"><a href=\"#2-7-作用域\" class=\"headerlink\" title=\"2.7. 作用域\"></a>2.7. 作用域</h2><ul>\n<li>不要将作用域和生命周期混为一谈，作用域是指文本域，而生命周期是指运行有效时段</li>\n<li>任何在<code>函数</code>外部（也就是包级语法域）声明的名字可以在同一个<code>包</code>的任何源文件中访问的</li>\n<li>对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包</li>\n<li>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是<br>函数级的作用域</li>\n</ul>\n<p>几种常见作用域例子</p>\n<ul>\n<li><p>正常情况下作用域例子</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func f() &#123;&#125;\n\nvar g &#x3D; &quot;g&quot;\n\nfunc main() &#123;\n    f :&#x3D; &quot;f&quot;\n    fmt.Println(f) &#x2F;&#x2F; &quot;f&quot;; local var f shadows package-level func f\n    fmt.Println(g) &#x2F;&#x2F; &quot;g&quot;; package-level var\n    fmt.Println(h) &#x2F;&#x2F; compile error: undefined: h\n&#125;</code></pre></li>\n<li><p>作用域嵌套,函数中可以进行词法域嵌套</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func main() &#123;\n  x :&#x3D; &quot;hello!&quot;\n  for i :&#x3D; 0; i &lt; len(x); i++ &#123;\n      x :&#x3D; x[i]\n      if x !&#x3D; &#39;!&#39; &#123;\n          x :&#x3D; x + &#39;A&#39; - &#39;a&#39;\n          fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;上述代码&#96;x[]&#96;和&#96;x + &#39;A&#39; - &#39;a&#39;&#96;都是引用了外部作用域声明的x变量。\n&#x2F;&#x2F;再比如下面的例子,有三个不同的x变量，</code></pre>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化\n&#x2F;&#x2F;词法域，一个在for循环体词法域；只有两个块是显式创建的：\nfunc main() &#123;\n  x :&#x3D; &quot;hello&quot;\n  for _, x :&#x3D; range x &#123;\n      x :&#x3D; x + &#39;A&#39; - &#39;a&#39;\n      fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)\n  &#125;\n&#125;</code></pre></li>\n<li><p>建隐式词法域,隐式作用域<br>  if和switch语句也会在条件部分创建隐式词法域，代码例子如下.第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if x :&#x3D; f(); x &#x3D;&#x3D; 0 &#123;\n  fmt.Println(x)\n&#125; else if y :&#x3D; g(x); x &#x3D;&#x3D; y &#123;\n    fmt.Println(x, y)\n&#125; else &#123;\n    fmt.Println(x, y)\n&#125;\nfmt.Println(x, y) &#x2F;&#x2F; compile error: x and y are not visible here</code></pre>\n<p>如果不想提前声明变量还可以选择如下方式，但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if f, err :&#x3D; os.Open(fname); err !&#x3D; nil &#123;\n  return err\n&#125; else &#123;\n    &#x2F;&#x2F; f and err are visible here too\n    f.ReadByte()\n    f.Close()\n&#125;</code></pre></li>\n<li><p>屏蔽其他作用域变暗亮<br>cwd在外部已经声明的包级变量，但是:&#x3D;语句还是将cwd和err重新声明为新的局部变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var cwd string\n\nfunc init() &#123;\n    cwd, err :&#x3D; os.Getwd() &#x2F;&#x2F; compile error: unused: cwd\n    if err !&#x3D; nil &#123;\n        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)\n    &#125;\n&#125;</code></pre>\n<p>可以用赋值运算符，就不会屏蔽<code>cwd</code>变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var cwd string\n\nfunc init() &#123;\n    var err error &#x2F;&#x2F;因为是赋值运算符所以需要定义error变量\n    cwd, err &#x3D; os.Getwd()\n    if err !&#x3D; nil &#123;\n        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)\n    &#125;\n&#125;</code></pre></li>\n</ul>\n<h1 id=\"3-基础数据类型\"><a href=\"#3-基础数据类型\" class=\"headerlink\" title=\"3.基础数据类型\"></a>3.基础数据类型</h1><ul>\n<li><p>整型格式控制符</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%b</td>\n<td>整型以二进制方式显示</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>整型以八进制方式显示</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>整型以十进制方式显示</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>整型以十六进制方式显示</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>整型以十六进制、字母大写方式显示</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>相应Unicode码点所表示的字符</td>\n</tr>\n<tr>\n<td>%U</td>\n<td>Unicode 字符, Unicode格式：123，等同于 “U+007B”</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>浮点数格式控制</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%e</td>\n<td>科学计数法,例如 -1234.456e+78</td>\n</tr>\n<tr>\n<td>%E</td>\n<td>科学计数法,例如 -1234.456E+78</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>有小数点而无指数,例如 123.456</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>\n</tr>\n<tr>\n<td>%G</td>\n<td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>字符串格式化</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%s</td>\n<td>字符串或切片的无解译字节</td>\n</tr>\n<tr>\n<td>%q</td>\n<td>双引号围绕的字符串，由Go语法安全地转义</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>十六进制，小写字母，每字节两个字符</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>十六进制，大写字母，每字节两个字符</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>指针格式化</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%p</td>\n<td>十六进制表示，前缀 0x</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>通用的占位符</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%v</td>\n<td>值的默认格式。</td>\n</tr>\n<tr>\n<td>%+v</td>\n<td>类似%v，但输出结构体时会添加字段名</td>\n</tr>\n<tr>\n<td>%#v</td>\n<td>相应值的Go语法表示</td>\n</tr>\n<tr>\n<td>%T</td>\n<td>相应值的类型的Go语法表示</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>百分号,字面上的%,非占位符含义</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>控制宽度<br>  宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐</p>\n<ul>\n<li><p>字符串控制</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">fmt.Printf(&quot;|%s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 不设置宽度\nfmt.Printf(&quot;|%5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度,  默认+， 右对齐\nfmt.Printf(&quot;|%-5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度, 左对齐\n\nfmt.Printf(&quot;|%05s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; |000aa|\n</code></pre>\n</li>\n<li><p>浮点控制</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">a :&#x3D; 54.123456\nfmt.Printf(&quot;|%f|&quot;, a)  &#x2F;&#x2F; |54.123456|\nfmt.Printf(&quot;|%5.1f|&quot;, a)  &#x2F;&#x2F; | 54.1|\nfmt.Printf(&quot;|%-5.1f|&quot;, a) &#x2F;&#x2F; |54.1 |\nfmt.Printf(&quot;|%05.1f|&quot;, a) &#x2F;&#x2F; |054.1|</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-1-整型\"><a href=\"#3-1-整型\" class=\"headerlink\" title=\"3.1 整型\"></a>3.1 整型</h2><ol>\n<li>因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节</li>\n<li>Unicode和rune类型是个<code>int32</code>等价的类型,通常用于表示一个Unicode码点</li>\n<li>同样byte也是<code>uint8</code>类型的等价类型</li>\n<li>还有一种无符号的整数类型<code>uintptr</code>，没有指定具体的bit大小但是足以容纳指针。<code>uintptr</code>类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方</li>\n<li><code>int</code>、<code>uint</code>和<code>uintptr</code>是不同类型的兄弟类型。其中<code>int</code>和<code>int32</code>也是不同的类型，即使<code>int</code>的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然</li>\n<li>位元素符号</li>\n<li><code>int32</code>和<code>int64</code>无法直接四则运算</li>\n<li><code>fmt.Printf(&quot;%d %[1]o %#[1]o\\n&quot;, o) // &quot;438 666 0666&quot;</code>中的<code>fmt</code>两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀</li>\n</ol>\n<h2 id=\"3-2-浮点数\"><a href=\"#3-2-浮点数\" class=\"headerlink\" title=\"3.2 浮点数\"></a>3.2 浮点数</h2><ol>\n<li>一个<code>float32</code>类型的浮点数可以提供大约<code>6</code>个十进制数的精度，而<code>float64</code>则可以提供约<code>15</code>个十进制数的精度；通常应该优先使用<code>float64</code>类型，因为<code>float32</code>类型的累计计算误差很容易扩散，并且<code>float32</code>能精确表示的正整数并不是很大</li>\n<li>浮点数字面量可以直接书写</li>\n<li>很大或者很小的数都可以用科学计数法来书写</li>\n<li><code>fmt.Printf(&quot;x = %d e^x = %8.3f\\n&quot;, x, math.Exp(float64(x)))</code>8.3是指三个小数精度，8个字符宽度,<code>%g %e %f</code>.</li>\n</ol>\n<h2 id=\"3-3-复数\"><a href=\"#3-3-复数\" class=\"headerlink\" title=\"3.3 复数\"></a>3.3 复数</h2><p>复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var x complex128 &#x3D; complex(1, 2) &#x2F;&#x2F; 1+2i\nvar y complex128 &#x3D; complex(3, 4) &#x2F;&#x2F; 3+4i\nfmt.Println(x*y)                 &#x2F;&#x2F; &quot;(-5+10i)&quot;\nfmt.Println(real(x*y))           &#x2F;&#x2F; &quot;-5&quot;\nfmt.Println(imag(x*y))           &#x2F;&#x2F; &quot;10&quot;\n</code></pre>\n\n<h2 id=\"3-4-布尔类型\"><a href=\"#3-4-布尔类型\" class=\"headerlink\" title=\"3.4 布尔类型\"></a>3.4 布尔类型</h2><p>布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">i :&#x3D; 0\nif b &#123;\n    i &#x3D; 1\n&#125;</code></pre>\n\n<h2 id=\"3-5-字符串\"><a href=\"#3-5-字符串\" class=\"headerlink\" title=\"3.5 字符串\"></a>3.5 字符串</h2><ul>\n<li><p>字符串可以用&#x3D;&#x3D;和&lt;进行比较；比较通过逐个字节比较完成的</p>\n</li>\n<li><p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故<code>s[0] = &#39;L&#39; // compile error: cannot assign to s[0]</code></p>\n<ul>\n<li>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中</li>\n<li>可在字符串面值中写<code>十六进制</code>和<code>八进制</code>数字进行码点转义</li>\n<li>原生字面值用反引号(&#96;)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.</li>\n<li>通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思</li>\n<li>UTF-8 [to be continue]</li>\n<li><code>bytes</code>、<code>strings</code>、<code>strconv</code>和<code>unicode</code>包,四个包对字符串处理尤为重要,<code>strings</code>包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能</li>\n<li>字符串和数字的转换,<code>strconv</code>包提供这类转换功能</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"4-复合数据类型\"><a href=\"#4-复合数据类型\" class=\"headerlink\" title=\"4. 复合数据类型\"></a>4. 复合数据类型</h1><h2 id=\"4-1-数组\"><a href=\"#4-1-数组\" class=\"headerlink\" title=\"4.1 数组\"></a>4.1 数组</h2><p>数组代码示例</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var a [3]int             &#x2F;&#x2F; array of 3 integers\nfmt.Println(a[0])        &#x2F;&#x2F; print the first element\nfmt.Println(a[len(a)-1]) &#x2F;&#x2F; print the last element, a[2]\n\n&#x2F;&#x2F; Print the indices and elements.\nfor i, v :&#x3D; range a &#123;\n    fmt.Printf(&quot;%d %d\\n&quot;, i, v)\n&#125;\n\n&#x2F;&#x2F; Print the elements only.\nfor _, v :&#x3D; range a &#123;\n    fmt.Printf(&quot;%d\\n&quot;, v)\n&#125;</code></pre>\n\n<p>如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">q :&#x3D; [...]int&#123;1, 2, 3&#125;\nfmt.Printf(&quot;%T\\n&quot;, q) &#x2F;&#x2F; &quot;[3]int&quot;</code></pre>\n<p>上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Currency int\n\nconst (\n    USD Currency &#x3D; iota &#x2F;&#x2F; 美元\n    EUR                 &#x2F;&#x2F; 欧元\n    GBP                 &#x2F;&#x2F; 英镑\n    RMB                 &#x2F;&#x2F; 人民币\n)\n\nsymbol :&#x3D; [...]string&#123;USD: &quot;$&quot;, EUR: &quot;€&quot;, GBP: &quot;￡&quot;, RMB: &quot;￥&quot;&#125;\n\nfmt.Println(RMB, symbol[RMB]) &#x2F;&#x2F; &quot;3 ￥&quot;</code></pre>\n<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">r :&#x3D; [...]int&#123;99: -1&#125;</code></pre>\n<p>数组进行比较是比较所有元素是否相等</p>\n<h2 id=\"4-2-slice\"><a href=\"#4-2-slice\" class=\"headerlink\" title=\"4.2 slice\"></a>4.2 slice</h2><p>创建slice变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">v_len :&#x3D; make([]T, len)\nv_len_cap :&#x3D; make([]T, len, cap) &#x2F;&#x2F; same as make([]T, cap)[:len]\ns :&#x3D; []int&#123;0, 1, 2, 3, 4, 5&#125;</code></pre>\n<p><code>slice</code>和<code>数组</code>典型的不同就是<code>slice</code>不指定长度<br><code>bytes.Equal</code>函数来判断两个字节型slice是否相等（[]byte)</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func equal(x, y []string) bool &#123;\n    if len(x) !&#x3D; len(y) &#123;\n        return false\n    &#125;\n    for i :&#x3D; range x &#123;\n        if x[i] !&#x3D; y[i] &#123;\n            return false\n        &#125;\n    &#125;\n    return true\n&#125;</code></pre>\n\n<p>slice的nil值</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var s []int    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; nil        &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; []int(nil) &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; []int&#123;&#125;    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s !&#x3D; nil</code></pre>\n\n<h3 id=\"4-2-1-append函数\"><a href=\"#4-2-1-append函数\" class=\"headerlink\" title=\"4.2.1 append函数\"></a>4.2.1 append函数</h3><p>(留着放些API东西)</p>\n<h2 id=\"4-3-Map\"><a href=\"#4-3-Map\" class=\"headerlink\" title=\"4.3 Map\"></a>4.3 Map</h2><p>其中K对应的key必须是支持&#x3D;&#x3D;比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在<br>创建map</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">ages :&#x3D; make(map[string]int) &#x2F;&#x2F; mapping from strings to ints\nages :&#x3D; map[string]int&#123;\n    &quot;alice&quot;:   31,\n    &quot;charlie&quot;: 34,\n&#125;\n&#x2F;&#x2F;访问map数据，也是put操作\nages[&quot;alice&quot;] &#x3D; 32\n&#x2F;&#x2F;删除元素\ndelete(ages, &quot;alice&quot;) &#x2F;&#x2F; remove element ages[&quot;alice&quot;]\n&#x2F;&#x2F;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：\n_ &#x3D; &amp;ages[&quot;bob&quot;] &#x2F;&#x2F; compile error: cannot take address of map element\n</code></pre>\n<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">import &quot;sort&quot;\n\nvar names []string\nfor name :&#x3D; range ages &#123;\n    names &#x3D; append(names, name)\n&#125;\nsort.Strings(names)\nfor _, name :&#x3D; range names &#123;\n    fmt.Printf(&quot;%s\\t%d\\n&quot;, name, ages[name])\n&#125;</code></pre>\n\n<p>map返回两个值，第一个值是bool类型,false则说明不存在这个key。<br>map的key要求必须是可比较类型，那么如果想用slice作为key就需要写小改动</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var m &#x3D; make(map[string]int)\n\nfunc k(list []string) string &#123; return fmt.Sprintf(&quot;%q&quot;, list) &#125;\n\nfunc Add(list []string)       &#123; m[k(list)]++ &#125;\nfunc Count(list []string) int &#123; return m[k(list)] &#125;</code></pre>\n\n<h2 id=\"4-4-结构体\"><a href=\"#4-4-结构体\" class=\"headerlink\" title=\"4.4 结构体\"></a>4.4 结构体</h2><pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">seen :&#x3D; make(map[string]struct&#123;&#125;) &#x2F;&#x2F; set of strings\n&#x2F;&#x2F; ...\nif _, ok :&#x3D; seen[s]; !ok &#123;\n    seen[s] &#x3D; struct&#123;&#125;&#123;&#125;\n    &#x2F;&#x2F; ...first time seeing s...\n&#125;</code></pre>\n\n<h3 id=\"4-4-1-结构体字面值\"><a href=\"#4-4-1-结构体字面值\" class=\"headerlink\" title=\"4.4.1 结构体字面值\"></a>4.4.1 结构体字面值</h3><pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Point struct&#123; X, Y int &#125;\n&#x2F;&#x2F;第一种类型初始化方式\np :&#x3D; Point&#123;1, 2&#125;\n&#x2F;&#x2F;第二种初始化方式,如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要\np :&#x3D;Point&#123;x:1,y:2&#125;</code></pre>\n\n<p>非导出结构体或者字段，不能在其他包中进行赋值</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package p\ntype T struct&#123; a, b int &#125; &#x2F;&#x2F; a and b are not exported\n\npackage q\nimport &quot;p&quot;\nvar _ &#x3D; p.T&#123;a: 1, b: 2&#125; &#x2F;&#x2F; compile error: can&#39;t reference a, b\nvar _ &#x3D; p.T&#123;1, 2&#125;       &#x2F;&#x2F; compile error: can&#39;t reference a, b</code></pre>\n\n<p>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nfunc Bonus(e *Employee, percent int) int &#123;\n    return e.Salary * percent &#x2F; 100\n&#125;</code></pre>\n\n<p>可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">pp :&#x3D; &amp;Point&#123;1, 2&#125;</code></pre>\n\n<p>它和下面的语句是等价的</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">pp :&#x3D; new(Point)\n*pp &#x3D; Point&#123;1, 2&#125;</code></pre>\n\n<h3 id=\"4-4-2-结构体的比较\"><a href=\"#4-4-2-结构体的比较\" class=\"headerlink\" title=\"4.4.2 结构体的比较\"></a>4.4.2 结构体的比较</h3><p>首先结构体是可比较类型</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\ntype Point struct&#123; X, Y int &#125;\n\np :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;2, 1&#125;\nfmt.Println(p.X &#x3D;&#x3D; q.X &amp;&amp; p.Y &#x3D;&#x3D; q.Y) &#x2F;&#x2F; &quot;false&quot;\nfmt.Println(p &#x3D;&#x3D; q)                   &#x2F;&#x2F; &quot;false&quot;\n</code></pre>\n\n<h3 id=\"4-4-3-结构体嵌入和匿名成员\"><a href=\"#4-4-3-结构体嵌入和匿名成员\" class=\"headerlink\" title=\"4.4.3 结构体嵌入和匿名成员\"></a>4.4.3 结构体嵌入和匿名成员</h3><pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\ntype Point struct &#123;\n    X, Y int\n&#125;\n\ntype Circle struct &#123;\n    Center Point\n    Radius int\n&#125;\n\ntype Wheel struct &#123;\n    Circle Circle\n    Spokes int\n&#125;\n\nvar w Wheel\nw.Circle.Center.X &#x3D; 8\nw.Circle.Center.Y &#x3D; 8\nw.Circle.Radius &#x3D; 5\nw.Spokes &#x3D; 20</code></pre>\n\n<p>匿名成员，说白了就是只写类型不写名字.</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Circle struct &#123;\n    Point\n    Radius int\n&#125;\n\ntype Wheel struct &#123;\n    Circle\n    Spokes int\n&#125;\n\nvar w Wheel\nw.X &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.X &#x3D; 8\nw.Y &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.Y &#x3D; 8\nw.Radius &#x3D; 5       &#x2F;&#x2F; equivalent to w.Circle.Radius &#x3D; 5\nw.Spokes &#x3D; 20\n&#x2F;&#x2F;以下初始化是错误的\nw &#x3D; Wheel&#123;8, 8, 5, 20&#125;                       &#x2F;&#x2F; compile error: unknown fields\nw &#x3D; Wheel&#123;X: 8, Y: 8, Radius: 5, Spokes: 20&#125; &#x2F;&#x2F; compile error: unknown fields</code></pre>\n\n<p>所以我们只能用下面两种方式进行初始化</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nw &#x3D; Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;\n\nw &#x3D; Wheel&#123;\n    Circle: Circle&#123;\n        Point:  Point&#123;X: 8, Y: 8&#125;,\n        Radius: 5,\n    &#125;,\n    Spokes: 20, &#x2F;&#x2F; NOTE: trailing comma necessary here (and at Radius)\n&#125;\n\nfmt.Printf(&quot;%#v\\n&quot;, w)\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;\n\nw.X &#x3D; 42\n\nfmt.Printf(&quot;%#v\\n&quot;, w)\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;\n</code></pre>\n<p>需要注意，但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</p>\n<h2 id=\"4-5-json字符串\"><a href=\"#4-5-json字符串\" class=\"headerlink\" title=\"4.5 json字符串\"></a>4.5 json字符串</h2><p><code>json.Marshal</code>包<br>代码例子</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Movie struct &#123;\n    Title  string\n    Year   int  &#96;json:&quot;released&quot;&#96; &#x2F;&#x2F; 这个tag指定生成json名字\n    Color  bool &#96;json:&quot;color,omitempty&quot;&#96;\n    Actors []string\n&#125;\n\nvar movies &#x3D; []Movie&#123;\n    &#123;Title: &quot;Casablanca&quot;, Year: 1942, Color: false,\n        Actors: []string&#123;&quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot;&#125;&#125;,\n    &#123;Title: &quot;Cool Hand Luke&quot;, Year: 1967, Color: true,\n        Actors: []string&#123;&quot;Paul Newman&quot;&#125;&#125;,\n    &#123;Title: &quot;Bullitt&quot;, Year: 1968, Color: true,\n        Actors: []string&#123;&quot;Steve McQueen&quot;, &quot;Jacqueline Bisset&quot;&#125;&#125;,\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<h2 id=\"4-6-文本和HTML模板\"><a href=\"#4-6-文本和HTML模板\" class=\"headerlink\" title=\"4.6 文本和HTML模板\"></a>4.6 文本和HTML模板</h2><p>(后面需要时候着重的看)<br><code>text/template和html/template</code>,们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。模板语言支持流程控制语句<br>模板语言demo</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">const templ &#x3D; &#96;&#123;&#123;.TotalCount&#125;&#125; issues:\n&#123;&#123;range .Items&#125;&#125;----------------------------------------\nNumber: &#123;&#123;.Number&#125;&#125;\nUser:   &#123;&#123;.User.Login&#125;&#125;\nTitle:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;\nAge:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days\n&#123;&#123;end&#125;&#125;&#96;</code></pre>\n\n<p><code>|</code> 操作符表示将前一个表达式的结果作为后一个函数的输入.<br>生成模板的输出需要两个处理步骤</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var report &#x3D; template.Must(template.New(&quot;issuelist&quot;).\n    Funcs(template.FuncMap&#123;&quot;daysAgo&quot;: daysAgo&#125;).\n    Parse(templ))\n\nfunc main() &#123;\n    result, err :&#x3D; github.SearchIssues(os.Args[1:])\n    if err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n    if err :&#x3D; report.Execute(os.Stdout, result); err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n&#125;</code></pre>\n<p>如果想转化为html则需要编写如下代码</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nimport &quot;html&#x2F;template&quot;\n\nvar issueList &#x3D; template.Must(template.New(&quot;issuelist&quot;).Parse(&#96;\n&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;&#x2F;h1&gt;\n&lt;table&gt;\n&lt;tr style&#x3D;&#39;text-align: left&#39;&gt;\n  &lt;th&gt;#&lt;&#x2F;th&gt;\n  &lt;th&gt;State&lt;&#x2F;th&gt;\n  &lt;th&gt;User&lt;&#x2F;th&gt;\n  &lt;th&gt;Title&lt;&#x2F;th&gt;\n&lt;&#x2F;tr&gt;\n&#123;&#123;range .Items&#125;&#125;\n&lt;tr&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Number&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;&#x2F;td&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.User.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Title&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n&#123;&#123;end&#125;&#125;\n&lt;&#x2F;table&gt;\n&#96;))</code></pre>\n<p>注意，html&#x2F;template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text&#x2F;template包的话，这2个issue将会产生错误，其中“&lt;”四个字符将会被当作小于字符“&lt;”处理，同时“<link>”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。</p>\n<h1 id=\"5-函数\"><a href=\"#5-函数\" class=\"headerlink\" title=\"5. 函数\"></a>5. 函数</h1><p>声明和定义</p>\n<ul>\n<li><p>switch 控制语句</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">switch cond&#123;\n  case a :\n      fmt.Printf()\n  case b :\n      fmt.Printf()\n  case c :\n      fmt.Printf()\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"5-1-错误\"><a href=\"#5-1-错误\" class=\"headerlink\" title=\"5.1 错误\"></a>5.1 错误</h2><p>通常，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</p>\n<p>我们有几种处理错误的策略</p>\n<ol>\n<li>发生错误时的解析器</li>\n</ol>\n<p>  发生解析错误后,findLinks 函数构造了一个新的异常信息,既包含了自定义的，也包含了底层解析出错的信息</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">doc, err :&#x3D; html.Parse(resp.Body)\nresp.Body.Close()\nif err !&#x3D; nil &#123;\n    return nil, fmt.Errorf(&quot;parsing %s as HTML: %v&quot;, url,err)\n&#125;</code></pre>\n\n<p>  参考宇航局事故调查<br>2. 重试<br>  我们需要限制重试的时间间隔或重试的次数，防止无限制的重试.<br>3. 输出错误信息并结束程序<br>  输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行,对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序<br>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;\n  log.Fatalf(&quot;Site is down: %v\\n&quot;, err)\n&#125;</code></pre><br>  <code>log.Fatalf</code>代码更简洁，并输出自定义格式信息</p>\n<ol start=\"4\">\n<li>只是输出错误信息就可以</li>\n</ol>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if err :&#x3D; Ping(); err !&#x3D; nil &#123;\n  log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)\n&#125;\n&#x2F;&#x2F;或者标准错误流输出错误信息。\n\nif err :&#x3D; Ping(); err !&#x3D; nil &#123;\n    fmt.Fprintf(os.Stderr, &quot;ping failed: %v; networking disabled\\n&quot;, err)\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li>直接忽略掉错误</li>\n</ol>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">dir, err :&#x3D; ioutil.TempDir(&quot;&quot;, &quot;scratch&quot;)\nif err !&#x3D; nil &#123;\n    return fmt.Errorf(&quot;failed to create temp dir: %v&quot;,err)\n&#125;\n&#x2F;&#x2F; ...use temp dir…\nos.RemoveAll(dir) &#x2F;&#x2F; ignore errors; $TMPDIR is cleaned periodically</code></pre>\n<p>  尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响</p>\n<ol start=\"6\">\n<li>文件结尾错误</li>\n</ol>\n<p>io包保证任何由文件结束引起的读取失败都返</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package io\n\nimport &quot;errors&quot;\n\n&#x2F;&#x2F; EOF is the error returned by Read when no more input is available.\nvar EOF &#x3D; errors.New(&quot;EOF&quot;)\n\nin :&#x3D; bufio.NewReader(os.Stdin)\nfor &#123;\n    r, _, err :&#x3D; in.ReadRune()\n    if err &#x3D;&#x3D; io.EOF &#123;\n        break &#x2F;&#x2F; finished reading\n    &#125;\n    if err !&#x3D; nil &#123;\n        return fmt.Errorf(&quot;read failed:%v&quot;, err)\n    &#125;\n    &#x2F;&#x2F; ...use r…\n&#125;</code></pre>\n\n<h2 id=\"5-2-函数值\"><a href=\"#5-2-函数值\" class=\"headerlink\" title=\"5.2 函数值\"></a>5.2 函数值</h2><ul>\n<li><p>函数在golang中也是一种类型，可以被复制给其他变量。  </p>\n</li>\n<li><p>很熟类型的<code>零</code>值是<code>nil</code>,调用值为nil会引起<code>panic</code>错误  </p>\n</li>\n<li><p>函数值之间是不可以比较的,也不能用函数值作为map的key</p>\n</li>\n<li><p>strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func add1(r rune) rune &#123; return r + 1 &#125;\n\nfmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) &#x2F;&#x2F; &quot;IBM.:111&quot;\nfmt.Println(strings.Map(add1, &quot;VMS&quot;))      &#x2F;&#x2F; &quot;WNT&quot;\nfmt.Println(strings.Map(add1, &quot;Admix&quot;))    &#x2F;&#x2F; &quot;Benjy&quot;</code></pre></li>\n</ul>\n<p>demo示例</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;值得学习\n&#x2F;&#x2F; forEachNode针对每个结点x，都会调用pre(x)和post(x)。\n&#x2F;&#x2F; pre和post都是可选的。\n&#x2F;&#x2F; 遍历孩子结点之前，pre被调用\n&#x2F;&#x2F; 遍历孩子结点之后，post被调用\nfunc forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123;\n    if pre !&#x3D; nil &#123;\n        pre(n)\n    &#125;\n    for c :&#x3D; n.FirstChild; c !&#x3D; nil; c &#x3D; c.NextSibling &#123;\n        forEachNode(c, pre, post)\n    &#125;\n    if post !&#x3D; nil &#123;\n        post(n)\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"5-3-匿名函数\"><a href=\"#5-3-匿名函数\" class=\"headerlink\" title=\"5.3 匿名函数\"></a>5.3 匿名函数</h2><p>函数内部定义的函数可以访问整个词法环境，言外之意就是嵌套的函数可以访问外层函数的变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; squares返回一个匿名函数。\n&#x2F;&#x2F; 该匿名函数每次被调用时都会返回下一个数的平方。\n&#x2F;&#x2F;squares 函数每次都返回一个函数类型-func()int&#123;&#125;\nfunc squares() func() int &#123;\n    var x int\n    return func() int &#123; &#x2F;&#x2F; 匿名函数\n        x++\n        return x * x\n    &#125;\n&#125;\nfunc main() &#123;\n    f :&#x3D; squares()\n    fmt.Println(f()) &#x2F;&#x2F; &quot;1&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;4&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;9&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;16&quot;\n&#125;\n&#x2F;&#x2F;通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</code></pre>\n\n<blockquote>\n<p>网页抓取的核心问题就是如何遍历图</p>\n</blockquote>\n<p>警告:捕获迭代变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var rmdirs []func()\nfor _, d :&#x3D; range tempDirs() &#123;\n    dir :&#x3D; d &#x2F;&#x2F; NOTE: necessary!\n    os.MkdirAll(dir, 0755) &#x2F;&#x2F; creates parent directories too\n    rmdirs &#x3D; append(rmdirs, func() &#123;\n        os.RemoveAll(dir)\n    &#125;)\n&#125;\n&#x2F;&#x2F; ...do some work…\nfor _, rmdir :&#x3D; range rmdirs &#123;\n    rmdir() &#x2F;&#x2F; clean up\n&#125;\n&#x2F;&#x2F; \nvar rmdirs []func()\nfor _, dir :&#x3D; range tempDirs() &#123;\n    os.MkdirAll(dir, 0755)\n    rmdirs &#x3D; append(rmdirs, func() &#123;\n        os.RemoveAll(dir) &#x2F;&#x2F; NOTE: incorrect!\n    &#125;)\n&#125;\n</code></pre>\n<p>问题出在了循环变量的作用域,循环变量dir在这个词法块中被声明，每一次迭代都是会不断地更新这个值，被<code>range</code>语句，解决这个问题的办法就是引入同名变量来覆盖其作用域。</p>\n<h2 id=\"5-4-可变参数\"><a href=\"#5-4-可变参数\" class=\"headerlink\" title=\"5.4 可变参数\"></a>5.4 可变参数</h2><p>简单的可变参数例子,其实<code>可变参数</code>就是个切片的值传递,<code>interface&#123;&#125;</code>表示函数的最后一个参数可以接收任意类型</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func sum(vals ...int) int &#123;\n    total :&#x3D; 0\n    for _, val :&#x3D; range vals &#123;\n        total +&#x3D; val\n    &#125;\n    return total\n&#125;</code></pre>\n<p>如果原参数就是切片该怎么传递？可以直接在<code>实参</code>后面加省略号</p>\n<h2 id=\"5-5-defer函数\"><a href=\"#5-5-defer函数\" class=\"headerlink\" title=\"5.5 defer函数\"></a>5.5 defer函数</h2><p>在函数执行完成之后，不管是正常退出还是异常退出函数，最后都会被执行</p>\n<h2 id=\"5-6-panic异常\"><a href=\"#5-6-panic异常\" class=\"headerlink\" title=\"5.6 panic异常\"></a>5.6 panic异常</h2><p>当panic发生时会在该goroutine上执行defer函数，打印对应的栈信息<br><code>regexp</code>包的使用<br>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func main() &#123;\n    defer printStack()\n    f(3)\n&#125;\nfunc printStack() &#123;\n    var buf [4096]byte\n    n :&#x3D; runtime.Stack(buf[:], false)\n    os.Stdout.Write(buf[:n])\n&#125;\n</code></pre>\n<p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p>\n<h2 id=\"5-7-Recovery捕获异常\"><a href=\"#5-7-Recovery捕获异常\" class=\"headerlink\" title=\"5.7 Recovery捕获异常\"></a>5.7 Recovery捕获异常</h2><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所</p>\n<ul>\n<li>语言解析器为例<br>说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误</li>\n</ul>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func Parse(input string) (s *Syntax, err error) &#123;\n    defer func() &#123;\n        if p :&#x3D; recover(); p !&#x3D; nil &#123;\n            err &#x3D; fmt.Errorf(&quot;internal error: %v&quot;, p)\n        &#125;\n    &#125;()\n    &#x2F;&#x2F; ...parser...\n&#125;</code></pre>\n\n\n<ul>\n<li>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。  </li>\n<li>有时我们很难完全遵循规范，举个例子，net&#x2F;http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</li>\n</ul>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; soleTitle returns the text of the first non-empty title element\n&#x2F;&#x2F; in doc, and an error if there was not exactly one.\n&#x2F;&#x2F;防御性panic代码\nfunc soleTitle(doc *html.Node) (title string, err error) &#123;\n    type bailout struct&#123;&#125;\n    defer func() &#123;\n        switch p :&#x3D; recover(); p &#123;\n        case nil:       &#x2F;&#x2F; no panic\n        case bailout&#123;&#125;: &#x2F;&#x2F; &quot;expected&quot; panic\n            err &#x3D; fmt.Errorf(&quot;multiple title elements&quot;)\n        default:\n            panic(p) &#x2F;&#x2F; unexpected panic; carry on panicking\n        &#125;\n    &#125;()\n    &#x2F;&#x2F; Bail out of recursion if we find more than one nonempty title.\n    forEachNode(doc, func(n *html.Node) &#123;\n        if n.Type &#x3D;&#x3D; html.ElementNode &amp;&amp; n.Data &#x3D;&#x3D; &quot;title&quot; &amp;&amp;\n            n.FirstChild !&#x3D; nil &#123;\n            if title !&#x3D; &quot;&quot; &#123;\n                panic(bailout&#123;&#125;) &#x2F;&#x2F; multiple titleelements\n            &#125;\n            title &#x3D; n.FirstChild.Data\n        &#125;\n    &#125;, nil)\n    if title &#x3D;&#x3D; &quot;&quot; &#123;\n        return &quot;&quot;, fmt.Errorf(&quot;no title element&quot;)\n    &#125;\n    return title, nil\n&#125;</code></pre>\n\n<h1 id=\"6-方法\"><a href=\"#6-方法\" class=\"headerlink\" title=\"6. 方法\"></a>6. 方法</h1><h2 id=\"6-1-方法声明\"><a href=\"#6-1-方法声明\" class=\"headerlink\" title=\"6.1 方法声明\"></a>6.1 方法声明</h2><ul>\n<li>普通函数与接收器方法<br><code>接收器</code>因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。对于一个给定的类型，其内部的方法都必须有唯一的方法名</li>\n</ul>\n<h2 id=\"6-2-基于指针对象的方法\"><a href=\"#6-2-基于指针对象的方法\" class=\"headerlink\" title=\"6.2 基于指针对象的方法\"></a>6.2 基于指针对象的方法</h2><ul>\n<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。</li>\n<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。</li>\n<li>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们下面例子里做的这样  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func (list *IntList) Sum() int &#123;\nif list &#x3D;&#x3D; nil &#123;\n    return 0\n&#125;\nreturn list.Value + list.Tail.Sum()\n&#125;</code></pre>\n  如果此时结构体是<code>nil</code>调用对象可能会发生类似于空指针异常的错误</li>\n</ul>\n<h2 id=\"6-3-通过嵌入结构体来扩展类型\"><a href=\"#6-3-通过嵌入结构体来扩展类型\" class=\"headerlink\" title=\"6.3. 通过嵌入结构体来扩展类型\"></a>6.3. 通过嵌入结构体来扩展类型</h2><ul>\n<li><p>方法值<br>  在go语言中，方法是第一公民，这一点在函数式编程中非常实用(maybe)</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;方法值demo\np :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;4, 6&#125;\n\ndistanceFromP :&#x3D; p.Distance        &#x2F;&#x2F; method value,Distance是结构体方法\nfmt.Println(distanceFromP(q))      &#x2F;&#x2F; &quot;5&quot;\nvar origin Point                   &#x2F;&#x2F; &#123;0, 0&#125;\nfmt.Println(distanceFromP(origin)) &#x2F;&#x2F; &quot;2.23606797749979&quot;, sqrt(5)\n\nscaleP :&#x3D; p.ScaleBy &#x2F;&#x2F; method value\nscaleP(2)           &#x2F;&#x2F; p becomes (2, 4)\nscaleP(3)           &#x2F;&#x2F;      then (6, 12)\nscaleP(10)          &#x2F;&#x2F;      then (60, 120)</code></pre>\n</li>\n<li><p>方法表达式<br>  在面向对象中，当根据哪一个变量来决定调用哪个函数时候,方法表达式就很有用了.</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">p :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;4, 6&#125;\n\ndistance :&#x3D; Point.Distance   &#x2F;&#x2F; method expression\nfmt.Println(distance(p, q))  &#x2F;&#x2F; &quot;5&quot;\nfmt.Printf(&quot;%T\\n&quot;, distance) &#x2F;&#x2F; &quot;func(Point, Point) float64&quot;\n\nscale :&#x3D; (*Point).ScaleBy\nscale(&amp;p, 2)\nfmt.Println(p)            &#x2F;&#x2F; &quot;&#123;2 4&#125;&quot;\nfmt.Printf(&quot;%T\\n&quot;, scale) &#x2F;&#x2F; &quot;func(*Point, float64)&quot;\n</code></pre></li>\n</ul>\n<p>practice demo</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Point struct&#123; X, Y float64 &#125;\n\nfunc (p Point) Add(q Point) Point &#123; return Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;\nfunc (p Point) Sub(q Point) Point &#123; return Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;\n\ntype Path []Point\n\nfunc (path Path) TranslateBy(offset Point, add bool) &#123;\n    var op func(p, q Point) Point\n    if add &#123;\n        op &#x3D; Point.Add\n    &#125; else &#123;\n        op &#x3D; Point.Sub\n    &#125;\n    for i :&#x3D; range path &#123;\n        &#x2F;&#x2F; Call either path[i].Add(offset) or path[i].Sub(offset).\n        path[i] &#x3D; op(path[i], offset)\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"6-4-封装\"><a href=\"#6-4-封装\" class=\"headerlink\" title=\"6.4 封装\"></a>6.4 封装</h2><p>封装提供了三方面的优点。</p>\n<ol>\n<li><p>首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可.</p>\n</li>\n<li><p>第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由</p>\n</li>\n<li><p>bytes.Buffer这个类型作为例子来考虑</p>\n <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\ntype Buffer struct &#123;\nbuf     []byte\ninitial [64]byte\n&#x2F;* ... *&#x2F;\n&#125;\n\n&#x2F;&#x2F; Grow expands the buffer&#39;s capacity, if necessary,\n&#x2F;&#x2F; to guarantee space for another n bytes. [...]\nfunc (b *Buffer) Grow(n int) &#123;\n    if b.buf &#x3D;&#x3D; nil &#123;\n        b.buf &#x3D; b.initial[:0] &#x2F;&#x2F; use preallocated space initially\n    &#125;\n    if len(b.buf)+n &gt; cap(b.buf) &#123;\n        buf :&#x3D; make([]byte, b.Len(), 2*cap(b.buf) + n)\n        copy(buf, b.buf)\n        b.buf &#x3D; buf\n    &#125;\n&#125;\n&#x2F;&#x2F; Grow()函数式导出类型，但是stuct的字段不是到处类型</code></pre>\n</li>\n<li><p>只暴漏关键信息给外部使用者</p>\n</li>\n</ol>\n<h1 id=\"7-接口\"><a href=\"#7-接口\" class=\"headerlink\" title=\"7. 接口\"></a>7. 接口</h1><p>很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用  </p>\n<p>只要一个物体能像鸭子一样叫那我们就可以称它为鸭子；只要一个软件能存储和查询数据我们就可以称它为数据库；只要一台机器有洗衣服和甩干的功能我们就可以称它为洗衣机。  </p>\n<p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型</p>\n<h2 id=\"7-1-接口约定\"><a href=\"#7-1-接口约定\" class=\"headerlink\" title=\"7.1. 接口约定\"></a>7.1. 接口约定</h2><p>例如<code>fmt</code>包</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package fmt\n\nfunc Fprintf(w io.Writer, format string, args ...interface&#123;&#125;) (int, error)\n&#x2F;&#x2F;Printf 最后调用Fprintf 函数\nfunc Printf(format string, args ...interface&#123;&#125;) (int, error) &#123;\n    return Fprintf(os.Stdout, format, args...)\n&#125;\n&#x2F;&#x2F; Sprintf函数最后也是调用Fprintf\nfunc Sprintf(format string, args ...interface&#123;&#125;) string &#123;\n    var buf bytes.Buffer\n    Fprintf(&amp;buf, format, args...)\n    return buf.String()\n&#125;</code></pre>\n\n<p><code>Fprintf</code>函数的<code>F</code>说明了文件类型也说明了所有信息要被写入到文件当中，在<code>Printf</code>函数中的第一个参数<code>os.Stdout</code>是<code>*os.File</code>类型实现了<code>io.Writer</code>接口，在<code>Sprintf</code>函数中的第一个参数<code>&amp;buf</code>是一个指向可以写入字节的内存缓冲区也该类型也是实现了<code>io.Writer</code>接口,用户可以自定义一个函数并实现<code>io.Writer</code>接口。<br><strong>LSP里氏替换</strong> : <code>fmt.Fprintf</code>通过使用接口类型<code>io.Writer</code>使得只要调用者只要传入实现了该接口的类型就可以实现自由替换</p>\n<details><summary>自定义bytecounter函数，实现计算int转byte长度</summary>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage main\n\nimport (\n\t&quot;fmt&quot;\n)\n\n&#x2F;&#x2F;!+bytecounter\n\ntype ByteCounter int\n\nfunc (c *ByteCounter) Write(p []byte) (int, error) &#123;\n\t*c +&#x3D; ByteCounter(len(p)) &#x2F;&#x2F; convert int to ByteCounter\n\treturn len(p), nil\n&#125;\n\n&#x2F;&#x2F;!-bytecounter\n\nfunc main() &#123;\n\t&#x2F;&#x2F;!+main\n\tvar c ByteCounter\n\tc.Write([]byte(&quot;hello&quot;))\n\tfmt.Println(c) &#x2F;&#x2F; &quot;5&quot;, &#x3D; len(&quot;hello&quot;)\n\n\tc &#x3D; 0 &#x2F;&#x2F; reset the counter\n\tvar name &#x3D; &quot;Dolly&quot;\n\tfmt.Fprintf(&amp;c, &quot;hello, %s&quot;, name)\n\tfmt.Println(c) &#x2F;&#x2F; &quot;12&quot;, &#x3D; len(&quot;hello, Dolly&quot;)\n\t&#x2F;&#x2F;!-main\n&#125;</code></pre>\n\n</details>\n\n<p>因为它实现了<code>writer</code>接口就可以传入到<code>Fprintf</code>函数中.总结来说，接口约定了包使用者的行为，但是使用者想创建什么样的实例需要他自己去实现。</p>\n<h2 id=\"7-2-接口类型\"><a href=\"#7-2-接口类型\" class=\"headerlink\" title=\"7.2 接口类型\"></a>7.2 接口类型</h2><p>通过组合定义接口</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package io\ntype Reader interface &#123;\n    Read(p []byte) (n int, err error)\n&#125;\ntype Closer interface &#123;\n    Close() error\n&#125;\n\ntype ReadWriter interface &#123;\n    Reader\n    Writer\n&#125;\ntype ReadWriteCloser interface &#123;\n    Reader\n    Writer\n    Closer\n&#125;\n&#x2F;&#x2F; 另一种命名风格\ntype ReadWriter interface &#123;\n    Read(p []byte) (n int, err error)\n    Write(p []byte) (n int, err error)\n&#125;\n&#x2F;&#x2F;或者甚至使用一种混合的风格：\n\ntype ReadWriter interface &#123;\n    Read(p []byte) (n int, err error)\n    Writer\n&#125;</code></pre>\n\n<h2 id=\"7-3-实现接口的条件\"><a href=\"#7-3-实现接口的条件\" class=\"headerlink\" title=\"7.3 实现接口的条件\"></a>7.3 实现接口的条件</h2><ul>\n<li><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口.</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var w io.Writer\n&#x2F;&#x2F;只实现了Write 方法\nw &#x3D; os.Stdout           &#x2F;&#x2F; OK: *os.File has Write method\n&#x2F;&#x2F;只实现了Write方法\nw &#x3D; new(bytes.Buffer)   &#x2F;&#x2F; OK: *bytes.Buffer has Write method\n&#x2F;&#x2F; time.Duration没有Write方法\nw &#x3D; time.Second         &#x2F;&#x2F; compile error: time.Duration lacks Write method\n\nvar rwc io.ReadWriteCloser\nrwc &#x3D; os.Stdout         &#x2F;&#x2F; OK: *os.File has Read, Write, Close methods\nrwc &#x3D; new(bytes.Buffer) &#x2F;&#x2F; compile error: *bytes.Buffer lacks Close method\n&#x2F;&#x2F; 这个规则甚至适用于等式右边本身也是一个接口类型\n&#x2F;&#x2F; rwc io.ReadWriteCloser\nw &#x3D; rwc                 &#x2F;&#x2F; OK: io.ReadWriteCloser has Write method\n&#x2F;&#x2F; w 只有Write方法\nrwc &#x3D; w                 &#x2F;&#x2F; compile error: io.Writer lacks Close method</code></pre>\n</li>\n<li></li>\n</ul>\n<h2 id=\"7-4-flag-Value接口\"><a href=\"#7-4-flag-Value接口\" class=\"headerlink\" title=\"7.4 flag.Value接口\"></a>7.4 flag.Value接口</h2><p>(翻译的太差劲，要去读原文)</p>\n<ul>\n<li><p>简单的<code>flag</code>包支持命令行的例子</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var period &#x3D; flag.Duration(&quot;period&quot;, 1*time.Second, &quot;sleep period&quot;)\n\nfunc main() &#123;\n    flag.Parse()\n    fmt.Printf(&quot;Sleeping for %v...&quot;, *period)\n    time.Sleep(*period)\n    fmt.Println()\n&#125;</code></pre>\n</li>\n<li><p>自定义新的标记符号</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package tempconv\n\nimport (\n    &quot;flag&quot;\n    &quot;fmt&quot;\n)\n\ntype Celsius float64\ntype Fahrenheit float64\n\nfunc CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9.0&#x2F;5.0 + 32.0) &#125;\nfunc FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32.0) * 5.0 &#x2F; 9.0) &#125;\n\nfunc (c Celsius) String() string &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125;\n\n&#x2F;*\n&#x2F;&#x2F;!+flagvalue\npackage flag\n\n&#x2F;&#x2F; Value is the interface to the value stored in a flag.\ntype Value interface &#123;\n    String() string\n    Set(string) error\n&#125;\n&#x2F;&#x2F;!-flagvalue\n*&#x2F;\n\n&#x2F;&#x2F;!+celsiusFlag\n&#x2F;&#x2F; *celsiusFlag satisfies the flag.Value interface.\ntype celsiusFlag struct&#123; Celsius &#125;\n\nfunc (f *celsiusFlag) Set(s string) error &#123;\n    var unit string\n    var value float64\n    fmt.Sscanf(s, &quot;%f%s&quot;, &amp;value, &amp;unit) &#x2F;&#x2F; no error check needed\n    switch unit &#123;\n    case &quot;C&quot;, &quot;°C&quot;:\n        f.Celsius &#x3D; Celsius(value)\n        return nil\n    case &quot;F&quot;, &quot;°F&quot;:\n        f.Celsius &#x3D; FToC(Fahrenheit(value))\n        return nil\n    &#125;\n    return fmt.Errorf(&quot;invalid temperature %q&quot;, s)\n&#125;\n\n&#x2F;&#x2F;!-celsiusFlag\n\n&#x2F;&#x2F;!+CelsiusFlag\n\n&#x2F;&#x2F; CelsiusFlag defines a Celsius flag with the specified name,\n&#x2F;&#x2F; default value, and usage, and returns the address of the flag variable.\n&#x2F;&#x2F; The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.\nfunc CelsiusFlag(name string, value Celsius, usage string) *Celsius &#123;\n    f :&#x3D; celsiusFlag&#123;value&#125;\n    flag.CommandLine.Var(&amp;f, name, usage)\n    return &amp;f.Celsius\n&#125;\n&#x2F;&#x2F; main函数\nvar temp &#x3D; tempconv.CelsiusFlag(&quot;temp&quot;, 20.0, &quot;the temperature&quot;)\n\nfunc main() &#123;\n    flag.Parse()\n    fmt.Println(*temp)\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"7-5-接口值\"><a href=\"#7-5-接口值\" class=\"headerlink\" title=\"7.5 接口值\"></a>7.5 接口值</h2><p>下面语句中,<code>io.Writer</code>是接口类型值</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var w io.Writer\nw &#x3D; os.Stdout\nw &#x3D; new(bytes.Buffer)\nw &#x3D; nil</code></pre>\n<ul>\n<li><p>对于接口的定义也不例外，<code>接口</code>的零值是它的类型和值的部分都是<code>nil</code></p>\n</li>\n<li><p>一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w&#x3D;&#x3D;nil或者w!&#x3D;nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生<code>panic</code>: <code>w.Write([]byte(&quot;hello&quot;)) // panic: nil pointer dereference</code></p>\n</li>\n<li><p>第二句statement，这个赋值过程调用了一个<code>具体类型</code>到<code>接口类型</code>的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的<code>os.File</code>类型变量的指针.接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是nil值。</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;\nos.Stdout.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot; \n&#x2F;&#x2F;上下两句是等价的</code></pre></li>\n<li><p>一个接口值可以持有任意大的动态值</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var x interface&#123;&#125; &#x3D; time.Now()</code></pre>\n\n<p>  接口值可以使用&#x3D;&#x3D;和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的&#x3D;&#x3D;操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数,然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var x interface&#123;&#125; &#x3D; []int&#123;1, 2, 3&#125;\nfmt.Println(x &#x3D;&#x3D; x) &#x2F;&#x2F; panic: comparing uncomparable type []int</code></pre></li>\n</ul>\n<p>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值.</p>\n<ul>\n<li><em>警告</em>: 一个包含nil指针的接口不是nil接口</li>\n</ul>\n<p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>\n<p>思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">const debug &#x3D; true\n\nfunc main() &#123;\n    var buf *bytes.Buffer\n    if debug &#123;\n        buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output\n    &#125;\n    f(buf) &#x2F;&#x2F; NOTE: subtly incorrect!\n    if debug &#123;\n        &#x2F;&#x2F; ...use buf...\n    &#125;\n&#125;\n\n&#x2F;&#x2F; If out is non-nil, output will be written to it.\nfunc f(out io.Writer) &#123;\n    &#x2F;&#x2F; ...do something...\n    if out !&#x3D; nil &#123;\n        out.Write([]byte(&quot;done!\\n&quot;))\n    &#125;\n&#125;</code></pre>\n<p>我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if out !&#x3D; nil &#123;\n    out.Write([]byte(&quot;done!\\n&quot;)) &#x2F;&#x2F; panic: nil pointer dereference\n&#125;</code></pre>\n<p>当main函数调用函数f时，它给f函数的out参数赋了一个<em>bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是</em>bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!&#x3D;nil的结果依然是true。</p>\n<p><img src=\"https://user-images.githubusercontent.com/46363359/182982938-08d67c3f-7aa6-457d-88a5-02646c5e2735.png\"></p>\n<p>动态分配机制依然决定(<em>bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如</em>os.File的类型，nil是一个有效的接收者（§6.2.1），但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</p>\n<p>问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var buf io.Writer\nif debug &#123;\n    buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output\n&#125;\nf(buf) &#x2F;&#x2F; OK</code></pre>\n<p>现在我们已经把接口值的技巧都讲完了，让我们来看更多的一些在Go标准库中的重要接口类型。在下面的三章中，我们会看到接口类型是怎样用在排序，web服务，错误处理中的。</p>\n<h2 id=\"7-6-sort-Interface接口\"><a href=\"#7-6-sort-Interface接口\" class=\"headerlink\" title=\"7.6. sort.Interface接口\"></a>7.6. sort.Interface接口</h2><p>golang提供了<code>sort</code>包帮助进行排序数据,实现排序需要自己实现对应的排序接口.</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type byArtist []*Track\nfunc (x byArtist) Len() int           &#123; return len(x) &#125;\nfunc (x byArtist) Less(i, j int) bool &#123; return x[i].Artist &lt; x[j].Artist &#125;\nfunc (x byArtist) Swap(i, j int)      &#123; x[i], x[j] &#x3D; x[j], x[i] &#125;</code></pre>\n<p>对于自定义的排序，我们也需要实现排序函数.</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;!+customcode\ntype customSort struct &#123;\n\tt    []*Track\n\tless func(x, y *Track) bool\n&#125;\n\nfunc (x customSort) Len() int           &#123; return len(x.t) &#125;\nfunc (x customSort) Less(i, j int) bool &#123; return x.less(x.t[i], x.t[j]) &#125;\nfunc (x customSort) Swap(i, j int)      &#123; x.t[i], x.t[j] &#x3D; x.t[j], x.t[i] &#125;\n\nsort.Sort(customSort&#123;tracks, func(x, y *Track) bool &#123;\n\t\tif x.Title !&#x3D; y.Title &#123;\n\t\t\treturn x.Title &lt; y.Title\n\t\t&#125;\n\t\tif x.Year !&#x3D; y.Year &#123;\n\t\t\treturn x.Year &lt; y.Year\n\t\t&#125;\n\t\tif x.Length !&#x3D; y.Length &#123;\n\t\t\treturn x.Length &lt; y.Length\n\t\t&#125;\n\t\treturn false\n\t&#125;&#125;)</code></pre>\n<p><code>IntsAreSorted(...interface&#123;&#125;)</code> reports whether the slice x is sorted in increasing order.</p>\n<h2 id=\"7-7-http-Handler接口\"><a href=\"#7-7-http-Handler接口\" class=\"headerlink\" title=\"7.7. http.Handler接口\"></a>7.7. http.Handler接口</h2><p>http.Handler的实例</p>\n<h2 id=\"7-8-error接口\"><a href=\"#7-8-error接口\" class=\"headerlink\" title=\"7.8. error接口\"></a>7.8. error接口</h2><pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage errors_demo\n\nfunc New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125;\n\ntype errorString struct &#123; text string &#125;\n\nfunc (e *errorString) Error() string &#123; return e.text &#125;</code></pre>\n<p>调用<code>errors.New</code>函数是非常稀少的，因为有一个方便的封装函数<code>fmt.Errorf</code>它还会处理字符串格式化<br>另一个error demo实例</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package syscall\n\ntype Errno uintptr &#x2F;&#x2F; operating system error code\n\nvar errors &#x3D; [...]string&#123;\n    1:   &quot;operation not permitted&quot;,   &#x2F;&#x2F; EPERM\n    2:   &quot;no such file or directory&quot;, &#x2F;&#x2F; ENOENT\n    3:   &quot;no such process&quot;,           &#x2F;&#x2F; ESRCH\n    &#x2F;&#x2F; ...\n&#125;\n\nfunc (e Errno) Error() string &#123;\n    if 0 &lt;&#x3D; int(e) &amp;&amp; int(e) &lt; len(errors) &#123;\n        return errors[e]\n    &#125;\n    return fmt.Sprintf(&quot;errno %d&quot;, e)\n&#125;\n\nvar err error &#x3D; syscall.Errno(2)\nfmt.Println(err.Error()) &#x2F;&#x2F; &quot;no such file or directory&quot;\nfmt.Println(err)         &#x2F;&#x2F; &quot;no such file or directory&quot;</code></pre>\n<p>用有限几个进行描述，并且它满足标准错误接口</p>\n<h2 id=\"7-9-类型断言\"><a href=\"#7-9-类型断言\" class=\"headerlink\" title=\"7.9. 类型断言\"></a>7.9. 类型断言</h2><p>语法上它看起来像<code>x.(T)</code>被称为断言类型，这里<code>x</code>表示一个接口的类型和T表示一个类型,详细解释，一个类型断言检查它操作对象的动态类型是否和断言的类型是否匹配,分两种情况</p>\n<ul>\n<li><p>(T传入的是具体类型，X是动态类型),然后类型断言检查<code>X</code>的动态类型是否和<code>T</code>相同.如果检查成功了类型断言的结果就是<code>X</code>的动态值</p>\n</li>\n<li><p>(T传入的是接口类型，X是动态类型),然后类型断言检查是否<code>x</code>的动态类型满足T,如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nvar w io.Writer\nw &#x3D; os.Stdout   &#x2F;&#x2F;能赋值说明os.Stdout 实现了Write()方法\nrw :&#x3D; w.(io.ReadWriter) &#x2F;&#x2F; success: *os.File has both Read and Write,断言w是否实现了接口(io.ReadWriter)的Read和Write接口\nw &#x3D; new(ByteCounter)\nrw &#x3D; w.(io.ReadWriter) &#x2F;&#x2F; panic: *ByteCounter has no Read method\n&#x2F;&#x2F;如果对预期结果只是个判断就可以用第二个返回参数bool.\nvar w io.Writer &#x3D; os.Stdout\nf, ok :&#x3D; w.(*os.File)      &#x2F;&#x2F; success:  ok, f &#x3D;&#x3D; os.Stdout\nb, ok :&#x3D; w.(*bytes.Buffer) &#x2F;&#x2F; failure: !ok, b &#x3D;&#x3D; nil\n&#x2F;&#x2F; if 后面的w变量不会覆盖外层的w\nif w, ok :&#x3D; w.(*os.File); ok &#123;\n&#x2F;&#x2F; ...use w...\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"7-10-基于类型断言区别错误类型\"><a href=\"#7-10-基于类型断言区别错误类型\" class=\"headerlink\" title=\"7.10. 基于类型断言区别错误类型\"></a>7.10. 基于类型断言区别错误类型</h2><p>对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。</p>\n<p>一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\n\npackage main\n\nimport (\n\t&quot;errors&quot;\n\t&quot;fmt&quot;\n\t&quot;os&quot;\n\t&quot;syscall&quot;\n)\n\ntype PathError struct &#123;\n\tOp   string\n\tPath string\n\tErr  error\n&#125;\n\nfunc (e *PathError) Error() string &#123;\n\treturn e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()\n&#125;\n\nvar ErrNotExist &#x3D; errors.New(&quot;file does not exist&quot;)\n\n&#x2F;&#x2F; IsNotExist returns a boolean indicating whether the error is known to\n&#x2F;&#x2F; report that a file or directory does not exist. It is satisfied by\n&#x2F;&#x2F; ErrNotExist as well as some syscall errors.\nfunc IsNotExist(err error) bool &#123;\n\tif pe, ok :&#x3D; err.(*PathError); ok &#123;\n\t\terr &#x3D; pe.Err\n\t&#125;\n\treturn err &#x3D;&#x3D; syscall.ENOENT || err &#x3D;&#x3D; ErrNotExist\n&#125;\n\nfunc main() &#123;\n\t_, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)\n\tfmt.Println(os.IsNotExist(err)) &#x2F;&#x2F; &quot;true&quot;\n&#125;</code></pre>\n\n<h2 id=\"7-11-any关键字与泛型\"><a href=\"#7-11-any关键字与泛型\" class=\"headerlink\" title=\"7.11. any关键字与泛型\"></a>7.11. any关键字与泛型</h2><p>类型定义时不限制<code>形参类型</code>，在函数调用的时候再指定<code>具体类型</code>.  <code>any</code>其实是<code>interface&#123;&#125;</code>的别名<br>泛型好处:  (1).在编译期间对类型进行检查以提高类型安全(2).通过指定类型消除强制类型转换(3).能够减少代码重复性，提供更通用的功能函数。</p>\n<ul>\n<li>类型泛型<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;fmt&quot;\n\ntype ListType[T int | int32 | int64 | string] []T\n\ntype MapType[K int | int32, V int64 | string] map[K]V\n\nfunc main() &#123;\n    var intList ListType[int]\n    intList &#x3D; []int&#123;1, 2, 3&#125;\n    fmt.Println(intList)\n    strList :&#x3D; ListType[string]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;\n    fmt.Println(strList)\n\n    intMap :&#x3D; MapType[int, string]&#123;1: &quot;1&quot;, 2: &quot;2&quot;&#125;\n    int32Map :&#x3D; MapType[int32, int64]&#123;1: 2, 3: 4&#125;\n    fmt.Println(intMap)\n    fmt.Println(int32Map)\n&#125;</code></pre>\n这里面的T,K,V都是占位符号,<code>ListType</code>只能在那三种类型中选择,同理<code>MapType</code>也是</li>\n<li>接口泛型<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type GenericStackInterface[T any] interface &#123;\n  Push(element T)\n  Pop() T\n&#125;</code></pre></li>\n<li>泛型函数<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func minInt[T int | int8 | int16 | int32](a, b T) T &#123;\nif a &lt; b &#123;\n    return a\n&#125;\n    return b\n&#125;\n\nfunc maxInt[T int | int8 | int16 | int32](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\nfunc Mix(a any) any &#123;\n\n&#125;\n&#x2F;&#x2F;还可以简化一下\ntype Numeric interface &#123;\n    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64\n&#125;\nfunc min[T Numeric](a, b T) T &#123;\nif a &lt; b &#123;\n    return a\n&#125;\n    return b\n&#125;\n\nfunc max[T Numeric](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\n&#x2F;&#x2F; go.18内置了数字类型的集合，故可以\nimport (\n&quot;golang.org&#x2F;x&#x2F;exp&#x2F;constraints&quot;\n)\n\nfunc minType[T constraints.Ordered](a, b T) T &#123;\n    if a &lt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\n\nfunc maxType[T constraints.Ordered](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;</code></pre>\n如果进入<code>constraints</code>源代码查看其具体代码的话，会发现在 Ordered 类型中也是有各种数字类型组合起来的。但是有一点奇怪的地方就是这里的类型集合中，各种类型前加了一个波浪线~, 表示衍生类型，即使用 type 自定义的类型也可以被识别到，只要底层类型一致即可。比如 ~int 可以包含 int 和 type MyInt int 等多种类型</li>\n</ul>\n<h1 id=\"8-Goroutines和Channels\"><a href=\"#8-Goroutines和Channels\" class=\"headerlink\" title=\"8. Goroutines和Channels\"></a>8. Goroutines和Channels</h1><p>(多看看本章代码)</p>\n<h2 id=\"8-1-goroutine\"><a href=\"#8-1-goroutine\" class=\"headerlink\" title=\"8.1 goroutine\"></a>8.1 goroutine</h2><p>通过代码示例了解<code>goroutine</code>的使用</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func main() &#123;\n    go spinner(100 * time.Millisecond)\n    const n &#x3D; 45\n    fibN :&#x3D; fib(n) &#x2F;&#x2F; slow\n    fmt.Printf(&quot;\\rFibonacci(%d) &#x3D; %d\\n&quot;, n, fibN)\n&#125;\n\nfunc spinner(delay time.Duration) &#123;\n    for &#123;\n        for _, r :&#x3D; range &#96;-\\|&#x2F;&#96; &#123;\n            fmt.Printf(&quot;\\r%c&quot;, r)\n            time.Sleep(delay)\n        &#125;\n    &#125;\n&#125;\n\nfunc fib(x int) int &#123;\n    if x &lt; 2 &#123;\n        return x\n    &#125;\n    return fib(x-1) + fib(x-2)\n&#125;</code></pre>\n<h2 id=\"8-2-channel\"><a href=\"#8-2-channel\" class=\"headerlink\" title=\"8.2 channel\"></a>8.2 channel</h2><p>这里应该还得看一下uber编码规范</p>\n<ul>\n<li><p>无缓冲channel</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">ch &lt;- x\nx &#x3D; &lt;-chan &#x2F;&#x2F;取出元素\n&lt;- ch &#x2F;&#x2F;取出，舍弃\nclose(ch) &#x2F;&#x2F; 关闭chan</code></pre>\n\n<ul>\n<li><p>串联channel</p>\n</li>\n<li><p>单方向channel</p>\n</li>\n</ul>\n</li>\n<li><p>缓冲channel</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">ch &#x3D; make(chan string, 3) &#x2F;&#x2F;channel容量为3</code></pre></li>\n</ul>\n<h2 id=\"8-3-基于select的多路复用\"><a href=\"#8-3-基于select的多路复用\" class=\"headerlink\" title=\"8.3 基于select的多路复用\"></a>8.3 基于select的多路复用</h2><details>\n<summary>多路复用demo</summary>\n<pre>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.\n&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;\n\n&#x2F;&#x2F; See page 246.\n\n&#x2F;&#x2F; Countdown implements the countdown for a rocket launch.\npackage main\n\n&#x2F;&#x2F; NOTE: the ticker goroutine never terminates if the launch is aborted.\n&#x2F;&#x2F; This is a &quot;goroutine leak&quot;.\n\nimport (\n        &quot;fmt&quot;\n        &quot;os&quot;\n        &quot;time&quot;\n)\n\n&#x2F;&#x2F;!+\n\nfunc main() &#123;\n        &#x2F;&#x2F; ...create abort channel...\n\n        &#x2F;&#x2F;!-\n\n        abort :&#x3D; make(chan struct&#123;&#125;)\n        go func() &#123;\n                os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte\n                abort &lt;- struct&#123;&#125;&#123;&#125;\n        &#125;()\n\n        &#x2F;&#x2F;!+\n        fmt.Println(&quot;Commencing countdown.  Press return to abort.&quot;)\n        tick :&#x3D; time.Tick(1 * time.Second)\n        for countdown :&#x3D; 10; countdown &gt; 0; countdown-- &#123;\n                fmt.Println(countdown)\n                select &#123;\n                case &lt;-tick:\n                        &#x2F;&#x2F; Do nothing.\n                case &lt;-abort:\n                        fmt.Println(&quot;Launch aborted!&quot;)\n                        return\n                &#125;\n        &#125;\n        launch()\n&#125;\n&#x2F;&#x2F;!-\nfunc launch() &#123;\n        fmt.Println(&quot;Lift off!&quot;)\n&#125;</code></pre>\n\n<p></pre></p>\n</details>\n\n<ul>\n<li><p>goroutine泄露 : 当for语句执行完后，程序已经跳转到其他部分，但是<code>time.Tick(1 * time.Second)</code>仍然会继续的网channel里面发送数据，这就会导致gotourine泄露，以上面为例，那么就需要合适的地方调用<code>tick.stop()</code></p>\n</li>\n<li><p>channel的ready : 一定要等到channel准备完毕，开始接受或者发送消息</p>\n</li>\n<li><p>channel的轮询 : 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">select &#123;\n  case &lt;-abort:\n      fmt.Printf(&quot;Launch aborted!\\n&quot;)\n      return\n  default:\n      &#x2F;&#x2F; do nothing\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"8-4-并发的退出\"><a href=\"#8-4-并发的退出\" class=\"headerlink\" title=\"8.4. 并发的退出\"></a>8.4. 并发的退出</h2><p>这节主要讨论如何有效退出goroutines</p>\n<details>\n<summary>\n<font size=\"3\" color=\"orange\">goroutines退出代码示例</font></summary>\n<pre>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;gopl.io&#x2F;ch8&#x2F;du4\n&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.\n&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;\n\n&#x2F;&#x2F; See page 251.\n\n&#x2F;&#x2F; The du4 command computes the disk usage of the files in a directory.\npackage main\n\n&#x2F;&#x2F; The du4 variant includes cancellation:\n&#x2F;&#x2F; it terminates quickly when the user hits return.\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;os&quot;\n\t&quot;path&#x2F;filepath&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\n&#x2F;&#x2F;!+1\nvar done &#x3D; make(chan struct&#123;&#125;)\n\nfunc cancelled() bool &#123;\n\tselect &#123;\n\tcase &lt;-done:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;!-1\n\nfunc main() &#123;\n\t&#x2F;&#x2F; Determine the initial directories.\n\troots :&#x3D; os.Args[1:]\n\tif len(roots) &#x3D;&#x3D; 0 &#123;\n\t\troots &#x3D; []string&#123;&quot;.&quot;&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;!+2\n\t&#x2F;&#x2F; Cancel traversal when input is detected.\n\tgo func() &#123;\n\t\tos.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte\n\t\tclose(done)\n\t&#125;()\n\t&#x2F;&#x2F;!-2\n\n\t&#x2F;&#x2F; Traverse each root of the file tree in parallel.\n\tfileSizes :&#x3D; make(chan int64)\n\tvar n sync.WaitGroup\n\tfor _, root :&#x3D; range roots &#123;\n\t\tn.Add(1)\n\t\tgo walkDir(root, &amp;n, fileSizes)\n\t&#125;\n\tgo func() &#123;\n\t\tn.Wait()\n\t\tclose(fileSizes)\n\t&#125;()\n\n\t&#x2F;&#x2F; Print the results periodically.\n\ttick :&#x3D; time.Tick(500 * time.Millisecond)\n\tvar nfiles, nbytes int64\nloop:\n\t&#x2F;&#x2F;!+3\n\tfor &#123;\n\t\tselect &#123;\n\t\tcase &lt;-done:\n\t\t\t&#x2F;&#x2F; Drain fileSizes to allow existing goroutines to finish.\n\t\t\tfor range fileSizes &#123;\n\t\t\t\t&#x2F;&#x2F; Do nothing.\n\t\t\t&#125;\n\t\t\treturn\n\t\tcase size, ok :&#x3D; &lt;-fileSizes:\n\t\t\t&#x2F;&#x2F; ...\n\t\t\t&#x2F;&#x2F;!-3\n\t\t\tif !ok &#123;\n\t\t\t\tbreak loop &#x2F;&#x2F; fileSizes was closed\n\t\t\t&#125;\n\t\t\tnfiles++\n\t\t\tnbytes +&#x3D; size\n\t\tcase &lt;-tick:\n\t\t\tprintDiskUsage(nfiles, nbytes)\n\t\t&#125;\n\t&#125;\n\tprintDiskUsage(nfiles, nbytes) &#x2F;&#x2F; final totals\n&#125;\n\nfunc printDiskUsage(nfiles, nbytes int64) &#123;\n\tfmt.Printf(&quot;%d files  %.1f GB\\n&quot;, nfiles, float64(nbytes)&#x2F;1e9)\n&#125;\n\n&#x2F;&#x2F; walkDir recursively walks the file tree rooted at dir\n&#x2F;&#x2F; and sends the size of each found file on fileSizes.\n&#x2F;&#x2F;!+4\nfunc walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) &#123;\n\tdefer n.Done()\n\tif cancelled() &#123;\n\t\treturn\n\t&#125;\n\tfor _, entry :&#x3D; range dirents(dir) &#123;\n\t\t&#x2F;&#x2F; ...\n\t\t&#x2F;&#x2F;!-4\n\t\tif entry.IsDir() &#123;\n\t\t\tn.Add(1)\n\t\t\tsubdir :&#x3D; filepath.Join(dir, entry.Name())\n\t\t\tgo walkDir(subdir, n, fileSizes)\n\t\t&#125; else &#123;\n\t\t\tfileSizes &lt;- entry.Size()\n\t\t&#125;\n\t\t&#x2F;&#x2F;!+4\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;!-4\n\nvar sema &#x3D; make(chan struct&#123;&#125;, 20) &#x2F;&#x2F; concurrency-limiting counting semaphore\n\n&#x2F;&#x2F; dirents returns the entries of directory dir.\n&#x2F;&#x2F;!+5\nfunc dirents(dir string) []os.FileInfo &#123;\n\tselect &#123;\n\tcase sema &lt;- struct&#123;&#125;&#123;&#125;: &#x2F;&#x2F; acquire token\n\tcase &lt;-done:\n\t\treturn nil &#x2F;&#x2F; cancelled\n\t&#125;\n\tdefer func() &#123; &lt;-sema &#125;() &#x2F;&#x2F; release token\n\n\t&#x2F;&#x2F; ...read directory...\n\t&#x2F;&#x2F;!-5\n\n\tf, err :&#x3D; os.Open(dir)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Fprintf(os.Stderr, &quot;du: %v\\n&quot;, err)\n\t\treturn nil\n\t&#125;\n\tdefer f.Close()\n\n\tentries, err :&#x3D; f.Readdir(0) &#x2F;&#x2F; 0 &#x3D;&gt; no limit; read all entries\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Fprintf(os.Stderr, &quot;du: %v\\n&quot;, err)\n\t\t&#x2F;&#x2F; Don&#39;t return: Readdir may return partial results.\n\t&#125;\n\treturn entries\n&#125;</code></pre>\n\n<p></pre></p>\n</details>\n\n<h1 id=\"9-基于共享变量的并发\"><a href=\"#9-基于共享变量的并发\" class=\"headerlink\" title=\"9. 基于共享变量的并发\"></a>9. 基于共享变量的并发</h1><p>(多看这章代码)<br>避免数据竞争的三个方法</p>\n<ul>\n<li><p>并发读数据不会有数据竞争问题</p>\n</li>\n<li><p>避免从多个goroutine中访问变量，使用独立变量</p>\n</li>\n<li><p>临界区控制</p>\n</li>\n<li><p>总结</p>\n<ul>\n<li>数据竞争: 程序在多个goroutine交叉执行操作时，导致数据不一致.  </li>\n<li><code>包级别</code>的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。<br>  (多看看本章代码)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-1-sync-Mutex与sync-RMutex互斥锁\"><a href=\"#9-1-sync-Mutex与sync-RMutex互斥锁\" class=\"headerlink\" title=\"9.1 sync.Mutex与sync.RMutex互斥锁\"></a>9.1 sync.Mutex与sync.RMutex互斥锁</h2><p>比如银行存款查询余额的场景，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款(这句话很关键要没有)操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁</p>\n<ul>\n<li>总结<ul>\n<li>避免临界区中的变量在中途被其他的goroutine修改</li>\n<li>使用mutex包进行互斥goroutine</li>\n<li>一个deferred Unlock即使在临界区发生<code>panic</code>时依然会执行</li>\n<li>golang不支持重入锁</li>\n<li>sync.RWMutex.RLock()持锁，sync.RWMutex.Lock()会阻塞，相同的RWMutex.Lock()持锁，sync.RWMutex.RLock()阻塞，但是sync.RWMutex.RLock()阻塞之间不阻塞</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-2-sync-Once惰性初始化\"><a href=\"#9-2-sync-Once惰性初始化\" class=\"headerlink\" title=\"9.2 sync.Once惰性初始化\"></a>9.2 sync.Once惰性初始化</h2><p>如果初始化的成本太高，需要延迟的初始化对象。可考虑使用<code>sync.Once</code><br><detials></p>\n<summary>sync.One的demo</summary>\n<pre>\n\n<p></pre></p>\n</details>\n\n\n<h2 id=\"9-3-sync-Cond的使用\"><a href=\"#9-3-sync-Cond的使用\" class=\"headerlink\" title=\"9.3 sync.Cond的使用\"></a>9.3 sync.Cond的使用</h2><ol>\n<li><p>使用场景: <code>sync.Cond</code> 经常用在多个goroutine等待，一个goroutine通知,如果是一读一等待使用<code>sync.Mutx</code>和<code>chan</code>就可以</p>\n</li>\n<li><p><code>sync.Cond</code>的<a href=\"https://pkg.go.dev/sync@go1.19#Cond\">方法</a></p>\n <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; Each Cond has an associated Locker L (often a *Mutex or *RWMutex),\n&#x2F;&#x2F; which must be held when changing the condition and\n&#x2F;&#x2F; when calling the Wait method.\n&#x2F;&#x2F;\n&#x2F;&#x2F; A Cond must not be copied after first use.\ntype Cond struct &#123;\n        noCopy noCopy\n        &#x2F;&#x2F; L is held while observing or changing the condition\n        L Locker\n        notify  notifyList\n        checker copyChecker\n&#125;\n</code></pre>\n\n<p> Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁</p>\n <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; Signal wakes one goroutine waiting on c, if there is any.\n&#x2F;&#x2F;\n&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L\n&#x2F;&#x2F; during the call.\n&#x2F;&#x2F;Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护\nfunc (c *Cond) Signal()\n&#x2F;&#x2F; Broadcast wakes all goroutines waiting on c.\n&#x2F;&#x2F;\n&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L\n&#x2F;&#x2F; during the call.\nfunc (c *Cond) Broadcast()\n\n&#x2F;&#x2F; Wait atomically unlocks c.L and suspends execution\n&#x2F;&#x2F; of the calling goroutine. After later resuming execution,\n&#x2F;&#x2F; Wait locks c.L before returning. Unlike in other systems,\n&#x2F;&#x2F; Wait cannot return unless awoken by Broadcast or Signal.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Because c.L is not locked when Wait first resumes, the caller\n&#x2F;&#x2F; typically cannot assume that the condition is true when\n&#x2F;&#x2F; Wait returns. Instead, the caller should Wait in a loop:\n&#x2F;&#x2F;\n&#x2F;&#x2F;    c.L.Lock()\n&#x2F;&#x2F;    for !condition() &#123;\n&#x2F;&#x2F;        c.Wait()\n&#x2F;&#x2F;    &#125;\n&#x2F;&#x2F;    ... make use of condition ...\n&#x2F;&#x2F;    c.L.Unlock()\n&#x2F;&#x2F;挂起调用者所在的 goroutine,等待Broadcast或者Signal方法\nfunc (c *Cond) Wait()\n    &#x2F;&#x2F;代码片段\n    c.L.Lock()\n    for !condition() &#123;\n        c.Wait()\n    &#125;\n    ... make use of condition ...\n    c.L.Unlock()\n\n\n\n</code></pre>\n</li>\n<li><p>Cond代码示例</p>\n <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var done &#x3D; false\n\nfunc read(name string, c *sync.Cond) &#123;\n    c.L.Lock()\n    for !done &#123;\n        c.Wait()\n    &#125;\n    log.Println(name, &quot;starts reading&quot;)\n    c.L.Unlock()\n&#125;\n\nfunc write(name string, c *sync.Cond) &#123;\n    log.Println(name, &quot;starts writing&quot;)\n    time.Sleep(time.Second)\n    c.L.Lock()\n    done &#x3D; true\n    c.L.Unlock()\n    log.Println(name, &quot;wakes all&quot;)\n    c.Broadcast()\n&#125;\n\nfunc main() &#123;\n    cond :&#x3D; sync.NewCond(&amp;sync.Mutex&#123;&#125;)\n\n    go read(&quot;reader1&quot;, cond)\n    go read(&quot;reader2&quot;, cond)\n    go read(&quot;reader3&quot;, cond)\n    write(&quot;writer&quot;, cond)\n\n    time.Sleep(time.Second * 3)\n&#125;\n</code></pre></li>\n</ol>\n<h2 id=\"9-4-Goroutines和线程\"><a href=\"#9-4-Goroutines和线程\" class=\"headerlink\" title=\"9.4. Goroutines和线程\"></a>9.4. Goroutines和线程</h2><ul>\n<li><p>每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量</p>\n</li>\n<li><p>一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩</p>\n</li>\n<li><p>Go的<code>运行时</code>有自己的调度器，这个调度器比如m:n调度，n个操作系统线程调度m个gotoutine，例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。</p>\n</li>\n<li><p>GOMAXPROCS : 变量来决定会有多少个操作系统的线程同时执行Go的代码,其默认的值是运行机器上的CPU的核心数,<code>GOMAXPROCS</code>是前面说的m:n调度中的n.下面代码就可以简单的看出os线程调度代码的情况</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nfor &#123;\n    go fmt.Print(0)\n    fmt.Print(1)\n&#125;\n\n$ GOMAXPROCS&#x3D;1 go run hacker-cliché.go\n111111111111111111110000000000000000000011111...\n\n$ GOMAXPROCS&#x3D;2 go run hacker-cliché.go\n010101010101010101011001100101011010010100110...</code></pre>\n\n\n</li>\n<li><p>总结</p>\n<ul>\n<li>通过广播机制来取消goroutines</li>\n<li>确保主函数退出，routines也随即退出</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"10-包和工具\"><a href=\"#10-包和工具\" class=\"headerlink\" title=\"10. 包和工具\"></a>10. 包和工具</h1><p>互联网上已经发布了非常多的Go语言开源包，它们可以通过 <a href=\"http://godoc.org/\">http://godoc.org</a> 检索</p>\n<ul>\n<li>包的声明 ： 通过<code>package.struct</code>的形式访问我们的下载的<code>package</code>,但是也有同名的例如<code>math/rand</code>和<code>crypto/rand</code>，这种要重新指定包名，只影响当前文件，同时也解决了那些又臭又长的包名</li>\n<li>文件开头以<code>_</code>和<code>.</code>的会被忽略</li>\n<li>以<code>_test</code>结尾的通常是测试包</li>\n<li>一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in&#x2F;yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml</li>\n<li><code>包的匿名导入</code>:<ul>\n<li>解决包的依赖顺序</li>\n<li>初始化包级声明的变量</li>\n<li>按顺序初始化包中每个文件里的 init 函数</li>\n<li>每个文件中可以包含多个 init 函数，按顺序执行(所以你导和不导包差距很大，匿名导入只是表明你无法使用相应包内函数)</li>\n<li>包名和成员名要尽量的短，并且能见名知意</li>\n</ul>\n</li>\n<li>go的工具<ul>\n<li>工作区结构 : 当需要切换工作区的时候，只需要更新下GOPATH环境变量即可<code>src</code>保存源代码,<code>pkg</code>子目录用于保存编译后的包的目标文件,<code>bin</code>子目录用于保存编译后的可执行程序</li>\n<li>下载包 : <code>go get</code>命令，<code>go get -u</code>命令只是简单地保证每个下载最新版本，实际工作中要对包版本做精细的管理，需要vendor目录管理不同版本的包,<code>go help gopath</code>查看vendor帮助文档,而go get 相当于获取的是远程仓库源代码的整个库，还可以看到仓库的版本信息，go支持导入远程github仓库的代码，<code>go get</code>下载的包保存在哪里呢？一般他会保存在这个目录：<code>GOPATH/src</code><br><a href=\"https://www.cnblogs.com/mrbug/p/11990418.html#:~:text=go%20get%20%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8C%85,%E7%9A%84go%20%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E3%80%82\">goget详细介绍</a>，<code>go get</code>是对模块代码的更新</li>\n<li>构建包 : 可以使用相对路径和绝对路径进行构建项目，<code>go run</code>其实也可以偷懒，直接<code>go run *.go</code>,<code>go build -i</code>命令将安装每个目标所依赖的包,<code>// +build linux darwin</code>,在包声明和包注释的前面，该构建注释参数告诉<code>go build</code>只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件,<code>// +build ignore</code>这个构建注释则表示不编译这个文件。<code>go doc go/build</code></li>\n<li>包文档 : 专门用于保存包文档的源文件通常叫<code>doc.go</code>,例如 <code>go doc time</code> 某个具体成员结构<code>go doc time.Since</code>,或者具体函数<code>go doc time.Duration.Second</code> , 更简单的是<code>godoc -http :8000</code>包含了所有go包的索引，<code>-analysis=type</code>和<code>-analysis=pointer</code>命令行标志参数用于打开文档和代码中关于静态分析的结果</li>\n<li>内部包 : 一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包</li>\n<li>搜索包 : <code>go list</code>列出工作区相关包,还可以查看完整包的原信息,例如<code>hash</code>包<code>go list -json hash</code><ul>\n<li>命令行参数-f则允许用户使用text&#x2F;template包（§4.6）的模板语言定义输出文本的格式<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;windows环境下注意\ngo list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...\n  compress&#x2F;bzip2 -&gt; bufio io sort\n  compress&#x2F;flate -&gt; bufio fmt io math sort strconv\n  compress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io time\n  compress&#x2F;lzw -&gt; bufio errors fmt io\n  compress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"11-测试\"><a href=\"#11-测试\" class=\"headerlink\" title=\"11. 测试\"></a>11. 测试</h1><p>go test选项含义</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n-args 传递参数到test binary<span class=\"token punctuation\">(</span>到时候补一个demo<span class=\"token punctuation\">)</span>\n-c 编译test binary,但是不执行\n-exec xprog  运行test binary ,原理如同 go run\n-i 安装test binary的相关依赖\n-json 将测试输出转化为json为了自动化处理\n-c <span class=\"token function\">file</span>   定义编译后的binary的文件名\n</code></pre>\n\n\n<h2 id=\"11-1-go-test\"><a href=\"#11-1-go-test\" class=\"headerlink\" title=\"11.1 go test\"></a>11.1 go test</h2><p>一个测试函数是以<code>Test</code>为函数名前缀的函数<br>一个基准测试函数是以<code>Benchmark</code>为函数名前缀的函数<br>一个示例函数是以<code>Example</code>为函数名前缀的函数，提供一个由编译器保证正确性的示例文档</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">- &#96;go test -v &#96;会打印每个函数的名字和运行时间\n- &#96;go test -run&#x3D; &#96;会去匹配正则表达式，只有被匹配到的才会被执行\n- &#96;go test -v .&#x2F;...&#96; 执行所有当前目录下测试cases\n- &#96;go test -v foo&#x2F;...&#96; 执行foo目录下所有cases\n- &#96;go test -v foo...&#96; 执行指定前缀的测试cases\n- &#96;go test ...&#96; gopath下所有测试cases\n- &#96;go test -v hello_test.go&#96; 执行某一文件下的测试cases,但是该文件中如果调用了其它文件中的模块会报错\n- &#96;go test -v hello_test.go -test.run TestHello&#96; 测试单个函数</code></pre>\n<ul>\n<li><p>组织多个测试用例</p>\n<p>即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息,可以使用<code>t.Fatal</code>或<code>t.Fatalf</code>停止当前测试函数</p>\n  <details>\n  <summary>组织多测试用例</summary>\n  <pre>\n  \n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func TestIsPalindrome(t *testing.T) &#123;\nvar tests &#x3D; []struct &#123;\n    input string\n    want  bool\n&#125;&#123;\n        &#123;&quot;&quot;, true&#125;,\n        &#123;&quot;a&quot;, true&#125;,\n        &#123;&quot;aa&quot;, true&#125;,\n        &#123;&quot;ab&quot;, false&#125;,\n        &#123;&quot;kayak&quot;, true&#125;,\n        &#123;&quot;detartrated&quot;, true&#125;,\n        &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;,\n        &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;,\n        &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;,\n        &#123;&quot;été&quot;, true&#125;,\n        &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;,\n        &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome\n        &#123;&quot;desserts&quot;, false&#125;,   &#x2F;&#x2F; semi-palindrome\n    &#125;\n    for _, test :&#x3D; range tests &#123;\n        if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123;\n            t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>  </pre></p>\n  </details>\n</li>\n<li><p>随机测试</p>\n<ol>\n<li>编写对照函数，效率低下</li>\n<li>生成的随机输入的数据遵循特定的模式，然后就知道期望的输出</li>\n</ol>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nimport &quot;math&#x2F;rand&quot;\n\n  &#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents\n  &#x2F;&#x2F; are derived from the pseudo-random number generator rng.\n  func randomPalindrome(rng *rand.Rand) string &#123;\n      n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24\n      runes :&#x3D; make([]rune, n)\n      for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;\n          r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\\u0999&#39;\n          runes[i] &#x3D; r\n          runes[n-1-i] &#x3D; r\n      &#125;\n      return string(runes)\n  &#125;\n\n  func TestRandomPalindromes(t *testing.T) &#123;\n      &#x2F;&#x2F; Initialize a pseudo-random number generator.\n      seed :&#x3D; time.Now().UTC().UnixNano()\n      t.Logf(&quot;Random seed: %d&quot;, seed)\n      rng :&#x3D; rand.New(rand.NewSource(seed))\n\n      for i :&#x3D; 0; i &lt; 1000; i++ &#123;\n          p :&#x3D; randomPalindrome(rng)\n          if !IsPalindrome(p) &#123;\n              t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)\n          &#125;\n      &#125;\n  &#125;\n  &#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.\n  &#x2F;&#x2F; Letter case is ignored, as are non-letters.\n  func IsPalindrome(s string) bool &#123;\n      var letters []rune\n      for _, r :&#x3D; range s &#123;\n          if unicode.IsLetter(r) &#123;\n              letters &#x3D; append(letters, unicode.ToLower(r))\n          &#125;\n      &#125;\n      for i :&#x3D; range letters &#123;\n          if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;\n              return false\n          &#125;\n      &#125;\n      return true\n  &#125;\n</code></pre>\n</li>\n<li><p>测试一个命令(测试内部未导出函数)</p>\n<p>要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。要注意的是在测试代码中并没有调用<code>log.Fatal</code>或<code>os.Exit</code>，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理,如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理.导出内部函数,</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; src&#x2F;bytes&#x2F;export_test.go\n  package bytes\n  &#x2F;&#x2F; Export func for testing\n  var IndexBytePortable &#x3D; indexBytePortable &#x2F;&#x2F; 赋值给包级可导出变量</code></pre>\n\n<p>然后通过外部包进行测试</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\n&#x2F;&#x2F; src&#x2F;bytes&#x2F;bytes_test.go\n  package bytes_test\n\n  func TestIndexByte(t *testing.T) &#123;\n      for _, tt :&#x3D; range indexTests &#123;\n          ... 代码片段\n          posp :&#x3D; IndexBytePortable(a, b) &#x2F;&#x2F; 导出的内部方法在这里被使用\n          if posp !&#x3D; tt.i &#123;\n              t.Errorf(&#96;indexBytePortable(%q, &#39;%c&#39;) &#x3D; %v&#96;, tt.a, b, posp)\n          &#125;\n      &#125;\n  &#125;\n</code></pre>\n<p>还有种方式就是不导出，直接在包名下写测试函数，然后进行测试源代码</p>\n</li>\n<li><p>白盒测试</p>\n<p>TBC,代码的内部实现对于测试人员来说是可见的，言外之意就是能看到内部实现,测试内部实现，这个实现可能是未导出的</p>\n</li>\n<li><p>外部测试包</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package pprint_test\n  &#x2F;&#x2F;这时候就可以在\n  import (\n      &quot;gott&#x2F;hi&quot;\n      &#x2F;&#x2F; 导入 要进行测试的 pprint 包本身\n      &quot;gott&#x2F;pprint&quot;\n      &quot;testing&quot;\n  )\n\n  func TestPPrint(t *testing.T) &#123;\n      pprint.PPrint()\n      hi.Say()\n      t.Log(&quot;expect call PPrint&quot;)\n  &#125;\n  </code></pre>\n<p>使用 Go 官方的代码风格：pprint_test.go 文件，因为pprint_test在 pprint 目录下，通过在 import 时，使用<code>.</code>选项，可以直接调用PPrint()方法</p>\n</li>\n<li><p>编写有效的测试</p>\n<ol>\n<li>一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息</li>\n<li>一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律</li>\n<li>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试</li>\n</ol>\n</li>\n<li><p>避免脆弱的测试<br>TBC</p>\n</li>\n</ul>\n<h2 id=\"11-2-测试覆盖率\"><a href=\"#11-2-测试覆盖率\" class=\"headerlink\" title=\"11.2 测试覆盖率\"></a>11.2 测试覆盖率</h2><p>对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化(应该是有)</p>\n<ol>\n<li>go test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;eval</li>\n<li>go test -run&#x3D;Coverage -covermode&#x3D;count gopl.io&#x2F;ch7&#x2F;eval</li>\n</ol>\n<h2 id=\"11-3-基准测试\"><a href=\"#11-3-基准测试\" class=\"headerlink\" title=\"11.3 基准测试\"></a>11.3 基准测试</h2><ol>\n<li><code>-bench</code>也是正则匹配,BenchmarkIsPalindrome-8,8表示的是GOMAXPROCS的值,<code>-benchmem</code>命令行标志参数将在报告中包含内存的分配数据统计</li>\n<li>比较型的基准测试就是普通程序代码,它们通常是单参数的函数，由几个不同数量级的基准测试函数调用,通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。所有的测试cases都要保留，随着项目的发展，都需要做回归测试</li>\n</ol>\n<h2 id=\"11-4-刨析\"><a href=\"#11-4-刨析\" class=\"headerlink\" title=\"11.4 刨析\"></a>11.4 刨析</h2><p>TBC</p>\n<h2 id=\"11-5-示例函数\"><a href=\"#11-5-示例函数\" class=\"headerlink\" title=\"11.5 示例函数\"></a>11.5 示例函数</h2><p>示例函数有三个用处。</p>\n<ol>\n<li>最主要的一个是作为文档，根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。</li>\n<li>在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的&#x2F;&#x2F; Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配</li>\n<li>提供一个真实的演练场，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数</li>\n</ol>\n<h1 id=\"12-appendIndex\"><a href=\"#12-appendIndex\" class=\"headerlink\" title=\"12. appendIndex\"></a>12. appendIndex</h1><ol>\n<li>线程内再重启一个线程，然后就可以通过加锁，进行隔离开，但此时任然是两个线程的间的交替</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"#1-%E5%85%A5%E9%97%A8\">1. 入门</a></li>\n<li><a href=\"#2-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84\">2. 程序结构</a><ul>\n<li><a href=\"#21-%E5%91%BD%E5%90%8D\">2.1 命名</a></li>\n<li><a href=\"#22-%E5%A3%B0%E6%98%8E\">2.2 声明</a></li>\n<li><a href=\"#23-%E5%8F%98%E9%87%8F\">2.3 变量</a><ul>\n<li><a href=\"#231-%E7%AE%80%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E\">2.3.1 简短变量声明</a></li>\n<li><a href=\"#232-%E6%8C%87%E9%92%88\">2.3.2 指针</a></li>\n<li><a href=\"#233-new%E5%87%BD%E6%95%B0\">2.3.3 new函数</a></li>\n<li><a href=\"#234-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">2.3.4. 变量的生命周期</a></li>\n</ul>\n</li>\n<li><a href=\"#24-%E8%B5%8B%E5%80%BC\">2.4 赋值</a><ul>\n<li><a href=\"#241-%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC\">2.4.1 元组赋值</a></li>\n</ul>\n</li>\n<li><a href=\"#25-%E7%B1%BB%E5%9E%8B\">2.5 类型</a></li>\n<li><a href=\"#26-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6\">2.6 包和文件</a></li>\n<li><a href=\"#27-%E4%BD%9C%E7%94%A8%E5%9F%9F\">2.7. 作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">3.基础数据类型</a><ul>\n<li><a href=\"#31-%E6%95%B4%E5%9E%8B\">3.1 整型</a></li>\n<li><a href=\"#32-%E6%B5%AE%E7%82%B9%E6%95%B0\">3.2 浮点数</a></li>\n<li><a href=\"#33-%E5%A4%8D%E6%95%B0\">3.3 复数</a></li>\n<li><a href=\"#34-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B\">3.4 布尔类型</a></li>\n<li><a href=\"#35-%E5%AD%97%E7%AC%A6%E4%B8%B2\">3.5 字符串</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">4. 复合数据类型</a><ul>\n<li><a href=\"#41-%E6%95%B0%E7%BB%84\">4.1 数组</a></li>\n<li><a href=\"#42-slice\">4.2 slice</a><ul>\n<li><a href=\"#421-append%E5%87%BD%E6%95%B0\">4.2.1 append函数</a></li>\n</ul>\n</li>\n<li><a href=\"#43-map\">4.3 Map</a></li>\n<li><a href=\"#44-%E7%BB%93%E6%9E%84%E4%BD%93\">4.4 结构体</a><ul>\n<li><a href=\"#441-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E5%80%BC\">4.4.1 结构体字面值</a></li>\n<li><a href=\"#442-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%AF%94%E8%BE%83\">4.4.2 结构体的比较</a></li>\n<li><a href=\"#443-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98\">4.4.3 结构体嵌入和匿名成员</a></li>\n</ul>\n</li>\n<li><a href=\"#45-json%E5%AD%97%E7%AC%A6%E4%B8%B2\">4.5 json字符串</a></li>\n<li><a href=\"#46-%E6%96%87%E6%9C%AC%E5%92%8Chtml%E6%A8%A1%E6%9D%BF\">4.6 文本和HTML模板</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E5%87%BD%E6%95%B0\">5. 函数</a><ul>\n<li><a href=\"#51-%E9%94%99%E8%AF%AF\">5.1 错误</a></li>\n<li><a href=\"#52-%E5%87%BD%E6%95%B0%E5%80%BC\">5.2 函数值</a></li>\n<li><a href=\"#53-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\">5.3 匿名函数</a></li>\n<li><a href=\"#54-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\">5.4 可变参数</a></li>\n<li><a href=\"#55-defer%E5%87%BD%E6%95%B0\">5.5 defer函数</a></li>\n<li><a href=\"#56-panic%E5%BC%82%E5%B8%B8\">5.6 panic异常</a></li>\n<li><a href=\"#57-recovery%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8\">5.7 Recovery捕获异常</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E6%96%B9%E6%B3%95\">6. 方法</a><ul>\n<li><a href=\"#61-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E\">6.1 方法声明</a></li>\n<li><a href=\"#62-%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95\">6.2 基于指针对象的方法</a></li>\n<li><a href=\"#63-%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B\">6.3. 通过嵌入结构体来扩展类型</a></li>\n<li><a href=\"#64-%E5%B0%81%E8%A3%85\">6.4 封装</a></li>\n</ul>\n</li>\n<li><a href=\"#7-%E6%8E%A5%E5%8F%A3\">7. 接口</a><ul>\n<li><a href=\"#71-%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A\">7.1. 接口约定</a></li>\n<li><a href=\"#72-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B\">7.2 接口类型</a></li>\n<li><a href=\"#73-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6\">7.3 实现接口的条件</a></li>\n<li><a href=\"#74-flagvalue%E6%8E%A5%E5%8F%A3\">7.4 flag.Value接口</a></li>\n<li><a href=\"#75-%E6%8E%A5%E5%8F%A3%E5%80%BC\">7.5 接口值</a></li>\n<li><a href=\"#76-sortinterface%E6%8E%A5%E5%8F%A3\">7.6. sort.Interface接口</a></li>\n<li><a href=\"#77-httphandler%E6%8E%A5%E5%8F%A3\">7.7. http.Handler接口</a></li>\n<li><a href=\"#78-error%E6%8E%A5%E5%8F%A3\">7.8. error接口</a></li>\n<li><a href=\"#79-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\">7.9. 类型断言</a></li>\n<li><a href=\"#710-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B\">7.10. 基于类型断言区别错误类型</a></li>\n<li><a href=\"#711-any%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%B3%9B%E5%9E%8B\">7.11. any关键字与泛型</a></li>\n</ul>\n</li>\n<li><a href=\"#8-goroutines%E5%92%8Cchannels\">8. Goroutines和Channels</a><ul>\n<li><a href=\"#81-goroutine\">8.1 goroutine</a></li>\n<li><a href=\"#82-channel\">8.2 channel</a></li>\n<li><a href=\"#83-%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\">8.3 基于select的多路复用</a></li>\n<li><a href=\"#84-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%80%E5%87%BA\">8.4. 并发的退出</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91\">9. 基于共享变量的并发</a><ul>\n<li><a href=\"#91-syncmutex%E4%B8%8Esyncrmutex%E4%BA%92%E6%96%A5%E9%94%81\">9.1 sync.Mutex与sync.RMutex互斥锁</a></li>\n<li><a href=\"#92-synconce%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96\">9.2 sync.Once惰性初始化</a></li>\n<li><a href=\"#93-synccond%E7%9A%84%E4%BD%BF%E7%94%A8\">9.3 sync.Cond的使用</a></li>\n<li><a href=\"#94-goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B\">9.4. Goroutines和线程</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7\">10. 包和工具</a></li>\n<li><a href=\"#11-%E6%B5%8B%E8%AF%95\">11. 测试</a><ul>\n<li><a href=\"#111-go-test\">11.1 go test</a></li>\n<li><a href=\"#112-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87\">11.2 测试覆盖率</a></li>\n<li><a href=\"#113-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\">11.3 基准测试</a></li>\n<li><a href=\"#114-%E5%88%A8%E6%9E%90\">11.4 刨析</a></li>\n<li><a href=\"#115-%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0\">11.5 示例函数</a></li>\n</ul>\n</li>\n<li><a href=\"#12-appendindex\">12. appendIndex</a></li>\n</ul>\n<h1 id=\"1-入门\"><a href=\"#1-入门\" class=\"headerlink\" title=\"1. 入门\"></a>1. 入门</h1><h1 id=\"2-程序结构\"><a href=\"#2-程序结构\" class=\"headerlink\" title=\"2. 程序结构\"></a>2. 程序结构</h1><h2 id=\"2-1-命名\"><a href=\"#2-1-命名\" class=\"headerlink\" title=\"2.1 命名\"></a>2.1 命名</h2><table>\n<thead>\n<tr>\n<th>功能性关键字</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break</td>\n<td></td>\n</tr>\n<tr>\n<td>case</td>\n<td></td>\n</tr>\n<tr>\n<td>chan</td>\n<td></td>\n</tr>\n<tr>\n<td>const</td>\n<td></td>\n</tr>\n<tr>\n<td>continue</td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n</tr>\n<tr>\n<td>defer</td>\n<td></td>\n</tr>\n<tr>\n<td>else</td>\n<td></td>\n</tr>\n<tr>\n<td>fallthrough</td>\n<td></td>\n</tr>\n<tr>\n<td>for</td>\n<td></td>\n</tr>\n<tr>\n<td>func</td>\n<td></td>\n</tr>\n<tr>\n<td>go</td>\n<td></td>\n</tr>\n<tr>\n<td>if</td>\n<td></td>\n</tr>\n<tr>\n<td>import</td>\n<td></td>\n</tr>\n<tr>\n<td>interface</td>\n<td></td>\n</tr>\n<tr>\n<td>map</td>\n<td></td>\n</tr>\n<tr>\n<td>package</td>\n<td></td>\n</tr>\n<tr>\n<td>range</td>\n<td></td>\n</tr>\n<tr>\n<td>return</td>\n<td></td>\n</tr>\n<tr>\n<td>select</td>\n<td></td>\n</tr>\n<tr>\n<td>struct</td>\n<td></td>\n</tr>\n<tr>\n<td>switch</td>\n<td></td>\n</tr>\n<tr>\n<td>type</td>\n<td></td>\n</tr>\n<tr>\n<td>var</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>内建常量</th>\n<th>关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>true</td>\n<td></td>\n</tr>\n<tr>\n<td>false</td>\n<td></td>\n</tr>\n<tr>\n<td>iota</td>\n<td></td>\n</tr>\n<tr>\n<td>nil</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>内建类型</th>\n<th>关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int</td>\n<td></td>\n</tr>\n<tr>\n<td>int8</td>\n<td></td>\n</tr>\n<tr>\n<td>int16</td>\n<td></td>\n</tr>\n<tr>\n<td>int32</td>\n<td></td>\n</tr>\n<tr>\n<td>int64</td>\n<td></td>\n</tr>\n<tr>\n<td>uint</td>\n<td></td>\n</tr>\n<tr>\n<td>uint8</td>\n<td></td>\n</tr>\n<tr>\n<td>uint16</td>\n<td></td>\n</tr>\n<tr>\n<td>uint32</td>\n<td></td>\n</tr>\n<tr>\n<td>uint64</td>\n<td></td>\n</tr>\n<tr>\n<td>uintptr</td>\n<td></td>\n</tr>\n<tr>\n<td>float32</td>\n<td></td>\n</tr>\n<tr>\n<td>float64</td>\n<td></td>\n</tr>\n<tr>\n<td>complex128</td>\n<td></td>\n</tr>\n<tr>\n<td>complex64</td>\n<td></td>\n</tr>\n<tr>\n<td>bool</td>\n<td></td>\n</tr>\n<tr>\n<td>byte</td>\n<td></td>\n</tr>\n<tr>\n<td>rune</td>\n<td></td>\n</tr>\n<tr>\n<td>string</td>\n<td></td>\n</tr>\n<tr>\n<td>error</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>内建函数</th>\n<th>关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>make</td>\n<td></td>\n</tr>\n<tr>\n<td>len</td>\n<td></td>\n</tr>\n<tr>\n<td>cap</td>\n<td></td>\n</tr>\n<tr>\n<td>new</td>\n<td></td>\n</tr>\n<tr>\n<td>append</td>\n<td></td>\n</tr>\n<tr>\n<td>copy</td>\n<td></td>\n</tr>\n<tr>\n<td>close</td>\n<td></td>\n</tr>\n<tr>\n<td>delete</td>\n<td></td>\n</tr>\n<tr>\n<td>complex</td>\n<td></td>\n</tr>\n<tr>\n<td>real</td>\n<td></td>\n</tr>\n<tr>\n<td>imag</td>\n<td></td>\n</tr>\n<tr>\n<td>panic</td>\n<td></td>\n</tr>\n<tr>\n<td>recover</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>Go推荐使用<code>驼峰式</code>命名:</p>\n<ul>\n<li>一个名字必须以一个字母（Unicode字母）或下划线开头,下划线开头可能表示<code>私有的</code></li>\n<li>后面可以跟任意数量的字母、数字或下划线。</li>\n<li>名字的开头字母的大小写决定了名字在包外的可见性.如果一个名字是大写字母开头的(译注必须是 在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将是导出的,也就是说可以被外部的包访问,例如<code>fmt.Printf</code>,就可以在包外访问</li>\n</ul>\n<h2 id=\"2-2-声明\"><a href=\"#2-2-声明\" class=\"headerlink\" title=\"2.2 声明\"></a>2.2 声明</h2><p>Go语言主要有四种类型的声明语句:</p>\n<ul>\n<li>var</li>\n<li>const</li>\n<li>type</li>\n<li>func</li>\n</ul>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;fmt&quot;\n\nconst boilingF &#x3D; 212.0\nconst var a &#x3D; 0\n\nfunc main() &#123;\n    var f &#x3D; boilingF\n    var c &#x3D; (f - 32) * 5 &#x2F; 9\n    fmt.Printf(&quot;boiling point &#x3D; %g°F or %g°C\\n&quot;, f, c)\n    &#x2F;&#x2F; Output:\n    &#x2F;&#x2F; boiling point &#x3D; 212°F or 100°C\n&#125;</code></pre>\n\n<p><code>boilingF</code>是包一级的变量在包内可以访问。如果函数没有返回值，那么返回值列表是省略的。函数顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者</p>\n<h2 id=\"2-3-变量\"><a href=\"#2-3-变量\" class=\"headerlink\" title=\"2.3 变量\"></a>2.3 变量</h2><p>常规声明变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var 变量名字 类型 &#x3D; 表达式</code></pre>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var i ,j , k int &#x2F;&#x2F; 都是int类型\nvar b,f,s &#x3D;true , 2.3 ,&quot;four&quot; &#x2F;&#x2F;bool , float 64,string\nvar f, err &#x3D; os.Open(name) &#x2F;&#x2F; os.Open returns a file and an error</code></pre>\n\n<ul>\n<li>在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。</li>\n<li><code>类型</code>和<code>表达式</code>都可以缺省,如果是<code>类型</code>缺省那么就可以通过<code>表达式</code>进行推断,如果是表达式缺省那么就会赋类型的<code>零</code>值,如果是自定义类型或者是引用类型就是内部各个字段都是<code>零</code>值.Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态</li>\n</ul>\n<h3 id=\"2-3-1-简短变量声明\"><a href=\"#2-3-1-简短变量声明\" class=\"headerlink\" title=\"2.3.1 简短变量声明\"></a>2.3.1 简短变量声明</h3>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">anim :&#x3D; gif.GIF&#123;LoopCount: nframes&#125; &#x2F;&#x2F;聚合类型,引用类型\nfreq :&#x3D; rand.Float64() * 3.0 &#x2F;&#x2F; float\nt :&#x3D; 0.0  &#x2F;&#x2F;float\nf, err :&#x3D; os.Open(name) &#x2F;&#x2F;通过函数进行声明，并初始化\nif err !&#x3D; nil &#123;\n    return err\n&#125;</code></pre>\n\n<ul>\n<li>例子1中声明的err是重复,第二个简短声明符的err就是赋值操作，注意该操作是在变量相同作用例子2中这种情况编译不通过,至少有一个是新声明的.[ 实际工程中尽量不要出现例子2 ]</li>\n</ul>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;例子1\nin, err :&#x3D; os.Open(infile)\n&#x2F;&#x2F; ...\nout, err :&#x3D; os.Create(outfile)\n&#x2F;&#x2F;例子2\nf, err :&#x3D; os.Open(infile)\n&#x2F;&#x2F; ...\nf, err :&#x3D; os.Create(outfile) &#x2F;&#x2F; compile error: no new variables</code></pre>\n\n\n<h3 id=\"2-3-2-指针\"><a href=\"#2-3-2-指针\" class=\"headerlink\" title=\"2.3.2 指针\"></a>2.3.2 指针</h3><ul>\n<li><p><code>任何类型</code>的指针的<code>零值</code>都是<code>nil</code>。如果p指向某个有效变量，那么<code>p != nil</code>测试为<code>真</code>。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>\n</li>\n<li><p>返回局部变量地址也是安全的。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func incr(p *int) int &#123;\n    *p++ &#x2F;&#x2F; 非常重要：只是增加p指向的变量的值，并不改变p指针！！！\n    return *p\n&#125;\nv :&#x3D; 1\nincr(&amp;v)              &#x2F;&#x2F; side effect: v is now 2\nfmt.Println(incr(&amp;v)) &#x2F;&#x2F; &quot;3&quot; (and v is 3)</code></pre>\n</li>\n<li><p>在flag包中,应用到了<code>指针</code>技术</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\nimport (\n    &quot;flag&quot;\n    &quot;fmt&quot;\n    &quot;strings&quot;\n)\nvar n &#x3D; flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)\nvar sep &#x3D; flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)\n\nfunc main() &#123;\n    flag.Parse() &#x2F;&#x2F;解析标志性参数位\n    fmt.Print(strings.Join(flag.Args(), *sep)) &#x2F;&#x2F;flag.Args() 解析非标志参数位\n    if !*n &#123;\n        fmt.Println()\n    &#125;\n&#125;</code></pre>\n<ul>\n<li>在此代码例子中使用<code>flag.Args()</code>解析非标志参数位,<code>flag.Parse()</code>解析标志性参数位,to be continue</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-3-new函数\"><a href=\"#2-3-3-new函数\" class=\"headerlink\" title=\"2.3.3 new函数\"></a>2.3.3 new函数</h3><p>  表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T(返回的是指针)</p>\n<ul>\n<li>每次new()返回新的变量地址,比如new(int)</li>\n</ul>\n<h3 id=\"2-3-4-变量的生命周期\"><a href=\"#2-3-4-变量的生命周期\" class=\"headerlink\" title=\"2.3.4. 变量的生命周期\"></a>2.3.4. 变量的生命周期</h3><ul>\n<li>包一级的声明会伴随程序整个声明周期,但是函数内部则是动态,会被GC回收</li>\n<li>函数的<code>参数变量</code>(参数列表)和<code>返回值变量</code>都是<code>局部变量</code>。它们在函数每次被调用的时候创建,下面循环的<code>变量t</code>就是动态创建,用完就扔  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;\n  x :&#x3D; math.Sin(t)\n  y :&#x3D; math.Sin(t*freq + phase)\n  img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),\n      blackIndex)\n&#125;</code></pre></li>\n</ul>\n<p>  下面也是合法的</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;\n  x :&#x3D; math.Sin(t)\n  y :&#x3D; math.Sin(t*freq + phase)\n  img.SetColorIndex(\n      size+int(x*size+0.5), size+int(y*size+0.5),\n      blackIndex, &#x2F;&#x2F; 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性\n  )               &#x2F;&#x2F; 小括弧另起一行缩进，和大括弧的风格保存一致\n&#125;</code></pre>\n\n<ul>\n<li><code>局部变量逃逸</code>.因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。<code>编译器</code>会自动选择在<code>栈</code>上还是在<code>堆</code>上分配局部变量的存储空间,代码如下,<code>f</code>函数里的<code>x变量</code>必须在<code>堆</code>上分配,因为它在函数退出后依然可以通过包一级的<code>global变量</code>找到,<code>g</code>函数在栈上分配<code>*y</code>内存空间  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var global *int\n\nfunc f() &#123;\n    var x int\n    x &#x3D; 1\n    global &#x3D; &amp;x\n&#125;\n\nfunc g() &#123;\n    y :&#x3D; new(int)\n    *y &#x3D; 1\n&#125;\n</code></pre></li>\n<li>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期,比如,如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。</li>\n</ul>\n<h2 id=\"2-4-赋值\"><a href=\"#2-4-赋值\" class=\"headerlink\" title=\"2.4 赋值\"></a>2.4 赋值</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">x &#x3D; 1                       &#x2F;&#x2F; 命名变量的赋值\n*p &#x3D; true                   &#x2F;&#x2F; 通过指针间接赋值\nperson.name &#x3D; &quot;bob&quot;         &#x2F;&#x2F; 结构体字段赋值\ncount[x] &#x3D; count[x] * scale &#x2F;&#x2F; 数组、slice或map的元素赋值\n</code></pre>\n\n<h3 id=\"2-4-1-元组赋值\"><a href=\"#2-4-1-元组赋值\" class=\"headerlink\" title=\"2.4.1 元组赋值\"></a>2.4.1 元组赋值</h3>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">x,y &#x3D; y,x; &#x2F;&#x2F;不限制数量\na[i], a[j] &#x3D; a[j], a[i];\n&#x2F;&#x2F;额外的布尔类型表达某种错误类型\nv, ok &#x3D; m[key]             &#x2F;&#x2F; map lookup\nv, ok &#x3D; x.(T)              &#x2F;&#x2F; type assertion\nv, ok &#x3D; &lt;-ch               &#x2F;&#x2F; channel receive\n&#x2F;&#x2F;只做检查\nv &#x3D; m[key]                &#x2F;&#x2F; map查找，失败时返回零值\nv &#x3D; x.(T)                 &#x2F;&#x2F; type断言，失败时panic异常\nv &#x3D; &lt;-ch                  &#x2F;&#x2F; 管道接收，失败时返回零值（阻塞不算是失败）\n\n_, ok &#x3D; m[key]            &#x2F;&#x2F; map返回2个值\n_, ok &#x3D; mm[&quot;&quot;], false     &#x2F;&#x2F; map返回1个值\n_ &#x3D; mm[&quot;&quot;]                &#x2F;&#x2F; map返回1个值\n&#x2F;&#x2F;复合类型隐式赋值\nmedals :&#x3D; []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125;\n&#x2F;&#x2F;等价写法\nmedals[0] &#x3D; &quot;gold&quot;\nmedals[1] &#x3D; &quot;silver&quot;\nmedals[2] &#x3D; &quot;bronze&quot;</code></pre>\n<ul>\n<li>对于两个值是否可以用&#x3D;&#x3D;或!&#x3D;进行相等比较的能力也和可赋值能力有关系</li>\n</ul>\n<h2 id=\"2-5-类型\"><a href=\"#2-5-类型\" class=\"headerlink\" title=\"2.5 类型\"></a>2.5 类型</h2>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package tempconv\n\nimport &quot;fmt&quot;\n\ntype Celsius float64    &#x2F;&#x2F; 摄氏温度\ntype Fahrenheit float64 &#x2F;&#x2F; 华氏温度\n\nconst (\n    AbsoluteZeroC Celsius &#x3D; -273.15 &#x2F;&#x2F; 绝对零度\n    FreezingC     Celsius &#x3D; 0       &#x2F;&#x2F; 结冰点温度\n    BoilingC      Celsius &#x3D; 100     &#x2F;&#x2F; 沸水温度\n)\n\nfunc CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9&#x2F;5 + 32) &#125;\n\nfunc FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 &#x2F; 9) &#125;\n</code></pre>\n\n<ul>\n<li>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用</li>\n<li><code>Celsius</code>和<code>Fahrenheit</code>是两种不同类型,<code>Celsius(t)</code>或<code>Fahrenheit(t)</code>形式的显式转型,<code>整数</code>-&gt;<code>小数</code>回省略小数部分(CPP在这部分有很详细的讨论)</li>\n<li>如果两个值有着不同的类型，则不能直接进行比较</li>\n<li>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集后面详细讨论</li>\n</ul>\n<h2 id=\"2-6-包和文件\"><a href=\"#2-6-包和文件\" class=\"headerlink\" title=\"2.6 包和文件\"></a>2.6 包和文件</h2><ul>\n<li><p><code>名字空间</code>每个包都对应一个独立的名字空间,例如，在image包中的Decode函数和在unicode&#x2F;utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问</p>\n</li>\n<li><p><code>包的导入</code>Go语言的规范并没有定义这些源代码的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。</p>\n</li>\n<li><p><code>包的初始化</code>。包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的。例如<code>func init() &#123; /* ... */ &#125;</code>,<code>init</code>不能被调用，也不能被声明。包会按照声明的顺序初始化。</p>\n</li>\n<li><p><code>包的初始化顺序</code>。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了</p>\n<p>复杂初始化可以用以下方式</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;可以使用匿名函数处理\nvar pc [256]byte &#x3D; func() (pc [256]byte) &#123;\n  for i :&#x3D; range pc &#123;\n      pc[i] &#x3D; pc[i&#x2F;2] + byte(i&amp;1)\n  &#125;\n  return\n&#125;()\n</code></pre></li>\n</ul>\n<h2 id=\"2-7-作用域\"><a href=\"#2-7-作用域\" class=\"headerlink\" title=\"2.7. 作用域\"></a>2.7. 作用域</h2><ul>\n<li>不要将作用域和生命周期混为一谈，作用域是指文本域，而生命周期是指运行有效时段</li>\n<li>任何在<code>函数</code>外部（也就是包级语法域）声明的名字可以在同一个<code>包</code>的任何源文件中访问的</li>\n<li>对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包</li>\n<li>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是<br>函数级的作用域</li>\n</ul>\n<p>几种常见作用域例子</p>\n<ul>\n<li><p>正常情况下作用域例子</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func f() &#123;&#125;\n\nvar g &#x3D; &quot;g&quot;\n\nfunc main() &#123;\n    f :&#x3D; &quot;f&quot;\n    fmt.Println(f) &#x2F;&#x2F; &quot;f&quot;; local var f shadows package-level func f\n    fmt.Println(g) &#x2F;&#x2F; &quot;g&quot;; package-level var\n    fmt.Println(h) &#x2F;&#x2F; compile error: undefined: h\n&#125;</code></pre></li>\n<li><p>作用域嵌套,函数中可以进行词法域嵌套</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func main() &#123;\n  x :&#x3D; &quot;hello!&quot;\n  for i :&#x3D; 0; i &lt; len(x); i++ &#123;\n      x :&#x3D; x[i]\n      if x !&#x3D; &#39;!&#39; &#123;\n          x :&#x3D; x + &#39;A&#39; - &#39;a&#39;\n          fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;上述代码&#96;x[]&#96;和&#96;x + &#39;A&#39; - &#39;a&#39;&#96;都是引用了外部作用域声明的x变量。\n&#x2F;&#x2F;再比如下面的例子,有三个不同的x变量，</code></pre>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化\n&#x2F;&#x2F;词法域，一个在for循环体词法域；只有两个块是显式创建的：\nfunc main() &#123;\n  x :&#x3D; &quot;hello&quot;\n  for _, x :&#x3D; range x &#123;\n      x :&#x3D; x + &#39;A&#39; - &#39;a&#39;\n      fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)\n  &#125;\n&#125;</code></pre></li>\n<li><p>建隐式词法域,隐式作用域<br>  if和switch语句也会在条件部分创建隐式词法域，代码例子如下.第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if x :&#x3D; f(); x &#x3D;&#x3D; 0 &#123;\n  fmt.Println(x)\n&#125; else if y :&#x3D; g(x); x &#x3D;&#x3D; y &#123;\n    fmt.Println(x, y)\n&#125; else &#123;\n    fmt.Println(x, y)\n&#125;\nfmt.Println(x, y) &#x2F;&#x2F; compile error: x and y are not visible here</code></pre>\n<p>如果不想提前声明变量还可以选择如下方式，但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if f, err :&#x3D; os.Open(fname); err !&#x3D; nil &#123;\n  return err\n&#125; else &#123;\n    &#x2F;&#x2F; f and err are visible here too\n    f.ReadByte()\n    f.Close()\n&#125;</code></pre></li>\n<li><p>屏蔽其他作用域变暗亮<br>cwd在外部已经声明的包级变量，但是:&#x3D;语句还是将cwd和err重新声明为新的局部变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var cwd string\n\nfunc init() &#123;\n    cwd, err :&#x3D; os.Getwd() &#x2F;&#x2F; compile error: unused: cwd\n    if err !&#x3D; nil &#123;\n        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)\n    &#125;\n&#125;</code></pre>\n<p>可以用赋值运算符，就不会屏蔽<code>cwd</code>变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var cwd string\n\nfunc init() &#123;\n    var err error &#x2F;&#x2F;因为是赋值运算符所以需要定义error变量\n    cwd, err &#x3D; os.Getwd()\n    if err !&#x3D; nil &#123;\n        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)\n    &#125;\n&#125;</code></pre></li>\n</ul>\n<h1 id=\"3-基础数据类型\"><a href=\"#3-基础数据类型\" class=\"headerlink\" title=\"3.基础数据类型\"></a>3.基础数据类型</h1><ul>\n<li><p>整型格式控制符</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%b</td>\n<td>整型以二进制方式显示</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>整型以八进制方式显示</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>整型以十进制方式显示</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>整型以十六进制方式显示</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>整型以十六进制、字母大写方式显示</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>相应Unicode码点所表示的字符</td>\n</tr>\n<tr>\n<td>%U</td>\n<td>Unicode 字符, Unicode格式：123，等同于 “U+007B”</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>浮点数格式控制</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%e</td>\n<td>科学计数法,例如 -1234.456e+78</td>\n</tr>\n<tr>\n<td>%E</td>\n<td>科学计数法,例如 -1234.456E+78</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>有小数点而无指数,例如 123.456</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>\n</tr>\n<tr>\n<td>%G</td>\n<td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>字符串格式化</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%s</td>\n<td>字符串或切片的无解译字节</td>\n</tr>\n<tr>\n<td>%q</td>\n<td>双引号围绕的字符串，由Go语法安全地转义</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>十六进制，小写字母，每字节两个字符</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>十六进制，大写字母，每字节两个字符</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>指针格式化</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%p</td>\n<td>十六进制表示，前缀 0x</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>通用的占位符</p>\n<table>\n<thead>\n<tr>\n<th>格 式</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%v</td>\n<td>值的默认格式。</td>\n</tr>\n<tr>\n<td>%+v</td>\n<td>类似%v，但输出结构体时会添加字段名</td>\n</tr>\n<tr>\n<td>%#v</td>\n<td>相应值的Go语法表示</td>\n</tr>\n<tr>\n<td>%T</td>\n<td>相应值的类型的Go语法表示</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>百分号,字面上的%,非占位符含义</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>控制宽度<br>  宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐</p>\n<ul>\n<li><p>字符串控制</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">fmt.Printf(&quot;|%s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 不设置宽度\nfmt.Printf(&quot;|%5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度,  默认+， 右对齐\nfmt.Printf(&quot;|%-5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度, 左对齐\n\nfmt.Printf(&quot;|%05s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; |000aa|\n</code></pre>\n</li>\n<li><p>浮点控制</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">a :&#x3D; 54.123456\nfmt.Printf(&quot;|%f|&quot;, a)  &#x2F;&#x2F; |54.123456|\nfmt.Printf(&quot;|%5.1f|&quot;, a)  &#x2F;&#x2F; | 54.1|\nfmt.Printf(&quot;|%-5.1f|&quot;, a) &#x2F;&#x2F; |54.1 |\nfmt.Printf(&quot;|%05.1f|&quot;, a) &#x2F;&#x2F; |054.1|</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-1-整型\"><a href=\"#3-1-整型\" class=\"headerlink\" title=\"3.1 整型\"></a>3.1 整型</h2><ol>\n<li>因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节</li>\n<li>Unicode和rune类型是个<code>int32</code>等价的类型,通常用于表示一个Unicode码点</li>\n<li>同样byte也是<code>uint8</code>类型的等价类型</li>\n<li>还有一种无符号的整数类型<code>uintptr</code>，没有指定具体的bit大小但是足以容纳指针。<code>uintptr</code>类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方</li>\n<li><code>int</code>、<code>uint</code>和<code>uintptr</code>是不同类型的兄弟类型。其中<code>int</code>和<code>int32</code>也是不同的类型，即使<code>int</code>的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然</li>\n<li>位元素符号</li>\n<li><code>int32</code>和<code>int64</code>无法直接四则运算</li>\n<li><code>fmt.Printf(&quot;%d %[1]o %#[1]o\\n&quot;, o) // &quot;438 666 0666&quot;</code>中的<code>fmt</code>两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀</li>\n</ol>\n<h2 id=\"3-2-浮点数\"><a href=\"#3-2-浮点数\" class=\"headerlink\" title=\"3.2 浮点数\"></a>3.2 浮点数</h2><ol>\n<li>一个<code>float32</code>类型的浮点数可以提供大约<code>6</code>个十进制数的精度，而<code>float64</code>则可以提供约<code>15</code>个十进制数的精度；通常应该优先使用<code>float64</code>类型，因为<code>float32</code>类型的累计计算误差很容易扩散，并且<code>float32</code>能精确表示的正整数并不是很大</li>\n<li>浮点数字面量可以直接书写</li>\n<li>很大或者很小的数都可以用科学计数法来书写</li>\n<li><code>fmt.Printf(&quot;x = %d e^x = %8.3f\\n&quot;, x, math.Exp(float64(x)))</code>8.3是指三个小数精度，8个字符宽度,<code>%g %e %f</code>.</li>\n</ol>\n<h2 id=\"3-3-复数\"><a href=\"#3-3-复数\" class=\"headerlink\" title=\"3.3 复数\"></a>3.3 复数</h2><p>复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var x complex128 &#x3D; complex(1, 2) &#x2F;&#x2F; 1+2i\nvar y complex128 &#x3D; complex(3, 4) &#x2F;&#x2F; 3+4i\nfmt.Println(x*y)                 &#x2F;&#x2F; &quot;(-5+10i)&quot;\nfmt.Println(real(x*y))           &#x2F;&#x2F; &quot;-5&quot;\nfmt.Println(imag(x*y))           &#x2F;&#x2F; &quot;10&quot;\n</code></pre>\n\n<h2 id=\"3-4-布尔类型\"><a href=\"#3-4-布尔类型\" class=\"headerlink\" title=\"3.4 布尔类型\"></a>3.4 布尔类型</h2><p>布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">i :&#x3D; 0\nif b &#123;\n    i &#x3D; 1\n&#125;</code></pre>\n\n<h2 id=\"3-5-字符串\"><a href=\"#3-5-字符串\" class=\"headerlink\" title=\"3.5 字符串\"></a>3.5 字符串</h2><ul>\n<li><p>字符串可以用&#x3D;&#x3D;和&lt;进行比较；比较通过逐个字节比较完成的</p>\n</li>\n<li><p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故<code>s[0] = &#39;L&#39; // compile error: cannot assign to s[0]</code></p>\n<ul>\n<li>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中</li>\n<li>可在字符串面值中写<code>十六进制</code>和<code>八进制</code>数字进行码点转义</li>\n<li>原生字面值用反引号(&#96;)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.</li>\n<li>通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思</li>\n<li>UTF-8 [to be continue]</li>\n<li><code>bytes</code>、<code>strings</code>、<code>strconv</code>和<code>unicode</code>包,四个包对字符串处理尤为重要,<code>strings</code>包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能</li>\n<li>字符串和数字的转换,<code>strconv</code>包提供这类转换功能</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"4-复合数据类型\"><a href=\"#4-复合数据类型\" class=\"headerlink\" title=\"4. 复合数据类型\"></a>4. 复合数据类型</h1><h2 id=\"4-1-数组\"><a href=\"#4-1-数组\" class=\"headerlink\" title=\"4.1 数组\"></a>4.1 数组</h2><p>数组代码示例</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var a [3]int             &#x2F;&#x2F; array of 3 integers\nfmt.Println(a[0])        &#x2F;&#x2F; print the first element\nfmt.Println(a[len(a)-1]) &#x2F;&#x2F; print the last element, a[2]\n\n&#x2F;&#x2F; Print the indices and elements.\nfor i, v :&#x3D; range a &#123;\n    fmt.Printf(&quot;%d %d\\n&quot;, i, v)\n&#125;\n\n&#x2F;&#x2F; Print the elements only.\nfor _, v :&#x3D; range a &#123;\n    fmt.Printf(&quot;%d\\n&quot;, v)\n&#125;</code></pre>\n\n<p>如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">q :&#x3D; [...]int&#123;1, 2, 3&#125;\nfmt.Printf(&quot;%T\\n&quot;, q) &#x2F;&#x2F; &quot;[3]int&quot;</code></pre>\n<p>上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Currency int\n\nconst (\n    USD Currency &#x3D; iota &#x2F;&#x2F; 美元\n    EUR                 &#x2F;&#x2F; 欧元\n    GBP                 &#x2F;&#x2F; 英镑\n    RMB                 &#x2F;&#x2F; 人民币\n)\n\nsymbol :&#x3D; [...]string&#123;USD: &quot;$&quot;, EUR: &quot;€&quot;, GBP: &quot;￡&quot;, RMB: &quot;￥&quot;&#125;\n\nfmt.Println(RMB, symbol[RMB]) &#x2F;&#x2F; &quot;3 ￥&quot;</code></pre>\n<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">r :&#x3D; [...]int&#123;99: -1&#125;</code></pre>\n<p>数组进行比较是比较所有元素是否相等</p>\n<h2 id=\"4-2-slice\"><a href=\"#4-2-slice\" class=\"headerlink\" title=\"4.2 slice\"></a>4.2 slice</h2><p>创建slice变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">v_len :&#x3D; make([]T, len)\nv_len_cap :&#x3D; make([]T, len, cap) &#x2F;&#x2F; same as make([]T, cap)[:len]\ns :&#x3D; []int&#123;0, 1, 2, 3, 4, 5&#125;</code></pre>\n<p><code>slice</code>和<code>数组</code>典型的不同就是<code>slice</code>不指定长度<br><code>bytes.Equal</code>函数来判断两个字节型slice是否相等（[]byte)</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func equal(x, y []string) bool &#123;\n    if len(x) !&#x3D; len(y) &#123;\n        return false\n    &#125;\n    for i :&#x3D; range x &#123;\n        if x[i] !&#x3D; y[i] &#123;\n            return false\n        &#125;\n    &#125;\n    return true\n&#125;</code></pre>\n\n<p>slice的nil值</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var s []int    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; nil        &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; []int(nil) &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; []int&#123;&#125;    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s !&#x3D; nil</code></pre>\n\n<h3 id=\"4-2-1-append函数\"><a href=\"#4-2-1-append函数\" class=\"headerlink\" title=\"4.2.1 append函数\"></a>4.2.1 append函数</h3><p>(留着放些API东西)</p>\n<h2 id=\"4-3-Map\"><a href=\"#4-3-Map\" class=\"headerlink\" title=\"4.3 Map\"></a>4.3 Map</h2><p>其中K对应的key必须是支持&#x3D;&#x3D;比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在<br>创建map</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">ages :&#x3D; make(map[string]int) &#x2F;&#x2F; mapping from strings to ints\nages :&#x3D; map[string]int&#123;\n    &quot;alice&quot;:   31,\n    &quot;charlie&quot;: 34,\n&#125;\n&#x2F;&#x2F;访问map数据，也是put操作\nages[&quot;alice&quot;] &#x3D; 32\n&#x2F;&#x2F;删除元素\ndelete(ages, &quot;alice&quot;) &#x2F;&#x2F; remove element ages[&quot;alice&quot;]\n&#x2F;&#x2F;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：\n_ &#x3D; &amp;ages[&quot;bob&quot;] &#x2F;&#x2F; compile error: cannot take address of map element\n</code></pre>\n<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">import &quot;sort&quot;\n\nvar names []string\nfor name :&#x3D; range ages &#123;\n    names &#x3D; append(names, name)\n&#125;\nsort.Strings(names)\nfor _, name :&#x3D; range names &#123;\n    fmt.Printf(&quot;%s\\t%d\\n&quot;, name, ages[name])\n&#125;</code></pre>\n\n<p>map返回两个值，第一个值是bool类型,false则说明不存在这个key。<br>map的key要求必须是可比较类型，那么如果想用slice作为key就需要写小改动</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var m &#x3D; make(map[string]int)\n\nfunc k(list []string) string &#123; return fmt.Sprintf(&quot;%q&quot;, list) &#125;\n\nfunc Add(list []string)       &#123; m[k(list)]++ &#125;\nfunc Count(list []string) int &#123; return m[k(list)] &#125;</code></pre>\n\n<h2 id=\"4-4-结构体\"><a href=\"#4-4-结构体\" class=\"headerlink\" title=\"4.4 结构体\"></a>4.4 结构体</h2><pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">seen :&#x3D; make(map[string]struct&#123;&#125;) &#x2F;&#x2F; set of strings\n&#x2F;&#x2F; ...\nif _, ok :&#x3D; seen[s]; !ok &#123;\n    seen[s] &#x3D; struct&#123;&#125;&#123;&#125;\n    &#x2F;&#x2F; ...first time seeing s...\n&#125;</code></pre>\n\n<h3 id=\"4-4-1-结构体字面值\"><a href=\"#4-4-1-结构体字面值\" class=\"headerlink\" title=\"4.4.1 结构体字面值\"></a>4.4.1 结构体字面值</h3><pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Point struct&#123; X, Y int &#125;\n&#x2F;&#x2F;第一种类型初始化方式\np :&#x3D; Point&#123;1, 2&#125;\n&#x2F;&#x2F;第二种初始化方式,如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要\np :&#x3D;Point&#123;x:1,y:2&#125;</code></pre>\n\n<p>非导出结构体或者字段，不能在其他包中进行赋值</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package p\ntype T struct&#123; a, b int &#125; &#x2F;&#x2F; a and b are not exported\n\npackage q\nimport &quot;p&quot;\nvar _ &#x3D; p.T&#123;a: 1, b: 2&#125; &#x2F;&#x2F; compile error: can&#39;t reference a, b\nvar _ &#x3D; p.T&#123;1, 2&#125;       &#x2F;&#x2F; compile error: can&#39;t reference a, b</code></pre>\n\n<p>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nfunc Bonus(e *Employee, percent int) int &#123;\n    return e.Salary * percent &#x2F; 100\n&#125;</code></pre>\n\n<p>可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">pp :&#x3D; &amp;Point&#123;1, 2&#125;</code></pre>\n\n<p>它和下面的语句是等价的</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">pp :&#x3D; new(Point)\n*pp &#x3D; Point&#123;1, 2&#125;</code></pre>\n\n<h3 id=\"4-4-2-结构体的比较\"><a href=\"#4-4-2-结构体的比较\" class=\"headerlink\" title=\"4.4.2 结构体的比较\"></a>4.4.2 结构体的比较</h3><p>首先结构体是可比较类型</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\ntype Point struct&#123; X, Y int &#125;\n\np :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;2, 1&#125;\nfmt.Println(p.X &#x3D;&#x3D; q.X &amp;&amp; p.Y &#x3D;&#x3D; q.Y) &#x2F;&#x2F; &quot;false&quot;\nfmt.Println(p &#x3D;&#x3D; q)                   &#x2F;&#x2F; &quot;false&quot;\n</code></pre>\n\n<h3 id=\"4-4-3-结构体嵌入和匿名成员\"><a href=\"#4-4-3-结构体嵌入和匿名成员\" class=\"headerlink\" title=\"4.4.3 结构体嵌入和匿名成员\"></a>4.4.3 结构体嵌入和匿名成员</h3><pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\ntype Point struct &#123;\n    X, Y int\n&#125;\n\ntype Circle struct &#123;\n    Center Point\n    Radius int\n&#125;\n\ntype Wheel struct &#123;\n    Circle Circle\n    Spokes int\n&#125;\n\nvar w Wheel\nw.Circle.Center.X &#x3D; 8\nw.Circle.Center.Y &#x3D; 8\nw.Circle.Radius &#x3D; 5\nw.Spokes &#x3D; 20</code></pre>\n\n<p>匿名成员，说白了就是只写类型不写名字.</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Circle struct &#123;\n    Point\n    Radius int\n&#125;\n\ntype Wheel struct &#123;\n    Circle\n    Spokes int\n&#125;\n\nvar w Wheel\nw.X &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.X &#x3D; 8\nw.Y &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.Y &#x3D; 8\nw.Radius &#x3D; 5       &#x2F;&#x2F; equivalent to w.Circle.Radius &#x3D; 5\nw.Spokes &#x3D; 20\n&#x2F;&#x2F;以下初始化是错误的\nw &#x3D; Wheel&#123;8, 8, 5, 20&#125;                       &#x2F;&#x2F; compile error: unknown fields\nw &#x3D; Wheel&#123;X: 8, Y: 8, Radius: 5, Spokes: 20&#125; &#x2F;&#x2F; compile error: unknown fields</code></pre>\n\n<p>所以我们只能用下面两种方式进行初始化</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nw &#x3D; Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;\n\nw &#x3D; Wheel&#123;\n    Circle: Circle&#123;\n        Point:  Point&#123;X: 8, Y: 8&#125;,\n        Radius: 5,\n    &#125;,\n    Spokes: 20, &#x2F;&#x2F; NOTE: trailing comma necessary here (and at Radius)\n&#125;\n\nfmt.Printf(&quot;%#v\\n&quot;, w)\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;\n\nw.X &#x3D; 42\n\nfmt.Printf(&quot;%#v\\n&quot;, w)\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;\n</code></pre>\n<p>需要注意，但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</p>\n<h2 id=\"4-5-json字符串\"><a href=\"#4-5-json字符串\" class=\"headerlink\" title=\"4.5 json字符串\"></a>4.5 json字符串</h2><p><code>json.Marshal</code>包<br>代码例子</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Movie struct &#123;\n    Title  string\n    Year   int  &#96;json:&quot;released&quot;&#96; &#x2F;&#x2F; 这个tag指定生成json名字\n    Color  bool &#96;json:&quot;color,omitempty&quot;&#96;\n    Actors []string\n&#125;\n\nvar movies &#x3D; []Movie&#123;\n    &#123;Title: &quot;Casablanca&quot;, Year: 1942, Color: false,\n        Actors: []string&#123;&quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot;&#125;&#125;,\n    &#123;Title: &quot;Cool Hand Luke&quot;, Year: 1967, Color: true,\n        Actors: []string&#123;&quot;Paul Newman&quot;&#125;&#125;,\n    &#123;Title: &quot;Bullitt&quot;, Year: 1968, Color: true,\n        Actors: []string&#123;&quot;Steve McQueen&quot;, &quot;Jacqueline Bisset&quot;&#125;&#125;,\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<h2 id=\"4-6-文本和HTML模板\"><a href=\"#4-6-文本和HTML模板\" class=\"headerlink\" title=\"4.6 文本和HTML模板\"></a>4.6 文本和HTML模板</h2><p>(后面需要时候着重的看)<br><code>text/template和html/template</code>,们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。模板语言支持流程控制语句<br>模板语言demo</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">const templ &#x3D; &#96;&#123;&#123;.TotalCount&#125;&#125; issues:\n&#123;&#123;range .Items&#125;&#125;----------------------------------------\nNumber: &#123;&#123;.Number&#125;&#125;\nUser:   &#123;&#123;.User.Login&#125;&#125;\nTitle:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;\nAge:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days\n&#123;&#123;end&#125;&#125;&#96;</code></pre>\n\n<p><code>|</code> 操作符表示将前一个表达式的结果作为后一个函数的输入.<br>生成模板的输出需要两个处理步骤</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var report &#x3D; template.Must(template.New(&quot;issuelist&quot;).\n    Funcs(template.FuncMap&#123;&quot;daysAgo&quot;: daysAgo&#125;).\n    Parse(templ))\n\nfunc main() &#123;\n    result, err :&#x3D; github.SearchIssues(os.Args[1:])\n    if err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n    if err :&#x3D; report.Execute(os.Stdout, result); err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n&#125;</code></pre>\n<p>如果想转化为html则需要编写如下代码</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nimport &quot;html&#x2F;template&quot;\n\nvar issueList &#x3D; template.Must(template.New(&quot;issuelist&quot;).Parse(&#96;\n&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;&#x2F;h1&gt;\n&lt;table&gt;\n&lt;tr style&#x3D;&#39;text-align: left&#39;&gt;\n  &lt;th&gt;#&lt;&#x2F;th&gt;\n  &lt;th&gt;State&lt;&#x2F;th&gt;\n  &lt;th&gt;User&lt;&#x2F;th&gt;\n  &lt;th&gt;Title&lt;&#x2F;th&gt;\n&lt;&#x2F;tr&gt;\n&#123;&#123;range .Items&#125;&#125;\n&lt;tr&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Number&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;&#x2F;td&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.User.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Title&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n&#123;&#123;end&#125;&#125;\n&lt;&#x2F;table&gt;\n&#96;))</code></pre>\n<p>注意，html&#x2F;template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text&#x2F;template包的话，这2个issue将会产生错误，其中“&lt;”四个字符将会被当作小于字符“&lt;”处理，同时“<link>”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。</p>\n<h1 id=\"5-函数\"><a href=\"#5-函数\" class=\"headerlink\" title=\"5. 函数\"></a>5. 函数</h1><p>声明和定义</p>\n<ul>\n<li><p>switch 控制语句</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">switch cond&#123;\n  case a :\n      fmt.Printf()\n  case b :\n      fmt.Printf()\n  case c :\n      fmt.Printf()\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"5-1-错误\"><a href=\"#5-1-错误\" class=\"headerlink\" title=\"5.1 错误\"></a>5.1 错误</h2><p>通常，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</p>\n<p>我们有几种处理错误的策略</p>\n<ol>\n<li>发生错误时的解析器</li>\n</ol>\n<p>  发生解析错误后,findLinks 函数构造了一个新的异常信息,既包含了自定义的，也包含了底层解析出错的信息</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">doc, err :&#x3D; html.Parse(resp.Body)\nresp.Body.Close()\nif err !&#x3D; nil &#123;\n    return nil, fmt.Errorf(&quot;parsing %s as HTML: %v&quot;, url,err)\n&#125;</code></pre>\n\n<p>  参考宇航局事故调查<br>2. 重试<br>  我们需要限制重试的时间间隔或重试的次数，防止无限制的重试.<br>3. 输出错误信息并结束程序<br>  输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行,对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序<br>  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;\n  log.Fatalf(&quot;Site is down: %v\\n&quot;, err)\n&#125;</code></pre><br>  <code>log.Fatalf</code>代码更简洁，并输出自定义格式信息</p>\n<ol start=\"4\">\n<li>只是输出错误信息就可以</li>\n</ol>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if err :&#x3D; Ping(); err !&#x3D; nil &#123;\n  log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)\n&#125;\n&#x2F;&#x2F;或者标准错误流输出错误信息。\n\nif err :&#x3D; Ping(); err !&#x3D; nil &#123;\n    fmt.Fprintf(os.Stderr, &quot;ping failed: %v; networking disabled\\n&quot;, err)\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li>直接忽略掉错误</li>\n</ol>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">dir, err :&#x3D; ioutil.TempDir(&quot;&quot;, &quot;scratch&quot;)\nif err !&#x3D; nil &#123;\n    return fmt.Errorf(&quot;failed to create temp dir: %v&quot;,err)\n&#125;\n&#x2F;&#x2F; ...use temp dir…\nos.RemoveAll(dir) &#x2F;&#x2F; ignore errors; $TMPDIR is cleaned periodically</code></pre>\n<p>  尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响</p>\n<ol start=\"6\">\n<li>文件结尾错误</li>\n</ol>\n<p>io包保证任何由文件结束引起的读取失败都返</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package io\n\nimport &quot;errors&quot;\n\n&#x2F;&#x2F; EOF is the error returned by Read when no more input is available.\nvar EOF &#x3D; errors.New(&quot;EOF&quot;)\n\nin :&#x3D; bufio.NewReader(os.Stdin)\nfor &#123;\n    r, _, err :&#x3D; in.ReadRune()\n    if err &#x3D;&#x3D; io.EOF &#123;\n        break &#x2F;&#x2F; finished reading\n    &#125;\n    if err !&#x3D; nil &#123;\n        return fmt.Errorf(&quot;read failed:%v&quot;, err)\n    &#125;\n    &#x2F;&#x2F; ...use r…\n&#125;</code></pre>\n\n<h2 id=\"5-2-函数值\"><a href=\"#5-2-函数值\" class=\"headerlink\" title=\"5.2 函数值\"></a>5.2 函数值</h2><ul>\n<li><p>函数在golang中也是一种类型，可以被复制给其他变量。  </p>\n</li>\n<li><p>很熟类型的<code>零</code>值是<code>nil</code>,调用值为nil会引起<code>panic</code>错误  </p>\n</li>\n<li><p>函数值之间是不可以比较的,也不能用函数值作为map的key</p>\n</li>\n<li><p>strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func add1(r rune) rune &#123; return r + 1 &#125;\n\nfmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) &#x2F;&#x2F; &quot;IBM.:111&quot;\nfmt.Println(strings.Map(add1, &quot;VMS&quot;))      &#x2F;&#x2F; &quot;WNT&quot;\nfmt.Println(strings.Map(add1, &quot;Admix&quot;))    &#x2F;&#x2F; &quot;Benjy&quot;</code></pre></li>\n</ul>\n<p>demo示例</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;值得学习\n&#x2F;&#x2F; forEachNode针对每个结点x，都会调用pre(x)和post(x)。\n&#x2F;&#x2F; pre和post都是可选的。\n&#x2F;&#x2F; 遍历孩子结点之前，pre被调用\n&#x2F;&#x2F; 遍历孩子结点之后，post被调用\nfunc forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123;\n    if pre !&#x3D; nil &#123;\n        pre(n)\n    &#125;\n    for c :&#x3D; n.FirstChild; c !&#x3D; nil; c &#x3D; c.NextSibling &#123;\n        forEachNode(c, pre, post)\n    &#125;\n    if post !&#x3D; nil &#123;\n        post(n)\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"5-3-匿名函数\"><a href=\"#5-3-匿名函数\" class=\"headerlink\" title=\"5.3 匿名函数\"></a>5.3 匿名函数</h2><p>函数内部定义的函数可以访问整个词法环境，言外之意就是嵌套的函数可以访问外层函数的变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; squares返回一个匿名函数。\n&#x2F;&#x2F; 该匿名函数每次被调用时都会返回下一个数的平方。\n&#x2F;&#x2F;squares 函数每次都返回一个函数类型-func()int&#123;&#125;\nfunc squares() func() int &#123;\n    var x int\n    return func() int &#123; &#x2F;&#x2F; 匿名函数\n        x++\n        return x * x\n    &#125;\n&#125;\nfunc main() &#123;\n    f :&#x3D; squares()\n    fmt.Println(f()) &#x2F;&#x2F; &quot;1&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;4&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;9&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;16&quot;\n&#125;\n&#x2F;&#x2F;通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</code></pre>\n\n<blockquote>\n<p>网页抓取的核心问题就是如何遍历图</p>\n</blockquote>\n<p>警告:捕获迭代变量</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var rmdirs []func()\nfor _, d :&#x3D; range tempDirs() &#123;\n    dir :&#x3D; d &#x2F;&#x2F; NOTE: necessary!\n    os.MkdirAll(dir, 0755) &#x2F;&#x2F; creates parent directories too\n    rmdirs &#x3D; append(rmdirs, func() &#123;\n        os.RemoveAll(dir)\n    &#125;)\n&#125;\n&#x2F;&#x2F; ...do some work…\nfor _, rmdir :&#x3D; range rmdirs &#123;\n    rmdir() &#x2F;&#x2F; clean up\n&#125;\n&#x2F;&#x2F; \nvar rmdirs []func()\nfor _, dir :&#x3D; range tempDirs() &#123;\n    os.MkdirAll(dir, 0755)\n    rmdirs &#x3D; append(rmdirs, func() &#123;\n        os.RemoveAll(dir) &#x2F;&#x2F; NOTE: incorrect!\n    &#125;)\n&#125;\n</code></pre>\n<p>问题出在了循环变量的作用域,循环变量dir在这个词法块中被声明，每一次迭代都是会不断地更新这个值，被<code>range</code>语句，解决这个问题的办法就是引入同名变量来覆盖其作用域。</p>\n<h2 id=\"5-4-可变参数\"><a href=\"#5-4-可变参数\" class=\"headerlink\" title=\"5.4 可变参数\"></a>5.4 可变参数</h2><p>简单的可变参数例子,其实<code>可变参数</code>就是个切片的值传递,<code>interface&#123;&#125;</code>表示函数的最后一个参数可以接收任意类型</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func sum(vals ...int) int &#123;\n    total :&#x3D; 0\n    for _, val :&#x3D; range vals &#123;\n        total +&#x3D; val\n    &#125;\n    return total\n&#125;</code></pre>\n<p>如果原参数就是切片该怎么传递？可以直接在<code>实参</code>后面加省略号</p>\n<h2 id=\"5-5-defer函数\"><a href=\"#5-5-defer函数\" class=\"headerlink\" title=\"5.5 defer函数\"></a>5.5 defer函数</h2><p>在函数执行完成之后，不管是正常退出还是异常退出函数，最后都会被执行</p>\n<h2 id=\"5-6-panic异常\"><a href=\"#5-6-panic异常\" class=\"headerlink\" title=\"5.6 panic异常\"></a>5.6 panic异常</h2><p>当panic发生时会在该goroutine上执行defer函数，打印对应的栈信息<br><code>regexp</code>包的使用<br>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func main() &#123;\n    defer printStack()\n    f(3)\n&#125;\nfunc printStack() &#123;\n    var buf [4096]byte\n    n :&#x3D; runtime.Stack(buf[:], false)\n    os.Stdout.Write(buf[:n])\n&#125;\n</code></pre>\n<p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p>\n<h2 id=\"5-7-Recovery捕获异常\"><a href=\"#5-7-Recovery捕获异常\" class=\"headerlink\" title=\"5.7 Recovery捕获异常\"></a>5.7 Recovery捕获异常</h2><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所</p>\n<ul>\n<li>语言解析器为例<br>说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误</li>\n</ul>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func Parse(input string) (s *Syntax, err error) &#123;\n    defer func() &#123;\n        if p :&#x3D; recover(); p !&#x3D; nil &#123;\n            err &#x3D; fmt.Errorf(&quot;internal error: %v&quot;, p)\n        &#125;\n    &#125;()\n    &#x2F;&#x2F; ...parser...\n&#125;</code></pre>\n\n\n<ul>\n<li>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。  </li>\n<li>有时我们很难完全遵循规范，举个例子，net&#x2F;http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</li>\n</ul>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; soleTitle returns the text of the first non-empty title element\n&#x2F;&#x2F; in doc, and an error if there was not exactly one.\n&#x2F;&#x2F;防御性panic代码\nfunc soleTitle(doc *html.Node) (title string, err error) &#123;\n    type bailout struct&#123;&#125;\n    defer func() &#123;\n        switch p :&#x3D; recover(); p &#123;\n        case nil:       &#x2F;&#x2F; no panic\n        case bailout&#123;&#125;: &#x2F;&#x2F; &quot;expected&quot; panic\n            err &#x3D; fmt.Errorf(&quot;multiple title elements&quot;)\n        default:\n            panic(p) &#x2F;&#x2F; unexpected panic; carry on panicking\n        &#125;\n    &#125;()\n    &#x2F;&#x2F; Bail out of recursion if we find more than one nonempty title.\n    forEachNode(doc, func(n *html.Node) &#123;\n        if n.Type &#x3D;&#x3D; html.ElementNode &amp;&amp; n.Data &#x3D;&#x3D; &quot;title&quot; &amp;&amp;\n            n.FirstChild !&#x3D; nil &#123;\n            if title !&#x3D; &quot;&quot; &#123;\n                panic(bailout&#123;&#125;) &#x2F;&#x2F; multiple titleelements\n            &#125;\n            title &#x3D; n.FirstChild.Data\n        &#125;\n    &#125;, nil)\n    if title &#x3D;&#x3D; &quot;&quot; &#123;\n        return &quot;&quot;, fmt.Errorf(&quot;no title element&quot;)\n    &#125;\n    return title, nil\n&#125;</code></pre>\n\n<h1 id=\"6-方法\"><a href=\"#6-方法\" class=\"headerlink\" title=\"6. 方法\"></a>6. 方法</h1><h2 id=\"6-1-方法声明\"><a href=\"#6-1-方法声明\" class=\"headerlink\" title=\"6.1 方法声明\"></a>6.1 方法声明</h2><ul>\n<li>普通函数与接收器方法<br><code>接收器</code>因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。对于一个给定的类型，其内部的方法都必须有唯一的方法名</li>\n</ul>\n<h2 id=\"6-2-基于指针对象的方法\"><a href=\"#6-2-基于指针对象的方法\" class=\"headerlink\" title=\"6.2 基于指针对象的方法\"></a>6.2 基于指针对象的方法</h2><ul>\n<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。</li>\n<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。</li>\n<li>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们下面例子里做的这样  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func (list *IntList) Sum() int &#123;\nif list &#x3D;&#x3D; nil &#123;\n    return 0\n&#125;\nreturn list.Value + list.Tail.Sum()\n&#125;</code></pre>\n  如果此时结构体是<code>nil</code>调用对象可能会发生类似于空指针异常的错误</li>\n</ul>\n<h2 id=\"6-3-通过嵌入结构体来扩展类型\"><a href=\"#6-3-通过嵌入结构体来扩展类型\" class=\"headerlink\" title=\"6.3. 通过嵌入结构体来扩展类型\"></a>6.3. 通过嵌入结构体来扩展类型</h2><ul>\n<li><p>方法值<br>  在go语言中，方法是第一公民，这一点在函数式编程中非常实用(maybe)</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;方法值demo\np :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;4, 6&#125;\n\ndistanceFromP :&#x3D; p.Distance        &#x2F;&#x2F; method value,Distance是结构体方法\nfmt.Println(distanceFromP(q))      &#x2F;&#x2F; &quot;5&quot;\nvar origin Point                   &#x2F;&#x2F; &#123;0, 0&#125;\nfmt.Println(distanceFromP(origin)) &#x2F;&#x2F; &quot;2.23606797749979&quot;, sqrt(5)\n\nscaleP :&#x3D; p.ScaleBy &#x2F;&#x2F; method value\nscaleP(2)           &#x2F;&#x2F; p becomes (2, 4)\nscaleP(3)           &#x2F;&#x2F;      then (6, 12)\nscaleP(10)          &#x2F;&#x2F;      then (60, 120)</code></pre>\n</li>\n<li><p>方法表达式<br>  在面向对象中，当根据哪一个变量来决定调用哪个函数时候,方法表达式就很有用了.</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">p :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;4, 6&#125;\n\ndistance :&#x3D; Point.Distance   &#x2F;&#x2F; method expression\nfmt.Println(distance(p, q))  &#x2F;&#x2F; &quot;5&quot;\nfmt.Printf(&quot;%T\\n&quot;, distance) &#x2F;&#x2F; &quot;func(Point, Point) float64&quot;\n\nscale :&#x3D; (*Point).ScaleBy\nscale(&amp;p, 2)\nfmt.Println(p)            &#x2F;&#x2F; &quot;&#123;2 4&#125;&quot;\nfmt.Printf(&quot;%T\\n&quot;, scale) &#x2F;&#x2F; &quot;func(*Point, float64)&quot;\n</code></pre></li>\n</ul>\n<p>practice demo</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type Point struct&#123; X, Y float64 &#125;\n\nfunc (p Point) Add(q Point) Point &#123; return Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;\nfunc (p Point) Sub(q Point) Point &#123; return Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;\n\ntype Path []Point\n\nfunc (path Path) TranslateBy(offset Point, add bool) &#123;\n    var op func(p, q Point) Point\n    if add &#123;\n        op &#x3D; Point.Add\n    &#125; else &#123;\n        op &#x3D; Point.Sub\n    &#125;\n    for i :&#x3D; range path &#123;\n        &#x2F;&#x2F; Call either path[i].Add(offset) or path[i].Sub(offset).\n        path[i] &#x3D; op(path[i], offset)\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"6-4-封装\"><a href=\"#6-4-封装\" class=\"headerlink\" title=\"6.4 封装\"></a>6.4 封装</h2><p>封装提供了三方面的优点。</p>\n<ol>\n<li><p>首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可.</p>\n</li>\n<li><p>第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由</p>\n</li>\n<li><p>bytes.Buffer这个类型作为例子来考虑</p>\n <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\ntype Buffer struct &#123;\nbuf     []byte\ninitial [64]byte\n&#x2F;* ... *&#x2F;\n&#125;\n\n&#x2F;&#x2F; Grow expands the buffer&#39;s capacity, if necessary,\n&#x2F;&#x2F; to guarantee space for another n bytes. [...]\nfunc (b *Buffer) Grow(n int) &#123;\n    if b.buf &#x3D;&#x3D; nil &#123;\n        b.buf &#x3D; b.initial[:0] &#x2F;&#x2F; use preallocated space initially\n    &#125;\n    if len(b.buf)+n &gt; cap(b.buf) &#123;\n        buf :&#x3D; make([]byte, b.Len(), 2*cap(b.buf) + n)\n        copy(buf, b.buf)\n        b.buf &#x3D; buf\n    &#125;\n&#125;\n&#x2F;&#x2F; Grow()函数式导出类型，但是stuct的字段不是到处类型</code></pre>\n</li>\n<li><p>只暴漏关键信息给外部使用者</p>\n</li>\n</ol>\n<h1 id=\"7-接口\"><a href=\"#7-接口\" class=\"headerlink\" title=\"7. 接口\"></a>7. 接口</h1><p>很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用  </p>\n<p>只要一个物体能像鸭子一样叫那我们就可以称它为鸭子；只要一个软件能存储和查询数据我们就可以称它为数据库；只要一台机器有洗衣服和甩干的功能我们就可以称它为洗衣机。  </p>\n<p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型</p>\n<h2 id=\"7-1-接口约定\"><a href=\"#7-1-接口约定\" class=\"headerlink\" title=\"7.1. 接口约定\"></a>7.1. 接口约定</h2><p>例如<code>fmt</code>包</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package fmt\n\nfunc Fprintf(w io.Writer, format string, args ...interface&#123;&#125;) (int, error)\n&#x2F;&#x2F;Printf 最后调用Fprintf 函数\nfunc Printf(format string, args ...interface&#123;&#125;) (int, error) &#123;\n    return Fprintf(os.Stdout, format, args...)\n&#125;\n&#x2F;&#x2F; Sprintf函数最后也是调用Fprintf\nfunc Sprintf(format string, args ...interface&#123;&#125;) string &#123;\n    var buf bytes.Buffer\n    Fprintf(&amp;buf, format, args...)\n    return buf.String()\n&#125;</code></pre>\n\n<p><code>Fprintf</code>函数的<code>F</code>说明了文件类型也说明了所有信息要被写入到文件当中，在<code>Printf</code>函数中的第一个参数<code>os.Stdout</code>是<code>*os.File</code>类型实现了<code>io.Writer</code>接口，在<code>Sprintf</code>函数中的第一个参数<code>&amp;buf</code>是一个指向可以写入字节的内存缓冲区也该类型也是实现了<code>io.Writer</code>接口,用户可以自定义一个函数并实现<code>io.Writer</code>接口。<br><strong>LSP里氏替换</strong> : <code>fmt.Fprintf</code>通过使用接口类型<code>io.Writer</code>使得只要调用者只要传入实现了该接口的类型就可以实现自由替换</p>\n<details><summary>自定义bytecounter函数，实现计算int转byte长度</summary>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage main\n\nimport (\n\t&quot;fmt&quot;\n)\n\n&#x2F;&#x2F;!+bytecounter\n\ntype ByteCounter int\n\nfunc (c *ByteCounter) Write(p []byte) (int, error) &#123;\n\t*c +&#x3D; ByteCounter(len(p)) &#x2F;&#x2F; convert int to ByteCounter\n\treturn len(p), nil\n&#125;\n\n&#x2F;&#x2F;!-bytecounter\n\nfunc main() &#123;\n\t&#x2F;&#x2F;!+main\n\tvar c ByteCounter\n\tc.Write([]byte(&quot;hello&quot;))\n\tfmt.Println(c) &#x2F;&#x2F; &quot;5&quot;, &#x3D; len(&quot;hello&quot;)\n\n\tc &#x3D; 0 &#x2F;&#x2F; reset the counter\n\tvar name &#x3D; &quot;Dolly&quot;\n\tfmt.Fprintf(&amp;c, &quot;hello, %s&quot;, name)\n\tfmt.Println(c) &#x2F;&#x2F; &quot;12&quot;, &#x3D; len(&quot;hello, Dolly&quot;)\n\t&#x2F;&#x2F;!-main\n&#125;</code></pre>\n\n</details>\n\n<p>因为它实现了<code>writer</code>接口就可以传入到<code>Fprintf</code>函数中.总结来说，接口约定了包使用者的行为，但是使用者想创建什么样的实例需要他自己去实现。</p>\n<h2 id=\"7-2-接口类型\"><a href=\"#7-2-接口类型\" class=\"headerlink\" title=\"7.2 接口类型\"></a>7.2 接口类型</h2><p>通过组合定义接口</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package io\ntype Reader interface &#123;\n    Read(p []byte) (n int, err error)\n&#125;\ntype Closer interface &#123;\n    Close() error\n&#125;\n\ntype ReadWriter interface &#123;\n    Reader\n    Writer\n&#125;\ntype ReadWriteCloser interface &#123;\n    Reader\n    Writer\n    Closer\n&#125;\n&#x2F;&#x2F; 另一种命名风格\ntype ReadWriter interface &#123;\n    Read(p []byte) (n int, err error)\n    Write(p []byte) (n int, err error)\n&#125;\n&#x2F;&#x2F;或者甚至使用一种混合的风格：\n\ntype ReadWriter interface &#123;\n    Read(p []byte) (n int, err error)\n    Writer\n&#125;</code></pre>\n\n<h2 id=\"7-3-实现接口的条件\"><a href=\"#7-3-实现接口的条件\" class=\"headerlink\" title=\"7.3 实现接口的条件\"></a>7.3 实现接口的条件</h2><ul>\n<li><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口.</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var w io.Writer\n&#x2F;&#x2F;只实现了Write 方法\nw &#x3D; os.Stdout           &#x2F;&#x2F; OK: *os.File has Write method\n&#x2F;&#x2F;只实现了Write方法\nw &#x3D; new(bytes.Buffer)   &#x2F;&#x2F; OK: *bytes.Buffer has Write method\n&#x2F;&#x2F; time.Duration没有Write方法\nw &#x3D; time.Second         &#x2F;&#x2F; compile error: time.Duration lacks Write method\n\nvar rwc io.ReadWriteCloser\nrwc &#x3D; os.Stdout         &#x2F;&#x2F; OK: *os.File has Read, Write, Close methods\nrwc &#x3D; new(bytes.Buffer) &#x2F;&#x2F; compile error: *bytes.Buffer lacks Close method\n&#x2F;&#x2F; 这个规则甚至适用于等式右边本身也是一个接口类型\n&#x2F;&#x2F; rwc io.ReadWriteCloser\nw &#x3D; rwc                 &#x2F;&#x2F; OK: io.ReadWriteCloser has Write method\n&#x2F;&#x2F; w 只有Write方法\nrwc &#x3D; w                 &#x2F;&#x2F; compile error: io.Writer lacks Close method</code></pre>\n</li>\n<li></li>\n</ul>\n<h2 id=\"7-4-flag-Value接口\"><a href=\"#7-4-flag-Value接口\" class=\"headerlink\" title=\"7.4 flag.Value接口\"></a>7.4 flag.Value接口</h2><p>(翻译的太差劲，要去读原文)</p>\n<ul>\n<li><p>简单的<code>flag</code>包支持命令行的例子</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var period &#x3D; flag.Duration(&quot;period&quot;, 1*time.Second, &quot;sleep period&quot;)\n\nfunc main() &#123;\n    flag.Parse()\n    fmt.Printf(&quot;Sleeping for %v...&quot;, *period)\n    time.Sleep(*period)\n    fmt.Println()\n&#125;</code></pre>\n</li>\n<li><p>自定义新的标记符号</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package tempconv\n\nimport (\n    &quot;flag&quot;\n    &quot;fmt&quot;\n)\n\ntype Celsius float64\ntype Fahrenheit float64\n\nfunc CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9.0&#x2F;5.0 + 32.0) &#125;\nfunc FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32.0) * 5.0 &#x2F; 9.0) &#125;\n\nfunc (c Celsius) String() string &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125;\n\n&#x2F;*\n&#x2F;&#x2F;!+flagvalue\npackage flag\n\n&#x2F;&#x2F; Value is the interface to the value stored in a flag.\ntype Value interface &#123;\n    String() string\n    Set(string) error\n&#125;\n&#x2F;&#x2F;!-flagvalue\n*&#x2F;\n\n&#x2F;&#x2F;!+celsiusFlag\n&#x2F;&#x2F; *celsiusFlag satisfies the flag.Value interface.\ntype celsiusFlag struct&#123; Celsius &#125;\n\nfunc (f *celsiusFlag) Set(s string) error &#123;\n    var unit string\n    var value float64\n    fmt.Sscanf(s, &quot;%f%s&quot;, &amp;value, &amp;unit) &#x2F;&#x2F; no error check needed\n    switch unit &#123;\n    case &quot;C&quot;, &quot;°C&quot;:\n        f.Celsius &#x3D; Celsius(value)\n        return nil\n    case &quot;F&quot;, &quot;°F&quot;:\n        f.Celsius &#x3D; FToC(Fahrenheit(value))\n        return nil\n    &#125;\n    return fmt.Errorf(&quot;invalid temperature %q&quot;, s)\n&#125;\n\n&#x2F;&#x2F;!-celsiusFlag\n\n&#x2F;&#x2F;!+CelsiusFlag\n\n&#x2F;&#x2F; CelsiusFlag defines a Celsius flag with the specified name,\n&#x2F;&#x2F; default value, and usage, and returns the address of the flag variable.\n&#x2F;&#x2F; The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.\nfunc CelsiusFlag(name string, value Celsius, usage string) *Celsius &#123;\n    f :&#x3D; celsiusFlag&#123;value&#125;\n    flag.CommandLine.Var(&amp;f, name, usage)\n    return &amp;f.Celsius\n&#125;\n&#x2F;&#x2F; main函数\nvar temp &#x3D; tempconv.CelsiusFlag(&quot;temp&quot;, 20.0, &quot;the temperature&quot;)\n\nfunc main() &#123;\n    flag.Parse()\n    fmt.Println(*temp)\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"7-5-接口值\"><a href=\"#7-5-接口值\" class=\"headerlink\" title=\"7.5 接口值\"></a>7.5 接口值</h2><p>下面语句中,<code>io.Writer</code>是接口类型值</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var w io.Writer\nw &#x3D; os.Stdout\nw &#x3D; new(bytes.Buffer)\nw &#x3D; nil</code></pre>\n<ul>\n<li><p>对于接口的定义也不例外，<code>接口</code>的零值是它的类型和值的部分都是<code>nil</code></p>\n</li>\n<li><p>一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w&#x3D;&#x3D;nil或者w!&#x3D;nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生<code>panic</code>: <code>w.Write([]byte(&quot;hello&quot;)) // panic: nil pointer dereference</code></p>\n</li>\n<li><p>第二句statement，这个赋值过程调用了一个<code>具体类型</code>到<code>接口类型</code>的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的<code>os.File</code>类型变量的指针.接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是nil值。</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;\nos.Stdout.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot; \n&#x2F;&#x2F;上下两句是等价的</code></pre></li>\n<li><p>一个接口值可以持有任意大的动态值</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var x interface&#123;&#125; &#x3D; time.Now()</code></pre>\n\n<p>  接口值可以使用&#x3D;&#x3D;和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的&#x3D;&#x3D;操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数,然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var x interface&#123;&#125; &#x3D; []int&#123;1, 2, 3&#125;\nfmt.Println(x &#x3D;&#x3D; x) &#x2F;&#x2F; panic: comparing uncomparable type []int</code></pre></li>\n</ul>\n<p>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值.</p>\n<ul>\n<li><em>警告</em>: 一个包含nil指针的接口不是nil接口</li>\n</ul>\n<p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>\n<p>思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">const debug &#x3D; true\n\nfunc main() &#123;\n    var buf *bytes.Buffer\n    if debug &#123;\n        buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output\n    &#125;\n    f(buf) &#x2F;&#x2F; NOTE: subtly incorrect!\n    if debug &#123;\n        &#x2F;&#x2F; ...use buf...\n    &#125;\n&#125;\n\n&#x2F;&#x2F; If out is non-nil, output will be written to it.\nfunc f(out io.Writer) &#123;\n    &#x2F;&#x2F; ...do something...\n    if out !&#x3D; nil &#123;\n        out.Write([]byte(&quot;done!\\n&quot;))\n    &#125;\n&#125;</code></pre>\n<p>我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">if out !&#x3D; nil &#123;\n    out.Write([]byte(&quot;done!\\n&quot;)) &#x2F;&#x2F; panic: nil pointer dereference\n&#125;</code></pre>\n<p>当main函数调用函数f时，它给f函数的out参数赋了一个<em>bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是</em>bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!&#x3D;nil的结果依然是true。</p>\n<p><img src=\"https://user-images.githubusercontent.com/46363359/182982938-08d67c3f-7aa6-457d-88a5-02646c5e2735.png\"></p>\n<p>动态分配机制依然决定(<em>bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如</em>os.File的类型，nil是一个有效的接收者（§6.2.1），但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</p>\n<p>问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var buf io.Writer\nif debug &#123;\n    buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output\n&#125;\nf(buf) &#x2F;&#x2F; OK</code></pre>\n<p>现在我们已经把接口值的技巧都讲完了，让我们来看更多的一些在Go标准库中的重要接口类型。在下面的三章中，我们会看到接口类型是怎样用在排序，web服务，错误处理中的。</p>\n<h2 id=\"7-6-sort-Interface接口\"><a href=\"#7-6-sort-Interface接口\" class=\"headerlink\" title=\"7.6. sort.Interface接口\"></a>7.6. sort.Interface接口</h2><p>golang提供了<code>sort</code>包帮助进行排序数据,实现排序需要自己实现对应的排序接口.</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type byArtist []*Track\nfunc (x byArtist) Len() int           &#123; return len(x) &#125;\nfunc (x byArtist) Less(i, j int) bool &#123; return x[i].Artist &lt; x[j].Artist &#125;\nfunc (x byArtist) Swap(i, j int)      &#123; x[i], x[j] &#x3D; x[j], x[i] &#125;</code></pre>\n<p>对于自定义的排序，我们也需要实现排序函数.</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;!+customcode\ntype customSort struct &#123;\n\tt    []*Track\n\tless func(x, y *Track) bool\n&#125;\n\nfunc (x customSort) Len() int           &#123; return len(x.t) &#125;\nfunc (x customSort) Less(i, j int) bool &#123; return x.less(x.t[i], x.t[j]) &#125;\nfunc (x customSort) Swap(i, j int)      &#123; x.t[i], x.t[j] &#x3D; x.t[j], x.t[i] &#125;\n\nsort.Sort(customSort&#123;tracks, func(x, y *Track) bool &#123;\n\t\tif x.Title !&#x3D; y.Title &#123;\n\t\t\treturn x.Title &lt; y.Title\n\t\t&#125;\n\t\tif x.Year !&#x3D; y.Year &#123;\n\t\t\treturn x.Year &lt; y.Year\n\t\t&#125;\n\t\tif x.Length !&#x3D; y.Length &#123;\n\t\t\treturn x.Length &lt; y.Length\n\t\t&#125;\n\t\treturn false\n\t&#125;&#125;)</code></pre>\n<p><code>IntsAreSorted(...interface&#123;&#125;)</code> reports whether the slice x is sorted in increasing order.</p>\n<h2 id=\"7-7-http-Handler接口\"><a href=\"#7-7-http-Handler接口\" class=\"headerlink\" title=\"7.7. http.Handler接口\"></a>7.7. http.Handler接口</h2><p>http.Handler的实例</p>\n<h2 id=\"7-8-error接口\"><a href=\"#7-8-error接口\" class=\"headerlink\" title=\"7.8. error接口\"></a>7.8. error接口</h2><pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\npackage errors_demo\n\nfunc New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125;\n\ntype errorString struct &#123; text string &#125;\n\nfunc (e *errorString) Error() string &#123; return e.text &#125;</code></pre>\n<p>调用<code>errors.New</code>函数是非常稀少的，因为有一个方便的封装函数<code>fmt.Errorf</code>它还会处理字符串格式化<br>另一个error demo实例</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package syscall\n\ntype Errno uintptr &#x2F;&#x2F; operating system error code\n\nvar errors &#x3D; [...]string&#123;\n    1:   &quot;operation not permitted&quot;,   &#x2F;&#x2F; EPERM\n    2:   &quot;no such file or directory&quot;, &#x2F;&#x2F; ENOENT\n    3:   &quot;no such process&quot;,           &#x2F;&#x2F; ESRCH\n    &#x2F;&#x2F; ...\n&#125;\n\nfunc (e Errno) Error() string &#123;\n    if 0 &lt;&#x3D; int(e) &amp;&amp; int(e) &lt; len(errors) &#123;\n        return errors[e]\n    &#125;\n    return fmt.Sprintf(&quot;errno %d&quot;, e)\n&#125;\n\nvar err error &#x3D; syscall.Errno(2)\nfmt.Println(err.Error()) &#x2F;&#x2F; &quot;no such file or directory&quot;\nfmt.Println(err)         &#x2F;&#x2F; &quot;no such file or directory&quot;</code></pre>\n<p>用有限几个进行描述，并且它满足标准错误接口</p>\n<h2 id=\"7-9-类型断言\"><a href=\"#7-9-类型断言\" class=\"headerlink\" title=\"7.9. 类型断言\"></a>7.9. 类型断言</h2><p>语法上它看起来像<code>x.(T)</code>被称为断言类型，这里<code>x</code>表示一个接口的类型和T表示一个类型,详细解释，一个类型断言检查它操作对象的动态类型是否和断言的类型是否匹配,分两种情况</p>\n<ul>\n<li><p>(T传入的是具体类型，X是动态类型),然后类型断言检查<code>X</code>的动态类型是否和<code>T</code>相同.如果检查成功了类型断言的结果就是<code>X</code>的动态值</p>\n</li>\n<li><p>(T传入的是接口类型，X是动态类型),然后类型断言检查是否<code>x</code>的动态类型满足T,如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nvar w io.Writer\nw &#x3D; os.Stdout   &#x2F;&#x2F;能赋值说明os.Stdout 实现了Write()方法\nrw :&#x3D; w.(io.ReadWriter) &#x2F;&#x2F; success: *os.File has both Read and Write,断言w是否实现了接口(io.ReadWriter)的Read和Write接口\nw &#x3D; new(ByteCounter)\nrw &#x3D; w.(io.ReadWriter) &#x2F;&#x2F; panic: *ByteCounter has no Read method\n&#x2F;&#x2F;如果对预期结果只是个判断就可以用第二个返回参数bool.\nvar w io.Writer &#x3D; os.Stdout\nf, ok :&#x3D; w.(*os.File)      &#x2F;&#x2F; success:  ok, f &#x3D;&#x3D; os.Stdout\nb, ok :&#x3D; w.(*bytes.Buffer) &#x2F;&#x2F; failure: !ok, b &#x3D;&#x3D; nil\n&#x2F;&#x2F; if 后面的w变量不会覆盖外层的w\nif w, ok :&#x3D; w.(*os.File); ok &#123;\n&#x2F;&#x2F; ...use w...\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"7-10-基于类型断言区别错误类型\"><a href=\"#7-10-基于类型断言区别错误类型\" class=\"headerlink\" title=\"7.10. 基于类型断言区别错误类型\"></a>7.10. 基于类型断言区别错误类型</h2><p>对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。</p>\n<p>一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\n\npackage main\n\nimport (\n\t&quot;errors&quot;\n\t&quot;fmt&quot;\n\t&quot;os&quot;\n\t&quot;syscall&quot;\n)\n\ntype PathError struct &#123;\n\tOp   string\n\tPath string\n\tErr  error\n&#125;\n\nfunc (e *PathError) Error() string &#123;\n\treturn e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()\n&#125;\n\nvar ErrNotExist &#x3D; errors.New(&quot;file does not exist&quot;)\n\n&#x2F;&#x2F; IsNotExist returns a boolean indicating whether the error is known to\n&#x2F;&#x2F; report that a file or directory does not exist. It is satisfied by\n&#x2F;&#x2F; ErrNotExist as well as some syscall errors.\nfunc IsNotExist(err error) bool &#123;\n\tif pe, ok :&#x3D; err.(*PathError); ok &#123;\n\t\terr &#x3D; pe.Err\n\t&#125;\n\treturn err &#x3D;&#x3D; syscall.ENOENT || err &#x3D;&#x3D; ErrNotExist\n&#125;\n\nfunc main() &#123;\n\t_, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)\n\tfmt.Println(os.IsNotExist(err)) &#x2F;&#x2F; &quot;true&quot;\n&#125;</code></pre>\n\n<h2 id=\"7-11-any关键字与泛型\"><a href=\"#7-11-any关键字与泛型\" class=\"headerlink\" title=\"7.11. any关键字与泛型\"></a>7.11. any关键字与泛型</h2><p>类型定义时不限制<code>形参类型</code>，在函数调用的时候再指定<code>具体类型</code>.  <code>any</code>其实是<code>interface&#123;&#125;</code>的别名<br>泛型好处:  (1).在编译期间对类型进行检查以提高类型安全(2).通过指定类型消除强制类型转换(3).能够减少代码重复性，提供更通用的功能函数。</p>\n<ul>\n<li>类型泛型<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package main\n\nimport &quot;fmt&quot;\n\ntype ListType[T int | int32 | int64 | string] []T\n\ntype MapType[K int | int32, V int64 | string] map[K]V\n\nfunc main() &#123;\n    var intList ListType[int]\n    intList &#x3D; []int&#123;1, 2, 3&#125;\n    fmt.Println(intList)\n    strList :&#x3D; ListType[string]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;\n    fmt.Println(strList)\n\n    intMap :&#x3D; MapType[int, string]&#123;1: &quot;1&quot;, 2: &quot;2&quot;&#125;\n    int32Map :&#x3D; MapType[int32, int64]&#123;1: 2, 3: 4&#125;\n    fmt.Println(intMap)\n    fmt.Println(int32Map)\n&#125;</code></pre>\n这里面的T,K,V都是占位符号,<code>ListType</code>只能在那三种类型中选择,同理<code>MapType</code>也是</li>\n<li>接口泛型<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">type GenericStackInterface[T any] interface &#123;\n  Push(element T)\n  Pop() T\n&#125;</code></pre></li>\n<li>泛型函数<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func minInt[T int | int8 | int16 | int32](a, b T) T &#123;\nif a &lt; b &#123;\n    return a\n&#125;\n    return b\n&#125;\n\nfunc maxInt[T int | int8 | int16 | int32](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\nfunc Mix(a any) any &#123;\n\n&#125;\n&#x2F;&#x2F;还可以简化一下\ntype Numeric interface &#123;\n    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64\n&#125;\nfunc min[T Numeric](a, b T) T &#123;\nif a &lt; b &#123;\n    return a\n&#125;\n    return b\n&#125;\n\nfunc max[T Numeric](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\n&#x2F;&#x2F; go.18内置了数字类型的集合，故可以\nimport (\n&quot;golang.org&#x2F;x&#x2F;exp&#x2F;constraints&quot;\n)\n\nfunc minType[T constraints.Ordered](a, b T) T &#123;\n    if a &lt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\n\nfunc maxType[T constraints.Ordered](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;</code></pre>\n如果进入<code>constraints</code>源代码查看其具体代码的话，会发现在 Ordered 类型中也是有各种数字类型组合起来的。但是有一点奇怪的地方就是这里的类型集合中，各种类型前加了一个波浪线~, 表示衍生类型，即使用 type 自定义的类型也可以被识别到，只要底层类型一致即可。比如 ~int 可以包含 int 和 type MyInt int 等多种类型</li>\n</ul>\n<h1 id=\"8-Goroutines和Channels\"><a href=\"#8-Goroutines和Channels\" class=\"headerlink\" title=\"8. Goroutines和Channels\"></a>8. Goroutines和Channels</h1><p>(多看看本章代码)</p>\n<h2 id=\"8-1-goroutine\"><a href=\"#8-1-goroutine\" class=\"headerlink\" title=\"8.1 goroutine\"></a>8.1 goroutine</h2><p>通过代码示例了解<code>goroutine</code>的使用</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func main() &#123;\n    go spinner(100 * time.Millisecond)\n    const n &#x3D; 45\n    fibN :&#x3D; fib(n) &#x2F;&#x2F; slow\n    fmt.Printf(&quot;\\rFibonacci(%d) &#x3D; %d\\n&quot;, n, fibN)\n&#125;\n\nfunc spinner(delay time.Duration) &#123;\n    for &#123;\n        for _, r :&#x3D; range &#96;-\\|&#x2F;&#96; &#123;\n            fmt.Printf(&quot;\\r%c&quot;, r)\n            time.Sleep(delay)\n        &#125;\n    &#125;\n&#125;\n\nfunc fib(x int) int &#123;\n    if x &lt; 2 &#123;\n        return x\n    &#125;\n    return fib(x-1) + fib(x-2)\n&#125;</code></pre>\n<h2 id=\"8-2-channel\"><a href=\"#8-2-channel\" class=\"headerlink\" title=\"8.2 channel\"></a>8.2 channel</h2><p>这里应该还得看一下uber编码规范</p>\n<ul>\n<li><p>无缓冲channel</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">ch &lt;- x\nx &#x3D; &lt;-chan &#x2F;&#x2F;取出元素\n&lt;- ch &#x2F;&#x2F;取出，舍弃\nclose(ch) &#x2F;&#x2F; 关闭chan</code></pre>\n\n<ul>\n<li><p>串联channel</p>\n</li>\n<li><p>单方向channel</p>\n</li>\n</ul>\n</li>\n<li><p>缓冲channel</p>\n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">ch &#x3D; make(chan string, 3) &#x2F;&#x2F;channel容量为3</code></pre></li>\n</ul>\n<h2 id=\"8-3-基于select的多路复用\"><a href=\"#8-3-基于select的多路复用\" class=\"headerlink\" title=\"8.3 基于select的多路复用\"></a>8.3 基于select的多路复用</h2><details>\n<summary>多路复用demo</summary>\n<pre>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.\n&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;\n\n&#x2F;&#x2F; See page 246.\n\n&#x2F;&#x2F; Countdown implements the countdown for a rocket launch.\npackage main\n\n&#x2F;&#x2F; NOTE: the ticker goroutine never terminates if the launch is aborted.\n&#x2F;&#x2F; This is a &quot;goroutine leak&quot;.\n\nimport (\n        &quot;fmt&quot;\n        &quot;os&quot;\n        &quot;time&quot;\n)\n\n&#x2F;&#x2F;!+\n\nfunc main() &#123;\n        &#x2F;&#x2F; ...create abort channel...\n\n        &#x2F;&#x2F;!-\n\n        abort :&#x3D; make(chan struct&#123;&#125;)\n        go func() &#123;\n                os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte\n                abort &lt;- struct&#123;&#125;&#123;&#125;\n        &#125;()\n\n        &#x2F;&#x2F;!+\n        fmt.Println(&quot;Commencing countdown.  Press return to abort.&quot;)\n        tick :&#x3D; time.Tick(1 * time.Second)\n        for countdown :&#x3D; 10; countdown &gt; 0; countdown-- &#123;\n                fmt.Println(countdown)\n                select &#123;\n                case &lt;-tick:\n                        &#x2F;&#x2F; Do nothing.\n                case &lt;-abort:\n                        fmt.Println(&quot;Launch aborted!&quot;)\n                        return\n                &#125;\n        &#125;\n        launch()\n&#125;\n&#x2F;&#x2F;!-\nfunc launch() &#123;\n        fmt.Println(&quot;Lift off!&quot;)\n&#125;</code></pre>\n\n<p></pre></p>\n</details>\n\n<ul>\n<li><p>goroutine泄露 : 当for语句执行完后，程序已经跳转到其他部分，但是<code>time.Tick(1 * time.Second)</code>仍然会继续的网channel里面发送数据，这就会导致gotourine泄露，以上面为例，那么就需要合适的地方调用<code>tick.stop()</code></p>\n</li>\n<li><p>channel的ready : 一定要等到channel准备完毕，开始接受或者发送消息</p>\n</li>\n<li><p>channel的轮询 : 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">select &#123;\n  case &lt;-abort:\n      fmt.Printf(&quot;Launch aborted!\\n&quot;)\n      return\n  default:\n      &#x2F;&#x2F; do nothing\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"8-4-并发的退出\"><a href=\"#8-4-并发的退出\" class=\"headerlink\" title=\"8.4. 并发的退出\"></a>8.4. 并发的退出</h2><p>这节主要讨论如何有效退出goroutines</p>\n<details>\n<summary>\n<font size=\"3\" color=\"orange\">goroutines退出代码示例</font></summary>\n<pre>\n\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;gopl.io&#x2F;ch8&#x2F;du4\n&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.\n&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;\n\n&#x2F;&#x2F; See page 251.\n\n&#x2F;&#x2F; The du4 command computes the disk usage of the files in a directory.\npackage main\n\n&#x2F;&#x2F; The du4 variant includes cancellation:\n&#x2F;&#x2F; it terminates quickly when the user hits return.\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;os&quot;\n\t&quot;path&#x2F;filepath&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\n&#x2F;&#x2F;!+1\nvar done &#x3D; make(chan struct&#123;&#125;)\n\nfunc cancelled() bool &#123;\n\tselect &#123;\n\tcase &lt;-done:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;!-1\n\nfunc main() &#123;\n\t&#x2F;&#x2F; Determine the initial directories.\n\troots :&#x3D; os.Args[1:]\n\tif len(roots) &#x3D;&#x3D; 0 &#123;\n\t\troots &#x3D; []string&#123;&quot;.&quot;&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;!+2\n\t&#x2F;&#x2F; Cancel traversal when input is detected.\n\tgo func() &#123;\n\t\tos.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte\n\t\tclose(done)\n\t&#125;()\n\t&#x2F;&#x2F;!-2\n\n\t&#x2F;&#x2F; Traverse each root of the file tree in parallel.\n\tfileSizes :&#x3D; make(chan int64)\n\tvar n sync.WaitGroup\n\tfor _, root :&#x3D; range roots &#123;\n\t\tn.Add(1)\n\t\tgo walkDir(root, &amp;n, fileSizes)\n\t&#125;\n\tgo func() &#123;\n\t\tn.Wait()\n\t\tclose(fileSizes)\n\t&#125;()\n\n\t&#x2F;&#x2F; Print the results periodically.\n\ttick :&#x3D; time.Tick(500 * time.Millisecond)\n\tvar nfiles, nbytes int64\nloop:\n\t&#x2F;&#x2F;!+3\n\tfor &#123;\n\t\tselect &#123;\n\t\tcase &lt;-done:\n\t\t\t&#x2F;&#x2F; Drain fileSizes to allow existing goroutines to finish.\n\t\t\tfor range fileSizes &#123;\n\t\t\t\t&#x2F;&#x2F; Do nothing.\n\t\t\t&#125;\n\t\t\treturn\n\t\tcase size, ok :&#x3D; &lt;-fileSizes:\n\t\t\t&#x2F;&#x2F; ...\n\t\t\t&#x2F;&#x2F;!-3\n\t\t\tif !ok &#123;\n\t\t\t\tbreak loop &#x2F;&#x2F; fileSizes was closed\n\t\t\t&#125;\n\t\t\tnfiles++\n\t\t\tnbytes +&#x3D; size\n\t\tcase &lt;-tick:\n\t\t\tprintDiskUsage(nfiles, nbytes)\n\t\t&#125;\n\t&#125;\n\tprintDiskUsage(nfiles, nbytes) &#x2F;&#x2F; final totals\n&#125;\n\nfunc printDiskUsage(nfiles, nbytes int64) &#123;\n\tfmt.Printf(&quot;%d files  %.1f GB\\n&quot;, nfiles, float64(nbytes)&#x2F;1e9)\n&#125;\n\n&#x2F;&#x2F; walkDir recursively walks the file tree rooted at dir\n&#x2F;&#x2F; and sends the size of each found file on fileSizes.\n&#x2F;&#x2F;!+4\nfunc walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) &#123;\n\tdefer n.Done()\n\tif cancelled() &#123;\n\t\treturn\n\t&#125;\n\tfor _, entry :&#x3D; range dirents(dir) &#123;\n\t\t&#x2F;&#x2F; ...\n\t\t&#x2F;&#x2F;!-4\n\t\tif entry.IsDir() &#123;\n\t\t\tn.Add(1)\n\t\t\tsubdir :&#x3D; filepath.Join(dir, entry.Name())\n\t\t\tgo walkDir(subdir, n, fileSizes)\n\t\t&#125; else &#123;\n\t\t\tfileSizes &lt;- entry.Size()\n\t\t&#125;\n\t\t&#x2F;&#x2F;!+4\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;!-4\n\nvar sema &#x3D; make(chan struct&#123;&#125;, 20) &#x2F;&#x2F; concurrency-limiting counting semaphore\n\n&#x2F;&#x2F; dirents returns the entries of directory dir.\n&#x2F;&#x2F;!+5\nfunc dirents(dir string) []os.FileInfo &#123;\n\tselect &#123;\n\tcase sema &lt;- struct&#123;&#125;&#123;&#125;: &#x2F;&#x2F; acquire token\n\tcase &lt;-done:\n\t\treturn nil &#x2F;&#x2F; cancelled\n\t&#125;\n\tdefer func() &#123; &lt;-sema &#125;() &#x2F;&#x2F; release token\n\n\t&#x2F;&#x2F; ...read directory...\n\t&#x2F;&#x2F;!-5\n\n\tf, err :&#x3D; os.Open(dir)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Fprintf(os.Stderr, &quot;du: %v\\n&quot;, err)\n\t\treturn nil\n\t&#125;\n\tdefer f.Close()\n\n\tentries, err :&#x3D; f.Readdir(0) &#x2F;&#x2F; 0 &#x3D;&gt; no limit; read all entries\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Fprintf(os.Stderr, &quot;du: %v\\n&quot;, err)\n\t\t&#x2F;&#x2F; Don&#39;t return: Readdir may return partial results.\n\t&#125;\n\treturn entries\n&#125;</code></pre>\n\n<p></pre></p>\n</details>\n\n<h1 id=\"9-基于共享变量的并发\"><a href=\"#9-基于共享变量的并发\" class=\"headerlink\" title=\"9. 基于共享变量的并发\"></a>9. 基于共享变量的并发</h1><p>(多看这章代码)<br>避免数据竞争的三个方法</p>\n<ul>\n<li><p>并发读数据不会有数据竞争问题</p>\n</li>\n<li><p>避免从多个goroutine中访问变量，使用独立变量</p>\n</li>\n<li><p>临界区控制</p>\n</li>\n<li><p>总结</p>\n<ul>\n<li>数据竞争: 程序在多个goroutine交叉执行操作时，导致数据不一致.  </li>\n<li><code>包级别</code>的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。<br>  (多看看本章代码)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-1-sync-Mutex与sync-RMutex互斥锁\"><a href=\"#9-1-sync-Mutex与sync-RMutex互斥锁\" class=\"headerlink\" title=\"9.1 sync.Mutex与sync.RMutex互斥锁\"></a>9.1 sync.Mutex与sync.RMutex互斥锁</h2><p>比如银行存款查询余额的场景，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款(这句话很关键要没有)操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁</p>\n<ul>\n<li>总结<ul>\n<li>避免临界区中的变量在中途被其他的goroutine修改</li>\n<li>使用mutex包进行互斥goroutine</li>\n<li>一个deferred Unlock即使在临界区发生<code>panic</code>时依然会执行</li>\n<li>golang不支持重入锁</li>\n<li>sync.RWMutex.RLock()持锁，sync.RWMutex.Lock()会阻塞，相同的RWMutex.Lock()持锁，sync.RWMutex.RLock()阻塞，但是sync.RWMutex.RLock()阻塞之间不阻塞</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-2-sync-Once惰性初始化\"><a href=\"#9-2-sync-Once惰性初始化\" class=\"headerlink\" title=\"9.2 sync.Once惰性初始化\"></a>9.2 sync.Once惰性初始化</h2><p>如果初始化的成本太高，需要延迟的初始化对象。可考虑使用<code>sync.Once</code><br><detials></p>\n<summary>sync.One的demo</summary>\n<pre>\n\n<p></pre></p>\n</details>\n\n\n<h2 id=\"9-3-sync-Cond的使用\"><a href=\"#9-3-sync-Cond的使用\" class=\"headerlink\" title=\"9.3 sync.Cond的使用\"></a>9.3 sync.Cond的使用</h2><ol>\n<li><p>使用场景: <code>sync.Cond</code> 经常用在多个goroutine等待，一个goroutine通知,如果是一读一等待使用<code>sync.Mutx</code>和<code>chan</code>就可以</p>\n</li>\n<li><p><code>sync.Cond</code>的<a href=\"https://pkg.go.dev/sync@go1.19#Cond\">方法</a></p>\n <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; Each Cond has an associated Locker L (often a *Mutex or *RWMutex),\n&#x2F;&#x2F; which must be held when changing the condition and\n&#x2F;&#x2F; when calling the Wait method.\n&#x2F;&#x2F;\n&#x2F;&#x2F; A Cond must not be copied after first use.\ntype Cond struct &#123;\n        noCopy noCopy\n        &#x2F;&#x2F; L is held while observing or changing the condition\n        L Locker\n        notify  notifyList\n        checker copyChecker\n&#125;\n</code></pre>\n\n<p> Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁</p>\n <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; Signal wakes one goroutine waiting on c, if there is any.\n&#x2F;&#x2F;\n&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L\n&#x2F;&#x2F; during the call.\n&#x2F;&#x2F;Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护\nfunc (c *Cond) Signal()\n&#x2F;&#x2F; Broadcast wakes all goroutines waiting on c.\n&#x2F;&#x2F;\n&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L\n&#x2F;&#x2F; during the call.\nfunc (c *Cond) Broadcast()\n\n&#x2F;&#x2F; Wait atomically unlocks c.L and suspends execution\n&#x2F;&#x2F; of the calling goroutine. After later resuming execution,\n&#x2F;&#x2F; Wait locks c.L before returning. Unlike in other systems,\n&#x2F;&#x2F; Wait cannot return unless awoken by Broadcast or Signal.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Because c.L is not locked when Wait first resumes, the caller\n&#x2F;&#x2F; typically cannot assume that the condition is true when\n&#x2F;&#x2F; Wait returns. Instead, the caller should Wait in a loop:\n&#x2F;&#x2F;\n&#x2F;&#x2F;    c.L.Lock()\n&#x2F;&#x2F;    for !condition() &#123;\n&#x2F;&#x2F;        c.Wait()\n&#x2F;&#x2F;    &#125;\n&#x2F;&#x2F;    ... make use of condition ...\n&#x2F;&#x2F;    c.L.Unlock()\n&#x2F;&#x2F;挂起调用者所在的 goroutine,等待Broadcast或者Signal方法\nfunc (c *Cond) Wait()\n    &#x2F;&#x2F;代码片段\n    c.L.Lock()\n    for !condition() &#123;\n        c.Wait()\n    &#125;\n    ... make use of condition ...\n    c.L.Unlock()\n\n\n\n</code></pre>\n</li>\n<li><p>Cond代码示例</p>\n <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">var done &#x3D; false\n\nfunc read(name string, c *sync.Cond) &#123;\n    c.L.Lock()\n    for !done &#123;\n        c.Wait()\n    &#125;\n    log.Println(name, &quot;starts reading&quot;)\n    c.L.Unlock()\n&#125;\n\nfunc write(name string, c *sync.Cond) &#123;\n    log.Println(name, &quot;starts writing&quot;)\n    time.Sleep(time.Second)\n    c.L.Lock()\n    done &#x3D; true\n    c.L.Unlock()\n    log.Println(name, &quot;wakes all&quot;)\n    c.Broadcast()\n&#125;\n\nfunc main() &#123;\n    cond :&#x3D; sync.NewCond(&amp;sync.Mutex&#123;&#125;)\n\n    go read(&quot;reader1&quot;, cond)\n    go read(&quot;reader2&quot;, cond)\n    go read(&quot;reader3&quot;, cond)\n    write(&quot;writer&quot;, cond)\n\n    time.Sleep(time.Second * 3)\n&#125;\n</code></pre></li>\n</ol>\n<h2 id=\"9-4-Goroutines和线程\"><a href=\"#9-4-Goroutines和线程\" class=\"headerlink\" title=\"9.4. Goroutines和线程\"></a>9.4. Goroutines和线程</h2><ul>\n<li><p>每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量</p>\n</li>\n<li><p>一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩</p>\n</li>\n<li><p>Go的<code>运行时</code>有自己的调度器，这个调度器比如m:n调度，n个操作系统线程调度m个gotoutine，例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。</p>\n</li>\n<li><p>GOMAXPROCS : 变量来决定会有多少个操作系统的线程同时执行Go的代码,其默认的值是运行机器上的CPU的核心数,<code>GOMAXPROCS</code>是前面说的m:n调度中的n.下面代码就可以简单的看出os线程调度代码的情况</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nfor &#123;\n    go fmt.Print(0)\n    fmt.Print(1)\n&#125;\n\n$ GOMAXPROCS&#x3D;1 go run hacker-cliché.go\n111111111111111111110000000000000000000011111...\n\n$ GOMAXPROCS&#x3D;2 go run hacker-cliché.go\n010101010101010101011001100101011010010100110...</code></pre>\n\n\n</li>\n<li><p>总结</p>\n<ul>\n<li>通过广播机制来取消goroutines</li>\n<li>确保主函数退出，routines也随即退出</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"10-包和工具\"><a href=\"#10-包和工具\" class=\"headerlink\" title=\"10. 包和工具\"></a>10. 包和工具</h1><p>互联网上已经发布了非常多的Go语言开源包，它们可以通过 <a href=\"http://godoc.org/\">http://godoc.org</a> 检索</p>\n<ul>\n<li>包的声明 ： 通过<code>package.struct</code>的形式访问我们的下载的<code>package</code>,但是也有同名的例如<code>math/rand</code>和<code>crypto/rand</code>，这种要重新指定包名，只影响当前文件，同时也解决了那些又臭又长的包名</li>\n<li>文件开头以<code>_</code>和<code>.</code>的会被忽略</li>\n<li>以<code>_test</code>结尾的通常是测试包</li>\n<li>一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in&#x2F;yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml</li>\n<li><code>包的匿名导入</code>:<ul>\n<li>解决包的依赖顺序</li>\n<li>初始化包级声明的变量</li>\n<li>按顺序初始化包中每个文件里的 init 函数</li>\n<li>每个文件中可以包含多个 init 函数，按顺序执行(所以你导和不导包差距很大，匿名导入只是表明你无法使用相应包内函数)</li>\n<li>包名和成员名要尽量的短，并且能见名知意</li>\n</ul>\n</li>\n<li>go的工具<ul>\n<li>工作区结构 : 当需要切换工作区的时候，只需要更新下GOPATH环境变量即可<code>src</code>保存源代码,<code>pkg</code>子目录用于保存编译后的包的目标文件,<code>bin</code>子目录用于保存编译后的可执行程序</li>\n<li>下载包 : <code>go get</code>命令，<code>go get -u</code>命令只是简单地保证每个下载最新版本，实际工作中要对包版本做精细的管理，需要vendor目录管理不同版本的包,<code>go help gopath</code>查看vendor帮助文档,而go get 相当于获取的是远程仓库源代码的整个库，还可以看到仓库的版本信息，go支持导入远程github仓库的代码，<code>go get</code>下载的包保存在哪里呢？一般他会保存在这个目录：<code>GOPATH/src</code><br><a href=\"https://www.cnblogs.com/mrbug/p/11990418.html#:~:text=go%20get%20%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8C%85,%E7%9A%84go%20%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E3%80%82\">goget详细介绍</a>，<code>go get</code>是对模块代码的更新</li>\n<li>构建包 : 可以使用相对路径和绝对路径进行构建项目，<code>go run</code>其实也可以偷懒，直接<code>go run *.go</code>,<code>go build -i</code>命令将安装每个目标所依赖的包,<code>// +build linux darwin</code>,在包声明和包注释的前面，该构建注释参数告诉<code>go build</code>只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件,<code>// +build ignore</code>这个构建注释则表示不编译这个文件。<code>go doc go/build</code></li>\n<li>包文档 : 专门用于保存包文档的源文件通常叫<code>doc.go</code>,例如 <code>go doc time</code> 某个具体成员结构<code>go doc time.Since</code>,或者具体函数<code>go doc time.Duration.Second</code> , 更简单的是<code>godoc -http :8000</code>包含了所有go包的索引，<code>-analysis=type</code>和<code>-analysis=pointer</code>命令行标志参数用于打开文档和代码中关于静态分析的结果</li>\n<li>内部包 : 一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包</li>\n<li>搜索包 : <code>go list</code>列出工作区相关包,还可以查看完整包的原信息,例如<code>hash</code>包<code>go list -json hash</code><ul>\n<li>命令行参数-f则允许用户使用text&#x2F;template包（§4.6）的模板语言定义输出文本的格式<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F;windows环境下注意\ngo list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...\n  compress&#x2F;bzip2 -&gt; bufio io sort\n  compress&#x2F;flate -&gt; bufio fmt io math sort strconv\n  compress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io time\n  compress&#x2F;lzw -&gt; bufio errors fmt io\n  compress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"11-测试\"><a href=\"#11-测试\" class=\"headerlink\" title=\"11. 测试\"></a>11. 测试</h1><p>go test选项含义</p>\n<pre class=\"language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n-args 传递参数到test binary<span class=\"token punctuation\">(</span>到时候补一个demo<span class=\"token punctuation\">)</span>\n-c 编译test binary,但是不执行\n-exec xprog  运行test binary ,原理如同 go run\n-i 安装test binary的相关依赖\n-json 将测试输出转化为json为了自动化处理\n-c <span class=\"token function\">file</span>   定义编译后的binary的文件名\n</code></pre>\n\n\n<h2 id=\"11-1-go-test\"><a href=\"#11-1-go-test\" class=\"headerlink\" title=\"11.1 go test\"></a>11.1 go test</h2><p>一个测试函数是以<code>Test</code>为函数名前缀的函数<br>一个基准测试函数是以<code>Benchmark</code>为函数名前缀的函数<br>一个示例函数是以<code>Example</code>为函数名前缀的函数，提供一个由编译器保证正确性的示例文档</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">- &#96;go test -v &#96;会打印每个函数的名字和运行时间\n- &#96;go test -run&#x3D; &#96;会去匹配正则表达式，只有被匹配到的才会被执行\n- &#96;go test -v .&#x2F;...&#96; 执行所有当前目录下测试cases\n- &#96;go test -v foo&#x2F;...&#96; 执行foo目录下所有cases\n- &#96;go test -v foo...&#96; 执行指定前缀的测试cases\n- &#96;go test ...&#96; gopath下所有测试cases\n- &#96;go test -v hello_test.go&#96; 执行某一文件下的测试cases,但是该文件中如果调用了其它文件中的模块会报错\n- &#96;go test -v hello_test.go -test.run TestHello&#96; 测试单个函数</code></pre>\n<ul>\n<li><p>组织多个测试用例</p>\n<p>即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息,可以使用<code>t.Fatal</code>或<code>t.Fatalf</code>停止当前测试函数</p>\n  <details>\n  <summary>组织多测试用例</summary>\n  <pre>\n  \n  <pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">func TestIsPalindrome(t *testing.T) &#123;\nvar tests &#x3D; []struct &#123;\n    input string\n    want  bool\n&#125;&#123;\n        &#123;&quot;&quot;, true&#125;,\n        &#123;&quot;a&quot;, true&#125;,\n        &#123;&quot;aa&quot;, true&#125;,\n        &#123;&quot;ab&quot;, false&#125;,\n        &#123;&quot;kayak&quot;, true&#125;,\n        &#123;&quot;detartrated&quot;, true&#125;,\n        &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;,\n        &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;,\n        &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;,\n        &#123;&quot;été&quot;, true&#125;,\n        &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;,\n        &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome\n        &#123;&quot;desserts&quot;, false&#125;,   &#x2F;&#x2F; semi-palindrome\n    &#125;\n    for _, test :&#x3D; range tests &#123;\n        if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123;\n            t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>  </pre></p>\n  </details>\n</li>\n<li><p>随机测试</p>\n<ol>\n<li>编写对照函数，效率低下</li>\n<li>生成的随机输入的数据遵循特定的模式，然后就知道期望的输出</li>\n</ol>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\nimport &quot;math&#x2F;rand&quot;\n\n  &#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents\n  &#x2F;&#x2F; are derived from the pseudo-random number generator rng.\n  func randomPalindrome(rng *rand.Rand) string &#123;\n      n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24\n      runes :&#x3D; make([]rune, n)\n      for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;\n          r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\\u0999&#39;\n          runes[i] &#x3D; r\n          runes[n-1-i] &#x3D; r\n      &#125;\n      return string(runes)\n  &#125;\n\n  func TestRandomPalindromes(t *testing.T) &#123;\n      &#x2F;&#x2F; Initialize a pseudo-random number generator.\n      seed :&#x3D; time.Now().UTC().UnixNano()\n      t.Logf(&quot;Random seed: %d&quot;, seed)\n      rng :&#x3D; rand.New(rand.NewSource(seed))\n\n      for i :&#x3D; 0; i &lt; 1000; i++ &#123;\n          p :&#x3D; randomPalindrome(rng)\n          if !IsPalindrome(p) &#123;\n              t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)\n          &#125;\n      &#125;\n  &#125;\n  &#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.\n  &#x2F;&#x2F; Letter case is ignored, as are non-letters.\n  func IsPalindrome(s string) bool &#123;\n      var letters []rune\n      for _, r :&#x3D; range s &#123;\n          if unicode.IsLetter(r) &#123;\n              letters &#x3D; append(letters, unicode.ToLower(r))\n          &#125;\n      &#125;\n      for i :&#x3D; range letters &#123;\n          if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;\n              return false\n          &#125;\n      &#125;\n      return true\n  &#125;\n</code></pre>\n</li>\n<li><p>测试一个命令(测试内部未导出函数)</p>\n<p>要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。要注意的是在测试代码中并没有调用<code>log.Fatal</code>或<code>os.Exit</code>，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理,如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理.导出内部函数,</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">&#x2F;&#x2F; src&#x2F;bytes&#x2F;export_test.go\n  package bytes\n  &#x2F;&#x2F; Export func for testing\n  var IndexBytePortable &#x3D; indexBytePortable &#x2F;&#x2F; 赋值给包级可导出变量</code></pre>\n\n<p>然后通过外部包进行测试</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">\n&#x2F;&#x2F; src&#x2F;bytes&#x2F;bytes_test.go\n  package bytes_test\n\n  func TestIndexByte(t *testing.T) &#123;\n      for _, tt :&#x3D; range indexTests &#123;\n          ... 代码片段\n          posp :&#x3D; IndexBytePortable(a, b) &#x2F;&#x2F; 导出的内部方法在这里被使用\n          if posp !&#x3D; tt.i &#123;\n              t.Errorf(&#96;indexBytePortable(%q, &#39;%c&#39;) &#x3D; %v&#96;, tt.a, b, posp)\n          &#125;\n      &#125;\n  &#125;\n</code></pre>\n<p>还有种方式就是不导出，直接在包名下写测试函数，然后进行测试源代码</p>\n</li>\n<li><p>白盒测试</p>\n<p>TBC,代码的内部实现对于测试人员来说是可见的，言外之意就是能看到内部实现,测试内部实现，这个实现可能是未导出的</p>\n</li>\n<li><p>外部测试包</p>\n<pre class=\"language-golang\" data-language=\"golang\"><code class=\"language-golang\">package pprint_test\n  &#x2F;&#x2F;这时候就可以在\n  import (\n      &quot;gott&#x2F;hi&quot;\n      &#x2F;&#x2F; 导入 要进行测试的 pprint 包本身\n      &quot;gott&#x2F;pprint&quot;\n      &quot;testing&quot;\n  )\n\n  func TestPPrint(t *testing.T) &#123;\n      pprint.PPrint()\n      hi.Say()\n      t.Log(&quot;expect call PPrint&quot;)\n  &#125;\n  </code></pre>\n<p>使用 Go 官方的代码风格：pprint_test.go 文件，因为pprint_test在 pprint 目录下，通过在 import 时，使用<code>.</code>选项，可以直接调用PPrint()方法</p>\n</li>\n<li><p>编写有效的测试</p>\n<ol>\n<li>一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息</li>\n<li>一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律</li>\n<li>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试</li>\n</ol>\n</li>\n<li><p>避免脆弱的测试<br>TBC</p>\n</li>\n</ul>\n<h2 id=\"11-2-测试覆盖率\"><a href=\"#11-2-测试覆盖率\" class=\"headerlink\" title=\"11.2 测试覆盖率\"></a>11.2 测试覆盖率</h2><p>对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化(应该是有)</p>\n<ol>\n<li>go test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;eval</li>\n<li>go test -run&#x3D;Coverage -covermode&#x3D;count gopl.io&#x2F;ch7&#x2F;eval</li>\n</ol>\n<h2 id=\"11-3-基准测试\"><a href=\"#11-3-基准测试\" class=\"headerlink\" title=\"11.3 基准测试\"></a>11.3 基准测试</h2><ol>\n<li><code>-bench</code>也是正则匹配,BenchmarkIsPalindrome-8,8表示的是GOMAXPROCS的值,<code>-benchmem</code>命令行标志参数将在报告中包含内存的分配数据统计</li>\n<li>比较型的基准测试就是普通程序代码,它们通常是单参数的函数，由几个不同数量级的基准测试函数调用,通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。所有的测试cases都要保留，随着项目的发展，都需要做回归测试</li>\n</ol>\n<h2 id=\"11-4-刨析\"><a href=\"#11-4-刨析\" class=\"headerlink\" title=\"11.4 刨析\"></a>11.4 刨析</h2><p>TBC</p>\n<h2 id=\"11-5-示例函数\"><a href=\"#11-5-示例函数\" class=\"headerlink\" title=\"11.5 示例函数\"></a>11.5 示例函数</h2><p>示例函数有三个用处。</p>\n<ol>\n<li>最主要的一个是作为文档，根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。</li>\n<li>在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的&#x2F;&#x2F; Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配</li>\n<li>提供一个真实的演练场，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数</li>\n</ol>\n<h1 id=\"12-appendIndex\"><a href=\"#12-appendIndex\" class=\"headerlink\" title=\"12. appendIndex\"></a>12. appendIndex</h1><ol>\n<li>线程内再重启一个线程，然后就可以通过加锁，进行隔离开，但此时任然是两个线程的间的交替</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl8ziiu580000l1db0x645daz","category_id":"cl8ziiu5d0002l1dbholzdfc9","_id":"cl8ziiu5i000al1dbblg18839"},{"post_id":"cl8ziiu5c0001l1db8w7g62tt","category_id":"cl8ziiu5g0006l1db66ci7e20","_id":"cl8ziiu5k000fl1dbfarr5df0"},{"post_id":"cl8ziiu5e0003l1dbgvrsb7zl","category_id":"cl8ziiu5i000bl1db7npccavp","_id":"cl8ziiu5l000kl1dber73935r"},{"post_id":"cl8ziiu5f0004l1dbb0tfcbhh","category_id":"cl8ziiu5k000gl1dbe6kjehpc","_id":"cl8ziiu5m000pl1db1z3p76eh"},{"post_id":"cl8ziiu5f0005l1db6lco6d8y","category_id":"cl8ziiu5l000ll1db7t1p3sk2","_id":"cl8ziiu5p000vl1dbgl62bcpe"},{"post_id":"cl8ziiu5i0009l1dbfmys5w82","category_id":"cl8ziiu5l000ll1db7t1p3sk2","_id":"cl8ziiu5p000yl1db4lsv3o7m"},{"post_id":"cl8ziiu5j000cl1db3qo638l6","category_id":"cl8ziiu5o000ul1dbhhpxa06n","_id":"cl8ziiu5q0012l1db5xrmasx0"},{"post_id":"cl8ziiu5j000dl1db5nty72rq","category_id":"cl8ziiu5p000zl1dbej7w2tzx","_id":"cl8ziiu5r0016l1dbch4wa6d3"},{"post_id":"cl8ziiu5k000il1db9ujx0n8r","category_id":"cl8ziiu5i000bl1db7npccavp","_id":"cl8ziiu5s001cl1dbaiwg6007"},{"post_id":"cl8ziiu5k000il1db9ujx0n8r","category_id":"cl8ziiu5q0013l1dbcdt295uv","_id":"cl8ziiu5t001el1db2vrk6lrv"},{"post_id":"cl8ziiu5l000jl1dbcro83u9l","category_id":"cl8ziiu5i000bl1db7npccavp","_id":"cl8ziiu5t001hl1db1qcgaeep"},{"post_id":"cl8ziiu5l000jl1dbcro83u9l","category_id":"cl8ziiu5q0013l1dbcdt295uv","_id":"cl8ziiu5u001kl1db33q9hiht"},{"post_id":"cl8ziiu5m000ml1dbfqn29b6n","category_id":"cl8ziiu5i000bl1db7npccavp","_id":"cl8ziiu5v001nl1db1c4j0xbb"},{"post_id":"cl8ziiu5m000ml1dbfqn29b6n","category_id":"cl8ziiu5q0013l1dbcdt295uv","_id":"cl8ziiu5v001pl1dbbi6ggt23"},{"post_id":"cl8ziiu5m000ol1dbdmxr6mlb","category_id":"cl8ziiu5i000bl1db7npccavp","_id":"cl8ziiu5w001rl1dbhu125cd3"},{"post_id":"cl8ziiu5m000ol1dbdmxr6mlb","category_id":"cl8ziiu5q0013l1dbcdt295uv","_id":"cl8ziiu5w001ul1db31obfezz"},{"post_id":"cl8ziiu5n000ql1dbhedccz6b","category_id":"cl8ziiu5v001ml1db5zuahsic","_id":"cl8ziiu5x001yl1dbeva5g6u0"},{"post_id":"cl8ziiu5o000sl1db7ublg526","category_id":"cl8ziiu5v001ml1db5zuahsic","_id":"cl8ziiu5y0021l1dbdmtsg4o1"},{"post_id":"cl8ziiu5o000tl1db9beq3cnu","category_id":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu600026l1dbfqb888hd"},{"post_id":"cl8ziiu5p000wl1db702scjbi","category_id":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu61002al1db6nb837u3"},{"post_id":"cl8ziiu5p000xl1dbcnns5loh","category_id":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu62002el1db3v9l9yuo"},{"post_id":"cl8ziiu5q0011l1db1bz6hksk","category_id":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu66002nl1db1opue7k2"},{"post_id":"cl8ziiu5r0018l1db2chg7euc","category_id":"cl8ziiu66002ql1db5e4leuva","_id":"cl8ziiu67002wl1dbh6sj8usj"},{"post_id":"cl8ziiu5q0010l1dbcsg4h7gl","category_id":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu6f003hl1dbgerp7h8a"},{"post_id":"cl8ziiu5q0010l1dbcsg4h7gl","category_id":"cl8ziiu6f003fl1db1n288xoj","_id":"cl8ziiu6f003jl1dbdmbyh6v6"},{"post_id":"cl8ziiu62002cl1db6mfwbfrb","category_id":"cl8ziiu6f003gl1db42r76nom","_id":"cl8ziiu6f003kl1db83cq246t"},{"post_id":"cl8ziiu62002fl1db9cq5hxxw","category_id":"cl8ziiu6f003il1dbflv9bjmj","_id":"cl8ziiu6g003nl1db4mybc6g7"},{"post_id":"cl8ziiu63002hl1db4rvdhcsq","category_id":"cl8ziiu6f003il1dbflv9bjmj","_id":"cl8ziiu6g003pl1dbamgo576r"},{"post_id":"cl8ziiu65002jl1dbbitj2075","category_id":"cl8ziiu6f003il1dbflv9bjmj","_id":"cl8ziiu6g003rl1dbe6rn1wt8"},{"post_id":"cl8ziiu5r0014l1db5tooef1v","category_id":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu6h003tl1db0z5sfhum"},{"post_id":"cl8ziiu5r0014l1db5tooef1v","category_id":"cl8ziiu6f003fl1db1n288xoj","_id":"cl8ziiu6h003ul1db08b6h1ai"},{"post_id":"cl8ziiu65002kl1dbeglt5vyh","category_id":"cl8ziiu6f003il1dbflv9bjmj","_id":"cl8ziiu6h003vl1dbcyr144td"},{"post_id":"cl8ziiu5r0015l1dbhztp9z78","category_id":"cl8ziiu5x001xl1db6ev1bj8d","_id":"cl8ziiu6i003xl1dbgxncb7vy"},{"post_id":"cl8ziiu5r0015l1dbhztp9z78","category_id":"cl8ziiu6h003sl1db2zht1yxw","_id":"cl8ziiu6i003zl1db7uhjd9qq"},{"post_id":"cl8ziiu5s0019l1db1ebmh8n3","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6i0041l1db3mpe62z4"},{"post_id":"cl8ziiu5s0019l1db1ebmh8n3","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6i0042l1db6zqscmtf"},{"post_id":"cl8ziiu5t001dl1db1c1ohsrt","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6j0044l1db30fn1mm5"},{"post_id":"cl8ziiu5t001dl1db1c1ohsrt","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6j0045l1db3qhnd4cd"},{"post_id":"cl8ziiu5t001fl1db7p718mgy","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6j0047l1dbedh2a266"},{"post_id":"cl8ziiu5t001fl1db7p718mgy","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6j0048l1dbh8r4eck3"},{"post_id":"cl8ziiu5u001il1dbegjv1bjg","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6j004al1dbem4khpqc"},{"post_id":"cl8ziiu5u001il1dbegjv1bjg","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6j004bl1db68kfauv5"},{"post_id":"cl8ziiu5u001ll1db58473rqd","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6j004dl1db1ndwbtuh"},{"post_id":"cl8ziiu5u001ll1db58473rqd","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6k004el1dbgt4e454i"},{"post_id":"cl8ziiu5v001ol1db7rb9928v","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6k004gl1db18e87phy"},{"post_id":"cl8ziiu5v001ol1db7rb9928v","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6k004hl1db441r92jv"},{"post_id":"cl8ziiu5v001ql1db3emqacy9","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6k004jl1dbcmzufary"},{"post_id":"cl8ziiu5v001ql1db3emqacy9","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6k004kl1dbf5331fgn"},{"post_id":"cl8ziiu5w001sl1db71yhh1at","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6k004ml1db0ipfbiac"},{"post_id":"cl8ziiu5w001sl1db71yhh1at","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6k004nl1dbaepjd9cn"},{"post_id":"cl8ziiu5w001vl1db5458ffmh","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6k004pl1dbcunnezdd"},{"post_id":"cl8ziiu5w001vl1db5458ffmh","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6k004ql1db9b3c5nmg"},{"post_id":"cl8ziiu5x001wl1db5s5tfsjy","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6l004sl1dbgqdqcevn"},{"post_id":"cl8ziiu5x001wl1db5s5tfsjy","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6l004tl1db06f45o6f"},{"post_id":"cl8ziiu5x001zl1dbg4s02c6i","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6l004vl1db9nc028p1"},{"post_id":"cl8ziiu5x001zl1dbg4s02c6i","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6l004wl1db9ck2307m"},{"post_id":"cl8ziiu5y0020l1db741h340x","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6l004yl1dbfkzza4ob"},{"post_id":"cl8ziiu5y0020l1db741h340x","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6l004zl1dbal0ydqmv"},{"post_id":"cl8ziiu5z0023l1dbcih43hdo","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6l0051l1db50h19jbp"},{"post_id":"cl8ziiu5z0023l1dbcih43hdo","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6m0052l1db68dt8soj"},{"post_id":"cl8ziiu5z0024l1dbdxn0h52z","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6m0054l1dbbv9sf6ge"},{"post_id":"cl8ziiu5z0024l1dbdxn0h52z","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6m0055l1db3o37eph1"},{"post_id":"cl8ziiu600027l1dbbxe1a8is","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6m0057l1dbb6xicinm"},{"post_id":"cl8ziiu600027l1dbbxe1a8is","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6m0058l1db2uft7e0d"},{"post_id":"cl8ziiu600028l1db17cjayg0","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6n0059l1db4h5jcq3a"},{"post_id":"cl8ziiu600028l1db17cjayg0","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6n005al1dbdxigglxr"},{"post_id":"cl8ziiu61002bl1db3shnh1vk","category_id":"cl8ziiu67002tl1db9hx30i04","_id":"cl8ziiu6n005bl1db8tt0coun"},{"post_id":"cl8ziiu61002bl1db3shnh1vk","category_id":"cl8ziiu6h003wl1dbh6cjhvgk","_id":"cl8ziiu6n005cl1db96ou2b7b"},{"post_id":"cl8ziiu6o005dl1dbf2di6rpv","category_id":"cl8ziiu66002ql1db5e4leuva","_id":"cl8ziiu6p005fl1db7pendxbb"}],"PostTag":[{"post_id":"cl8ziiu5f0005l1db6lco6d8y","tag_id":"cl8ziiu5h0008l1db2ni18fgc","_id":"cl8ziiu5k000hl1db5psuf74e"},{"post_id":"cl8ziiu5i0009l1dbfmys5w82","tag_id":"cl8ziiu5k000el1db7wjrdhzm","_id":"cl8ziiu5m000nl1db998e0uyb"},{"post_id":"cl8ziiu5r0018l1db2chg7euc","tag_id":"cl8ziiu5s001al1db8oz1f1vk","_id":"cl8ziiu5u001jl1dbe7osfce2"},{"post_id":"cl8ziiu62002cl1db6mfwbfrb","tag_id":"cl8ziiu63002gl1dbdccrgku7","_id":"cl8ziiu66002ol1dbhv3s9clp"},{"post_id":"cl8ziiu62002fl1db9cq5hxxw","tag_id":"cl8ziiu65002ll1dbcj4ra8xx","_id":"cl8ziiu66002rl1db3pfraijw"},{"post_id":"cl8ziiu63002hl1db4rvdhcsq","tag_id":"cl8ziiu65002ll1dbcj4ra8xx","_id":"cl8ziiu67002ul1dbb2ywa17n"},{"post_id":"cl8ziiu65002jl1dbbitj2075","tag_id":"cl8ziiu65002ll1dbcj4ra8xx","_id":"cl8ziiu67002yl1dbg7k1fehc"},{"post_id":"cl8ziiu65002kl1dbeglt5vyh","tag_id":"cl8ziiu65002ll1dbcj4ra8xx","_id":"cl8ziiu6b0030l1db59tu1wly"},{"post_id":"cl8ziiu6o005dl1dbf2di6rpv","tag_id":"cl8ziiu5s001al1db8oz1f1vk","_id":"cl8ziiu6p005el1dbg49cdelj"}],"Tag":[{"name":"Docker","_id":"cl8ziiu5h0008l1db2ni18fgc"},{"name":"ansible","_id":"cl8ziiu5k000el1db7wjrdhzm"},{"name":"golang","_id":"cl8ziiu5s001al1db8oz1f1vk"},{"name":"Oracle","_id":"cl8ziiu63002gl1dbdccrgku7"},{"name":"非技术类","_id":"cl8ziiu65002ll1dbcj4ra8xx"}]}}