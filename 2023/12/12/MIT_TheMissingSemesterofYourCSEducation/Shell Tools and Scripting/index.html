
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CoffeeMan">
    <title>Shell Tools and Scripting - CoffeeMan</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://kirk-zhang58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg"},"articleBody":"MIT: The Missing Semester of Your CS Education\n\n\n\n\nShell Tools and Scriptinghttps://missing.csail.mit.edu/2020/shell-tools/\nIn this lecture, we will present some of the basics of using bash as a scripting language along with a number of shell tools that cover several of the most common tasks that you will be constantly performing in the command line.\nShell Scripting变量定义\n字符串可以是单引号也可以是双引号，定义变量可直接是A&#x3D;B这种形式,变量用双引号就不会转义(读取)。\nfoo&#x3D;bar\necho &quot;$foo&quot;\n# prints bar\necho &#39;$foo&#39;\n# prints $foo\n\nAs with most programming languages, bash supports control flow techniques \nshell逻辑控制语句\nincluding if, case, while and for. Similarly, bash has functions that take arguments and can operate with them. Here is an example of a function that creates a directory and cds into it.\nmcd () &#123;\n    mkdir -p &quot;$1&quot;\n    cd &quot;$1&quot;\n&#125;\n\n\nHere $1 is the first argument to the script&#x2F;function. Unlike other scripting languages, bash uses a variety of special variables to refer to arguments, error codes, and other relevant variables. Below is a list of some of them. A more comprehensive list can be found here.\n\n$0 - Name of the script\n$1 to $9 - Arguments to the script. $1 is the first argument and so on.\n$@ - All the arguments\n$# - Number of arguments\n$? - Return code of the previous command\n$$ - Process identification number (PID) for the current script\n!! - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing sudo !!\n$_ - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by . or Alt+.\n\n0 exit  successful , 1 exit unsuccessful \nExit codes can be used to conditionally execute commands using &amp;&amp; (and operator) and || (or operator), both of which are short-circuiting operators.\nCommands can also be separated within the same line using a semicolon ;. The true program will always have a 0 return code and the false command will always have a 1 return code. Let’s see some examples\n逻辑运算符\nfalse || echo &quot;Oops, fail&quot;\n# Oops, fail\n\ntrue || echo &quot;Will not be printed&quot;\n#\n\ntrue &amp;&amp; echo &quot;Things went well&quot;\n# Things went well\n\nfalse &amp;&amp; echo &quot;Will not be printed&quot;\n#\n\ntrue ; echo &quot;This will always run&quot;\n# This will always run\n\nfalse ; echo &quot;This will always run&quot;\n# This will always run\n\n\nAnother common pattern is wanting to get the output of a command as a variable. This can be done with command substitution. Whenever you place $( CMD ) it will execute CMD, get the output of the command and substitute it in place. For example, if you do for file in $(ls), the shell will first call ls and then iterate over those values. A lesser known similar feature is process substitution, &lt;( CMD ) will execute CMD and place the output in a temporary file and substitute the &lt;() with that file’s name. This is useful when commands expect values to be passed by file instead of by STDIN. For example, diff &lt;(ls foo) &lt;(ls bar) will show differences between files in dirs foo and bar.\nSince that was a huge information dump, let’s see an example that showcases some of these features. It will iterate through the arguments we provide, grep for the string foobar, and append it to the file as a comment if it’s not found.\n#!&#x2F;bin&#x2F;bash\n\necho &quot;Starting program at $(date)&quot; # Date will be substituted\n\necho &quot;Running program $0 with $# arguments with pid $$&quot;\n\nfor file in &quot;$@&quot;; do\n    grep foobar &quot;$file&quot; &gt; &#x2F;dev&#x2F;null 2&gt; &#x2F;dev&#x2F;null\n    # When pattern is not found, grep has exit status 1\n    # We redirect STDOUT and STDERR to a null register since we do not care about them\n    if [[ $? -ne 0 ]]; then\n        echo &quot;File $file does not have any foobar, adding one&quot;\n        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;\n    fi\ndone\n\n\nIn the comparison we tested whether $? was not equal to 0. Bash implements many comparisons of this sort - you can find a detailed list in the manpage for [test](https://www.man7.org/linux/man-pages/man1/test.1.html). \nWhen performing comparisons in bash, try to use double brackets [[ ]] in favor of simple brackets [ ]. Chances of making mistakes are lower although it won’t be portable to sh. A more detailed explanation can be found here.\nWhen launching scripts, you will often want to provide arguments that are similar. Bash has ways of making this easier, expanding expressions by carrying out filename expansion. These techniques are often referred to as shell globbing.\n\nWildcards - Whenever you want to perform some sort of wildcard matching, you can use ? and &#96;&#96; to match one or any amount of characters respectively. For instance, given files foo, foo1, foo2, foo10 and bar, the command rm foo? will delete foo1 and foo2 whereas rm foo* will delete all but bar. 我经常使用星号\nCurly braces &#123;&#125; - Whenever you have a common substring in a series of commands, you can use curly braces for bash to expand this automatically. This comes in very handy when moving or converting files. {} 意思是选择括号里面的任意一个，提供了灵活性\n\nconvert image.&#123;png,jpg&#125;\n# Will expand to\nconvert image.png image.jpg\n\ncp &#x2F;path&#x2F;to&#x2F;project&#x2F;&#123;foo,bar,baz&#125;.sh &#x2F;newpath\n# Will expand to\ncp &#x2F;path&#x2F;to&#x2F;project&#x2F;foo.sh &#x2F;path&#x2F;to&#x2F;project&#x2F;bar.sh &#x2F;path&#x2F;to&#x2F;project&#x2F;baz.sh &#x2F;newpath\n\n# Globbing techniques can also be combined\nmv *&#123;.py,.sh&#125; folder\n# Will move all *.py and *.sh files\n\nmkdir foo bar\n# This creates files foo&#x2F;a, foo&#x2F;b, ... foo&#x2F;h, bar&#x2F;a, bar&#x2F;b, ... bar&#x2F;h\ntouch &#123;foo,bar&#125;&#x2F;&#123;a..h&#125;\ntouch foo&#x2F;x bar&#x2F;y\n# Show differences between files in foo and bar\ndiff &lt;(ls foo) &lt;(ls bar)\n# Outputs\n# &lt; x\n# ---\n# &gt; y\n\n\nWriting bash scripts can be tricky and unintuitive. There are tools like shellcheck that will help you find errors in your sh&#x2F;bash scripts.\nNote that scripts need not necessarily be written in bash to be called from the terminal. For instance, here’s a simple Python script that outputs its arguments in reversed order:\n#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python\nimport sys\nfor arg in reversed(sys.argv[1:]):\n    print(arg)\n\n\nThe kernel knows to execute this script with a python interpreter instead of a shell command because we included a shebang line at the top of the script. It is good practice to write shebang lines using the [env](https://www.man7.org/linux/man-pages/man1/env.1.html) command that will resolve to wherever the command lives in the system, increasing the portability of your scripts. To resolve the location, env will make use of the PATH environment variable we introduced in the first lecture. For this example the shebang line would look like\n#!/usr/bin/env python. 在第一行写的东西叫shebang line,这里还可以用于python\nSome differences between shell functions and scripts that you should keep in mind are:\n\nFunctions have to be in the same language as the shell, while scripts can be written in any language. This is why including a shebang for scripts is important.\nFunctions are loaded once when their definition is read. Scripts are loaded every time they are executed. This makes functions slightly faster to load, but whenever you change them you will have to reload their definition.\nFunctions are executed in the current shell environment whereas scripts execute in their own process. Thus, functions can modify environment variables, e.g. change your current directory, whereas scripts can’t. Scripts will be passed by value environment variables that have been exported using [export](https://www.man7.org/linux/man-pages/man1/export.1p.html)\nAs with any programming language, functions are a powerful construct to achieve modularity, code reuse, and clarity of shell code. Often shell scripts will include their own function definitions.\n\nShell ToolsFinding how to use commands(man)At this point, you might be wondering how to find the flags for the commands in the aliasing section such as ls -l, mv -i and mkdir -p. More generally, given a command, how do you go about finding out what it does and its different options? You could always start googling, but since UNIX predates StackOverflow, there are built-in ways of getting this information.\nAs we saw in the shell lecture, the first-order approach is to call said command with the -h or --help flags. A more detailed approach is to use the man command. Short for manual, [man](https://www.man7.org/linux/man-pages/man1/man.1.html) provides a manual page (called manpage) for a command you specify. For example, man rm will output the behavior of the rm command along with the flags that it takes, including the -i flag we showed earlier. In fact, what I have been linking so far for every command is the online version of the Linux manpages for the commands. Even non-native commands that you install will have manpage entries if the developer wrote them and included them as part of the installation process. For interactive tools such as the ones based on ncurses, help for the commands can often be accessed within the program using the :help command or typing ?.\nSometimes manpages can provide overly detailed descriptions of the commands, making it hard to decipher what flags&#x2F;syntax to use for common use cases. TLDR pages are a nifty complementary solution that focuses on giving example use cases of a command so you can quickly figure out which options to use. For instance, I find myself referring back to the tldr pages for [tar](https://tldr.inbrowser.app/pages/common/tar) and [ffmpeg](https://tldr.inbrowser.app/pages/common/ffmpeg) way more often than the manpages.\nFinding files(find)One of the most common repetitive tasks that every programmer faces is finding files or directories. All UNIX-like systems come packaged with [find](https://www.man7.org/linux/man-pages/man1/find.1.html), a great shell tool to find files. find will recursively search for files matching some criteria. Some examples:\n# Find all directories named src\nfind . -name src -type d\n# Find all python files that have a folder named test in their path\nfind . -path &#39;*&#x2F;test&#x2F;*.py&#39; -type f\n# Find all files modified in the last day\nfind . -mtime -1\n# Find all zip files with size in range 500k to 10M\nfind . -size +500k -size -10M -name &#39;*.tar.gz&#39;\n\n\nBeyond listing files, find can also perform actions over files that match your query. This property can be incredibly helpful to simplify what could be fairly monotonous tasks.\n# Delete all files with .tmp extension\nfind . -name &#39;*.tmp&#39; -exec rm &#123;&#125; \\;\n# Find all PNG files and convert them to JPG\nfind . -name &#39;*.png&#39; -exec convert &#123;&#125; &#123;&#125;.jpg \\;\n\n\nDespite find’s ubiquitousness, its syntax can sometimes be tricky to remember. For instance, to simply find files that match some pattern PATTERN you have to execute find -name &#39;*PATTERN*&#39; (or -iname if you want the pattern matching to be case insensitive). You could start building aliases for those scenarios, but part of the shell philosophy is that it is good to explore alternatives. Remember, one of the best properties of the shell is that you are just calling programs, so you can find (or even write yourself) replacements for some. For instance, [fd](https://github.com/sharkdp/fd) is a simple, fast, and user-friendly alternative to find. It offers some nice defaults like colorized output, default regex matching, and Unicode support. It also has, in my opinion, a more intuitive syntax. For example, the syntax to find a pattern PATTERN is fd PATTERN.\nMost would agree that find and fd are good, but some of you might be wondering about the efficiency of looking for files every time versus compiling some sort of index or database for quickly searching. That is what [locate](https://www.man7.org/linux/man-pages/man1/locate.1.html) is for. locate uses a database that is updated using [updatedb](https://www.man7.org/linux/man-pages/man1/updatedb.1.html). In most systems, updatedb is updated daily via [cron](https://www.man7.org/linux/man-pages/man8/cron.8.html). Therefore one trade-off between the two is speed vs freshness. Moreover find and similar tools can also find files using attributes such as file size, modification time, or file permissions, while locate just uses the file name. A more in-depth comparison can be found here.\n&#123;&#125; 在 find 命令中的 -exec 选项里面有特殊的含义,它代表着 find 命令找到的匹配文件的文件名。\n它的意思是:\n\n在当前目录 . 下递归查找所有文件名匹配 .tmp 的文件\n对找到的每个匹配的文件,执行 rm &#123;&#125; 命令,即删除该文件\n\\; 表示 -exec 选项的参数结束\n\nFinding code(grep)Finding files by name is useful, but quite often you want to search based on file content. A common scenario is wanting to search for all files that contain some pattern, along with where in those files said pattern occurs. To achieve this, most UNIX-like systems provide [grep](https://www.man7.org/linux/man-pages/man1/grep.1.html), a generic tool for matching patterns from the input text. grep is an incredibly valuable shell tool that we will cover in greater detail during the data wrangling lecture.\nFor now, know that grep has many flags that make it a very versatile tool. Some I frequently use are -C for getting Context around the matching line and -v for inverting the match, i.e. print all lines that do not match the pattern. For example, grep -C 5 will print 5 lines before and after the match. When it comes to quickly searching through many files, you want to use -R since it will Recursively go into directories and look for files for the matching string.\nBut grep -R can be improved in many ways, such as ignoring .git folders, using multi CPU support, &amp;c. Many grep alternatives have been developed, including ack, ag and rg. All of them are fantastic and pretty much provide the same functionality. For now I am sticking with ripgrep (rg), given how fast and intuitive it is. Some examples:\n# Find all python files where I used the requests library\nrg -t py &#39;import requests&#39;\n# Find all files (including hidden files) without a shebang line\nrg -u --files-without-match &quot;^#\\!&quot;\n# Find all matches of foo and print the following 5 lines\nrg foo -A 5\n# Print statistics of matches (# of matched lines and files )\nrg --stats PATTERN\n\n\nNote that as with find&#x2F;fd, it is important that you know that these problems can be quickly solved using one of these tools, while the specific tools you use are not as important.\ngrep的具体使用\nrg and ack是grep的平替\nFinding shell commands history Ctrl+R 很有用，当方向查找曾经使用过的命令\n grep \n fzf   - sudo apt install fzf , 更多使用，详见文档\nOnce fzf is installed, you can use it in various ways in your Bash shell. Here are a few examples:\n\nInteractive Directory Navigation: You can use fzf to navigate through directories interactively. Run the following command in your terminal:\n  cd &quot;$(fzf)&quot;\nvim &quot;$(fzf)&quot;\n  This will open a fuzzy finder interface that allows you to select a directory to navigate to.\n\nFuzzy File Search: You can use fzf to search for files in a directory with fuzzy matching. Run the following command in your terminal:\n  fzf\n\n  This will open a fuzzy finder interface where you can type a pattern to search for files. Use the arrow keys to select a file and press Enter to open it.\n\nCommand History Search: You can use fzf to search through your command history and execute previous commands. Run the following command in your terminal:\n  fc -rl 1 | fzf | xargs -r -I&#123;&#125; sh -c &quot;&#123;&#125;&quot;\n\n  This will open a fuzzy finder interface where you can search for previous commands. Use the arrow keys to select a command and press Enter to execute it.\n\n\nThese are just a few examples of how you can use fzf in Bash. You can explore the fzf documentation and examples for more advanced usage and customization options.\nYou can modify your shell’s history behavior, like preventing commands with a leading space from being included. This comes in handy when you are typing commands with passwords or other bits of sensitive information. To do this, add HISTCONTROL=ignorespace to your .bashrc or setopt HIST_IGNORE_SPACE to your .zshrc. If you make the mistake of not adding the leading space, you can always manually remove the entry by editing your .bash_history or .zsh_history.\nDirectory Navigation就是cd命令\nSo far, we have assumed that you are already where you need to be to perform these actions. But how do you go about quickly navigating directories? There are many simple ways that you could do this, such as writing shell aliases or creating symlinks with ln -s, but the truth is that developers have figured out quite clever and sophisticated solutions by now.\nAs with the theme of this course, you often want to optimize for the common case. Finding frequent and&#x2F;or recent files and directories can be done through tools like [fasd](https://github.com/clvv/fasd) and [autojump](https://github.com/wting/autojump). Fasd ranks files and directories by frecency, that is, by both frequency and recency. By default, fasd adds a z command that you can use to quickly cd using a substring of a frecent directory. For example, if you often go to /home/user/files/cool_project you can simply use z cool to jump there. Using autojump, this same change of directory could be accomplished using j cool.\nMore complex tools exist to quickly get an overview of a directory structure: [tree](https://linux.die.net/man/1/tree), [broot](https://github.com/Canop/broot) or even full fledged file managers like [nnn](https://github.com/jarun/nnn) or [ranger](https://github.com/ranger/ranger).\nExercises\nRead [man ls](https://www.man7.org/linux/man-pages/man1/ls.1.html) and write an ls command that lists files in the following manner- Includes all files, including hidden files\n\n`ls -la`\n\n- Sizes are listed in human readable format (e.g. 454M instead of 454279954)\n\n`ls  --block-size=M -ltr`\n\n- Files are ordered by recency\n\n`ls -lrt`\n\n- Output is colorized\n\n`ls -lrt`\n\nA sample output would look like this\n\n-rw-r--r--   1 user group 1.1M Jan 14 09:53 baz\ndrwxr-xr-x   5 user group  160 Jan 14 09:53 .\n-rw-r--r--   1 user group  514 Jan 14 06:42 bar\n-rw-r--r--   1 user group 106M Jan 13 12:12 foo\ndrwx------+ 47 user group 1.5K Jan 12 18:08 ..\n    \n\n\nWrite bash functions marco and polo that do the following. Whenever you execute marco the current working directory should be saved in some manner, then when you execute polo, no matter what directory you are in, polo should cd you back to the directory where you executed marco. For ease of debugging you can write the code in a file marco.sh and (re)load the definitions to your shell by executing source marco.sh.\n\nSay you have a command that fails rarely. In order to debug it you need to capture its output but it can be time consuming to get a failure run. Write a bash script that runs the following script until it fails and captures its standard output and error streams to files and prints everything at the end. Bonus points if you can also report how many runs it took for the script to fail.\n#!&#x2F;usr&#x2F;bin&#x2F;env bash\n    \nn&#x3D;$(( RANDOM % 100 )) -- 数学运算\n    \nif [[ n -eq 42 ]]; then\n   echo &quot;Something went wrong&quot;\n   &gt;&amp;2 echo &quot;The error was using magic numbers&quot;\n   exit 1\nfi\n    \necho &quot;Everything went according to plan&quot;\n    \n\n#!/usr/bin/env bash 会去调用当前环境(environment)的bash解释器来执行脚本。\n#!/bin/bash 直接调用系统默认的bash解释器来执行脚本。\n#!/usr/bin/env bash 的优点是:\n\n它会在当前系统环境的PATH变量里查找bash解释器的位置,而不用硬编码指定路径。\n如果当前系统中有多个bash版本,它会调用最新版本的bash。\n如果当前系统中bash的位置不在默认的&#x2F;bin文件夹下,这样可以避免路径找不到的错误。\n增强了脚本的可移植性,如果脚本移动到另一个目录或系统,仍然可以找到bash解释器。\n\n#!/bin/bash 的优点是路径固定简单,但如果bash路径变化就可能导致找不到解释器。\n所以,#!/usr/bin/env bash 是更加智能和可移植的声明bash脚本的方式,建议使用它来取代#!\n\nAs we covered in the lecture find’s -exec can be very powerful for performing operations over the files we are searching for. However, what if we want to do something with all the files, like creating a zip file? As you have seen so far commands will take input from both arguments and STDIN. When piping commands(管道), we are connecting STDOUT to STDIN, but some commands like tar take inputs from arguments. To bridge this disconnect there’s the [xargs](https://www.man7.org/linux/man-pages/man1/xargs.1.html) command which will execute a command using STDIN as arguments. For example ls | xargs rm will delete the files in the current directory.\n Your task is to write a command that recursively finds all HTML files in the folder and makes a zip with them. Note that your command should work even if the files have spaces (hint: check -d flag for xargs).\n If you’re on macOS, note that the default BSD find is different from the one included in GNU coreutils. You can use -print0 on find and the -0 flag on xargs. As a macOS user, you should be aware that command-line utilities shipped with macOS may differ from the GNU counterparts; you can install the GNU versions if you like by using brew.\n\n(Advanced) Write a command or script to recursively find the most recently modified file in a directory. More generally, can you list all files by recency?\n\n\n","dateCreated":"2023-12-12T21:25:53+08:00","dateModified":"2023-12-12T21:34:46+08:00","datePublished":"2023-12-12T21:25:53+08:00","description":"MIT: The Missing Semester of Your CS Education","headline":"Shell Tools and Scripting","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://kirk-zhang58.github.io/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Shell%20Tools%20and%20Scripting/"},"publisher":{"@type":"Organization","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://kirk-zhang58.github.io/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Shell%20Tools%20and%20Scripting/"}</script>
    <meta name="description" content="MIT: The Missing Semester of Your CS Education">
<meta property="og:type" content="blog">
<meta property="og:title" content="Shell Tools and Scripting">
<meta property="og:url" content="https://kirk-zhang58.github.io/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Shell%20Tools%20and%20Scripting/index.html">
<meta property="og:site_name" content="CoffeeMan">
<meta property="og:description" content="MIT: The Missing Semester of Your CS Education">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-12-12T13:25:53.003Z">
<meta property="article:modified_time" content="2023-12-12T13:34:46.443Z">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://kirk-zhang58.github.io/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-enqn8ywxdrgzxevdhlfqryyhvgcrb9sbhlwpkdlid2ghnaolwkvd1xdhq21k.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CoffeeMan
        </a>
    </div>
    
        
            <a
                class="header-right-picture open-algolia-search"
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/SimonTeo58"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/11289672/simon-teo"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/shiming_kirk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/kirk-zhang-424935235/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/zxc741208584@qq.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Shell Tools and Scripting
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-12-12T21:25:53+08:00">
	
		    Dec 12, 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/linux/">linux</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>MIT: The Missing Semester of Your CS Education</p>
<span id="more"></span>

<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Shell-Tools-and-Scripting"><span class="toc-text">Shell Tools and Scripting</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shell-Scripting"><span class="toc-text">Shell Scripting</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shell-Tools"><span class="toc-text">Shell Tools</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding-how-to-use-commands-man"><span class="toc-text">Finding how to use commands(man)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding-files-find"><span class="toc-text">Finding files(find)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding-code-grep"><span class="toc-text">Finding code(grep)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding-shell-commands"><span class="toc-text">Finding shell commands</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Directory-Navigation"><span class="toc-text">Directory Navigation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercises"><span class="toc-text">Exercises</span></a></li></ol>

<h1 id="Shell-Tools-and-Scripting"><a href="#Shell-Tools-and-Scripting" class="headerlink" title="Shell Tools and Scripting"></a>Shell Tools and Scripting</h1><p><a target="_blank" rel="noopener" href="https://missing.csail.mit.edu/2020/shell-tools/">https://missing.csail.mit.edu/2020/shell-tools/</a></p>
<p>In this lecture, we will present some of the basics of using bash as a scripting language along with a number of shell tools that cover several of the most common tasks that you will be constantly performing in the command line.</p>
<h1 id="Shell-Scripting"><a href="#Shell-Scripting" class="headerlink" title="Shell Scripting"></a>Shell Scripting</h1><p>变量定义</p>
<p>字符串可以是单引号也可以是双引号，定义变量可直接是A&#x3D;B这种形式,变量用双引号就不会转义(读取)。</p>
<pre class="language-none"><code class="language-none">foo&#x3D;bar
echo &quot;$foo&quot;
# prints bar
echo &#39;$foo&#39;
# prints $foo</code></pre>

<p>As with most programming languages, bash supports control flow techniques </p>
<p>shell逻辑控制语句</p>
<p>including <code>if</code>, <code>case</code>, <code>while</code> and <code>for</code>. Similarly, <code>bash</code> has functions that take arguments and can operate with them. Here is an example of a function that creates a directory and <code>cd</code>s into it.</p>
<pre class="language-none"><code class="language-none">mcd () &#123;
    mkdir -p &quot;$1&quot;
    cd &quot;$1&quot;
&#125;
</code></pre>

<p>Here <code>$1</code> is the first argument to the script&#x2F;function. Unlike other scripting languages, bash uses a variety of special variables to refer to arguments, error codes, and other relevant variables. Below is a list of some of them. A more comprehensive list can be found <a target="_blank" rel="noopener" href="https://tldp.org/LDP/abs/html/special-chars.html">here</a>.</p>
<ul>
<li><code>$0</code> - Name of the script</li>
<li><code>$1</code> to <code>$9</code> - Arguments to the script. <code>$1</code> is the first argument and so on.</li>
<li><code>$@</code> - All the arguments</li>
<li><code>$#</code> - Number of arguments</li>
<li><code>$?</code> - Return code of the previous command</li>
<li><code>$$</code> - Process identification number (PID) for the current script</li>
<li><code>!!</code> - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing <code>sudo !!</code></li>
<li><code>$_</code> - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing <code>Esc</code> followed by <code>.</code> or <code>Alt+.</code></li>
</ul>
<p>0 exit  successful , 1 exit unsuccessful </p>
<p>Exit codes can be used to conditionally execute commands using <code>&amp;&amp;</code> (and operator) and <code>||</code> (or operator), both of which are <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuiting</a> operators.</p>
<p>Commands can also be separated within the same line using a semicolon <code>;</code>. The <code>true</code> program will always have a 0 return code and the <code>false</code> command will always have a 1 return code. Let’s see some examples</p>
<p>逻辑运算符</p>
<pre class="language-none"><code class="language-none">false || echo &quot;Oops, fail&quot;
# Oops, fail

true || echo &quot;Will not be printed&quot;
#

true &amp;&amp; echo &quot;Things went well&quot;
# Things went well

false &amp;&amp; echo &quot;Will not be printed&quot;
#

true ; echo &quot;This will always run&quot;
# This will always run

false ; echo &quot;This will always run&quot;
# This will always run
</code></pre>

<p>Another common pattern is wanting to get the output of a command as a variable. This can be done with <em>command substitution</em>. Whenever you place <code>$( CMD )</code> it will execute <code>CMD</code>, get the output of the command and substitute it in place. For example, if you do <code>for file in $(ls)</code>, the shell will first call <code>ls</code> and then iterate over those values. A lesser known similar feature is <em>process substitution</em>, <code>&lt;( CMD )</code> will execute <code>CMD</code> and place the output in a temporary file and substitute the <code>&lt;()</code> with that file’s name. This is useful when commands expect values to be passed by file instead of by STDIN. For example, <code>diff &lt;(ls foo) &lt;(ls bar)</code> will show differences between files in dirs <code>foo</code> and <code>bar</code>.</p>
<p>Since that was a huge information dump, let’s see an example that showcases some of these features. It will iterate through the arguments we provide, <code>grep</code> for the string <code>foobar</code>, and append it to the file as a comment if it’s not found.</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash

echo &quot;Starting program at $(date)&quot; # Date will be substituted

echo &quot;Running program $0 with $# arguments with pid $$&quot;

for file in &quot;$@&quot;; do
    grep foobar &quot;$file&quot; &gt; &#x2F;dev&#x2F;null 2&gt; &#x2F;dev&#x2F;null
    # When pattern is not found, grep has exit status 1
    # We redirect STDOUT and STDERR to a null register since we do not care about them
    if [[ $? -ne 0 ]]; then
        echo &quot;File $file does not have any foobar, adding one&quot;
        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;
    fi
done
</code></pre>

<p>In the comparison we tested whether <code>$?</code> was not equal to 0. Bash implements many comparisons of this sort - you can find a detailed list in the manpage for <code>[test](https://www.man7.org/linux/man-pages/man1/test.1.html)</code>. </p>
<p>When performing comparisons in bash, try to use double brackets <code>[[ ]]</code> in favor of simple brackets <code>[ ]</code>. Chances of making mistakes are lower although it won’t be portable to <code>sh</code>. A more detailed explanation can be found <a target="_blank" rel="noopener" href="http://mywiki.wooledge.org/BashFAQ/031">here</a>.</p>
<p>When launching scripts, you will often want to provide arguments that are similar. Bash has ways of making this easier, expanding expressions by carrying out filename expansion. These techniques are often referred to as shell <em>globbing</em>.</p>
<ul>
<li>Wildcards - Whenever you want to perform some sort of wildcard matching, you can use <code>?</code> and &#96;&#96; to match one or any amount of characters respectively. For instance, given files <code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> and <code>bar</code>, the command <code>rm foo?</code> will delete <code>foo1</code> and <code>foo2</code> whereas <code>rm foo*</code> will delete all but <code>bar</code>. 我经常使用星号</li>
<li>Curly braces <code>&#123;&#125;</code> - Whenever you have a common substring in a series of commands, you can use curly braces for bash to expand this automatically. This comes in very handy when moving or converting files. {} 意思是选择括号里面的任意一个，提供了灵活性</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">convert image.&#123;png,jpg&#125;
# Will expand to
convert image.png image.jpg

cp &#x2F;path&#x2F;to&#x2F;project&#x2F;&#123;foo,bar,baz&#125;.sh &#x2F;newpath
# Will expand to
cp &#x2F;path&#x2F;to&#x2F;project&#x2F;foo.sh &#x2F;path&#x2F;to&#x2F;project&#x2F;bar.sh &#x2F;path&#x2F;to&#x2F;project&#x2F;baz.sh &#x2F;newpath

# Globbing techniques can also be combined
mv *&#123;.py,.sh&#125; folder
# Will move all *.py and *.sh files

mkdir foo bar
# This creates files foo&#x2F;a, foo&#x2F;b, ... foo&#x2F;h, bar&#x2F;a, bar&#x2F;b, ... bar&#x2F;h
touch &#123;foo,bar&#125;&#x2F;&#123;a..h&#125;
touch foo&#x2F;x bar&#x2F;y
# Show differences between files in foo and bar
diff &lt;(ls foo) &lt;(ls bar)
# Outputs
# &lt; x
# ---
# &gt; y
</code></pre>

<p>Writing <code>bash</code> scripts can be tricky and unintuitive. There are tools like <a target="_blank" rel="noopener" href="https://github.com/koalaman/shellcheck">shellcheck</a> that will help you find errors in your sh&#x2F;bash scripts.</p>
<p>Note that scripts need not necessarily be written in bash to be called from the terminal. For instance, here’s a simple Python script that outputs its arguments in reversed order:</p>
<pre class="language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
</code></pre>

<p>The kernel knows to execute this script with a python interpreter instead of a shell command because we included a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a> line at the top of the script. It is good practice to write shebang lines using the <code>[env](https://www.man7.org/linux/man-pages/man1/env.1.html)</code> command that will resolve to wherever the command lives in the system, increasing the portability of your scripts. To resolve the location, <code>env</code> will make use of the <code>PATH</code> environment variable we introduced in the first lecture. For this example the shebang line would look like</p>
<p><code>#!/usr/bin/env python</code>. 在第一行写的东西叫shebang line,这里还可以用于python</p>
<p>Some differences between shell functions and scripts that you should keep in mind are:</p>
<ul>
<li>Functions have to be in the same language as the shell, while scripts can be written in any language. This is why including a shebang for scripts is important.</li>
<li>Functions are loaded once when their definition is read. Scripts are loaded every time they are executed. This makes functions slightly faster to load, but whenever you change them you will have to reload their definition.</li>
<li>Functions are executed in the current shell environment whereas scripts execute in their own process. Thus, functions can modify environment variables, e.g. change your current directory, whereas scripts can’t. Scripts will be passed by value environment variables that have been exported using <code>[export](https://www.man7.org/linux/man-pages/man1/export.1p.html)</code></li>
<li>As with any programming language, functions are a powerful construct to achieve modularity, code reuse, and clarity of shell code. Often shell scripts will include their own function definitions.</li>
</ul>
<h1 id="Shell-Tools"><a href="#Shell-Tools" class="headerlink" title="Shell Tools"></a>Shell Tools</h1><h2 id="Finding-how-to-use-commands-man"><a href="#Finding-how-to-use-commands-man" class="headerlink" title="Finding how to use commands(man)"></a>Finding how to use commands(man)</h2><p>At this point, you might be wondering how to find the flags for the commands in the aliasing section such as <code>ls -l</code>, <code>mv -i</code> and <code>mkdir -p</code>. More generally, given a command, how do you go about finding out what it does and its different options? You could always start googling, but since UNIX predates StackOverflow, there are built-in ways of getting this information.</p>
<p>As we saw in the shell lecture, the first-order approach is to call said command with the <code>-h</code> or <code>--help</code> flags. A more detailed approach is to use the <code>man</code> command. Short for manual, <code>[man](https://www.man7.org/linux/man-pages/man1/man.1.html)</code> provides a manual page (called manpage) for a command you specify. For example, <code>man rm</code> will output the behavior of the <code>rm</code> command along with the flags that it takes, including the <code>-i</code> flag we showed earlier. In fact, what I have been linking so far for every command is the online version of the Linux manpages for the commands. Even non-native commands that you install will have manpage entries if the developer wrote them and included them as part of the installation process. For interactive tools such as the ones based on ncurses, help for the commands can often be accessed within the program using the <code>:help</code> command or typing <code>?</code>.</p>
<p>Sometimes manpages can provide overly detailed descriptions of the commands, making it hard to decipher what flags&#x2F;syntax to use for common use cases. <a target="_blank" rel="noopener" href="https://tldr.sh/">TLDR pages</a> are a nifty complementary solution that focuses on giving example use cases of a command so you can quickly figure out which options to use. For instance, I find myself referring back to the tldr pages for <code>[tar](https://tldr.inbrowser.app/pages/common/tar)</code> and <code>[ffmpeg](https://tldr.inbrowser.app/pages/common/ffmpeg)</code> way more often than the manpages.</p>
<h2 id="Finding-files-find"><a href="#Finding-files-find" class="headerlink" title="Finding files(find)"></a>Finding files(find)</h2><p>One of the most common repetitive tasks that every programmer faces is finding files or directories. All UNIX-like systems come packaged with <code>[find](https://www.man7.org/linux/man-pages/man1/find.1.html)</code>, a great shell tool to find files. <code>find</code> will recursively search for files matching some criteria. Some examples:</p>
<pre class="language-none"><code class="language-none"># Find all directories named src
find . -name src -type d
# Find all python files that have a folder named test in their path
find . -path &#39;*&#x2F;test&#x2F;*.py&#39; -type f
# Find all files modified in the last day
find . -mtime -1
# Find all zip files with size in range 500k to 10M
find . -size +500k -size -10M -name &#39;*.tar.gz&#39;
</code></pre>

<p>Beyond listing files, find can also perform actions over files that match your query. This property can be incredibly helpful to simplify what could be fairly monotonous tasks.</p>
<pre class="language-none"><code class="language-none"># Delete all files with .tmp extension
find . -name &#39;*.tmp&#39; -exec rm &#123;&#125; \;
# Find all PNG files and convert them to JPG
find . -name &#39;*.png&#39; -exec convert &#123;&#125; &#123;&#125;.jpg \;
</code></pre>

<p>Despite <code>find</code>’s ubiquitousness, its syntax can sometimes be tricky to remember. For instance, to simply find files that match some pattern <code>PATTERN</code> you have to execute <code>find -name &#39;*PATTERN*&#39;</code> (or <code>-iname</code> if you want the pattern matching to be case insensitive). You could start building aliases for those scenarios, but part of the shell philosophy is that it is good to explore alternatives. Remember, one of the best properties of the shell is that you are just calling programs, so you can find (or even write yourself) replacements for some. For instance, <code>[fd](https://github.com/sharkdp/fd)</code> is a simple, fast, and user-friendly alternative to <code>find</code>. It offers some nice defaults like colorized output, default regex matching, and Unicode support. It also has, in my opinion, a more intuitive syntax. For example, the syntax to find a pattern <code>PATTERN</code> is <code>fd PATTERN</code>.</p>
<p>Most would agree that <code>find</code> and <code>fd</code> are good, but some of you might be wondering about the efficiency of looking for files every time versus compiling some sort of index or database for quickly searching. That is what <code>[locate](https://www.man7.org/linux/man-pages/man1/locate.1.html)</code> is for. <code>locate</code> uses a database that is updated using <code>[updatedb](https://www.man7.org/linux/man-pages/man1/updatedb.1.html)</code>. In most systems, <code>updatedb</code> is updated daily via <code>[cron](https://www.man7.org/linux/man-pages/man8/cron.8.html)</code>. Therefore one trade-off between the two is speed vs freshness. Moreover <code>find</code> and similar tools can also find files using attributes such as file size, modification time, or file permissions, while <code>locate</code> just uses the file name. A more in-depth comparison can be found <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">here</a>.</p>
<p><code>&#123;&#125;</code> 在 find 命令中的 -exec 选项里面有特殊的含义,它代表着 find 命令找到的匹配文件的文件名。</p>
<p>它的意思是:</p>
<ul>
<li>在当前目录 <code>.</code> 下递归查找所有文件名匹配 <code>.tmp</code> 的文件</li>
<li>对找到的每个匹配的文件,执行 <code>rm &#123;&#125;</code> 命令,即删除该文件</li>
<li><code>\;</code> 表示 -exec 选项的参数结束</li>
</ul>
<h2 id="Finding-code-grep"><a href="#Finding-code-grep" class="headerlink" title="Finding code(grep)"></a>Finding code(grep)</h2><p>Finding files by name is useful, but quite often you want to search based on file <em>content</em>. A common scenario is wanting to search for all files that contain some pattern, along with where in those files said pattern occurs. To achieve this, most UNIX-like systems provide <code>[grep](https://www.man7.org/linux/man-pages/man1/grep.1.html)</code>, a generic tool for matching patterns from the input text. <code>grep</code> is an incredibly valuable shell tool that we will cover in greater detail during the data wrangling lecture.</p>
<p>For now, know that <code>grep</code> has many flags that make it a very versatile tool. Some I frequently use are <code>-C</code> for getting <strong>C</strong>ontext around the matching line and <code>-v</code> for in<strong>v</strong>erting the match, i.e. print all lines that do <strong>not</strong> match the pattern. For example, <code>grep -C 5</code> will print 5 lines before and after the match. When it comes to quickly searching through many files, you want to use <code>-R</code> since it will <strong>R</strong>ecursively go into directories and look for files for the matching string.</p>
<p>But <code>grep -R</code> can be improved in many ways, such as ignoring <code>.git</code> folders, using multi CPU support, &amp;c. Many <code>grep</code> alternatives have been developed, including <a target="_blank" rel="noopener" href="https://github.com/beyondgrep/ack3">ack</a>, <a target="_blank" rel="noopener" href="https://github.com/ggreer/the_silver_searcher">ag</a> and <a target="_blank" rel="noopener" href="https://github.com/BurntSushi/ripgrep">rg</a>. All of them are fantastic and pretty much provide the same functionality. For now I am sticking with <code>ripgrep</code> (<code>rg</code>), given how fast and intuitive it is. Some examples:</p>
<pre class="language-none"><code class="language-none"># Find all python files where I used the requests library
rg -t py &#39;import requests&#39;
# Find all files (including hidden files) without a shebang line
rg -u --files-without-match &quot;^#\!&quot;
# Find all matches of foo and print the following 5 lines
rg foo -A 5
# Print statistics of matches (# of matched lines and files )
rg --stats PATTERN
</code></pre>

<p>Note that as with <code>find</code>&#x2F;<code>fd</code>, it is important that you know that these problems can be quickly solved using one of these tools, while the specific tools you use are not as important.</p>
<p>grep的具体使用</p>
<p>rg and ack是grep的平替</p>
<h2 id="Finding-shell-commands"><a href="#Finding-shell-commands" class="headerlink" title="Finding shell commands"></a>Finding shell commands</h2><p> <code>history</code> <code>Ctrl+R</code> 很有用，当方向查找曾经使用过的命令</p>
<p> <code>grep</code> </p>
<p> <code>fzf</code>   - sudo apt install fzf , 更多使用，详见文档</p>
<p>Once <code>fzf</code> is installed, you can use it in various ways in your Bash shell. Here are a few examples:</p>
<ul>
<li><p><strong>Interactive Directory Navigation</strong>: You can use <code>fzf</code> to navigate through directories interactively. Run the following command in your terminal:</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">cd &quot;$(fzf)&quot;
vim &quot;$(fzf)&quot;</code></pre>
<p>  This will open a fuzzy finder interface that allows you to select a directory to navigate to.</p>
</li>
<li><p><strong>Fuzzy File Search</strong>: You can use <code>fzf</code> to search for files in a directory with fuzzy matching. Run the following command in your terminal:</p>
  <pre class="language-none"><code class="language-none">fzf
</code></pre>
<p>  This will open a fuzzy finder interface where you can type a pattern to search for files. Use the arrow keys to select a file and press Enter to open it.</p>
</li>
<li><p><strong>Command History Search</strong>: You can use <code>fzf</code> to search through your command history and execute previous commands. Run the following command in your terminal:</p>
  <pre class="language-none"><code class="language-none">fc -rl 1 | fzf | xargs -r -I&#123;&#125; sh -c &quot;&#123;&#125;&quot;
</code></pre>
<p>  This will open a fuzzy finder interface where you can search for previous commands. Use the arrow keys to select a command and press Enter to execute it.</p>
</li>
</ul>
<p>These are just a few examples of how you can use <code>fzf</code> in Bash. You can explore the <code>fzf</code> documentation and examples for more advanced usage and customization options.</p>
<p>You can modify your shell’s history behavior, like preventing commands with a leading space from being included. This comes in handy when you are typing commands with passwords or other bits of sensitive information. To do this, add <code>HISTCONTROL=ignorespace</code> to your <code>.bashrc</code> or <code>setopt HIST_IGNORE_SPACE</code> to your <code>.zshrc</code>. If you make the mistake of not adding the leading space, you can always manually remove the entry by editing your <code>.bash_history</code> or <code>.zsh_history</code>.</p>
<h2 id="Directory-Navigation"><a href="#Directory-Navigation" class="headerlink" title="Directory Navigation"></a>Directory Navigation</h2><p>就是cd命令</p>
<p>So far, we have assumed that you are already where you need to be to perform these actions. But how do you go about quickly navigating directories? There are many simple ways that you could do this, such as writing shell aliases or creating symlinks with <a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man1/ln.1.html">ln -s</a>, but the truth is that developers have figured out quite clever and sophisticated solutions by now.</p>
<p>As with the theme of this course, you often want to optimize for the common case. Finding frequent and&#x2F;or recent files and directories can be done through tools like <code>[fasd](https://github.com/clvv/fasd)</code> and <code>[autojump](https://github.com/wting/autojump)</code>. Fasd ranks files and directories by <em><a target="_blank" rel="noopener" href="https://web.archive.org/web/20210421120120/https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm">frecency</a></em>, that is, by both <em>frequency</em> and <em>recency</em>. By default, <code>fasd</code> adds a <code>z</code> command that you can use to quickly <code>cd</code> using a substring of a <em>frecent</em> directory. For example, if you often go to <code>/home/user/files/cool_project</code> you can simply use <code>z cool</code> to jump there. Using autojump, this same change of directory could be accomplished using <code>j cool</code>.</p>
<p>More complex tools exist to quickly get an overview of a directory structure: <code>[tree](https://linux.die.net/man/1/tree)</code>, <code>[broot](https://github.com/Canop/broot)</code> or even full fledged file managers like <code>[nnn](https://github.com/jarun/nnn)</code> or <code>[ranger](https://github.com/ranger/ranger)</code>.</p>
<h1 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h1><ol>
<li>Read <code>[man ls](https://www.man7.org/linux/man-pages/man1/ls.1.html)</code> and write an <code>ls</code> command that lists files in the following manner<br>- Includes all files, including hidden files</li>
</ol>
<pre><code>`ls -la`

- Sizes are listed in human readable format (e.g. 454M instead of 454279954)

`ls  --block-size=M -ltr`

- Files are ordered by recency

`ls -lrt`

- Output is colorized

`ls -lrt`

A sample output would look like this

<pre class="language-none"><code class="language-none">-rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
drwxr-xr-x   5 user group  160 Jan 14 09:53 .
-rw-r--r--   1 user group  514 Jan 14 06:42 bar
-rw-r--r--   1 user group 106M Jan 13 12:12 foo
drwx------+ 47 user group 1.5K Jan 12 18:08 ..
    </code></pre>
</code></pre>
<ol start="2">
<li><p>Write bash functions <code>marco</code> and <code>polo</code> that do the following. Whenever you execute <code>marco</code> the current working directory should be saved in some manner, then when you execute <code>polo</code>, no matter what directory you are in, <code>polo</code> should <code>cd</code> you back to the directory where you executed <code>marco</code>. For ease of debugging you can write the code in a file <code>marco.sh</code> and (re)load the definitions to your shell by executing <code>source marco.sh</code>.</p>
</li>
<li><p>Say you have a command that fails rarely. In order to debug it you need to capture its output but it can be time consuming to get a failure run. Write a bash script that runs the following script until it fails and captures its standard output and error streams to files and prints everything at the end. Bonus points if you can also report how many runs it took for the script to fail.</p>
<pre class="language-none"><code class="language-none">#!&#x2F;usr&#x2F;bin&#x2F;env bash
    
n&#x3D;$(( RANDOM % 100 )) -- 数学运算
    
if [[ n -eq 42 ]]; then
   echo &quot;Something went wrong&quot;
   &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
   exit 1
fi
    
echo &quot;Everything went according to plan&quot;
    </code></pre>

<p><code>#!/usr/bin/env bash</code> 会去调用当前环境(environment)的bash解释器来执行脚本。</p>
<p><code>#!/bin/bash</code> 直接调用系统默认的bash解释器来执行脚本。</p>
<p><code>#!/usr/bin/env bash</code> 的优点是:</p>
<ol>
<li>它会在当前系统环境的PATH变量里查找bash解释器的位置,而不用硬编码指定路径。</li>
<li>如果当前系统中有多个bash版本,它会调用最新版本的bash。</li>
<li>如果当前系统中bash的位置不在默认的&#x2F;bin文件夹下,这样可以避免路径找不到的错误。</li>
<li>增强了脚本的可移植性,如果脚本移动到另一个目录或系统,仍然可以找到bash解释器。</li>
</ol>
<p><code>#!/bin/bash</code> 的优点是路径固定简单,但如果bash路径变化就可能导致找不到解释器。</p>
<p>所以,<code>#!/usr/bin/env bash</code> 是更加智能和可移植的声明bash脚本的方式,建议使用它来取代#!</p>
</li>
<li><p>As we covered in the lecture <code>find</code>’s <code>-exec</code> can be very powerful for performing operations over the files we are searching for. However, what if we want to do something with <strong>all</strong> the files, like creating a zip file? As you have seen so far commands will take input from both arguments and STDIN. When piping commands(管道), we are connecting STDOUT to STDIN, but some commands like <code>tar</code> take inputs from arguments. To bridge this disconnect there’s the <code>[xargs](https://www.man7.org/linux/man-pages/man1/xargs.1.html)</code> command <strong>which will execute a command using STDIN as arguments</strong>. For example <code>ls | xargs rm</code> will delete the files in the current directory.</p>
<p> Your task is to write a command that recursively finds all HTML files in the folder and makes a zip with them. Note that your command should work even if the files have spaces (hint: check <code>-d</code> flag for <code>xargs</code>).</p>
<p> If you’re on macOS, note that the default BSD <code>find</code> is different from the one included in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a>. You can use <code>-print0</code> on <code>find</code> and the <code>-0</code> flag on <code>xargs</code>. As a macOS user, you should be aware that command-line utilities shipped with macOS may differ from the GNU counterparts; you can install the GNU versions if you like by <a target="_blank" rel="noopener" href="https://formulae.brew.sh/formula/coreutils">using brew</a>.</p>
</li>
<li><p>(Advanced) Write a command or script to recursively find the most recently modified file in a directory. More generally, can you list all files by recency?</p>
</li>
</ol>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Security%20and%20Cryptography/"
                    data-tooltip="Security and Cryptography"
                    aria-label="PREVIOUS: Security and Cryptography"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Course%20overview/"
                    data-tooltip="Course overview + the shell"
                    aria-label="NEXT: Course overview + the shell"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://kirk-zhang58.github.io/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Shell%20Tools%20and%20Scripting/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Security%20and%20Cryptography/"
                    data-tooltip="Security and Cryptography"
                    aria-label="PREVIOUS: Security and Cryptography"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Course%20overview/"
                    data-tooltip="Course overview + the shell"
                    aria-label="NEXT: Course overview + the shell"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://kirk-zhang58.github.io/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Shell%20Tools%20and%20Scripting/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href=""
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.foo_bar.com/sharer/sharer.php?u=https://kirk-zhang58.github.io/2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Shell%20Tools%20and%20Scripting/"
                        aria-label="global.share_on_wechat"
                    >
                        <i class="fa-foo_bar" aria-hidden="true"></i><span>global.share_on_wechat</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Canton
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-rejca0yeyo8jtv4zo5d19sxydkf6sqbqktdggflqfhvi7djqtgunc35t58di.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'ca29b9a1203b5920918d',
              clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
              repo: 'SimonTeo58.github.io',
              owner: 'SimonTeo58',
              admin: ['SimonTeo58'],
              id: '2023/12/12/MIT_TheMissingSemesterofYourCSEducation/Shell Tools and Scripting/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
