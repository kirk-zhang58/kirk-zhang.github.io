<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>go语言圣经 | Eden</title>
  <meta name="keywords" content=" golang ">
  <meta name="description" content="go语言圣经 | Eden">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="二.Students’ Guide to Raf文档 背景 实现raft 重要的细节   Debugging Raft 活锁 不正确的RPC 没有按照论文的理论实现raft term混乱(term不稳定) 优化   Applications on top of Raft AppendIndex    二.Students’ Guide to Raf文档 https:&#x2F;&#x2F;thesquareplan">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.824之lab2_raft_guide">
<meta property="og:url" content="https://simonteo58.github.io/2022/10/05/MIT6.824/lab2_raft_guide/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:description" content="二.Students’ Guide to Raf文档 背景 实现raft 重要的细节   Debugging Raft 活锁 不正确的RPC 没有按照论文的理论实现raft term混乱(term不稳定) 优化   Applications on top of Raft AppendIndex    二.Students’ Guide to Raf文档 https:&#x2F;&#x2F;thesquareplan">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-05T12:21:56.280Z">
<meta property="article:modified_time" content="2022-10-05T12:38:05.080Z">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>kirkzhang</span>
</div>

<div class="icon">
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(42)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="CPP">
                        
                        CPP
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="非技术类">
                        
                        非技术类
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="分布式">
                        <i class="fold iconfont icon-right"></i>
                        
                        分布式
                        <small>(3)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="分布式<--->MIT6.824">
                                        
                                        MIT6.824
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据结构">
                        
                        数据结构
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="archive">
                        <i class="fold iconfont icon-right"></i>
                        
                        archive
                        <small>(6)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="archive<--->非技术类">
                                        
                                        非技术类
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="archive<--->golang">
                                        
                                        golang
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="CICD">
                        
                        CICD
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="golang">
                        
                        golang
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="leetcode">
                        <i class="fold iconfont icon-right"></i>
                        
                        leetcode
                        <small>(17)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="leetcode<--->leetcode题解">
                                        
                                        leetcode题解
                                        
                                            <small>(17
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="linux">
                        
                        linux
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="Oracle">
                        
                        Oracle
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="TED">
                        
                        TED
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="WEB API">
                        
                        WEB API
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  "
               target="_blank"
                    
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="42">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="/null">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>非技术类</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ansible</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>golang</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Oracle</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All 分布式 MIT6.824 "
           href="/2022/10/05/MIT6.824/lab2_raft_guide/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MIT6.824之lab2_raft_guide">MIT6.824之lab2_raft_guide</span>
            <span class="post-date" title="2022-10-05 20:21:56">2022/10/05</span>
        </a>
        
        <a  class="All archive 非技术类 "
           href="/2022/09/26/archive/%E8%B4%B9%E6%9B%BC:%E4%BB%BB%E4%BD%95%E4%BC%9F%E5%A4%A7%E7%9A%84%E7%A7%91%E5%AD%A6%E6%88%90%E5%B0%B1%E9%83%BD%E6%BA%90%E4%BA%8E%E6%80%9D%E6%83%B3%E8%87%AA%E7%94%B1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="费曼:任何伟大的科学成就，都源于思想自由">费曼:任何伟大的科学成就，都源于思想自由</span>
            <span class="post-date" title="2022-09-26 00:05:55">2022/09/26</span>
        </a>
        
        <a  class="All archive golang "
           href="/2022/09/09/archive/golang_concurrency_map/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="concurreny-map代码阅读">concurreny-map代码阅读</span>
            <span class="post-date" title="2022-09-09 16:43:34">2022/09/09</span>
        </a>
        
        <a  class="All "
           href="/2022/09/09/pro_git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="pro_git">pro_git</span>
            <span class="post-date" title="2022-09-09 12:21:02">2022/09/09</span>
        </a>
        
        <a  class="All Oracle "
           href="/2022/08/31/oracle/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA_Oracle_DBA_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E8%AF%8A%E6%96%AD%E6%A1%88%E4%BE%8B/"
           data-tag="Oracle"
           data-author="" >
            <span class="post-title" title="深入浅出_Oracle_DBA_入门_进阶与诊断案例">深入浅出_Oracle_DBA_入门_进阶与诊断案例</span>
            <span class="post-date" title="2022-08-31 17:35:04">2022/08/31</span>
        </a>
        
        <a  class="All archive "
           href="/2022/08/27/archive/Api%E6%95%B0%E6%8D%AE%E8%87%AA%E5%8A%A8%E5%85%A5%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="API数据自动入库">API数据自动入库</span>
            <span class="post-date" title="2022-08-27 13:35:51">2022/08/27</span>
        </a>
        
        <a  class="All archive golang "
           href="/2022/08/26/archive/%E5%86%85%E5%AD%98%E9%AB%98%E6%95%88golang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="内存高效golang">内存高效golang</span>
            <span class="post-date" title="2022-08-26 21:18:06">2022/08/26</span>
        </a>
        
        <a  class="All archive "
           href="/2022/08/26/archive/remote_github/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="更新origin 和upstream url链接">更新origin 和upstream url链接</span>
            <span class="post-date" title="2022-08-26 21:14:30">2022/08/26</span>
        </a>
        
        <a  class="All 分布式 MIT6.824 "
           href="/2022/08/12/MIT6.824/lab2_raft_paper/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MIT6.824之lab2_raft_paper">MIT6.824之lab2_raft_paper</span>
            <span class="post-date" title="2022-08-12 21:57:38">2022/08/12</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/08/04/non_IT/%E5%A4%9A%E5%B7%B4%E8%83%BA%E6%88%92%E6%96%AD/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="多巴胺戒断">多巴胺戒断</span>
            <span class="post-date" title="2022-08-04 23:08:38">2022/08/04</span>
        </a>
        
        <a  class="All 分布式 "
           href="/2022/07/26/SAF_mechanism/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SAF mechanism replication">SAF mechanism replication</span>
            <span class="post-date" title="2022-07-26 17:00:17">2022/07/26</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/07/14/non_IT/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="禅与摩托车维修艺术">禅与摩托车维修艺术</span>
            <span class="post-date" title="2022-07-14 08:37:05">2022/07/14</span>
        </a>
        
        <a  class="All 数据结构 "
           href="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构讲义">数据结构讲义</span>
            <span class="post-date" title="2022-07-12 23:27:09">2022/07/12</span>
        </a>
        
        <a  class="All archive "
           href="/2022/06/24/archive/archive/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="手册阅读归档">手册阅读归档</span>
            <span class="post-date" title="2022-06-24 06:54:11">2022/06/24</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="13.罗马数字转整数">13.罗马数字转整数</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="14.最长公共前缀">14.最长公共前缀</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="20.有效的括号">20.有效的括号</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="21.合并两个有序链表">21.合并两个有序链表</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="27.移除元素">27.移除元素</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/28.%E5%AE%9E%E7%8E%B0-str-str/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="28.实现 strStr()">28.实现 strStr()</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="35.搜索插入位置">35.搜索插入位置</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="53.最大子数组和">53.最大子数组和</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/58.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="58.最后一个单词的长度">58.最后一个单词的长度</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/66.%E5%8A%A0%E4%B8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="66.加一">66.加一</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/67.%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="67.二进制的求和">67.二进制的求和</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/69.x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="69.x-的平方根">69.x-的平方根</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="70.爬楼梯">70.爬楼梯</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/83.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="83.删除排序链表中的重复元素">83.删除排序链表中的重复元素</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="88.合并两个有序数组">88.合并两个有序数组</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/9.%E5%9B%9E%E6%96%87%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="9.回文数">9.回文数</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="94.二叉树的中序排序">94.二叉树的中序排序</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All TED "
           href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%B8%93%E6%B3%A8%E5%8A%9B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何提高专注力-How to Get Your Brain to Focus-TED">如何提高专注力-How to Get Your Brain to Focus-TED</span>
            <span class="post-date" title="2022-06-22 23:10:43">2022/06/22</span>
        </a>
        
        <a  class="All 算法 "
           href="/2022/06/22/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="算法导论">算法导论</span>
            <span class="post-date" title="2022-06-22 22:07:23">2022/06/22</span>
        </a>
        
        <a  class="All TED "
           href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何阅读-TED">如何阅读-TED</span>
            <span class="post-date" title="2022-06-22 22:05:35">2022/06/22</span>
        </a>
        
        <a  class="All WEB API "
           href="/2022/06/22/API_design%E5%8E%9F%E5%88%99/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="API Design Patterns">API Design Patterns</span>
            <span class="post-date" title="2022-06-22 21:55:02">2022/06/22</span>
        </a>
        
        <a  class="All linux "
           href="/2022/06/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%88%87shell%E8%85%B3%E6%9C%AC%E7%B7%A8%E7%A8%8B%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux命令行与shell腳本編程大全">Linux命令行与shell腳本編程大全</span>
            <span class="post-date" title="2022-06-22 21:53:01">2022/06/22</span>
        </a>
        
        <a  class="All golang "
           href="/2022/06/22/golang/go%E5%9C%A3%E7%BB%8F/"
           data-tag="golang"
           data-author="" >
            <span class="post-title" title="go语言圣经">go语言圣经</span>
            <span class="post-date" title="2022-06-22 21:16:20">2022/06/22</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/06/22/non_IT/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%BB%E7%A0%94%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="如何在读研的道路上快速失败">如何在读研的道路上快速失败</span>
            <span class="post-date" title="2022-06-22 21:14:38">2022/06/22</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/06/22/non_IT/%E4%BB%8E0%E5%88%B01_%E5%BC%80%E5%90%AF%E5%95%86%E4%B8%9A%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%98%E5%AF%86/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="从0到1:开启商业与未来的秘密">从0到1:开启商业与未来的秘密</span>
            <span class="post-date" title="2022-06-22 20:51:26">2022/06/22</span>
        </a>
        
        <a  class="All CICD "
           href="/2022/06/22/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="docker从入门到实践">docker从入门到实践</span>
            <span class="post-date" title="2022-06-22 20:47:28">2022/06/22</span>
        </a>
        
        <a  class="All CICD "
           href="/2022/06/22/%E5%A5%94%E8%B7%91%E5%90%A7ansible/"
           data-tag="ansible"
           data-author="" >
            <span class="post-title" title="奔跑吧ansible">奔跑吧ansible</span>
            <span class="post-date" title="2022-06-22 20:45:28">2022/06/22</span>
        </a>
        
        <a  class="All CPP "
           href="/2022/06/22/C++_Primer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++ Primer Plus">C++ Primer Plus</span>
            <span class="post-date" title="2022-06-22 01:01:03">2022/06/22</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-golang/go圣经" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">go语言圣经</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="golang">golang</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">golang</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-10-05 21:41:57'>2022-06-22 21:16</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%85%A5%E9%97%A8"><span class="toc-text">1. 入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">2. 程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%91%BD%E5%90%8D"><span class="toc-text">2.1 命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A3%B0%E6%98%8E"><span class="toc-text">2.2 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%8F%98%E9%87%8F"><span class="toc-text">2.3 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E7%AE%80%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">2.3.1 简短变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%8C%87%E9%92%88"><span class="toc-text">2.3.2 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-new%E5%87%BD%E6%95%B0"><span class="toc-text">2.3.3 new函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2.3.4. 变量的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%B5%8B%E5%80%BC"><span class="toc-text">2.4 赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC"><span class="toc-text">2.4.1 元组赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.5 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-text">2.6 包和文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2.7. 作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%95%B4%E5%9E%8B"><span class="toc-text">3.1 整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">3.2 浮点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%A4%8D%E6%95%B0"><span class="toc-text">3.3 复数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.4 布尔类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3.5 字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. 复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%95%B0%E7%BB%84"><span class="toc-text">4.1 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-slice"><span class="toc-text">4.2 slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-append%E5%87%BD%E6%95%B0"><span class="toc-text">4.2.1 append函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Map"><span class="toc-text">4.3 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">4.4 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-text">4.4.1 结构体字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">4.4.2 结构体的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98"><span class="toc-text">4.4.3 结构体嵌入和匿名成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-json%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.5 json字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%96%87%E6%9C%AC%E5%92%8CHTML%E6%A8%A1%E6%9D%BF"><span class="toc-text">4.6 文本和HTML模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0"><span class="toc-text">5. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%94%99%E8%AF%AF"><span class="toc-text">5.1 错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%87%BD%E6%95%B0%E5%80%BC"><span class="toc-text">5.2 函数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">5.3 匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">5.4 可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-defer%E5%87%BD%E6%95%B0"><span class="toc-text">5.5 defer函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-panic%E5%BC%82%E5%B8%B8"><span class="toc-text">5.6 panic异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-Recovery%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-text">5.7 Recovery捕获异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95"><span class="toc-text">6. 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E"><span class="toc-text">6.1 方法声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6.2 基于指针对象的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">6.3. 通过嵌入结构体来扩展类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%B0%81%E8%A3%85"><span class="toc-text">6.4 封装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3"><span class="toc-text">7. 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A"><span class="toc-text">7.1. 接口约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.2 接口类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">7.3 实现接口的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-flag-Value%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.4 flag.Value接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="toc-text">7.5 接口值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-sort-Interface%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.6. sort.Interface接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-http-Handler%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.7. http.Handler接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-error%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.8. error接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">7.9. 类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-10-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.10. 基于类型断言区别错误类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-any%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">7.11. any关键字与泛型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Goroutines%E5%92%8CChannels"><span class="toc-text">8. Goroutines和Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-goroutine"><span class="toc-text">8.1 goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-channel"><span class="toc-text">8.2 channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">8.3 基于select的多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%80%E5%87%BA"><span class="toc-text">8.4. 并发的退出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="toc-text">9. 基于共享变量的并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-sync-Mutex%E4%B8%8Esync-RMutex%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">9.1 sync.Mutex与sync.RMutex互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-sync-Once%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">9.2 sync.Once惰性初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-sync-Cond%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">9.3 sync.Cond的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-Goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">9.4. Goroutines和线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">10. 包和工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%B5%8B%E8%AF%95"><span class="toc-text">11. 测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-go-test"><span class="toc-text">11.1 go test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-text">11.2 测试覆盖率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-text">11.3 基准测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E5%88%A8%E6%9E%90"><span class="toc-text">11.4 刨析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0"><span class="toc-text">11.5 示例函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-appendIndex"><span class="toc-text">12. appendIndex</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-%E5%85%A5%E9%97%A8">1. 入门</a></li>
<li><a href="#2-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84">2. 程序结构</a><ul>
<li><a href="#21-%E5%91%BD%E5%90%8D">2.1 命名</a></li>
<li><a href="#22-%E5%A3%B0%E6%98%8E">2.2 声明</a></li>
<li><a href="#23-%E5%8F%98%E9%87%8F">2.3 变量</a><ul>
<li><a href="#231-%E7%AE%80%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">2.3.1 简短变量声明</a></li>
<li><a href="#232-%E6%8C%87%E9%92%88">2.3.2 指针</a></li>
<li><a href="#233-new%E5%87%BD%E6%95%B0">2.3.3 new函数</a></li>
<li><a href="#234-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">2.3.4. 变量的生命周期</a></li>
</ul>
</li>
<li><a href="#24-%E8%B5%8B%E5%80%BC">2.4 赋值</a><ul>
<li><a href="#241-%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC">2.4.1 元组赋值</a></li>
</ul>
</li>
<li><a href="#25-%E7%B1%BB%E5%9E%8B">2.5 类型</a></li>
<li><a href="#26-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6">2.6 包和文件</a></li>
<li><a href="#27-%E4%BD%9C%E7%94%A8%E5%9F%9F">2.7. 作用域</a></li>
</ul>
</li>
<li><a href="#3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">3.基础数据类型</a><ul>
<li><a href="#31-%E6%95%B4%E5%9E%8B">3.1 整型</a></li>
<li><a href="#32-%E6%B5%AE%E7%82%B9%E6%95%B0">3.2 浮点数</a></li>
<li><a href="#33-%E5%A4%8D%E6%95%B0">3.3 复数</a></li>
<li><a href="#34-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">3.4 布尔类型</a></li>
<li><a href="#35-%E5%AD%97%E7%AC%A6%E4%B8%B2">3.5 字符串</a></li>
</ul>
</li>
<li><a href="#4-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4. 复合数据类型</a><ul>
<li><a href="#41-%E6%95%B0%E7%BB%84">4.1 数组</a></li>
<li><a href="#42-slice">4.2 slice</a><ul>
<li><a href="#421-append%E5%87%BD%E6%95%B0">4.2.1 append函数</a></li>
</ul>
</li>
<li><a href="#43-map">4.3 Map</a></li>
<li><a href="#44-%E7%BB%93%E6%9E%84%E4%BD%93">4.4 结构体</a><ul>
<li><a href="#441-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E5%80%BC">4.4.1 结构体字面值</a></li>
<li><a href="#442-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%AF%94%E8%BE%83">4.4.2 结构体的比较</a></li>
<li><a href="#443-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98">4.4.3 结构体嵌入和匿名成员</a></li>
</ul>
</li>
<li><a href="#45-json%E5%AD%97%E7%AC%A6%E4%B8%B2">4.5 json字符串</a></li>
<li><a href="#46-%E6%96%87%E6%9C%AC%E5%92%8Chtml%E6%A8%A1%E6%9D%BF">4.6 文本和HTML模板</a></li>
</ul>
</li>
<li><a href="#5-%E5%87%BD%E6%95%B0">5. 函数</a><ul>
<li><a href="#51-%E9%94%99%E8%AF%AF">5.1 错误</a></li>
<li><a href="#52-%E5%87%BD%E6%95%B0%E5%80%BC">5.2 函数值</a></li>
<li><a href="#53-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">5.3 匿名函数</a></li>
<li><a href="#54-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">5.4 可变参数</a></li>
<li><a href="#55-defer%E5%87%BD%E6%95%B0">5.5 defer函数</a></li>
<li><a href="#56-panic%E5%BC%82%E5%B8%B8">5.6 panic异常</a></li>
<li><a href="#57-recovery%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">5.7 Recovery捕获异常</a></li>
</ul>
</li>
<li><a href="#6-%E6%96%B9%E6%B3%95">6. 方法</a><ul>
<li><a href="#61-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E">6.1 方法声明</a></li>
<li><a href="#62-%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">6.2 基于指针对象的方法</a></li>
<li><a href="#63-%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B">6.3. 通过嵌入结构体来扩展类型</a></li>
<li><a href="#64-%E5%B0%81%E8%A3%85">6.4 封装</a></li>
</ul>
</li>
<li><a href="#7-%E6%8E%A5%E5%8F%A3">7. 接口</a><ul>
<li><a href="#71-%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A">7.1. 接口约定</a></li>
<li><a href="#72-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B">7.2 接口类型</a></li>
<li><a href="#73-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6">7.3 实现接口的条件</a></li>
<li><a href="#74-flagvalue%E6%8E%A5%E5%8F%A3">7.4 flag.Value接口</a></li>
<li><a href="#75-%E6%8E%A5%E5%8F%A3%E5%80%BC">7.5 接口值</a></li>
<li><a href="#76-sortinterface%E6%8E%A5%E5%8F%A3">7.6. sort.Interface接口</a></li>
<li><a href="#77-httphandler%E6%8E%A5%E5%8F%A3">7.7. http.Handler接口</a></li>
<li><a href="#78-error%E6%8E%A5%E5%8F%A3">7.8. error接口</a></li>
<li><a href="#79-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">7.9. 类型断言</a></li>
<li><a href="#710-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">7.10. 基于类型断言区别错误类型</a></li>
<li><a href="#711-any%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%B3%9B%E5%9E%8B">7.11. any关键字与泛型</a></li>
</ul>
</li>
<li><a href="#8-goroutines%E5%92%8Cchannels">8. Goroutines和Channels</a><ul>
<li><a href="#81-goroutine">8.1 goroutine</a></li>
<li><a href="#82-channel">8.2 channel</a></li>
<li><a href="#83-%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">8.3 基于select的多路复用</a></li>
<li><a href="#84-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%80%E5%87%BA">8.4. 并发的退出</a></li>
</ul>
</li>
<li><a href="#9-%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91">9. 基于共享变量的并发</a><ul>
<li><a href="#91-syncmutex%E4%B8%8Esyncrmutex%E4%BA%92%E6%96%A5%E9%94%81">9.1 sync.Mutex与sync.RMutex互斥锁</a></li>
<li><a href="#92-synconce%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96">9.2 sync.Once惰性初始化</a></li>
<li><a href="#93-synccond%E7%9A%84%E4%BD%BF%E7%94%A8">9.3 sync.Cond的使用</a></li>
<li><a href="#94-goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B">9.4. Goroutines和线程</a></li>
</ul>
</li>
<li><a href="#10-%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7">10. 包和工具</a></li>
<li><a href="#11-%E6%B5%8B%E8%AF%95">11. 测试</a><ul>
<li><a href="#111-go-test">11.1 go test</a></li>
<li><a href="#112-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87">11.2 测试覆盖率</a></li>
<li><a href="#113-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">11.3 基准测试</a></li>
<li><a href="#114-%E5%88%A8%E6%9E%90">11.4 刨析</a></li>
<li><a href="#115-%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0">11.5 示例函数</a></li>
</ul>
</li>
<li><a href="#12-appendindex">12. appendIndex</a></li>
</ul>
<h1 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h1><h1 id="2-程序结构"><a href="#2-程序结构" class="headerlink" title="2. 程序结构"></a>2. 程序结构</h1><h2 id="2-1-命名"><a href="#2-1-命名" class="headerlink" title="2.1 命名"></a>2.1 命名</h2><table>
<thead>
<tr>
<th>功能性关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td></td>
</tr>
<tr>
<td>case</td>
<td></td>
</tr>
<tr>
<td>chan</td>
<td></td>
</tr>
<tr>
<td>const</td>
<td></td>
</tr>
<tr>
<td>continue</td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
</tr>
<tr>
<td>defer</td>
<td></td>
</tr>
<tr>
<td>else</td>
<td></td>
</tr>
<tr>
<td>fallthrough</td>
<td></td>
</tr>
<tr>
<td>for</td>
<td></td>
</tr>
<tr>
<td>func</td>
<td></td>
</tr>
<tr>
<td>go</td>
<td></td>
</tr>
<tr>
<td>if</td>
<td></td>
</tr>
<tr>
<td>import</td>
<td></td>
</tr>
<tr>
<td>interface</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td></td>
</tr>
<tr>
<td>package</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td></td>
</tr>
<tr>
<td>return</td>
<td></td>
</tr>
<tr>
<td>select</td>
<td></td>
</tr>
<tr>
<td>struct</td>
<td></td>
</tr>
<tr>
<td>switch</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td></td>
</tr>
<tr>
<td>var</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内建常量</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td></td>
</tr>
<tr>
<td>iota</td>
<td></td>
</tr>
<tr>
<td>nil</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内建类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td></td>
</tr>
<tr>
<td>int8</td>
<td></td>
</tr>
<tr>
<td>int16</td>
<td></td>
</tr>
<tr>
<td>int32</td>
<td></td>
</tr>
<tr>
<td>int64</td>
<td></td>
</tr>
<tr>
<td>uint</td>
<td></td>
</tr>
<tr>
<td>uint8</td>
<td></td>
</tr>
<tr>
<td>uint16</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td></td>
</tr>
<tr>
<td>uint64</td>
<td></td>
</tr>
<tr>
<td>uintptr</td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td></td>
</tr>
<tr>
<td>float64</td>
<td></td>
</tr>
<tr>
<td>complex128</td>
<td></td>
</tr>
<tr>
<td>complex64</td>
<td></td>
</tr>
<tr>
<td>bool</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>rune</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td></td>
</tr>
<tr>
<td>error</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>make</td>
<td></td>
</tr>
<tr>
<td>len</td>
<td></td>
</tr>
<tr>
<td>cap</td>
<td></td>
</tr>
<tr>
<td>new</td>
<td></td>
</tr>
<tr>
<td>append</td>
<td></td>
</tr>
<tr>
<td>copy</td>
<td></td>
</tr>
<tr>
<td>close</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td></td>
</tr>
<tr>
<td>complex</td>
<td></td>
</tr>
<tr>
<td>real</td>
<td></td>
</tr>
<tr>
<td>imag</td>
<td></td>
</tr>
<tr>
<td>panic</td>
<td></td>
</tr>
<tr>
<td>recover</td>
<td></td>
</tr>
</tbody></table>
<p>Go推荐使用<code>驼峰式</code>命名:</p>
<ul>
<li>一个名字必须以一个字母（Unicode字母）或下划线开头,下划线开头可能表示<code>私有的</code></li>
<li>后面可以跟任意数量的字母、数字或下划线。</li>
<li>名字的开头字母的大小写决定了名字在包外的可见性.如果一个名字是大写字母开头的(译注必须是 在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将是导出的,也就是说可以被外部的包访问,例如<code>fmt.Printf</code>,就可以在包外访问</li>
</ul>
<h2 id="2-2-声明"><a href="#2-2-声明" class="headerlink" title="2.2 声明"></a>2.2 声明</h2><p>Go语言主要有四种类型的声明语句:</p>
<ul>
<li>var</li>
<li>const</li>
<li>type</li>
<li>func</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

const boilingF &#x3D; 212.0
const var a &#x3D; 0

func main() &#123;
    var f &#x3D; boilingF
    var c &#x3D; (f - 32) * 5 &#x2F; 9
    fmt.Printf(&quot;boiling point &#x3D; %g°F or %g°C\n&quot;, f, c)
    &#x2F;&#x2F; Output:
    &#x2F;&#x2F; boiling point &#x3D; 212°F or 100°C
&#125;</code></pre>

<p><code>boilingF</code>是包一级的变量在包内可以访问。如果函数没有返回值，那么返回值列表是省略的。函数顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者</p>
<h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><p>常规声明变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var 变量名字 类型 &#x3D; 表达式</code></pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">var i ,j , k int &#x2F;&#x2F; 都是int类型
var b,f,s &#x3D;true , 2.3 ,&quot;four&quot; &#x2F;&#x2F;bool , float 64,string
var f, err &#x3D; os.Open(name) &#x2F;&#x2F; os.Open returns a file and an error</code></pre>

<ul>
<li>在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。</li>
<li><code>类型</code>和<code>表达式</code>都可以缺省,如果是<code>类型</code>缺省那么就可以通过<code>表达式</code>进行推断,如果是表达式缺省那么就会赋类型的<code>零</code>值,如果是自定义类型或者是引用类型就是内部各个字段都是<code>零</code>值.Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态</li>
</ul>
<h3 id="2-3-1-简短变量声明"><a href="#2-3-1-简短变量声明" class="headerlink" title="2.3.1 简短变量声明"></a>2.3.1 简短变量声明</h3>  <pre class="language-golang" data-language="golang"><code class="language-golang">anim :&#x3D; gif.GIF&#123;LoopCount: nframes&#125; &#x2F;&#x2F;聚合类型,引用类型
freq :&#x3D; rand.Float64() * 3.0 &#x2F;&#x2F; float
t :&#x3D; 0.0  &#x2F;&#x2F;float
f, err :&#x3D; os.Open(name) &#x2F;&#x2F;通过函数进行声明，并初始化
if err !&#x3D; nil &#123;
    return err
&#125;</code></pre>

<ul>
<li>例子1中声明的err是重复,第二个简短声明符的err就是赋值操作，注意该操作是在变量相同作用例子2中这种情况编译不通过,至少有一个是新声明的.[ 实际工程中尽量不要出现例子2 ]</li>
</ul>
  <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;例子1
in, err :&#x3D; os.Open(infile)
&#x2F;&#x2F; ...
out, err :&#x3D; os.Create(outfile)
&#x2F;&#x2F;例子2
f, err :&#x3D; os.Open(infile)
&#x2F;&#x2F; ...
f, err :&#x3D; os.Create(outfile) &#x2F;&#x2F; compile error: no new variables</code></pre>


<h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><ul>
<li><p><code>任何类型</code>的指针的<code>零值</code>都是<code>nil</code>。如果p指向某个有效变量，那么<code>p != nil</code>测试为<code>真</code>。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>
</li>
<li><p>返回局部变量地址也是安全的。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func incr(p *int) int &#123;
    *p++ &#x2F;&#x2F; 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
    return *p
&#125;
v :&#x3D; 1
incr(&amp;v)              &#x2F;&#x2F; side effect: v is now 2
fmt.Println(incr(&amp;v)) &#x2F;&#x2F; &quot;3&quot; (and v is 3)</code></pre>
</li>
<li><p>在flag包中,应用到了<code>指针</code>技术</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main
import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;strings&quot;
)
var n &#x3D; flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)
var sep &#x3D; flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)

func main() &#123;
    flag.Parse() &#x2F;&#x2F;解析标志性参数位
    fmt.Print(strings.Join(flag.Args(), *sep)) &#x2F;&#x2F;flag.Args() 解析非标志参数位
    if !*n &#123;
        fmt.Println()
    &#125;
&#125;</code></pre>
<ul>
<li>在此代码例子中使用<code>flag.Args()</code>解析非标志参数位,<code>flag.Parse()</code>解析标志性参数位,to be continue</li>
</ul>
</li>
</ul>
<h3 id="2-3-3-new函数"><a href="#2-3-3-new函数" class="headerlink" title="2.3.3 new函数"></a>2.3.3 new函数</h3><p>  表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T(返回的是指针)</p>
<ul>
<li>每次new()返回新的变量地址,比如new(int)</li>
</ul>
<h3 id="2-3-4-变量的生命周期"><a href="#2-3-4-变量的生命周期" class="headerlink" title="2.3.4. 变量的生命周期"></a>2.3.4. 变量的生命周期</h3><ul>
<li>包一级的声明会伴随程序整个声明周期,但是函数内部则是动态,会被GC回收</li>
<li>函数的<code>参数变量</code>(参数列表)和<code>返回值变量</code>都是<code>局部变量</code>。它们在函数每次被调用的时候创建,下面循环的<code>变量t</code>就是动态创建,用完就扔  <pre class="language-golang" data-language="golang"><code class="language-golang">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;
  x :&#x3D; math.Sin(t)
  y :&#x3D; math.Sin(t*freq + phase)
  img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
      blackIndex)
&#125;</code></pre></li>
</ul>
<p>  下面也是合法的</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;
  x :&#x3D; math.Sin(t)
  y :&#x3D; math.Sin(t*freq + phase)
  img.SetColorIndex(
      size+int(x*size+0.5), size+int(y*size+0.5),
      blackIndex, &#x2F;&#x2F; 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
  )               &#x2F;&#x2F; 小括弧另起一行缩进，和大括弧的风格保存一致
&#125;</code></pre>

<ul>
<li><code>局部变量逃逸</code>.因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。<code>编译器</code>会自动选择在<code>栈</code>上还是在<code>堆</code>上分配局部变量的存储空间,代码如下,<code>f</code>函数里的<code>x变量</code>必须在<code>堆</code>上分配,因为它在函数退出后依然可以通过包一级的<code>global变量</code>找到,<code>g</code>函数在栈上分配<code>*y</code>内存空间  <pre class="language-golang" data-language="golang"><code class="language-golang">var global *int

func f() &#123;
    var x int
    x &#x3D; 1
    global &#x3D; &amp;x
&#125;

func g() &#123;
    y :&#x3D; new(int)
    *y &#x3D; 1
&#125;
</code></pre></li>
<li>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期,比如,如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。</li>
</ul>
<h2 id="2-4-赋值"><a href="#2-4-赋值" class="headerlink" title="2.4 赋值"></a>2.4 赋值</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">x &#x3D; 1                       &#x2F;&#x2F; 命名变量的赋值
*p &#x3D; true                   &#x2F;&#x2F; 通过指针间接赋值
person.name &#x3D; &quot;bob&quot;         &#x2F;&#x2F; 结构体字段赋值
count[x] &#x3D; count[x] * scale &#x2F;&#x2F; 数组、slice或map的元素赋值
</code></pre>

<h3 id="2-4-1-元组赋值"><a href="#2-4-1-元组赋值" class="headerlink" title="2.4.1 元组赋值"></a>2.4.1 元组赋值</h3>  <pre class="language-golang" data-language="golang"><code class="language-golang">x,y &#x3D; y,x; &#x2F;&#x2F;不限制数量
a[i], a[j] &#x3D; a[j], a[i];
&#x2F;&#x2F;额外的布尔类型表达某种错误类型
v, ok &#x3D; m[key]             &#x2F;&#x2F; map lookup
v, ok &#x3D; x.(T)              &#x2F;&#x2F; type assertion
v, ok &#x3D; &lt;-ch               &#x2F;&#x2F; channel receive
&#x2F;&#x2F;只做检查
v &#x3D; m[key]                &#x2F;&#x2F; map查找，失败时返回零值
v &#x3D; x.(T)                 &#x2F;&#x2F; type断言，失败时panic异常
v &#x3D; &lt;-ch                  &#x2F;&#x2F; 管道接收，失败时返回零值（阻塞不算是失败）

_, ok &#x3D; m[key]            &#x2F;&#x2F; map返回2个值
_, ok &#x3D; mm[&quot;&quot;], false     &#x2F;&#x2F; map返回1个值
_ &#x3D; mm[&quot;&quot;]                &#x2F;&#x2F; map返回1个值
&#x2F;&#x2F;复合类型隐式赋值
medals :&#x3D; []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125;
&#x2F;&#x2F;等价写法
medals[0] &#x3D; &quot;gold&quot;
medals[1] &#x3D; &quot;silver&quot;
medals[2] &#x3D; &quot;bronze&quot;</code></pre>
<ul>
<li>对于两个值是否可以用&#x3D;&#x3D;或!&#x3D;进行相等比较的能力也和可赋值能力有关系</li>
</ul>
<h2 id="2-5-类型"><a href="#2-5-类型" class="headerlink" title="2.5 类型"></a>2.5 类型</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">package tempconv

import &quot;fmt&quot;

type Celsius float64    &#x2F;&#x2F; 摄氏温度
type Fahrenheit float64 &#x2F;&#x2F; 华氏温度

const (
    AbsoluteZeroC Celsius &#x3D; -273.15 &#x2F;&#x2F; 绝对零度
    FreezingC     Celsius &#x3D; 0       &#x2F;&#x2F; 结冰点温度
    BoilingC      Celsius &#x3D; 100     &#x2F;&#x2F; 沸水温度
)

func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9&#x2F;5 + 32) &#125;

func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 &#x2F; 9) &#125;
</code></pre>

<ul>
<li>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用</li>
<li><code>Celsius</code>和<code>Fahrenheit</code>是两种不同类型,<code>Celsius(t)</code>或<code>Fahrenheit(t)</code>形式的显式转型,<code>整数</code>-&gt;<code>小数</code>回省略小数部分(CPP在这部分有很详细的讨论)</li>
<li>如果两个值有着不同的类型，则不能直接进行比较</li>
<li>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集后面详细讨论</li>
</ul>
<h2 id="2-6-包和文件"><a href="#2-6-包和文件" class="headerlink" title="2.6 包和文件"></a>2.6 包和文件</h2><ul>
<li><p><code>名字空间</code>每个包都对应一个独立的名字空间,例如，在image包中的Decode函数和在unicode&#x2F;utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问</p>
</li>
<li><p><code>包的导入</code>Go语言的规范并没有定义这些源代码的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。</p>
</li>
<li><p><code>包的初始化</code>。包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的。例如<code>func init() &#123; /* ... */ &#125;</code>,<code>init</code>不能被调用，也不能被声明。包会按照声明的顺序初始化。</p>
</li>
<li><p><code>包的初始化顺序</code>。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了</p>
<p>复杂初始化可以用以下方式</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;可以使用匿名函数处理
var pc [256]byte &#x3D; func() (pc [256]byte) &#123;
  for i :&#x3D; range pc &#123;
      pc[i] &#x3D; pc[i&#x2F;2] + byte(i&amp;1)
  &#125;
  return
&#125;()
</code></pre></li>
</ul>
<h2 id="2-7-作用域"><a href="#2-7-作用域" class="headerlink" title="2.7. 作用域"></a>2.7. 作用域</h2><ul>
<li>不要将作用域和生命周期混为一谈，作用域是指文本域，而生命周期是指运行有效时段</li>
<li>任何在<code>函数</code>外部（也就是包级语法域）声明的名字可以在同一个<code>包</code>的任何源文件中访问的</li>
<li>对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包</li>
<li>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是<br>函数级的作用域</li>
</ul>
<p>几种常见作用域例子</p>
<ul>
<li><p>正常情况下作用域例子</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func f() &#123;&#125;

var g &#x3D; &quot;g&quot;

func main() &#123;
    f :&#x3D; &quot;f&quot;
    fmt.Println(f) &#x2F;&#x2F; &quot;f&quot;; local var f shadows package-level func f
    fmt.Println(g) &#x2F;&#x2F; &quot;g&quot;; package-level var
    fmt.Println(h) &#x2F;&#x2F; compile error: undefined: h
&#125;</code></pre></li>
<li><p>作用域嵌套,函数中可以进行词法域嵌套</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
  x :&#x3D; &quot;hello!&quot;
  for i :&#x3D; 0; i &lt; len(x); i++ &#123;
      x :&#x3D; x[i]
      if x !&#x3D; &#39;!&#39; &#123;
          x :&#x3D; x + &#39;A&#39; - &#39;a&#39;
          fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;上述代码&#96;x[]&#96;和&#96;x + &#39;A&#39; - &#39;a&#39;&#96;都是引用了外部作用域声明的x变量。
&#x2F;&#x2F;再比如下面的例子,有三个不同的x变量，</code></pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化
&#x2F;&#x2F;词法域，一个在for循环体词法域；只有两个块是显式创建的：
func main() &#123;
  x :&#x3D; &quot;hello&quot;
  for _, x :&#x3D; range x &#123;
      x :&#x3D; x + &#39;A&#39; - &#39;a&#39;
      fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)
  &#125;
&#125;</code></pre></li>
<li><p>建隐式词法域,隐式作用域<br>  if和switch语句也会在条件部分创建隐式词法域，代码例子如下.第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if x :&#x3D; f(); x &#x3D;&#x3D; 0 &#123;
  fmt.Println(x)
&#125; else if y :&#x3D; g(x); x &#x3D;&#x3D; y &#123;
    fmt.Println(x, y)
&#125; else &#123;
    fmt.Println(x, y)
&#125;
fmt.Println(x, y) &#x2F;&#x2F; compile error: x and y are not visible here</code></pre>
<p>如果不想提前声明变量还可以选择如下方式，但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if f, err :&#x3D; os.Open(fname); err !&#x3D; nil &#123;
  return err
&#125; else &#123;
    &#x2F;&#x2F; f and err are visible here too
    f.ReadByte()
    f.Close()
&#125;</code></pre></li>
<li><p>屏蔽其他作用域变暗亮<br>cwd在外部已经声明的包级变量，但是:&#x3D;语句还是将cwd和err重新声明为新的局部变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var cwd string

func init() &#123;
    cwd, err :&#x3D; os.Getwd() &#x2F;&#x2F; compile error: unused: cwd
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
&#125;</code></pre>
<p>可以用赋值运算符，就不会屏蔽<code>cwd</code>变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var cwd string

func init() &#123;
    var err error &#x2F;&#x2F;因为是赋值运算符所以需要定义error变量
    cwd, err &#x3D; os.Getwd()
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
&#125;</code></pre></li>
</ul>
<h1 id="3-基础数据类型"><a href="#3-基础数据类型" class="headerlink" title="3.基础数据类型"></a>3.基础数据类型</h1><ul>
<li><p>整型格式控制符</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>整型以二进制方式显示</td>
</tr>
<tr>
<td>%o</td>
<td>整型以八进制方式显示</td>
</tr>
<tr>
<td>%d</td>
<td>整型以十进制方式显示</td>
</tr>
<tr>
<td>%x</td>
<td>整型以十六进制方式显示</td>
</tr>
<tr>
<td>%X</td>
<td>整型以十六进制、字母大写方式显示</td>
</tr>
<tr>
<td>%c</td>
<td>相应Unicode码点所表示的字符</td>
</tr>
<tr>
<td>%U</td>
<td>Unicode 字符, Unicode格式：123，等同于 “U+007B”</td>
</tr>
</tbody></table>
</li>
<li><p>浮点数格式控制</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%e</td>
<td>科学计数法,例如 -1234.456e+78</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法,例如 -1234.456E+78</td>
</tr>
<tr>
<td>%f</td>
<td>有小数点而无指数,例如 123.456</td>
</tr>
<tr>
<td>%g</td>
<td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
<tr>
<td>%G</td>
<td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
</tbody></table>
</li>
<li><p>字符串格式化</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串或切片的无解译字节</td>
</tr>
<tr>
<td>%q</td>
<td>双引号围绕的字符串，由Go语法安全地转义</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制，小写字母，每字节两个字符</td>
</tr>
<tr>
<td>%X</td>
<td>十六进制，大写字母，每字节两个字符</td>
</tr>
</tbody></table>
</li>
<li><p>指针格式化</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%p</td>
<td>十六进制表示，前缀 0x</td>
</tr>
</tbody></table>
</li>
<li><p>通用的占位符</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%v</td>
<td>值的默认格式。</td>
</tr>
<tr>
<td>%+v</td>
<td>类似%v，但输出结构体时会添加字段名</td>
</tr>
<tr>
<td>%#v</td>
<td>相应值的Go语法表示</td>
</tr>
<tr>
<td>%T</td>
<td>相应值的类型的Go语法表示</td>
</tr>
<tr>
<td>%%</td>
<td>百分号,字面上的%,非占位符含义</td>
</tr>
</tbody></table>
</li>
<li><p>控制宽度<br>  宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐</p>
<ul>
<li><p>字符串控制</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">fmt.Printf(&quot;|%s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 不设置宽度
fmt.Printf(&quot;|%5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度,  默认+， 右对齐
fmt.Printf(&quot;|%-5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度, 左对齐

fmt.Printf(&quot;|%05s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; |000aa|
</code></pre>
</li>
<li><p>浮点控制</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">a :&#x3D; 54.123456
fmt.Printf(&quot;|%f|&quot;, a)  &#x2F;&#x2F; |54.123456|
fmt.Printf(&quot;|%5.1f|&quot;, a)  &#x2F;&#x2F; | 54.1|
fmt.Printf(&quot;|%-5.1f|&quot;, a) &#x2F;&#x2F; |54.1 |
fmt.Printf(&quot;|%05.1f|&quot;, a) &#x2F;&#x2F; |054.1|</code></pre></li>
</ul>
</li>
</ul>
<h2 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a>3.1 整型</h2><ol>
<li>因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节</li>
<li>Unicode和rune类型是个<code>int32</code>等价的类型,通常用于表示一个Unicode码点</li>
<li>同样byte也是<code>uint8</code>类型的等价类型</li>
<li>还有一种无符号的整数类型<code>uintptr</code>，没有指定具体的bit大小但是足以容纳指针。<code>uintptr</code>类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方</li>
<li><code>int</code>、<code>uint</code>和<code>uintptr</code>是不同类型的兄弟类型。其中<code>int</code>和<code>int32</code>也是不同的类型，即使<code>int</code>的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然</li>
<li>位元素符号</li>
<li><code>int32</code>和<code>int64</code>无法直接四则运算</li>
<li><code>fmt.Printf(&quot;%d %[1]o %#[1]o\n&quot;, o) // &quot;438 666 0666&quot;</code>中的<code>fmt</code>两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀</li>
</ol>
<h2 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2 浮点数"></a>3.2 浮点数</h2><ol>
<li>一个<code>float32</code>类型的浮点数可以提供大约<code>6</code>个十进制数的精度，而<code>float64</code>则可以提供约<code>15</code>个十进制数的精度；通常应该优先使用<code>float64</code>类型，因为<code>float32</code>类型的累计计算误差很容易扩散，并且<code>float32</code>能精确表示的正整数并不是很大</li>
<li>浮点数字面量可以直接书写</li>
<li>很大或者很小的数都可以用科学计数法来书写</li>
<li><code>fmt.Printf(&quot;x = %d e^x = %8.3f\n&quot;, x, math.Exp(float64(x)))</code>8.3是指三个小数精度，8个字符宽度,<code>%g %e %f</code>.</li>
</ol>
<h2 id="3-3-复数"><a href="#3-3-复数" class="headerlink" title="3.3 复数"></a>3.3 复数</h2><p>复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var x complex128 &#x3D; complex(1, 2) &#x2F;&#x2F; 1+2i
var y complex128 &#x3D; complex(3, 4) &#x2F;&#x2F; 3+4i
fmt.Println(x*y)                 &#x2F;&#x2F; &quot;(-5+10i)&quot;
fmt.Println(real(x*y))           &#x2F;&#x2F; &quot;-5&quot;
fmt.Println(imag(x*y))           &#x2F;&#x2F; &quot;10&quot;
</code></pre>

<h2 id="3-4-布尔类型"><a href="#3-4-布尔类型" class="headerlink" title="3.4 布尔类型"></a>3.4 布尔类型</h2><p>布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">i :&#x3D; 0
if b &#123;
    i &#x3D; 1
&#125;</code></pre>

<h2 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a>3.5 字符串</h2><ul>
<li><p>字符串可以用&#x3D;&#x3D;和&lt;进行比较；比较通过逐个字节比较完成的</p>
</li>
<li><p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故<code>s[0] = &#39;L&#39; // compile error: cannot assign to s[0]</code></p>
<ul>
<li>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中</li>
<li>可在字符串面值中写<code>十六进制</code>和<code>八进制</code>数字进行码点转义</li>
<li>原生字面值用反引号(&#96;)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.</li>
<li>通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思</li>
<li>UTF-8 [to be continue]</li>
<li><code>bytes</code>、<code>strings</code>、<code>strconv</code>和<code>unicode</code>包,四个包对字符串处理尤为重要,<code>strings</code>包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能</li>
<li>字符串和数字的转换,<code>strconv</code>包提供这类转换功能</li>
</ul>
</li>
</ul>
<h1 id="4-复合数据类型"><a href="#4-复合数据类型" class="headerlink" title="4. 复合数据类型"></a>4. 复合数据类型</h1><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>数组代码示例</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var a [3]int             &#x2F;&#x2F; array of 3 integers
fmt.Println(a[0])        &#x2F;&#x2F; print the first element
fmt.Println(a[len(a)-1]) &#x2F;&#x2F; print the last element, a[2]

&#x2F;&#x2F; Print the indices and elements.
for i, v :&#x3D; range a &#123;
    fmt.Printf(&quot;%d %d\n&quot;, i, v)
&#125;

&#x2F;&#x2F; Print the elements only.
for _, v :&#x3D; range a &#123;
    fmt.Printf(&quot;%d\n&quot;, v)
&#125;</code></pre>

<p>如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">q :&#x3D; [...]int&#123;1, 2, 3&#125;
fmt.Printf(&quot;%T\n&quot;, q) &#x2F;&#x2F; &quot;[3]int&quot;</code></pre>
<p>上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Currency int

const (
    USD Currency &#x3D; iota &#x2F;&#x2F; 美元
    EUR                 &#x2F;&#x2F; 欧元
    GBP                 &#x2F;&#x2F; 英镑
    RMB                 &#x2F;&#x2F; 人民币
)

symbol :&#x3D; [...]string&#123;USD: &quot;$&quot;, EUR: &quot;€&quot;, GBP: &quot;￡&quot;, RMB: &quot;￥&quot;&#125;

fmt.Println(RMB, symbol[RMB]) &#x2F;&#x2F; &quot;3 ￥&quot;</code></pre>
<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">r :&#x3D; [...]int&#123;99: -1&#125;</code></pre>
<p>数组进行比较是比较所有元素是否相等</p>
<h2 id="4-2-slice"><a href="#4-2-slice" class="headerlink" title="4.2 slice"></a>4.2 slice</h2><p>创建slice变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">v_len :&#x3D; make([]T, len)
v_len_cap :&#x3D; make([]T, len, cap) &#x2F;&#x2F; same as make([]T, cap)[:len]
s :&#x3D; []int&#123;0, 1, 2, 3, 4, 5&#125;</code></pre>
<p><code>slice</code>和<code>数组</code>典型的不同就是<code>slice</code>不指定长度<br><code>bytes.Equal</code>函数来判断两个字节型slice是否相等（[]byte)</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func equal(x, y []string) bool &#123;
    if len(x) !&#x3D; len(y) &#123;
        return false
    &#125;
    for i :&#x3D; range x &#123;
        if x[i] !&#x3D; y[i] &#123;
            return false
        &#125;
    &#125;
    return true
&#125;</code></pre>

<p>slice的nil值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var s []int    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; nil        &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; []int(nil) &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; []int&#123;&#125;    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s !&#x3D; nil</code></pre>

<h3 id="4-2-1-append函数"><a href="#4-2-1-append函数" class="headerlink" title="4.2.1 append函数"></a>4.2.1 append函数</h3><p>(留着放些API东西)</p>
<h2 id="4-3-Map"><a href="#4-3-Map" class="headerlink" title="4.3 Map"></a>4.3 Map</h2><p>其中K对应的key必须是支持&#x3D;&#x3D;比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在<br>创建map</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">ages :&#x3D; make(map[string]int) &#x2F;&#x2F; mapping from strings to ints
ages :&#x3D; map[string]int&#123;
    &quot;alice&quot;:   31,
    &quot;charlie&quot;: 34,
&#125;
&#x2F;&#x2F;访问map数据，也是put操作
ages[&quot;alice&quot;] &#x3D; 32
&#x2F;&#x2F;删除元素
delete(ages, &quot;alice&quot;) &#x2F;&#x2F; remove element ages[&quot;alice&quot;]
&#x2F;&#x2F;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：
_ &#x3D; &amp;ages[&quot;bob&quot;] &#x2F;&#x2F; compile error: cannot take address of map element
</code></pre>
<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import &quot;sort&quot;

var names []string
for name :&#x3D; range ages &#123;
    names &#x3D; append(names, name)
&#125;
sort.Strings(names)
for _, name :&#x3D; range names &#123;
    fmt.Printf(&quot;%s\t%d\n&quot;, name, ages[name])
&#125;</code></pre>

<p>map返回两个值，第一个值是bool类型,false则说明不存在这个key。<br>map的key要求必须是可比较类型，那么如果想用slice作为key就需要写小改动</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var m &#x3D; make(map[string]int)

func k(list []string) string &#123; return fmt.Sprintf(&quot;%q&quot;, list) &#125;

func Add(list []string)       &#123; m[k(list)]++ &#125;
func Count(list []string) int &#123; return m[k(list)] &#125;</code></pre>

<h2 id="4-4-结构体"><a href="#4-4-结构体" class="headerlink" title="4.4 结构体"></a>4.4 结构体</h2><pre class="language-golang" data-language="golang"><code class="language-golang">seen :&#x3D; make(map[string]struct&#123;&#125;) &#x2F;&#x2F; set of strings
&#x2F;&#x2F; ...
if _, ok :&#x3D; seen[s]; !ok &#123;
    seen[s] &#x3D; struct&#123;&#125;&#123;&#125;
    &#x2F;&#x2F; ...first time seeing s...
&#125;</code></pre>

<h3 id="4-4-1-结构体字面值"><a href="#4-4-1-结构体字面值" class="headerlink" title="4.4.1 结构体字面值"></a>4.4.1 结构体字面值</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Point struct&#123; X, Y int &#125;
&#x2F;&#x2F;第一种类型初始化方式
p :&#x3D; Point&#123;1, 2&#125;
&#x2F;&#x2F;第二种初始化方式,如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要
p :&#x3D;Point&#123;x:1,y:2&#125;</code></pre>

<p>非导出结构体或者字段，不能在其他包中进行赋值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package p
type T struct&#123; a, b int &#125; &#x2F;&#x2F; a and b are not exported

package q
import &quot;p&quot;
var _ &#x3D; p.T&#123;a: 1, b: 2&#125; &#x2F;&#x2F; compile error: can&#39;t reference a, b
var _ &#x3D; p.T&#123;1, 2&#125;       &#x2F;&#x2F; compile error: can&#39;t reference a, b</code></pre>

<p>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
func Bonus(e *Employee, percent int) int &#123;
    return e.Salary * percent &#x2F; 100
&#125;</code></pre>

<p>可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">pp :&#x3D; &amp;Point&#123;1, 2&#125;</code></pre>

<p>它和下面的语句是等价的</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">pp :&#x3D; new(Point)
*pp &#x3D; Point&#123;1, 2&#125;</code></pre>

<h3 id="4-4-2-结构体的比较"><a href="#4-4-2-结构体的比较" class="headerlink" title="4.4.2 结构体的比较"></a>4.4.2 结构体的比较</h3><p>首先结构体是可比较类型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
type Point struct&#123; X, Y int &#125;

p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;2, 1&#125;
fmt.Println(p.X &#x3D;&#x3D; q.X &amp;&amp; p.Y &#x3D;&#x3D; q.Y) &#x2F;&#x2F; &quot;false&quot;
fmt.Println(p &#x3D;&#x3D; q)                   &#x2F;&#x2F; &quot;false&quot;
</code></pre>

<h3 id="4-4-3-结构体嵌入和匿名成员"><a href="#4-4-3-结构体嵌入和匿名成员" class="headerlink" title="4.4.3 结构体嵌入和匿名成员"></a>4.4.3 结构体嵌入和匿名成员</h3><pre class="language-golang" data-language="golang"><code class="language-golang">
type Point struct &#123;
    X, Y int
&#125;

type Circle struct &#123;
    Center Point
    Radius int
&#125;

type Wheel struct &#123;
    Circle Circle
    Spokes int
&#125;

var w Wheel
w.Circle.Center.X &#x3D; 8
w.Circle.Center.Y &#x3D; 8
w.Circle.Radius &#x3D; 5
w.Spokes &#x3D; 20</code></pre>

<p>匿名成员，说白了就是只写类型不写名字.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Circle struct &#123;
    Point
    Radius int
&#125;

type Wheel struct &#123;
    Circle
    Spokes int
&#125;

var w Wheel
w.X &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.X &#x3D; 8
w.Y &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.Y &#x3D; 8
w.Radius &#x3D; 5       &#x2F;&#x2F; equivalent to w.Circle.Radius &#x3D; 5
w.Spokes &#x3D; 20
&#x2F;&#x2F;以下初始化是错误的
w &#x3D; Wheel&#123;8, 8, 5, 20&#125;                       &#x2F;&#x2F; compile error: unknown fields
w &#x3D; Wheel&#123;X: 8, Y: 8, Radius: 5, Spokes: 20&#125; &#x2F;&#x2F; compile error: unknown fields</code></pre>

<p>所以我们只能用下面两种方式进行初始化</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
w &#x3D; Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;

w &#x3D; Wheel&#123;
    Circle: Circle&#123;
        Point:  Point&#123;X: 8, Y: 8&#125;,
        Radius: 5,
    &#125;,
    Spokes: 20, &#x2F;&#x2F; NOTE: trailing comma necessary here (and at Radius)
&#125;

fmt.Printf(&quot;%#v\n&quot;, w)
&#x2F;&#x2F; Output:
&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;

w.X &#x3D; 42

fmt.Printf(&quot;%#v\n&quot;, w)
&#x2F;&#x2F; Output:
&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;
</code></pre>
<p>需要注意，但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</p>
<h2 id="4-5-json字符串"><a href="#4-5-json字符串" class="headerlink" title="4.5 json字符串"></a>4.5 json字符串</h2><p><code>json.Marshal</code>包<br>代码例子</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Movie struct &#123;
    Title  string
    Year   int  &#96;json:&quot;released&quot;&#96; &#x2F;&#x2F; 这个tag指定生成json名字
    Color  bool &#96;json:&quot;color,omitempty&quot;&#96;
    Actors []string
&#125;

var movies &#x3D; []Movie&#123;
    &#123;Title: &quot;Casablanca&quot;, Year: 1942, Color: false,
        Actors: []string&#123;&quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot;&#125;&#125;,
    &#123;Title: &quot;Cool Hand Luke&quot;, Year: 1967, Color: true,
        Actors: []string&#123;&quot;Paul Newman&quot;&#125;&#125;,
    &#123;Title: &quot;Bullitt&quot;, Year: 1968, Color: true,
        Actors: []string&#123;&quot;Steve McQueen&quot;, &quot;Jacqueline Bisset&quot;&#125;&#125;,
    &#x2F;&#x2F; ...
&#125;</code></pre>

<h2 id="4-6-文本和HTML模板"><a href="#4-6-文本和HTML模板" class="headerlink" title="4.6 文本和HTML模板"></a>4.6 文本和HTML模板</h2><p>(后面需要时候着重的看)<br><code>text/template和html/template</code>,们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。模板语言支持流程控制语句<br>模板语言demo</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const templ &#x3D; &#96;&#123;&#123;.TotalCount&#125;&#125; issues:
&#123;&#123;range .Items&#125;&#125;----------------------------------------
Number: &#123;&#123;.Number&#125;&#125;
User:   &#123;&#123;.User.Login&#125;&#125;
Title:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;
Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days
&#123;&#123;end&#125;&#125;&#96;</code></pre>

<p><code>|</code> 操作符表示将前一个表达式的结果作为后一个函数的输入.<br>生成模板的输出需要两个处理步骤</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var report &#x3D; template.Must(template.New(&quot;issuelist&quot;).
    Funcs(template.FuncMap&#123;&quot;daysAgo&quot;: daysAgo&#125;).
    Parse(templ))

func main() &#123;
    result, err :&#x3D; github.SearchIssues(os.Args[1:])
    if err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
    if err :&#x3D; report.Execute(os.Stdout, result); err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
&#125;</code></pre>
<p>如果想转化为html则需要编写如下代码</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
import &quot;html&#x2F;template&quot;

var issueList &#x3D; template.Must(template.New(&quot;issuelist&quot;).Parse(&#96;
&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;&#x2F;h1&gt;
&lt;table&gt;
&lt;tr style&#x3D;&#39;text-align: left&#39;&gt;
  &lt;th&gt;#&lt;&#x2F;th&gt;
  &lt;th&gt;State&lt;&#x2F;th&gt;
  &lt;th&gt;User&lt;&#x2F;th&gt;
  &lt;th&gt;Title&lt;&#x2F;th&gt;
&lt;&#x2F;tr&gt;
&#123;&#123;range .Items&#125;&#125;
&lt;tr&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Number&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;&#x2F;td&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.User.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Title&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
&lt;&#x2F;tr&gt;
&#123;&#123;end&#125;&#125;
&lt;&#x2F;table&gt;
&#96;))</code></pre>
<p>注意，html&#x2F;template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text&#x2F;template包的话，这2个issue将会产生错误，其中“&lt;”四个字符将会被当作小于字符“&lt;”处理，同时“<link>”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。</p>
<h1 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h1><p>声明和定义</p>
<ul>
<li><p>switch 控制语句</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">switch cond&#123;
  case a :
      fmt.Printf()
  case b :
      fmt.Printf()
  case c :
      fmt.Printf()
&#125;</code></pre></li>
</ul>
<h2 id="5-1-错误"><a href="#5-1-错误" class="headerlink" title="5.1 错误"></a>5.1 错误</h2><p>通常，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</p>
<p>我们有几种处理错误的策略</p>
<ol>
<li>发生错误时的解析器</li>
</ol>
<p>  发生解析错误后,findLinks 函数构造了一个新的异常信息,既包含了自定义的，也包含了底层解析出错的信息</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">doc, err :&#x3D; html.Parse(resp.Body)
resp.Body.Close()
if err !&#x3D; nil &#123;
    return nil, fmt.Errorf(&quot;parsing %s as HTML: %v&quot;, url,err)
&#125;</code></pre>

<p>  参考宇航局事故调查<br>2. 重试<br>  我们需要限制重试的时间间隔或重试的次数，防止无限制的重试.<br>3. 输出错误信息并结束程序<br>  输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行,对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序<br>  <pre class="language-golang" data-language="golang"><code class="language-golang">if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;
  log.Fatalf(&quot;Site is down: %v\n&quot;, err)
&#125;</code></pre><br>  <code>log.Fatalf</code>代码更简洁，并输出自定义格式信息</p>
<ol start="4">
<li>只是输出错误信息就可以</li>
</ol>
  <pre class="language-golang" data-language="golang"><code class="language-golang">if err :&#x3D; Ping(); err !&#x3D; nil &#123;
  log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)
&#125;
&#x2F;&#x2F;或者标准错误流输出错误信息。

if err :&#x3D; Ping(); err !&#x3D; nil &#123;
    fmt.Fprintf(os.Stderr, &quot;ping failed: %v; networking disabled\n&quot;, err)
&#125;</code></pre>

<ol start="5">
<li>直接忽略掉错误</li>
</ol>
  <pre class="language-golang" data-language="golang"><code class="language-golang">dir, err :&#x3D; ioutil.TempDir(&quot;&quot;, &quot;scratch&quot;)
if err !&#x3D; nil &#123;
    return fmt.Errorf(&quot;failed to create temp dir: %v&quot;,err)
&#125;
&#x2F;&#x2F; ...use temp dir…
os.RemoveAll(dir) &#x2F;&#x2F; ignore errors; $TMPDIR is cleaned periodically</code></pre>
<p>  尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响</p>
<ol start="6">
<li>文件结尾错误</li>
</ol>
<p>io包保证任何由文件结束引起的读取失败都返</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package io

import &quot;errors&quot;

&#x2F;&#x2F; EOF is the error returned by Read when no more input is available.
var EOF &#x3D; errors.New(&quot;EOF&quot;)

in :&#x3D; bufio.NewReader(os.Stdin)
for &#123;
    r, _, err :&#x3D; in.ReadRune()
    if err &#x3D;&#x3D; io.EOF &#123;
        break &#x2F;&#x2F; finished reading
    &#125;
    if err !&#x3D; nil &#123;
        return fmt.Errorf(&quot;read failed:%v&quot;, err)
    &#125;
    &#x2F;&#x2F; ...use r…
&#125;</code></pre>

<h2 id="5-2-函数值"><a href="#5-2-函数值" class="headerlink" title="5.2 函数值"></a>5.2 函数值</h2><ul>
<li><p>函数在golang中也是一种类型，可以被复制给其他变量。  </p>
</li>
<li><p>很熟类型的<code>零</code>值是<code>nil</code>,调用值为nil会引起<code>panic</code>错误  </p>
</li>
<li><p>函数值之间是不可以比较的,也不能用函数值作为map的key</p>
</li>
<li><p>strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func add1(r rune) rune &#123; return r + 1 &#125;

fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) &#x2F;&#x2F; &quot;IBM.:111&quot;
fmt.Println(strings.Map(add1, &quot;VMS&quot;))      &#x2F;&#x2F; &quot;WNT&quot;
fmt.Println(strings.Map(add1, &quot;Admix&quot;))    &#x2F;&#x2F; &quot;Benjy&quot;</code></pre></li>
</ul>
<p>demo示例</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;值得学习
&#x2F;&#x2F; forEachNode针对每个结点x，都会调用pre(x)和post(x)。
&#x2F;&#x2F; pre和post都是可选的。
&#x2F;&#x2F; 遍历孩子结点之前，pre被调用
&#x2F;&#x2F; 遍历孩子结点之后，post被调用
func forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123;
    if pre !&#x3D; nil &#123;
        pre(n)
    &#125;
    for c :&#x3D; n.FirstChild; c !&#x3D; nil; c &#x3D; c.NextSibling &#123;
        forEachNode(c, pre, post)
    &#125;
    if post !&#x3D; nil &#123;
        post(n)
    &#125;
&#125;</code></pre>

<h2 id="5-3-匿名函数"><a href="#5-3-匿名函数" class="headerlink" title="5.3 匿名函数"></a>5.3 匿名函数</h2><p>函数内部定义的函数可以访问整个词法环境，言外之意就是嵌套的函数可以访问外层函数的变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; squares返回一个匿名函数。
&#x2F;&#x2F; 该匿名函数每次被调用时都会返回下一个数的平方。
&#x2F;&#x2F;squares 函数每次都返回一个函数类型-func()int&#123;&#125;
func squares() func() int &#123;
    var x int
    return func() int &#123; &#x2F;&#x2F; 匿名函数
        x++
        return x * x
    &#125;
&#125;
func main() &#123;
    f :&#x3D; squares()
    fmt.Println(f()) &#x2F;&#x2F; &quot;1&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;4&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;9&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;16&quot;
&#125;
&#x2F;&#x2F;通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</code></pre>

<blockquote>
<p>网页抓取的核心问题就是如何遍历图</p>
</blockquote>
<p>警告:捕获迭代变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var rmdirs []func()
for _, d :&#x3D; range tempDirs() &#123;
    dir :&#x3D; d &#x2F;&#x2F; NOTE: necessary!
    os.MkdirAll(dir, 0755) &#x2F;&#x2F; creates parent directories too
    rmdirs &#x3D; append(rmdirs, func() &#123;
        os.RemoveAll(dir)
    &#125;)
&#125;
&#x2F;&#x2F; ...do some work…
for _, rmdir :&#x3D; range rmdirs &#123;
    rmdir() &#x2F;&#x2F; clean up
&#125;
&#x2F;&#x2F; 
var rmdirs []func()
for _, dir :&#x3D; range tempDirs() &#123;
    os.MkdirAll(dir, 0755)
    rmdirs &#x3D; append(rmdirs, func() &#123;
        os.RemoveAll(dir) &#x2F;&#x2F; NOTE: incorrect!
    &#125;)
&#125;
</code></pre>
<p>问题出在了循环变量的作用域,循环变量dir在这个词法块中被声明，每一次迭代都是会不断地更新这个值，被<code>range</code>语句，解决这个问题的办法就是引入同名变量来覆盖其作用域。</p>
<h2 id="5-4-可变参数"><a href="#5-4-可变参数" class="headerlink" title="5.4 可变参数"></a>5.4 可变参数</h2><p>简单的可变参数例子,其实<code>可变参数</code>就是个切片的值传递,<code>interface&#123;&#125;</code>表示函数的最后一个参数可以接收任意类型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func sum(vals ...int) int &#123;
    total :&#x3D; 0
    for _, val :&#x3D; range vals &#123;
        total +&#x3D; val
    &#125;
    return total
&#125;</code></pre>
<p>如果原参数就是切片该怎么传递？可以直接在<code>实参</code>后面加省略号</p>
<h2 id="5-5-defer函数"><a href="#5-5-defer函数" class="headerlink" title="5.5 defer函数"></a>5.5 defer函数</h2><p>在函数执行完成之后，不管是正常退出还是异常退出函数，最后都会被执行</p>
<h2 id="5-6-panic异常"><a href="#5-6-panic异常" class="headerlink" title="5.6 panic异常"></a>5.6 panic异常</h2><p>当panic发生时会在该goroutine上执行defer函数，打印对应的栈信息<br><code>regexp</code>包的使用<br>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
    defer printStack()
    f(3)
&#125;
func printStack() &#123;
    var buf [4096]byte
    n :&#x3D; runtime.Stack(buf[:], false)
    os.Stdout.Write(buf[:n])
&#125;
</code></pre>
<p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p>
<h2 id="5-7-Recovery捕获异常"><a href="#5-7-Recovery捕获异常" class="headerlink" title="5.7 Recovery捕获异常"></a>5.7 Recovery捕获异常</h2><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所</p>
<ul>
<li>语言解析器为例<br>说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">func Parse(input string) (s *Syntax, err error) &#123;
    defer func() &#123;
        if p :&#x3D; recover(); p !&#x3D; nil &#123;
            err &#x3D; fmt.Errorf(&quot;internal error: %v&quot;, p)
        &#125;
    &#125;()
    &#x2F;&#x2F; ...parser...
&#125;</code></pre>


<ul>
<li>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。  </li>
<li>有时我们很难完全遵循规范，举个例子，net&#x2F;http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; soleTitle returns the text of the first non-empty title element
&#x2F;&#x2F; in doc, and an error if there was not exactly one.
&#x2F;&#x2F;防御性panic代码
func soleTitle(doc *html.Node) (title string, err error) &#123;
    type bailout struct&#123;&#125;
    defer func() &#123;
        switch p :&#x3D; recover(); p &#123;
        case nil:       &#x2F;&#x2F; no panic
        case bailout&#123;&#125;: &#x2F;&#x2F; &quot;expected&quot; panic
            err &#x3D; fmt.Errorf(&quot;multiple title elements&quot;)
        default:
            panic(p) &#x2F;&#x2F; unexpected panic; carry on panicking
        &#125;
    &#125;()
    &#x2F;&#x2F; Bail out of recursion if we find more than one nonempty title.
    forEachNode(doc, func(n *html.Node) &#123;
        if n.Type &#x3D;&#x3D; html.ElementNode &amp;&amp; n.Data &#x3D;&#x3D; &quot;title&quot; &amp;&amp;
            n.FirstChild !&#x3D; nil &#123;
            if title !&#x3D; &quot;&quot; &#123;
                panic(bailout&#123;&#125;) &#x2F;&#x2F; multiple titleelements
            &#125;
            title &#x3D; n.FirstChild.Data
        &#125;
    &#125;, nil)
    if title &#x3D;&#x3D; &quot;&quot; &#123;
        return &quot;&quot;, fmt.Errorf(&quot;no title element&quot;)
    &#125;
    return title, nil
&#125;</code></pre>

<h1 id="6-方法"><a href="#6-方法" class="headerlink" title="6. 方法"></a>6. 方法</h1><h2 id="6-1-方法声明"><a href="#6-1-方法声明" class="headerlink" title="6.1 方法声明"></a>6.1 方法声明</h2><ul>
<li>普通函数与接收器方法<br><code>接收器</code>因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。对于一个给定的类型，其内部的方法都必须有唯一的方法名</li>
</ul>
<h2 id="6-2-基于指针对象的方法"><a href="#6-2-基于指针对象的方法" class="headerlink" title="6.2 基于指针对象的方法"></a>6.2 基于指针对象的方法</h2><ul>
<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。</li>
<li>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们下面例子里做的这样  <pre class="language-golang" data-language="golang"><code class="language-golang">func (list *IntList) Sum() int &#123;
if list &#x3D;&#x3D; nil &#123;
    return 0
&#125;
return list.Value + list.Tail.Sum()
&#125;</code></pre>
  如果此时结构体是<code>nil</code>调用对象可能会发生类似于空指针异常的错误</li>
</ul>
<h2 id="6-3-通过嵌入结构体来扩展类型"><a href="#6-3-通过嵌入结构体来扩展类型" class="headerlink" title="6.3. 通过嵌入结构体来扩展类型"></a>6.3. 通过嵌入结构体来扩展类型</h2><ul>
<li><p>方法值<br>  在go语言中，方法是第一公民，这一点在函数式编程中非常实用(maybe)</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;方法值demo
p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;4, 6&#125;

distanceFromP :&#x3D; p.Distance        &#x2F;&#x2F; method value,Distance是结构体方法
fmt.Println(distanceFromP(q))      &#x2F;&#x2F; &quot;5&quot;
var origin Point                   &#x2F;&#x2F; &#123;0, 0&#125;
fmt.Println(distanceFromP(origin)) &#x2F;&#x2F; &quot;2.23606797749979&quot;, sqrt(5)

scaleP :&#x3D; p.ScaleBy &#x2F;&#x2F; method value
scaleP(2)           &#x2F;&#x2F; p becomes (2, 4)
scaleP(3)           &#x2F;&#x2F;      then (6, 12)
scaleP(10)          &#x2F;&#x2F;      then (60, 120)</code></pre>
</li>
<li><p>方法表达式<br>  在面向对象中，当根据哪一个变量来决定调用哪个函数时候,方法表达式就很有用了.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;4, 6&#125;

distance :&#x3D; Point.Distance   &#x2F;&#x2F; method expression
fmt.Println(distance(p, q))  &#x2F;&#x2F; &quot;5&quot;
fmt.Printf(&quot;%T\n&quot;, distance) &#x2F;&#x2F; &quot;func(Point, Point) float64&quot;

scale :&#x3D; (*Point).ScaleBy
scale(&amp;p, 2)
fmt.Println(p)            &#x2F;&#x2F; &quot;&#123;2 4&#125;&quot;
fmt.Printf(&quot;%T\n&quot;, scale) &#x2F;&#x2F; &quot;func(*Point, float64)&quot;
</code></pre></li>
</ul>
<p>practice demo</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Point struct&#123; X, Y float64 &#125;

func (p Point) Add(q Point) Point &#123; return Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;
func (p Point) Sub(q Point) Point &#123; return Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) &#123;
    var op func(p, q Point) Point
    if add &#123;
        op &#x3D; Point.Add
    &#125; else &#123;
        op &#x3D; Point.Sub
    &#125;
    for i :&#x3D; range path &#123;
        &#x2F;&#x2F; Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] &#x3D; op(path[i], offset)
    &#125;
&#125;</code></pre>

<h2 id="6-4-封装"><a href="#6-4-封装" class="headerlink" title="6.4 封装"></a>6.4 封装</h2><p>封装提供了三方面的优点。</p>
<ol>
<li><p>首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可.</p>
</li>
<li><p>第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由</p>
</li>
<li><p>bytes.Buffer这个类型作为例子来考虑</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">
type Buffer struct &#123;
buf     []byte
initial [64]byte
&#x2F;* ... *&#x2F;
&#125;

&#x2F;&#x2F; Grow expands the buffer&#39;s capacity, if necessary,
&#x2F;&#x2F; to guarantee space for another n bytes. [...]
func (b *Buffer) Grow(n int) &#123;
    if b.buf &#x3D;&#x3D; nil &#123;
        b.buf &#x3D; b.initial[:0] &#x2F;&#x2F; use preallocated space initially
    &#125;
    if len(b.buf)+n &gt; cap(b.buf) &#123;
        buf :&#x3D; make([]byte, b.Len(), 2*cap(b.buf) + n)
        copy(buf, b.buf)
        b.buf &#x3D; buf
    &#125;
&#125;
&#x2F;&#x2F; Grow()函数式导出类型，但是stuct的字段不是到处类型</code></pre>
</li>
<li><p>只暴漏关键信息给外部使用者</p>
</li>
</ol>
<h1 id="7-接口"><a href="#7-接口" class="headerlink" title="7. 接口"></a>7. 接口</h1><p>很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用  </p>
<p>只要一个物体能像鸭子一样叫那我们就可以称它为鸭子；只要一个软件能存储和查询数据我们就可以称它为数据库；只要一台机器有洗衣服和甩干的功能我们就可以称它为洗衣机。  </p>
<p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型</p>
<h2 id="7-1-接口约定"><a href="#7-1-接口约定" class="headerlink" title="7.1. 接口约定"></a>7.1. 接口约定</h2><p>例如<code>fmt</code>包</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package fmt

func Fprintf(w io.Writer, format string, args ...interface&#123;&#125;) (int, error)
&#x2F;&#x2F;Printf 最后调用Fprintf 函数
func Printf(format string, args ...interface&#123;&#125;) (int, error) &#123;
    return Fprintf(os.Stdout, format, args...)
&#125;
&#x2F;&#x2F; Sprintf函数最后也是调用Fprintf
func Sprintf(format string, args ...interface&#123;&#125;) string &#123;
    var buf bytes.Buffer
    Fprintf(&amp;buf, format, args...)
    return buf.String()
&#125;</code></pre>

<p><code>Fprintf</code>函数的<code>F</code>说明了文件类型也说明了所有信息要被写入到文件当中，在<code>Printf</code>函数中的第一个参数<code>os.Stdout</code>是<code>*os.File</code>类型实现了<code>io.Writer</code>接口，在<code>Sprintf</code>函数中的第一个参数<code>&amp;buf</code>是一个指向可以写入字节的内存缓冲区也该类型也是实现了<code>io.Writer</code>接口,用户可以自定义一个函数并实现<code>io.Writer</code>接口。<br><strong>LSP里氏替换</strong> : <code>fmt.Fprintf</code>通过使用接口类型<code>io.Writer</code>使得只要调用者只要传入实现了该接口的类型就可以实现自由替换</p>
<details><summary>自定义bytecounter函数，实现计算int转byte长度</summary>

<pre class="language-golang" data-language="golang"><code class="language-golang">
package main

import (
	&quot;fmt&quot;
)

&#x2F;&#x2F;!+bytecounter

type ByteCounter int

func (c *ByteCounter) Write(p []byte) (int, error) &#123;
	*c +&#x3D; ByteCounter(len(p)) &#x2F;&#x2F; convert int to ByteCounter
	return len(p), nil
&#125;

&#x2F;&#x2F;!-bytecounter

func main() &#123;
	&#x2F;&#x2F;!+main
	var c ByteCounter
	c.Write([]byte(&quot;hello&quot;))
	fmt.Println(c) &#x2F;&#x2F; &quot;5&quot;, &#x3D; len(&quot;hello&quot;)

	c &#x3D; 0 &#x2F;&#x2F; reset the counter
	var name &#x3D; &quot;Dolly&quot;
	fmt.Fprintf(&amp;c, &quot;hello, %s&quot;, name)
	fmt.Println(c) &#x2F;&#x2F; &quot;12&quot;, &#x3D; len(&quot;hello, Dolly&quot;)
	&#x2F;&#x2F;!-main
&#125;</code></pre>

</details>

<p>因为它实现了<code>writer</code>接口就可以传入到<code>Fprintf</code>函数中.总结来说，接口约定了包使用者的行为，但是使用者想创建什么样的实例需要他自己去实现。</p>
<h2 id="7-2-接口类型"><a href="#7-2-接口类型" class="headerlink" title="7.2 接口类型"></a>7.2 接口类型</h2><p>通过组合定义接口</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package io
type Reader interface &#123;
    Read(p []byte) (n int, err error)
&#125;
type Closer interface &#123;
    Close() error
&#125;

type ReadWriter interface &#123;
    Reader
    Writer
&#125;
type ReadWriteCloser interface &#123;
    Reader
    Writer
    Closer
&#125;
&#x2F;&#x2F; 另一种命名风格
type ReadWriter interface &#123;
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
&#125;
&#x2F;&#x2F;或者甚至使用一种混合的风格：

type ReadWriter interface &#123;
    Read(p []byte) (n int, err error)
    Writer
&#125;</code></pre>

<h2 id="7-3-实现接口的条件"><a href="#7-3-实现接口的条件" class="headerlink" title="7.3 实现接口的条件"></a>7.3 实现接口的条件</h2><ul>
<li><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer
&#x2F;&#x2F;只实现了Write 方法
w &#x3D; os.Stdout           &#x2F;&#x2F; OK: *os.File has Write method
&#x2F;&#x2F;只实现了Write方法
w &#x3D; new(bytes.Buffer)   &#x2F;&#x2F; OK: *bytes.Buffer has Write method
&#x2F;&#x2F; time.Duration没有Write方法
w &#x3D; time.Second         &#x2F;&#x2F; compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc &#x3D; os.Stdout         &#x2F;&#x2F; OK: *os.File has Read, Write, Close methods
rwc &#x3D; new(bytes.Buffer) &#x2F;&#x2F; compile error: *bytes.Buffer lacks Close method
&#x2F;&#x2F; 这个规则甚至适用于等式右边本身也是一个接口类型
&#x2F;&#x2F; rwc io.ReadWriteCloser
w &#x3D; rwc                 &#x2F;&#x2F; OK: io.ReadWriteCloser has Write method
&#x2F;&#x2F; w 只有Write方法
rwc &#x3D; w                 &#x2F;&#x2F; compile error: io.Writer lacks Close method</code></pre>
</li>
<li></li>
</ul>
<h2 id="7-4-flag-Value接口"><a href="#7-4-flag-Value接口" class="headerlink" title="7.4 flag.Value接口"></a>7.4 flag.Value接口</h2><p>(翻译的太差劲，要去读原文)</p>
<ul>
<li><p>简单的<code>flag</code>包支持命令行的例子</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var period &#x3D; flag.Duration(&quot;period&quot;, 1*time.Second, &quot;sleep period&quot;)

func main() &#123;
    flag.Parse()
    fmt.Printf(&quot;Sleeping for %v...&quot;, *period)
    time.Sleep(*period)
    fmt.Println()
&#125;</code></pre>
</li>
<li><p>自定义新的标记符号</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">package tempconv

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

type Celsius float64
type Fahrenheit float64

func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9.0&#x2F;5.0 + 32.0) &#125;
func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32.0) * 5.0 &#x2F; 9.0) &#125;

func (c Celsius) String() string &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125;

&#x2F;*
&#x2F;&#x2F;!+flagvalue
package flag

&#x2F;&#x2F; Value is the interface to the value stored in a flag.
type Value interface &#123;
    String() string
    Set(string) error
&#125;
&#x2F;&#x2F;!-flagvalue
*&#x2F;

&#x2F;&#x2F;!+celsiusFlag
&#x2F;&#x2F; *celsiusFlag satisfies the flag.Value interface.
type celsiusFlag struct&#123; Celsius &#125;

func (f *celsiusFlag) Set(s string) error &#123;
    var unit string
    var value float64
    fmt.Sscanf(s, &quot;%f%s&quot;, &amp;value, &amp;unit) &#x2F;&#x2F; no error check needed
    switch unit &#123;
    case &quot;C&quot;, &quot;°C&quot;:
        f.Celsius &#x3D; Celsius(value)
        return nil
    case &quot;F&quot;, &quot;°F&quot;:
        f.Celsius &#x3D; FToC(Fahrenheit(value))
        return nil
    &#125;
    return fmt.Errorf(&quot;invalid temperature %q&quot;, s)
&#125;

&#x2F;&#x2F;!-celsiusFlag

&#x2F;&#x2F;!+CelsiusFlag

&#x2F;&#x2F; CelsiusFlag defines a Celsius flag with the specified name,
&#x2F;&#x2F; default value, and usage, and returns the address of the flag variable.
&#x2F;&#x2F; The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.
func CelsiusFlag(name string, value Celsius, usage string) *Celsius &#123;
    f :&#x3D; celsiusFlag&#123;value&#125;
    flag.CommandLine.Var(&amp;f, name, usage)
    return &amp;f.Celsius
&#125;
&#x2F;&#x2F; main函数
var temp &#x3D; tempconv.CelsiusFlag(&quot;temp&quot;, 20.0, &quot;the temperature&quot;)

func main() &#123;
    flag.Parse()
    fmt.Println(*temp)
&#125;</code></pre></li>
</ul>
<h2 id="7-5-接口值"><a href="#7-5-接口值" class="headerlink" title="7.5 接口值"></a>7.5 接口值</h2><p>下面语句中,<code>io.Writer</code>是接口类型值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer
w &#x3D; os.Stdout
w &#x3D; new(bytes.Buffer)
w &#x3D; nil</code></pre>
<ul>
<li><p>对于接口的定义也不例外，<code>接口</code>的零值是它的类型和值的部分都是<code>nil</code></p>
</li>
<li><p>一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w&#x3D;&#x3D;nil或者w!&#x3D;nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生<code>panic</code>: <code>w.Write([]byte(&quot;hello&quot;)) // panic: nil pointer dereference</code></p>
</li>
<li><p>第二句statement，这个赋值过程调用了一个<code>具体类型</code>到<code>接口类型</code>的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的<code>os.File</code>类型变量的指针.接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是nil值。</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;
os.Stdout.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot; 
&#x2F;&#x2F;上下两句是等价的</code></pre></li>
<li><p>一个接口值可以持有任意大的动态值</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var x interface&#123;&#125; &#x3D; time.Now()</code></pre>

<p>  接口值可以使用&#x3D;&#x3D;和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的&#x3D;&#x3D;操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数,然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var x interface&#123;&#125; &#x3D; []int&#123;1, 2, 3&#125;
fmt.Println(x &#x3D;&#x3D; x) &#x2F;&#x2F; panic: comparing uncomparable type []int</code></pre></li>
</ul>
<p>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值.</p>
<ul>
<li><em>警告</em>: 一个包含nil指针的接口不是nil接口</li>
</ul>
<p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>
<p>思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const debug &#x3D; true

func main() &#123;
    var buf *bytes.Buffer
    if debug &#123;
        buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output
    &#125;
    f(buf) &#x2F;&#x2F; NOTE: subtly incorrect!
    if debug &#123;
        &#x2F;&#x2F; ...use buf...
    &#125;
&#125;

&#x2F;&#x2F; If out is non-nil, output will be written to it.
func f(out io.Writer) &#123;
    &#x2F;&#x2F; ...do something...
    if out !&#x3D; nil &#123;
        out.Write([]byte(&quot;done!\n&quot;))
    &#125;
&#125;</code></pre>
<p>我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if out !&#x3D; nil &#123;
    out.Write([]byte(&quot;done!\n&quot;)) &#x2F;&#x2F; panic: nil pointer dereference
&#125;</code></pre>
<p>当main函数调用函数f时，它给f函数的out参数赋了一个<em>bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是</em>bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!&#x3D;nil的结果依然是true。</p>
<p><img src="https://user-images.githubusercontent.com/46363359/182982938-08d67c3f-7aa6-457d-88a5-02646c5e2735.png"></p>
<p>动态分配机制依然决定(<em>bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如</em>os.File的类型，nil是一个有效的接收者（§6.2.1），但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</p>
<p>问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var buf io.Writer
if debug &#123;
    buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output
&#125;
f(buf) &#x2F;&#x2F; OK</code></pre>
<p>现在我们已经把接口值的技巧都讲完了，让我们来看更多的一些在Go标准库中的重要接口类型。在下面的三章中，我们会看到接口类型是怎样用在排序，web服务，错误处理中的。</p>
<h2 id="7-6-sort-Interface接口"><a href="#7-6-sort-Interface接口" class="headerlink" title="7.6. sort.Interface接口"></a>7.6. sort.Interface接口</h2><p>golang提供了<code>sort</code>包帮助进行排序数据,实现排序需要自己实现对应的排序接口.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type byArtist []*Track
func (x byArtist) Len() int           &#123; return len(x) &#125;
func (x byArtist) Less(i, j int) bool &#123; return x[i].Artist &lt; x[j].Artist &#125;
func (x byArtist) Swap(i, j int)      &#123; x[i], x[j] &#x3D; x[j], x[i] &#125;</code></pre>
<p>对于自定义的排序，我们也需要实现排序函数.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;!+customcode
type customSort struct &#123;
	t    []*Track
	less func(x, y *Track) bool
&#125;

func (x customSort) Len() int           &#123; return len(x.t) &#125;
func (x customSort) Less(i, j int) bool &#123; return x.less(x.t[i], x.t[j]) &#125;
func (x customSort) Swap(i, j int)      &#123; x.t[i], x.t[j] &#x3D; x.t[j], x.t[i] &#125;

sort.Sort(customSort&#123;tracks, func(x, y *Track) bool &#123;
		if x.Title !&#x3D; y.Title &#123;
			return x.Title &lt; y.Title
		&#125;
		if x.Year !&#x3D; y.Year &#123;
			return x.Year &lt; y.Year
		&#125;
		if x.Length !&#x3D; y.Length &#123;
			return x.Length &lt; y.Length
		&#125;
		return false
	&#125;&#125;)</code></pre>
<p><code>IntsAreSorted(...interface&#123;&#125;)</code> reports whether the slice x is sorted in increasing order.</p>
<h2 id="7-7-http-Handler接口"><a href="#7-7-http-Handler接口" class="headerlink" title="7.7. http.Handler接口"></a>7.7. http.Handler接口</h2><p>http.Handler的实例</p>
<h2 id="7-8-error接口"><a href="#7-8-error接口" class="headerlink" title="7.8. error接口"></a>7.8. error接口</h2><pre class="language-golang" data-language="golang"><code class="language-golang">
package errors_demo

func New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125;

type errorString struct &#123; text string &#125;

func (e *errorString) Error() string &#123; return e.text &#125;</code></pre>
<p>调用<code>errors.New</code>函数是非常稀少的，因为有一个方便的封装函数<code>fmt.Errorf</code>它还会处理字符串格式化<br>另一个error demo实例</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package syscall

type Errno uintptr &#x2F;&#x2F; operating system error code

var errors &#x3D; [...]string&#123;
    1:   &quot;operation not permitted&quot;,   &#x2F;&#x2F; EPERM
    2:   &quot;no such file or directory&quot;, &#x2F;&#x2F; ENOENT
    3:   &quot;no such process&quot;,           &#x2F;&#x2F; ESRCH
    &#x2F;&#x2F; ...
&#125;

func (e Errno) Error() string &#123;
    if 0 &lt;&#x3D; int(e) &amp;&amp; int(e) &lt; len(errors) &#123;
        return errors[e]
    &#125;
    return fmt.Sprintf(&quot;errno %d&quot;, e)
&#125;

var err error &#x3D; syscall.Errno(2)
fmt.Println(err.Error()) &#x2F;&#x2F; &quot;no such file or directory&quot;
fmt.Println(err)         &#x2F;&#x2F; &quot;no such file or directory&quot;</code></pre>
<p>用有限几个进行描述，并且它满足标准错误接口</p>
<h2 id="7-9-类型断言"><a href="#7-9-类型断言" class="headerlink" title="7.9. 类型断言"></a>7.9. 类型断言</h2><p>语法上它看起来像<code>x.(T)</code>被称为断言类型，这里<code>x</code>表示一个接口的类型和T表示一个类型,详细解释，一个类型断言检查它操作对象的动态类型是否和断言的类型是否匹配,分两种情况</p>
<ul>
<li><p>(T传入的是具体类型，X是动态类型),然后类型断言检查<code>X</code>的动态类型是否和<code>T</code>相同.如果检查成功了类型断言的结果就是<code>X</code>的动态值</p>
</li>
<li><p>(T传入的是接口类型，X是动态类型),然后类型断言检查是否<code>x</code>的动态类型满足T,如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">
var w io.Writer
w &#x3D; os.Stdout   &#x2F;&#x2F;能赋值说明os.Stdout 实现了Write()方法
rw :&#x3D; w.(io.ReadWriter) &#x2F;&#x2F; success: *os.File has both Read and Write,断言w是否实现了接口(io.ReadWriter)的Read和Write接口
w &#x3D; new(ByteCounter)
rw &#x3D; w.(io.ReadWriter) &#x2F;&#x2F; panic: *ByteCounter has no Read method
&#x2F;&#x2F;如果对预期结果只是个判断就可以用第二个返回参数bool.
var w io.Writer &#x3D; os.Stdout
f, ok :&#x3D; w.(*os.File)      &#x2F;&#x2F; success:  ok, f &#x3D;&#x3D; os.Stdout
b, ok :&#x3D; w.(*bytes.Buffer) &#x2F;&#x2F; failure: !ok, b &#x3D;&#x3D; nil
&#x2F;&#x2F; if 后面的w变量不会覆盖外层的w
if w, ok :&#x3D; w.(*os.File); ok &#123;
&#x2F;&#x2F; ...use w...
&#125;</code></pre></li>
</ul>
<h2 id="7-10-基于类型断言区别错误类型"><a href="#7-10-基于类型断言区别错误类型" class="headerlink" title="7.10. 基于类型断言区别错误类型"></a>7.10. 基于类型断言区别错误类型</h2><p>对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。</p>
<p>一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">

package main

import (
	&quot;errors&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;syscall&quot;
)

type PathError struct &#123;
	Op   string
	Path string
	Err  error
&#125;

func (e *PathError) Error() string &#123;
	return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()
&#125;

var ErrNotExist &#x3D; errors.New(&quot;file does not exist&quot;)

&#x2F;&#x2F; IsNotExist returns a boolean indicating whether the error is known to
&#x2F;&#x2F; report that a file or directory does not exist. It is satisfied by
&#x2F;&#x2F; ErrNotExist as well as some syscall errors.
func IsNotExist(err error) bool &#123;
	if pe, ok :&#x3D; err.(*PathError); ok &#123;
		err &#x3D; pe.Err
	&#125;
	return err &#x3D;&#x3D; syscall.ENOENT || err &#x3D;&#x3D; ErrNotExist
&#125;

func main() &#123;
	_, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)
	fmt.Println(os.IsNotExist(err)) &#x2F;&#x2F; &quot;true&quot;
&#125;</code></pre>

<h2 id="7-11-any关键字与泛型"><a href="#7-11-any关键字与泛型" class="headerlink" title="7.11. any关键字与泛型"></a>7.11. any关键字与泛型</h2><p>类型定义时不限制<code>形参类型</code>，在函数调用的时候再指定<code>具体类型</code>.  <code>any</code>其实是<code>interface&#123;&#125;</code>的别名<br>泛型好处:  (1).在编译期间对类型进行检查以提高类型安全(2).通过指定类型消除强制类型转换(3).能够减少代码重复性，提供更通用的功能函数。</p>
<ul>
<li>类型泛型<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

type ListType[T int | int32 | int64 | string] []T

type MapType[K int | int32, V int64 | string] map[K]V

func main() &#123;
    var intList ListType[int]
    intList &#x3D; []int&#123;1, 2, 3&#125;
    fmt.Println(intList)
    strList :&#x3D; ListType[string]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;
    fmt.Println(strList)

    intMap :&#x3D; MapType[int, string]&#123;1: &quot;1&quot;, 2: &quot;2&quot;&#125;
    int32Map :&#x3D; MapType[int32, int64]&#123;1: 2, 3: 4&#125;
    fmt.Println(intMap)
    fmt.Println(int32Map)
&#125;</code></pre>
这里面的T,K,V都是占位符号,<code>ListType</code>只能在那三种类型中选择,同理<code>MapType</code>也是</li>
<li>接口泛型<pre class="language-golang" data-language="golang"><code class="language-golang">type GenericStackInterface[T any] interface &#123;
  Push(element T)
  Pop() T
&#125;</code></pre></li>
<li>泛型函数<pre class="language-golang" data-language="golang"><code class="language-golang">func minInt[T int | int8 | int16 | int32](a, b T) T &#123;
if a &lt; b &#123;
    return a
&#125;
    return b
&#125;

func maxInt[T int | int8 | int16 | int32](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
func Mix(a any) any &#123;

&#125;
&#x2F;&#x2F;还可以简化一下
type Numeric interface &#123;
    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64
&#125;
func min[T Numeric](a, b T) T &#123;
if a &lt; b &#123;
    return a
&#125;
    return b
&#125;

func max[T Numeric](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
&#x2F;&#x2F; go.18内置了数字类型的集合，故可以
import (
&quot;golang.org&#x2F;x&#x2F;exp&#x2F;constraints&quot;
)

func minType[T constraints.Ordered](a, b T) T &#123;
    if a &lt; b &#123;
        return a
    &#125;
    return b
&#125;

func maxType[T constraints.Ordered](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;</code></pre>
如果进入<code>constraints</code>源代码查看其具体代码的话，会发现在 Ordered 类型中也是有各种数字类型组合起来的。但是有一点奇怪的地方就是这里的类型集合中，各种类型前加了一个波浪线~, 表示衍生类型，即使用 type 自定义的类型也可以被识别到，只要底层类型一致即可。比如 ~int 可以包含 int 和 type MyInt int 等多种类型</li>
</ul>
<h1 id="8-Goroutines和Channels"><a href="#8-Goroutines和Channels" class="headerlink" title="8. Goroutines和Channels"></a>8. Goroutines和Channels</h1><p>(多看看本章代码)</p>
<h2 id="8-1-goroutine"><a href="#8-1-goroutine" class="headerlink" title="8.1 goroutine"></a>8.1 goroutine</h2><p>通过代码示例了解<code>goroutine</code>的使用</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
    go spinner(100 * time.Millisecond)
    const n &#x3D; 45
    fibN :&#x3D; fib(n) &#x2F;&#x2F; slow
    fmt.Printf(&quot;\rFibonacci(%d) &#x3D; %d\n&quot;, n, fibN)
&#125;

func spinner(delay time.Duration) &#123;
    for &#123;
        for _, r :&#x3D; range &#96;-\|&#x2F;&#96; &#123;
            fmt.Printf(&quot;\r%c&quot;, r)
            time.Sleep(delay)
        &#125;
    &#125;
&#125;

func fib(x int) int &#123;
    if x &lt; 2 &#123;
        return x
    &#125;
    return fib(x-1) + fib(x-2)
&#125;</code></pre>
<h2 id="8-2-channel"><a href="#8-2-channel" class="headerlink" title="8.2 channel"></a>8.2 channel</h2><p>这里应该还得看一下uber编码规范</p>
<ul>
<li><p>无缓冲channel</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">ch &lt;- x
x &#x3D; &lt;-chan &#x2F;&#x2F;取出元素
&lt;- ch &#x2F;&#x2F;取出，舍弃
close(ch) &#x2F;&#x2F; 关闭chan</code></pre>

<ul>
<li><p>串联channel</p>
</li>
<li><p>单方向channel</p>
</li>
</ul>
</li>
<li><p>缓冲channel</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">ch &#x3D; make(chan string, 3) &#x2F;&#x2F;channel容量为3</code></pre></li>
</ul>
<h2 id="8-3-基于select的多路复用"><a href="#8-3-基于select的多路复用" class="headerlink" title="8.3 基于select的多路复用"></a>8.3 基于select的多路复用</h2><details>
<summary>多路复用demo</summary>
<pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.
&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;

&#x2F;&#x2F; See page 246.

&#x2F;&#x2F; Countdown implements the countdown for a rocket launch.
package main

&#x2F;&#x2F; NOTE: the ticker goroutine never terminates if the launch is aborted.
&#x2F;&#x2F; This is a &quot;goroutine leak&quot;.

import (
        &quot;fmt&quot;
        &quot;os&quot;
        &quot;time&quot;
)

&#x2F;&#x2F;!+

func main() &#123;
        &#x2F;&#x2F; ...create abort channel...

        &#x2F;&#x2F;!-

        abort :&#x3D; make(chan struct&#123;&#125;)
        go func() &#123;
                os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte
                abort &lt;- struct&#123;&#125;&#123;&#125;
        &#125;()

        &#x2F;&#x2F;!+
        fmt.Println(&quot;Commencing countdown.  Press return to abort.&quot;)
        tick :&#x3D; time.Tick(1 * time.Second)
        for countdown :&#x3D; 10; countdown &gt; 0; countdown-- &#123;
                fmt.Println(countdown)
                select &#123;
                case &lt;-tick:
                        &#x2F;&#x2F; Do nothing.
                case &lt;-abort:
                        fmt.Println(&quot;Launch aborted!&quot;)
                        return
                &#125;
        &#125;
        launch()
&#125;
&#x2F;&#x2F;!-
func launch() &#123;
        fmt.Println(&quot;Lift off!&quot;)
&#125;</code></pre>

<p></pre></p>
</details>

<ul>
<li><p>goroutine泄露 : 当for语句执行完后，程序已经跳转到其他部分，但是<code>time.Tick(1 * time.Second)</code>仍然会继续的网channel里面发送数据，这就会导致gotourine泄露，以上面为例，那么就需要合适的地方调用<code>tick.stop()</code></p>
</li>
<li><p>channel的ready : 一定要等到channel准备完毕，开始接受或者发送消息</p>
</li>
<li><p>channel的轮询 : 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">select &#123;
  case &lt;-abort:
      fmt.Printf(&quot;Launch aborted!\n&quot;)
      return
  default:
      &#x2F;&#x2F; do nothing
&#125;</code></pre></li>
</ul>
<h2 id="8-4-并发的退出"><a href="#8-4-并发的退出" class="headerlink" title="8.4. 并发的退出"></a>8.4. 并发的退出</h2><p>这节主要讨论如何有效退出goroutines</p>
<details>
<summary>
<font size="3" color="orange">goroutines退出代码示例</font></summary>
<pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;gopl.io&#x2F;ch8&#x2F;du4
&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.
&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;

&#x2F;&#x2F; See page 251.

&#x2F;&#x2F; The du4 command computes the disk usage of the files in a directory.
package main

&#x2F;&#x2F; The du4 variant includes cancellation:
&#x2F;&#x2F; it terminates quickly when the user hits return.

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;path&#x2F;filepath&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

&#x2F;&#x2F;!+1
var done &#x3D; make(chan struct&#123;&#125;)

func cancelled() bool &#123;
	select &#123;
	case &lt;-done:
		return true
	default:
		return false
	&#125;
&#125;

&#x2F;&#x2F;!-1

func main() &#123;
	&#x2F;&#x2F; Determine the initial directories.
	roots :&#x3D; os.Args[1:]
	if len(roots) &#x3D;&#x3D; 0 &#123;
		roots &#x3D; []string&#123;&quot;.&quot;&#125;
	&#125;

	&#x2F;&#x2F;!+2
	&#x2F;&#x2F; Cancel traversal when input is detected.
	go func() &#123;
		os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte
		close(done)
	&#125;()
	&#x2F;&#x2F;!-2

	&#x2F;&#x2F; Traverse each root of the file tree in parallel.
	fileSizes :&#x3D; make(chan int64)
	var n sync.WaitGroup
	for _, root :&#x3D; range roots &#123;
		n.Add(1)
		go walkDir(root, &amp;n, fileSizes)
	&#125;
	go func() &#123;
		n.Wait()
		close(fileSizes)
	&#125;()

	&#x2F;&#x2F; Print the results periodically.
	tick :&#x3D; time.Tick(500 * time.Millisecond)
	var nfiles, nbytes int64
loop:
	&#x2F;&#x2F;!+3
	for &#123;
		select &#123;
		case &lt;-done:
			&#x2F;&#x2F; Drain fileSizes to allow existing goroutines to finish.
			for range fileSizes &#123;
				&#x2F;&#x2F; Do nothing.
			&#125;
			return
		case size, ok :&#x3D; &lt;-fileSizes:
			&#x2F;&#x2F; ...
			&#x2F;&#x2F;!-3
			if !ok &#123;
				break loop &#x2F;&#x2F; fileSizes was closed
			&#125;
			nfiles++
			nbytes +&#x3D; size
		case &lt;-tick:
			printDiskUsage(nfiles, nbytes)
		&#125;
	&#125;
	printDiskUsage(nfiles, nbytes) &#x2F;&#x2F; final totals
&#125;

func printDiskUsage(nfiles, nbytes int64) &#123;
	fmt.Printf(&quot;%d files  %.1f GB\n&quot;, nfiles, float64(nbytes)&#x2F;1e9)
&#125;

&#x2F;&#x2F; walkDir recursively walks the file tree rooted at dir
&#x2F;&#x2F; and sends the size of each found file on fileSizes.
&#x2F;&#x2F;!+4
func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) &#123;
	defer n.Done()
	if cancelled() &#123;
		return
	&#125;
	for _, entry :&#x3D; range dirents(dir) &#123;
		&#x2F;&#x2F; ...
		&#x2F;&#x2F;!-4
		if entry.IsDir() &#123;
			n.Add(1)
			subdir :&#x3D; filepath.Join(dir, entry.Name())
			go walkDir(subdir, n, fileSizes)
		&#125; else &#123;
			fileSizes &lt;- entry.Size()
		&#125;
		&#x2F;&#x2F;!+4
	&#125;
&#125;

&#x2F;&#x2F;!-4

var sema &#x3D; make(chan struct&#123;&#125;, 20) &#x2F;&#x2F; concurrency-limiting counting semaphore

&#x2F;&#x2F; dirents returns the entries of directory dir.
&#x2F;&#x2F;!+5
func dirents(dir string) []os.FileInfo &#123;
	select &#123;
	case sema &lt;- struct&#123;&#125;&#123;&#125;: &#x2F;&#x2F; acquire token
	case &lt;-done:
		return nil &#x2F;&#x2F; cancelled
	&#125;
	defer func() &#123; &lt;-sema &#125;() &#x2F;&#x2F; release token

	&#x2F;&#x2F; ...read directory...
	&#x2F;&#x2F;!-5

	f, err :&#x3D; os.Open(dir)
	if err !&#x3D; nil &#123;
		fmt.Fprintf(os.Stderr, &quot;du: %v\n&quot;, err)
		return nil
	&#125;
	defer f.Close()

	entries, err :&#x3D; f.Readdir(0) &#x2F;&#x2F; 0 &#x3D;&gt; no limit; read all entries
	if err !&#x3D; nil &#123;
		fmt.Fprintf(os.Stderr, &quot;du: %v\n&quot;, err)
		&#x2F;&#x2F; Don&#39;t return: Readdir may return partial results.
	&#125;
	return entries
&#125;</code></pre>

<p></pre></p>
</details>

<h1 id="9-基于共享变量的并发"><a href="#9-基于共享变量的并发" class="headerlink" title="9. 基于共享变量的并发"></a>9. 基于共享变量的并发</h1><p>(多看这章代码)<br>避免数据竞争的三个方法</p>
<ul>
<li><p>并发读数据不会有数据竞争问题</p>
</li>
<li><p>避免从多个goroutine中访问变量，使用独立变量</p>
</li>
<li><p>临界区控制</p>
</li>
<li><p>总结</p>
<ul>
<li>数据竞争: 程序在多个goroutine交叉执行操作时，导致数据不一致.  </li>
<li><code>包级别</code>的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。<br>  (多看看本章代码)</li>
</ul>
</li>
</ul>
<h2 id="9-1-sync-Mutex与sync-RMutex互斥锁"><a href="#9-1-sync-Mutex与sync-RMutex互斥锁" class="headerlink" title="9.1 sync.Mutex与sync.RMutex互斥锁"></a>9.1 sync.Mutex与sync.RMutex互斥锁</h2><p>比如银行存款查询余额的场景，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款(这句话很关键要没有)操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁</p>
<ul>
<li>总结<ul>
<li>避免临界区中的变量在中途被其他的goroutine修改</li>
<li>使用mutex包进行互斥goroutine</li>
<li>一个deferred Unlock即使在临界区发生<code>panic</code>时依然会执行</li>
<li>golang不支持重入锁</li>
<li>sync.RWMutex.RLock()持锁，sync.RWMutex.Lock()会阻塞，相同的RWMutex.Lock()持锁，sync.RWMutex.RLock()阻塞，但是sync.RWMutex.RLock()阻塞之间不阻塞</li>
</ul>
</li>
</ul>
<h2 id="9-2-sync-Once惰性初始化"><a href="#9-2-sync-Once惰性初始化" class="headerlink" title="9.2 sync.Once惰性初始化"></a>9.2 sync.Once惰性初始化</h2><p>如果初始化的成本太高，需要延迟的初始化对象。可考虑使用<code>sync.Once</code><br><detials></p>
<summary>sync.One的demo</summary>
<pre>

<p></pre></p>
</details>


<h2 id="9-3-sync-Cond的使用"><a href="#9-3-sync-Cond的使用" class="headerlink" title="9.3 sync.Cond的使用"></a>9.3 sync.Cond的使用</h2><ol>
<li><p>使用场景: <code>sync.Cond</code> 经常用在多个goroutine等待，一个goroutine通知,如果是一读一等待使用<code>sync.Mutx</code>和<code>chan</code>就可以</p>
</li>
<li><p><code>sync.Cond</code>的<a target="_blank" rel="noopener" href="https://pkg.go.dev/sync@go1.19#Cond">方法</a></p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
&#x2F;&#x2F; which must be held when changing the condition and
&#x2F;&#x2F; when calling the Wait method.
&#x2F;&#x2F;
&#x2F;&#x2F; A Cond must not be copied after first use.
type Cond struct &#123;
        noCopy noCopy
        &#x2F;&#x2F; L is held while observing or changing the condition
        L Locker
        notify  notifyList
        checker copyChecker
&#125;
</code></pre>

<p> Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Signal wakes one goroutine waiting on c, if there is any.
&#x2F;&#x2F;
&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L
&#x2F;&#x2F; during the call.
&#x2F;&#x2F;Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护
func (c *Cond) Signal()
&#x2F;&#x2F; Broadcast wakes all goroutines waiting on c.
&#x2F;&#x2F;
&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L
&#x2F;&#x2F; during the call.
func (c *Cond) Broadcast()

&#x2F;&#x2F; Wait atomically unlocks c.L and suspends execution
&#x2F;&#x2F; of the calling goroutine. After later resuming execution,
&#x2F;&#x2F; Wait locks c.L before returning. Unlike in other systems,
&#x2F;&#x2F; Wait cannot return unless awoken by Broadcast or Signal.
&#x2F;&#x2F;
&#x2F;&#x2F; Because c.L is not locked when Wait first resumes, the caller
&#x2F;&#x2F; typically cannot assume that the condition is true when
&#x2F;&#x2F; Wait returns. Instead, the caller should Wait in a loop:
&#x2F;&#x2F;
&#x2F;&#x2F;    c.L.Lock()
&#x2F;&#x2F;    for !condition() &#123;
&#x2F;&#x2F;        c.Wait()
&#x2F;&#x2F;    &#125;
&#x2F;&#x2F;    ... make use of condition ...
&#x2F;&#x2F;    c.L.Unlock()
&#x2F;&#x2F;挂起调用者所在的 goroutine,等待Broadcast或者Signal方法
func (c *Cond) Wait()
    &#x2F;&#x2F;代码片段
    c.L.Lock()
    for !condition() &#123;
        c.Wait()
    &#125;
    ... make use of condition ...
    c.L.Unlock()



</code></pre>
</li>
<li><p>Cond代码示例</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">var done &#x3D; false

func read(name string, c *sync.Cond) &#123;
    c.L.Lock()
    for !done &#123;
        c.Wait()
    &#125;
    log.Println(name, &quot;starts reading&quot;)
    c.L.Unlock()
&#125;

func write(name string, c *sync.Cond) &#123;
    log.Println(name, &quot;starts writing&quot;)
    time.Sleep(time.Second)
    c.L.Lock()
    done &#x3D; true
    c.L.Unlock()
    log.Println(name, &quot;wakes all&quot;)
    c.Broadcast()
&#125;

func main() &#123;
    cond :&#x3D; sync.NewCond(&amp;sync.Mutex&#123;&#125;)

    go read(&quot;reader1&quot;, cond)
    go read(&quot;reader2&quot;, cond)
    go read(&quot;reader3&quot;, cond)
    write(&quot;writer&quot;, cond)

    time.Sleep(time.Second * 3)
&#125;
</code></pre></li>
</ol>
<h2 id="9-4-Goroutines和线程"><a href="#9-4-Goroutines和线程" class="headerlink" title="9.4. Goroutines和线程"></a>9.4. Goroutines和线程</h2><ul>
<li><p>每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量</p>
</li>
<li><p>一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩</p>
</li>
<li><p>Go的<code>运行时</code>有自己的调度器，这个调度器比如m:n调度，n个操作系统线程调度m个gotoutine，例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。</p>
</li>
<li><p>GOMAXPROCS : 变量来决定会有多少个操作系统的线程同时执行Go的代码,其默认的值是运行机器上的CPU的核心数,<code>GOMAXPROCS</code>是前面说的m:n调度中的n.下面代码就可以简单的看出os线程调度代码的情况</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
for &#123;
    go fmt.Print(0)
    fmt.Print(1)
&#125;

$ GOMAXPROCS&#x3D;1 go run hacker-cliché.go
111111111111111111110000000000000000000011111...

$ GOMAXPROCS&#x3D;2 go run hacker-cliché.go
010101010101010101011001100101011010010100110...</code></pre>


</li>
<li><p>总结</p>
<ul>
<li>通过广播机制来取消goroutines</li>
<li>确保主函数退出，routines也随即退出</li>
</ul>
</li>
</ul>
<h1 id="10-包和工具"><a href="#10-包和工具" class="headerlink" title="10. 包和工具"></a>10. 包和工具</h1><p>互联网上已经发布了非常多的Go语言开源包，它们可以通过 <a target="_blank" rel="noopener" href="http://godoc.org/">http://godoc.org</a> 检索</p>
<ul>
<li>包的声明 ： 通过<code>package.struct</code>的形式访问我们的下载的<code>package</code>,但是也有同名的例如<code>math/rand</code>和<code>crypto/rand</code>，这种要重新指定包名，只影响当前文件，同时也解决了那些又臭又长的包名</li>
<li>文件开头以<code>_</code>和<code>.</code>的会被忽略</li>
<li>以<code>_test</code>结尾的通常是测试包</li>
<li>一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in&#x2F;yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml</li>
<li><code>包的匿名导入</code>:<ul>
<li>解决包的依赖顺序</li>
<li>初始化包级声明的变量</li>
<li>按顺序初始化包中每个文件里的 init 函数</li>
<li>每个文件中可以包含多个 init 函数，按顺序执行(所以你导和不导包差距很大，匿名导入只是表明你无法使用相应包内函数)</li>
<li>包名和成员名要尽量的短，并且能见名知意</li>
</ul>
</li>
<li>go的工具<ul>
<li>工作区结构 : 当需要切换工作区的时候，只需要更新下GOPATH环境变量即可<code>src</code>保存源代码,<code>pkg</code>子目录用于保存编译后的包的目标文件,<code>bin</code>子目录用于保存编译后的可执行程序</li>
<li>下载包 : <code>go get</code>命令，<code>go get -u</code>命令只是简单地保证每个下载最新版本，实际工作中要对包版本做精细的管理，需要vendor目录管理不同版本的包,<code>go help gopath</code>查看vendor帮助文档,而go get 相当于获取的是远程仓库源代码的整个库，还可以看到仓库的版本信息，go支持导入远程github仓库的代码，<code>go get</code>下载的包保存在哪里呢？一般他会保存在这个目录：<code>GOPATH/src</code><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrbug/p/11990418.html#:~:text=go%20get%20%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8C%85,%E7%9A%84go%20%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E3%80%82">goget详细介绍</a>，<code>go get</code>是对模块代码的更新</li>
<li>构建包 : 可以使用相对路径和绝对路径进行构建项目，<code>go run</code>其实也可以偷懒，直接<code>go run *.go</code>,<code>go build -i</code>命令将安装每个目标所依赖的包,<code>// +build linux darwin</code>,在包声明和包注释的前面，该构建注释参数告诉<code>go build</code>只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件,<code>// +build ignore</code>这个构建注释则表示不编译这个文件。<code>go doc go/build</code></li>
<li>包文档 : 专门用于保存包文档的源文件通常叫<code>doc.go</code>,例如 <code>go doc time</code> 某个具体成员结构<code>go doc time.Since</code>,或者具体函数<code>go doc time.Duration.Second</code> , 更简单的是<code>godoc -http :8000</code>包含了所有go包的索引，<code>-analysis=type</code>和<code>-analysis=pointer</code>命令行标志参数用于打开文档和代码中关于静态分析的结果</li>
<li>内部包 : 一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包</li>
<li>搜索包 : <code>go list</code>列出工作区相关包,还可以查看完整包的原信息,例如<code>hash</code>包<code>go list -json hash</code><ul>
<li>命令行参数-f则允许用户使用text&#x2F;template包（§4.6）的模板语言定义输出文本的格式<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;windows环境下注意
go list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...
  compress&#x2F;bzip2 -&gt; bufio io sort
  compress&#x2F;flate -&gt; bufio fmt io math sort strconv
  compress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io time
  compress&#x2F;lzw -&gt; bufio errors fmt io
  compress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="11-测试"><a href="#11-测试" class="headerlink" title="11. 测试"></a>11. 测试</h1><p>go test选项含义</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">
-args 传递参数到test binary<span class="token punctuation">(</span>到时候补一个demo<span class="token punctuation">)</span>
-c 编译test binary,但是不执行
-exec xprog  运行test binary ,原理如同 go run
-i 安装test binary的相关依赖
-json 将测试输出转化为json为了自动化处理
-c <span class="token function">file</span>   定义编译后的binary的文件名
</code></pre>


<h2 id="11-1-go-test"><a href="#11-1-go-test" class="headerlink" title="11.1 go test"></a>11.1 go test</h2><p>一个测试函数是以<code>Test</code>为函数名前缀的函数<br>一个基准测试函数是以<code>Benchmark</code>为函数名前缀的函数<br>一个示例函数是以<code>Example</code>为函数名前缀的函数，提供一个由编译器保证正确性的示例文档</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">- &#96;go test -v &#96;会打印每个函数的名字和运行时间
- &#96;go test -run&#x3D; &#96;会去匹配正则表达式，只有被匹配到的才会被执行
- &#96;go test -v .&#x2F;...&#96; 执行所有当前目录下测试cases
- &#96;go test -v foo&#x2F;...&#96; 执行foo目录下所有cases
- &#96;go test -v foo...&#96; 执行指定前缀的测试cases
- &#96;go test ...&#96; gopath下所有测试cases
- &#96;go test -v hello_test.go&#96; 执行某一文件下的测试cases,但是该文件中如果调用了其它文件中的模块会报错
- &#96;go test -v hello_test.go -test.run TestHello&#96; 测试单个函数</code></pre>
<ul>
<li><p>组织多个测试用例</p>
<p>即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息,可以使用<code>t.Fatal</code>或<code>t.Fatalf</code>停止当前测试函数</p>
  <details>
  <summary>组织多测试用例</summary>
  <pre>
  
  <pre class="language-golang" data-language="golang"><code class="language-golang">func TestIsPalindrome(t *testing.T) &#123;
var tests &#x3D; []struct &#123;
    input string
    want  bool
&#125;&#123;
        &#123;&quot;&quot;, true&#125;,
        &#123;&quot;a&quot;, true&#125;,
        &#123;&quot;aa&quot;, true&#125;,
        &#123;&quot;ab&quot;, false&#125;,
        &#123;&quot;kayak&quot;, true&#125;,
        &#123;&quot;detartrated&quot;, true&#125;,
        &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;,
        &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;,
        &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;,
        &#123;&quot;été&quot;, true&#125;,
        &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;,
        &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome
        &#123;&quot;desserts&quot;, false&#125;,   &#x2F;&#x2F; semi-palindrome
    &#125;
    for _, test :&#x3D; range tests &#123;
        if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123;
            t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got)
        &#125;
    &#125;
&#125;</code></pre>

<p>  </pre></p>
  </details>
</li>
<li><p>随机测试</p>
<ol>
<li>编写对照函数，效率低下</li>
<li>生成的随机输入的数据遵循特定的模式，然后就知道期望的输出</li>
</ol>
<pre class="language-golang" data-language="golang"><code class="language-golang">
import &quot;math&#x2F;rand&quot;

  &#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents
  &#x2F;&#x2F; are derived from the pseudo-random number generator rng.
  func randomPalindrome(rng *rand.Rand) string &#123;
      n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24
      runes :&#x3D; make([]rune, n)
      for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;
          r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\u0999&#39;
          runes[i] &#x3D; r
          runes[n-1-i] &#x3D; r
      &#125;
      return string(runes)
  &#125;

  func TestRandomPalindromes(t *testing.T) &#123;
      &#x2F;&#x2F; Initialize a pseudo-random number generator.
      seed :&#x3D; time.Now().UTC().UnixNano()
      t.Logf(&quot;Random seed: %d&quot;, seed)
      rng :&#x3D; rand.New(rand.NewSource(seed))

      for i :&#x3D; 0; i &lt; 1000; i++ &#123;
          p :&#x3D; randomPalindrome(rng)
          if !IsPalindrome(p) &#123;
              t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)
          &#125;
      &#125;
  &#125;
  &#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.
  &#x2F;&#x2F; Letter case is ignored, as are non-letters.
  func IsPalindrome(s string) bool &#123;
      var letters []rune
      for _, r :&#x3D; range s &#123;
          if unicode.IsLetter(r) &#123;
              letters &#x3D; append(letters, unicode.ToLower(r))
          &#125;
      &#125;
      for i :&#x3D; range letters &#123;
          if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;
              return false
          &#125;
      &#125;
      return true
  &#125;
</code></pre>
</li>
<li><p>测试一个命令(测试内部未导出函数)</p>
<p>要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。要注意的是在测试代码中并没有调用<code>log.Fatal</code>或<code>os.Exit</code>，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理,如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理.导出内部函数,</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; src&#x2F;bytes&#x2F;export_test.go
  package bytes
  &#x2F;&#x2F; Export func for testing
  var IndexBytePortable &#x3D; indexBytePortable &#x2F;&#x2F; 赋值给包级可导出变量</code></pre>

<p>然后通过外部包进行测试</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
&#x2F;&#x2F; src&#x2F;bytes&#x2F;bytes_test.go
  package bytes_test

  func TestIndexByte(t *testing.T) &#123;
      for _, tt :&#x3D; range indexTests &#123;
          ... 代码片段
          posp :&#x3D; IndexBytePortable(a, b) &#x2F;&#x2F; 导出的内部方法在这里被使用
          if posp !&#x3D; tt.i &#123;
              t.Errorf(&#96;indexBytePortable(%q, &#39;%c&#39;) &#x3D; %v&#96;, tt.a, b, posp)
          &#125;
      &#125;
  &#125;
</code></pre>
<p>还有种方式就是不导出，直接在包名下写测试函数，然后进行测试源代码</p>
</li>
<li><p>白盒测试</p>
<p>TBC,代码的内部实现对于测试人员来说是可见的，言外之意就是能看到内部实现,测试内部实现，这个实现可能是未导出的</p>
</li>
<li><p>外部测试包</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package pprint_test
  &#x2F;&#x2F;这时候就可以在
  import (
      &quot;gott&#x2F;hi&quot;
      &#x2F;&#x2F; 导入 要进行测试的 pprint 包本身
      &quot;gott&#x2F;pprint&quot;
      &quot;testing&quot;
  )

  func TestPPrint(t *testing.T) &#123;
      pprint.PPrint()
      hi.Say()
      t.Log(&quot;expect call PPrint&quot;)
  &#125;
  </code></pre>
<p>使用 Go 官方的代码风格：pprint_test.go 文件，因为pprint_test在 pprint 目录下，通过在 import 时，使用<code>.</code>选项，可以直接调用PPrint()方法</p>
</li>
<li><p>编写有效的测试</p>
<ol>
<li>一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息</li>
<li>一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律</li>
<li>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试</li>
</ol>
</li>
<li><p>避免脆弱的测试<br>TBC</p>
</li>
</ul>
<h2 id="11-2-测试覆盖率"><a href="#11-2-测试覆盖率" class="headerlink" title="11.2 测试覆盖率"></a>11.2 测试覆盖率</h2><p>对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化(应该是有)</p>
<ol>
<li>go test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;eval</li>
<li>go test -run&#x3D;Coverage -covermode&#x3D;count gopl.io&#x2F;ch7&#x2F;eval</li>
</ol>
<h2 id="11-3-基准测试"><a href="#11-3-基准测试" class="headerlink" title="11.3 基准测试"></a>11.3 基准测试</h2><ol>
<li><code>-bench</code>也是正则匹配,BenchmarkIsPalindrome-8,8表示的是GOMAXPROCS的值,<code>-benchmem</code>命令行标志参数将在报告中包含内存的分配数据统计</li>
<li>比较型的基准测试就是普通程序代码,它们通常是单参数的函数，由几个不同数量级的基准测试函数调用,通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。所有的测试cases都要保留，随着项目的发展，都需要做回归测试</li>
</ol>
<h2 id="11-4-刨析"><a href="#11-4-刨析" class="headerlink" title="11.4 刨析"></a>11.4 刨析</h2><p>TBC</p>
<h2 id="11-5-示例函数"><a href="#11-5-示例函数" class="headerlink" title="11.5 示例函数"></a>11.5 示例函数</h2><p>示例函数有三个用处。</p>
<ol>
<li>最主要的一个是作为文档，根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。</li>
<li>在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的&#x2F;&#x2F; Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配</li>
<li>提供一个真实的演练场，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数</li>
</ol>
<h1 id="12-appendIndex"><a href="#12-appendIndex" class="headerlink" title="12. appendIndex"></a>12. appendIndex</h1><ol>
<li>线程内再重启一个线程，然后就可以通过加锁，进行隔离开，但此时任然是两个线程的间的交替</li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源,欢迎对文章中的引用来源进行考证,欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论,也可以邮件至zxc741208584@gmail.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'ca29b9a1203b5920918d',
            clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
            repo: 'SimonTeo58.github.io',
            owner: 'SimonTeo58',
            admin: ['SimonTeo58'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    i hear i forget, i see i remember , i do i understand
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
