<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MIT6.824之lab2 | Fish Tank</title>
  <meta name="keywords" content="">
  <meta name="description" content="MIT6.824之lab2 | Fish Tank">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="1. 数据库额启动与关闭oracle server分为两部分(database: 这部分是指文件系统上的数据，instance则是指后台运行的线程和部分共享内存)。并且数据启动分为三部分：1. nomount  2. mount  3. open 状态  启动到nomount状态">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出_Oracle_DBA_入门_进阶与诊断案例">
<meta property="og:url" content="https://simonteo58.github.io/2022/08/31/oracle/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA_Oracle_DBA_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E8%AF%8A%E6%96%AD%E6%A1%88%E4%BE%8B/index.html">
<meta property="og:site_name" content="Fish Tank">
<meta property="og:description" content="1. 数据库额启动与关闭oracle server分为两部分(database: 这部分是指文件系统上的数据，instance则是指后台运行的线程和部分共享内存)。并且数据启动分为三部分：1. nomount  2. mount  3. open 状态  启动到nomount状态">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-08-31T09:35:04.687Z">
<meta property="article:modified_time" content="2022-08-31T09:44:50.597Z">
<meta property="article:author" content="kirkzhang">
<meta property="article:tag" content="Oracle">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>kirkzhang</span>
</div>

<div class="icon">
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(39)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="CPP">
                        
                        CPP
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="非技术类">
                        
                        非技术类
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="分布式">
                        <i class="fold iconfont icon-right"></i>
                        
                        分布式
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="分布式<--->MIT6.824">
                                        
                                        MIT6.824
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据结构">
                        
                        数据结构
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="archive">
                        <i class="fold iconfont icon-right"></i>
                        
                        archive
                        <small>(4)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="archive<--->golang">
                                        
                                        golang
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="CICD">
                        
                        CICD
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="golang">
                        
                        golang
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="leetcode">
                        <i class="fold iconfont icon-right"></i>
                        
                        leetcode
                        <small>(17)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="leetcode<--->leetcode题解">
                                        
                                        leetcode题解
                                        
                                            <small>(17
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="linux">
                        
                        linux
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="Oracle">
                        
                        Oracle
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="TED">
                        
                        TED
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="WEB API">
                        
                        WEB API
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  "
               target="_blank"
                    
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="39">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="/null">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>非技术类</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ansible</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>golang</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Oracle</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All Oracle "
           href="/2022/08/31/oracle/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA_Oracle_DBA_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E8%AF%8A%E6%96%AD%E6%A1%88%E4%BE%8B/"
           data-tag="Oracle"
           data-author="" >
            <span class="post-title" title="深入浅出_Oracle_DBA_入门_进阶与诊断案例">深入浅出_Oracle_DBA_入门_进阶与诊断案例</span>
            <span class="post-date" title="2022-08-31 17:35:04">2022/08/31</span>
        </a>
        
        <a  class="All archive "
           href="/2022/08/27/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%E5%BD%92%E6%A1%A3/Api%E6%95%B0%E6%8D%AE%E8%87%AA%E5%8A%A8%E5%85%A5%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="API数据自动入库">API数据自动入库</span>
            <span class="post-date" title="2022-08-27 13:35:51">2022/08/27</span>
        </a>
        
        <a  class="All archive golang "
           href="/2022/08/26/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%E5%BD%92%E6%A1%A3/%E5%86%85%E5%AD%98%E9%AB%98%E6%95%88golang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="内存高效golang">内存高效golang</span>
            <span class="post-date" title="2022-08-26 21:18:06">2022/08/26</span>
        </a>
        
        <a  class="All archive "
           href="/2022/08/26/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%E5%BD%92%E6%A1%A3/remote_github/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="更新remote位置">更新remote位置</span>
            <span class="post-date" title="2022-08-26 21:14:30">2022/08/26</span>
        </a>
        
        <a  class="All 分布式 MIT6.824 "
           href="/2022/08/12/MIT6.824/lab2_blog/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MIT6.824之lab2">MIT6.824之lab2</span>
            <span class="post-date" title="2022-08-12 21:57:38">2022/08/12</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/08/04/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E5%A4%9A%E5%B7%B4%E8%83%BA%E6%88%92%E6%96%AD/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="多巴胺戒断">多巴胺戒断</span>
            <span class="post-date" title="2022-08-04 23:08:38">2022/08/04</span>
        </a>
        
        <a  class="All 分布式 "
           href="/2022/07/26/SAF_mechanism/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SAF mechanism replication">SAF mechanism replication</span>
            <span class="post-date" title="2022-07-26 17:00:17">2022/07/26</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/07/14/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="禅与摩托车维修艺术">禅与摩托车维修艺术</span>
            <span class="post-date" title="2022-07-14 08:37:05">2022/07/14</span>
        </a>
        
        <a  class="All 数据结构 "
           href="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构讲义">数据结构讲义</span>
            <span class="post-date" title="2022-07-12 23:27:09">2022/07/12</span>
        </a>
        
        <a  class="All archive "
           href="/2022/06/24/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%E5%BD%92%E6%A1%A3/archive/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="手册阅读归档">手册阅读归档</span>
            <span class="post-date" title="2022-06-24 06:54:11">2022/06/24</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="14.最长公共前缀">14.最长公共前缀</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="20.有效的括号">20.有效的括号</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="13.罗马数字转整数">13.罗马数字转整数</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="21.合并两个有序链表">21.合并两个有序链表</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="27.移除元素">27.移除元素</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="35.搜索插入位置">35.搜索插入位置</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/28.%E5%AE%9E%E7%8E%B0-str-str/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="28.实现 strStr()">28.实现 strStr()</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="53.最大子数组和">53.最大子数组和</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/66.%E5%8A%A0%E4%B8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="66.加一">66.加一</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/67.%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="67.二进制的求和">67.二进制的求和</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/58.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="58.最后一个单词的长度">58.最后一个单词的长度</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/69.x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="69.x-的平方根">69.x-的平方根</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/83.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="83.删除排序链表中的重复元素">83.删除排序链表中的重复元素</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="70.爬楼梯">70.爬楼梯</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="88.合并两个有序数组">88.合并两个有序数组</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="94.二叉树的中序排序">94.二叉树的中序排序</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/9.%E5%9B%9E%E6%96%87%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="9.回文数">9.回文数</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All TED "
           href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%B8%93%E6%B3%A8%E5%8A%9B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何提高专注力-How to Get Your Brain to Focus-TED">如何提高专注力-How to Get Your Brain to Focus-TED</span>
            <span class="post-date" title="2022-06-22 23:10:43">2022/06/22</span>
        </a>
        
        <a  class="All 算法 "
           href="/2022/06/22/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="算法导论">算法导论</span>
            <span class="post-date" title="2022-06-22 22:07:23">2022/06/22</span>
        </a>
        
        <a  class="All TED "
           href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何阅读-TED">如何阅读-TED</span>
            <span class="post-date" title="2022-06-22 22:05:35">2022/06/22</span>
        </a>
        
        <a  class="All WEB API "
           href="/2022/06/22/API_design%E5%8E%9F%E5%88%99/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="API Design Patterns">API Design Patterns</span>
            <span class="post-date" title="2022-06-22 21:55:02">2022/06/22</span>
        </a>
        
        <a  class="All linux "
           href="/2022/06/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%88%87shell%E8%85%B3%E6%9C%AC%E7%B7%A8%E7%A8%8B%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux命令行与shell腳本編程大全">Linux命令行与shell腳本編程大全</span>
            <span class="post-date" title="2022-06-22 21:53:01">2022/06/22</span>
        </a>
        
        <a  class="All golang "
           href="/2022/06/22/go%E5%9C%A3%E7%BB%8F/"
           data-tag="golang"
           data-author="" >
            <span class="post-title" title="go语言圣经">go语言圣经</span>
            <span class="post-date" title="2022-06-22 21:16:20">2022/06/22</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/06/22/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%BB%E7%A0%94%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="如何在读研的道路上快速失败">如何在读研的道路上快速失败</span>
            <span class="post-date" title="2022-06-22 21:14:38">2022/06/22</span>
        </a>
        
        <a  class="All golang "
           href="/2022/06/22/golang_standard_library/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="golang standard library">golang standard library</span>
            <span class="post-date" title="2022-06-22 21:04:15">2022/06/22</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/06/22/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E4%BB%8E0%E5%88%B01_%E5%BC%80%E5%90%AF%E5%95%86%E4%B8%9A%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%98%E5%AF%86/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="从0到1:开启商业与未来的秘密">从0到1:开启商业与未来的秘密</span>
            <span class="post-date" title="2022-06-22 20:51:26">2022/06/22</span>
        </a>
        
        <a  class="All CICD "
           href="/2022/06/22/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="docker从入门到实践">docker从入门到实践</span>
            <span class="post-date" title="2022-06-22 20:47:28">2022/06/22</span>
        </a>
        
        <a  class="All CICD "
           href="/2022/06/22/%E5%A5%94%E8%B7%91%E5%90%A7ansible/"
           data-tag="ansible"
           data-author="" >
            <span class="post-title" title="奔跑吧ansible">奔跑吧ansible</span>
            <span class="post-date" title="2022-06-22 20:45:28">2022/06/22</span>
        </a>
        
        <a  class="All CPP "
           href="/2022/06/22/C++_Primer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++ Primer Plus">C++ Primer Plus</span>
            <span class="post-date" title="2022-06-22 01:01:03">2022/06/22</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-MIT6.824/lab2_blog" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">MIT6.824之lab2</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="分布式">分布式</a> > 
            
            <a  data-rel="分布式&lt;---&gt;MIT6.824">MIT6.824</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-09-05 22:31:52'>2022-08-12 21:57</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">raft共识算法的认识与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%85%E8%AF%BB%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3"><span class="toc-text">阅读相关文档</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6"><span class="toc-text">可理解的一致性算法研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">2. 复制状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Paxos%E6%80%8E%E4%B9%88%E4%BA%86%EF%BC%9F"><span class="toc-text">3 Paxos怎么了？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7"><span class="toc-text">4. 设计的可理解性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-text">5. raft一致性算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-raft%E5%9F%BA%E7%A1%80"><span class="toc-text">5.1 raft基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Leader-election"><span class="toc-text">5.2  Leader election</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Log-replication"><span class="toc-text">5.3 Log replication</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">5.4 安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E9%80%89%E4%B8%BE%E9%99%90%E5%88%B6"><span class="toc-text">5.4.1 选举限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%89%8D%E4%BB%BB%E6%9C%9F%E5%86%85%E7%9A%84%E6%97%A5%E5%BF%97%E6%9D%A1%E7%9B%AE"><span class="toc-text">5.4.2 提交之前任期内的日志条目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0raft"><span class="toc-text">实现raft</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">重要的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debugging-Raft"><span class="toc-text">Debugging Raft</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Applications-on-top-of-Raft"><span class="toc-text">Applications on top of Raft</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AppendIndex"><span class="toc-text">AppendIndex</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="raft共识算法的认识与实现"><a href="#raft共识算法的认识与实现" class="headerlink" title="raft共识算法的认识与实现"></a>raft共识算法的认识与实现</h1><h2 id="阅读相关文档"><a href="#阅读相关文档" class="headerlink" title="阅读相关文档"></a>阅读相关文档</h2><ul>
<li><p>阅读raft论文</p>
<!-- <details> -->
<summary>raft论文总结</summary>
<text>

<h1 id="可理解的一致性算法研究"><a href="#可理解的一致性算法研究" class="headerlink" title="可理解的一致性算法研究"></a>可理解的一致性算法研究</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>raft比paxos更容易理解,在构建大型系统的时候方便实现</li>
</ul>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><ol>
<li>什么叫一致性算法，一致性算法就是协调多台机器有序工作，允许成员失败</li>
<li>天下苦paxos久矣，需要个更简单理解和实现的一致性算法，方便程序员理解什么是一致性算法</li>
<li>raft将问题分解，减少raft不确定性，在实际的教学当中，raft要比paxos容易理解</li>
<li>raft与Oki，VSR很像，但有如下新特性<ul>
<li>强leader ： 日志只从领导流向follower</li>
<li>leader选举 ： raft使用随机定时器来选举领导人。</li>
<li>成员变更 ： raft使用了一种新的<code>联合共识</code>的方法，多数两种不同的配置在转换过程中重叠在一起</li>
</ul>
</li>
<li>使劲吹raft多么多么牛逼，算法性能与其他一致性算法差不多，本文的其余部分介绍了复制的状态机问题（第2节），讨论了Paxos的优点和缺点（第3节），描述了我们对可理解性的一般方法（第4节），提出了Raft共识算法（第5-8节），评估了Paxos，Raft共识算法（第5-8节），评估了Raft（第9节），并讨论了相关工作（第10节）。</li>
</ol>
<h2 id="2-复制状态机"><a href="#2-复制状态机" class="headerlink" title="2. 复制状态机"></a>2. 复制状态机</h2><ol>
<li><p>共识通常出现在状态机背景下，冗余状态机通常被用来解决分布式系统中的容错问题，例如，诸如GFS [8], HDFS [38],和RAM云[33]通常使用一个状态机管理leader选举，存储相关重要的配置信息复制状态机的例子包括Chubby[2] 和 ZooKeeper [11]</p>
<p> <img src="/./../../picture/mit6.824/raft_figure_1.png" alt="raft_figure_1"></p>
</li>
<li><p>因为两台状态机按顺序执行相同的<code>日志</code>x&#x3D;1.y&#x3D;3等等,那么这两个状态机计算的状态和输出的结果也是一样的，所以共识算法要保证日志的一致性是非常重要的工作。即使一些状态机因为机械故障导致宕机(少于raft规定的数量)，但是这些服务器看起来还是像一个整体一样对外提供服务。</p>
<ul>
<li>它们确保在所有非拜占庭条件下的安全性（永远不会返回错误的结果），包括网络延迟、分区、以及数据包丢失、重复和重新排序</li>
<li>只要有任何一台服务器在运行，它们就能完全发挥可用作用。大部分的服务器都在运行，并能与其他服务器和客户进行通信。彼此之间以及与客户端之间进行通信。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器的故障,假设服务器的故障是通过停止；它们后来可能从稳定的存储中恢复状态并重新加入集群。</li>
<li>它们并不依赖时间来确保日志的一致性：时钟故障和极端的消息延迟在最坏的情况下会导致可用性问题。延迟，在最坏的情况下，会导致可用性问题。</li>
<li>在通常情况下，只要集群中的大多数follower响应了命令，命令就以完成。一旦集群中的大多数follower对单轮RPC作出反应，一个命令就已经完成。少数缓慢的服务器不影响整个系统的性能。</li>
</ul>
</li>
</ol>
<p>  总结 : 第二节主要是引入状态机的太粘，并给出raft与状态机交互的大致流程</p>
<h2 id="3-Paxos怎么了？"><a href="#3-Paxos怎么了？" class="headerlink" title="3 Paxos怎么了？"></a>3 Paxos怎么了？</h2><ol>
<li><p>Leslie Lamport创造了paxos共识算法，paxos被证明是安全的(能够达到一致)，有效的。但是paxos有两个明显的缺点(ps:什么是多paxos,single-decree子集)</p>
<ul>
<li>paxos非常难以理解，专业人士也很难理解全面，Paxos的不透明性来自于它选择了(单法令)子集作为其基础</li>
<li>构建实际系统时候也很难去实现，并验证，，Paxos使用的是对称的对等方法为核心（尽管它最终建议采用一种弱的领导形式作为性能优化）。这在简化问题上是有意义的.但很少有实际的系统使用这种方法</li>
</ul>
</li>
<li><p>构建一个paxos为基础的分布式系统很难，理解paxos算法也很难(ps:下面引用来自于Chubby系统的总结)。所以作者认为paxos没有为构建一个分布式系统提供一个很好的基础，所以作者提出了新的一致性算法 – 容易理解，对构建大型分布式系统也有帮助。在设计raft算法的时候，作者使用问题分解方法，将问题分解为，选举，日志复制，安全和成员变更等主要子问题。</p>
<blockquote>
<p>Paxos算法的描述与现实世界的需求之间存在着巨大的差距。最终的系统将基于一个未经证实的协议[4]。</p>
</blockquote>
</li>
<li><p>第二个简化的地方是简化了状态空间，使系统连贯，作者努力消除不确定性，日志不允许有洞，并且Raft限制了日志可能变得彼此不一致的方式，但在某些情况下，不确定性实际上提高了可理解性。特别是，随机化方法引入了不确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (“选择什么,这并不重要”)。我们使用随机化来简化Raft领袖选举算法</p>
</li>
</ol>
<p>  总结 : 第三节只是阐述了paxos的<code>问题</code>,比如难理解，很难实现在构建大型系统的。</p>
<h2 id="4-设计的可理解性"><a href="#4-设计的可理解性" class="headerlink" title="4. 设计的可理解性"></a>4. 设计的可理解性</h2><ol>
<li>在设计raft之初就设置了如下目标<ul>
<li>提供正确的理论基础，方便理解</li>
<li>减少开发时间，并易于扩展</li>
<li>在斟酌备选方案时，主要是从可理解性，会不会raft(状态空间，系统)变得复杂，但是这种分析是很主观的(想想作者与我们的硬实力差距)，所以作者选择了两种研究方式。<ul>
<li>问题分解，将共识分解为独立的子问题，分别为选举，日志复制，安全和成员变成。</li>
<li>减少状态空间(只有leader,candidate,follower,以及优化提到的prevote&#x2F;vote&#x2F;appendentry),不允许日志有漏洞(index1和3之间是空的日志)，raft通过冲突检测来矫正不一致情况。随机化的方法引入了非确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (“选择什么；这并不重要”)。我们使用随机化 来简化Raft领袖选举算法</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="5-raft一致性算法"><a href="#5-raft一致性算法" class="headerlink" title="5. raft一致性算法"></a>5. raft一致性算法</h2><ol>
<li>leader接受来自客户端的日志条目，将其复制到其他服务器上，并告诉服务器何时可以将日志条目应用到他们的状态机上。有一个领导者可以简化对复制日志的管理。例如只允许数据从领导者流向其他服务器。一个领导者可能失败或与其他服务器断开连接，在这种情况下 选举一个新的领导者</li>
</ol>
<p>  <img src="/./../../picture/mit6.824/raft_figure_2.png" alt="raft_figure_2"><br>  考虑到领导者的方法，Raft将共识问题分解为三个相对独立的子问题，这将在后面的小节中讨论。</p>
<ul>
<li>leader选举 : 现任领导人失败,必须选择新的领导人</li>
<li>Log replication : 领导者必须接受日志条目从client,并在整个集群中复制它们。迫使其他日志与自己的日志一致（第5.3节）。</li>
<li>Safety : Raft的关键安全属性是图中的状态机安全属性。图3中的状态机安全属性：如果任何服务器 在其状态机上应用了一个特定的日志条目。 那么其他服务器就不能对相同的日志索引应用不同的命令 对相同的日志索引应用不同的命令。第5.4节描述了如何Raft如何确保这一特性；该解决方案涉及到一个 第5.2节中描述的选举机制的额外限制。</li>
</ul>
<p>  <img src="/./../../picture/mit6.824/raft_figure_3.png" alt="raft_figure_3"></p>
<ul>
<li>Election Safety: 一届任期内最多可以选出一位领导人</li>
<li>Leader Append-Only : 领导者从不覆盖或删除其日志中的的条目；它只添加新的条目</li>
<li>Log Matching : 如果两个日志包含一个具有相同的索引和术语，那么这两份日志的所有条目都是相同的。直到给定的索引为止</li>
<li>Leader Completeness : 如果在一个给定的term中提交了一个日志条目，那么该日志将出现在所有更高编号的术语的领导人的日志中。</li>
<li>State Machine Safety : 如果一个服务器在它的状态机上应用了一个日志条目 在它的状态机中应用了一个给定的索引，那么其他服务器将永远不会在同一索引应用不同的日志条目.<br>  Raft保证这些属性中的每一个都是真的,在任何时候都是真实的。节号表示每个属性的讨论位置。</li>
</ul>
<p>  <img src="/./../../picture/mit6.824/raft_figure_4_5.png" alt="raft_figure_3"></p>
<p>  总结</p>
<ol>
<li>所有节点都需要持久化的参数<ul>
<li><code>currentTerm</code>持久化参数，第一次初始化为0然后单调递增</li>
<li><code>voteFor</code>当前term记录投票的candidateId</li>
<li><code>commitIndex</code>记录当前节点可以提交的日志index</li>
<li><code>lastApplied</code>记录当前节点可以提交给上层状态机的index</li>
<li><code>nextIndex[]</code>当leader被选出时需要初始化的参数，且是leader最新log+1的位置</li>
<li><code>matchIndex[]</code>初始化为0，表示leader与follower匹配的日志位置</li>
</ul>
</li>
<li>reqeustVote RPC细节<ol>
<li>requestVote的请求参数<ul>
<li><code>term</code>请求的term</li>
<li><code>candidateId</code></li>
<li><code>lastLogIndex</code>candidate最新的log</li>
<li><code>lastLogTerm</code>candidate最新的term</li>
</ul>
</li>
<li>reqeustVote response参数<ul>
<li><code>term</code>投票时候的term</li>
<li><code>voteGranted</code>布尔类型，true说明follower同意投票</li>
</ul>
</li>
<li>重要交互逻辑<ul>
<li>如果rpc的term小于follower的current term，follower拒绝投票</li>
<li>如果voteFor是空或者为candaditeID,并且candaidate的log至少与follower是一样，也可以比Follower多，新</li>
</ul>
</li>
</ol>
</li>
<li>AppendEntry RPC细节<ol>
<li>AppendEntry请求参数<ul>
<li><code>term</code>post RPC时的term</li>
<li><code>leaderID</code></li>
<li><code>preLogIndex</code>leader进行一致性检测日志的index</li>
<li><code>preLogTerm</code>leader进行一致性检测时日志的term</li>
<li><code>entries</code>搬运的日志</li>
<li><code>leaderCommit</code>leader的commitIndex</li>
</ul>
</li>
<li>AppendEntry的response参数<ul>
<li><code>term</code>RPC的当前term</li>
<li><code>success</code>布尔类型返回true说明preLogIndex和preLogTerm是匹配的</li>
</ul>
</li>
<li>AppendEntry RPC的实现<ul>
<li>rpc’s term小于follower’s的term则返回false</li>
<li>如果preLogIndex，preLogTerm不匹配返回false</li>
<li>preLogIndex匹配但是preLogTerm不匹配则删掉后面所有的存在的log</li>
<li>append新log</li>
<li>leaderCommit大于follower的commitIndex时候要把follower的commitIndex设置为min(leaderCommit,len(logs))</li>
</ul>
</li>
</ol>
</li>
<li>提交给状态机的规则<ol>
<li>如果follower节点的commitIndex大于lastApplied 那么就可以将log提交给状态机</li>
<li>如果发现有大的term,那么一定要更新RPC中term参数,RPC term  &gt; currentTerm,然后candidate或者leader转变为follower</li>
<li>Follower收不到心跳就进行选举</li>
<li>Follower负责响应candidate和leader,言外之意就是处理requestVote RPC和AppendEntry RPC</li>
<li>Candadite会增加自己的term,给自己投票，重置选举超时时间，发送requestVote RPC,得到多数投票就变成leader</li>
<li>Candidate收到其他的AppendEntry的RPC就变成follower</li>
<li>Candidate在选举超时时间内没有完成选举就重新再来一轮</li>
<li>Leader在位时会不间断的发送心跳抑制Follower选举</li>
<li>Leader接收来自client的命令，然后走共识层进行</li>
<li>Leader的logIndex大于nextIndex就开始进行发送AppendEntry的RPC,如果匹配成功就更新Leader的matchIndex和nextIndex,如果没成功就增加nextIndex然后重试</li>
<li>如果存在一个整数N&gt;commitIndex,然后大部分matchIndex[i]&gt;&#x3D;N，那么log[N]&#x3D;&#x3D;currentTerm，然后将Leader设置commitIndex&#x3D;N</li>
</ol>
</li>
</ol>
<h2 id="5-1-raft基础"><a href="#5-1-raft基础" class="headerlink" title="5.1 raft基础"></a>5.1 raft基础</h2><ol>
<li>五台服务器是一个典型的最小集群，它最多允许两台服务器宕机，并且每台服务器有三种状态分别是<code>leader</code>,<code>candidate</code>,<code>follower</code>,follower是被动的不发送任何的请求(RPC),只是简单的回应leader和candidate的请求，如果follower接收到来自client的请求，也要路由给leader。Figure 4描述了三种状态的转换关系和条件</li>
<li>raft主要将时间定义为任意长度的term,是连续且单调递增的,在某些情况下,会出现多个candidate同时竞选leader的情况，这时候或会出现<code>瓜分投票</code>的情况，这是整个raft系统就无法继续前进，通过引入随机选举超时解决这个问题，如果一个follower没有在选举超时实践之内接收到leader的heartbeat就会开始选举</li>
<li>不同的服务器可能在不同的时间观察到term之间的转换。而在某些情况下，一个服务器<br>  可能观察不到一次选举，甚至是整个任期(candidate在一个term时间内无法完成选举)，term在Raft中充当逻辑时钟[14]，它们允许服务器检测过时的信息，如过时的leader。每个服务器存储一个当前的currentTerm，该currentTerm随着时间的推移单调地随时间增加。每当服务器进行通信时，就会交换currentTerm。如果一个服务器的currentTerm小于另一个服务器的currentTerm，那么它就会更新自己的currentTerm，那么它就将其currentTerm更新为较大的值。如果一个candidate或leader发现它的currenTerm已经过时，它就会变成follower。如果follower收到一个过时的term的请求，它将拒绝该请求。<br>  <img src="/./../../picture/mit6.824/raft_figure_6.png" alt="feature 6"></li>
</ol>
<h2 id="5-2-Leader-election"><a href="#5-2-Leader-election" class="headerlink" title="5.2  Leader election"></a>5.2  Leader election</h2><ol>
<li><p>Raft使用心跳机制来触发领导者选举。当服务器启动时，它们开始作为跟随者。A 服务器只要收到有效的RPC从leader或者候选人,领导者定期发送 心跳（AppendEntries RPCs，不携带任何日志条目）。到所有追随者，以维持他们的权威。 如果一个 跟随者在一段时间内没有收到通信，称为选举超时。称为选举超时，那么它就认为没有可行的领导者，并开始选举，想成为一个新的领导者。</p>
</li>
<li><p>在开始选举，candidate递增其当前term并过渡到候选状态。然后,它为自己投票 并向集群中的每个服务器发出RequestVote RPCs。candidate继续处于 这个状态，直到发生以下三种情况之一: (a) 它赢得选举. (b) 另一个服务器确立了自己的领导地位，或者 (c) 一段时间内没有赢家。这些结果将在下面的段落中分别讨论</p>
</li>
<li><p>如果一个候选人在选举中获得了来自整个集群中大多数服务器的投票，那么它就赢得了的大多数服务器的投票选举。每台服务器在给定的任期内最多只能为一名候选人投票。以先来后到为原则（注意:第<a href="#54-%E5%AE%89%E5%85%A8%E6%80%A7">5.4安全性</a> 节对投票增加了一个额外的限制）。多数规则确保最多只有一名candidate能在某届选举中获胜（选举）。一旦一个candidate在选举中获胜，他就成为leader。然后它将心跳信息发送给所有的其他服务器，以建立其权威并防止新的选举。</p>
</li>
<li><p>在等待投票的过程中，候选人可能会收到一个来自另一个leader的AppendEntries RPC，该RPC来自另一服务器，声称自己是leader。如果leader的任期(包括在其RPC中)至少是与Candidate的当前任期一样大,那么candidate承认该leader是合法的，并返回到Follower状态。如果RPC中的term小于candidate的term,那么Candidate就拒绝RPC(被拒绝的RPC变成follower)，继续处于候选状态。</p>
</li>
<li><p>第三个可能的结果是，一个candidate既没有赢得选举，也没有失去选举：如果许多Follower同时成为候选人，选票可能被分割，因此没有候选人获得多数。当这种情况发生时，每个candidate都会超时，并通过增加其任期和启动新一轮的RequestVote RPC来开始新的选举。然而，如果没有额外的措施，分裂的投票 可以无限期地重复.(使用随即超时时间来解决follower同时变成candidate,也防止了candidate同时请求投票投票窘境)</p>
</li>
<li><p>Raft使用随机的选举超时来确保分歧票的情况很少出现，而且能迅速解决。为了从一开始就防止分裂投票，从一个固定的时间间隔中随机选择选举超时（例如，150-300ms）。因此在大多数情况下,在分散服务器中，只有一个服务器会超时。它赢得了选举，并在其他服务器超时之前发送了在其他服务器超时前发送心跳。同样的机制被用来处理<code>分裂的投票</code>。每个candidate在选举开始时重新启动其随机的<code>选举超时</code>。并等待该超时过后再开始下一次选举。这减少了在新的选举中出现新的选举再次出现分裂票的可能性。第9.3节显示这种方法可以迅速选出一个领导者</p>
</li>
<li><p>选举是一个例子，说明可理解性如何指导我们对设计方案的选择。最初我们计划使用一个排名系统:每个candidate被分配一个独特的排名，用来在竞争的candidate之间进行选择。如果一个candidate发现了另一个排名更高的candidate，它就会回到follower的状态，这样排名更高的候选人就能更容易地赢得下一次选举。我们发现，这种方法在可用性方面产生了一些微妙的问题(一个排名较低的服务器可能需要超时，并成为一个新的服务器）。如果一个排名较高的服务器失败了，一个排名较低的服务器可能需要超时并再次成为候选人，但如果它过早地这样做，它可能会重置选举领导者的进展)。我们对算法进行了多次调整，但每次调整后都会出现新的corner cases。最终我们得出结论，随机重试的方法更加明显和容易理解。</p>
</li>
</ol>
<h2 id="5-3-Log-replication"><a href="#5-3-Log-replication" class="headerlink" title="5.3 Log replication"></a>5.3 Log replication</h2><ol>
<li><p>一旦一个领导者被选出，它就开始为客户端请求。每个客户请求都包含一个命令，由复制的状态机执行。leader将该命令作为一个新条目附加到它的日志中，然后向其他每个服务器并行地发出AppendEntries RPCs来复制该条目。当该条目已经被安全复制后（如下所述），leader将该条目应用于其状态机并返回，并将执行的结果返回给客户端。如果跟随者崩溃或运行缓慢。或者网络数据包丢失，领导者会无限期地重试AppendEntries RPCs甚至在它已经响应了直到所有跟随者最终存储了所有的日志条目。</p>
</li>
<li><p>日志的组织方式如图figure 6所示。每个日志条目都存储了一条状态机命令，以及领导者收到该条目时的term编号。日志条目中的term被用来检测日志之间的不一致，并确保图figure 3中的一些属性。每个日志条目也有一个整数索引，用来识别它在日志中的位置</p>
</li>
<li><p>leader决定何时将日志条目应用于状态机是安全的；这样的条目被称为<code>commited</code>。Raft保证所提交的logEntry是持久的并且最终会被所有可用的状态机执行。一旦创建日志条目的leader创建该条目的领导者将其复制到大多数的服务器上(例如，图6中的第7条)，包括之前leader创建的logEntry包括由以前的领导者创建的条目。第<a href="#54-%E5%AE%89%E5%85%A8%E6%80%A7">5.4节</a>它还表明，这种<code>commited</code>的定义是安全。领导者跟踪它所知道的最高<code>commited</code>的最高索引，并将该索引包括在未来的 AppendEntries RPCs（包括心跳）中，以便其他服务器最终发现。其他服务器最终会发现。一旦一个跟随者知道 一旦跟随者得知一个日志条目被提交，它就会将该条目应用到其本地状态机（按日志顺序).</p>
</li>
<li><p>我们设计的Raft日志机制在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更具可预测性，而且是确保安全的重要组成部分。Raft维护以下属性，它们共同构成了日志匹配属性在figure 3中.</p>
</li>
</ol>
<ul>
<li>如果不同服务器日志中的两个条目具有相同的索引和term，那么它们存储的是同一个命令。</li>
<li>如果不同服务器日志中的两个条目具有相同的索引和term，那么这些日志在所有前面的条目相同。</li>
</ul>
<ol start="5">
<li><p>第一个属性：一个leader在一个给定的term中最多创建一个具有给定日志索引的logEntry，而logEntry永远不会改变它们在日志中的位置。第二个属性由AppendEntries执行的简单一致性检查来保证。当发送一个AppendEntries RPC时，leader在其日志中包括条目的索引以及紧接在其日志中的条目的索引和term。如果follower在其日志中没有找到具有相同索引和术语的条目它的日志中没有找到具有相同索引和term的条目，那么它就会拒绝这些logEntry。一致性检查充当了一个归纳步骤：日志的初始空状态满足了日志的匹配属性，而一致性检查则保留了只要日志被扩展，一致性检查就会保留日志匹配属性。因此，只要AppendEntries成功返回。领导者知道跟随者的logEntry与它的自己的logEntry相同的,直到新的条目。</p>
</li>
<li><p>在正常运行期间，领导者和跟随者的日志保持一致，因此AppendEntries一致性检查不会失败。然而，leader崩溃会使日志不一致（老leader可能没有完全复制其日志中的所有条目）。这些不一致会在一系列的领导者和追随者崩溃中加剧。figure 7说明了追随者的日志可能与新领导者的日志不同的方式。跟随者可能会缺少领导者的条目，可能会有领导者没有的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个term。</p>
</li>
<li><p>在Raft中，领导者通过强迫跟随者重复自己的日志来处理不一致的问题。跟随者的日志与自己的日志重复。这意味着 跟随者日志中的冲突条目将被领导者日志中的条目覆盖。第5.4节将表明这就是安全的 如果再加上一个限制。</p>
</li>
<li><p>为了使追随者的日志与自己的日志保持一致，领导者必须找到两个日志一致的最新日志条目，删除追随者日志中此后的所有条目，并向追随者发送此后领导者的所有条目。所有这些动作都是为了响应AppendEntries RPCs所进行的一致性检查而发生的。leader为每个follower维护一个nextIndex，它是领导将发送给该跟随者的下一个日志条目的索引。当一个领导者第一次上台时。它将所有的<code>nextIndex</code>值初始化为其日志中最后一条的索引（feature 7中的11）。如果跟随者的日志与领导者的日志不一致，在下一个AppendEntries RPC中，AppendEntries一致性检查将失败。在拒绝之后，领导者会减少<code>nextIndex</code>并重试 AppendEntries RPC。最终，<code>nextIndex</code>将达到 一个领导者和追随者日志匹配的点。当这种情况发生时，AppendEntries就会成功，这就删除了移除跟随者日志中任何冲突的条目，并从领导者日志中添加 从领导者的日志中添加条目（如果有的话）。一旦AppendEntries 成功后，跟随者的日志就与领导者的一致了。并且在余下的时间里保持这种状态。</p>
</li>
<li><p>如果需要，该协议可以被优化以减少被拒绝的AppendEntries RPC的数量。例如，当拒绝一个AppendEntries请求时，跟随者包括冲突条目的term和它为该term存储的第一个索引。有了这些信息，领导者可以递减 <code>nextIndex</code>以绕过该term中的所有冲突条目；每个有冲突条目的term将需要一个AppendEntries RPC而不是每个logEntry的RPC。在实践中，我们怀疑这种优化是否有必要，因为故障发生的频率很低而且不太可能有很多不一致的条目。</p>
</li>
<li><p>有了这种机制，领导者不需要采取任何特别的行动来恢复日志的一致性。它只是开始正常运行，而日志会自动收敛，以应Append-Entries一致性检查的失败。一个领导者从不覆盖或删除自己日志中的条目（figure 3中的 仅领导者append logEntry属性）。</p>
</li>
<li><p>这种日志复制机制表现出了第2节中所描述的理想的共识属性：只要大多数服务器都在运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目可以通过单轮RPCs复制到集群的大部分；而且一个缓慢的跟随者也不会影响性能。</p>
</li>
</ol>
<h2 id="5-4-安全性"><a href="#5-4-安全性" class="headerlink" title="5.4 安全性"></a>5.4 安全性</h2><p>  目前来说已经说明raft是如何选举和复制日志的，但是这并不能保证不同的状态机执行不同的log，还是会因为follower进入不可用状态然后恢复活性并竞选为leader，这时候leader的日志就会不一致</p>
<h3 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h3><p>  VSR算法一开始日志不全的情况下成为leader，然后当某台服务器成为leader之后会额外的同步这些未同步的日志，而raft则会检查candidate和follower的日志，因为如果集群保证半数node提交日志，那么就会有半数服务器是拥有最新的日志的，两份日志，任期号大的比较新，任期号相同，索引大的比较新</p>
<h3 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h3><p>  熟读figure 8 的图，为了消除figure 8的情况，raft不会通过计算副本数量来提交日志，只有当前任期的日志会通过计算副本数量来进行提交日志，而raft使用了一种更加保守办法，为每个logEntry都保留任期号，想提交之前日志，leader必须使用当前任期号，与其他算法相比，raft只需要发送更少的日志条目</p>
</text>

<!-- </details> -->
</li>
<li><p>Students’ Guide to Raft</p>
  <!-- <details> -->
  <summary>Students' Guide to Raf文档</summary>
  
  <text>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">https://thesquareplanet.com/blog/students-guide-to-raft/</a> 原文链接</p>
</blockquote>
<p>  在过去几个月里，我成为了MIT6.824的一名助教.以往这门课程的实验都是基于paxos实现一致性算法,然后今年(2016),我们决定使用raft,raft的设计理念是”理解门槛低”，并且我们也希望这项决定使同学们的生活更简单[在过去的几个月里，我一直是麻省理工学院6.824分布式系统课的教学助理。这门课传统上有一些建立在Paxos共识算法上的实验，但今年，我们决定改用Raft。Raft是 “设计成易于理解的”，我们希望这一改变能使学生的生活更轻松]</p>
<p>  这篇实验指南,对应着”教师教学指南”，印证着我们实验室与raft的journey，也希望对学生更好的理解raft内部运行机制，实现raft分布式协议起到帮助,如果你正在寻找Raft和Paxos的对比，或者raft的教学(pedagogical)分析,请前去阅读《教师教学指南》.文章底部包含一些学生提问的关于raft的共性问题的问题列表。如果你遇到的问题不在那些问题之内，请前去检查Q&amp;A系统，这篇文章非常的长,但是它提出的所有点，都是现实中学生(助教)碰到过的问题，这是一篇值得阅读的文章。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  开始深入研究raft之前,一些前情提要或许是有用的，6.824过去有一些基于用golang实现的Paxos实验，之所以选择go是因为它易于理解和学习的，它非常适合实现高并发，分布式应用(goroutine是特别便利的)，通过这门课程的四门实验课程，学生构建一个容错的，共享key-value存储系统，第一个实验让你构建一个基于log的一致性算法库,第二门实验在一致性算法库智商添加了key-value的存储，第三们实验课是实验构建共享的key-value容错集群,使用共享master节点解决集群成员变更，同时第四们实验,学生不得不实现失败和恢复机制，包括磁盘完整和磁盘不完整的情况这个实现曾作为学生默认的最后实验</p>
<p>  这些年我们决定使用raft重写所有mit6.824的实验，前三个实验跟以前是相同的,但是删除了第四个已经在raft中实现了关于失败与持久化的实验,这篇文章主要讨论了我们第一个实验的经验，一个直接跟raft相关的的实验，虽然我们也会接触到构建raft之上的应用层,(第二门实验)。</p>
<p>  如果想了解raft的简单的运行逻辑，这个<a target="_blank" rel="noopener" href="https://raft.github.io/">web site</a>网站演示的raft协议是最好的文字材料.</p>
<p>  raft是一种被设计为容易理解的一致性算法,在容错,性能方面等价于paxos算法,他们的不同点是raft将问题解耦为相对独立的问题,它也在实际的系统中清晰的解决了很多实际问题.我们也希望跟多的读者实现raft,以及构建更多的基于raft一致性系统</p>
<p>  这个网站的可视化raft协议提供了很好的主要组件的概括,论文提供了更直观的说明为什么需要这些组件,如果你还没有阅读raft extend 论文,请有限阅读那篇论文然后再阅读这份&lt;&lt;raft指南&gt;&gt;,由于我假设你对raft有了个大致的了解(ps:这段要翻译成”你对raft有一定程度的熟悉”).</p>
<p>  正如其他的分布式一致性协议一样,协议细节有很多的”坑”,在稳定的状态下,没有节点失效,raft协议就很好理解,可以很直观的理解,可以从上面的可视化网站了解其运行机制,假设没有节点失效,一个leader会最终被选出来,客户端所有发给raft的请求都会最终发送给follower,但是当网络出现通信延迟,网络分区,节点宕机等等假设发生,但是在特定情况下,我们看到有很多bugs一次次的重复出现,由于直接的错误理解和疏忽,当阅读论文的时候,这不是raft独有的,而是所有提出正确复杂分布式系统都存在的问题</p>
<h2 id="实现raft"><a href="#实现raft" class="headerlink" title="实现raft"></a>实现raft</h2><p>  raft论文的figure2是最好的guide，figure2指定每个RPC的工作的方式，当你读完figure2就可以着手实现raft，但是问题也就接踵而至。实际上，figure2是极其严格的，论文中有些叙述是must而不是should，举个例子，你也会有理由重置election timer, 无论什么时候收到 Request vote and Append entry RPC,这两个RPC说明，其他的server其中一个是leader，另一个是candidate在尝试成为leader，这不允许人为干预或者推理。</p>
<blockquote>
<p>If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate.</p>
</blockquote>
<p>  他们之间是有很大区别的，之前的实现可能有某些特定场景下有严重的活性问题</p>
<h2 id="重要的细节"><a href="#重要的细节" class="headerlink" title="重要的细节"></a>重要的细节</h2><p>  raft会把没有entry的appendEntry的RPC视为hearbeat,很多同学假设AppendEntry RPC是某种特殊的RPC,尤其是很多人是指简单的reset计时器，然后返回success，而不进行任何的冲突检测，接受accept就承认follower承认没有冲突，leader根据返回的response来提交logEntry,另外一个问题就是，follower根据收到冲突的prevLogIndex，就会删掉那个点的log，然后吧entries直接进行复制。</p>
<blockquote>
<p>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</p>
</blockquote>
<p>  这里的if很关键。如果跟随者拥有领导者发送的所有条目，跟随者必须不截断其日志。任何跟随领导者发送的条目的元素都必须被保留。这是因为我们可能从领导者那里收到了一个过时的AppendEntries RPC，而截断日志将意味着 “收回”我们可能已经告诉领导者我们的日志中的条目。</p>
<h2 id="Debugging-Raft"><a href="#Debugging-Raft" class="headerlink" title="Debugging Raft"></a>Debugging Raft</h2><p>  第一版的实现肯定是问题摆出，我们需要慢慢的迭代实现， 问题大致有如下几点，</p>
<ul>
<li><p>活锁</p>
<ol>
<li>当你的系统活锁时，你系统中的每个节点都在做一些事情，但你的节点集体处于这样一种状态，没有任何进展。这种情况在Raft中很容易发生，尤其是当你没有虔诚地遵循图2时。</li>
<li>有一种活锁情况特别经常出现；没有选举领导人，或者一旦选举了领导人，其他节点又开始选举，迫使最近当选的领导人立即退位。<br>  通常情况下是拥有最新log的服务器和过期服务器同时竞争服务器，但是通常是拥有最新log服务器竞选成功。</li>
<li>遇到高term就变成follower</li>
</ol>
</li>
<li><p>不正确的RPC</p>
<ol>
<li>发现不对逻辑的RPC就尽快返回false</li>
<li>发现follower比leader日志少了，follower就返回false，然后将最新index更新给leader的nextIndex</li>
<li>leader即使没有发送entry，也要检查prevLogIndex</li>
<li>AppendEntries的最后一步（#5）中的min是必要的，它需要用最后一个新条目的索引来计算。仅仅让应用lastApplied和commitIndex之间的日志内容的函数在到达日志的末尾时停止，是不够的。这是因为你的日志中可能会有与领导者的日志不同的条目，在领导者发给你的条目之后（这些条目都与你的日志中的条目一致）。因为 #3 决定了你只在有冲突的条目时才截断你的日志，那些条目不会被删除，如果 leaderCommit 超出了领导者发给你的条目，你可能会应用不正确的条目。发送高leader commit index和空的entry的RPC就会导致apply出现问题</li>
<li>要完全按照第5.4节中描述的方式实现 “最新日志”检查。老老实实的实现，不要只只检查长度!</li>
</ol>
</li>
<li><p>没有按照论文的理论实现raft</p>
<ol>
<li>在任何阶段<code>commitIndex&gt;lastApplied</code>你都可以直接<code>apply</code>log到上层状态机,提交日志的时候不持有锁或者设置数据保护区，保证其他程序不apply日志</li>
<li>将<code>commitIndex&gt;lastApplied</code>解耦,每次sentout心跳的时候检查<code>commitIndex</code>你必须要等<code>appendlog</code>动作完成</li>
<li><code>AppendEntries</code>RPC并不是因为log不一致被reject,应该立刻降级为follower,不要更新<code>nextIndex</code>，如果这个时候立刻选举你可能会面对数据竞争的问题</li>
<li><code>commitIndex</code>不能设置为旧的term，你一定要checklog[N].Term &#x3D;&#x3D;currentTerm.这是因为leader不知道follower是否在当前任期提交了日志,Figure 8会详细阐述这个问题</li>
</ol>
 <pre class="language-text" data-language="text"><code class="language-text">One common source of confusion is the difference between nextIndex and matchIndex. In particular, you may observe that matchIndex = nextIndex - 1, and simply not implement matchIndex. This is not safe. While nextIndex and matchIndex are generally updated at the same time to a similar value (specifically, nextIndex = matchIndex + 1), the two serve quite different purposes. nextIndex is a guess as to what prefix the leader shares with a given follower. It is generally quite optimistic (we share everything), and is moved backwards only on negative responses. For example, when a leader has just been elected, nextIndex is set to be index index at the end of the log. In a way, nextIndex is used for performance – you only need to send these things to this peer.matchIndex is used for safety. It is a conservative measurement of what prefix of the log the leader shares with a given follower. matchIndex cannot ever be set to a value that is too high, as this may cause the commitIndex to be moved too far forward. This is why matchIndex is initialized to -1 (i.e., we agree on no prefix), and only updated when a follower positively acknowledges an AppendEntries RPC.</code></pre>

<p> 正常情况下确实是<code>matchIndex = nextIndex - 1</code>,然后就不实现<code>matchIndex</code>是不安全的,<code>nextIndex</code>只是简单的认为leader已经提交了发送了哪些以前的logEntry，比如leader被选举出来只是讲nextIndex设置为log的长度，而<code>matchIndex</code>则是安全的方法，确定leader已经提交了多少的日志，<code>matchIndex</code>不会设置的太高，这会导致<code>commitIndex</code>移动的太快</p>
</li>
<li><p>term混乱（term不稳定)</p>
  <pre class="language-text" data-language="text"><code class="language-text">Term confusion refers to servers getting confused by RPCs that come from old terms. In general, this is not a problem when receiving an RPC, since the rules in Figure 2 say exactly what you should do when you see an old term. However, Figure 2 generally doesn’t discuss what you should do when you get old RPC replies. From experience, we have found that by far the simplest thing to do is to first record the term in the reply (it may be higher than your current term), and then to compare the current term with the term you sent in your original RPC. If the two are different, drop the reply and return. Only if the two terms are the same should you continue processing the reply. There may be further optimizations you can do here with some clever protocol reasoning, but this approach seems to work well. And not doing it leads down a long, winding path of blood, sweat, tears and despair.

A related, but not identical problem is that of assuming that your state has not changed between when you sent the RPC, and when you received the reply. A good example of this is setting matchIndex = nextIndex - 1, or matchIndex = len(log) when you receive a response to an RPC. This is not safe, because both of those values could have been updated since when you sent the RPC. Instead, the correct thing to do is update matchIndex to be prevLogIndex + len(entries[]) from the arguments you sent in the RPC originally.</code></pre>
<p>  因为网络导致的RPC过期问题，term混淆是指服务器被来自旧term的RPC所迷惑。一般来说，在收到RPC时，因为图2中的规则确切地说明了当你看到一个旧term时你应该做什么。然而，图2一般没有讨论当你收到旧的RPC回复时你应该做什么。根据经验，我们发现，到目前为止，最简单的做法是首先记录回复中的术语（它可能比你当前的term高），然后将当前term与你在原始RPC中发送的term进行比较。如果两者不同，就放弃回复并返回。只有当这两个术语相同时，你才应该继续处理回复。也许你可以通过一些巧妙的协议推理在这里做进一步的优化，但这种方法似乎很有效。而不这样做会导致一条漫长而曲折的血汗、泪水和绝望的道路。</p>
</li>
<li><p>优化</p>
  <pre class="language-text" data-language="text"><code class="language-text">An aside on optimizations
The Raft paper includes a couple of optional features of interest. In 6.824, we require the students to implement two of them: log compaction (section 7) and accelerated log backtracking (top left hand side of page 8). The former is necessary to avoid the log growing without bound, and the latter is useful for bringing stale followers up to date quickly.

These features are not a part of “core Raft”, and so do not receive as much attention in the paper as the main consensus protocol. Log compaction is covered fairly thoroughly (in Figure 13), but leaves out some design details that you might miss if you read it too casually:

When snapshotting application state, you need to make sure that the application state corresponds to the state following some known index in the Raft log. This means that the application either needs to communicate to Raft what index the snapshot corresponds to, or that Raft needs to delay applying additional log entries until the snapshot has been completed.
The text does not discuss the recovery protocol for when a server crashes and comes back up now that snapshots are involved. In particular, if Raft state and snapshots are committed separately, a server could crash between persisting a snapshot and persisting the updated Raft state. This is a problem, because step 7 in Figure 13 dictates that the Raft log covered by the snapshot must be discarded.

If, when the server comes back up, it reads the updated snapshot, but the outdated log, it may end up applying some log entries that are already contained within the snapshot. This happens since the commitIndex and lastApplied are not persisted, and so Raft doesn’t know that those log entries have already been applied. The fix for this is to introduce a piece of persistent state to Raft that records what “real” index the first entry in Raft’s persisted log corresponds to. This can then be compared to the loaded snapshot’s lastIncludedIndex to determine what elements at the head of the log to discard.

The accelerated log backtracking optimization is very underspecified, probably because the authors do not see it as being necessary for most deployments. It is not clear from the text exactly how the conflicting index and term sent back from the client should be used by the leader to determine what nextIndex to use. We believe the protocol the authors probably want you to follow is:

If a follower does not have prevLogIndex in its log, it should return with conflictIndex = len(log) and conflictTerm = None.
If a follower does have prevLogIndex in its log, but the term does not match, it should return conflictTerm = log[prevLogIndex].Term, and then search its log for the first index whose entry has term equal to conflictTerm.
Upon receiving a conflict response, the leader should first search its log for conflictTerm. If it finds an entry in its log with that term, it should set nextIndex to be the one beyond the index of the last entry in that term in its log.
If it does not find an entry with that term, it should set nextIndex = conflictIndex.
A half-way solution is to just use conflictIndex (and ignore conflictTerm), which simplifies the implementation, but then the leader will sometimes end up sending more log entries to the follower than is strictly necessary to bring them up to date.</code></pre>

<ul>
<li><p>当快照应用程序状态时，你需要确保应用程序状态与Raft日志中某个已知索引之后的状态相对应，这意味着应用程序要么需要向Raft传达快照所对应的索引，要么Raft需要推迟应用额外的日志条目，直到快照完成。</p>
</li>
<li><p>该文本没有讨论当服务器崩溃并重新启动时的恢复协议，因为现在涉及到快照。特别是，如果Raft状态和快照是分开提交的，服务器可能会在坚持快照和坚持更新的Raft状态之间崩溃。这是一个问题，因为图13中的第7步决定了快照所覆盖的Raft日志必须被丢弃。如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是在Raft中引入一个持久化状态，记录Raft持久化日志中的第一个条目所对应的 “真实 “索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定在日志的头部有哪些元素需要丢弃.</p>
</li>
</ul>
</li>
</ul>
<h2 id="Applications-on-top-of-Raft"><a href="#Applications-on-top-of-Raft" class="headerlink" title="Applications on top of Raft"></a>Applications on top of Raft</h2><ul>
<li><p>Applying client operations</p>
  <pre class="language-text" data-language="text"><code class="language-text">You may be confused about how you would even implement an application in terms of a replicated log. You might start off by having your service, whenever it receives a client request, send that request to the leader, wait for Raft to apply something, do the operation the client asked for, and then return to the client. While this would be fine in a single-client system, it does not work for concurrent clients.

Instead, the service should be constructed as a state machine where client operations transition the machine from one state to another. You should have a loop somewhere that takes one client operation at the time (in the same order on all servers – this is where Raft comes in), and applies each one to the state machine in order. This loop should be the only part of your code that touches the application state (the key/value mapping in 6.824). This means that your client-facing RPC methods should simply submit the client’s operation to Raft, and then wait for that operation to be applied by this “applier loop”. Only when the client’s command comes up should it be executed, and any return values read out. Note that this includes read requests!

This brings up another question: how do you know when a client operation has completed? In the case of no failures, this is simple – you just wait for the thing you put into the log to come back out (i.e., be passed to apply()). When that happens, you return the result to the client. However, what happens if there are failures? For example, you may have been the leader when the client initially contacted you, but someone else has since been elected, and the client request you put in the log has been discarded. Clearly you need to have the client try again, but how do you know when to tell them about the error?

One simple way to solve this problem is to record where in the Raft log the client’s operation appears when you insert it. Once the operation at that index is sent to apply(), you can tell whether or not the client’s operation succeeded based on whether the operation that came up for that index is in fact the one you put there. If it isn’t, a failure has happened and an error can be returned to the client.</code></pre>

<p>  解决这个问题的一个简单方法是，当你插入客户操作时，记录客户操作在Raft日志中出现的位置。一旦该索引的操作被发送到apply()，你可以根据该索引出现的操作是否是你放在那里的操作来判断客户的操作是否成功。如果不是，就说明发生了失败，可以向客户返回一个错误。</p>
</li>
<li><p>Duplicate detection</p>
  <pre class="language-text" data-language="text"><code class="language-text">As soon as you have clients retry operations in the face of errors, you need some kind of duplicate detection scheme – if a client sends an APPEND to your server, doesn’t hear back, and re-sends it to the next server, your apply() function needs to ensure that the APPEND isn’t executed twice. To do so, you need some kind of unique identifier for each client request, so that you can recognize if you have seen, and more importantly, applied, a particular operation in the past. Furthermore, this state needs to be a part of your state machine so that all your Raft servers eliminate the same duplicates.

There are many ways of assigning such identifiers. One simple and fairly efficient one is to give each client a unique identifier, and then have them tag each request with a monotonically increasing sequence number. If a client re-sends a request, it re-uses the same sequence number. Your server keeps track of the latest sequence number it has seen for each client, and simply ignores any operation that it has already seen.</code></pre>
</li>
<li><p>Hairy corner-cases</p>
  <pre class="language-text" data-language="text"><code class="language-text">If your implementation follows the general outline given above, there are at least two subtle issues you are likely to run into that may be hard to identify without some serious debugging. To save you some time, here they are:</code></pre>
<ul>
<li>Re-appearing indices</li>
</ul>
</li>
<li><p>The four-way deadlock</p>
  <pre class="language-text" data-language="text"><code class="language-text">All credit for finding this goes to Steven Allen, another 6.824 TA. He found the following nasty four-way deadlock that you can easily get into when building applications on top of Raft.

Your Raft code, however it is structured, likely has a Start()-like function that allows the application to add new commands to the Raft log. It also likely has a loop that, when commitIndex is updated, calls apply() on the application for every element in the log between lastApplied and commitIndex. These routines probably both take some lock a. In your Raft-based application, you probably call Raft’s Start() function somewhere in your RPC handlers, and you have some code somewhere else that is informed whenever Raft applies a new log entry. Since these two need to communicate (i.e., the RPC method needs to know when the operation it put into the log completes), they both probably take some lock b.

In Go, these four code segments probably look something like this:</code></pre>
  </text>
  <!-- </details> --></li>
</ul>
</li>
</ul>
<h2 id="AppendIndex"><a href="#AppendIndex" class="headerlink" title="AppendIndex"></a>AppendIndex</h2><ul>
<li>2022&#x2F;08&#x2F;21<br>  etcd的raft模块难得不只是一点点，看来不能直接看它和etcd的整合，尝试着理解那个example开始。一个玩具的raftkv.</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源,欢迎对文章中的引用来源进行考证,欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论,也可以邮件至zxc741208584@gmail.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'ca29b9a1203b5920918d',
            clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
            repo: 'SimonTeo58.github.io',
            owner: 'SimonTeo58',
            admin: ['SimonTeo58'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    i hear i forget, i see i remember , i do i understand
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
