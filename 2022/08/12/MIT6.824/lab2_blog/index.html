<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MIT6.824之lab2 | Fish Tank</title>
  <meta name="keywords" content="">
  <meta name="description" content="MIT6.824之lab2 | Fish Tank">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="raft共识算法的认识与实现阅读助教文档 阅读raft论文      raft extend论文        可理解的一致性算法研究摘要  raft是一种通过管理冗余日志的一致性算法，它产生的结果等价于paxos,与paxos具有相同的效率,但结构却与paxos不同,这个结构也使raft更加容易理解相比于paxos，对于构建实际的系统提供了更好的基础。为了使其变得更加容易理解，raft将共识的关">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.824之lab2">
<meta property="og:url" content="https://simonteo58.github.io/2022/08/12/MIT6.824/lab2_blog/index.html">
<meta property="og:site_name" content="Fish Tank">
<meta property="og:description" content="raft共识算法的认识与实现阅读助教文档 阅读raft论文      raft extend论文        可理解的一致性算法研究摘要  raft是一种通过管理冗余日志的一致性算法，它产生的结果等价于paxos,与paxos具有相同的效率,但结构却与paxos不同,这个结构也使raft更加容易理解相比于paxos，对于构建实际的系统提供了更好的基础。为了使其变得更加容易理解，raft将共识的关">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://simonteo58.github.io/picture/mit6.824/raft_figure_1.png">
<meta property="og:image" content="https://simonteo58.github.io/picture/mit6.824/raft_figure_6.png">
<meta property="article:published_time" content="2022-08-12T13:57:38.288Z">
<meta property="article:modified_time" content="2022-08-21T16:20:56.587Z">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://simonteo58.github.io/picture/mit6.824/raft_figure_1.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>kirkzhang</span>
</div>

<div class="icon">
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(35)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="CPP">
                        
                        CPP
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="非技术类">
                        
                        非技术类
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="分布式">
                        <i class="fold iconfont icon-right"></i>
                        
                        分布式
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="分布式<--->MIT6.824">
                                        
                                        MIT6.824
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据结构">
                        
                        数据结构
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="archive">
                        
                        archive
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="CICD">
                        
                        CICD
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="code_learning">
                        
                        code_learning
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="golang">
                        
                        golang
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="leetcode">
                        <i class="fold iconfont icon-right"></i>
                        
                        leetcode
                        <small>(17)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="leetcode<--->leetcode题解">
                                        
                                        leetcode题解
                                        
                                            <small>(17
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="linux">
                        
                        linux
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="TED">
                        
                        TED
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="WEB API">
                        
                        WEB API
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  "
               target="_blank"
                    
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="35">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="/null">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>非技术类</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ansible</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CPP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>golang</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>raft</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All 分布式 MIT6.824 "
           href="/2022/08/12/MIT6.824/lab2_blog/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MIT6.824之lab2">MIT6.824之lab2</span>
            <span class="post-date" title="2022-08-12 21:57:38">2022/08/12</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/08/04/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E5%A4%9A%E5%B7%B4%E8%83%BA%E6%88%92%E6%96%AD/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="多巴胺戒断">多巴胺戒断</span>
            <span class="post-date" title="2022-08-04 23:08:38">2022/08/04</span>
        </a>
        
        <a  class="All 分布式 "
           href="/2022/07/26/SAF_mechanism/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SAF mechanism replication">SAF mechanism replication</span>
            <span class="post-date" title="2022-07-26 17:00:17">2022/07/26</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/07/14/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="禅与摩托车维修艺术">禅与摩托车维修艺术</span>
            <span class="post-date" title="2022-07-14 08:37:05">2022/07/14</span>
        </a>
        
        <a  class="All 数据结构 "
           href="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构讲义">数据结构讲义</span>
            <span class="post-date" title="2022-07-12 23:27:09">2022/07/12</span>
        </a>
        
        <a  class="All archive "
           href="/2022/06/24/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%E5%BD%92%E6%A1%A3/archive/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="手册阅读归档">手册阅读归档</span>
            <span class="post-date" title="2022-06-24 06:54:11">2022/06/24</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="13.罗马数字转整数">13.罗马数字转整数</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="14.最长公共前缀">14.最长公共前缀</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="20.有效的括号">20.有效的括号</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="21.合并两个有序链表">21.合并两个有序链表</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/28.%E5%AE%9E%E7%8E%B0-str-str/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="28.实现 strStr()">28.实现 strStr()</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="27.移除元素">27.移除元素</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="35.搜索插入位置">35.搜索插入位置</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="53.最大子数组和">53.最大子数组和</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/58.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="58.最后一个单词的长度">58.最后一个单词的长度</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/66.%E5%8A%A0%E4%B8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="66.加一">66.加一</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/67.%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="67.二进制的求和">67.二进制的求和</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/69.x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="69.x-的平方根">69.x-的平方根</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="70.爬楼梯">70.爬楼梯</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/83.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="83.删除排序链表中的重复元素">83.删除排序链表中的重复元素</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="88.合并两个有序数组">88.合并两个有序数组</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/9.%E5%9B%9E%E6%96%87%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="9.回文数">9.回文数</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All leetcode leetcode题解 "
           href="/2022/06/23/leetcode/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="94.二叉树的中序排序">94.二叉树的中序排序</span>
            <span class="post-date" title="2022-06-23 00:10:00">2022/06/23</span>
        </a>
        
        <a  class="All TED "
           href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%B8%93%E6%B3%A8%E5%8A%9B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何提高专注力-How to Get Your Brain to Focus-TED">如何提高专注力-How to Get Your Brain to Focus-TED</span>
            <span class="post-date" title="2022-06-22 23:10:43">2022/06/22</span>
        </a>
        
        <a  class="All 算法 "
           href="/2022/06/22/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="算法导论">算法导论</span>
            <span class="post-date" title="2022-06-22 22:07:23">2022/06/22</span>
        </a>
        
        <a  class="All TED "
           href="/2022/06/22/TED/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何阅读-TED">如何阅读-TED</span>
            <span class="post-date" title="2022-06-22 22:05:35">2022/06/22</span>
        </a>
        
        <a  class="All WEB API "
           href="/2022/06/22/API_design%E5%8E%9F%E5%88%99/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="API Design Patterns">API Design Patterns</span>
            <span class="post-date" title="2022-06-22 21:55:02">2022/06/22</span>
        </a>
        
        <a  class="All linux "
           href="/2022/06/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%88%87shell%E8%85%B3%E6%9C%AC%E7%B7%A8%E7%A8%8B%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux命令行與shell腳本編程大全">Linux命令行與shell腳本編程大全</span>
            <span class="post-date" title="2022-06-22 21:53:01">2022/06/22</span>
        </a>
        
        <a  class="All golang "
           href="/2022/06/22/go%E5%9C%A3%E7%BB%8F/"
           data-tag="golang"
           data-author="" >
            <span class="post-title" title="go语言圣经">go语言圣经</span>
            <span class="post-date" title="2022-06-22 21:16:20">2022/06/22</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/06/22/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%BB%E7%A0%94%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="如何在读研的道路上快速失败">如何在读研的道路上快速失败</span>
            <span class="post-date" title="2022-06-22 21:14:38">2022/06/22</span>
        </a>
        
        <a  class="All code_learning "
           href="/2022/06/22/golang_standard_library/"
           data-tag="raft"
           data-author="" >
            <span class="post-title" title="golang standard library">golang standard library</span>
            <span class="post-date" title="2022-06-22 21:04:15">2022/06/22</span>
        </a>
        
        <a  class="All 非技术类 "
           href="/2022/06/22/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E4%BB%8E0%E5%88%B01_%E5%BC%80%E5%90%AF%E5%95%86%E4%B8%9A%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A7%98%E5%AF%86/"
           data-tag="非技术类"
           data-author="" >
            <span class="post-title" title="从0到1:开启商业与未来的秘密">从0到1:开启商业与未来的秘密</span>
            <span class="post-date" title="2022-06-22 20:51:26">2022/06/22</span>
        </a>
        
        <a  class="All CICD "
           href="/2022/06/22/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="docker从入门到实践">docker从入门到实践</span>
            <span class="post-date" title="2022-06-22 20:47:28">2022/06/22</span>
        </a>
        
        <a  class="All CICD "
           href="/2022/06/22/%E5%A5%94%E8%B7%91%E5%90%A7ansible/"
           data-tag="ansible"
           data-author="" >
            <span class="post-title" title="奔跑吧ansible">奔跑吧ansible</span>
            <span class="post-date" title="2022-06-22 20:45:28">2022/06/22</span>
        </a>
        
        <a  class="All CPP "
           href="/2022/06/22/C++_Primer/"
           data-tag="CPP"
           data-author="" >
            <span class="post-title" title="C++ Primer Plus">C++ Primer Plus</span>
            <span class="post-date" title="2022-06-22 01:01:03">2022/06/22</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-MIT6.824/lab2_blog" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">MIT6.824之lab2</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="分布式">分布式</a> > 
            
            <a  data-rel="分布式&lt;---&gt;MIT6.824">MIT6.824</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-08-22 00:20:56'>2022-08-12 21:57</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">raft共识算法的认识与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%85%E8%AF%BB%E5%8A%A9%E6%95%99%E6%96%87%E6%A1%A3"><span class="toc-text">阅读助教文档</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6"><span class="toc-text">可理解的一致性算法研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">2. 复制状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-What%E2%80%99s-wrong-with-Paxos"><span class="toc-text">3 What’s wrong with Paxos?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7"><span class="toc-text">4. 设计的可理解性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-text">5. raft一致性算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-raft%E5%9F%BA%E7%A1%80"><span class="toc-text">5.1 raft基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Leader-election"><span class="toc-text">5.2  Leader election</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Log-replication"><span class="toc-text">5.3 Log replication</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0raft"><span class="toc-text">实现raft</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">重要的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debugging-Raft"><span class="toc-text">Debugging Raft</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Applications-on-top-of-Raft"><span class="toc-text">Applications on top of Raft</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AppendIndex"><span class="toc-text">AppendIndex</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="raft共识算法的认识与实现"><a href="#raft共识算法的认识与实现" class="headerlink" title="raft共识算法的认识与实现"></a>raft共识算法的认识与实现</h1><h2 id="阅读助教文档"><a href="#阅读助教文档" class="headerlink" title="阅读助教文档"></a>阅读助教文档</h2><ul>
<li><p>阅读raft论文</p>
  <details>
  <summary>raft extend论文</summary>
  
  <text>

<h1 id="可理解的一致性算法研究"><a href="#可理解的一致性算法研究" class="headerlink" title="可理解的一致性算法研究"></a>可理解的一致性算法研究</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>  raft是一种通过管理冗余日志的一致性算法，它产生的结果等价于paxos,与paxos具有相同的效率,但结构却与paxos不同,这个结构也使raft更加容易理解相比于paxos，对于构建实际的系统提供了更好的基础。为了使其变得更加容易理解，raft将共识的关键因素问题分离开,诸如,选举,log复制和安全性,它强制执行更强一致性，以减少必须考虑的状态数量。来自一名用户研究证明raft相对于paxos更容易理解,raft的新特性包括成员变更,通过使用重叠大部分节点来保证集群的安全性</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>  一致性算法允许多台机器组合为一个秩序的集群有序工作，并且能在成员失效时继续正常运行，因为这特性，在构建大范围可靠的软件系统扮演重要角色，paxos在过去几年中统治者一致性算法领域：大部分基于paxo的一致性实现或者受它影响，paxos过去常常成为主要的一致性教学工具.</p>
<p>  不幸的是，paxos非常难以理解的，在进行了大量的尝试才使之更容易理解，它的架构需要复杂的变更来满足实际系统，最终，系统工程师和学生在其中苦苦挣扎</p>
<p>  经过苦苦的挣扎，我们找到了一种对于教育和构建大型系统更加友好的一致性算法基础，我们的方法不太寻常，主要目标是易于理解，我们能否为定义出一个比paxos更容易理解的学习的，更容易实践的一致性算法？并且，我想这个算法能够促进开发者，使他们知道仅仅让算法工作不重要，但能发现它为什么工作才重要</p>
<p>  这个工作的结果是一个叫做raft的一致性算法，在设计raft，我们一用特定的技术来改进它的可理解性，包括解耦（选举、日志复制和安全）和减少状态空间，减少了raft不确定性，减少服务器不一致的情况，一项针对两所大学的43名学生的用户研究表明，Raft的使用明显更容易。两所大学的43名学生的用户研究表明，Raft明显比Paxos更容易理解。比Paxos更容易理解：在学习了两种算法之后。这些学生中有33人能够回答有关Raft的问题比Paxos的问题好。</p>
<p>  raft在很多方面斗鱼现存的一致性算法很相似(像vsr,Oki),但是raft有一些新奇的特性</p>
<ul>
<li>强leader : raft使用更强leadership形式相比于其他一致性算法。 比如说。日志条目只从领导者流向其他服务器。这简化了对冗余日志的管理并使Raft更容易理解</li>
<li>leader选举 : raft使用随机定时器来选举领导人。只增加了少量的机制，这在大部分需要心脏跳动的共识算法基础上，同时简单而迅速地解决冲突。</li>
<li>成员关系变更 : Raft的机制用于改变集群中的服务器集使用了一种新的<code>联合共识</code>的方法，其中两个不同配置的多数两种不同的配置在转换过程中重叠在一起。这使得集群在配置变化期间能够继续运行在配置变化期间继续正常运行。</li>
</ul>
<p>  我们认为Raft优于Paxos等其他共识算法，无论是出于教育目的还是作为实施的基础。它比其他算法更简单，更容易理解；它的描述足够完整，可以满足实际系统的需要。它有几个开放源码的实现，并被一些公司使用。它比其他算法更简单易懂；它的安全属性已被正式详细说明和证明；它的效率与其他算法相当。本文的其余部分介绍了复制的状态机问题（第二节），讨论了Paxos的优点和缺点（第三节），描述了我们对可理解性的一般方法（第4节），提出了Raft共识算法（第5-8节），评估了Paxos，Raft共识算法（第5-8节），评估了Raft（第9节），并讨论了相关工作（第10节）。</p>
<h2 id="2-复制状态机"><a href="#2-复制状态机" class="headerlink" title="2. 复制状态机"></a>2. 复制状态机</h2><p>  共识算法通常在复制状态机的背景下出现。复制的状态机[37]。在这种方法中，服务器集群中的状态机,计算相同的副本，即使一些服务器停机，也能继续运行。 复制的状态机被用来解决分布式系统中的各种容错问题。例如，大规模的系统诸如GFS [8], HDFS [38],和RAM云[33]，通常使用一个单独的复制的状态机来管理领导者的选举，并存储必须在领导者崩溃时仍然存在的配置信息。复制状态机的例子包括Chubby[2] 和 ZooKeeper [11]。</p>
<p>  <img src="/./../../picture/mit6.824/raft_figure_1.png" alt="raft_figure_1"></p>
<p>  复制的状态机通常是使用复制的日志来实现的，如图1所示。每台服务器存储一个包含一系列命令的日志，其状态机按顺序执行这些命令。每个日志都包含相同的命令，所以每个状态机处理相同的命令序列。由于状态机是确定的，所以每个状态机都会计算出相同的状态和相同的输出序列</p>
<p>  保持复制日志的一致性是共识算法的工作。共识算法的工作。服务器上的共识模块接收来自客户端的命令并将其添加到其日志中。它与其他服务器上的共识模块进行通信以确保每个日志最终都包含相同的请求，即使一些服务器失败。一旦命令被正确复制，每个服务器的状态机按照日志顺序处理它们，然后将结果返回给客户。的结果会返回给客户。因此，这些服务器看起来形成一个单一的、高度可靠的状态机</p>
<ul>
<li>它们确保在所有非拜占庭条件下的安全性（永远不会返回错误的结果），包括网络延迟、分区、以及数据包丢失、重复和重新排序</li>
<li>只要有任何一台服务器在运行，它们就能完全发挥可用作用。大部分的服务器都在运行，并能与其他服务器和客户进行通信。彼此之间以及与客户端之间进行通信。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器的故障,假设服务器的故障是通过停止；它们后来可能从稳定的存储中恢复状态并重新加入集群。</li>
<li>它们并不依赖时间来确保日志的一致性：时钟故障和极端的消息延迟在最坏的情况下会导致可用性问题。延迟，在最坏的情况下，会导致可用性问题。</li>
<li>在通常情况下，只要集群中的大多数follower响应了命令，命令就以完成。一旦集群中的大多数follower对单轮RPC作出反应，一个命令就已经完成。少数缓慢的服务器不影响整个系统的性能。</li>
</ul>
<h2 id="3-What’s-wrong-with-Paxos"><a href="#3-What’s-wrong-with-Paxos" class="headerlink" title="3 What’s wrong with Paxos?"></a>3 What’s wrong with Paxos?</h2><p>  在过去的十年里，Leslie Lamport的Paxos协议[15]几乎成了共识的代名词。它是课程中最常教授的协议，而且大多数共识的实现都以它为起点。Paxos首先定义了一个能够达成的协议，比如说一个单一的复制的日志条目。我们把这个子集称为单决策的Paxos。然后，Paxos将该协议的多个实例结合起来，以便促进一系列的决定，如一个日志（多Paxos）。Paxos既保证了安全性，又保证了有效性，而且它支持支持集群成员的变化。它的正确性已经被它的正确性已被证明，而且在正常情况下是有效的。</p>
<p>  不幸的是，Paxos有两个显著的缺点。第一个缺点是，Paxos非常难以理解。困难的。完整的解释[15]是出了名的不透明；很少有人能成功地理解它，而且是在付出巨大努力之后。只有在付出巨大努力的情况下。因此，已经有一些人努力用更简单的术语解释Paxos[16, 20, 21]。这些解释集中在single-decree子集上，但是它们仍然具有挑战性。在对NSDI 2012的与会者进行的非正式调查中，我们发现很少有人对Paxos感到满意，即使在经验丰富的研究人员中。我们自己也在为Paxos挣扎；我们无法理解完整的协议，直到读了几篇关于Paxos的文章之后。在阅读了几个简化的解释和设计了我们自己的替代协议之后，我们才理解了完整的协议，这个过程几乎花了一年时间。</p>
<p>  我们假设，Paxos的不透明性来自于它选择了单法令子集作为其基础。单一法令的Paxos是密集而微妙的：它被划分为两个阶段，没有简单直观的解释并且不能被独立理解。正因为如此。因此，很难发展出关于单指令协议工作原因的直觉。multi-Paxos的组成规则大大增加了复杂性和微妙性。我们相信，在多个节点达成共识的整体问题（即，一个日志而不是一个条目）可以用其他更直接、更明显的方式进行分解。</p>
<p>  Paxos的第二个问题是，它没有为建立实际的实现提供一个良好的基础。原因之一是没有广泛认同的多Paxos的算法。Lamport的描述主要是关于single-decree Paxos；他勾勒了multi-Paxos的可能方法，但缺少许多细节。已经有一些尝试来充实和优化Paxos，如[26]、[39]和[13]，但这些尝试相互之间以及与Lamport的草图不同, 系统如Chubby[4]已经实现了类似Paxos的算法，但与大多数情况一样，他们的细节没有被公布。</p>
<p>  此外，Paxos架构对于构建实用系统来说是一个糟糕的架构。构建实用的系统；这也是单法令分解的另一个后果。这也是单树种分解的结果。例如，独立地选择一组日志条目，然后把它们拼凑成一个连续的日志，这没有什么好处；这只是增加了复杂性。这只会增加复杂性。更简单、更有效的做法是设计一个围绕着日志的系统，新的条目以一个受限的顺序依次添加。另一个问题是，Paxos使用的是对称的对等方法的核心（尽管它最终建议采用一种弱的领导形式作为性能优化）。作为一种性能优化）。这在这在一个只有一个决定的简化世界里是有意义的。但很少有实际的系统使用这种方法。如果必须做出一系列的决定，更简单、更快速的做法是首先选举一个领导者，然后让领导者协调这些决定。</p>
<p>  因此，实用的系统与Paxos几乎没有相似之处。每一个从Paxos开始的实现是困难的，然后开发一个明显不同的架构。这既费时又容易出错，而理解Paxos的困难又加剧了这个问题。Paxos的表述对于证明其正确性的定理来说可能是一个很好的表述，但实际的实现与Paxos有很大的不同，以至于证明的结果是Paxos，所以证明的价值不大。以下来自Chubby实现者典型评论。</p>
<blockquote>
<p>在对Paxos算法的描述与现实世界的需求之间存在着巨大的差距。最终的系统将基于一个未经证实的协议[4]。</p>
</blockquote>
<p>  由于这些问题，我们得出结论，Paxos 并没有为系统建设或教育提供一个良好的基础。鉴于共识在大规模软件系统中的重要性，我们决定看看我们能否设计出一种替代性的共识算法具有比Paxos更好的特性。Raft就是这个实验的结果。</p>
<p>  在Raft的设计中，有许多地方我们必须在备选方法中做出选择。在这些情况下，我们根据以下因素对备选方案进行评估可理解性：解释每个备选方案有多难（例如，其状态空间有多复杂，是否有微妙的影响？），读者能完全理解该方法和其影响？</p>
<p>  我们认识到，这种分析有很大程度的主观性；然而，我们使用了两种普遍适用的技术。第一种技术是众所周知的问题分解方法。众所周知的问题分解方法：在可能的情况下，我们将问题分为独立的部分这些问题可以相对独立地被解决、解释和理解。独立的。例如，在Raft中，我们将领导者选举、日志复制、安全和成员变更。</p>
<p>  我们的第二个方法是简化状态空间通过减少需要考虑的状态数量来简化状态空间，使得系统更加连贯，并尽可能消除不确定性。在可能的情况下。具体来说，日志不允许有洞，并且Raft限制了日志可能变得彼此不一致的方式。尽管在大多数情况下，我们试图消除不确定性，但在某些情况下，不确定性实际上提高了可理解性。特别是，随机化的方法引入了不确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (“选择什么；这并不重要”)。我们使用随机化来简化Raft领袖选举算法。</p>
<h2 id="4-设计的可理解性"><a href="#4-设计的可理解性" class="headerlink" title="4. 设计的可理解性"></a>4. 设计的可理解性</h2><p>  在设计raft时我们设置了一些目标，他必须提供为实际系统建设提供一个完整的而使用的基础，以至于可以显著的减少开发工作者的设计工作量。它必须在所有条件下都是安全的并在典型的操作条件下可用；而且必须对普通操作有效。但我们最重要的目标和最困难的挑战是可理解性， 它必须能够让广大听众不费力地理解该算法，此外，必须是容易开发的，以便这样，系统构建者就可以在现实世界的实现不可避免的扩展。在Raft的设计中，有许多地方我们必须在备选方法中做出选择。在这些情况下，我们根据可理解性因素对备选方案进行评估（例如，其状态空间有多复杂，是否有微妙的影响？），以及一个读者完全理解这个方法和它的作用有多容易。读者完全理解该方法及其影响是否容易。我们认识到，这种分析有很大程度的主观性；然而，我们使用了两种普遍适用的技术。第一种技术是众所周知的问题分解方法：只要有可能，我们就把问题分成独立的部分这些问题可以相对独立地被解决、解释和理解。例如，在Raft中，我们将领导者,选举、日志复制、安全和成员变更。</p>
<p>  我们的第二个方法是简化状态空间通过减少需要考虑的状态数量，使系统更加连贯，并尽可能消除非确定性。具体来说，不允许日志有漏洞，而且Raft限制了日志相互之间不一致的方式。尽管在大多数情况下，我们试图消除非确定性，但在某些情况下，非确定性实际上会提高可理解性。特别是，随机化的方法引入了非确定性，但它们倾向于通过处理所有可能的选择来减少状态的空间，以一种类似的方式处理所有可能的选择 (“选择什么；这并不重要”)。我们使用随机化 来简化Raft领袖选举算法。</p>
<h2 id="5-raft一致性算法"><a href="#5-raft一致性算法" class="headerlink" title="5. raft一致性算法"></a>5. raft一致性算法</h2><p>  Raft是一种用于管理第2节所述形式的日志副本的算法。图2简要介绍了该算法图2以简略的形式总结了该算法，供参考，图3列出了该算法的关键属性；这些元素<br>  图中的内容将在本节的其余部分逐一讨论。</p>
<p>  Raft通过首先选举一个杰出的领导者来实现共识，然后让该领导者完全负责管理复制的日志。领导接受来自客户端的日志条目，将其复制到其他服务器上，并告诉服务器何时可以将日志条目应用到他们的状态机上。有一个领导者可以简化对复制日志的管理。例如，领导者可以在不咨询其他服务器的情况下决定在日志中放置新条目的位置，并且数据以一种简单的方式从领导者流向其他服务器。数据从领导者流向其他服务器。一个领导者可能失败或与其他服务器断开连接，在这种情况下 选举一个新的领导者</p>
<p>  考虑到领导者的方法，Raft将共识问题分解为三个相对独立的子问题，这将在后面的小节中讨论。</p>
<ul>
<li><p>leader选举 : 现任领导人失败,必须选择新的领导人</p>
</li>
<li><p>Log replication : 领导者必须接受日志条目从client,并在整个集群中复制它们。迫使其他日志与自己的日志一致（第5.3节）。</p>
</li>
<li><p>Safety : Raft的关键安全属性是图中的状态机安全属性。图3中的状态机安全属性：如果任何服务器 在其状态机上应用了一个特定的日志条目。 那么其他服务器就不能对相同的日志索引应用不同的命令 对相同的日志索引应用不同的命令。第5.4节描述了如何Raft如何确保这一特性；该解决方案涉及到一个 第5.2节中描述的选举机制的额外限制。</p>
<ul>
<li>Election Safety: 一届任期内最多可以选出一位领导人</li>
<li>Leader Append-Only : 领导者从不覆盖或删除其日志中的的条目；它只添加新的条目</li>
<li>Log Matching : 如果两个日志包含一个具有相同的索引和术语，那么这两份日志的所有条目都是相同的。直到给定的索引为止</li>
<li>Leader Completeness : 如果在一个给定的term中提交了一个日志条目，那么该日志将出现在所有更高编号的术语的领导人的日志中。</li>
<li>State Machine Safety : 如果一个服务器在它的状态机上应用了一个日志条目 在它的状态机中应用了一个给定的索引，那么其他服务器将永远不会在同一索引应用不同的日志条目.</li>
</ul>
<p>  图3：Raft保证这些属性中的每一个都是真的,在任何时候都是真实的。节号表示每个属性的讨论位置。</p>
</li>
</ul>
<p>  在介绍了共识算法之后，本节讨论了可用性问题和时间在系统中的作用。系统中的作用。</p>
<h2 id="5-1-raft基础"><a href="#5-1-raft基础" class="headerlink" title="5.1 raft基础"></a>5.1 raft基础</h2><p>  一个Raft集群包含几个服务器；五个是典型集群结构，每个服务器都处于三种状态之一: leader、Candiate或Follower。在任何时候，每台服务器都处于三种状态之一：领导者、追随者或候选者。 在正常运行中，正好有一个领导者，其他所有的服务器都是追随者。跟随者是被动的：他们不发出任何请求 他们自己没有发出任何请求，而只是对领导者和候选人的请求作出回应。和候选者的请求。领导者处理所有客户的请求（如果 如果客户联系追随者，追随者会将其重定向到领导者）。第三种状态，候选人，被用来选举一个新的leader 如第5.2节所述。图4显示了这些状态和它们的转换；下面将讨论这些角色转换。</p>
<p>  Raft将时间划分为任意长度，如图5所示。term是连续的 整数编号。每个任期以选举开始，在选举中，一个或多个候选人试图成为领导人。一个或多个候选人试图成为领袖，如第5.2节所述 5.2节中描述的那样。如果某位候选人在选举中获胜，那么他将在剩余的任期内担任领袖。在剩下的任期内担任领导者。在某些情况下选举将导致投票的分裂。在这种情况下，任期 将在没有领袖的情况下结束；新的任期（重新选举）将很快开始。筏子确保在一个特定的任期内最多有一个领导人，在一个给定的任期内</p>
<p>  不同的服务器可能会在不同的时间观察到不同的任期，而在某些情况下，一个服务器 可能不会观察到一次选举，甚至是整个任期。term在Raft中起着逻辑时钟的作用[14]，它们允许服务器检测过时的信息，如过时的领导。每个服务器都会存储一个当前的术语编号，该编号随着时间的推移 单调地随时间增加。每当服务器进行通信时，就会交换当前的term。如果一个服务器的当前term小于另一个服务器的current_term，那么它就会更新自己的current term。</p>
<p>  如果一个服务器的current term小于另一个服务器的term，那么它就将其当前term更新为较大的值。那么它就将自己的当前term更新为较大的值。如果一个候选人或领导者发现候选者或领导者发现它的term已经过期，它立即恢复到追随者状态。如果一个服务器收到了一个带有过时的term的请求，它将拒绝该请求。raft服务器使用远程过程调用 (RPCs)进行通信，而基本的共识算法只需要两种类型的RPC。RequestVote RPCs是由候选人发起的（第5.2节），而AppendEntries RPC则由领导者发起，用于复制日志条目并提供一种心跳形式（第5.3节）。第7节增加了第三个RPC，用于在服务器之间传输快照。服务器之间传输快照。如果服务器没有及时收到响应，它们会重试RPC，并以并行方式发出RPC，以获得最佳性能。以获得最佳性能。</p>
<h2 id="5-2-Leader-election"><a href="#5-2-Leader-election" class="headerlink" title="5.2  Leader election"></a>5.2  Leader election</h2><p>  Raft使用心跳机制来触发领导者选举。当服务器启动时，它们开始作为跟随者。A 服务器只要收到有效的RPC从leader或者候选人,领导者定期发送 心跳（AppendEntries RPCs，不携带任何日志条目）。到所有追随者，以维持他们的权威。 如果一个 跟随者在一段时间内没有收到通信，称为选举超时。称为选举超时，那么它就认为没有可行的领导者，并开始选举，以选择一个新的领导者。</p>
<p>  在开始选举，追随者递增其当前任期并过渡到候选状态。然后，它为自己投票 并向集群中的每个服务器发出RequestVote RPCs。簇中的其他服务器。候选人继续处于 这个状态，直到发生以下三种情况之一：(a) 它赢得选举(b) 另一个服务器确立了自己的领导地位，或者 (c) 一段时间内没有赢家。这些结果将在下面的段落中分别讨论</p>
<p>  如果一个候选人在选举中获得了来自整个集群中大多数服务器的投票，那么它就赢得了的大多数服务器的投票选举。每台服务器在给定的任期内最多只能为一名候选人投票。以先来后到为原则（注意：第5.4节对投票增加了一个额外的限制）。多数规则确保最多只有一名候选人能在某届选举中获胜（选举）。选举（图3中的选举安全属性）。一旦一个候选人在选举中获胜，他就成为领导者。然后它将心跳信息发送给所有的其他服务器，以建立其权威并防止新的选举。</p>
<p>  在等待投票的过程中，候选人可能会收到一个来自另一个服务器的AppendEntries RPC，该RPC来自另一服务器，要求自己成为leader。如果leader的任期（包括在其RPC中）至少是与Candidate的当前任期一样大，那么candidate承认该领导者是合法的，并返回到Follower状态。如果RPC中的term小于候选人的term,那么Candidate就拒绝RPC，继续处于候选状态。</p>
<p>  第三个可能的结果是，一个候选人既没有赢得选举，也没有失去选举：如果许多追随者同时成为候选人，选票可能被分割，因此没有候选人获得多数。当这种情况发生时，每个候选人都会超时，并通过增加其任期和启动新一轮的RequestVote RPC来开始新的选举。然而，如果没有额外的措施，分裂的投票 可以无限期地重复.</p>
<p>  Raft使用随机的选举超时来确保分歧票的情况很少出现，而且能迅速解决。为了从一开始就防止分裂投票，从一个固定的时间间隔中随机选择选举超时（例如，150-300ms）。因此在大多数情况下,这将分散服务器，只有一个服务器会超时。它赢得了选举，并在其他服务器超时之前发送了在其他服务器超时前发送心跳。同样的同样的机制被用来处理分裂的投票。每个候选人在选举开始时重新启动其随机的选举超时。并等待该超时过后再开始下一次选举。这减少了在新的选举中出现在新的选举中再次出现分裂票的可能性。第9.3节显示这种方法可以迅速选出一个领导者</p>
<p>  <img src="/./../../picture/mit6.824/raft_figure_6.png" alt="feature 6"><br>  选举是一个例子，说明可理解性如何指导我们对设计方案的选择。最初我们计划使用一个排名系统：每个候选人被分配一个独特的排名，用来在竞争的候选人之间进行选择。如果一个候选人发现了另一个排名更高的候选人，它就会回到追随者的状态，这样排名更高的候选人就能更容易地赢得下一次选举。我们发现，这种方法在可用性方面产生了一些微妙的问题（一个排名较低的服务器可能需要超时，并成为一个新的服务器）。如果一个排名较高的服务器失败了，一个排名较低的服务器可能需要超时并再次成为候选人，但如果它过早地这样做，它可能会重置选举领导者的进展）。我们对算法进行了多次调整，但每次调整后都会出现新的角落案例。最终我们得出结论，随机重试的方法更加明显和容易理解。</p>
<h2 id="5-3-Log-replication"><a href="#5-3-Log-replication" class="headerlink" title="5.3 Log replication"></a>5.3 Log replication</h2><p>  一旦一个领导者被选出，它就开始为客户端请求。每个客户请求都包含一个命令，由 由复制的状态机执行。领导者 将该命令作为一个新条目附加到它的日志中，然后向其他每个服务器并行地发出AppendEntries RPCs来复制该条目。服务器来复制该条目。当该条目已经被 安全复制后（如下所述），领导者将该条目应用于其状态机并返回 条目到它的状态机，并将执行的结果返回给客户端。执行的结果返回给客户端。如果跟随者崩溃或运行缓慢。或者网络数据包丢失，领导者会无限期地重试AppendEntries RPCs（甚至在它已经响应了 直到所有跟随者最终存储了所有的日志条目。</p>
<p>  日志的组织方式如图6所示。每个日志条目都存储了一条状态机命令，以及领导者收到该条目时的术语条目被领导者收到时的编号。日志条目中的 日志条目中的术语编号被用来检测日志之间的不一致，并确保图3中的一些属性 图3中的一些属性。每个日志条目也有一个整数索引，用来识别它在日志中的位置</p>
<p>  领导决定何时将日志条目应用于状态机是安全的；这样的条目被称为承诺。Raft保证所提交的条目是持久的 并且最终会被所有可用的 状态机执行。一旦创建日志条目的领导 创建该条目的领导者将其复制到大多数的 服务器上复制（例如，图6中的第7条）。这也会使 领导者的日志中所有之前的条目，包括之前领导者创建的条目 包括由以前的领导者创建的条目。第5.4节讨论了一些 5.4节讨论了在领导变更后应用这一规则的一些微妙之处。它还表明，这种承诺的定义是安全。领导者跟踪它所知道的最高指数 承诺的最高索引，并将该索引包括在未来的 AppendEntries RPCs（包括心跳）中，以便其他服务器最终发现。其他服务器最终会发现。一旦一个跟随者知道 一旦跟随者得知一个日志条目被提交，它就会将该条目应用到其 本地状态机（按日志顺序).</p>
<p>  我们设计的Raft日志机制在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更具可预测性，而且是确保安全的重要组成部分。Raft维护以下属性，它们共同构成了日志匹配属性 在图3中.</p>
<ul>
<li>如果不同日志中的两个条目具有相同的索引 和术语，那么它们存储的是同一个命令。</li>
<li>如果不同日志中的两个条目具有相同的索引 和术语，那么这些日志在所有前面的条目相同。</li>
</ul>
<p>  第一个属性来自于这样一个事实：一个领导者在一个给定的术语中最多创建一个具有给定日志索引的条目 词条，而日志条目永远不会改变它们在 日志中的位置。第二个属性由AppendEntries执行的简单一致性检查来保证。当发送一个AppendEntries RPC时，领导者在其日志中包括条目的索引 以及紧接在其日志中的条目的索引和术语。新的条目。如果跟随者在其日志中没有找到具有相同索引和术语的条目它的日志中没有找到具有相同索引和术语的条目，那么它就会拒绝这些 新条目。一致性检查充当了一个归纳 步骤：日志的初始空状态满足了日志的 匹配属性，而一致性检查则保留了 只要日志被扩展，一致性检查就会保留日志匹配属性。因此，只要AppendEntries成功返回。领导者知道跟随者的日志与它的 自己的日志，直到新的条目。</p>
<p>  在正常运行期间，领导者和跟随者的日志保持一致，因此AppendEntries一致性检查不会失败。然而，领导者崩溃会使日志不一致（老领导者可能没有完全复制其日志中的所有条目）。这些不一致会在一系列的领导者和追随者崩溃中加剧。图7说明了追随者的日志可能与新领导者的日志不同的方式。跟随者可能会缺少领导者的条目，可能会有领导者没有的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个学期。</p>
<p>  在Raft中，领导者通过强迫跟随者重复自己的日志来处理不一致的问题。跟随者的日志与自己的日志重复。这意味着 跟随者日志中的冲突条目将被覆盖 用领导者日志中的条目覆盖。第5.4节将表明 如果再加上一个限制，这就是安全的。</p>
<p>  为了使追随者的日志与自己的日志保持一致，领导者必须找到两个日志一致的最新日志条目，删除追随者日志中此后的所有条目，并向追随者发送此后领导者的所有条目。所有这些动作都是为了响应AppendEntries RPCs所进行的一致性检查而发生的。领导为每个跟随者维护一个nextIndex，它是领导将发送给该跟随者的下一个日志条目的索引。当一个领导者第一次上台时。它将所有的nextIndex值初始化为其日志中最后一条的索引（feature 7中的11）。如果跟随者的日志与领导者的日志不一致，在下一个AppendEntries RPC中，AppendEntries一致性检查将失败。在拒绝之后，领导者会减少NextIndex并重试 AppendEntries RPC。最终，NextIndex将达到 一个领导者和追随者日志匹配的点。当 当这种情况发生时，AppendEntries就会成功，这就删除了 移除跟随者日志中任何冲突的条目，并从领导者日志中添加 从领导者的日志中添加条目（如果有的话）。一旦AppendEntries 成功后，跟随者的日志就与领导者的一致了。并且在余下的时间里保持这种状态。</p>
<p>  如果需要，该协议可以被优化以减少被拒绝的AppendEntries RPC的数量。例如，当拒绝一个AppendEntries请求时，跟随者可以包括冲突条目的term和它为该term存储的第一个索引。有了这些信息，领导者可以递减 nextIndex 以绕过该术语中的所有冲突条目；每个有冲突条目的术语将需要一个 AppendEntries RPC 而不是每个词条一个RPC。而不是每个条目一个RPC。在实践中，我们怀疑这种优化是否有必要，因为故障发生的频率很低而且不太可能有很多不一致的条目</p>
<p>  这种日志复制机制表现出了第2节中所描述的理想的 第2节中描述的共识属性：只要大多数服务器都在运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目 在正常情况下，一个新条目可以通过单轮RPCs复制到集群的大部分；而且一个缓慢的跟随者也不会 影响性能。<br>  </text></p>
  </details>
</li>
<li><p>Students’ Guide to Raft</p>
  <details>
  <summary>Students' Guide to Raf文档</summary>
  
  <text>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">https://thesquareplanet.com/blog/students-guide-to-raft/</a> 原文链接</p>
</blockquote>
<p>  For the past few months, I have been a Teaching Assistant for MIT’s 6.824 Distributed Systems class. The class has traditionally had a number of labs building on the Paxos consensus algorithm, but this year, we decided to make the move to Raft. Raft was “designed to be easy to understand”, and our hope was that the change might make the students’ lives easier.</p>
<p>  This post, and the accompanying <strong>Instructors’ Guide to Raft</strong> post, chronicles our journey with Raft, and will hopefully be useful to implementers of the Raft protocol and students trying to get a better understanding of Raft’s internals. If you are looking for a Paxos vs Raft comparison, or for a more pedagogical analysis of Raft, you should go read the Instructors’ Guide. The bottom of this post contains a list of questions commonly asked by 6.824 students, as well as answers to those questions. If you run into an issue that is not listed in the main content of this post, check out the Q&amp;A. The post is quite long, but all the points it makes are real problems that a lot of 6.824 students (and TAs) ran into. It is a worthwhile read.</p>
<p>  在过去几个月里，我成为了MIT6.824的一名助教.以往这门课程的实验都是基于paxos实现一致性算法,然后今年(2016),我们决定使用raft,raft的设计理念是”理解门槛低”，并且我们也希望这项决定使同学们的生活更简单[在过去的几个月里，我一直是麻省理工学院6.824分布式系统课的教学助理。这门课传统上有一些建立在Paxos共识算法上的实验，但今年，我们决定改用Raft。Raft是 “设计成易于理解的”，我们希望这一改变能使学生的生活更轻松]</p>
<p>  这篇实验指南,对应着”教师教学指南”，印证着我们实验室与raft的journey，也希望对学生更好的理解raft内部运行机制，实现raft分布式协议起到帮助,如果你正在寻找Raft和Paxos的对比，或者raft的教学(pedagogical)分析,请前去阅读《教师教学指南》.文章底部包含一些学生提问的关于raft的共性问题的问题列表。如果你遇到的问题不在那些问题之内，请前去检查Q&amp;A系统，这篇文章非常的长,但是它提出的所有点，都是现实中学生(助教)碰到过的问题，这是一篇值得阅读的文章。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  Before we dive into Raft, some context may be useful. 6.824 used to have a set of Paxos-based labs that were built in Go; Go was chosen both because it is easy to learn for students, and because is pretty well-suited for writing concurrent, distributed applications (goroutines come in particularly handy). Over the course of four labs, students build a fault-tolerant, sharded key-value store. The first lab had them build a consensus-based log library, the second added a key value store on top of that, and the third sharded the key space among multiple fault-tolerant clusters, with a fault-tolerant shard master handling configuration changes. We also had a fourth lab in which the students had to handle the failure and recovery of machines, both with and without their disks intact. This lab was available as a default final project for students.</p>
<p>  This year, we decided to rewrite all these labs using Raft. The first three labs were all the same, but the fourth lab was dropped as persistence and failure recovery is already built into Raft. This article will mainly discuss our experiences with the first lab, as it is the one most directly related to Raft, though I will also touch on building applications on top of Raft (as in the second lab).</p>
<p>  Raft, for those of you who are just getting to know it, is best described by the text on the protocol’s <a target="_blank" rel="noopener" href="https://raft.github.io/">web site</a>:</p>
<blockquote>
<p>Raft is a consensus algorithm that is designed to be easy to understand. It’s equivalent to Paxos in fault-tolerance and performance. The difference is that it’s decomposed into relatively independent subproblems, and it cleanly addresses all major pieces needed for practical systems. We hope Raft will make consensus available to a wider audience, and that this wider audience will be able to develop a variety of higher quality consensus-based systems than are available today.</p>
</blockquote>
<p>  Visualizations like <a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">this one</a> give a good overview of the principal components of the protocol, and the paper gives good intuition for why the various pieces are needed. If you haven’t already read the extended Raft paper, you should go read that before continuing this article, as I will assume a decent familiarity with Raft.</p>
<p>  As with all distributed consensus protocols, the devil is very much in the details. In the steady state where there are no failures, Raft’s behavior is easy to understand, and can be explained in an intuitive manner. For example, it is simple to see from the visualizations that, assuming no failures, a leader will eventually be elected, and eventually all operations sent to the leader will be applied by the followers in the right order. However, when delayed messages, network partitions, and failed servers are introduced, each and every if, but, become crucial. In particular, there are a number of bugs that we see repeated over and over again, simply due to misunderstandings or oversights when reading the paper. This problem is not unique to Raft, and is one that comes up in all complex distributed systems that provide correctness.</p>
<p>  开始深入研究raft之前,一些前情提要或许是有用的，6.824过去有一些基于用golang实现的Paxos实验，之所以选择go是因为它易于理解和学习的，它非常适合实现高并发，分布式应用(goroutine是特别便利的)，通过这门课程的四门实验课程，学生构建一个容错的，共享key-value存储系统，第一个实验让你构建一个基于log的一致性算法库,第二门实验在一致性算法库智商添加了key-value的存储，第三们实验课是实验构建共享的key-value容错集群,使用共享master节点解决集群成员变更，同时第四们实验,学生不得不实现失败和恢复机制，包括磁盘完整和磁盘不完整的情况这个实现曾作为学生默认的最后实验</p>
<p>  这些年我们决定使用raft重写所有mit6.824的实验，前三个实验跟以前是相同的,但是删除了第四个已经在raft中实现了关于失败与持久化的实验,这篇文章主要讨论了我们第一个实验的经验，一个直接跟raft相关的的实验，虽然我们也会接触到构建raft之上的应用层,(第二门实验)。</p>
<p>  如果想了解raft的简单的运行逻辑，这个<a target="_blank" rel="noopener" href="https://raft.github.io/">web site</a>网站演示的raft协议是最好的文字材料.</p>
<p>  raft是一种被设计为容易理解的一致性算法,在容错,性能方面等价于paxos算法,他们的不同点是raft将问题解耦为相对独立的问题,它也在实际的系统中清晰的解决了很多实际问题.我们也希望跟多的读者实现raft,以及构建更多的基于raft一致性系统</p>
<p>  这个网站的可视化raft协议提供了很好的主要组件的概括,论文提供了更直观的说明为什么需要这些组件,如果你还没有阅读raft extend 论文,请有限阅读那篇论文然后再阅读这份&lt;&lt;raft指南&gt;&gt;,由于我假设你对raft有了个大致的了解(ps:这段要翻译成”你对raft有一定程度的熟悉”).</p>
<p>  正如其他的分布式一致性协议一样,协议细节有很多的”坑”,在稳定的状态下,没有节点失效,raft协议就很好理解,可以很直观的理解,可以从上面的可视化网站了解其运行机制,假设没有节点失效,一个leader会最终被选出来,客户端所有发给raft的请求都会最终发送给follower,但是当网络出现通信延迟,网络分区,节点宕机等等假设发生,但是在特定情况下,我们看到有很多bugs一次次的重复出现,由于直接的错误理解和疏忽,当阅读论文的时候,这不是raft独有的,而是所有提出正确复杂分布式系统都存在的问题</p>
<h2 id="实现raft"><a href="#实现raft" class="headerlink" title="实现raft"></a>实现raft</h2><p>  raft论文的figure2是最好的guide，figure2指定每个RPC的工作的方式，当你读完figure2就可以着手实现raft，但是问题也就接踵而至。实际上，figure2是极其严格的，论文中有些叙述是must而不是should，举个例子，Request vote and Append entry RPC,这两个RPC说明，其他的server其中一个是leader，另一个是candidate在尝试成为leader，这不允许人为干预或者推理。</p>
<blockquote>
<p>If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate.</p>
</blockquote>
<p>  这两者的区别变得很重要，在正式的实现当中（工业级实现）在特定环境中会显著的减少leader活性。 to be continue</p>
<h2 id="重要的细节"><a href="#重要的细节" class="headerlink" title="重要的细节"></a>重要的细节</h2><p>  raft会把没有newtry的appendEntry的RPC视为hearbeat,很多同学假设AppendEntry RPC是某种特殊的RPC,尤其是很多人是指简单的reset计时器，然后返回success，而不进行任何的冲突检测，接受accept就承认follower承认没有冲突，leader根据返回的response来提交logEntry,另外一个问题就是，follower根据收到冲突的prevLogIndex，就会删掉那个点的log，然后吧entries直接进行复制。</p>
<blockquote>
<p>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</p>
</blockquote>
<p>  这里的if很关键。如果跟随者拥有领导者发送的所有条目，跟随者必须不截断其日志。任何跟随领导者发送的条目的元素都必须被保留。这是因为我们可能从领导者那里收到了一个过时的AppendEntries RPC，而截断日志将意味着 “收回”我们可能已经告诉领导者我们的日志中的条目。</p>
<h2 id="Debugging-Raft"><a href="#Debugging-Raft" class="headerlink" title="Debugging Raft"></a>Debugging Raft</h2><p>  第一版的实现肯定是问题摆出，我们需要慢慢的迭代实现， 问题大致有如下几点，</p>
<ul>
<li><p>活锁</p>
<ol>
<li>当你的系统活锁时，你系统中的每个节点都在做一些事情，但你的节点集体处于这样一种状态，没有任何进展。这种情况在Raft中很容易发生，尤其是当你没有虔诚地遵循图2时。</li>
<li>有一种活锁情况特别经常出现；没有选举领导人，或者一旦选举了领导人，其他节点又开始选举，迫使最近当选的领导人立即退位。<br>  通常情况下是拥有最新log的服务器和过期服务器同时竞争服务器，但是通常是拥有最新log服务器竞选成功。</li>
<li>遇到高term就变成follower</li>
</ol>
</li>
<li><p>不正确的RPC</p>
<ol>
<li>防现不对逻辑的RPC就尽快返回false</li>
<li>发现follower的日志少了，follower就返回false，然后将最新index更新给leader的nextIndex</li>
<li>leader即使没有发送entry，也要检查prevLogIndex</li>
<li>AppendEntries的最后一步（#5）中的min是必要的，它需要用最后一个新条目的索引来计算。仅仅让应用lastApplied和commitIndex之间的日志内容的函数在到达日志的末尾时停止，是不够的。这是因为你的日志中可能会有与领导者的日志不同的条目，在领导者发给你的条目之后（这些条目都与你的日志中的条目一致）。因为 #3 决定了你只在有冲突的条目时才截断你的日志，那些条目不会被删除，如果 leaderCommit 超出了领导者发给你的条目，你可能会应用不正确的条目。发送高leader commit index和空的entry的RPC就会导致apply出现问题</li>
<li>要完全按照第5.4节中描述的方式实现 “最新日志”检查。老老实实的实现，不要只只检查长度!</li>
</ol>
</li>
<li><p>没有按照论文的理论实现raft</p>
<ol>
<li>在任何阶段<code>commitIndex&gt;lastApplied</code>你都可以直接<code>apply</code>log到上层状态机,提交日志的时候不持有锁或者设置数据保护区，保证其他程序不apply日志</li>
<li>将<code>commitIndex&gt;lastApplied</code>解耦,每次sentout心跳的时候检查<code>commitIndex</code>你必须要等<code>appendlog</code>动作完成</li>
<li><code>AppendEntries</code>RPC并不是因为log不一致被reject,应该立刻降级为follower,不要更新<code>nextIndex</code>，如果这个时候立刻选举你可能会面对数据竞争的问题</li>
<li><code>commitIndex</code>不能设置为旧的term，你一定要checklog[N].Term &#x3D;&#x3D;currentTerm.这是因为leader不知道follower是否在当前任期提交了日志,Figure 8会详细阐述这个问题</li>
</ol>
 <pre class="language-text" data-language="text"><code class="language-text">One common source of confusion is the difference between nextIndex and matchIndex. In particular, you may observe that matchIndex = nextIndex - 1, and simply not implement matchIndex. This is not safe. While nextIndex and matchIndex are generally updated at the same time to a similar value (specifically, nextIndex = matchIndex + 1), the two serve quite different purposes. nextIndex is a guess as to what prefix the leader shares with a given follower. It is generally quite optimistic (we share everything), and is moved backwards only on negative responses. For example, when a leader has just been elected, nextIndex is set to be index index at the end of the log. In a way, nextIndex is used for performance – you only need to send these things to this peer.matchIndex is used for safety. It is a conservative measurement of what prefix of the log the leader shares with a given follower. matchIndex cannot ever be set to a value that is too high, as this may cause the commitIndex to be moved too far forward. This is why matchIndex is initialized to -1 (i.e., we agree on no prefix), and only updated when a follower positively acknowledges an AppendEntries RPC.</code></pre>

<p> 正常情况下确实是<code>matchIndex = nextIndex - 1</code>,然后就不实现<code>matchIndex</code>是不安全的,<code>nextIndex</code>只是简单的认为leader已经提交了发送了哪些以前的logEntry，比如leader被选举出来只是讲nextIndex设置为log的长度，而<code>matchIndex</code>则是安全的方法，确定leader已经提交了多少的日志，<code>matchIndex</code>不会设置的太高，这会导致<code>commitIndex</code>移动的太快</p>
</li>
<li><p>term混乱（term不稳定)</p>
  <pre class="language-text" data-language="text"><code class="language-text">Term confusion refers to servers getting confused by RPCs that come from old terms. In general, this is not a problem when receiving an RPC, since the rules in Figure 2 say exactly what you should do when you see an old term. However, Figure 2 generally doesn’t discuss what you should do when you get old RPC replies. From experience, we have found that by far the simplest thing to do is to first record the term in the reply (it may be higher than your current term), and then to compare the current term with the term you sent in your original RPC. If the two are different, drop the reply and return. Only if the two terms are the same should you continue processing the reply. There may be further optimizations you can do here with some clever protocol reasoning, but this approach seems to work well. And not doing it leads down a long, winding path of blood, sweat, tears and despair.

A related, but not identical problem is that of assuming that your state has not changed between when you sent the RPC, and when you received the reply. A good example of this is setting matchIndex = nextIndex - 1, or matchIndex = len(log) when you receive a response to an RPC. This is not safe, because both of those values could have been updated since when you sent the RPC. Instead, the correct thing to do is update matchIndex to be prevLogIndex + len(entries[]) from the arguments you sent in the RPC originally.</code></pre>
<p>  因为网络导致的RPC过期问题，term混淆是指服务器被来自旧term的RPC所迷惑。一般来说，在收到RPC时，因为图2中的规则确切地说明了当你看到一个旧term时你应该做什么。然而，图2一般没有讨论当你收到旧的RPC回复时你应该做什么。根据经验，我们发现，到目前为止，最简单的做法是首先记录回复中的术语（它可能比你当前的term高），然后将当前term与你在原始RPC中发送的term进行比较。如果两者不同，就放弃回复并返回。只有当这两个术语相同时，你才应该继续处理回复。也许你可以通过一些巧妙的协议推理在这里做进一步的优化，但这种方法似乎很有效。而不这样做会导致一条漫长而曲折的血汗、泪水和绝望的道路。</p>
</li>
<li><p>优化</p>
  <pre class="language-text" data-language="text"><code class="language-text">An aside on optimizations
The Raft paper includes a couple of optional features of interest. In 6.824, we require the students to implement two of them: log compaction (section 7) and accelerated log backtracking (top left hand side of page 8). The former is necessary to avoid the log growing without bound, and the latter is useful for bringing stale followers up to date quickly.

These features are not a part of “core Raft”, and so do not receive as much attention in the paper as the main consensus protocol. Log compaction is covered fairly thoroughly (in Figure 13), but leaves out some design details that you might miss if you read it too casually:

When snapshotting application state, you need to make sure that the application state corresponds to the state following some known index in the Raft log. This means that the application either needs to communicate to Raft what index the snapshot corresponds to, or that Raft needs to delay applying additional log entries until the snapshot has been completed.
The text does not discuss the recovery protocol for when a server crashes and comes back up now that snapshots are involved. In particular, if Raft state and snapshots are committed separately, a server could crash between persisting a snapshot and persisting the updated Raft state. This is a problem, because step 7 in Figure 13 dictates that the Raft log covered by the snapshot must be discarded.

If, when the server comes back up, it reads the updated snapshot, but the outdated log, it may end up applying some log entries that are already contained within the snapshot. This happens since the commitIndex and lastApplied are not persisted, and so Raft doesn’t know that those log entries have already been applied. The fix for this is to introduce a piece of persistent state to Raft that records what “real” index the first entry in Raft’s persisted log corresponds to. This can then be compared to the loaded snapshot’s lastIncludedIndex to determine what elements at the head of the log to discard.

The accelerated log backtracking optimization is very underspecified, probably because the authors do not see it as being necessary for most deployments. It is not clear from the text exactly how the conflicting index and term sent back from the client should be used by the leader to determine what nextIndex to use. We believe the protocol the authors probably want you to follow is:

If a follower does not have prevLogIndex in its log, it should return with conflictIndex = len(log) and conflictTerm = None.
If a follower does have prevLogIndex in its log, but the term does not match, it should return conflictTerm = log[prevLogIndex].Term, and then search its log for the first index whose entry has term equal to conflictTerm.
Upon receiving a conflict response, the leader should first search its log for conflictTerm. If it finds an entry in its log with that term, it should set nextIndex to be the one beyond the index of the last entry in that term in its log.
If it does not find an entry with that term, it should set nextIndex = conflictIndex.
A half-way solution is to just use conflictIndex (and ignore conflictTerm), which simplifies the implementation, but then the leader will sometimes end up sending more log entries to the follower than is strictly necessary to bring them up to date.</code></pre>

<ul>
<li><p>当快照应用程序状态时，你需要确保应用程序状态与Raft日志中某个已知索引之后的状态相对应，这意味着应用程序要么需要向Raft传达快照所对应的索引，要么Raft需要推迟应用额外的日志条目，直到快照完成。</p>
</li>
<li><p>该文本没有讨论当服务器崩溃并重新启动时的恢复协议，因为现在涉及到快照。特别是，如果Raft状态和快照是分开提交的，服务器可能会在坚持快照和坚持更新的Raft状态之间崩溃。这是一个问题，因为图13中的第7步决定了快照所覆盖的Raft日志必须被丢弃。如果当服务器重新启动时，它读取的是更新的快照，而不是过时的日志，那么它最终可能会应用一些已经包含在快照中的日志条目。这种情况会发生，因为commitIndex和lastApplied没有被持久化，所以Raft不知道这些日志条目已经被应用。解决这个问题的方法是在Raft中引入一个持久化状态，记录Raft持久化日志中的第一个条目所对应的 “真实 “索引。然后，这可以与加载的快照的lastIncludedIndex进行比较，以确定在日志的头部有哪些元素需要丢弃.</p>
</li>
</ul>
</li>
</ul>
<h2 id="Applications-on-top-of-Raft"><a href="#Applications-on-top-of-Raft" class="headerlink" title="Applications on top of Raft"></a>Applications on top of Raft</h2><ul>
<li><p>Applying client operations</p>
  <pre class="language-text" data-language="text"><code class="language-text">You may be confused about how you would even implement an application in terms of a replicated log. You might start off by having your service, whenever it receives a client request, send that request to the leader, wait for Raft to apply something, do the operation the client asked for, and then return to the client. While this would be fine in a single-client system, it does not work for concurrent clients.

Instead, the service should be constructed as a state machine where client operations transition the machine from one state to another. You should have a loop somewhere that takes one client operation at the time (in the same order on all servers – this is where Raft comes in), and applies each one to the state machine in order. This loop should be the only part of your code that touches the application state (the key/value mapping in 6.824). This means that your client-facing RPC methods should simply submit the client’s operation to Raft, and then wait for that operation to be applied by this “applier loop”. Only when the client’s command comes up should it be executed, and any return values read out. Note that this includes read requests!

This brings up another question: how do you know when a client operation has completed? In the case of no failures, this is simple – you just wait for the thing you put into the log to come back out (i.e., be passed to apply()). When that happens, you return the result to the client. However, what happens if there are failures? For example, you may have been the leader when the client initially contacted you, but someone else has since been elected, and the client request you put in the log has been discarded. Clearly you need to have the client try again, but how do you know when to tell them about the error?

One simple way to solve this problem is to record where in the Raft log the client’s operation appears when you insert it. Once the operation at that index is sent to apply(), you can tell whether or not the client’s operation succeeded based on whether the operation that came up for that index is in fact the one you put there. If it isn’t, a failure has happened and an error can be returned to the client.</code></pre>

<p>  解决这个问题的一个简单方法是，当你插入客户操作时，记录客户操作在Raft日志中出现的位置。一旦该索引的操作被发送到apply()，你可以根据该索引出现的操作是否是你放在那里的操作来判断客户的操作是否成功。如果不是，就说明发生了失败，可以向客户返回一个错误。</p>
</li>
<li><p>Duplicate detection</p>
  <pre class="language-text" data-language="text"><code class="language-text">As soon as you have clients retry operations in the face of errors, you need some kind of duplicate detection scheme – if a client sends an APPEND to your server, doesn’t hear back, and re-sends it to the next server, your apply() function needs to ensure that the APPEND isn’t executed twice. To do so, you need some kind of unique identifier for each client request, so that you can recognize if you have seen, and more importantly, applied, a particular operation in the past. Furthermore, this state needs to be a part of your state machine so that all your Raft servers eliminate the same duplicates.

There are many ways of assigning such identifiers. One simple and fairly efficient one is to give each client a unique identifier, and then have them tag each request with a monotonically increasing sequence number. If a client re-sends a request, it re-uses the same sequence number. Your server keeps track of the latest sequence number it has seen for each client, and simply ignores any operation that it has already seen.</code></pre>
</li>
<li><p>Hairy corner-cases</p>
  <pre class="language-text" data-language="text"><code class="language-text">If your implementation follows the general outline given above, there are at least two subtle issues you are likely to run into that may be hard to identify without some serious debugging. To save you some time, here they are:</code></pre>
<ul>
<li>Re-appearing indices</li>
</ul>
</li>
<li><p>The four-way deadlock</p>
  <pre class="language-text" data-language="text"><code class="language-text">All credit for finding this goes to Steven Allen, another 6.824 TA. He found the following nasty four-way deadlock that you can easily get into when building applications on top of Raft.

Your Raft code, however it is structured, likely has a Start()-like function that allows the application to add new commands to the Raft log. It also likely has a loop that, when commitIndex is updated, calls apply() on the application for every element in the log between lastApplied and commitIndex. These routines probably both take some lock a. In your Raft-based application, you probably call Raft’s Start() function somewhere in your RPC handlers, and you have some code somewhere else that is informed whenever Raft applies a new log entry. Since these two need to communicate (i.e., the RPC method needs to know when the operation it put into the log completes), they both probably take some lock b.

In Go, these four code segments probably look something like this:</code></pre>
  </text>
  </details></li>
</ul>
</li>
</ul>
<h2 id="AppendIndex"><a href="#AppendIndex" class="headerlink" title="AppendIndex"></a>AppendIndex</h2><ul>
<li>2022&#x2F;08&#x2F;21<br>  etcd的raft模块难得不只是一点点，看来不能直接看它和etcd的整合，尝试着理解那个example开始。一个玩具的raftkv.</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源,欢迎对文章中的引用来源进行考证,欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论,也可以邮件至zxc741208584@gmail.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'ca29b9a1203b5920918d',
            clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
            repo: 'SimonTeo58.github.io',
            owner: 'SimonTeo58',
            admin: ['SimonTeo58'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    i hear i forget, i see i remember , i do i understand
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
