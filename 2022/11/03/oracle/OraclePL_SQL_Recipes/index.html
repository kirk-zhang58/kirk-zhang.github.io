
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CoffeeMan">
    <title>Oracle PLSQL Recipes - CoffeeMan</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://simonteo58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg"},"articleBody":"摘要: 其实这个讲PLSQL有点基础\n\n\n\n\n\n1 PL&#x2F;SQL Fundamentals1.1 创建plsql代码块如和创建一个可以执行的plsql代码块？\n-- demo 1\nbegin\n  -- 中间写代码\nend;\n\n-- demo 2\n\n\ndeclare\n\n-- 定义变量\n\nbegin \n -- 业务逻辑\nend;\n\n在实际的开发当中，这些代码块会进行嵌套，第一层代码块定义的变量，内层的代码块也可以直接使用\n1.2 在plsql种执行plsql代码块如何在sqlplus中执行plsql代码?\n登录sqlplus就可以直接输入自己的代码，然后end;结束代码块，并且接着输入/,这时候sqlplus解释器就可以执行代码了。但是有一点需要明确，如果你的代码块是以declare开头的，那么就会直接输出到屏幕\nsql&gt; begin\nDBMS_OUTPUT.put_line(&quot;hello world&quot;)\nend;\n&#x2F;\n\n但是如果你想创建package,function,procedure,可以使用如下语句，方便后面的调用\nSQL&gt; CREATE OR REPLACE PROCEDURE hello_world AS \n BEGIN \n DBMS_OUTPUT.PUT_LINE(&#39;Hello World&#39;); \n END; \n &#x2F; \n\n1.3 store code in script如果你想通过sql脚本执行代码，该如何运行？\nSET SERVEROUTPUT ON;\nDECLARE \n counter NUMBER;\nBEGIN \n  FOR counter IN REVERSE 0..10 LOOP \n  DBMS_OUTPUT.PUT_LINE (counter); \n  END LOOP; \nEND;\n&#x2F;\n你可以保存你的plsql代码在脚本里,重要一步是要保证你的文件扩展名是.sqlSQL Developer supports a number of additionalextensions for more specific types of PL&#x2F;SQL. \n1.4 执行你的脚本登录sqlplus，然后跳(Traverse)到你的脚本目录\n@绝对路径\n@相对路径\nsqlplus username&#x2F;password@database my_stored_script.sql \n\n1.5 接受用户的输入从键盘中sqlplus使用&amp;符号来接受来自键盘的输入\nDECLARE\n emp_count NUMBER; \nBEGIN \n SELECT count(*) \n INTO emp_count \n FROM employees \n WHERE department_id &#x3D; &amp;department_id; \nEND; \n\n但是如果你想从键盘接受一个输入，但是后面又想继续使用，则可以使用如下方法\nDECLARE\n emp_count NUMBER; \nBEGIN \n  SELECT count(*) \n  INTO emp_count \n  FROM employees \n  WHERE department_id &#x3D; &amp;&amp;department_id; \n  DBMS_OUTPUT.PUT_LINE(&#39;The employee count is: &#39; || emp_count || \n  &#39; for the department with an ID of: &#39; || &amp;department_id); \nEND;\n\n\n另外还有一种方法就是定义变量来承接从键盘来的输入,但是要注意这个变量定义的类型,如果是numeric类型的，如果是varchar2类型则需要用单引号,见如下代码\nDECLARE \n    first varchar2(20); \n    last varchar2(25); \n    emp_last VARCHAR2(25) :&#x3D; &#39;&amp;last_name&#39;; \n    emp_count NUMBER; \nBEGIN \n    SELECT count(*) \n    INTO emp_count \n    FROM employees \n    WHERE last_name &#x3D; emp_last; \n IF emp_count &gt; 1 THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;More than 1 employee exists with that name.&#39;); \n ELSE \n    SELECT first_name, last_name \n    INTO first, last \n    FROM employees \n    WHERE last_name &#x3D; emp_last; \n    DBMS_OUTPUT.PUT_LINE(&#39;The matching employee is: &#39; || \n    first || &#39; &#39; || last); \n END IF; \nEXCEPTION \n    WHEN NO_DATA_FOUND THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;Please enter a different last name.&#39;); \nEND; \n\n1.6 Displaying Results in SQL*PlusSET SERVEROUTPUT ON is issued, then the default buffer size is 20,000 bytes.Any content that surpasses that size will be cut off. To increase the buffer, simply set the size of bufferyou’d like to use when turning the SERVEROUTPUT on: \n1.7 Commenting Your Code1.8 Referencing a Block of Code如何引用一个代码块?\n给一个代码块添加label标签,比如下面的代码\n\n&lt;&lt;dept_block&gt;&gt;\nDECLARE \n  dept_name varchar2(30); \nBEGIN \n  SELECT department_name \n  INTO dept_name \n  FROM departments \n  WHERE department_id &#x3D; 230;\n  DBMS_OUTPUT.PUT_LINE(dept_name);\nEND dept_block;\n\n\n1.9. Referring to Variables from Nested Blocks如果code block是嵌套关系那么该如何使用具有相同名字的变量,可以使用label来区分不同的变量名字\n&lt;&lt;outer_block&gt;&gt;\nDECLARE\n  mgr_id NUMBER(6) :&#x3D; &#39;&amp;current_manager_id&#39;;\n  dept_count number :&#x3D; 0;\nBEGIN\n\nSELECT count(*)\n    INTO dept_count \n    FROM departments \n    WHERE manager_id &#x3D; outer_block.mgr_id;\n\n IF dept_count &gt; 0 THEN \n    &lt;&lt;inner_block&gt;&gt; \n    DECLARE \n      dept_name VARCHAR2(30); \n      mgr_id NUMBER(6):&#x3D; &#39;&amp;new_manager_id&#39;; \n    BEGIN \n    SELECT department_name \n    INTO dept_name \n    FROM departments \n    WHERE manager_id &#x3D; outer_block.mgr_id; \n\n    UPDATE departments \n    SET manager_id &#x3D; inner_block.mgr_id \n    WHERE manager_id &#x3D; outer_block.mgr_id; \n    DBMS_OUTPUT.PUT_LINE \n    (&#39;Department manager ID has been changed for &#39; || dept_name); \n    END inner_block; \n ELSE \n    DBMS_OUTPUT.PUT_LINE(&#39;There are no departments listed for the manager&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;There are no departments listed for the manager&#39;); \nEND outer_block; \n\n但是inner block创建的变量，outside block是不会读取到的,外部块变量在内部块中是可见的，而不需要完全限定名称，并且不需要块标签\n1.10. Ignoring Substitution Variables转义那些sqlplus使用的特殊字符\nSQL&gt; SET ESCAPE &#39;\\&#39; \nSQL&gt; INSERT INTO DEPARTMENTS VALUES( \n  departments_seq.nextval, \n  &#39;Shipping \\&amp; Receiving&#39;, \n  null, \n null);\n\n还有另外一种\nSQL&gt; SET DEFINE OFF\nINSERT INTO DEPARTMENTS VALUES( \ndepartments_seq.nextval, \n&#39;Importing &amp; Exporting&#39;, \nnull, \nnull); \n\n\n1.11. Changing the Substitution Variable Character如果你对改变替换变量符号(&amp;)为其他的符号\n可以使用set define ^, 你也可以使用任意其他的符号来替换\nSQL&gt; SET DEFINE ^\nSQL&gt; SELECT department_name \n     FROM departments \n     WHERE department_id &#x3D; ^dept_id;\n\n1.12. Creating a Variable to Match a Database Column Type如果向查数据库中某一个表的数据，该如何将查询结果赋值给变量呢？可以使用%type关键字,会将一列的数据赋值给变量,而%rowtype则是返回一列的数据给变量\n\nDECLARE\n dept_name departments.department_name%TYPE; \n dept_id NUMBER(6) :&#x3D; &amp;department_id; \nBEGIN \n SELECT department_name \n INTO dept_name \n FROM departments \n WHERE department_id &#x3D; dept_id; \n DBMS_OUTPUT.PUT_LINE(&#39;The department with the given ID is: &#39; || dept_name); \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No department for the given ID&#39;); \nEND;\n\n2.基础sql\n2.1 Retrieving a Single Row from the Databaseproblem\nYou are interested in returning one row from a database table via a query that searches for an exactmatch.\nsolution 1你可以使用select ... into ...语法\nDECLARE\n    first VARCHAR2(20);  -- varchar2(20)一定是要兼容的数据库表字段的\n    last VARCHAR2(25); \n    email VARCHAR2(25); \nBEGIN \n    SELECT first_name, last_name, email \n    INTO first, last, email \n    FROM employees \n    WHERE employee_id &#x3D; 100; \n    DBMS_OUTPUT.PUT_LINE( \n    &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); \nEXCEPTION \nWHEN NO_DATA_FOUND THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given ID&#39;); \nWHEN TOO_MANY_ROWS THEN\n    DBMS_OUTPUT.PUT_LINE(&#39;More than one employee matches the given ID&#39;); \nEND; \n\nsolution 2\nDECLARE\n CURSOR emp_cursor IS \n SELECT first_name, last_name, email \n FROM employees \n WHERE employee_id &#x3D; &amp;emp_id; \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n OPEN emp_cursor; \n FETCH emp_cursor INTO first, last, email; \n IF emp_cursor%NOTFOUND THEN \n      RAISE NO_DATA_FOUND; \n ELSE \n -- Perform second fetch to see if more than one row is returned \n    FETCH emp_cursor INTO first, last, email; \n    IF emp_cursor%FOUND THEN \n      RAISE TOO_MANY_ROWS; \n    ELSE \n      DBMS_OUTPUT.PUT_LINE( \n      &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); \n      END IF;\n END IF; \nCLOSE emp_cursor; \n\n\nhow it works\nsolution 1: One is to issue a SELECT…INTO statement,which is a statement designed to return just one row.The other approach is to open a cursor, fetch the  one row, and close the cursorsolution 2: We keep an open mind on that point. Consider that if youare expecting exactly one row to bereturned, getting multiple rows back represents an exception case that you must somehow deal with.The cursor-based solution makes it easy to simply ignore that exception case, but ignoring a conditionthat you do not expect to occur does not change the fact that it has occurred. Although a cursor is used,the cases where no data is returned or where too many rows are returnedgiven the user-supplied EMPLOYEE_IDstill remain a reality. However, since cursors are specifically designed to deal with zero rows or morethan one row coming back from a query, no exceptions will be raised if these situations occur. For this reason,Solution #2 contains some conditional logic that is used to manually raise the desired exceptions.In the event that the user supplies the block with an invalid EMPLOYEE_ID, the cursor will not fetch any data. The %NOTFOUND attribute of the cursor will be checked to see whether the cursor successfully fetched data. If not, then the NO_DATA_FOUND exception is raised. If the cursor is successful in retrieving data, then a second FETCH statement is issued to see whether more thanone row will be returned. If more than one row is returned, then the TOO_MANY_ROWS exception is raised;otherwise, the expected output is displayed. In any event, the output that is displayed using either of thesolutions will be the same whether successful or not.\n2.2. Qualifying Column and Variable Names（变量和表列名相同)ProblemYou have a variable and a column sharing the same name. You want to refer to both in the same SQLstatement.For example, you decide that you’d like to search for records where LAST_NAME is not equal to a lastname that is provided by a user via an argument to a procedure call. Suppose you have declared avariable LAST_NAME, and you want to alter the query to read as follows: \nSELECT first_name, last_name, email\n INTO first, last, email \n FROM employees \nWHERE last_name &#x3D; last_name; \nHow does PL&#x2F;SQL know which LAST_NAME you are referring to since both the table column name andthe variable name are the same? You need a way to differentiate your references. \nSolutionYou can use the dot notation to fully qualify the local variable name with the procedure name so thatPL&#x2F;SQL can differentiate between the two. The altered query, including the fully qualifiedprocedure_name.variable solution, would read as follows: \nCREATE OR REPLACE PROCEDURE retrieve_emp_info(last_name IN VARCHAR2) AS \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n SELECT first_name, last_name, email \n INTO first, last, email \n FROM employees \n WHERE last_name &#x3D; retrieve_emp_info.last_name; \n DBMS_OUTPUT.PUT_LINE( \n &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last_name || &#39; - &#39; || email); \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name &#39; || last_name); \nEND; \n\nHow It Works\nPL&#x2F;SQL name resolution(方法) becomes very important in circumstances such as these, and by fully qualifyingthe names, you can be sure that your code will work as expected. The solution used dot notation to fullyqualify the variable name. \nThe column name could have been qualified with the table name, as in EMPLOYEES.LAST_NAME.However, there’s no need to qualify the column name in this case. Because the reference occurs within aSELECT, the closest resolution for LAST_NAME becomes the table column of that name. So, in this particularcase, it is necessary only to qualify references to variable names in the enclosing PL&#x2F;SQL block. \nIf you are executing a simple BEGIN…END block, then you also have the option of fully qualifying thevariable using the dot notation along with the block label. For the purposes of this demonstration, let’ssay that the code block shown in the solution was labeled &lt;&gt;. You could then fully qualify avariable named description as follows: \nside note:\n\n\n&lt;&lt;emp_info&gt;&gt;\nDECLARE \n last_name VARCHAR2(25) :&#x3D; &#39;Fay&#39;; \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n SELECT first_name, last_name, email \n INTO first, last, email \n FROM employees \n WHERE last_name &#x3D; emp_info.last_name; \nEND; \n\nIn this example, the LAST_NAME that is declared in the code block is used within the SELECT..INTOquery, and it is fully qualified with the code block label.\n\n\nsummary: \n\nwhile code block contain same variable name as parameter, we could use “procedure”(including package name i though) name qualify parameter name at where clause statement.\nactualy you could use table name qualify parameter name in code block, but no more works on it,due to in your select statement,it had been qualified by table name.\nand so on , if you use label on your code block, as case shown above\n\n\n\n2.3. Declaring Variable Types That Match Column TypesProblemYou want to declare some variables in your code block that match the same datatypes as some columnsin a particular table. If the datatype on one of those columns changes, you’d like the code block toautomatically update the variable type to match that of the updated column\nNoteSharp-eyed readers will notice that we cover this problem redundantly in Chapter 1. We cover thisproblem here as well, because the solution is fundamental to working in PL&#x2F;SQL, especially to working with SQL inPL&#x2F;SQL. We don’t want you to miss what we discuss in this recipe. It is that important.\nSolutionUse the %TYPE attribute(n.属性) on table columns to identify(v.确定) the types of data that will be returned into your local variables. Instead of providing a hard-coded datatype for a variable, append %TYPE to the database column name. Doing so will apply the datatype from the specified column to the variable you are declaring.\nIn the following example, the same SELECT INTO query is issued, as in the previous problem, to retrieve an employee record from the database. However, in this case, the variables are declared using the %TYPE attribute rather than designating a specified datatype for each.\nDECLARE \n  first   employees.first_name%TYPE;\n  last    employees.last_name%TYPE;\n  email   employees.email%TYPE;\nBEGIN \nSELECT \n  first_name, \n  last_name, \n  email INTO first, last, email \nFROM \n  employees \nWHERE \n  employee_id &#x3D; &amp; emp_id;\n  DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email);\nEXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;No matching employee was found, please try again.&#39;);\nWHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&#39;An unknown error has occured, please try again.&#39;);\nEND;\n\nAs you can see from the solution, the code block looks essentially the same as the one in the previous recipe. The only difference is that here the %TYPE attribute of each database column is being used in order to declare your local variable types.\nHow It WorksThe %TYPE attribute can become a significant time-saver and savior for declaring variable types, especially if the underlying database column types are subject(会发生变化) to change. This attribute enables the local variable to assume the same datatype of its corresponding database column type at runtime. Retrieving several columns into local application variables can become tedious(沉闷的) if you need to continually verify that the datatypes of each variable are the same as those of the columns whose data they will consume.The%TYPE attribute can be used when defining variables, constants, fields, and parameters. Using %TYPE assures(保证) that the variables you declare will always remain synchronized with the datatypes of their corresponding columns.\n\nsummary: \nat all above explained that we could use `%TYPE` attribute to define variable which the same as table datatype\n\n\n2.4. Returning Queried Data into a PL&#x2F;SQL RecordProblemInstead of retrieving only a select few columns via a database query, you’d rather return the entirematching row. It can be a time-consuming task to replicate each of the table’s columns in yourapplication by creating a local variable for each along with selecting the correct datatypes. Although youcan certainly make use of the %TYPE attribute while declaring the variables, you’d rather retrieve theentire row into a single object. Furthermore, you’d like the object that the data is going to be stored intoto have the ability to assume the same datatypes for each of the columns being returned just as youwould by using the %TYPE attribute.SolutionMake use of the %ROWTYPE attribute for the particular database table that you are querying. The %ROWTYPEattribute returns a record type that represents a database row from the specified table. For instance, thefollowing example demonstrates how the %ROWTYPE attribute can store an entire employee table row for acursor: \nDECLARE \n CURSOR emp_cur IS \n SELECT * \n FROM employees \n WHERE employee_id &#x3D; &amp;emp_id; \n -- Declaring a local variable using the ROWTYPE attribute \n -- of the employees table \n emp_rec employees%ROWTYPE; \nBEGIN \n OPEN emp_cur; \n FETCH emp_cur INTO emp_rec; \n IF emp_cur%FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || emp_rec.first_name || &#39; &#39; || \n emp_rec.last_name || &#39; - &#39; || emp_rec.email); \n ELSE \n  DBMS_OUTPUT.PUT_LINE(&#39;No matching employee for the given ID&#39;);\n END IF; \n CLOSE emp_cur; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given emp ID’); \nEND; \n\n\nHow It WorksThe %ROWTYPE attribute represents an entire database table row as a record type. Each of thecorresponding table columns is represented within the record as a variable, and each variable in therecord inherits its type from the respective table column.Using the %ROWTYPE attribute offers several advantages to declaring each variable individually. Forstarters, declaring a single record type is much more productive than declaring several local variables tocorrespond to each of the columns of a table. Also, if any of the table columns’ datatypes is everadjusted, then your code will not break because the %ROWTYPE attribute works in much the same manneras the %TYPE attribute of a column in that it will automatically maintain the same datatypes as thecorresponding table columns. Therefore, if a column with a type of VARCHAR2(10) is changed toVARCHAR2(100), that change will ripple(vt.在…上形成波痕) through into your record definition.Using %ROWTYPE also makes your code much easier to read because you are not littering(n.乱丢废物) localvariables throughout. Instead, you can use the dot notation to reference each of the different columnsthat the record type returned by %ROWTYPE consists of. For instance, in the solution, the first_name,last_name, and email columns are referenced from the emp_rec record type. \n2.5. Creating Your Own Records to Receive Query ResultsProblemYou want to query the database, return several columns from one or more tables, and store them intolocal variables of a code block for processing. Rather than placing the values of the columns intoseparate variables, you want to create a single variable that contains all the values.summary: return several columns from one or more tables.\nSolutionCreate a database RECORD containing variables to hold the data you want to retrieve from the database.Since a RECORD can hold multiple variables of different datatypes, they work nicely for grouping data thathas been retrieved as a result of a query.In the following example, the database is queried for the name and position of a player. The datathat is returned is used to populate(vt.居住于；构成人口) a PL&#x2F;SQL RECORD containing three separate variables: first name, lastname, and position. \nDECLARE\n  TYPE emp_info IS RECORD(first employees.first_name%TYPE, \n                         last employees.last_name%TYPE, \n                         email employees.email%TYPE); \n  emp_info_rec emp_info;  -- 用emp_info 类型定义了emp_info_rec变量\n\nBEGIN \n SELECT first_name, last_name, email \n INTO emp_info_rec \n FROM employees \n WHERE last_name &#x3D; &#39;Vargas&#39;; \n DBMS_OUTPUT.PUT_LINE(&#39;The queried employee&#39;&#39;s email address is &#39; || emp_info_rec.email); \n EXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); \nEND; \n\nHow It WorksRecords are useful for passing similar data around within an application, but they are also quite usefulfor simply retrieving data and organizing it nicely as is the case with the solution to this recipe. To createa record, you first declare a record TYPE. This declaration can consist of one or more different datatypesthat represent columns of one or more database tables. Once the record type is declared, you create avariable and define it as an instance of the record type. This variable is then used to populate and work with the data stored in the record. \nCursor work very well with records of data. When declaring a cursor, you can select particularcolumns of data to return into your record. The record variable then takes on the type of cursor%ROWTYPE.In the following example, a cursor is used to determine which fields you want to return from EMPLOYEES.That cursor’s %ROWTYPE attribute is then used to define a record variable that is used for holding thequeried data. \nDECLARE\n CURSOR emp_cur IS \n SELECT first_name, last_name, email \n FROM employees \n WHERE employee_id &#x3D; 100; \n emp_rec emp_cur%ROWTYPE; \nBEGIN \n OPEN emp_cur; \n FETCH emp_cur INTO emp_rec; \n IF emp_cur %FOUND THEN \nCLOSE emp_cur; \n DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || \n &#39;&#39;&#39;s email is &#39; || emp_rec.email); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the provided ID number&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); \nEND; \nAs you can see in this example, the cursor %ROWTYPE attribute creates a record type using thecolumns that are queried by the cursor. The result is easy-to-read code that gains all the positive effectsof declaring record types via the %ROWTYPE attribute. \n2.6. Looping Through Rows from a QueryProblemA query that you are issuing to the database will return many rows. You want to loop through those rowsand process them accordingly. \nSolution #1There are a couple of different solutions for looping through rows from a query. One is to work directlywith a SELECT statement and use a FOR loop along with it. In the following example, you will see thistechnique in action:\nSET SERVEROUTPUT ON; \nBEGIN \n FOR emp IN \n ( \n SELECT first_name, last_name, email \n FROM employees \n WHERE commission_pct is not NULL \n ) \n LOOP \n DBMS_OUTPUT.PUT_LINE(emp.first_name || &#39; &#39; || emp.last_name || &#39; - &#39; || emp.email); \n END LOOP; \nEND; \n\nSolution #2Similarly, you can choose to use a FOR loop along with a cursor. Here’s an example: \nSET SERVEROUTPUT ON; \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, email \n FROM employees \nWHERE commission_pct is not NULL; \n      emp_rec emp_cur%ROWTYPE;\nBEGIN \n FOR emp_rec IN emp_cur LOOP \n DBMS_OUTPUT.PUT_LINE( \n emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_rec.email); \n END LOOP; \nEND; \n\nHow It WorksThe loop that is used in the first solution is also known as an implicit(adj.含蓄的,暗示的) cursor FOR loop. No variables need to be explicitly defined in that solution, because the FOR loop will automatically create a record using the results of the query. That record will take the name provided in the FOR variable_name IN clause. Thatrecord variable can then be used to reference the different columns that are returned by the query. As demonstrated in the second solution to this recipe, a cursor is also a very useful way to loop through the results of a query. This technique is also known as an explicit cursor FOR loop. This technique is very similar to looping through the results of an explicitly listed query. Neither solution requires you to explicitly open and close a cursor. In both cases, the opening andclosing is done on your behalf by the FOR loop processing. As you can see, the FOR loop with the SELECT query in the first example is a bit more concise(adj.简明的,简洁的), and there are fewer lines of code. The first example also contains no declarations. In the second example, with the cursor, there are two declarations that account for more lines of code. However, using the cursor is a standard technique that provides for more reusable code. For instance, you can elect to use the cursor any number of times, and you’ll need to write the query only once when declaring the cursor. On the contrary, if you wanted to reuse the query in the first example, then you would have to rewrite it,and having to write the same query multiple times opens the door to errors and inconsistencies. We recommend Solution #2. \n2.7. Obtaining Environment and Session InformationProblemYou want to obtain environment and session information such as the name and IP address of thecurrent user so that the values can be stored into local variables for logging purposes.SolutionMake use of the SYS_CONTEXT() built-in function to query the database for the user’s information. Once youhave obtained the information, then store it into a local variable. At that point, you can do whateveryou’d like with it, such as save it in a logging table. The following code block demonstrates thistechnique: \n&lt;&lt;obtain_user_info&gt;&gt;\nDECLARE \n  username varchar2(100); \n  ip_address varchar2(100); \nBEGIN\n  SELECT SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), SYS_CONTEXT(&#39;USERENV&#39;,&#39;IP_ADDRESS&#39;) \n  INTO username, ip_address \n  FROM DUAL; \n  DBMS_OUTPUT.PUT_LINE(&#39;The connected user is: &#39; || username || &#39;, and the IP address\n  is &#39; || \n  ip_address); \nEND; \nOnce this code block has been run, then the user’s information should be stored into the localvariables that have been declared within it. \nHow It WorksYou can use the SYS_CONTEXT function to obtain important information regarding the current user’senvironment, among other things. It is often times used for auditing(n.审计;查帐) purposes so that a particular codeblock can grab(vi.攫取;夺取) important information about the connected user such as you’ve seen in the solution tothis recipe. The SYS_CONTEXT function allows you to define a namespace and then place parameterswithin it so that they can be retrieved for use at a later time. The general syntax for the use ofSYS_CONTEXT is as follows: \nSYS_CONTEXT(&#39;namespace&#39;,&#39;parameter&#39;[,length]) \nA namespace can be any valid SQL identifier, and it must be created using the CREATE_CONTEXTstatement. The parameter must be a string or evaluate to a string, and it must be set using theDBMS_SESSION.SET_CONTEXT procedure. The call to SYS_CONTEXT with a valid namespace and parameterwill result in the return of a value that has a VARCHAR2 datatype. The default maximum length of thereturned value is 256 bytes. However, this default maximum length can be overridden by specifying thelength when calling SYS_CONTEXT. The length is an optional parameter. The range of values for the lengthis 1 to 4000, and if you specify an invalid value, then the default of 256 will be used.The USERENV namespace is automatically available for use because it is a built-in namespaceprovided by Oracle. The USERENV namespace contains session information for the current user. Table 2-1lists the parameters that are available to use with the USERENV namespace.Table 2-1. USERENV Parameter Listing \n-- Parameter          Description \nACTION                Identifies the position in the application name.\nAUDITED_CURSORID      Returns the cursor ID of the SQL that triggered the audit. \nAUTHENTICATED_DATA    Returns the data being used to authenticate the user. \nAUTHENTICATION_TYPE   Identifies how the user was authenticated. \nBG_JOB_ID             If an Oracle Database background process was used to establish the connection, then this returns the job ID of the current session. If no \n                      background process was established, then NULL is returned. \nCLIENT_IDENTIFIER     Returns identifier that is set by the application. \nCLIENT_INFO           Returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. \nCURRENT_SCHEMA        Returns the current session’s default schema.\nCURRENT_SCHEMAID      Returns the current schema’s identifier.\nCURRENT_SQL           Returns the first 4KB of the triggering SQL.\nDB_DOMAIN             Returns the value specified in the DB_DOMAIN parameter. \nDB_NAME               Returns the value specified in the DB_NAME parameter. \nDB_UNIQUE_NAME        Returns the value specified in the DB_UNIQUE_NAME parameter. \nENTRYID               Returns the current audit entry number. \nEXTERNAL_NAME         Returns the external name of the database user. \nFG_JOB_ID             If an Oracle Database foreground process was used to establish the connection, then this returns the job ID of the current session. If no \n                      foreground process was established, then NULL is returned. \nGLOBAL_CONTEXT_MEMORY Returns the number being used by the globally accessed context in the \n                      System Global Area.   \nHOST                  Returns the host name of the machine from which the client has connected. \nINSTANCE              Returns the instance ID number of the current instance. \nIP_ADDRESS            Returns the IP address of the machine from which the client has connected. \nISDBA                 Returns TRUE if the user was authenticated as a DBA. \nLANG                  Returns the ISO abbreviation of the language name. \nLANGUAGE              Returns the language and territory used by the session, along with the \n                      character set. \nMODULE                Returns the application name. This name has to be set via the\n                      DBMS_APPLICATION_INFO package. \nNETWORK_PROTOCOL      Returns the network protocol being used for communication. \nNLS_CALENDAR          Returns the current calendar of the current session. \nNLS_CURRENCY          Returns the currency of the current session. \nNLS_DATE_FORMAT       Returns the date format for the session. \nNLS_DATE_LANGUAGE     Returns the language being used for expressing dates. \nNLS_SORT              Returns the BINARY or linguistic sort basis. \nNLS_TERRITORY         Returns the territory of the current session. \nOS_USER               Returns the operating system user name of the client that initiated the \n                      session. \nPROXY_USER            Returns the name of the database that opened the current session on behalf \n                      of SESSION_USER. \nPROXY_USERID          Returns the identifier of the database user who opened the current session on behalf of the SESSION_USER. \nSERVICE_NAME          Returns the name of the service to which a given session is connected. \nSESSION_USER          Returns the database user name through which the current user is authenticated. \nSESSION_USERID        Returns the identifier of the database user name by which the current user is authenticated. \nSESSIONID             Returns the auditing session identifier. \nSTATEMENTID           Returns the auditing statement identifier. \nTERMINAL              Returns the operating system identifier for the client of the current session. \nWhen SYS_CONTEXT is used within any query, it is most commonly issued against the DUAL table. TheDUAL table is installed along with the data dictionary when the Oracle Database is created. This table isreally a dummy(adj.虚拟的,假的) table that contains one column that is appropriately named DUMMY. This column containsthe value X.\nSQL&gt; desc dual;\n Name Null? Type \n ----------------------------------------- -------- ---------------------------- \nDUMMY VARCHAR2(1) \nAmong other things, DUAL is useful for obtaining values from the database when no actual table isneeded. Our solution case is such a situation.\n2.8. Formatting Query ResultsProblemYour boss asks you to print the results from a couple of queries in a nicely formatted manner.SolutionUse a combination of different built-in formatting functions along with the concatenation operator (||)to create a nice-looking basic report. The RPAD and LPAD functions along with the concatenation operatorare used together in the following example that displays a list of employees from a company: \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, phone_number \n FROM employees; \n emp_rec employees%ROWTYPE; \nBEGIN \n FOR emp_rec IN emp_cur LOOP \n IF emp_rec.phone_number IS NOT NULL THEN \n DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 35,&#39;.&#39;) || \n emp_rec.phone_number); \n ELSE \n DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || \n &#39; does not have a phone number.&#39;); \n END IF; \n END LOOP; \nEND; \nThe following is another variant of the same report, but this time dashes are used instead of using \ndots to space out the report: \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, phone_number \n FROM employees; \n emp_rec employees%ROWTYPE; \nBEGIN \n FOR emp_rec IN emp_cur LOOP \n  IF emp_rec.phone_number IS NOT NULL THEN\n  --CHECK FOR INTERNATIONAL PHONE NUMBERS\n        IF length(emp_rec.phone_number) &gt; 12 THEN\n          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,18));\n        ELSE\n          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,12));\n        END IF;\n      ELSE\n        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;does not have a phone number.&#39;);\n    END IF;\n  END LOOP;\nEND;\n\nHow It WorksThe RPAD and LPAD functions are used to return the data in a formatted manner. The RPAD function takes astring of text and pads it on the right by the number of spaces provided by the second parameter. Thesyntax for the RPAD function is as follows:\nRPAD(input_text, n, character) -- append n piece characters on the right\n\nIn this syntax, n is the number of spaces used to pad. Similarly, the LPAD function pads on the left ofthe provided string. The syntax is exactly the same as RPAD; the only difference is the direction of thepadding. The combination of these two functions, along with the concatenation operator (||), providesfor some excellent formatting options.  \nIt is important to look at the data being returned before you try to format it, especially to considerwhat formatting options will look best when generating output for presentation. In the case of theexamples in this recipe, the latter example would be the most reasonable choice of formatting for thedata being returned, since the phone number includes dots in it. The first example uses dots to space outthe report, so too many dots may make the output difficult to read. Know your data, and then choose theappropriate PL&#x2F;SQL built-ins to format accordingly.  \nNote When using DBMS_OUTPUT to display data, please be sure to pay attention to the size of the buffer. You canset the buffer size from 2,000 to 1,000,000 bytes by passing the size you desire to the DBMS_OUTPUT.ENABLE procedure.If you attempt to display content over this size limit, then Oracle will raise an exception.\nOracle provides a number of built-in functions to use when formatting strings. Two others that areespecially useful are LTRIM(&lt;string&gt;) and RTRIM(&lt;string&gt;). These remove leading and trailing spaces,respectively. See your Oracle SQL Reference manual for a complete list of available string functions.\n2.9. Updating Rows Returned by a QueryProblem  You’ve queried the database and retrieved a row into a variable. You want to update some valuescontained in the row and commit them to the database.Solution  First, retrieve the database row that you want to update. Second, update the values in the row that needto be changed, and then issue an UPDATE statement to modify the database with the updated values. Inthe following example, a procedure is created that queries a table of employees for a particularemployee. The resulting employee’s department ID is then updated with the new one unless theemployee is already a member of the given department.\nCREATE OR REPLACE PROCEDURE change_emp_dept(emp_id IN NUMBER, \n dept_id IN NUMBER) AS \n emp_row employees%ROWTYPE; \n dept departments.department_name%TYPE; \n rec_count number :&#x3D; 0; \nBEGIN \n SELECT count(*) \n INTO rec_count \n FROM employees \n WHERE employee_id &#x3D; emp_id; \n IF rec_count &#x3D; 1 THEN \n SELECT * \n INTO emp_row \n FROM employees \n WHERE employee_id &#x3D; emp_id; \n IF emp_row.department_id !&#x3D; dept_id THEN \n emp_row.department_id :&#x3D; dept_id; \n UPDATE employees SET ROW &#x3D; emp_row \n WHERE employee_id &#x3D; emp_id; \n SELECT department_name \n INTO dept \n from departments \n WHERE department_id &#x3D; dept_id; \n DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || emp_row.first_name || &#39; &#39; || \n emp_row.last_name || &#39; is now in department: &#39; || dept); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;The employee is already in that department...no change&#39;); \n END IF; \nELSIF rec_count &gt; 1 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The employee ID you entered is not unique&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;No employee records match the given employee ID&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Invalid employee or department ID, try again&#39;); \n WHEN OTHERS THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Unsuccessful change, please check ID numbers and try again&#39;); \nEND; \nAs you can see, the example queries the database into a record declared using the %ROWTYPEattribute. The value that needs to be updated is then modified using the data contained in the record.Lastly, using the SET ROW clause updates the table with the modified record.How It WorksAs you’ve seen in the solution to the recipe, it is possible to update the values of a row returned by aquery using the UPDATE...SET ROW syntax. In many cases, using a single UPDATE statement can solve thistype of transaction. However, in some scenarios where you need to evaluate the current value of aparticular column, then this solution is the correct choice.\nUsing the UPDATE ROW statement, you can update entire database rows with a single variable of eitherthe %ROWTYPE or RECORD type. The UPDATE statement also allows you to return values after the update byadding the RETURNING clause to the end of the statement followed(v.跟着,听从) by the column names to return and thevariables that will receive their values. Take a look at this next example:\nDECLARE\n first        employees.first_name%TYPE; \n last         employees.last_name%TYPE; \n new_salary   employees.salary%TYPE; \nBEGIN \n UPDATE employees \n SET salary &#x3D; salary + (salary * .03) \n WHERE employee_id &#x3D; 100  RETURNING first_name, last_name,salary INTO first, last, new_salary; \n DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || first || &#39; &#39; || last || &#39; now has a salary of: &#39; || new_salary); \nEND; \nAs you can see, the example outputs the new values that are the result of the update statement.Using the RETURNING clause saves a step in that you are not required to requery the table after the updatein order to display the updated results.\n2.10. Updating Rows Returned by a CursorProblemYou’ve created a cursor to use for querying your data. You want to loop through the results using a cursor for loop and update the data as needed.SolutionUse the WHERE_CURRENT_OF clause within your loop to update the current data row in the iteration. In thefollowing example, the EMPLOYEES table is queried for all employees in a particular department. Theresults of the query are then iterated using a FOR loop, and the salary is increased for each employeerecord that is returned.\n\nDECLARE \n CURSOR emp_sal_cur IS \n SELECT * \n FROM employees \n WHERE department_id &#x3D; 60 \n FOR UPDATE;        --cursor should use &#96;FOR UPDATE&#96; clause statement\n\n emp_sal_rec emp_sal_cur%ROWTYPE; -- cursor also would define varable using ROWTYPE keyword\n\n BEGIN \n FOR emp_sal_rec IN emp_sal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;Old Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); \n    UPDATE employees \n    SET salary &#x3D; salary + (salary * .025) \n    WHERE CURRENT OF emp_sal_cur;  -- current of your_cursor\n END LOOP; \n\n -- Display the updated salaries \n FOR emp_sal_rec IN emp_sal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;New Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); \n END LOOP; \nEND;\n\nAn update on the EMPLOYEES table occurs with each iteration of the loop. The second loop in thisexample simply displays the new salary result for each employee that was returned by the cursor query.How It WorksUpdating values when iterating a cursor can be handy(adj.便利的,手边的), especially when working with a number of(大量) rows.There is one main difference between a cursor that allows updating and one(cursor) that does not. Thatdifference is the addition of the FOR UPDATE clause in the cursor declaration. By using the FOR UPDATEclause of the SELECT statement, you are causing the database to lock the rows that have been read by thequery. This lock is to ensure that nobody else can modify the rows while you are working with them. Thelock creates a read-only block on the table rows so that if someone else attempts to modify them whileyou have them locked, then they will have to wait until you have performed either a COMMIT or a ROLLBACK.The FOR UPDATE clause has an optional NOWAIT keyword. By including this keyword, you will ensurethat your query does not block your transaction if someone else already has the rows that you arequerying blocked. The NOWAIT keyword tells Oracle not to wait if the requested rows are already locked,and control is immediately passed back to your program so that it can continue to run. If the NOWAITkeyword is omitted and the rows are already locked, then your program will stop and wait until the lockhas been released.\nYou can use the cursor with any style of loop, as you’ve seen in previous recipes. No matter whichtype of loop you choose, the UPDATE must be coded using the WHERE CURRENT OF your_cursor clause to update thecurrent row in the cursor iteration. You will need to be sure to commit the changes after this block hasbeen run, and in many circumstances the COMMIT statement can be coded into this block once it has beentested and verified to work correctly. As with any UPDATE statement, if you fail to COMMIT your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to yourschema only until you disconnect. Issuing a COMMIT after your UPDATE statements have been issued is alsoa good practice in this case because it will release the lock on the rows you had queried via the cursor sothat someone else can update them if needed. If you determine the data that was updated by the codeblock is incorrect, then a ROLLBACK will also release the lock.\n\n\nsummary:\n\nif you wanna update data of cursor that returned by select, you can use WHERE CURRENT OF emp_sal_cur and for update\nBy using the FOR UPDATE clause of the SELECT statement,data lock is data level\nwether FOR UPDATE clause update table data or cursor only?(it should be commit changes for table)\nif you fail to COMMIT your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to yourschema only until you disconnec\nCOMMIT and ROLLBACK either release lock\n\n \n\n2.11. Deleting Rows Returned by a CursorProblemThere are a series of database rows that you’d like to delete. You’ve created a cursor FOR LOOP, and you want to delete some or all rows that have been queried with the cursor.SolutionUse a DELETE statement within a FOR LOOP to delete the rows that are retrieved by the cursor. If you create a cursor using the FOR UPDATE clause, then you will be able to use the WHERE CURRENT OF clause along with the DELETE statement to eliminate the current row within each iteration of the cursor. The following example shows how this can be done to remove all job history for a given department ID:\nCREATE OR REPLACE PROCEDURE remove_job_history(dept_id IN NUMBER) AS \n\n CURSOR job_history_cur IS \n SELECT * \n FROM job_history \n WHERE department_id &#x3D; dept_id \n FOR UPDATE; \n    job_history_rec job_history_cur%ROWTYPE; \n BEGIN \n  FOR job_history_rec IN job_history_cur LOOP \n    DELETE FROM job_history WHERE CURRENT OF job_history_cur; \n    DBMS_OUTPUT.PUT_LINE(&#39;Job history removed for department &#39; || dept_id); \n  END LOOP; \nEND; \nUsing this technique, the job history for the department with the given ID will be removed from the JOB_HISTORY table.\nHow It WorksMuch like updating rows using a cursor, the deletion of rows uses the WHERE CURRENT OF clause within the DELETE statement to remove each row. The cursor query must contain the FOR UPDATE clause in order to lock the rows that you are reading until a COMMIT or ROLLBACK has been issued. As mentioned in the previous recipe, the NOWAIT keyword is optional, and it can be used to allow control to be immediately returned to your program if someone else already has locks on the rows that you are interested in updating. In each iteration of the loop, the DELETE statement is used along with the WHERE CURRENT OF clause to remove the current cursor record from the database. Once the loop has been completed, then all the rows that had been queried via the cursor should have been deleted. This technique is especially useful if you are going to be performing some further processing on each of the records and then deleting them. One such case would be if you wanted to write each of the records to a history table prior to deleting them. In any case, the cursor FOR loop deletion technique is a great way to remove rows from the database and work with the data along the way.\n2.12. Performing a TransactionProblemYou need to complete a series of INSERT or UPDATE statements in order to process a complete transaction. In doing so, you need to ensure that if one of the statements fails, that all of the statements are canceled so that the transaction is not partially processed.SolutionUse the transaction control mechanisms that are part of PL&#x2F;SQL, as well as SQL itself, in order to control your transactions. When all your statements have been completed successfully, issue a COMMIT to make them final. On the other hand, if one of the statements does not complete successfully, then perform a ROLLBACK to undo all the other changes that have been made and bring the database back to the state that it was in prior(美[‘praɪɚ],adj.优先的,在先的,在前的) to the transaction occurring.In the following example, the code block entails the body of a script that is to be executed in order to create a new department and add some employees to it. The department change involves an INSERT and UPDATE statement to complete.\nDECLARE\n -- Query all programmers who make more than 4000 \n -- as they will be moved to the new &#39;Web Development&#39; department \n CURSOR new_dept_cur IS \n    SELECT * \n    FROM employees \n    WHERE job_id &#x3D; &#39;IT_PROG&#39;\n    AND salary &gt; 4000 \n    FOR UPDATE; \n new_dept_rec         new_dept_cur%ROWTYPE; \n current_department   departments.department_id%TYPE; \nBEGIN \n -- Create a new department \n INSERT INTO departments values( \n                                DEPARTMENTS_SEQ.nextval, -- Department ID (sequence value) \n                                &#39;Web Development&#39;, -- Department Title \n                                103 -- Manager ID \n                                1700); -- Location ID \n -- Obtain the current department ID…the new department ID \n SELECT DEPARTMENTS_SEQ.currval \n INTO current_department \n FROM DUAL; \n\n -- Assign all employees to the new department \n FOR new_dept_rec IN new_dept_cur LOOP \n      UPDATE employees \n      SET department_id &#x3D; current_department \n      WHERE CURRENT OF new_dept_cur; \n END LOOP;\n\n COMMIT;\n      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); \nEND;\nAs you can see, a transaction was performed in this block of code. It is important to roll back changes if errors occur along the way so that the transaction is not partially completed.\nHow It WorksTransaction control is built into the Oracle Database. Any database changes that are made within a code block are visible to the current session only until a COMMIT has been made. The changes that have been made by the statements can be rolled back via the ROLLBACK command up until the point that a COMMIT is issued. Oracle uses table and row locks to ensure that data that has been updated in one session cannot be seen in another session until a COMMIT occurs. A transaction is started when the first statement after the last COMMIT or ROLLBACK is processed or when a session is created. It ends when a COMMIT or ROLLBACK occurs. A transaction is not bound to a single code block, and any code block may contain one or more transactions. Oracle provides a SAVEPOINT command, which places a marker at the current database state so as to allow you to roll back to that point in time in a transaction. Oracle Database automatically issues a SAVEPOINT prior to processing the first statement in any transaction.\nAs a rule of thumb, it is always a good idea to have exception handling in place in case an exceptionoccurs. However, if an unhandled exception occurs, then the database will roll back the statement that caused the exception, not the entire transaction. Therefore, it is up to the program to handle exceptions and issue the ROLLBACK command if the entire transaction should be undone. If a database crashes and goes down during a transaction, then when the database is restarted, all uncommitted statements are rolled back. All transactions are completed when a COMMIT or ROLLBACK is issued.\n2.13. Ensuring That Multiple Queries “See” the Same DataProblemYou are issuing a set of queries against the database, and you need to ensure that none of the table rows change throughout the course of the queries being made.SolutionSet up a read-only transaction in which the current transaction will see the data only as an unchanged snapshot in time. To do so, use the SET TRANSACTION statement to begin a read-only transaction and establish a snapshot of the data so it will be consistent and unchanged from all other updates being made. For instance, the following example displays a block that sets up read-only queries against the database for dollar values from a bank account:\nDECLARE \n daily_atm_total NUMBER(12,2); \n weekly_atm_total NUMBER(12,2); \nBEGIN \n COMMIT; -- ends previous transaction \n SET TRANSACTION READ ONLY NAME &#39;ATM Weekly Summary&#39;; \n SELECT SUM (wd_amt) INTO daily_atm_total FROM atm_withdrawals \n WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE, &#39;MM-DD-YYYY&#39;); \n SELECT SUM (weekly_total) INTO weekly_atm_total FROM atm_withdrawals \n WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE - 7, &#39;MM-DD-YYYY&#39;); \n DBMS_OUTPUT.PUT_LINE(daily_atm_total || &#39; - &#39; || weekly_atm_total); \n COMMIT; -- ends read-only transaction \nEND; \nQuerying the database using read-only transactions will ensure that someone will see the correct values in a situation such as the one depicted(vt.描述,描画) in this example.\nHow It Worksoften times there are situations when you need to ensure that the data being queried throughout a transaction’s life cycle is unchanged by other users’ updates. The classic case is when someone goes to withdraw money from the bank and their spouse(n.配偶) is at an ATM machine depositing into the account at the same time. If read consistency were not in place, the individual may view their account balance and see that there was plenty of money to withdraw, and then they’d go to take the money out and receive an error because the spouse had canceled the deposit(美 [dɪ’pɑzɪt]n.存款,押金) instead. A read-only transaction allows for read consistency until a COMMIT has been issued. If the spouse had confirmed the deposit, then the next query on the account would reflect the additional funds (assuming that the bank were to release them to the account in real time).Situations such as these require that you provide an environment that is essentially isolated from the outside world. You can use the SET TRANSACTION command to start a read-only transaction, set an isolation level, and assign the current transaction to a rollback segment. The SET TRANSACTION statement must be the first statement in a read-only transaction, and it can appear only once in the transaction. Note that there are some statement restrictions when using a read-only transaction. Only SELECT INTO, OPEN, FETCH, CLOSE, LOCK TABLE, COMMIT, and ROLLBACK statements can be used; other statements are not allowed.\n2.14. Executing One Transaction from Within Another(nested tracsaction)ProblemYou are executing a transaction, and you are faced with the need to suspend your current work, issue a completely separate transaction, and then pick up your current work. For example, say you want to log entries into a log table. The log entries should be persisted separately from the current transaction such that if the transaction fails or is rolled back, the log entries will still be completed.SolutionStart an autonomous transaction to make the log entry. This will ensure that the log entry is performed separately from the current transaction. In the following example, an employee is deleted from the EMPLOYEES table. Hence, a job is ended, and the job history must be recorded into the JOB_HISTORY table. In the case that something fails within the transaction, the log entry into the JOB_HISTORY table must be intact(adj.完整的,原封不动的). This log entry cannot be rolled back because it is performed using an autonomous transaction.The code to encapsulate(美 [ɪn’kæpsjə’let],vt.压缩,将…装入胶囊) the autonomous transaction needs to be placed into a named block that can be called when the logging needs to be performed. The following piece of code creates a PL&#x2F;SQL procedure that performs the log entry using an autonomous transaction. (You will learn more about procedures in Chapter 4.) Specifically notice(n.通知,布告) the declaration of PRAGMA AUTONOMOUS_TRANSACTION. That pragma specifies that the procedure executes as a separate transaction, independent of any calling transaction.\nCREATE OR REPLACE PROCEDURE log_job_history ( emp_id IN \n                                              employees.employee_id%TYPE, \n                                              Job_id IN jobs.job_id%TYPE, \n                                              Department_id IN employees.department_id%TYPE, \n                                              employee_start IN DATE) AS \n  PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN \n INSERT INTO job_history \n VALUES (emp_id, \n employee_start, \n sysdate, \n job_id, \n department_id); \n COMMIT; \nEND;\n\nThe LOG_JOB_HISTORY procedure inserts an entry into the log table separately from the transaction that is taking place in the calling code block. The following code performs the job termination, and it calls the log_substitution procedure to record the history:\nDECLARE\n CURSOR dept_removal_cur IS \n    SELECT * \n    FROM employees \n    WHERE department_id &#x3D; 10 \n    FOR UPDATE; \n dept_removal_rec dept_removal_cur%ROWTYPE; \nBEGIN \n -- Delete all employees from the database who reside in department 10 \n FOR dept_removal_rec IN dept_removal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;DELETING RECORD NOW&#39;); \n    DELETE FROM employees WHERE CURRENT OF dept_removal_cur; \n    -- Log the termination \n    log_job_history(dept_removal_rec.employee_id, \n                      dept_removal_rec.job_id, \n                      dept_removal_rec.department_id, \n                      dept_removal_rec.hire_date);\n END LOOP; \n    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); \nEXCEPTION \n -- Handles all errors \n WHEN NO_DATA_FOUND THEN\n    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been rolled back due to errors, please try again.&#39;); \n    ROLLBACK; \nEND;\nIf this code block is executed and then rolled back, the entry into the job history table remains,because it is performed as a separate, autonomous transaction.How It WorksAn autonomous transaction is a transaction that is called by another transaction and that runs separately from the calling transaction. Autonomous transactions commit or roll back without affecting the calling transaction. They also have the full functionality of regular transactions; they merely(adv.仅仅,只不过,只是) run separately from the main transaction. They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.\nAn autonomous transaction must be created with a top-level code block, trigger, procedure,function, or stand-alone named piece of code. In the solution, you saw that a procedure was created to run as an autonomous transaction. That is because it is not possible to create an autonomous transaction within a nested code block. To name a transaction as autonomous, you must place the statement PRAGMA AUTONOMOUS_TRANSACTION within the declaration section of a block encompassing(adj.包含的,包容的,环绕) the transaction. To end the transaction, perform a COMMIT or ROLLBACK.\n\n\nsummary: \n\nThey allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.\n\n\n\n2.15. Finding and Removing Duplicate Table RowsProblemYou have found that for some reason your database contains a table that has duplicate records. You areworking with a database that unfortunately does not use primary key values, so you must manually enforce data integrity. You need a way to remove the duplicate records. However, any query you write to remove one record will also remove its duplicate.SolutionThe solution to this issue involves two steps. First you need to query the database to find all duplicaterows, and then you need to run a statement to delete one of each duplicate record that is found.The following code block queries the EMPLOYEES table for duplicate rows. When a duplicate is found,it is returned along with a count of duplicates found.\n&lt;&lt;duplicate_emp_qry&gt;&gt;\nDECLARE\nCURSOR emp_cur IS\n  SELECT *\n  FROM employees\n  ORDER BY employee_id;\n  emp_count\n  number :&#x3D; 0;\n  total_count\n  number :&#x3D; 0;\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(&#39;You will see each duplicated employee listed more &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;than once in the list below. This will allow you to &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;review the list and ensure that indeed...there are more &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;than one of these employee records in the table.&#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;Duplicated Employees: &#39;);\n-- Loop through each player in the table\nFOR emp_rec IN emp_cur LOOP\n-- Select the number of records in the table that have the same ID as the current record\nSELECT count(*)\nINTO emp_count\nFROM employees\nWHERE employee_id &#x3D; emp_rec.employee_id;\n-- If the count is greater than one then a duplicate has been found, so print it out.\nIF emp_count &gt; 1 THEN \n DBMS_OUTPUT.PUT_LINE(emp_rec.employee_id || &#39; - &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_count); \n total_count :&#x3D; total_count + 1; \n END IF; \n END LOOP; \nEND;\nIf the table includes a duplicate, then it is printed out as follows:You will see each duplicated employee listed more than once in the list below. This will allow you to review the list and ensure that indeed…there are morethan one of these employees in the table.Duplicated Employees:100 - Steven King - 2100 – Steven King - 2PL&#x2F;SQL procedure successfully completed.  \nNext, you need to delete the duplicated rows that have been found. The following DELETE statementwill ensure that one of the duplicates is removed:DELETE FROM employees A WHERE ROWID &gt; (SELECT min(rowid) FROM employees BWHERE A.employee_id &#x3D; B.employee_id);\nHow It WorksUsually using primary keys prohibits the entry of duplicate rows into a database table. However, many legacy databases still in use today do not include such constraints. In rare situations, a duplicate key and values are entered into the database that can cause issues when querying data or assigning values. The method shown in the solution for finding duplicate rows is very basic. The solution loops through each record in the table, and during each pass, it queries the table for the number of records found that match the current record’s EMPLOYEE_ID. If the number found is greater than one, then you know that you have found a duplicate. The solution presented here for finding duplicates will work on any table provided that you have a column of data that should contain logically unique values. In the example, each record should contain a different EMPLOYEE_ID, so if there is more than one record with the same EMPLOYEE_ID value, then a duplicate is found. If the table you are working with does not contain any unique columns, then you can concatenate a number of columns in order to obtain a unique combination. For instance, if EMPLOYEES did not contain an EMPLOYEE_ID column, then you could concatenate the FIRST_NAME, LAST_NAME, and EMAIL columns to obtain a unique combination. More likely than not, there will not be two employees in the table with the same name and e-mail address. The second part of the solution involves removing one or more duplicate records from the set. To do so, you have to look at a pseudocolumn known as the ROWID. The ROWID is a pseudocolumn (invisible column) that is found in each table in an Oracle Database that uniquely identifies each row. By comparing these unique ROWID values, you can delete just one of the records, not both. The DELETE statement actually finds the rows that contain the same uniquely identified column(s) and then removes the row with the larger ROWID value.\n3. Looping and Logic3.1. Choosing When to Execute CodeProblemYour code contains a condition, and you are interested in executing code to perform specific actions if the condition evaluates to TRUE, FALSE, or NULL.SolutionUse an IF-THEN statement to evaluate an expression (or condition) and determine which code to executeas a result. The following example depicts a very simple IF-THEN statement that evaluates one variable to see whether it contains a larger value than another variable. If so, then the statements contained within the IF-THEN statement are executed; otherwise, they are ignored. \nDECLARE \n value_one NUMBER :&#x3D; &amp;value_one; \n value_two NUMBER :&#x3D; &amp;value_two; \nBEGIN \n IF value_one &gt; value_two THEN \n DBMS_OUTPUT.PUT_LINE(&#39;value_one is greater than value_two&#39;); \n END IF; \nEND; \nAs you can see from the example, if value_one is greater than value_two, a line of output will be printed stating so. Otherwise, the IF statement is bypassed, and processing continues.How It WorksAs shown in the solution, the general format for the IF-THEN statement is as follows:\nIF condition THEN\n Statements to be executed \n …\nEND IF; \nThe IF-THEN statement is one of the most frequently used conditional statements. If a given condition evaluates to TRUE, then the code contained within the IF-THEN statement is executed. If the condition evaluates to FALSE or NULL, then the statement is exited. However, it is possible to incorporate(vt.包含,吸收) a different set of statements if the condition is not satisfied. Please see Recipe 3-2 for an example. Any number of IF-THEN statements can be nested within one another. The statements within the IF-THEN will be executed if the condition that is specified evaluates to TRUE.\n3-2. Choosing Between Two Mutually Exclusive ConditionsProblemYou have two conditions that are mutually(美 [‘mjutʃuəli]adv.互相地,互助) exclusive. You want to execute one set of statements if thefirst condition evaluates to TRUE. Otherwise, if the first condition is FALSE or NULL, then execute a differentset of statements.SolutionUse an IF-ELSE statement to evaluate the condition and execute the statements that correspond to it ifthe condition evaluates to TRUE. In the following example, a given employee ID is used to query theEMPLOYEES table. If that employee exists, then the employee record will be retrieved. If not found, then amessage will be displayed stating that no match was found. \nDECLARE \n employee employees%ROWTYPE; \n emp_count number :&#x3D; 0; \nBEGIN \n SELECT count(*) \n INTO emp_count \n FROM employees \n WHERE employee_id &#x3D; 100; \n IF emp_count &gt; 0 THEN \n SELECT * \n INTO employee \n FROM employees \n WHERE employee_id &#x3D; 100; \n IF employee.manager_id IS NOT NULL THEN \n DBMS_OUTPUT.PUT_LINE(employee.first_name || &#39; &#39; || employee.last_name || \n &#39; has an assigned manager.&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(employee.first_name || &#39; &#39; || employee.last_name || \n &#39; does not have an assigned manager.&#39;); \nEND IF; \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;The given employee ID does not match any records, &#39;|| \n &#39; please try again&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Try another employee ID.&#39;); \nEND; \nIn the real world, the employee ID would not be hard-coded into the example. However, this example provides a good scenario for evaluating mutually exclusive conditions and also nesting IF statements.How It WorksThe IF-ELSE statement syntax is basically the same as the IF-THEN syntax, except that a different set ofstatements is executed in the ELSE clause when the condition evaluates to FALSE or NULL. Therefore, if thefirst condition is FALSE or NULL, then the control automatically drops down into the statements containedwithin the ELSE clause and executes them.\n3.3. Evaluating Multiple Mutually Exclusive ConditionsProblemYour application has multiple conditions to evaluate, and each of them is mutually exclusive. If one ofthe conditions evaluates to FALSE, you’d like to evaluate the next one. You want that process to continueuntil there are no more conditions.Two solutions are possible: one using IF and the other using CASE.\nSolution #1Use an IF-ELSIF-ELSE statement to perform an evaluation of all mutually exclusive conditions. The following example is a SQL*Plus script that queries how many countries are in a specified region.\nIf the region that is typed as input when the following example executes matches any of the regions specified by the conditions in the IF statement, then subsequent statements are executed. However, a default message is displayed if the input does not match any region.\nDECLARE\n Region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; \n country_count number :&#x3D; 0; \nBEGIN \n IF upper(region) &#x3D; &#39;EUROPE&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 1; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Europe region.&#39;); \n ELSIF upper(region) &#x3D; &#39;AMERICAS&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 2; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Americas region.&#39;); \n ELSIF upper(region) &#x3D; &#39;ASIA&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 3; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Asia region.&#39;); \n ELSIF upper(region) &#x3D; &#39;MIDDLE EAST AND AFRICA&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 4; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Middle East and Africa region.&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); \n END IF; \nEND; \nSolution #2You can use the searched CASE statement to evaluate a boolean expression to determine which statements to execute among multiple, mutually exclusive conditions. The next example is a SQL*Plus script that performs the same tasks as Solution #1 but this time using a searched CASE statement:\nDECLARE\n region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; \n country_count number :&#x3D; 0; \nBEGIN \n CASE \n WHEN upper(region) &#x3D; &#39;EUROPE&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 1; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Europe region.&#39;); \n WHEN upper(region) &#x3D; &#39;AMERICAS&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 2; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Americas region.&#39;); \n WHEN upper(region) &#x3D; &#39;ASIA&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 3; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Asia region.&#39;); \n WHEN upper(region) &#x3D; &#39;MIDDLE EAST AND AFRICA&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 4; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Middle East and Africa region.&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); \n END CASE; \nEND; \n\nHow It WorksIF-ELSIF-ELSE can be used to evaluate any number of conditions. It functions such that if the firstcondition in the IF-ELSIF-ELSE statement evaluates to TRUE, then the statements within its block areexecuted, and all others are bypassed. Similarly, if the first condition evaluates to FALSE and the secondcondition evaluates to TRUE, then the second condition’s statements will be executed, others will beignored, and so on.\nCASE\n WHEN &lt;&lt;boolean_expression&gt;&gt; THEN &lt;&lt;statements&gt;&gt; \n[ELSE statements]; \n\n\n3.4 Driving from an Expression Having Multiple OutcomesProblemYou have a single expression that yields multiple outcomes. You are interested in evaluating the expression and performing a different set of statements depending upon the outcome.SolutionUse a CASE statement to evaluate your expression, and decide which set of statements to execute depending upon the outcome. In the following example, a SQL*Plus script accepts a region entry, which is being evaluated to determine the set of statements to be executed. Based upon the value of the region, the corresponding set of statements is executed, and once those statements have been executed, then the control is passed to the statement immediately following the CASE statement. \nDECLARE \n region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; \n country_count number :&#x3D; 0; \nBEGIN \n CASE upper(region) \n WHEN &#39;EUROPE&#39; THEN \n    SELECT count(*) \n    INTO country_count \n    FROM countries \n    WHERE region_id &#x3D; 1; \n    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Europe region.&#39;); \n WHEN &#39;AMERICAS&#39; THEN \n    SELECT count(*) \n    INTO country_count \n    FROM countries \n    WHERE region_id &#x3D; 2; \n    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; ||&#39;the Americas region.&#39;); \n WHEN &#39;ASIA&#39; THEN \n    SELECT count(*) \n    INTO country_count \n    FROM countries \n    WHERE region_id &#x3D; 3; \n    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Asia region.&#39;); \n WHEN &#39;MIDDLE EAST AND AFRICA&#39; THEN \n    SELECT count(*) \n    INTO country_count \n    FROM countries \n    WHERE region_id &#x3D; 4; \n    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Middle East and Africa region.&#39;); \n ELSE \n    DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); \n END CASE; \nEND; \n\n\nHow It WorksThere are two different types of CASE statements that can be used—those being the searched CASE and the simple CASE statement. The solution to this recipe demonstrates the simple CASE. For an example of a searched CASE statement, please see Recipe 3-3.\nThe simple CASE statement begins with the keyword CASE followed by a single expression called a selector. The selector is evaluated one time, and it can evaluate to any PL&#x2F;SQL type other than BLOB, BFILE, an object type, a record, or a collection type. The selector is followed by a series of WHEN clauses. The WHEN clauses are evaluated sequentially to determine whether the value of the selector equals the result from any of the WHEN clause expressions. If a match is found, then the corresponding WHEN clause is executed.\nThe CASE statement can include any number of WHEN clauses, and much like an IF statement, it can be followed with a trailing ELSE clause that will be executed if none of the WHEN expressions matches. If the ELSE clause is omitted, a predefined exception will be raised if the CASE statement does not match any of the WHEN clauses. The END CASE keywords end the statement.\n3.5. Looping Until a Specified Condition Is MetProblemYou want to loop through a set of statements until a specified condition evaluates to true.SolutionUse a simple LOOP statement along with an EXIT clause to define a condition that will end the iteration.The following example shows a simple LOOP that will print out each employee with a department_id equalto 90:\nDECLARE\nCURSOR emp_cur IS\nSELECT *\nFROM employees\nWHERE department_id &#x3D; 90;\nemp_rec employees%ROWTYPE;\n\nBEGIN\nOPEN emp_cur;\nLOOP\n  FETCH emp_cur into emp_rec;\n  IF emp_cur%FOUND THEN\n    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;-&#39;|| emp_rec.email);\n  ELSE\n    EXIT;\n  END IF;\nEND LOOP;\nCLOSE emp_cur;\nEND;\n\n\nAs you can see from the example, the cursor is opened prior to the start of the loop. Inside the loop,the cursor is fetched into emp_rec, and emp_rec is evaluated to see whether it contains anything using thecursor %FOUND attribute. If emp_cur%FOUND is FALSE, then the loop is exited using the EXIT keyword.How It WorksThe simple LOOP structure is very easy to use for generating a loop in your code. The LOOP keyword is usedto start the loop, and the END LOOP keywords are used to terminate it. Every simple loop must contain anEXIT or GOTO statement; otherwise, the loop will become infinite and run indefinitely.You can use a couple of different styles for the EXIT. When used alone, the EXIT keyword causes aloop to be terminated immediately, and control is passed to the first statement following the loop. Youcan use the EXIT-WHEN statement to terminate the loop based upon the evaluation of a condition after theWHEN statement. If the condition evaluates to TRUE, then the loop is terminated; otherwise, it willcontinue.The following example shows the same LOOP as the example in the solution, but instead of using anIF statement to evaluate the content of emp_rec, the EXIT-WHEN statement is used:\nDECLARE\nCURSOR emp_cur IS\nSELECT *\nFROM employees\nWHERE department_id &#x3D; 90;\nemp_rec employees%ROWTYPE;\nBEGIN\nOPEN emp_cur;\n LOOP \n FETCH emp_cur into emp_rec; \n EXIT WHEN emp_cur%NOTFOUND; \n      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39;-&#39; || emp_rec.email); \n END LOOP; \n CLOSE emp_cur; \nEND; \nYou can use a loop to iterate over any number of things including cursors or collections of data. Asyou will see in some of the coming recipes, different forms of loops work better in differentcircumstances. \n3.6. Iterating Cursor Results Until All Rows Have Been ReturnedProblemYou have created a cursor and retrieved a number of rows from the database. As a result, you want toloop through the results and do some processing on them.SolutionUse a standard FOR loop to iterate through the records. Within each iteration of the loop, process thecurrent record. The following code shows the use of a FOR loop to iterate through the records retrievedfrom the cursor and display each employee name and e-mail. Each iteration of the loop returns anemployee with the job_id of ‘ST_MAN’, and the loop will continue to execute until the cursor has beenexhausted.\nDECLARE \n CURSOR emp_cur IS \n SELECT * \n FROM employees \n WHERE job_id &#x3D; &#39;ST_MAN&#39;; \n emp_rec employees%ROWTYPE; \nBEGIN \n FOR emp_rec IN emp_cur LOOP \n DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || \n &#39; - &#39; || emp_rec.email); \n END LOOP; \nEND; \n\nHere are the results:Matthew Weiss - MWEISSAdam Fripp - AFRIPPPayam Kaufling - PKAUFLINShanta Vollman - SVOLLMANKevin Mourgos - KMOURGOSPL&#x2F;SQL procedure successfully completed\nAs you can see, the employee records that meet the specified criteria are displayed.\n3.7. Iterating Until a Condition Evaluates to FALSEProblemYou want to iterate over a series of statements until a specified condition no longer evaluates to TRUE.SolutionUse a WHILE statement to test the condition, and execute the series of statements if the conditionevaluates to TRUE; otherwise, skip the statements completely. The following example shows a WHILEstatement evaluating the current value of a variable and looping through until the value of the variablereaches ten. Within the loop, this variable is being multiplied by two and printing out its current value.\nDECLARE \n myValue NUMBER :&#x3D; 1; \nBEGIN \nWHILE myValue &lt; 10 LOOP \n DBMS_OUTPUT.PUT_LINE(&#39;The current value is: &#39; || myValue); \n myValue :&#x3D; myValue * 2; \n END LOOP;\nEND;\n\nHere are the results:The current value is: 1The current value is: 2The current value is: 4The current value is: 8PL&#x2F;SQL procedure successfully completed.The important thing to note in this example is that the value of myValue is increased with eachiteration of the loop as to eventually meet the condition specified in the WHILE loop.\nHow It WorksThe WHILE loop tests a condition at the top of the loop, and if it evaluates to TRUE, then the statements within the loop are executed, and control is returned to the start of the loop where the condition is tested again. If the condition does not evaluate to TRUE, the loop is bypassed, and control goes to the next statement after the END LOOP. If the condition never fails, then an infinite loop is formed, so it is important to ensure that the condition will eventually evaluate to FALSE. It is important to note that the statements in the loop will never be executed if the condition evaluates to FALSE during the first pass. This situation is different from the simple loop that alwaysiterates at least once because the EXIT condition is usually evaluated elsewhere in the loop. To ensure that a WHILE loop is always executed at least one time, you must ensure that the condition evaluates to TRUE at least once. One way to do this is to use a flag variable that is evaluated with each iteration of the loop. Set the flag equal to FALSE prior to starting the loop, and then set it to TRUE when a certain condition is met inside the loop. The following pseudocode depicts such a solution:\nBEGIN \n flag &#x3D; FALSE; \n WHILE flag &#x3D; TRUE LOOP \nPerform statements \n flag &#x3D; Boolean expression; \n END LOOP; \nEND; \nAs mentioned previously, the boolean expression that is assigned to the flag in this case musteventually evaluate to FALSE; otherwise, an infinite loop will occur.\n3.8.Bypassing the Current Loop IterationProblemIf a specified conditional statement evaluates to TRUE, you want to terminate the current loop iteration ofthe loop early and start the next iteration immediately.SolutionUse a CONTINUE statement along with a condition to end the current iteration. In the following example, a loop is used to iterate through the records in the employees table. The primary reason for the loop is to print out a list of employees who receive a salary greater than 15,000. If an employee does not receive more than 15,000, then nothing is printed out, and the loop continues to the next iteration.\nDECLARE \n    CURSOR emp_cur is \n    SELECT * \n    FROM employees; \n    emp_rec emp_cur%ROWTYPE; \nBEGIN \n    DBMS_OUTPUT.PUT_LINE(&#39;Employees with salary &gt; 15000: &#39;); \nOPEN emp_cur;\n LOOP \n FETCH emp_cur INTO emp_rec; \n EXIT WHEN emp_cur%NOTFOUND; \n IF emp_rec.salary &lt; 15000 THEN \n CONTINUE;\n ELSE \n    DBMS_OUTPUT.PUT_LINE(&#39;Employee: &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name); \n END IF; \n END LOOP; \n CLOSE emp_cur; \nEND; \n\nHere are some sample results:Employees with salary &gt; 15000:Employee: Steven KingEmployee: Neena KochharEmployee: Lex De HaanPL&#x2F;SQL procedure successfully completed.How It WorksYou can use the CONTINUE statement in any loop to unconditionally halt execution of the current iterationof the loop and move to the next. As shown in the solution, the CONTINUE statement is usuallyencompassed within some conditional statement so that it is invoked only when that certain conditionis met. \nYou can use the CONTINUE statement along with a label in order to jump to a specified point in theprogram. Rather than merely using CONTINUE to bypass the current loop iteration, specifying a label willallow you to resume programming in an outer loop. For more information regarding the use of theCONTINUE statement along with labels in nested loops, please see Recipe 3-13.As an alternative to specifying CONTINUE from within an IF statement, you can choose to write aCONTINUE WHEN statement. For example, the following two approaches yield identical results: \n IF team_rec.total_points &lt; 10 THEN \n CONTINUE; \nor \n CONTINUE WHEN rec.total_points &lt; 10; \n\nUsing the CONTINUE WHEN format, the loop will stop its current iteration if the condition in the WHENclause is met. Otherwise, the iteration will ignore the statement altogether.\n3.9. Iterating a Fixed Number of TimesProblemYou are interested in executing the contents of a loop a specified number of times. For example, you areinterested in executing a loop ten times, and you need to number each line of output in the range by thecurrent loop index.SolutionWrite a FOR loop. Use a variable to store the current index of the loop while looping through a range ofnumbers from one to ten in ascending order. The following lines of code will iterate ten times through aloop and print out the current index in each pass:\nBEGIN \n FOR idx IN 1..10 LOOP \n DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx); \n END LOOP; \nEND;\nHere is the result: \nThe current index is: 1 \nThe current index is: 2 \nThe current index is: 3 \nThe current index is: 4 \nThe current index is: 5 \nThe current index is: 6 \nThe current index is: 7 \nThe current index is: 8 \nThe current index is: 9\nThe current index is: 10\nPL&#x2F;SQL procedure successfully completed.How It WorksThe FOR loop will increment by one through the given range for each iteration until it reaches the end.The loop is opened using the keyword FOR, followed by a variable that will be used as the index for theloop. Following the index variable is the IN keyword, which is used to signify that the index variableshould increment one by one through the given range, which is listed after the IN keyword. The loop isterminated using the END LOOP keywords.Each statement contained within the loop is executed once for each iteration of the loop. The indexvariable can be used within the loop, but it cannot be changed. As shown in the solution, you may usethe index for printing purposes, and it is oftentimes used in calculations as well.The REVERSE keyword should be placed directly after the IN keyword and before the range that youspecify. The REVERSE keyword has no effect when working with cursors. If you need to iterate throughcursor results in a specific order, then specify an ORDER BY clause in your SELECT statement. \n3.11 Iterating in Increments Other Than One3-11. Iterating in Increments Other Than OneProblemRather than iterating through a range of numbers one at a time, you want to increment by some othervalue. For example, you might want to increment through even values such as 2, 4, 6, and so forth.SolutionMultiply the loop index by two (or by whatever other multiplier you need) to achieve the effect ofincrementing through all even numbers. As you can see in the following example, an even number isalways generated when the index is multiplied by two: \nBEGIN \n FOR idx IN 1..5 LOOP \n DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx*2); \n END LOOP; \nEND;\nHere is the result:The current index is: 2The current index is: 4The current index is: 6The current index is: 8The current index is: 10PL&#x2F;SQL procedure successfully completed.How It WorksUnlike some other languages, PL&#x2F;SQL does not include a STEP clause that can be used while looping. Towork around that limitation, you will need to write your own stepping algorithm. In the solution to thisrecipe, you can see that the algorithm was quite easy; you simply multiply the index by two to achievethe desired result. In this solution, assigning the range of 1..5 as the index produces the effect of iteratingthrough all even numbers from 2..10 when the current index is multiplied by two.Using similar techniques, you can increment through ranges of numbers in various intervals.However, sometimes this can become troublesome if you are attempting to step by anything other thaneven numbers. You can see an example of this in the next recipe.\n3.12. Stepping Through a Loop Based on Odd-Numbered IncrementsProblemRather than iterating through a range of numbers by even increments, you prefer to loop through therange using odd increments.SolutionUse the built-in MOD function to determine whether the current index is odd. If it is odd, then print outthe value; otherwise, continue to the next iteration. The following example shows how to implement thissolution:\nBEGIN \n FOR idx IN 1..10 LOOP \n IF MOD(idx,2) !&#x3D; 0 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx); \n END IF; \n END LOOP; \nEND; \n\nResults:The current index is: 1The current index is: 3The current index is: 5The current index is: 7The current index is: 9PL&#x2F;SQL procedure successfully completed.How It WorksThe solution depicts one possible workaround for a STEP replacement. Using the MOD function todetermine whether a number is odd works quite well. The MOD function, otherwise known as the modulusfunction, is used to return the remainder from the division of the two numbers that are passed into thefunction. Therefore, this function is useful for determining even or odd numbers. In this case, if anyvalue is returned from MOD, then the number is assumed to be odd, and the statements within the IFstatement will be executed.Such a technique may be useful in the case of iterating through a collection of data such as a table. Ifyou want to grab every other record from the collection, then performing a stepping solution such as thisor the solution from Recipe 3-11 will allow you to achieve the desired result. You could easily use theresulting index from this technique as the index for a collection.\n3.13. Exiting an Outer Loop PrematurelyProblemYour code contains a nested loop, and you want the inner loop to have the ability to exit from both loopsand stop iteration completely.SolutionUse loop labels for both loops and then reference either loop within an EXIT statement by following theEXIT keyword with a loop label. The following example prints out a series of numbers. During eachiteration, the inner loop will increment until it reaches an odd number. At that point, it will pass controlto the outer loop again. The outer loop will be exited when the index for the inner loop is greater than orequal to the number ten. \nBEGIN \n &lt;&lt;outer&gt;&gt; for idx1 in 1 .. 10 loop \n &lt;&lt;inner&gt;&gt; for idx2 in 1 .. 10 loop \n dbms_output.put(idx2); \n exit inner when idx2 &gt; idx1 * 2; \n exit outer when idx2 &#x3D; 10; \n END LOOP; \n DBMS_OUTPUT.NEW_LINE; \n END LOOP; \n DBMS_OUTPUT.NEW_LINE; \nEND;\nResults:12312345123456712345678912345678910PL&#x2F;SQL procedure successfully completed.How It WorksAny loop in PL&#x2F;SQL can be labeled using a similar style to labels for code blocks. The label can be anyvalid identifier surrounded by angle brackets before the loop, and optionally the identifier can be placedat the end after the END LOOP clause. The result of such a labeling mechanism is that you will have adistinct start and end to the loops and more control over loop execution.In the solution to this recipe, the label helps identify the outer loop so that it can be terminated withthe EXIT clause. Without a label, the EXIT will terminate the innermost FOR loop. However, the label canalso be used to help identify the loop’s index. In the solution, this is not necessary because the outer loopindex was named differently than the inner loop index. If both indexes were named the same, then youcould use the loop label along with the index name to fully qualify the index. The following exampledemonstrates this technique:\nBEGIN\n&lt;&lt;outer&gt;&gt; FOR idx IN 1 .. 10 LOOP\n&lt;&lt;inner&gt;&gt; FOR idx IN 1 .. 10 LOOP\n  DBMS_OUTPUT.PUT(inner.idx);\nEXIT inner WHEN inner.idx &gt; outer.idx * 2;\nEXIT outer WHEN inner.idx &#x3D; 10;\nEND LOOP;\n  DBMS_OUTPUT.NEW_LINE;\nEND LOOP;\n  DBMS_OUTPUT.NEW_LINE;\nEND;\n\nThis code will display the same results as the example given in the solution to this recipe. The onlydifference is that in this example the index name is the same in both the inner and outer loops. Analternative technique to end the current iteration of an inner loop is to use the CONTINUE statement. ACONTINUE statement can reference the label of a loop that is within the same scope. Therefore, an innerloop can exit its current iteration and proceed to an outer loop, as the following example demonstrates:\n\nBEGIN\n&lt;&lt;outer&gt;&gt; for idx1 in 1 .. 10 loop\n&lt;&lt;inner&gt;&gt; for idx2 in 1 .. 10 loop\ndbms_output.put(idx2);\nexit inner when idx2 &gt; idx1 * 2;\nexit outer when idx2 &#x3D; 10;\nEND LOOP;\nCONTINUE outer;\nEND LOOP;\nDBMS_OUTPUT.NEW_LINE;\nEND;\nIn this example, the same code that is used in the solution to this recipe is rewritten to incorporate aCONTINUE statement. This statement is used to move control of execution back to the outer loop. Whenthe CONTINUE statement is reached, execution of the current loop is immediately halted, and processingcontinues to the loop designated by the label.\n3.14. Jumping to a Designated Location in CodeProblemYou want your code to stop executing and jump to a different, designated location.SolutionUse a GOTO statement along with a label name to cause code execution to jump into the position wherethe label is located.The following example shows the GOTO statement in action. The user is prompted to enter a numericvalue, and that value is then evaluated to determine whether it is greater than ten. In either case, amessage is printed, and then the code jumps to the end_msg label. If the number entered is a negativenumber, then the code jumps to the bad_input label where an error message is printed.\nDECLARE\n in_number number :&#x3D; 0; \nBEGIN \n in_number :&#x3D; &#39;&amp;input_number&#39;; \n IF in_number &gt; 10 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The number you entered is greater than ten&#39;); \n GOTO end_msg; \n ELSIF in_number &lt;&#x3D; 10 and in_number &gt; 0 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The number you entered is less than or equal to ten&#39;); \n GOTO end_msg; \n ELSE \n -- Entered a negative number \n GOTO bad_input; \n END IF; \n &lt;&lt; bad_input &gt;&gt; \n DBMS_OUTPUT.PUT_LINE(&#39;Invalid input. No negatives allowed.&#39;); \n &lt;&lt; end_msg &gt;&gt; \n DBMS_OUTPUT.PUT_LINE(&#39;Thank you for playing..&#39;); \nEND; \nHow It WorksThe GOTO statement is used to branch code unconditionally. Code can be branched to any label withinthe same scope as the GOTO. In the solution, the GOTO statement causes the code to branch to a parentcode block. You could just as easily branch to a loop within the current or outer block. However, youcannot branch to a label within a subblock, IF statement, or LOOP. \nYou should use this statement sparingly because arbitrary branching makes code difficult to read. Useconditional statements to branch whenever possible, because that’s why they were put into thelanguage. As you can see from the solution, the same code could have been written printing the “Invalidnumber” message within the ELSE clause. There are usually better alternatives to using GOTO. \n4. Functions, Packages,and ProceduresPL&#x2F;SQL applications are composed of functions, procedures, and packages. Functions are PL&#x2F;SQLprograms that accept zero or more parameters and always return a result. Procedures are similar tofunctions, but they are not required to return a result. Packages are a combination of related functions,procedures, types, and variables. Each of these PL&#x2F;SQL components helps formulate the basis for smalland large applications alike. They differ from anonymous blocks that have been covered in previousrecipes because they are all named routines that are stored within the database. Together, they providethe advantage of reusable code that can be called from any schema in the database to which you’vegranted the appropriate access.Let’s say you have a few lines of code that perform some calculations on a number and return aresult. Will these calculations help you anywhere else? If so, then you should probably encapsulate thiscode in a function. Maybe you have a nightly script that you use as a batch job to load and execute.Perhaps this script can be turned into a stored procedure and Oracle Scheduler can kick it off each night.What about tasks that use more than one procedure or function? Can these be combined at all? APL&#x2F;SQL package would probably be a good choice in this case. After reading through the recipes in thischapter, you should be able to answer these questions at the drop of a hat.■ Note We mention job scheduling in our introduction to this chapter. However, we actually address that topic inChapter 11, which is an entire chapter dedicated to running PL&#x2F;SQL jobs, whether for application purposes or fordatabase maintenance. \n4-1. Creating a Stored FunctionProblemOne of your programs is using a few lines of code repeatedly for performing a calculation. Rather thanusing the same lines of code numerous times throughout your application, it makes more sense toencapsulate(美[ɪn’kæpsjə’let]vt.压缩;将…装入胶囊) the functionality into a common routine that can be called and reused time and time again.SolutionCreate a stored function to encapsulate your code, and save it into the database. Once stored in thedatabase, any user with execution privileges can invoke the function. Let’s take a look at a function togive you an idea of how they work.In this example, the function is used to round a given number to the nearest quarter. This functionworks well for accepting a decimal value for labor hours and rounding to the nearest quarter hour. \n-- at return part and no paramter name just a type\nCREATE OR REPLACE FUNCTION CALC_QUARTER_HOUR(HOURS IN NUMBER) RETURN NUMBER AS  \n  CALCULATED_HOURS NUMBER :&#x3D; 0; \nBEGIN \n  \n   -- if HOURS is greater than one, then calculate the decimal portion \n   -- based upon quarterly hours  \n IF HOURS &gt; 1 THEN \n  -- calculate the modulus of the HOURS variable and compare it to • \n  -- fractional values \n    IF MOD(HOURS, 1) &lt;&#x3D;.125 THEN \n       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1); \n    ELSIF MOD(HOURS, 1) &gt; .125 AND MOD(HOURS,1) &lt;&#x3D; .375 THEN \n       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.25,1); \n    ELSIF MOD(HOURS, 1) &gt; .375 AND MOD(HOURS,1) &lt;&#x3D; .625 THEN \n       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.50,1); \n    ELSIF MOD(HOURS, 1) &gt; .63 AND MOD(HOURS,1) &lt;&#x3D; .825 THEN \n       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.75,1); \n    ELSE \n       CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); \n       \n    END IF; \n     \n  ELSE \n    -- if HOURS is less than one, then calculate the entire value• \n    -- based upon quarterly hours \n    IF HOURS &gt; 0 AND HOURS &lt;&#x3D;.375 THEN \n        CALCULATED_HOURS :&#x3D; .25; \n    ELSIF HOURS &gt; .375 AND HOURS &lt;&#x3D; .625 THEN \n        CALCULATED_HOURS :&#x3D; .5; \n    ELSIF HOURS &gt; .625 AND HOURS &lt;&#x3D; .825 THEN \n        CALCULATED_HOURS :&#x3D; .75; \n    ELSE \n        CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); \n    END IF; \n     \n  END IF; \n   \n  RETURN CALCULATED_HOURS; \n   \nEND CALC_QUARTER_HOUR; \nThis function accepts one value as input, a decimal value representing a number of hours worked.The function then checks to see whether the value is greater than one, and if so, it performs a series ofmanipulations to round the value to the nearest quarter hour. If the value is not greater than one, thenthe function rounds the given fraction to the nearest quarter.■ Note See Recipe 4-2 for an example showing the execution of this function. \nHow It WorksA function is a named body of code that is stored within the database and returns a value. Functions areoften used to encapsulate logic so that it can be reused. A function can accept zero or more parametersand always returns a value. A function is comprised of a header, an execution section containingstatements, and an optional exception block.For example, the header for our solution function is as follows:  \nCREATE OR REPLACE FUNCTION CALC_QUARTER_HOUR(HOURS IN NUMBER) RETURN NUMBER AS  \nThe OR REPLACE clause is optional, but in practice it is something you’ll most always want. SpecifyingOR REPLACE will replace a function that is already under the same name in the same schema. (A functionname must be unique within its schema.)Functions can take zero or more parameters, which can be any datatype including collections. Youwill learn more about collections in Chapter 10. Our example function takes one parameter, a NUMBERrepresenting some number of hours.The parameters that can be passed to a function can be declared in three different ways, namely, asIN, OUT, and IN OUT. The difference between these three declaration types is that parameters declared asIN are basically read-only, OUT parameters are write-only, and IN OUT parameters are read-write. Thevalue of an OUT parameter is initially NULL but can contain a value after the function has returned.Similarly, the value of an IN OUT can be modified within the function, but IN parameters cannot.■ Note Typically you want only IN parameters for a function. If you find yourself creating a function with OUT or INOUT parameters, then reconsider and think about creating a stored procedure instead. This is not a hard-and-fastrequirement, but it is generally good practice for a function to return only one value.The declaration section of the function begins directly after the header, and unlike the anonymousblock, you do not include the DECLARE keyword at the top of this section. Just like the anonymous block,the declaration section is where you will declare any variables, types, or cursors for your function. Ourdeclaration section defines a single variable: CALCULATED_HOURS NUMBER :&#x3D; 0; Following the declaration is the executable section, which is laid out exactly like that of ananonymous block. The only difference with a function is that it always includes a RETURN statement. Itcan return a value of any datatype as long as it is the same datatype specified in the RETURN clause of theheader.Following the return clause can be an optional EXCEPTION block to handle any errors that wereencountered in the function. The following example is the same function that was demonstrated in thesolution to this recipe, except that it has an added EXCEPTION block. \nCREATE OR REPLACE FUNCTION CALC_QUARTER_HOUR(HOURS IN NUMBER) \n RETURN NUMBER AS  \n  CALCULATED_HOURS NUMBER :&#x3D; 0; \nBEGIN \n  \n   -- if HOURS is greater than one, then calculate the decimal portion \n \n  -- based upon quarterly hours  \n IF HOURS &gt; 1 THEN \n  -- calculate the modulus of the HOURS variable and compare it to  \n \n  -- fractional values \n    IF MOD(HOURS, 1) &lt;&#x3D;.125 THEN \n       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1); \n    ELSIF MOD(HOURS, 1) &gt; .125 AND MOD(HOURS,1) &lt;&#x3D; .375 THEN \n       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.25,1); \n    ELSIF MOD(HOURS, 1) &gt; .375 AND MOD(HOURS,1) &lt;&#x3D; .625 THEN \n       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.50,1); \n    ELSIF MOD(HOURS, 1) &gt; .63 AND MOD(HOURS,1) &lt;&#x3D; .825 THEN \n       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.75,1); \n    ELSE \n       CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); \n       \n    END IF; \n     \n  ELSE \n    -- if HOURS is less than one, then calculate the entire value \n \n    -- based upon quarterly hours \n    IF HOURS &gt; 0 AND HOURS &lt;&#x3D;.375 THEN \n        CALCULATED_HOURS :&#x3D; .25; \n    ELSIF HOURS &gt; .375 AND HOURS &lt;&#x3D; .625 THEN \n        CALCULATED_HOURS :&#x3D; .5; \n    ELSIF HOURS &gt; .625 AND HOURS &lt;&#x3D; .825 THEN \n        CALCULATED_HOURS :&#x3D; .75; \n    ELSE \n        CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); \n    END IF; \n     \n  END IF; \n   \n  RETURN CALCULATED_HOURS; \n \nEXCEPTION \n  WHEN VALUE_ERROR THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;VALUE ERROR RAISED, TRY AGAIN&#39;); \n    RETURN -1; \n  WHEN OTHERS THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;UNK ERROR RAISED, TRY AGAIN&#39;); \n    RETURN -1; \nEND CALC_QUARTER_HOUR; \nAgain, don’t fret if you are unfamiliar with how to handle exceptions, because they will be discussedin detail later in the book. At this point, it is important to know that you have the ability to declareexceptions that can be caught by code so that your program can process abnormalities or errorsaccordingly.Functions are important not only for encapsulation but also for reuse. As a matter of fact, thefunction defined within the solution uses other built-in PL&#x2F;SQL functions within them. There are entirelibraries that consist of functions that are helpful for performing various transactions. Functions are afundamental part of PL&#x2F;SQL programming, just as they are in any other language. It is up to you toensure that your database is stocked with plenty of useful functions that can be used in your current andfuture applications. \n4-2. Executing a Stored Function from a QueryProblemYou want to invoke a function from an SQL query. For example, you want to take the quarter-hourrounding function from Recipe 4-1 and invoke it on hourly values in a database table.SolutionWrite a query and invoke the function on values returned by the SELECT statement. In the following lines,the function that was written in the previous recipe will be called. The results of calling the function fromwithin a query are as follows: \nSQL&gt; select calc_quarter_hour(.17) from dual; \n \nCALC_QUARTER_HOUR(.17) \n---------------------- \n  .25 \n \nSQL&gt; select calc_quarter_hour(1.3) from dual; \n \nCALC_QUARTER_HOUR(1.3) \n---------------------- \n 1.25 \nHow It WorksThere are a few ways in which a function can be called, one of which is via a query. A function can beexecuted inline via a SELECT statement, as was the case with the solution to this recipe. A function canalso be executed by assigning it to a variable within an anonymous block or another function&#x2F;procedure.Since all functions return a value, this works quite well. For instance, the following QTR_HOUR variable canbe assigned the value that is returned from the function: \nDECLARE \n  qtr_hour          NUMBER; \nBEGIN \n  qtr_hour :&#x3D; calc_quarter_hour(1.3); \n  DBMS_OUTPUT.PUT_LINE(qtr_hour); \nEND; \n \nYou can also execute a function as part of an expression. In the following statement, you can see \nthat TOTAL_HOURS is calculated by adding the bill total to the value returned from the function: \n \nDECLARE \n  total_hours           NUMBER; \n  hours                 NUMBER :&#x3D; 8; \nBEGIN \n  total_hours :&#x3D; hours + calc_quarter_hour(3.2); \n  DBMS_OUTPUT.PUT_LINE(total_hours); \nEND; \nThe way in which your program calls a function depends on its needs. If you need to simply returnsome results from the database and apply a function to each of the results, then use a query. You mayhave an application that needs to pass a value to a function and use the result at some later point, inwhich case assigning the function to a variable would be a good choice for this case. Whatever the casemay be, functions provide convenient calling mechanisms to cover most use cases. \n4-3. Optimizing a Function That Will Always Return the Same Result for a Given InputProblemYou want to create a function that will return the same result whenever a given input, or set of inputs, ispresented to it. You want the database to optimize based upon that deterministic nature.SolutionSpecify the DETERMINISTIC keyword when creating the function to indicate that the function will alwaysreturn the same result for a given input. For instance, you want to return a specific manager name basedupon a given manager ID. Furthermore, you want to optimize for the fact that any given input willalways return the same result. The following example demonstrates a function that does so by specifyingthe DETERMINISTIC keyword:  \nCREATE OR REPLACE FUNCTION manager_name(mgr_id IN NUMBER) \nRETURN VARCHAR2 \nDETERMINISTIC IS \n  first_name     employees.first_name%TYPE; \n  last_name      employees.last_name%TYPE; \nBEGIN \n  IF mgr_id IS NOT NULL THEN \n    SELECT first_name, last_name \n    INTO first_name, last_name \n    FROM EMPLOYEES \n    WHERE employee_id &#x3D; mgr_id; \n \n    RETURN first_name || &#39; &#39; || last_name; \n  ELSE \n    RETURN &#39;N&#x2F;A&#39;; \n  END IF; \nEXCEPTION \n  WHEN NO_DATA_FOUND THEN \n    RETURN &#39;N&#x2F;A&#39;; \nEND; \nThis function will return the manager name for a matching EMPLOYEE_ID. If there are no matches forthe EMPLOYEE_ID found, then N&#x2F;A will be returned.How It WorksA deterministic function is one that always returns the same resulting value as long as the parametersthat are passed in are the same. This type of function can be useful for improving performance. Thefunction will be executed only once for any given set of parameters. This means that if the sameparameters are passed to this function in subsequent calls, then the function will be bypassed and returnthe cached value from the last execution using those parameters. This can really help in cases wherecalculations are being performed and repeated calls to the function may take a toll on performance.The DETERMINISTIC clause is required in a couple of cases. In the event that you are calling a functionin an expression of a function-based index, you need to write the function as DETERMINISTIC, or you willreceive errors. Similarly, a function must be made DETERMINISTIC if it is being called in an expression of amaterialized view query or if the view is marked as ENABLE QUERY REWRITE or REFRESH FAST. \n4-4. Creating a Stored ProcedureProblem\nThere is a database task that you are performing on a regular basis. Rather than executing a script thatcontains lines of PL&#x2F;SQL code each time you execute the task, you want to store the code in the databaseso that you can simply execute the task by name or so that you can schedule it to execute routinely viaOracle Scheduler. \n■ Note See Chapter 11 for information on scheduling PL&#x2F;SQL jobs using Oracle Scheduler. \nSolutionPlace the code that is used to perform your task within a stored procedure. The following examplecreates a procedure named INCREASE_WAGE to update the employee table by giving a designatedemployee a pay increase. Of course, you will need to execute this procedure for each eligible employeein your department. Storing the code in a procedure makes the task easier to perform. \nCREATE OR REPLACE PROCEDURE INCREASE_WAGE (empno_in IN NUMBER, \n                                           pct_increase IN NUMBER, \n                                           upper_bound IN NUMBER) AS \n  emp_count    NUMBER :&#x3D; 0; \n  emp_sal      employees.salary%TYPE; \n   \n  Results   VARCHAR2(50); \n  \nBEGIN \n    SELECT salary \n    INTO emp_sal \n    FROM employees \n    WHERE employee_id &#x3D; empno_in; \n     \n    IF emp_sal &lt; upper_bound \n    AND round(emp_sal + (emp_sal * pct_increase), 2) &lt; upper_bound THEN \n     \n        UPDATE employees \n        SET salary &#x3D; round(salary + (salary * pct_increase),2) \n        WHERE employee_id &#x3D; empno_in; \n         \n        results :&#x3D; &#39;SUCCESSFUL INCREASE&#39;; \n    ELSE \n        results :&#x3D; &#39;EMPLOYEE MAKES TOO MUCH, DECREASE RAISE PERCENTAGE&#39;; \n    END IF; \n     \n  DBMS_OUTPUT.PUT_LINE(results);\nEXCEPTION \n  WHEN NO_DATA_FOUND THEN \n    RAISE_APPLICATION_ERROR(-20001, &#39;No employee match for the given ID&#39;);\nEND; \nThe following are the results from executing the procedure for employee number 198. In the\nexample, the employee is being given a 3 percent increase and an upper bound of $5,000. \nBEGIN \n  increase_wage(198,.03,5000);\nEND; \nSUCCESSFUL INCREASEStatement processed. \nHow It WorksIn the example, the procedure accepts three parameters: the employee number, the percent of increasethey will receive, and an upper salary bound. You can then invoke the procedure by name, passing in therequired parameters.The procedure first searches the database for the provided employee number. If a record for thatemployee is found, then the employee record is queried for the current salary. If the salary is less thanthe upper bound and the resulting new salary will still be less than the upper bound, then the increasewill be applied via an UPDATE statement. If the employee is not found, then an alert message will bedisplayed. As you can see, this procedure can be called for any individual employee, and it will increasetheir wage accordingly as long as the increase stays within the bound.Stored procedures can be used to encapsulate functionality and store code in the database datadictionary. Much like a function, they can accept zero or more values as parameters, includingcollections. A stored procedure is structured in much the same way as a function in that it includes aheader, an executable section, and an optional exception-handling block. However, a procedure cannotinclude a RETURN clause in the header, and it does not return a value.For example, in the solution to this recipe, the procedure contains the following header: \nCREATE OR REPLACE PROCEDURE INCREASE_WAGE (empno_in IN NUMBER, \n                                           pct_increase IN NUMBER, \n                                           upper_bound IN NUMBER) AS \nThe header uses the OR REPLACE clause to indicate that this procedure should replace any procedurewith the same name that already exists. The procedure accepts three parameters, and although all ofthem are NUMBER type, any datatype can be accepted as a parameter. The declaration section comes afterthe header, and any cursors, variables, or exceptions that need to be declared should be taken care of inthat section. Next, the actual work that the procedure will do takes place between the BEGIN and ENDkeywords. Note that the header does not contain a RETURNS clause since procedures cannot return anyvalues.The advantage of using procedures is that code can be encapsulated into a callable named routinein the data dictionary and can be called by many users. To create a procedure in your schema, you musthave the CREATE PROCEDURE system privilege. You can create a stored procedure in another schema if youhave the CREATE ANY PROCEDURE system privilege. \n4-5. Executing a Stored ProcedureProblemYou want to execute a stored procedure from SQL*Plus. \nSolutionOpen SQL*Plus, and connect to the database schema that contains the procedure you are interested inexecuting. Execute the procedure by issuing the following command: \nEXEC procedure_name([param1, param2,...]); \n\nFor instance, to execute the procedure that was created in Recipe 4-3, you would issue the followingcommand:\nEXEC increase_wage(198, .03, 5000); \n\nThis would invoke the INCREASE_WAGE procedure, passing three parameters: EMPLOYEE_ID, apercentage of increase, and an upper salary bound.\nYou can also execute a stored procedure by creating a simple anonymous block that contains theprocedure call, as depicted(vt.描述,描画) in the following code:\nBEGIN \n  procedure_name([param1, param2,…]); \nEND; \n\nUsing this technique, invoking the stored procedure that was created in Recipe 4-3 would resemblethe following: \nBEGIN \n  increase_wage(198,.03,5000); \nEND; \n\nBoth techniques work equally well, but the latter would be better to use if you wanted to executemore than one procedure or follow up with more PL&#x2F;SQL statements. If you are running a singleprocedure from SQL*Plus, then using EXEC is certainly a good choice. \nHow It Works\nA stored procedure can be executed using the EXEC keyword. You can also type EXECUTE entirely. Both thelong and shortened versions will work.  \nIt is also possible to execute a procedure that is contained within other schemas, if the current userhas execute privileges on that procedure. In such a scenario, use dot notation to qualify the procedurename. Here’s an example: \nEXEC different_schema.increase_wage(emp_rec.employee_id, pct_increase, upper_bound); \n\n■ Note To learn more about privileges regarding stored programs, please take a look at Recipe 4-11.A procedure can also be invoked from within another procedure by simply typing the name andplacing the parameters inside parentheses, if there are any. For instance, the following lines of codedemonstrate calling a procedure from within another procedure. The procedure in this example invokesthe procedure that was shown in Recipe 4-3. \nCREATE OR REPLACE PROCEDURE grant_raises (pct_increase IN NUMBER, \n                                          upper_bound IN NUMBER) as \n  CURSOR emp_cur is \n  SELECT employee_id, first_name, last_name \n  FROM employees; \nBEGIN \n  -- loop through each record in the employees table \n  FOR emp_rec IN emp_cur LOOP\n      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name);\n      -- inside A invoke B procedure\n      increase_wage(emp_rec.employee_id, pct_increase, upper_bound); \n  END LOOP; \nEND;  \n\nThe procedure GRANT_RAISES applies an increase across the board to all employees. It loops throughall employee records, and the INCREASE_WAGE procedure is called with each iteration. The procedure iscalled without the use of the EXEC keyword since it is being invoked by another procedure rather thandirectly from the SQL*Plus command line.\nsummary\n\nexecute procedure by EXEC statement directly\nusing anonymous code block within procedure name\ninside A procedure invoke B procedure\n\n4-6. Creating Functions Within a Procedure or Code BlockProblem\nYou want to create some functions within a stored procedure. You want the functions to be local to theprocedure, available only from the procedure’s code block.\nSolutionCreate a stored procedure, and then create functions within the declaration section. The internalfunctions will accept parameters and return values just as an ordinary(adj.普通的,平凡) stored function would, except that the scope of the functions will be constrained to the outer code block or to the procedure. The procedurethat is demonstrated in this solution embodies two functions. One of the functions is used to calculatethe federal tax for an employee paycheck, while the other calculates the state tax. \nCREATE OR REPLACE PROCEDURE calc_employee_paycheck(emp_id IN NUMBER) as \n  emp_rec          employees%ROWTYPE; \n  paycheck_total   NUMBER; \n \n-- function for state tax \n  FUNCTION calc_state (sal IN NUMBER)  \n    RETURN NUMBER IS \n  BEGIN \n    RETURN sal *  .08; \n  END; \n\n-- function for federal tax \n FUNCTION calc_federal (sal IN NUMBER)  \n    RETURN NUMBER IS \n  BEGIN \n    RETURN sal *  .12; \n  END; \n \nBEGIN \n  DBMS_OUTPUT.PUT_LINE(&#39;Calculating paycheck with taxes&#39;); \n  SELECT * \n  INTO emp_rec \n  FROM employees \n  WHERE employee_id &#x3D; emp_id; \n \n  paycheck_total :&#x3D; emp_rec.salary - calc_state(emp_rec.salary) - \n                    calc_federal(emp_rec.salary); \n \n DBMS_OUTPUT.PUT_LINE(&#39;The paycheck total for &#39; || emp_rec.last_name || \n    &#39; is &#39; || paycheck_total); \nCHAPTER 4  FUNCTIONS, PACKAGES, AND PROCEDURES \n74 \nEXCEPTION \n  WHEN NO_DATA_FOUND THEN \n    RAISE_APPLICATION_ERROR(-20001, \n    &#39;No matching employee for the given ID&#39;); \nEND;\n\nHow It Works\nFunctions and procedures too can be contained within other bodies of code. Creating a functionwithin a declaration section will make the function accessible to the block that contains it. Thedeclaration of the function is the same as when you are creating a stored function, with the exception ofthe CREATE OR REPLACE keywords. Any variables that are declared inside the function will be accessibleonly to that function, not to the containing object.Creating a function or procedure inside a PL&#x2F;SQL code block can be useful when you want to makea function that is only to be used by the containing object. However, if you find that the body of theembedded function may change frequently, then coding a separate stored function may prove to bemore efficient.\n4-7. Passing Parameters by NameProblem\nYou have a procedure in your database that accepts a large number of parameters. When calling theprocedure, you would rather not worry that the positioning of the parameters is correct. \nSolution\nRather than trying to pass all the parameters to the procedure in the correct order, you can pass them byname. The code in this solution calls a procedure that accepts six parameters, and it passes theparameters by name rather than in order.Procedure Declaration: \nPROCEDURE process_emp_paycheck(EMP_ID IN NUMBER, \n   PAY_CODE IN NUMBER, \n   SICK_USED IN NUMBER, \n   VACATION_USED IN NUMBER, \n   FEDERAL_TAX IN NUMBER, \n   STATE_TAX IN NUMBER); \nProcedure Execution: \nEXEC process_emp_paycheck(EMP_ID&#x3D;&gt;10, \n   PAY_CODE&#x3D;&gt;10, \n   VACATION_USED&#x3D;&gt;8.0, \n   SICK_USED&#x3D;&gt;8.0, \n   STATE_TAX&#x3D;&gt;.06, \n   FEDERAL_TAX&#x3D;&gt;.08); \nAs you can see, by passing the parameters by name, they do not need to follow the same positionalordering as they do within the declaration of the procedure.\nHow It WorksTo pass a parameter by name, you list the parameter name followed by an arrow (consisting of an equalsign and a greater-than symbol) pointing to the value you are passing. The following pseudocode depictsthis technique:\nprocedure_name(parameter&#x3D;&gt;value); \n\nAlthough it can be more verbose to use named parameters, passing parameters by name can be veryhandy when there are several parameters to pass because you do not need to worry about passing themin the correct order. It is also helpful because it increases readability.Both procedures and functions can accept positional and named parameters. Neither notation issuperior to the other, so which one you choose to use is completely dependant upon the procedure orfunction that is currently being called. However, named parameters are a safe choice if trying tomaintain consistency with procedure calls throughout your application or your organization.Although not recommended, you can use both positional and named notation when passingparameters within the same call. When doing so, you need to place the parameters that you want to passusing positional notation first, followed by the parameters that you want to pass using named notation.The following execution illustrates using both positional and named notation while passing parametersto the PROCESS_EMP_PAYCHECK procedure: \nEXEC process_emp_paycheck(198, 10, 0, \n   SICK_USED&#x3D;&gt;4.0, \n   STATE_TAX&#x3D;&gt;.05, \n   FEDERAL_TAX&#x3D;&gt; .04); \n\nThis particular call passed both of the first parameters by position, those being EMP_ID and PAY_CODE.The last three parameters are passed by named notation. \nsummary :  \n\nif you specify parameter name , then would ignore order of you define parameter\n\n4-8. Setting Default Parameter ValuesProblemYou want to create a procedure that accepts several parameters. However, some of those parametersshould be made optional and contain default values.  \nSolutionYou can allow the procedure caller to omit the parameters if default values are declared for the variableswithin the procedure. The following example shows a procedure declaration that contains defaultvalues: \nPROCEDURE process_emp_paycheck(EMP_ID IN NUMBER, \n   PAY_CODE IN NUMBER, \n   SICK_USED IN NUMBER, \n   VACATION_USED IN NUMBER, \n   FEDERAL_TAX IN NUMBER DEFAULT .08,  -- could ignore value\n   STATE_TAX IN NUMBER DEFAULT .035);  -- could ignore value\n\nAnd here is an example execution: \nEXEC process_emp_paycheck(EMP_ID&#x3D;&gt;10, \n                           PAY_CODE&#x3D;&gt;10, \n                           VACATION_USED&#x3D;&gt;8.0, \n                           SICK_USED&#x3D;&gt;8.0); \n\nSince the procedure contains default values, the parameters can be omitted when the procedure iscalled. \nHow It WorksThe ability to provide a default value for a variable declaration is optional. To do so, you must providethe declaration of the variable with the keyword DEFAULT followed by the value, as shown in the solutionto this recipe. If a default value is declared, then you needn’t specify a value for the parameter when thefunction or procedure is called. If you do specify a value for a parameter that has a default value, thespecified value overrides the default.\n4-9. Collecting Related Routines into a Single UnitProblemYou have a number of procedures and functions that formulate(vt.规划;用公式表示) an entire application when usedtogether. Rather than defining each subprogram individually, you prefer to combine all of them into asingle, logically related entity.  \nSolutionCreate a PL&#x2F;SQL package that in turn declares(vt.宣布,声明) and defines each of the procedures together as anorganized entity. You declare each of the subprograms in the package specification (otherwise known asa header) and define them in the package body.The following example shows the creation of a PL&#x2F;SQL package containing two procedures and avariable.\nFirst, you create the package specification: \nCREATE OR REPLACE PACKAGE process_employee_time IS  \n  total_employee_salary  NUMBER; -- global variable inside \n  PROCEDURE grant_raises(pct_increase IN NUMBER, \n                                              upper_bound IN NUMBER); \n  PROCEDURE increase_wage (empno_in IN NUMBER, \n                           pct_increase IN NUMBER, \n                           upper_bound IN NUMBER) ; \nEND; \nThe specification lists the procedures, functions, and variables that you want to be visible fromoutside the package. Think of the specification as the external interface to your package.Next, create the package body: \nCREATE OR REPLACE PACKAGE BODY process_employee_time IS \n\n  PROCEDURE grant_raises (pct_increase IN NUMBER, \n                          upper_bound IN NUMBER) as \n  CURSOR emp_cur is \n  SELECT employee_id, first_name, last_name \n  FROM employees; \nBEGIN\n  -- loop through each record in the employees table \n  FOR emp_rec IN emp_cur LOOP \n      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name); \n      increase_wage(emp_rec.employee_id, pct_increase, upper_bound); \n  END LOOP; \nEND;  \n\n PROCEDURE INCREASE_WAGE (empno_in IN NUMBER, \n                          pct_increase IN NUMBER, \n                          upper_bound IN NUMBER) AS \n  emp_count    NUMBER :&#x3D; 0; \n  emp_sal      employees.salary%TYPE; \n   \n  Results   VARCHAR2(50); \n   \nBEGIN \n \n  SELECT count(*) \n  INTO emp_count \n  FROM employees \n  WHERE employee_id &#x3D; empno_in; \n  \n  IF emp_count &gt; 0 THEN \n    -- IF EMPLOYEE FOUND, THEN OBTAIN RECORD \n    SELECT salary \n    INTO emp_sal \n    FROM employees \n    WHERE employee_id &#x3D; empno_in; \n     \n    IF emp_sal &lt; upper_bound AND round(emp_sal + (emp_sal * pct_increase), 2) &lt; \n upper_bound THEN \n     \n        UPDATE employees \n        SET salary &#x3D; round(salary + (salary * pct_increase),2) \n        WHERE employee_id &#x3D; empno_in; \n         \n        results :&#x3D; &#39;SUCCESSFUL INCREASE&#39;; \n    ELSE \n        results :&#x3D; &#39;EMPLOYEE MAKES TOO MUCH, DECREASE RAISE PERCENTAGE&#39;; \n    END IF; \n     \n  ELSE \n    Results :&#x3D; &#39;NO EMPLOYEE FOUND&#39;; \n  END IF; \n \n  DBMS_OUTPUT.PUT_LINE(results); \n \n  END; \nEND; \n\nThe package in this example declares a global variable and two procedures within the packagespecification. The package body then defines both of the procedures and assigns a value to the variablethat was declared in the specification. Procedures defined within the package body are defined in thesame manner as they would be if they were stand-alone procedures. The difference is that now these twoprocedures are contained in a single package entity and are therefore related to each other and canshare variables declared globally within the package. \nHow It WorksA PL&#x2F;SQL package can be useful for organizing code into a single construct. Usually the code consists ofa grouping of variables, types, cursors, functions, and procedures that perform actions that are logicallyrelated to one another. Packages consist of a specification and a body, both of which are storedseparately in the data dictionary. The specification contains the declarations for each of the variables,types, subprograms, and so on, that are defined in the package. The body contains the implementationsfor each of the subprograms and cursors that are included in the specification, and it can also includeimplementations for other functions and procedures that are not in the specification. You’ll learn moreabout this in other recipes.\nMost packages contain both a specification and a body, and in these cases the specification acts asthe interface to the constructs implemented within the body. The items that are included in thespecification are available to the public and can be used outside the package. Not all packages contain abody. If there are only declarations of variables or constants in the package, then there is no need for abody to implement anything. Other PL&#x2F;SQL objects outside the package can reference any variables thatare declared in the specification. In other words, declaring a variable within a PL&#x2F;SQL packagespecification essentially creates a global variable.\n■ Note Global variables should be used wisely(adv.明智地;聪明地). The use of global variables can complicate matters when trackingdown problems or debugging your code. If global variables are used, then it can be hard to determine wherevalues have been set and where initialization of such variables occurs. Following the rules of encapsulation andusing local variables where possible can make your life easier.Procedures and functions defined within the package body may call each other, and they can bedefined in any order as long as they have been declared within the package specification. If any of theprocedures or functions have not been declared in the specification, then they must be defined in thepackage body prior to being called by any of the other procedures or functions.\nYou can change any implementations within a package body without recompiling the specification.This becomes very important when you have other objects in the database that depend on a particularpackage because it is probably not a good idea to change a package specification during normal businesshours when a package is in use by others. Doing so may result in unusable objects, and the packageusers could begin to see errors. However, if changes need to be made to the code within the packagebody, then you can change that code without affecting public-facing constructs of a package.Packages are one of the most important constructs that you can create in PL&#x2F;SQL. You will usepackages to combine common code objects for almost any significant application that you write. It ispossible to create entire applications without the use of a package, but doing so can create amaintenance nightmare because you will begin to see a pool of procedures and functions being createdwithin your database, and it will be difficult to remember which constructs are used for different tasks.Packages are especially handy when writing PL&#x2F;SQL web applications, and you will learn all about doingsummary:  \n\npackage differenates individual prodcdure is that pacakge could define global variable and shared each other\ncould including function not within specification\nthere are declarations of variables or constants, so no need to struct package body\n\n4-10. Writing Initialization Code for a PackageProblemYou want to execute some code each time a particular PL&#x2F;SQL package is instantiated in a session. \nSolutionCreate an initialization block for the package in question. By doing so, you will have the ability to executecode each time the package is initialized. The following example shows the same package that wasconstructed in Recipe 4-7. However, this time the package contains an initialization block. \nCREATE OR REPLACE PACKAGE BODY process_employee_time IS \n \n  PROCEDURE grant_raises (pct_increase IN NUMBER, \n                          upper_bound IN NUMBER) as \n  CURSOR emp_cur is \n  SELECT employee_id, first_name, last_name \n  FROM employees; \n  BEGIN \n  -- loop through each record in the employees table \n   FOR emp_rec IN emp_cur LOOP \n      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name); \n      increase_wage(emp_rec.employee_id, pct_increase, upper_bound); \n   END LOOP; \n  END grant_raises;  \n \n \n  PROCEDURE increase_wage (empno_in IN NUMBER, \n                          pct_increase IN NUMBER, \n                          upper_bound IN NUMBER) AS \n  emp_count    NUMBER :&#x3D; 0; \n  emp_sal      employees.salary%TYPE; \n   \n  Results   VARCHAR2(50); \n   \n  BEGIN \n \n  SELECT count(*) \n  INTO emp_count \n  FROM employees \n  WHERE employee_id &#x3D; empno_in; \n  \n  IF emp_count &gt; 0 THEN \n    -- IF EMPLOYEE FOUND, THEN OBTAIN RECORD \n    SELECT salary \n    INTO emp_sal \n    FROM employees \n    WHERE employee_id &#x3D; empno_in; \n     \n    IF emp_sal &lt; upper_bound AND round(emp_sal + (emp_sal * pct_increase), 2) &lt; \n upper_bound THEN \n     \n        UPDATE employees \n        SET salary &#x3D; round(salary + (salary * pct_increase),2) \n        WHERE employee_id &#x3D; empno_in; \n         \n        results :&#x3D; &#39;SUCCESSFUL INCREASE&#39;; \n    ELSE \n        results :&#x3D; &#39;EMPLOYEE MAKES TOO MUCH, DECREASE RAISE PERCENTAGE&#39;; \n    END IF; \n     \n  ELSE \n    Results :&#x3D; &#39;NO EMPLOYEE FOUND&#39;; \n  END IF; \n  DBMS_OUTPUT.PUT_LINE(results); \n  END increase_wage; \n\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(&#39;EXECUTING THE INITIALIZATION BLOCK&#39;);\nEND;\nThe initialization block in this example is the last code block within the package body. In this case,that block lies in the final three lines. \nHow It Works\nThe initialization block for the package in the solution displays a line of text to indicate that theinitialization block has been executed. The initialization block will execute once per session, the firsttime the package is used in that session. If you were to create this package in your session and invokeone of its members, you would see the message print. Although an initialization message is not veryuseful, there are several good reasons to use an initialization block. One such reason is to perform aquery to obtain some data for the session. \nsummary:  \n\nmore like java construct function and golang init() function\ncode struct for initializationcreate or replace package XXXX () is\nBEGIN\n    DBMS_OUTPUT.PUT_LINE(&#39;EXECUTING THE INITIALIZATION BLOCK&#39;);\nEND;\n\n4-11. Granting the Ability to Create and Execute Stored ProgramsProblemYou want to grant someone the ability to create and execute stored programs. \nSolutionTo grant the ability for a user to create a procedure, function, or package, you must log in to the databasewith a privileged account and grant the CREATE PROCEDURE privilege to the user. Here’s an example: \nGRANT CREATE PROCEDURE TO user; \n\nSimilarly, to grant permissions for execution of a procedure, package, or function, you must log inwith a privileged account and grant the user EXECUTE permissions on a particular procedure, function, orpackage. Here’s an example: \nGRANT EXECUTE ON schema_name.program_name TO schema;\n\nHow It Works\nBefore a user can create stored code, the user must be given permission to do so. The solution shows thestraightforward approach. The database administrator logs in and grants CREATE PROCEDURE to theschema owner. The schema owner can then log in and create stored code in their schema.A schema owner can always execute stored code in the schema. However, application users do notgenerally log in as schema owners because of the security risks inherent in doing so. Thus, you willcommonly be faced with the need to grant other users execute access on stored code. You do that bygranting EXECUTE privileges, as shown in the second solution example.  \nsummary :  \n\nlet A account access B schema objects by execute GRANT EXECUTE ON schema_name.program_name TO schema;\n\n4-12. Executing Packaged Procedures and FunctionsProblemYou want to execute one of the procedures or functions contained within a package. \nSolutionUse the package_name.object_name notation to execute a particular code object within a package. Forinstance, the following block of code executes the GRANT_RAISES procedure that is contained within thePROCESS_EMPLOYEE_TIME package. \nBEGIN \n    process_employee_time.grant_raises(.03,4000); \nEND; \n\nThe previous code block executes the GRANT_RAISES function, passing .03 for the percentage ofincrease and 4000 for the upper bound. \n*How It WorksDot notation is used for accessing members of a package. Similar to other languages such as Java, dotnotation can be used to access any publically accessible member of the package. Any variable, function,or procedure that is contained in the package specification can be accessed using the dot notation.Therefore, if your package contained a constant variable within its specification that you wanted toaccess, it would be possible to do so from outside the package.For a schema to access and execute package members, it must have the appropriate permissions. Togrant EXECUTE permission on a package that you own, use the following syntax: \nGRANT EXECUTE ON package_name TO user_name; \n\nDot notation works from within other procedures or functions. It can also be used from theSQL*Plus command line using the EXEC command.■ Note In most cases, if a package is being used by another schema, then it is a good idea to create a publicsynonym for that package within the database. This will help decrease issues while attempting to reference thepackage and its programs from the different schema because you will not need to specify the schema name inorder to qualify the call. Please see Recipe 4-13 for more information regarding public synonyms.summary:  \n\na good way is to create synonyms\n\n4-13. Creating a Public Name for a Stored ProgramProblemYou want to allow for any schema to have the ability to reference a particular stored program that iscontained(adj.泰然自若的;从容的;被控制的) within your schema. For instance, the CALC_EMPLOYEE_PAYCHECK procedure should beexecutable for any of the administrative users of the database. You want these users to have the ability tosimply call the procedure rather than preceding the procedure name with the schema using the dotnotation. \nSolutionCreate a public synonym for the function, procedure, or package. This will allow any user that hasEXECUTE privileges on the stored program to call it without specifying the schema name first. Instead, theinvoker need only reference the synonym.In the following example, the user AdminUser does not have direct access to theCALC_EMPLOYEE_PAYCHECK procedure, so they must fully qualify the name of the package using the schemaname for which the procedure resides. \nSQL&gt; exec application_account.calc_employee_paycheck(200); \nCalculating paycheck with taxes \nThe paycheck total for Whalen is 5200.8 \n \nPL&#x2F;SQL procedure successfully completed. \n\nNext, the database administrator will create a public synonym for the procedure:\nSQL&gt; CREATE PUBLIC SYNONYM calc_employee_paycheck \n           FOR application_user.calc_employee_paycheck; \n\nNow any user with execute privileges on the procedure can invoke it without fully qualifying thename since a public synonym named CALC_EMPLOYEE_PAYCHECK has been created. This is demonstrated inthe next lines of code. Again, the user AdminUser is now logged into the system and executes theprocedure. \nSQL&gt; exec calc_employee_paycheck(206); \nCalculating paycheck with taxes \nThe paycheck total for Gietz is 6640.8 \n \nPL&#x2F;SQL procedure successfully completed. \n\nAs you can see, the procedure name no longer requires the schema name to fully qualify it beforebeing invoked. \nHow It WorksCreating public synonyms is a useful technique for allowing any user to have access to a stored piece ofcode without knowing which schema the code belongs to. Any user who has EXECUTE privileges on thecode can invoke it without fully qualifying the name. Instead, the invoker specifies the synonym name.An account must be granted the CREATE PUBLIC SYNONYM privilege in order to create a publicsynonym. It’s actually common for database administrators to take care of creating such synonyms.To create a synonym, execute the following statement, replacing the PUB_SYNONYM_NAME identifierwith the name of your choice and replacing SCHEMA.STORED_PROGRAM with the schema name and programthat you want to make publically accessible: \nCREATE PUBLIC SYNONYM pub_synonym_name FOR schema.stored_program; \n\nThe public synonym name does not have to be the same as the actual stored program name, but it isconventional to keep them the same, and it makes things consistent and the names easier to remember.If you begin to have synonym names that differ from the actual program names, then confusion willeventually set in.\n■ Note Creating a synonym does not give execute access. Creating a public synonym provides only a global namethat avoids the need for dot notation. Invokers of a procedure or function still must be granted EXECUTE access, asshown in Recipe 4-11. \nsummary:  \n\ngrant read&#x2F;write user access right to execute procedure without schema name\nif you want to setup w&#x2F;r account for schema account.\ncreate public synonym name for application account\ngrant execute&#x2F;select&#x2F;update … on package_name on write_user&#x2F;read_user\n\n\n\n4-14. Executing Package Programs in SequenceProblemYou have created a package that contains all the necessary procedures and functions for your program.Although you can invoke each of these subprograms individually using thepackage_name.subprogram_name notation, it would be beneficial to execute all of them at the same timeby issuing a single statement. \nSolutionCreate a driver procedure within your PL&#x2F;SQL package that will be used to initiate all the subprograms in turn, and run your entire program. In the following example, a procedure named driver is created insidea package, and it will invoke all the other package subprograms in turn:First, create the specification: \nCREATE OR REPLACE PACKAGE synchronize_data IS \n  PROCEDURE driver; \nEND; \nThen, create the body: \nCREATE OR REPLACE PACKAGE BODY synchronize_data IS \n  PROCEDURE query_remote_data IS \n    BEGIN \n      --statements go here \n      DBMS_OUTPUT.PUT_LINE(&#39;QUERYING REMOTE DATA&#39;); \n    END query_remote_data;  \n \n  PROCEDURE obtain_new_record_list IS \n    BEGIN \n      --statements go here \n      DBMS_OUTPUT.PUT_LINE(&#39;NEW RECORD LIST&#39;); \n    END obtain_new_record_list;  \n \n  PROCEDURE obtain_updated_record_list IS \n    BEGIN \n      --statements go here \n      DBMS_OUTPUT.PUT_LINE(&#39;UPDATED RECORD LIST&#39;); \n    END obtain_updated_record_list;  \n \n  PROCEDURE sync_local_data IS \n    BEGIN \n      --statements go here \n      DBMS_OUTPUT.PUT_LINE(&#39;SYNC LOCAL DATA&#39;); \n    END sync_local_data;  \n   \n  PROCEDURE driver IS \n  BEGIN \n    query_remote_data; \n    obtain_new_record_list; \n    obtain_updated_record_list; \n    sync_local_data; \n  END driver; \nEND synchronize_data; \n\nThe driver procedure initiates all the other procedures in the order that they should be executed. Toinitiate the packaged program, you now make a call to the driver procedure as follows: \nBEGIN \n   synchronize_data.driver; \nEND;\nOne statement invokes the driver procedure. That procedure in turn invokes the other proceduresin the proper sequence.  \nHow It WorksBy creating a single procedure that can be called in order to execute all the other subprograms in turn,you eliminate the potential for calling subprograms in the incorrect order. This will also allow you theconvenience of making one call as opposed to numerous calls each time you want to execute the task(s)involved. And, if you create the other subprograms as private procedures and functions, then youeliminate the risk of a developer invoking them out of order. That’s because you only make the driverprocedure public, and you know that the driver invokes in the correct sequence.Oftentimes, packages are used to hold all the database constructs that make up an entire process. Inthe solution to this recipe, the package entails(vt.使需要.必需) a database synchronization process, and each procedurewithin performs a separate piece of the synchronization. When executed in the correct order, theprocedures together perform the complete synchronization task.One could just as easily create a script or manually invoke each package program separately just asthe driver procedure does in this case. However, you open the door to error when you write the logic ofinvoking the sequence of procedures from multiple places. Another important factor is that the drivercan also be used to perform any additional initialization that must be done prior to executing eachprocedure. Similarly, additional processing can be done in between each procedure call, such asprinting out the current status of the program. The driver procedure essentially provides another layerof abstraction that you can take advantage of. The package can be initialized using the default packageinitialization; then additional initialization or statements can be provided within the driver procedure,and the program caller doesn’t need to know about them.summary: \n\nAnother important factor is that the driver can also be used to perform any additional initialization that must be done prior to executing each procedure\nyou can take advantage of. The package can be initialized using the default package initialization\n\n4-15. Implementing a Failure FlagProblemYou want to create a boolean variable to determine whether one of the subprograms in the package hasgenerated an error. If an error has been generated by one of the subprograms, then the variable will beset to TRUE. This flag will be evaluated in the driver procedure to determine whether the updatesperformed by the package should be committed or rolled back. \nSolutionDeclare a global variable at the package level, and it will be accessible to all objects within. You can dothis by declaring the variable within the package body. The following package illustrates such a variable,where the variable has been declared within the package body so that it is available for all objects in thepackage only. \nCREATE OR REPLACE PACKAGE synchronize_data \nPROCEDURE driver; \nEND; \n \nCREATE OR REPLACE PACKAGE BODY synchronize_data IS \n  error_flag BOOLEAN :&#x3D; FALSE; \n \n  PROCEDURE query_remote_data is \n     Cursor remote_db_query is \n     SELECT * \n     FROM my_remote_data@remote_db; \n    \n     remote_db_rec employees%ROWTYPE; \n \n  BEGIN \n    OPEN remote_db_query; \n    LOOP \n      FETCH remote_db_query INTO remote_db_rec; \n      EXIT WHEN remote_db_query%NOTFOUND; \n    IF remote_db_query%NOTFOUND THEN \n      error_flag :&#x3D; TRUE; \n    ELSE \n      -- PERFORM PROCESSING \n      DBMS_OUTPUT.PUT_LINE(&#39;QUERY REMOTE DATA&#39;); \n    END IF; \n    END LOOP; \n    CLOSE remote_db_query; \n  END query_remote_data; \n \n  PROCEDURE obtain_new_record_list IS \n    BEGIN \n      --statements go here \n      DBMS_OUTPUT.PUT_LINE(&#39;NEW RECORD LIST&#39;); \n    END obtain_new_record_list;  \n \n  PROCEDURE obtain_updated_record_list IS \n    BEGIN \n      --statements go here \n      DBMS_OUTPUT.PUT_LINE(&#39;UPDATED RECORD LIST&#39;); \n    END obtain_updated_record_list;  \n \n  PROCEDURE sync_local_data IS \n    BEGIN \n      --statements go here \n      DBMS_OUTPUT.PUT_LINE(&#39;SYNC LOCAL DATA&#39;); \n    END sync_local_data;  \n \n \n  PROCEDURE driver IS \n  BEGIN \n    query_remote_data; \n    IF error_flag &#x3D; TRUE THEN \n      GOTO error_check; \n    END IF; \n     \n    obtain_new_record_list; \n    IF error_flag &#x3D; TRUE THEN \n      GOTO error_check; \n    END IF; \n \n    obtain_updated_record_list; \n    IF error_flag &#x3D; TRUE THEN \n      GOTO error_check; \n    END IF; \n \n    sync_local_data; \n \n    -- If any errors were found then roll back all updates \n    &lt;&lt;error_check&gt;&gt; \n    DBMS_OUTPUT.PUT_LINE(&#39;Checking transaction status&#39;); \n    IF error_flag &#x3D; TRUE THEN \n      ROLLBACK; \n      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been rolled back.&#39;); \n   ELSE \n      COMMIT; \n      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been processed.&#39;); \n    END IF; \n \n  END driver; \nEND;\nHow It WorksDeclaring variables in the package body outside any procedures or functions allows them to becomeaccessible to all subprograms within the package. If one or more of the subprograms changes such avariable’s value, then the changed value will be seen throughout the entire package.As depicted in the example, you can see that the variable is referenced several times throughout thepackage. If you had a requirement to make a variable global to all PL&#x2F;SQL objects outside the package aswell, then you can declare the variable within the package specification. As mentioned in Recipe 4-8,anything declared in the package specification is publically available to any PL&#x2F;SQL object outside aswell as within the package body. \n4-16. Forcing Data Access to Go Through PackagesProblemYou have defined all subprograms and packages for a particular application, and you want to allow otherusers to access these constructs and execute the program but not have access to any data tables directly. \nSolutionDefine all the packages, procedures, and functions for your program within a single schema that hasaccess to all the data. All user access should be made from separate schemas, and they should be grantedexecute privileges on the PL&#x2F;SQL objects but not access to the tables themselves.For instance, if you want to control access to a package named PROCESS_EMPLOYEE_TIME, that packagealong with all required tables, types, and sequences should be loaded into an application schema thathas the appropriate permissions required to access the data. For the purposes of this recipe, theapplication schema name is EMP.Next, create a role by which to manage the privileges needed to invoke the package’s proceduresand functions. Grant EXECUTE privileges to that role. Grant that role to application users.Your application users will now be able to execute the procedures and functions within the package.Those procedures and functions can in turn update the database tables in the package’s schema.However, users will not have direct access to those tables. All updates must flow through the package. \nHow It WorksTo control an application’s data, it is important to restrict access to the tables. The solution in this recipeshows how to create a package in the same schema that contains the application tables. The packagethus has access to those tables. Users, however, do not have table-level access.After creating the package, you can grant EXECUTE access on the package to application users. Userscan then invoke packaged procedures and functions, and those procedures and functions in turn canmodify the data in the tables. However, users have no direct access to the tables.By forcing users to go through packaged procedures and functions, you limit users to using adefined interface that remains under your control. You now have some amount of freedom to modify theunderlying tables. So long as you do not change the package interface, you can make changes to theunderlying tables without disrupting the application. \nsummary:  \n\nbig, deep, comprehensive,topic to disuss\nallow you must through package to access tables\n\n4-17. Executing Stored Code Under Your Own Privilege SetProblemYou have loaded all of an application’s objects into a single application schema. However, you do notwant packages, procedures, and functions to execute as the schema owner. Instead, you want storedcode to execute with the privileges and access of the user who is invoking that code.SolutionUse invoker’s rights by providing the AUTHID property within the declaration of your program. If theAUTHID property is specified when defining a package, procedure, or function, then you have the abilityto specify whether the program should be invoked using the CURRENT_USER privileges or the DEFINERprivileges. In the case of this solution, you would rather use the CURRENT_USER privileges to ensure thatthe user does not have the same level of access as the schema owner. The default is DEFINER.The following code shows how to create a procedure for changing a password, and it uses the AUTHIDproperty to ensure that the procedure will be run using the CURRENT_USER’s privilege set. This particularprocedure uses dynamic SQL to create a SQL statement. To learn more about using dynamic SQL, pleasesee Chapter 8.\nCREATE OR REPLACE PROCEDURE change_password(username IN VARCHAR2, \n                                                                                                                    \n                                          new_password IN VARCHAR2)\nAUTHID CURRENT_USER IS \n \nsql_stmt VARCHAR2(100); \n\nBEGIN \n    sql_stmt :&#x3D; &#39;ALTER USER &#39; ||  username || &#39; IDENTIFIED BY &#39; || new_password; \n    \n    EXECUTE IMMEDIATE sql_stmt; \nEND; \nWhen the user executes this procedure, it will be executed using their own set of permissions. Thiswill prevent them from changing anyone else’s password unless they have the ability to do so under theirallotted(v.分配;指派;拨给) permission set.  \nHow It WorksInvoker’s rights are a great way to secure your application if you are planning to limit access to theCURRENT_USER’s privilege set. To allow for invoker’s rights to be set into place, the AUTHID property mustbe used with the CURRENT_USER keyword in the definition of a stored PL&#x2F;SQL unit. This property affectsthe name resolution and privilege set for that unit. You can find the value of the AUTHID property if youtake a look at the USER_PROCEDURES data dictionary view.Using the invoker’s rights methodology is a great way to protect a program as long as the usersaccess the program with their own database account. If each user within the database has their ownaccount, then they can be granted the required level of access via database roles. The AUTHID propertycan constrain the execution of code to the current user’s privilege set. Because of that, if a user does nothave the privileges that are required to execute a particular program, then they will not have access.Simply put, invoker’s rights are a good means of securing your code as long as the approach is usedcorrectly.\nsummary:  \n\nmust execute code by your access right\n\n4-18. Accepting Multiple Parameter Sets in One FunctionProblemYou want to give a function the ability to accept multiple parameter types instead of being constrainedto a particular datatype or number of parameters. For example, you want to create a single function thatcan accept either one or two parameters and that will perform a slightly(adv.些微地,轻微地) different action depending uponthe number of parameters you pass it.  \nSolutionUse overloading to create multiple functions that are named the same and perform similar functionalitybut accept a different number of parameters, different ordering of parameters, or parameters of differenttypes. In this recipe, you will see a function named squared that takes a number and returns its valuesquared. Similarly, there is another function also named squared that accepts two numbers instead ofone. This second function is the overloaded version of the original squared. Here is the code for the twofunctions: \n-- Returns the square of the number passed in \nCREATE OR REPLACE FUNCTION squared (in_num IN NUMBER) \nRETURN NUMBER AS \n  -- variables\nBEGIN \n  RETURN in_num * in_num; \nEND; \n -- Returns the squared sum of two numbers \nCREATE OR REPLACE FUNCTION squared (in_num IN NUMBER, \n                                    in_num_two IN NUMBER) \n    RETURN NUMBER AS \nBEGIN \n  RETURN (in_num + in_num_two) * (in_num + in_num_two);  \nEND; \n\nanother type \nCREATE OR REPLACE FUNCTION squared (in_num IN NUMBER, \n                                    in_num_two IN NUMBER\n                                    out_number_three out NUMBER) \n    RETURN NUMBER AS \nNOK   NUMBER;\n\nBEGIN \n  out_number_three :&#x3D; (in_num + in_num_two) * (in_num + in_num_two);  \n  RETURN NOK;  \nEND; \n\nYou can see that each of the previous functions accepts a different number of parameters, but theyboth perform similar tasks. This is a good illustration for using function overloading because someoneusing this function would expect a similar result to be returned whether calling the function with oneparameter or two. \nHow It WorksLike many other programming languages, PL&#x2F;SQL offers an overloading(重载) of functions. This makes itpossible to name more than one function by the same name but give each of them different parametertypes, different parameter ordering, or a different number of parameters. This is also known as changingthe function signature. A signature for a function consists of the object name and its parameter list. Byoverloading, you have the ability to allow more flexibility to those using the function. For instance, if youplace both of the squared functions into a package named MATH_API, then someone using this packagecan simply call the function passing whatever they require and still receive a usable result withoutactually knowing the implementation details.Using overloading to create multiple functions or procedures by the same name can becometroublesome if overused. Be careful that your package is not littered with too many overloadedprocedures or functions because maintenance on such a code base can become a nightmare.Overloading has its good use cases, but if it can be avoided by using technique that is easier to follow,then it is a good idea to go the simpler route. \n4-19. Listing the Functions, Procedures, and Packages in a SchemaProblemYour team has defined a number of functions, procedures, and packages within a schema. You want togenerate a listing of all functions, procedures, and packages at the end of each day to evaluateproductivity. \nSolutionUse the USER_OBJECTS table to return the program list and prefix packages, procedures, and functions forthe same program with the same first word to make them easier to find.This first example will return a list of all procedure names that reside within the EMP schema and thathave a name that is prefixed with EMPTIME: \nSELECT OBJECT_NAME \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE &#x3D; &#39;PROCEDURE;\nWHERE OBJECT_NAME like &#39;EMPTIME%&#39;; \n\nThe next query will return a list of all function names that reside within the schema: \nSELECT OBJECT_NAME \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE &#x3D; &#39;FUNCTION&#39;; \n\nLastly, the following query will return a listing of all package names that reside within the schema: \nSELECT OBJECT_NAME \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE &#x3D; &#39;PACKAGE&#39;;\n\nget_DDL() \n\nHow It WorksOracle Database contains many views that contain data useful for application development. Using theUSER_OBJECTS table can be very handy when searching for objects within the database. By prefixing likeobjects with the same first word, it can make searching for a particular selection of objects rather easy.USER_OBJECTS provides the ability to find a certain object type by specifying the OBJECT_TYPE withinthe query. If no OBJECT_TYPE is specified, then all objects for the schema will be returned.\n4-20. Viewing Source Code for Stored ProgramsProblemYou want to retrieve the code for your stored functions, procedures, triggers, and packages. \nSolutionUse the DBMS_METADATA package to assist(vi.参加) you in fetching the information. In this case, you will use theDBMS_METADATA.GET_DDL procedure to obtain the code for a stored function. In the following code, theDBMS_METADATA package is used to return the DDL for the CALC_QUARTER_HOUR function: \nSELECT DBMS_METADATA.GET_DDL(&#39;FUNCTION&#39;,&#39;CALC_QUARTER_HOUR&#39;) FROM DUAL; \n\nThe query illustrated previously should produce results that are similar to the following as long asyou have the CALC_QUARTER_HOUR function loaded in your database: \nCREATE OR REPLACE FUNCTION &quot;MY_SCHEMA&quot;.&quot;CALC_QUARTER_HOUR&quot; (HOURS IN NUMBER) \nRETURN NUMBER AS \n   CALCULATED_HOURS NUMBER :&#x3D; 0; \nBEGIN \n   IF HOURS &gt; 1 THEN \n        IF MOD(HOURS, 1) &lt;&#x3D;.125 THEN \n          CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1); \n        ELSIF MOD(HOURS, 1) &gt; .125 AND MOD(HOURS,1) &lt;&#x3D; .375 THEN \n          CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.25,1); \n       ELSIF MOD(HOURS, 1) &gt; .375 AND MOD(HOURS,1) &lt;&#x3D; .625 THEN \n          CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.50,1); \n       ELSIF MOD(HOURS, 1) &gt; .63 AND MOD(HOURS,1) &lt;&#x3D; .825 THEN \n          CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.75,1); \n       ELSE \n          CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); \n       END IF; \n   ELSE \n       IF HOURS &gt; 0 AND HOURS &lt;&#x3D;.375 THEN \n         CALCULATED_HOURS :&#x3D; .25; \n       ELSIF HOURS &gt; .375 AND HOURS &lt;&#x3D; .625 THEN \n         CALCULATED_HOURS :&#x3D; .5; \n       ELSIF HOURS &gt; .625 AND HOURS &lt;&#x3D; .825 THEN \n         CALCULATED_HOURS :&#x3D; .75; \n       ELSE \n         CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); \n       END IF; \n   END IF; \n   RETURN CALCULATED_HOURS; \n END CALC_QUARTER_HOUR; \nThe GET_DDL function returns the code that can be used to re-create the procedure or function. Thiscan be a good way to debug code that you may not have authored and do not have on hand.■ Note The GET_DDL function will not format the code. Rather, it will be returned as a single string of text. Bydefault, the buffer will not be large enough to display all of the DDL. You can change the buffer size by issuing theSET LONG buffersize within SQL*Plus, substituting buffersize with a large integer value. \nHow It WorksYou can use the DBMS_METADATA package to retrieve various pieces of information from the database. Thesolution to this recipe demonstrated how to fetch the DDL for a function. There is an abundance ofinformation that can be obtained by using the DBMS_METADATA package, and GET_DDL barely scratches thesurface. \nThe GET_DDL function can return the code for each different type of object. To retrieve a the code foran object using GET_DDL, use the following syntax: \nSELECT DBMS_METADATA.GET_DDL(&#39;object_type&#39;,&#39;object_name&#39;, &#39;schema&#39;) FROM DUAL; \nThe OBJECT_TYPE can be the name of any database object type, including TABLE. For the purposes ofPL&#x2F;SQL code, the OBJECT_TYPE can be FUNCTION, PROCEDURE, PACKAGE, or TRIGGER. The SCHEMA parameter isoptional and does not have to be specified if the object resides within the caller’s schema.Using DBMS_METADATA, you can obtain complete database object definitions from the databasedictionary via the retrieval subprograms. To learn more about the DBMS_METADATA package and obtain alisting of available subprograms, please refer to the online Oracle documentation athttp://download.oracle.com/docs/cd/B28359_01/appdev.111/b28419/d_metada.htm#ARPLS640, whichgoes into detail regarding each of the subprogram functionalities. \nsummary:  \nIt has always been a huge pain to punch the DDL for tables, indexes and stored procedures into a flat file. Oracle now has a dbms_metadata package with a get_ddl function to copy DDL syntax out of the dictionary.\n\nWith all of the new storage clauses and advanced parameters, getting table and index definitions has always been a huge problem.  Hence, prior to Oracle, the DBA was generally forced to keep the DDL source code in a special library.  This makes life difficult because the DBA is now forced to maintain and manage versions of tables and index DDL separately from the data dictionary.\n\nOracle, the DBA will be able to keep all table and index definitions inside the data dictionary (where they belong), and use the get_ddl function to punch-out a copy whenever they need to migrate the object.\n\nBelow we see that the get_ddl function is very simple to use, only requiring the object_type and the object_name as import parameter.  Also, make sure to set linesize to a large value, because get_ddl returns a CLOB datatype, and you want SQL*Plus to be able to display the result set.\n\nSet lines 90000\n\nSpool sales_table_ddl.sql\n\nSelect dbms_metadata.get_ddl('TABLE','SALES','schema') from dual;\n\nSpool off;\n\nIf you like Oracle tuning, you might enjoy my latest book \"Oracle Tuning: The Definitive Reference\" by Rampant TechPress.  It's only $41.95 (I don't think it is right to charge a fortune for books!) and you can buy it right now at this link:\n\n5. TriggersTriggers play an important role in any database developer’s or database administrator’s career. Theyprovide the ability to execute code upon the occurrence of defined database, schema, or system events.Triggers can be useful for enhancing applications by providing database capabilities when a table eventoccurs, providing alerts on system event occurrences, and so much more. Triggers are an enormoustopic because they are very intricate constructs. However, even though triggers can open up a world ofpossibilities, they are easy to use.In this chapter, you will see recipes demonstrating the many different capabilities that triggersprovide to you. If you are interested in learning how to create code that executes upon a database table–level event, then this is the chapter for you. If you want to learn how to create an intricate alerting systemthat will send e-mail and create logs upon system events, then look at the recipes in this chapter.Triggers are intricate building blocks that can provide an enormous benefit to our databases andapplications as a whole. By learning how to incorporate these recipes into your applications, you will beable to solve many issues and enhance a number of your application features. Triggers can be one of themost useful tools to add to a DBA or application developer’s arsenal. \n5-1. Automatically Generating Column Values(how use before insert)ProblemYou want to automatically generate certain column values for newly inserted rows. For example, one of your tables includes a date field that you want to have populated with the current date when a record is inserted. \nSolutionCreate a trigger that executes BEFORE INSERT on the table. The trigger will capture the system date and populate this date field with it prior to inserting the row into the database. The following code demonstrates how to create a trigger that provides this type of functionality for your application. In the example, the EMPLOYEES table is going to have its HIRE_DATE populated with the current date when a record is inserted into the EMPLOYEES table. \nCREATE or REPLACE TRIGGER populate_hire_date \nBEFORE INSERT ON employees \n    FOR EACH ROW \nDECLARE \nBEGIN \n    :new.hire_date :&#x3D; sysdate; -- new.hire_date  means user&#39;s data\nEND; \n\nA BEFORE INSERT trigger has access to data before it is inserted into the table. This exampledemonstrates a useful technique for using this type of trigger. \nHow It WorksYou can use triggers to execute code when a DML statement, DDL statement, or system event occurs.This recipe demonstrates a trigger that executes when a DML event occurs. Specifically, the trigger thatwas created for this recipe is fired BEFORE a row is inserted into the EMPLOYEES table. Any DDL eventtrigger can be created to fire BEFORE or AFTER a row is inserted, updated, or deleted from a database table.This flexibility allows a developer or DBA the luxury of executing code either before or directly after thevalues are inserted into the database.The syntax for creating a trigger that will execute before an insert on a particular table is as follows: \nCREATE or REPLACE TRIGGER trigger_name \nBEFORE INSERT \n    ON table_name \n    [ FOR EACH ROW ] \nDECLARE \n    -- variable declarations \nBEGIN \n    -- trigger code \nEXCEPTION \n    WHEN ... \n    -- exception handling \nEND; \nThe CREATE OR REPLACE TRIGGER statement will do just what it says, either create the trigger in thecurrent schema if none is specified or replace it if another trigger by that name already exists. The triggername must be unique among other triggers within the same schema. Although it is possible to name atrigger the same as an existing table, we do not recommend doing so. Different triggers by the samename can coexist in the same database if they are in different schemas.The BEFORE INSERT clause is what tells Oracle when the trigger should be executed before a row isinserted into the table. The other option for insert triggers is AFTER INSERT, which causes the trigger to beexecuted after a row is inserted into the table. You will learn more about AFTER INSERT triggers inanother recipe within this chapter. The optional FOR EACH ROW clause determines whether the trigger willbe executed once for each row that is affected or once when the statement is executed. Essentially thisclause determines whether it will become a row-level trigger or a statement level-trigger. The FOR EACHROW clause can have a significant impact on the outcome of an UPDATE trigger. You will learn more aboutUPDATE triggers in the next recipe.The code that follows the optional FOR EACH ROW clause is the DECLARE section. Much like that of aprocedure, this section of the trigger is used to declare any variables, types, or cursors that will be usedby the trigger body. The body of the trigger also resembles(类似) that of a procedure. The trigger body is astandard code block that opens with the BEGIN keyword and ends with the END keyword. Any of thekeywords and constructs that can be used within other PL&#x2F;SQL code blocks can also be used in triggers.There are a couple of differences between the trigger and other code blocks in PL&#x2F;SQL. First, atrigger is limited to 32KB in size. This is a bit of a limitation; however, it does not prevent a trigger frominvoking other named code blocks. For example, you can write a trigger to invoke stored procedures andfunctions that are much longer than 32KB in size.  \nSecond, the INSERT trigger has access to data values prior to insertion in the database via the :NEWqualifier. This qualifier is what provides the power to the trigger construct. Using the :NEW qualifier alongwith a table column name allows you to access the value that is going to be placed into that column viathe INSERT statement that has just occurred. In the solution to is recipe, using :NEW.FIRST_NAME and:NEW.LAST_NAME allows you to reference the values that are going to be inserted into the FIRST_NAME andLAST_NAME columns before it occurs. This provides the ability to change the values or check the values forerror prior to insertion. \nIn the case of the solution to this recipe, the HIRE_DATE will always be made the same as the date inwhich the record is inserted into the database. Even if the HIRE_DATE is set to some date in the past, thistrigger will automatically assign SYSDATE to it and override the original value. Now, this may not be verypractical example because the data entry clerk may not be inputting the data on the same day as thehire, but it does provide an effective learning tool for this type of situation. If you wanted to modify thetrigger to be more realistic, then you could add an IF statement to check and see whether:NEW.HIRE_DATE already had a value. If it does, then that value is inserted into the database, but if leftblank, then SYSDATE could be used. Such an example would be a more practical real-life solution. \nsummary:  \n\n32KB in size but you could  invoke function and procedure that more that 32kb\n:NEW.FIRST_NAME allow you access data that you gonna insert\nEven if the HIRE_DATE is set to some date in the past, this trigger will automatically assign SYSDATE to it and override the original value\n\n5-2. Keeping Related Values in SyncProblemYou want to keep related values in sync that happen to be stored in separate tables. For example, say youare updating the salary level for a number of jobs within the JOBS table. However, in doing so, you willneed to update the salaries within the EMPLOYEES table for employees having those jobs. In short, if youupdate the salary range for a job, then you want to automatically update salaries to ensure that they fallwithin the new range.  \n■ Note When we use the term related in this problem description, we do not necessarily mean related in therelational sense that one commonly thinks about. There is no referential integrity issue in our scenario. Rather, weare instituting a business rule that says that employees automatically get salary bumps in response to changingsalary ranges. Not all businesses would choose to institute such a rule. In fact, we suspect most businesses wouldnot do such a thing.  \nSolutionCreate an AFTER UPDATE trigger on the primary table. In our example, create such a trigger to be executedafter the JOBS table has been updated. This trigger will obtain the updated salary from the JOBS table andmodify the data within the EMPLOYEES table accordingly. \nCREATE OR REPLACE TRIGGER job_salary_update \nAFTER UPDATE \n    ON jobs \nFOR EACH ROW \nDECLARE \n \n  CURSOR emp_cur IS \n  SELECT * FROM employees  \n  WHERE job_id &#x3D; :new.job_id \n  AND salary &lt; :new.min_salary FOR UPDATE; \n \n  emp_rec  emp_cur%ROWTYPE; \n \nBEGIN \n \n    FOR emp_rec IN emp_cur LOOP \n        UPDATE employees \n        SET salary &#x3D; :new.min_salary \n        WHERE CURRENT OF emp_cur; \n    END LOOP; \n \nEND; \n\nSince this example uses an AFTER UPDATE trigger, you have access to both the :NEW and :OLD data valuequalifiers. This can be very advantageous, as you’ll learn in the next section. \nHow It WorksThe update trigger provides the same type of functionality as an INSERT trigger. The syntax for an updatetrigger is almost identical to that of an insert trigger, other than the BEFORE UPDATE or AFTER UPDATEclause. A BEFORE UPDATE trigger is executed prior to an update on a database table. On the contrary, theAFTER UPDATE executes after an update has been made to a table.The optional FOR EACH ROW clause can make a great deal of difference when issuing an updatetrigger. If used, this clause tells Oracle to execute the trigger one time for every row that is updated. Thisis quite useful for capturing or modifying data as it is being updated. If the FOR EACH ROW clause isomitted, the trigger is executed one time either prior to or after the UPDATE has taken place. Without theFOR EACH ROW clause, the trigger is not executed once for each row but rather one time only for eachUPDATE statement that is issued.As mentioned previously in this recipe, update triggers have access to the :OLD and :NEW qualifiers.The qualifiers allow the trigger to obtain the values of data that are being updated prior to (:OLD) andafter (:NEW) the update has been made. Generally, update triggers are most useful for obtaining andmodifying data values as the update is occurring. Update triggers, along with every other type of trigger,should be used judiciously because too many triggers on a table can become problematic.For example, the solution to this recipe demonstrates a trigger in which a salary change in the JOBStable causes a trigger to execute. The trigger will be executed only if the JOBS table is updated. The cursorthat is declared will select all the records within the EMPLOYEES table that contain a SALARY that is lowerthan the new MIN_SALARY for the corresponding JOB_ID. In the body of the trigger, the cursor result set isiterated, and each record is updated so that the SALARY is adjusted to the new MIN_SALARY amount for thatjob.If that trigger contains another update statement that modifies values in the EMPLOYEES table, thenyou must be sure that the EMPLOYEES table does not contain an update trigger that modifies values withinthe JOBS table. Otherwise, a vicious cycle could occur in which one trigger is causing another trigger toexecute, which in turn causes the initial trigger to execute again, and so on. This may even cause anORA-xxxxx error if Oracle detects a recursive loop.Update triggers can provide the best of both worlds because you have access to data values beforeand after they have been updated. \n5-3. Responding to an Update of a Specific Table ColumnProblemYou want to automatically update some particular values within a table based upon another update thathas been made on a specific column of another table. For instance, assume that management hasdecided to change some positions around within your organization. A new manager is coming to one ofthe current manager positions, so several employees will receive a new manager. You need to find a wayto update several employee records to change their manager from the old one to the new one.  \nSolutionCreate an AFTER UPDATE trigger that will be executed only when the MANAGER_ID column is updated. Thefollowing trigger uses a cursor to obtain the employees that are supervised(adj.有监督的) by the old manager. Thetrigger then determines whether the MANAGER_ID column has been updated, and if so, it loops througheach employee who has the old manager in their record, and it updates the MANAGER_ID column to reflectthe new manager’s ID. \nCREATE OR REPLACE TRIGGER dept_mgr_update \nAFTER UPDATE OF manager_id   -- column name\n    ON departments  --table\nFOR EACH ROW \nDECLARE \n  CURSOR emp_cur IS \n  SELECT * \n  FROM EMPLOYEES \n  WHERE manager_id &#x3D; :old.manager_id \n  FOR UPDATE; \nBEGIN \n \n   \n     FOR emp_rec IN emp_cur LOOP \n        UPDATE employees \n        SET manager_id &#x3D; :new.manager_id \n        WHERE CURRENT OF emp_cur; \n     END LOOP; \n   \nEND; \nThis trigger will be executed only if the MANAGER_ID column of the DEPARTMENTS table is updated.Triggers that have this ability provide for better database performance, because the trigger is notexecuted each time the DEPARTMENTS table has been updated. \nHow It WorksTriggers can specify columns that must have their values updated in order to cause the trigger toexecute. This allows the developer to have finer-grained control over when the trigger executes. You cantake a few different strategies in order to cause a trigger to execute upon an update of a specifiedcolumn. As is demonstrated in the solution to this recipe, you can specify the column in the triggerdeclaration. This is one of the easiest approaches to take, and it causes the trigger to execute only if thatspecified column is updated. Alternatively, you can use a conditional predicate in the trigger body todetermine whether the row you had specified in the declaration is indeed being updated. A conditionalpredicate can be used along with a specified column name to determine whether a specified action isbeing performed on the named column. You can use three conditional predicates, INSERTING, UPDATING,and DELETING. Therefore, a conditional predicate such as the following can be used to determine whethera specified column is being updated by the current statement: \nIF UPDATING (&#39;my_column&#39;) THEN \n  -- Some statements \nEND IF; \n\nUsing a conditional predicate(vt.断定为) ensures that the code in the THEN clause is executed only if a specifiedaction is occurring against the named column. These predicates can also be used along with otherconditions to have finer-grained control over your statements. For instance, if you want to ensure that acolumn was being updated and also that the current date does not match some end date, then you cancombine those two conditions with an AND boolean operator. The following code demonstrates this typeof conditional statement: \nIF UPDATING (&#39;my_column&#39;) AND end_date &gt; SYSDATE THEN \n  -- Some statements \nEND IF; \n\nIf you prefer to use the technique demonstrated in the solution to this recipe, then you can stillcheck to ensure that the specified column is being updated by using the IF UPDATING predicate withoutthe column name specified. This technique would look like the following statement:\nIF UPDATING THEN \n  --some statements \nEND IF; \n\nAs mentioned in the solution to this recipe, specifying a specific column can help decrease theamount of times that the trigger is fired because it is executed only when the specified column has beenupdated. Another advantage to using this level of constraint within your triggers is that you can addmore triggers to the table if needed. For instance, if you needed to create another trigger to fire AFTERUPDATE on another column on the same table, then it would be possible to do so with less chance of aconflict. On the contrary(adj.相反的), if you were using a simple AFTER UPDATE trigger, then chances of a conflict aremore likely to occur. \nsummary:  \n\nthree types of update checking\n\n5-4. Making a View UpdatableProblemYou are working with a database view, and it needs to be updated. However, the view is not a simpleview and is therefore read-only. If you tried to update a column value on the view, then you wouldreceive an error. \nSolutionUse an INSTEAD OF trigger to specify the result of an update against the view, thus making the viewupdatable. For example, let’s begin with the following view definition: \nCREATE OR REPLACE VIEW EMP_JOB_VIEW AS \n  SELECT EMP.employee_ID, EMP.first_name, EMP.last_name, \n         EMP.email, JOB.job_title, \n         DEPT.department_name \n  FROM employees EMP, \n       jobs JOB, \n       departments DEPT \n  WHERE JOB.job_id &#x3D; EMP.job_id \n  AND DEPT.department_id &#x3D; EMP.department_id \n  ORDER BY EMP.last_name;  \n\nGiven the EMP_JOB_VIEW just shown, if you attempt to make an update to a column, then you willreceive an error. The following demonstrates the consequences of attempting to update theDEPARTMENT_NAME column of the view. \nSQL&gt; update emp_job_view \n  2  set department_name &#x3D; &#39;dept&#39; \n  3  where department_name &#x3D; &#39;Sales&#39;; \nwhere department_name &#x3D; &#39;Sales&#39; \n      * \nERROR at line 3: \nORA-01779: cannot modify a column which maps to a non key-preserved table \nHowever, using the INSTEAD OF clause, you can create a trigger to implement the logic for an UPDATEstatement issued against the view. Here’s an example:\nCREATE OR REPLACE TRIGGER update_emp_view \nINSTEAD OF UPDATE ON emp_job_view \nREFERENCING NEW AS NEW   -- note\nFOR EACH ROW \nDECLARE \n  emp_rec                        employees%ROWTYPE; \n \n  title                          jobs.job_title%TYPE; \n  dept_name                      departments.department_name%TYPE; \nBEGIN \n \n    SELECT * \n    INTO emp_rec \n    FROM employees \n    WHERE employee_id &#x3D; :new.employee_id; \n \n    UPDATE jobs \n    SET job_title &#x3D; :new.job_title \n    WHERE job_id &#x3D; emp_rec.job_id; \n \n    UPDATE departments \n    SET department_name &#x3D; :new.department_name \n    WHERE department_id &#x3D; emp_rec.department_id; \n     \n    UPDATE employees \n    SET email &#x3D; :new.email, \n    first_name &#x3D; :new.first_name, \n    last_name &#x3D; :new.last_name \n    WHERE employee_id &#x3D; :new.employee_id;\nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;No matching record exists&#39;); \nEND; \n\nThe following are the results of issuing an update on the view when the UPDATE_EMP_VIEW trigger is inplace. The UPDATE is issued, and the INSTEAD OF trigger executes instead of the database’s built-in logic.The result is that the rows containing a DEPARTMENT_NAME of Sales will be updated in the view. Hence, theunderlying(v.放在…的下面) row in the DEPARTMENTS table is updated to reflect the change.\nSQL&gt; update emp_job_view \n  2  set department_name &#x3D; &#39;Sales Dept&#39; \n  3  where department_name &#x3D; &#39;Sales&#39;; \n34 rows updated. \nIf you were to query the view after performing the update, then you would see that the view data hasbeen updated to reflect the requested change. If you read through the code in the trigger body, you cansee the magician behind the curtain(n.幕;窗帘).\nHow It WorksOftentimes it is beneficial to have access to view data via a trigger event. However, there are some viewsthat are read-only, and data manipulation(n.操纵;操作) is not allowed. Views that include any of the followingconstructs are not updatable and therefore require the use of an INSTEAD OF trigger for manipulation: \n•SET \n•DISTINCT \n•GROUP BY, ORDER BY, CONNECT BY \n•MODEL \n•START WITH \n•Subquery within a SELECT or containing the WITH READ ONLY clause \n•Collection expressions \n•Aggregate or analytic functions \nA trigger that has been created with the INSTEAD OF clause allows you to declare a view name to be actedupon, and then once the specified event occurs, the trigger is fired, which causes the actual INSERT,UPDATE, or DELETE statement to occur. The trigger body actually acts upon the real tables behind thescenes using the values that have been specified in the action.The format for the INSTEAD OF trigger is the same as any other trigger with the addition of theINSTEAD OF clause. You can see in the solution to this recipe that an additional clause has been specified,namely, REFERENCING NEW AS NEW. The REFERENCING clause can be used by triggers to specify how youwant to prefix :NEW or :OLD values. This allows you to use any alias for :NEW or :OLD, so it is possible toreference a new value using :blah.my_value if you used the following clause when you declared yourtrigger: \nREFERENCING NEW AS BLAH \n\nAlthough there is no real magic at work behind an INSTEAD OF trigger, they do abstract some of theimplementation details away from the typical user such that working with a view is no different fromworking with an actual table. \nsummary:  \n\n(the changes of view be reflected at basic table)\n\n5-5. Altering the Functionality of ApplicationsProblemYou want to modify a third-party application, but you are not in a position to change the source code.Either you are not allowed to change the source or you simply do not have access to make changes.As an example, let’s consider a form in one application used to create jobs within the JOBS table. Youwant to enhance the application so that mail is sent to all the administrative staff members when a newjob is created. However, your company does not own the license to modify the source code of theapplication.\nSolutionYou can often use triggers to add functionality to an application behind the scenes, without modifyingapplication code. Sometimes you have to think creatively to come up with a trigger or blend of triggersthat accomplishes your goal.You can solve our example problem by creating a trigger that will execute after an insert has been madeon the JOBS table. This trigger will obtain the information regarding the job that was just created andsend an e-mail containing that information to all administrative personnel. In the following trigger,some necessary information regarding the new job entry is obtained and processed by the SEND_EMAILprocedure, which in turn sends the mail.First, here is the code for the trigger: \nCREATE OR REPLACE TRIGGER send_job_alert \n  AFTER INSERT ON jobs \n  FOR EACH ROW \nDECLARE \n  to_address                    varchar2(50) :&#x3D; &#39;admin_list@mycompany.com&#39;; \n  v_subject                     varchar2(100) :&#x3D; &#39;New job created: &#39; || :new.job_title; \n  v_message                     varchar2(2000); \nBEGIN \n \n  v_message :&#x3D; &#39;There has been a new job created with an ID of &#39; || :new.job_id ||  \n               &#39; and a title of &#39; || :new.job_title || &#39;.  The salary range is: &#39; || \n               :new.min_salary || &#39; – &#39; || :new.max_salary; \n   -- Initiate the send_email procedure \n  SEND_EMAIL(to_address, v_subject,  v_message); \n               \nEND; \nNext is the stored procedure that actually sends the e-mail: \nCREATE OR REPLACE PROCEDURE send_email(to_address IN VARCHAR2, \n                                        subject IN VARCHAR2, \n                                        message IN VARCHAR2) AS \nBEGIN \n   UTL_MAIL.send(sender &#x3D;&gt; &#39;me@address.com&#39;, \n            recipients &#x3D;&gt; to_address, \n               subject &#x3D;&gt; subject, \n               message &#x3D;&gt; message, \n             mime_type &#x3D;&gt; &#39;text; charset&#x3D;us-ascii&#39;); \nEND; \n\nA trigger has the ability to call any other PL&#x2F;SQL named block as long as it is in the same schema orthe schema that contains the trigger has the correct privileges to access the named block in the otherschema. \nHow It Works\nThe ability to use triggers for altering third-party applications can be extremely beneficial. Using a DMLtrigger on INSERT, UPDATE, or DELETE of a particular table is a good way to control what occurs withapplication data once a database event occurs. This technique will be transparent to any applicationusers because the trigger would most likely be executed when the user saves a record via a button that isbuilt into the application. \nAlthough creating database triggers to alter functionality can be beneficial, you must also be carefulnot to create a trigger that will have an adverse effect on the application. For instance, if you create atrigger that updates some data that has been entered and the application is expecting to do somethingdifferent with the data, then the application may not work as expected. One way to remedy(vt.补救;治疗;纠正) this issuewould be to create an autonomous transaction. Autonomous transactions ensure that an applicationcontinues to run even if a dependent body of code fails. In this case, an autonomous transaction couldprevent a failed trigger from crashing an application. To learn more about using autonomoustransactions, please refer to Recipe 2-13. \nAnother issue that could arise is one where too many triggers are created on the same table for thesame event. You must be careful when creating triggers and be aware of all other triggers that will beexecuted during the same event. By default, Oracle does not fire triggers in any specific order, and theexecution order can vary each time the database event occurs. Do not create triggers that depend uponother triggers, because your application will eventually fail! If you must create two or more triggers thatexecute on the same table for the same event, then please ensure that you are using proper techniquesto make the triggers execute in the correct order. For more information on this topic, please refer toRecipe 5-11. \nThe trigger in this particular recipe called a stored procedure. This was done so that the trigger bodyperformed a specific task and remained concise. Triggers can call as many stored procedures asrequired, as long as the trigger itself is less than or equal to 32KB in size. The stored procedure in thesolution to this recipe is used to send an e-mail. As such, maintaining a separate procedure to performthe task of sending e-mail will allow the trigger body to remain concise, and the procedure can also beused elsewhere if needed.USING ORACLE’S UTL_MAIL PACKAGEThe e-mail in the solution to this recipe is sent using Oracle’s UTL_MAIL package. You will learn moreabout using this package in a later chapter, but for the purposes of testing this recipe, it is important toknow that the UTL_MAIL package is not enabled by default. To install it, you must log in as the SYS userand execute the utlmail.sql and prvtmail.plb scripts that reside within the$ORACLE_HOME/rdbms/admin directory.An outgoing mail server must also be defined by setting the SMTP_OUT_SERVER initialization parameterprior to use.\nsummary:  \n\nYou must be careful when creating triggers and be aware of all other triggers that will be executed during the same event,Do not create triggers that depend uponother triggers\ntriggers invoked no order\nUTL_MAIL PACKAGE is good tool send out mail\n\n5-6. Validating Input DataProblemYou want to validate data before allowing it to be inserted into a table. If the input data does not passyour business-rules test, you want the INSERT statement to fail. For example, you want to ensure that ane-mail address field in the EMPLOYEE table never contains the domain portion of an e-mail address, inother words, that it never contains the @ character or anything following the @ character. \n■ Note Recipe 5-7 presents an alternative solution to this same problem that involves silently cleansing erroneousdata as it is inserted.  \nSolutionGenerally speaking, do validation using BEFORE triggers, because that lets you trap(vt.诱捕;使…受限制) errors prior to changesbeing made to the data. For this recipe, you can write a BEFORE INSERT trigger to examine the e-mailaddress for any new employee. Raise an error if that address contains an @ character. The followingexample demonstrates a trigger that uses this technique. If an attempt to enter an invalid e-mail addressoccurs, an error will be raised. \nCREATE OR REPLACE TRIGGER check_email_address \nBEFORE INSERT ON employees \nFOR EACH ROW \nBEGIN \n  IF NOT INSTR(:new.email,&#39;@&#39;) &gt; 0 THEN \n    RAISE_APPLICATION_ERROR(-20001, &#39;INVALID EMAIL ADDRESS&#39;); \n  END IF; \nEND; \n\nHow It WorksA BEFORE INSERT trigger is useful for performing the validation of data before it is inserted into thedatabase. In the solution to this recipe, a trigger is created that will check to ensure that a string thatsupposedly(adv.可能;按照推测) contains an e-mail address does indeed have an @ character within it. The trigger uses theOracle built-in INSTR function inside a conditional statement to determine whether the @ characterexists. If the character does not exist within the string, then the trigger will raise a user-defined errormessage. On the other hand, if the string does contain the character, then the trigger will not doanything. Coding a trigger for validation of data is quite common. Although the solution to this recipe checksto ensure that an e-mail address is valid, you could write similar triggers to perform similar validation onother datatypes. \n5-7. Scrubbing(v.用力擦洗) Input DataProblemYou are interested in examining(检查) and correcting user input prior to it being inserted into a database table.  \nSolutionUse a BEFORE INSERT trigger to scrub the data prior to allowing it to be inserted into the table. By using atrigger, you will have access to the data before it is inserted, which will provide you with the ability toassess the data before it is persisted.In this particular example, a trigger is being used to examine the data that was entered on a form forinsertion into the EMPLOYEES table. The e-mail field is being validated to ensure that it is in a valid format.In particular, the e-mail field for the EMPLOYEES table includes only the address portion(n.部分;一份) to the left of the @symbol. This trigger ensures that even if someone had entered the entire e-mail address, then only thevalid portion would be inserted into the database. The following example demonstrates thisfunctionality: \nCREATE OR REPLACE TRIGGER check_email_address \nBEFORE INSERT ON employees \nFOR EACH ROW \nDECLARE \n  temp_email              employees.email%TYPE :&#x3D; :new.email; \nBEGIN \n  IF INSTR(temp_email,&#39;@&#39;) &gt; 0 THEN \n    temp_email :&#x3D; SUBSTR(:new.email, 0, INSTR(temp_email, &#39;@&#39;)-1); \n  END IF; \n :new.email :&#x3D; temp_email; \nEND; \n\nThe trigger in this example uses a couple of different PL&#x2F;SQL built-in functions to ensure that thedata being inserted into the EMPLOYEES.EMAIL table is formatted correctly.\nHow It Works\nBEFORE INSERT triggers work very nicely for verifying data prior to inserting it into the database. Sinceinsert triggers have access to the :NEW qualifier, the values that are going to be inserted into the databasetable can be tested to ensure that they conform(vi.符合;遵照) to the proper standards and can then be manipulated(v.操作) ifneed be. When used in a BEFORE trigger, the :NEW value can be altered, allowing triggers to change valuesprior to when they are inserted. The :OLD qualifier will allow one to access the NULL old values, but theycannot be changed. \nValidating data with triggers can be very useful if used appropriately. As a rule of thumb, you shouldnot attempt to create triggers for validating data that can be performed declaratively. For instance, if youneed to ensure that a column of data is never NULL, then you should place a NOT NULL constraint on thatcolumn.There are only a couple of circumstances where you are required to enforce(vt. 实施，执行；强迫，强制) constraints withintriggers, and those are as follows:• If you do not have access to the database objects to alter the table and add constraints because doing so would cause issues with a program that is in place• If the business logic cannot be reflected in a simple, declarative trigger• If your application requires a constraint to be enforced only part of the time\nIn all other circumstances, try to use database-level constraints because that is their job, and it canbe done much more efficiently than using a trigger. However, trigger validation is perfect for situationssuch as those depicted in the solution to this recipe, where complex business rules must be validatedthat are not possible with built-in constraints.\nsummary:  \n\nabove three rules must be clear\nINSTR‘s functionality\ntry to use database-level constraints because that is their job, and it can be done much more efficiently than using a trigger\n\n5-8. Replacing a Column’s ValueProblemYou want to verify that a column value is in the correct format when it is entered into the database.  If itis not in the correct format, then you want to adjust the value so that it is in the correct format beforeinserting into the database. For example, upon creation of an employee record, it is essential that the e-mail address follows a certain format.  If the e-mail address is not uniform with other employee e-mailaddresses, then it needs to be adjusted.  You want to write a trigger that ensures that the new employeeEMAIL value will be in the correct format. \nSolutionCheck the format using a BEFORE trigger. For this recipe, use a BEFORE INSERT trigger to determinewhether the new EMAIL value is in the correct format.  If it is not, then adjust the value accordingly so thatthe new e-mail address will start with the first letter of the employee’s first name, followed by theemployee’s last name.  If the new e-mail address is not unique, then a number must be added to the endof it to ensure that it will be unique.The following trigger demonstrates a BEFORE INSERT trigger that checks and updates the EMAIL valueas described. This trigger will be fired whenever someone inserts values into the EMPLOYEES table. \nCREATE OR REPLACE TRIGGER populate_emp_email \nBEFORE INSERT ON employees \nFOR EACH ROW \nDECLARE \n  email_count          NUMBER :&#x3D; 0; \n  success_flag         BOOLEAN :&#x3D; FALSE; \n  temp_email           employees.email%TYPE; \n  email_idx            NUMBER :&#x3D; 0; \nBEGIN \n  -- check to see if the email address is in the correct format \n  IF :new.email !&#x3D; UPPER(SUBSTR(:new.first_name,0,1) || :new.last_name) THEN   --- more like linux style\n    -- check the database to ensure that the new email address will be unique \n    temp_email :&#x3D; UPPER(SUBSTR(:new.first_name,0,1) || :new.last_name); \n    WHILE success_flag &#x3D; FALSE LOOP \n        SELECT COUNT(*) \n        INTO email_count \n        FROM employees \n        WHERE email &#x3D; temp_email; \n         \n        -- if it is unique then end the loop \n        IF email_count &#x3D; 0 THEN \n          success_flag :&#x3D; TRUE; \n        -- if not unique, then add the index number to the end and check again \n        ELSE \n          temp_email :&#x3D; UPPER(SUBSTR(:new.first_name,0,1) || :new.last_name) || email_idx; \n        END IF; \n        email_idx :&#x3D; email_idx + 1; \n    END LOOP; \n    :new.email :&#x3D; temp_email; \n  END IF; \n \nEND; \n\nThe value of the e-mail address must always follow the same format, and this trigger ensures thatthe any new EMAIL values will follow that format. If the new EMAIL value does follow the correct format,then it will be inserted into the database without changes, but if it does not follow the correct format,then this trigger will adjust the value accordingly. \nHow It WorksAnother frequent usage of triggers is to replace a value that someone is trying to insert into the databasewith some other value. Much like ensuring data integrity, you must write to the :NEW qualifier value inorder to replace another value that was entered. When the :NEW value is overwritten, then that new valueis inserted into the database instead of the original value. The BEFORE trigger acts as an interceptor wherethe values that are entered are intercepted prior to reaching the database table. The trigger has full reignto change values as needed as long as the values that are changed by the trigger still maintain thenecessary requirements to meet the database table constraints that have been defined.Any DML trigger can include multiple trigger events, including INSERT, UPDATE, or DELETE events. Anycombination of these three events can be used to fire a trigger. The events that are to be used for firing atrigger must be listed with the OR keyword between them. The following line of code is an example ofusing all three events on a BEFORE trigger: \nBEFORE INSERT OR UPDATE OR DELETE ON employees \n\nThe events can be in any order within the BEFORE clause. Any combination of these three events canalso be used with the AFTER trigger. The main difference between the BEFORE and AFTER triggers is whattype of access each has to the :NEW and :OLD qualifiers. Table 4-1 lists the different types of triggers andtheir subsequent access to the qualifiers.Table 4-1. \nTrigger Types and Qualifier Acccess \nTrigger Type :NEW :OLD \nBEFORE Writeable Always contains NULL \nAFTER Not writeable  Always contains populated values \nINSERT Contains values  Contains NULL \nDELETE Contains NULL  Contains populated values \nUPDATE Contains populated values Contains populated values \n\nA BEFORE trigger has write access to values using the :NEW qualifier, and AFTER triggers do not sincethe data has already been inserted or updated in the table. INSERT triggers have meaningful access tovalues with the :NEW qualifier only; variables using the :OLD qualifier will be NULL. UPDATE triggers havemeaningful access to values using both the :NEW and :OLD qualifiers. DELETE triggers have meaningfulaccess only to values using the :old qualifier; values using the :new qualifier will be NULL.Performing tasks such as replacing values with triggers should be used only on an as-needed basis.This type of trigger can cause confusion for those who do not have access to the trigger code. It is alsoimportant to ensure that triggers do not act upon each other in order to avoid mutating table errors. Thiscan occur if one trigger is updating the values of a table and another trigger is attempting to examine thevalues of the table at the same time.\nsummary:  \n\nBEFORE trigger has write access,  AFTER triggers do not\nDELETE triggers have meaningful access only to values using the :old qualifier; values using the :new qualifier will be NULL\nINSERT triggers have meaningful access to values with the :NEW qualifier only; variables using the :OLD qualifier will be NULL\nUPDATE triggers have meaningful access to values using both the :NEW and :OLD qualifiers\n\n5-9. Triggering on a System EventProblemYou want to write a trigger that executes on a system event such as a login. For example, you want toincrease security a bit for your database and ensure that users are logging into the database only duringthe week. In an effort to help control security, you want to receive an e-mail alert if someone logs intothe database on the weekend. \nSolutionCreate a system-level trigger that will log an event into a table if anyone logs into the database during off-hours. To notify you as promptly as possible, it may also be a good idea to send an e-mail when thisevent occurs. To create a system-level trigger, use the AFTER LOGON ON DATABASE clause in your triggerdefinition.The first step in creating this solution is to create an audit table. In the audit table you will want tocapture the IP address of the user’s machine, the time and date of the login, and the authenticatedusername. The following code will create a table to hold this information: \nCREATE TABLE login_audit_table( \nID                        NUMBER PRIMARY KEY,   -- Populated by sequence number \nlogin_audit_seq \nAUDIT_DATE                DATE NOT NULL, \nAUDIT_USER          VARCHAR2(50) NOT NULL, \nAUDIT_IP            VARCHAR2(50) NOT NULL, \nAUDIT_HOST          VARCHAR2(50) NOT NULL); \nNow that the auditing table has been created, it is time to create the trigger. The following codedemonstrates the creation of a logon trigger: \nCREATE OR REPLACE TRIGGER login_audit_event \nAFTER LOGON ON DATABASE \nDECLARE \n  v_subject                      VARCHAR2(100) :&#x3D; &#39;User login audit event triggered&#39;; \n  v_message                      VARCHAR2(1000); \nBEGIN \n  INSERT INTO login_audit_table values( \n    Login_audit_seq.nextval, \n    Sysdate, \n    SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USERID&#39;), \n    SYS_CONTEXT(&#39;USERENV&#39;,&#39;IP_ADDRESS&#39;), \n    SYS_CONTEXT(&#39;USERENV&#39;,&#39;HOST&#39;)); \n    v_message :&#x3D; &#39;User &#39; || SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USERID&#39;) || \n                           &#39; logged into the database at &#39; || sysdate || &#39; from host &#39; ||  \n                SYS_CONTEXT(&#39;USERENV&#39;,&#39;HOST&#39;); \n \n \n    SEND_email(&#39;DBA-GROUP@mycompany.com&#39;, \n                        v_subject, \n                        v_message); \n \nEND; \n\nThis simple trigger will fire each time someone logs into the database. To reduce the overhead ofthis trigger being initiated during normal business hours, this trigger should be disabled during normalbusiness hours. It is possible to create a stored procedure that disables and enables the trigger and thenschedule that procedure to be executed at certain times. However, if there are only a few users who willbe logging into the database each day, then trigger controls such as these are not necessary. \nHow It WorksTriggers are a great way to audit system events on a database. There are several types of system triggers: \n• AFTER STARTUP \n• BEFORE SHUTDOWN \n• AFTER LOGON \n• BEFORE LOGOFF \n• AFTER SUSPEND \n• AFTER SERVERERROR \n• AFTER DB_ROLE_CHANGE \nEach of these system events can be correlated to a trigger when the trigger includes the ON DATABASEclause, as shown here: \nCREATE OR REPLACE system_trigger \ntrigger_type ON DATABASE \n…   \nSystem triggers fire once for each correlating system event that occurs. Therefore, if there is a systemtrigger defined for both the LOGON and LOGOFF events, each will be fired one time for every user who logsonto or off the database. System triggers are excellent tools for helping audit database system events.Notice that the different system events have access only to certain types of events. For instance, STARTUPtriggers can be fired only after the event occurs. This is because the Oracle Database is not availablebefore STARTUP, so it would be impossible to fire a trigger beforehand. Similarly, SHUTDOWN triggers haveaccess to the BEFORE event only because the database is unavailable after SHUTDOWN.In the solution to this recipe, the trigger is intended to execute once after each login to the database.The trigger will insert some values from the current session into an auditing table, and it will send an e-mail to the DBA group. It should be noted that Oracle Database provides some auditing capabilities toperform similar activities right out of the box. In fact, Oracle 11g turns on auditing by default for everydatabase. However, the auditing options that are available via Oracle do not allow for sending e-mail asour solution does. You may prefer to use Oracle’s internal auditing features for storing the audit trail andcombine them with auditing triggers such as the one in this recipe for simply sending an e-mail whenthe event occurs.The SERVERERROR event is fired whenever an Oracle server error occurs. The SERVERERROR event canbe useful for detecting user SQL errors or logging system errors. However, there are a few cases in whichan Oracle server error does not trigger this event. Those Oracle errors are as follows: \n• ORA-01403:  No data found \n• ORA-01422:  Exact fetch returns more than requested number of rows \n• ORA-01423:  Error encountered while checking for extra rows in exact fetch \n• ORA-01034:  ORACLE not available \n• ORA-04030:  Out of process memory when trying to allocate bytes \nSystem event triggers can assist a DBA in administration of the database. These triggers can alsohelp developers if SQL errors are triggering SERVERERROR events and notifying of possible SQL problemsin the application. \nsummary:  \n\nSystem triggers are excellent tools for helping audit database system events\nthe different system events have access only to certain types of events\nSHUTDOWN triggers have access to the BEFORE event only because the database is unavailable after SHUTDOWN\noracle contains itself audit subsystem that us powerful\n\n5-10. Triggering on a Schema-Related EventProblemYou want to trigger on an event related to a change in a database schema. For example, if someone dropsa database table on accident, it could cause much time and grief attempting to restore and recover datato its original state. Rather than doing so, you want to place a control mechanism into the database thatwill ensure that administrators cannot delete essential tables. \nSolutionUse a PL&#x2F;SQL database trigger to raise an exception and send an alert to the DBA if someone attempts todrop a table. This will prevent any tables from inadvertently being dropped, and it will also allow theadministrator to know whether someone is potentially trying to drop tables. \nCREATE OR REPLACE TRIGGER ddl_trigger\nBEFORE CREATE OR ALTER OR DROP \nON SCHEMA \nDECLARE \n  evt              VARCHAR2(2000); \n  v_subject        VARCHAR2(100) :&#x3D; &#39;Drop table attempt&#39;; \n  v_message        VARCHAR2(1000);\nBEGIN \n  SELECT ora_sysevent \n  INTO evt \n  FROM dual; \n  IF evt &#x3D; &#39;DROP&#39; THEN \n   RAISE_APPLICATION_ERROR(-20900, &#39;UNABLE TO DROP TABLE, &#39; || \n           &#39;EVENT HAS BEEN LOGGED&#39;); \n  END IF; \n  v_message :&#x3D; &#39;Table drop attempted by: &#39;||  \n    SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USERID&#39;); \n  SEND_EMAIL(&#39;DBA-GROUP@mycompany.com&#39;, \n             v_subject, \n             v_message);\nEND;\nIn this situation, both the user who attempts to drop the table and the members of the DBA-GROUPmailing list will be notified. \nHow It WorksYou can use triggers to log or prevent certain database activities from occurring. In this recipe, you sawhow to create a trigger that will prevent a table from being dropped. The trigger will be executed prior toany CREATE, ALTER, or DROP within the current schema. Within the body of the trigger, the event is checkedto see whether it is a DROP, and actions are taken if so.■ Note To be even more fine-grained, it is possible to specify a particular schema for the trigger to use.  Doing sowould look like the following: \nBEFORE CREATE ALTER OR DROP ON HR.SCHEMA \n… \n\nThere are several other DDL trigger operations that can be used to help administer a database orapplication. The following are these operations along with the type of trigger that can be used with it: \nBEFORE &#x2F; AFTER ALTER \nBEFORE &#x2F; AFTER ANALYZE \nBEFORE &#x2F; AFTER ASSOCIATE STATISTICS \nBEFORE &#x2F; AFTER AUDIT \nBEFORE &#x2F; AFTER COMMENT \nBEFORE &#x2F; AFTER CREATE \nBEFORE &#x2F; AFTER DDL \nBEFORE &#x2F; AFTER DISASSOCIATE STATISTICS \nBEFORE &#x2F; AFTER DROP \nBEFORE &#x2F; AFTER GRANT \nBEFORE &#x2F; AFTER NOAUDIT \nBEFORE &#x2F; AFTER RENAME \nBEFORE &#x2F; AFTER REVOKE \nBEFORE &#x2F; AFTER TRUNCATE \nAFTER SUSPEND \n\nAll DDL triggers can be fired using either BEFORE or AFTER event types. In most cases, triggers that arefired before a DDL event occurs are used to prevent the event from happening. On the other hand,triggers that are fired after an event occurs usually log information or send an e-mail. In the solution tothis recipe, a combination of those two situations exists. The BEFORE event type was used because thetrigger is being used to prevent the tables from being dropped. However, logging or e-mailing can alsooccur to advise interested parties of the event. Typically a logging event occurs with an AFTER trigger sothat the event has already occurred and the database is in a consistent state prior to the logging. \n5-11. Firing Two Triggers on the Same EventProblemThere is a requirement to create a trigger to enter the SYSDATE into the HIRE_DATE column of theLOCATIONS table. However, there is already a trigger in place that is fired BEFORE INSERT on the table, andyou do not want the two triggers to conflict. \nSolutionUse the FOLLOWS clause to ensure the ordering of the execution of the triggers. The following exampleshows the creation of two triggers that are to be executed BEFORE INSERT on the EMPLOYEES table.First, we’ll create a trigger to verify that a new employee’s salary falls within range: \nCREATE OR REPLACE TRIGGER verify_emp_salary \nBEFORE INSERT ON employees \nFOR EACH ROW \nDECLARE \n  v_min_sal     jobs.min_salary%TYPE; \n  v_max_sal     jobs.max_salary%TYPE; \nBEGIN \n  SELECT min_salary, max_salary \n  INTO v_min_sal, v_max_sal \n  FROM JOBS \n  WHERE JOB_ID &#x3D; :new.JOB_ID; \n \n  IF :new.salary &gt; v_max_sal THEN \n    RAISE_APPLICATION_ERROR(-20901, \n       &#39;You cannot give a salary greater than the max in this category&#39;); \n  ELSIF :new.salary &lt; v_min_sal THEN \n    RAISE_APPLICATION_ERROR(-20902, \n       &#39;You cannot give a salary less than the min in this category&#39;); \n  END IF; \nEND; \nNext, you’ll create a trigger to force the hire date to be the current date: \nCREATE or REPLACE TRIGGER populate_hire_date \nBEFORE INSERT \n    ON employees \n    FOR EACH ROW \nFOLLOWS verify_emp_salary \nDECLARE \nBEGIN \n    :new.hire_date :&#x3D; sysdate; \nEND; \nSince it does not make sense to change the hire date if the record will not be inserted, you want theVERIFY_EMP_SALARY trigger to fire first. The FOLLOWS clause in the POPULATE_HIRE_DATE trigger ensures thatthis will be the case. \nHow It WorksOracle 11g introduced the FOLLOWS clause into the Oracle trigger that allows you to specify the ordering inwhich triggers should execute. The FOLLOWS clause specifies the trigger that should fire prior to the triggerbeing created. In other words, if you specify the FOLLOWS clause when creating a trigger, then you shouldname a trigger that you want to have executed prior to your new trigger. Hence, if you specify a trigger inthe FOLLOWS clause that does not already exist, you will receive a compile error. \n■ Note The PRECEDES(v.领先(precede的三单形式);在…之先) clause was introduced in Oracle 11g as well. You can use this clause to specify theopposite situation that is resolved using the FOLLOWS clause. If you specify PRECEDES instead of FOLLOWS, then thetrigger being created will fire prior to the trigger that you specify after the PRECEDES clause.By default, Oracle triggers fire in any arbitrary ordering. In the past, there was no way to guaranteethe order in which triggers were to be executed. The addition of the FOLLOWS clause now allows you to doso. However, it is important that you do not make triggers dependent upon each other. Doing so couldcause issues of one of the triggers were to be dropped for some reason. It is bad design to create a triggerthat depends on the successful completion of another trigger, so the FOLLOWS clause should be used onlyin situations where there is no dependency. \nsummary:  \n\nif you wanna make sure two triggers keep up order to be executed, please use follow clause\ndependent triggers is bad design\n\n5-12. Creating a Trigger That Fires on Multiple EventsProblemYou have logic that is very similar for two different events. Thus, you want to combine that logic into asingle trigger that fires for both. For example, let’s assume that we want to create a single trigger on theEMPLOYEES table with code to fire after each row that is inserted or modified and also with code to fire atthe end of each of those statements’ executions. \nSolutionUse a compound(adj.复合的;混合的) trigger to combine all the triggers into a single body of code. The trigger in this solutionwill execute based upon various timing points. It will execute AFTER EACH ROW in the EMPLOYEES table hasbeen updated, as well as AFTER the entire update statement has been executed. The AFTER EACH ROWsection of the trigger will audit the inserts and updates made on the table, and the AFTER STATEMENTsection of the trigger will send notification to the DBA regarding audits that have occurred on the table.The following code shows the creation of a compound trigger that comprises(vt.包含;由…组成) each of these twotriggers into one body of code: \nCREATE OR REPLACE TRIGGER emp_table_auditing \n  FOR INSERT OR UPDATE ON employees \n    COMPOUND TRIGGER \n  -- Global variable section \n  table_upd_count       NUMBER :&#x3D; 0; \n  table_id_start        employees.employee_id%TYPE; \n \n  AFTER EACH ROW IS \n  BEGIN \n    SELECT MAX(employee_id) \n    INTO table_id_start \n    FROM employees; \n \n    IF INSERTING THEN \n      \n      INSERT INTO update_access_log VALUES( \n        update_access_seq.nextval, \n        SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), \n        sysdate, \n        NULL, \n        :new.salary, \n        &#39;EMPLOYEES - INSERT&#39;, \n        &#39;SALARY&#39;); \n      table_upd_count :&#x3D; table_upd_count + 1; \n \n \n    ELSIF UPDATING THEN \n      IF :old.salary !&#x3D; :new.salary THEN \n        INSERT INTO update_access_log VALUES( \n          update_access_seq.nextval, \n          SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), \n          sysdate, \n          :old.salary, \n          :new.salary, \n          &#39;EMPLOYEES - UPDATE&#39;, \n          &#39;SALARY&#39;); \n        table_upd_count :&#x3D; table_upd_count + 1; \n      END IF; \n    END IF;    \n \n  END AFTER EACH ROW; \n \n  AFTER STATEMENT IS \n    v_subject                     VARCHAR2(100) :&#x3D; &#39;Employee Table Update&#39;; \n    v_message                     VARCHAR2(2000); \n  BEGIN \n         \n    v_message :&#x3D; &#39;There have been &#39; || table_upd_count || \n     &#39; changes made to the employee table starting with ID #&#39; || \n     table_id_start; \n \n    SEND_EMAIL(&#39;DBA-GROUP@my_company.com&#39;, \n               v_subject, \n               v_message); \n  END AFTER STATEMENT; \n \nEND emp_table_auditing; \n\nThe insert and update events are audited via the trigger that is coded using the AFTER EACH ROWclause, and then the AFTER STATEMENT trigger sends a notification to alert the DBA of each audit. The twotriggers share a global variable that is declared prior to the code for the first trigger. \nHow It Works\nPrior to Oracle 11g, there was no easy way to create multiple triggers that were able to share the same globalvariable. The compound trigger was introduced with the release of Oracle 11g, and it allows multiple triggers forthe same table to be embodied within a single trigger. Compound triggers allow you to code different timingpoints within the same trigger; those different events are as follows in logical execution order: \n• BEFORE STATEMENT \n• BEFORE EACH ROW \n• AFTER EACH ROW \n• AFTER STATEMENT \nEach of these timing points allows for the declaration of different trigger execution points. Using acompound trigger allows you to create a trigger that performs some actions: BEFORE INSERT on a tableand AFTER INSERT on a table all within the same trigger body. In the case of the solution to this recipe, anAFTER UPDATE trigger is coded within the same compound trigger as an AFTER STATEMENT trigger. Thelogical order of execution allows you to code triggers that depend upon others using this technique. Inother recipes within this chapter, you have learned that it is not good programming practice to codetriggers that depend upon each other. This is mainly because if one trigger is invalidated or dropped,then the other trigger that depends on it will automatically be invalidated. Since a compound trigger isone body of code, either the entire trigger is valid or invalid. Therefore, the failure points between twotrigger bodies are removed.In the solution, the AFTER STATEMENT trigger depends upon the AFTER EACH ROW trigger. If the AFTEREACH ROW trigger does not audit anything, then the AFTER STATEMENT trigger will still fire, but it will sendan e-mail that signifies zero rows have been changed. The two trigger bodies are able to share access toglobal variables, types, and cursors via the use of the global declaration section. Anything declaredwithin this section is visible to all triggers within the compound trigger body, so in the case of thissolution, you can use the first AFTER EACH ROW to update the value of the global variable, which is then inturn used within the AFTER STATEMENT trigger. The overall compound trigger structure is as follows: \nCREATE OR REPLACE TRIGGER trigger_name \n   FOR trigger_action ON table_name \n     COMPOUND TRIGGER \n    -- Global declaration section \n   global_variable VARCHAR2(10); \n  BEFORE STATEMENT IS \n  BEGIN \n     NULL; \n -- Statements go here. \n  END BEFORE STATEMENT; \n  \n  BEFORE EACH ROW IS \n  BEGIN \n    NULL; \n-- Statements go here.   \n  END BEFORE EACH ROW; \n  \n  AFTER EACH ROW IS  \n  BEGIN \n     NULL; \n-- Statements go here. \n  END AFTER EACH ROW; \n  \n  AFTER STATEMENT IS \n  BEGIN \n    NULL; \n -- Statements go here. \n  END AFTER STATEMENT; \n  \n  END trigger_name;  \nCompound triggers can be very useful for incorporating several different timed(different stage data change) events on the samedatabase table. Not only do they allow for easier maintenance because all code resides within one triggerbody, but they also allow for shared variables among the trigger events as well as more robustdependency management. \n5-13. Creating a Trigger in a Disabled StateProblemAfter a planning meeting, your company has decided that it would be a great idea to create a trigger tosend notification of updates to employee salaries. Since the trigger will be tied into the system-wide kdatabase application, you want to ensure that it compiles before enabling it so that it will not affect therest of the application.  \nSolutionCreate a trigger that is in a disabled state by default. This will afford you the opportunity to ensure thatthe trigger has compiled successfully before you enable it. Use the new DISABLE clause to ensure thatyour trigger is in DISABLED state by default.The following trigger sends messages to employees when their salary is changed. The trigger isdisabled by default to ensure that the application is not adversely affected if there is a compilation error. \nCREATE OR REPLACE TRIGGER send_salary_notice \nAFTER UPDATE OF SALARY ON employees \nFOR EACH ROW \nDISABLE \nDECLARE \n  v_subject     VARCHAR2(100) :&#x3D; &#39;Salary Update Has Occurrred&#39;; \n  v_message     VARCHAR2(2000); \nBEGIN \n  v_message :&#x3D; &#39;Your salary has been increased from &#39; || \n             :old.salary || &#39; to &#39; || :new.salary || &#39;.&#39;  || \n             &#39;If you have any questions or complaints, please &#39; || \n             &#39;do not contact the DBA.&#39;; \n \n  SEND_EMAIL(:new.email || &#39;@mycompany.com&#39;, \n             v_subject, \n             v_message); \nEND;   \nOn an annual basis, this trigger can be enabled via the following syntax: \nALTER TRIGGER send_salary_notice ENABLE; \n\nIt can then be disabled again using the same syntax: \nALTER TRIGGER send_salary_notice DISABLE; \n\nHow It WorksAnother welcome new feature with Oracle 11g is the ability to create triggers that are DISABLED by default.The syntax for creating a trigger in this fashion is as follows: \nCREATE OR REPLACE TRIGGER trigger_name \nON UPDATE OR INSERT OR DELETION OF table_name \n[FOR EACH ROW] \nDISABLED \nDECLARE \n  -- Declarations go here. \nBEGIN \n  -- Statements go here. \nEND; \nThe new DISABLED clause is used upon creation of a trigger. By default, a trigger is ENABLED by creation,and this clause allows for the opposite to hold true. \n6.Type ConversionType conversion takes place in almost every PL&#x2F;SQL program. It is important to know how to convertfrom one datatype to another so that your applications can contain more versatility. Not only aredatatype conversions important to developers, but they can also be a godsend to databaseadministrators. Type conversion can occur when moving data around from one table to another. It isalso very common when obtaining data from input forms and performing calculations upon it.Whatever your use may be, this chapter will get you headed into the right direction with a handful ofuseful recipes. If your application works with dates or numbers, you will most likely find this chapteruseful. There are two forms of datatype conversion: explicit conversion and implicit conversion. Explicitdatatype conversion is what you will learn about in the following recipes. Using explicit conversion, youtell Oracle how you want types to be converted. Implicit conversion is automatically performed byOracle. There are many datatypes that can be converted using implicit type conversion. However, it isnot recommended that you rely on implicit conversion, because you never know exactly how Oracle willconvert something. The recipes in this chapter will show you more reliable explicit conversiontechniques that will give you the ability to convert types in such a way that your application will be rocksolid. \n6-1. Converting a String to a NumberProblemYou need to convert some strings into numbers. For instance, your application contains several stringsthat are entered via a user input screen. These strings need to be converted into numbers so that theycan be used to perform calculations.SolutionUse the TO_NUMBER function to explicitly convert the VARCHAR2 field into a NUMBER. The following examplesdemonstrate the use of TO_NUMBER by showing how to convert some currency values taken from the userinterface into numbers for storage in the database.The first example demonstrates the conversion of a variable with a datatype of VARCHAR2 into aNUMBER: \nDECLARE  in_dollars              VARCHAR2(10) :&#x3D; &amp;dollars;  dollars_formatted  NUMBER;BEGIN  – Assume that IN_DOLLARS is the user input in VARCHAR2 format  dollars_formatted :&#x3D; TO_NUMBER(in_dollars, ‘9G999D99’);  DBMS_OUTPUT.PUT_LINE(dollars_formatted);CHAPTER 6  TYPE CONVERSION120END;The TO_NUMBER function returns a number from a VARCHAR2 format. The previous exampledemonstrates the typical usage of this function.How It WorksThe TO_NUMBER function provides an explicit way to convert strings into NUMBER format in PL&#x2F;SQL.Although most string to NUMBER conversion is implicit via Oracle Database, it is always a best practice toexplicitly use the TO_NUMBER function to ensure that your code will not break at some point in the future.The format for using the function is as follows:TO_NUMBER(expression [, format [, ‘nls’ ] ])The expression can be a value of type BINARY_DOUBLE, CHAR, VARCHAR2, NCHAR, or NVARCHAR2. Theoptional format is a mask that can be used to help format the expression value into a number. The maskis a string of characters that represents the format of the string value that is contained in the expressionvalue. Table 6-1 shows the most commonly used format mask characters:Table 6-1. Common Formatting Mask CharactersCharacter Description9 Represents a numeric characterDRepresents a decimal pointGRepresents a commaAlthough the use of a formatting mask is optional, it is a good idea to include it if you know theformat of the string. Doing so will help Oracle convert your value into a number more accurately. Lastly,you can use the optional nls settings to set the NLS_LANGUAGE that is to be used to convert the string, theNLS_CURRENCY, or any of the other NLS session parameters. Use of the nls parameter is not very common.■ Note For a complete listing of available session NLS parameters, issue the following query: SELECT * FROMNLS_SESSION_PARAMETERS.It is also possible to convert strings into numbers using the CAST function. However, for direct stringto number conversion, the TO_NUMBER function is the best tool for the job since it is straightforward andeasy to maintain. For more information on the CAST function, please take a look at Recipe 6-5.  CHAPTER 6  TYPE CONVERSION1216-2. Converting a String to a DateProblemYou need to convert some strings into DATE types. Let’s say you have a requirement to insert date typesinto a database table column from one of your applications. The user is allowed to enter a date usingyour application’s web page, but it is in a string format after the user submits the page. You need toconvert this date from a string to a date type.SolutionUse the TO_DATE function to convert the string values into the DATE type. This will allow your applicationto accept the date string in any format and convert it to a DATE type for you. The next example shows howto use the TO_DATE function: \nmy_val      DATE :&#x3D; TO_DATE(‘06&#x2F;12&#x2F;2010’,’MM&#x2F;DD&#x2F;YYYY’); \nYou can convert the string through assignment, as shown in the preceding example, or directlywithin a query, as shown in the next example: \nSELECT TO_DATE(‘December 31, 2010’, ‘Month DD, YYYY’) FROM DUAL; \nAs you can see, it is possible to convert multiple string formats into DATE types.How It WorksThe TO_DATE function is arguably the most widely used conversion function in Oracle. Whether you areusing the function to convert dates for proper formatting within a SQL query or you are accepting andconverting user input, this function is extremely helpful for getting your data into the Oracle DATEformat. The syntax for using this function is as follows: \nTO_DATE(expression[, format[,’nls’]]) \nThe syntax is much like that of the other Oracle conversion functions in that it accepts a requiredexpression or string and two optional parameters. The optional format is used to specify the format ofthe string and to assist Oracle in converting the value into a DATE type. Table 6-2 shows many of the morecommon characters that can be used to specify the date format. See the Oracle SQL Reference for acomplete list of formatting characters.Table 6-2. Date Formatting CharactersCharacter DescriptionMM Represents the numeric month.MON Represents an abbreviated month name.MONTH Represents the entire month name.CHAPTER 6  TYPE CONVERSION122Character DescriptionDD Represents the numeric day of the month.DY Abbreviation representing the day of the week.YY Represents the two-digit year.YYYY Represents the four-digit year.RR Represents the rounded two-digit year. The year is rounded in the range 1950 to 2049 toassist with two-digit years such as 10. A two-digit year less than 50 will result in a four-digit year such as 2010.AM or PM  Represents the meridian indicator.HH Represents the hour of the day in 12-hour time format.HH24 Represents the hour of the day in 24-hour time format.MI Represents the minutes in time.SS Represents the seconds in time. \nThe standard, or default, date format in Oracle is DD-MON-YY, though your database administratordoes have the ability to change that default format. If you want to convert a string that is in the defaultformat into a DATE type, then the mask is not required. The following example demonstrates thiscapability: \nTO_DATE(‘27-MAY-10’); \nOn the contrary, if you want to convert a string that is in a format that is different from the standard,then you must make use of a mask. The solution to this recipe depicts this type of behavior. Dates arealso in care of time in Oracle, so if you want to display the time in your date, then it is possible to do sousing the proper format mask. The following conversion will include both the date and the time: \n TO_DATE(‘05&#x2F;25&#x2F;2010 07:35AM’,’MM&#x2F;DD&#x2F;YYYY HH:MIAM’) \nThe TO_DATE conversion function is most often used when inserting or updating data. If you have atable column that has a DATE type, then you cannot place a string into that column unless it is in thestandard date format. To get the data from an entry screen into the database, the TO_DATE function isusually used to convert the string into a date while the value is being inserted or updated.It is also possible to convert strings to dates using the CAST function. For more information on theuse of the CAST function, please see Recipe 6-5.  CHAPTER 6  TYPE CONVERSION1236-3. Converting a Number to a StringProblemYou need to alter some numbers into a currency format for display. Given a set of numbers, yourapplication will perform a calculation and then convert the outcome into currency format, which will bea string type.SolutionUse the TO_CHAR conversion function to obtain a nicely formatted currency string. The following codeblock accepts a number, performs a calculation, and then converts the number to a string: \nCREATE OR REPLACE FUNCTION CALCULATE_BILL(bill_amount IN NUMBER) RETURN VARCHAR2 AS  tax                     NUMBER  :&#x3D; .12;  tip                     NUMBER  :&#x3D; .2;  total_bill              NUMBER  :&#x3D; 0;BEGIN  total_bill :&#x3D; bill_amount + (bill_amount * tax);  total_bill :&#x3D; total_bill + (total_bill * tip);  return to_char(total_bill, ‘$999.00’);END; \nWhen a bill amount is passed to the CALCULATE_BILL function, a nicely formatted dollar amount willbe returned. If you were to pass 24.75 to the function, it would return $33.26.How It WorksThe TO_CHAR function works much like the other Oracle TO_ conversion functions in that it accepts anumber value along with an optional format mask and nls language value. Table 6-3 describes the morecommonly used formatting mask characters for numbers.Table 6-3. Common Formatting Mask CharactersCharacter Description9 Represents a numeric character that displays only if a value is present. Represents a decimal point, Represents a comma$ Represents a dollar sign0 Represents a numeric character that will always display, even if null \nAs you can see from the solution to this recipe, the format mask of $999.00 is chosen. Why not usethe mask of $999.99 for the conversion? By using the 0 instead of the 9, you ensure that the cents valueCHAPTER 6  TYPE CONVERSION124will always be present. Even if the cents value is zero, you will still get a .00 at the end of your string.Essentially, the 0 character forces Oracle to pad with zeros rather than spaces.You can also pad with zero characters to the left of the decimal. Here’s an example: \nselect to_char(82,’0000099’) from dual; \nThat results in the following: \n0000082 \nIt is also possible to convert numbers to strings using the CAST function, although TO_CHAR makes forcode that is easier to read and maintain. For more information on the use of the CAST function, pleasesee recipe 6-5.6-4. Converting a Date to a StringProblemYou want to convert a date into a nicely formatted string value. For example, you are converting a legacyapplication from another database vendor into a web-based Oracle application. A few of the fields on theweb form are dates. The users of the application expect to see the dates in a specific format, so you needthe dates to be formatted in a particular manner for display.SolutionUse the TO_CHAR function using the date masks. The TO_CHAR function offers many formatting options forreturning a string from a DATE value. The following function accepts an EMPLOYEE_ID value and returns arepresentation of the HIRE_DATE spelled out. \nCREATE OR REPLACE PROCEDURE obtain_emp_hire_date(emp_id IN NUMBER) AS emp_hire_date    employees.hire_date%TYPE; emp_first        employees.first_name%TYPE; emp_last         employees.last_name%TYPE;BEGIN  SELECT hire_date, first_name, last_name  INTO emp_hire_date, emp_first, emp_last  FROM employees  WHERE employee_id &#x3D; emp_id; \n  DBMS_OUTPUT.PUT_LINE(emp_first || ‘ ‘ || emp_last ||        ‘ was hired on: ‘ ||        TO_CHAR(emp_hire_date, ‘DAY MONTH DDTH YYYY’));EXCEPTION  WHEN NO_DATA_FOUND THEN    DBMS_OUTPUT.PUT_LINE(‘No employee found for the given ID’);END; \nIf you pass the employee ID of 200 to this function, then it will return a result in the followingformat:  CHAPTER 6  TYPE CONVERSION125Jennifer Whalen was hired on: THURSDAY   SEPTEMBER 17TH 1987 \nPL&#x2F;SQL procedure successfully completed.How It WorksAs shown in the previous recipe, the TO_CHAR function accepts a NUMBER or DATE value and returns a nicelyformatted string. Using the many formatting masks that are available, you can return a string-basedrepresentation in a number of ways. As demonstrated in the solutions to this recipe and the previousone, the TO_CHAR function works a bit differently than the other conversion functions because theformatting mask is used to help produce the final string. Other conversion functions use the formattingmask to represent the format of the string you are passing in. In other words, TO_CHAR produces theformatted strings, whereas the other conversion functions accept them and produce a differentdatatype.Table 6-4 lists some of the most commonly used characters for converting dates into strings.Table 6-4. Date Formatting Mask CharactersCharacters DescriptionYYYY Represents the four-digit yearYEAR Represents the spelled-out yearYYY Represents the last three digits of the yearYY Represents the last two digits of the yearY Represents the last digit of the yearIYY Represents the last three digits of the ISO yearIY Represents the last two digits of the ISO yearI Represents the last digit of the ISO yearQ Represents the quarter of the yearMM Represents the month of the yearMON Represents the abbreviated month nameMONTH Represents the spelled-out month name padded with blanksRM Represents the Roman numeral monthWW Represents the week of the yearCHAPTER 6  TYPE CONVERSION126Characters DescriptionW Represents the week of the monthIW Represents the ISO week of the yearD Represents the day of the weekDAY Represents the name of the dayDD Represents the day of the monthDDD Represents the day of the yearDY Represents the abbreviated name of the dayJ Represents the Julian dayHH Represents the hour of the day (1–12)HH12 Represents the hour of the day (1–12); same as HHHH24 Represents the hour of the day (0–23)MI Represents the minute of the hour (0–59)SS Represents the second (0–59)SSSSS Represents the seconds past midnight (0–86399)FF Represents the fractional seconds \nThere are several formatting options, as you can see. It is best to spend some time with each of thedifferent combinations to decide upon which one works best for your solution.PL&#x2F;SQL can make date formatting easy, because it is possible to create your own function thatreturns a date formatted per your application’s requirements. Sometimes it is difficult to remember allthe different formatting options that are available for dates. It can also be quite painful to reference atable such as Table 6-4 each time you want to format a date string. You can instead create your ownconversion function to support just the formats that you use, and no others. Such a function greatlyreduces the possibility for error, thus enhancing consistency in how your application formats dates.The function in the following example accepts two parameters: the date to be converted and a stringthat specifies the output format. The second argument is limited to only four, easy-to-remember values:LONG, SHORT, STD, and DASH. \n– Returns a date string formatted per the style– that is passed into it.  The possible style strings– are as follows:  CHAPTER 6  TYPE CONVERSION127–   LONG &#x3D;&gt; The spelled out date–   SHORT &#x3D;&gt; The abbreviated date–   STD or blank &#x3D;&gt; The standard date format mm&#x2F;dd&#x2F;yyyy–   DASH &#x3D;&gt; The standard format with dashes mm-dd-yyyyCREATE OR REPLACE FUNCTION FORMAT_DATE(in_date IN DATE,                                       style IN VARCHAR2) RETURN VARCHAR2 AS formatted_date    VARCHAR2(100);BEGIN  CASE style    WHEN ‘LONG’ THEN        formatted_date :&#x3D; TO_CHAR(in_date, ‘DAY MONTH DDTH YYYY’);    WHEN ‘SHORT’ THEN        formatted_date :&#x3D; TO_CHAR(in_date, ‘DY MON DDTH YYYY’);    WHEN ‘DASH’ THEN        formatted_date :&#x3D; TO_CHAR(in_date, ‘MM-DD-YYYY’);    ELSE        formatted_date :&#x3D; TO_CHAR(in_date, ‘MM&#x2F;DD&#x2F;YYYY’);  END CASE;  RETURN formatted_date;END; \nThis function is nice because you only need to remember a short string that is used to represent thedate format that you’d like to return.It is also possible to convert dates to strings using the CAST function. For more information on theuse of the CAST function, please see Recipe 6-5.6-5. Converting Strings to TimestampsProblemYou are working with a series of strings. You want to convert them into timestamps.SolutionUse the TO_TIMESTAMP function to convert the strings into timestamps. In this example, a trigger iscreated that will log an INSERT into the JOBS table. The logging table consists of two columns. The firstcolumn is used to store the date of the transaction, and it is of type TIMESTAMP WITH LOCAL TIME ZONE.The second column is used to contain a DESCRIPTION of type VARCHAR2. The trigger that performs thelogging needs to combine a sysdate and a time zone value into a string prior to converting it into aTIMESTAMP.First, let’s create the table that will be used to log the changes on the JOBS table: \nCREATE TABLE time_log(job_time              TIMESTAMP WITH LOCAL TIME ZONE, description           VARCHAR2(2000)); \nNext, a simple function is created that will return the time zone for a given city code. The functionwill return time zones for Chicago, Orlando, or San Jose because these are the different cities where ourimaginary industry has offices.CHAPTER 6  TYPE CONVERSION128CREATE OR REPLACE FUNCTION find_tz (city IN VARCHAR2)RETURN NUMBER IS  tz          NUMBER :&#x3D; 0;BEGIN  IF city &#x3D; ‘CHI’ THEN    tz :&#x3D; -5;  ELSIF city &#x3D; ‘ORD’ THEN    tz :&#x3D; -4;  ELSIF city &#x3D; ‘SJ’ THEN    tz :&#x3D; -7;  END IF;  RETURN tz;END; \nThe last piece of code is the trigger that performs the INSERT on the logging table. This triggerperforms a conversion of a string to a TIMESTAMP using the TO_TIMESTAMP_TZ function. \nCREATE OR REPLACE TRIGGER log_job_historyAFTER INSERT ON jobsFOR EACH ROWDECLARE  my_ts  VARCHAR2(25) :&#x3D; to_char(sysdate, ‘YYYY-MM-DD HH:MI:SS’);BEGIN  my_ts :&#x3D; my_ts || ‘ ‘ || find_tz(‘CHI’); \n  INSERT INTO time_log values(    TO_TIMESTAMP_TZ(my_ts, ‘YYYY-MM-DD HH:MI:SS TZH:TZM’),    ‘INSERT’  ); \nEND; \nIn this example, the trigger is hard-coded to assume a Chicago entry, but in reality this informationwould have been obtained from the user’s session. However, since that code is out of scope for thisrecipe, the hard-coded city does the trick.How It WorksSimilar to other Oracle conversion functions, the TO_TIMESTAMP_TZ and TO_TIMESTAMP functions accepttwo arguments. The first argument is a string value containing a date value in text form. The secondargument is a format model that is used to coerce the given string value into the TIMESTAMP or TIMESTAMPWITH LOCAL TIME ZONE datatype. The TO_TIMESTAMP_TZ conversion will accept and convert a time zonealong with the TIMESTAMP, whereas the TO_TIMESTAMP function will not account for a time zone.The format model is very similar to that of the TO_CHAR and TO_DATE functions. The format model willdiffer depending upon the format of the date that you want to convert. In the solution to this recipe, theformat included a standard Oracle date along with a time zone. For a complete listing of all possibleformat model characters, please refer to the Oracle SQL Reference manual.  CHAPTER 6  TYPE CONVERSION1296-6. Writing ANSI-Compliant ConversionsProblemYou want to convert strings to dates using an ANSI-compliant methodology.SolutionUse the CAST function, because it is ANSI-compliant. In this example, a procedure is written that willselect each of the rows within the JOB_HISTORY table that fall within a specified date range. The dates willbe converted into strings, and other information will be appended to the converted dates. Thisprocedure will produce a simple report to display the JOB_HISTORY. \nCREATE OR REPLACE PROCEDURE job_history_rpt(in_start_date IN DATE,                                            in_end_date IN DATE) AS  CURSOR job_history_cur IS  SELECT CAST(hist.start_date AS VARCHAR2(12)) || ‘ - ‘ ||         CAST(hist.end_date AS VARCHAR2(12)) || ‘: ‘ ||         emp.first_name || ‘ ‘ || emp.last_name || ‘ - ‘ ||         job_title || ‘ ‘ || department_name as details  FROM jobs jobs,       job_history hist,       employees emp,       departments dept  WHERE hist.start_date &gt;&#x3D; in_start_date  AND hist.end_date &lt;&#x3D; in_end_date  AND jobs.job_id &#x3D; hist.job_id  AND emp.employee_id &#x3D; hist.employee_id  AND dept.department_id &#x3D; hist.department_id; \n  job_history_rec     job_history_cur%ROWTYPE; \nBEGIN  DBMS_OUTPUT.PUT_LINE(‘JOB HISTORY REPORT FOR ‘ ||    in_start_date || ‘ to ‘ || in_end_date);  FOR job_history_rec IN job_history_cur LOOP    DBMS_OUTPUT.PUT_LINE(job_history_rec.details);  END LOOP;END; \nGiven the start date of September 1, 1989, the resulting output from this procedure will resemble thefollowing: \nSQL&gt; exec job_history_rpt(to_date(‘01-SEP-1989’,’DD-MON-YYYY’),sysdate);JOB HISTORY REPORT FOR 01-SEP-89 to 01-SEP-1013-JAN-93 - 24-JUL-98: Lex De Haan - Programmer IT21-SEP-89 - 27-OCT-93: Neena Kochhar - Public Accountant Accounting28-OCT-93 - 15-MAR-97: Neena Kochhar - Accounting Manager Accounting17-FEB-96 - 19-DEC-99: Michael Hartstein - Marketing Representative MarketingCHAPTER 6  TYPE CONVERSION13024-MAR-98 - 31-DEC-98: Jonathon Taylor - Sales Representative Sales01-JAN-99 - 31-DEC-99: Jonathon Taylor - Sales Manager Sales01-JUL-94 - 31-DEC-98: Jennifer Whalen - Public Accountant ExecutivePL&#x2F;SQL procedure successfully completed.How It WorksThe CAST function can be used to easily convert datatypes. However, there is no real benefit to using CASTas opposed to TO_NUMBER or TO_CHAR in most cases. The format for the CAST function is as follows:CAST(expression AS type_name)You can use this function to convert between different datatypes. Table 6-5 lists the different to andfrom datatypes that the CAST function can handle.Table 6-5. CAST Function Converstion TableCAST from Datatype To DatatypeCHAR, VARCHAR2 CHAR, VARCHAR2NUMBERDATETIME&#x2F;INTERVALRAWROWID, UROWIDNUMBER CHAR, VARCHAR2NUMBERNCHAR, NVARCHAR2DATETIME&#x2F;INTERVAL CHAR, VARCHAR2DATETIME&#x2F;INTERVALNCHAR, NVARCHAR2RAW CHAR, VARCHAR2RAWNCHAR, NVARCHAR2ROWID, UROWID CHAR, VARCHAR2ROWID, UROWIDNCHAR, NVARCHAR2NCHAR, NVARCHAR2 NCHAR, NVARCHAR2The CAST function offers advantages to the TO_ conversion functions in some cases. For instance, ifyou are attempting to write SQL that is 100 percent ANSI-compliant, then you should use the CASTfunction because the Oracle conversion functions are not compliant. However, PL&#x2F;SQL itself is notANSI-compliant, so the CAST function offers no advantages while writing PL&#x2F;SQL code.The following are a few more examples of using the CAST function:  CHAPTER 6  TYPE CONVERSION131 \n– Convert date to VARCHAR2SELECT CAST(‘05-MAY-2010’ AS VARCHAR2(15)) FROM DUAL; \n– Convert string to NUMBERSELECT CAST(‘1024’ AS NUMBER) FROM DUAL; \n– Convert string to ROWIDSELECT CAST(‘AAYyVSADsAAAAFLAAA’ AS ROWID) FROM DUAL; \nIf you prefer to have more control over your conversions, the Oracle TO_ conversion functions arethe way to go. They allow you to provide a format mask to control the conversion formatting.6-7. Implicitly Converting Between PLS_INTEGER and NUMBERProblemYou want to convert a number to PLS_INTEGER datatype so that calculations can be performed.SolutionIn this case, allow Oracle to do the footwork and implicitly convert between the two datatypes. In thefollowing example, the function accepts a NUMBER, converts it to PLS_INTEGER, and performs a calculationreturning the result. The function converts to PLS_INTEGER in order to gain a performance boost. \nCREATE OR REPLACE FUNCTION mass_energy_calc (mass IN NUMBER,                                             energy IN NUMBER)RETURN PLS_INTEGER IS  new_mass    PLS_INTEGER :&#x3D; mass;  new_energy  PLS_INTEGER :&#x3D; energy;BEGIN  RETURN ((new_mass * new_energy) * (new_mass * new_energy));EXCEPTION  WHEN OTHERS THEN    RETURN -1;END; \nThe function will accept NUMBER values, automatically convert them into PLS_INTEGER, and return aPLS_INTEGER type.How It WorksImplicit conversion occurs when Oracle automatically converts from one datatype to another. Oraclewill implicitly convert some datatypes but not others. As per the solution to this recipe, one of thedatatypes that supports implicit conversion is PLS_INTEGER. As a matter of fact, PLS_INTEGER cannot beconverted using the TO_NUMBER function; so in this case, implicit is the best way to convert a PLS_INTEGERdatatype to anything else. However, if there is a way to explicitly convert the datatype from one toanother, then that is the recommended approach. You cannot be certain of the results when Oracle isautomatically converting for you; explicit conversion allows you to have more control.CHAPTER 6  TYPE CONVERSION132The PLS_INTEGER datatype can be advantageous over using a NUMBER in some cases. For instance, aPLS_INTEGER has performance advantages when compared to a NUMBER for doing calculations becausethey use machine arithmetic as opposed to library arithmetic. Additionally, the PLS_INTEGER datatyperequires less storage than its counterparts. In the solution to this recipe, the function takes advantage ofthe faster calculation speed that is possible using PLS_INTEGER.C H A P T E R  7 \n   \n133Numbers, Strings, and DatesEvery PL&#x2F;SQL program uses one or more datatypes. This chapter focuses on some details that youshould know when working with data in the form of numbers, strings, and dates. Each recipe in thischapter provides a basic tip for working with these datatypes. From basic string concatenation to moreadvanced regular expression processing, you’ll learn some techniques for getting things done in aneffective manner. You’ll learn about date calculations as well. When you’re done with this chapter, you’llbe ready to move on to the more advanced recipes later in the chapters to follow.7-1. Concatenating StringsProblemYou have two or more text strings, or variables containing strings, that you want to combine.SolutionUse the concatenation operator to append the strings. In the following example, you can see that twovariables are concatenated to a string of text to form a single string of text: \nDECLARE  CURSOR emp_cur IS  SELECT employee_id, first_name, last_name  FROM EMPLOYEES  WHERE HIRE_DATE &gt; TO_DATE(‘01&#x2F;01&#x2F;2000’,’MM&#x2F;DD&#x2F;YYYY’); \n  emp_rec       emp_cur%ROWTYPE;  emp_string    VARCHAR2(150);BEGIN  DBMS_OUTPUT.PUT_LINE(‘EMPLOYEES HIRED AFTER 01&#x2F;01&#x2F;2000’);  DBMS_OUTPUT.PUT_LINE(‘&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;’);  FOR emp_rec IN emp_cur LOOP        emp_string :&#x3D; emp_rec.first_name || ‘ ‘ ||                      emp_rec.last_name || ‘ - ‘ ||                      ‘ID #: ‘ || emp_rec.employee_id; \n    DBMS_OUTPUT.PUT_LINE(emp_string); \n\n  END LOOP;END; \nCHAPTER 7  NUMBERS, STRINGS, AND DATES134You can see that the example uses the concatenation operator || to formulate a string of text thatcontains each employee’s first name, last name, and employee ID number.How It WorksAs you have seen in the solution to this recipe, the concatenation operator is used for concatenatingstrings within your PL&#x2F;SQL applications. When the concatenation operator is used to concatenatenumbers with strings, the numbers are automatically converted into strings and then concatenated.Similarly, an automatic conversion occurs with dates before being concatenated.7-2. Adding Some Number of Days to a DateProblemYou want to add a number of days to a given date. For example, you are developing an application thatcalculates shipping dates for a company’s products. In this case, your application is processingshipments, and you need to calculate a date that is 14 days from the current date.SolutionTreat the number of days as an integer, and add that integer to your DATE value. The following lines ofcode show how this can be done: \nDECLARE  ship_date    DATE :&#x3D; SYSDATE + 14;BEGIN  DBMS_OUTPUT.PUT_LINE(‘The shipping date for any products ‘||                       ‘that are ordered today is ‘ || ship_date);END; \nThe result that is displayed for this example will be 14 days past your current date.If you wanted to encapsulate this logic within a function, then it would be easy to do. The followingfunction takes a date and a number as arguments. The function will perform simple mathematics andreturn the result. \nCREATE OR REPLACE FUNCTION calculate_days(date_to_change  IN DATE,                                          number_of_days  IN NUMBER)RETURN DATE ISBEGIN  RETURN date_to_change + number_of_days;END; \nNotice that the name of the function does not include the word add, such as ADD_DAYS. That wasdone on purpose because this function not only allows addition of days to a date, but if a negativenumber is passed in as an argument, then it will also subtract the number of days from the given date.How It WorksSince calculations such as these are the most common date calculations performed, Oracle makes themeasy to do. If a number is added to or subtracted from a DATE value, Oracle Database will add or subtract  CHAPTER 7  NUMBERS, STRINGS, AND DATES135that number of days from the date value. DATE types can have numbers added to them, and they can alsohave numbers subtracted from them. Multiplication and division do not work because it is not possibleto perform such a calculation on a date. For example, it doesn’t mean anything to speak of multiplying adate by some value.If you are developing an application that always performs an addition or subtraction using the samenumber of days, it may be helpful to create a function such as the one demonstrated in the solution tothis recipe. For instance, if you were developing a billing application and always required a date that was30 days into the future of the current date, then you could create a function named BILLING_DATE andhard-code the 30 days into it. This is not necessary, but if your business or application depended upon it,then it may be a good idea to encapsulate logic to alleviate possible data entry errors.7-3. Adding a Number of Months to a DateProblemYou want to add some number of months to a date. For example, you are developing a paymentapplication for a company, and it requires payments every six months. You need to enable theapplication to calculate the date six months in the future of the current date.■ Note This recipe’s solution also works for subtracting months. Simply “add” a negative number of months.SolutionUse the ADD_MONTHS function to add six months onto the given date.  Doing so will enable yourapplication to create bills for future payments.  This technique is demonstrated in the followingexample: \nDECLARE  new_date    DATE;BEGIN  new_date :&#x3D; ADD_MONTHS(sysdate,6);  DBMS_OUTPUT.PUT_LINE(‘The newly calculated date is: ‘ || new_date);END; \nThis simple technique will enable you to add a number of months to any given date. As with anyother logic, this could easily be encapsulated into a function for the specific purpose of producing abilling date that was six months into the future of the current date. Such a function may look somethinglike the next example: \nCREATE OR REPLACE FUNCTION calc_billing_date ISBEGIN  RETURN ADD_MONTHS(sysdate, 6);END; \nAlthough this function does not do much besides encapsulate logic, it is a good idea to code suchfunctions when developing a larger application where this type of calculation may be performed severalCHAPTER 7  NUMBERS, STRINGS, AND DATES136times. It will help to maintain consistency and alleviate maintenance issues if the date calculation everneeds to change. You could simply make the change within the function rather than visiting all thelocations in the code that use the function.How It WorksOracle provides the ADD_MONTHS function to assist with date calculations. This function has twopurposes—to add or subtract a specified number of months from the given date. The syntax for use ofthe ADD_MONTHS function is as follows: \nADD_MONTHS(date, integer) \nYou can also use the function to subtract months from the given date. If the function is passed anegative integer in place of the month’s argument, then that number of months will be subtracted fromthe date. The following example demonstrates this functionality: \nDECLARE  new_date    DATE;BEGIN  new_date :&#x3D; ADD_MONTHS(sysdate,-2);  DBMS_OUTPUT.PUT_LINE(‘The newly calculated date is: ‘ || new_date);END; \nAs you can see from the example in Figure 7-3, the negative integer is the only change made to thecode in order to achieve a subtraction of months rather than an addition. As a result, the example in thisfigure will return the current date minus two months.In the case that you are attempting to add months to a date that represents the last day of themonth, the ADD_MONTHS function works a bit differently than you might expect. For instance, if it is August31 and you want to add one month, then you would expect the calculation to resolve to September 31,which is not possible. However, ADD_MONTHS is smart enough to return the last day of September in thiscase. The following code provides a demonstration: \nDECLARE  new_date    DATE;BEGIN  new_date :&#x3D; ADD_MONTHS(to_date(‘08&#x2F;31&#x2F;2010’,’MM&#x2F;DD&#x2F;YYYY’),1);  DBMS_OUTPUT.PUT_LINE(‘The last day of next month is: ‘ || new_date);END; \nThe following is the resulting output: \nThe last day of next month is: 30-SEP-10 \nPL&#x2F;SQL procedure successfully completed.In general, if your source date is the late day of its month, then your result date will be forced to thelast day of its respective month. Adding one month to September 30, for example, will yield October 31.  CHAPTER 7  NUMBERS, STRINGS, AND DATES1377-4. Adding Years to a DateProblemYou are developing an application that requires date calculations to be performed. You need todetermine how to add to a specified date. You may also want to subtract years.SolutionCreate a function that will calculate a new date based upon the number of years that you have specified.If you want to subtract a number of years from a date, then pass a negative value for the number of years.The following code implements this functionality: \nCREATE OR REPLACE FUNCTION calculate_date_years (in_date DATE,                                    in_years NUMBER)RETURN DATE AS  new_date    DATE;BEGIN  IF in_date is NULL OR in_years is NULL THEN    RAISE NO_DATA_FOUND;  END IF;  new_date :&#x3D; ADD_MONTHS(in_date, 12 * in_years);  RETURN new_date;END; \nThe example function expects to receive a date and a number of years to add or subtract asarguments. If one of those arguments is left out, then PL&#x2F;SQL will raise an ORA-06553 error, and theexample also raises a special NO_DATA_FOUND error if one or both of the arguments are NULL. The returnvalue will be the input date but in the newly calculated year.How It WorksOracle provides a couple of different ways to calculate dates based upon the addition or subtraction ofyears. One such technique is to use the ADD_MONTHS function that was discussed in Recipe 7-3, as thesolution to this recipe demonstrates. Simple mathematics allow you to multiply the number of yearspassed into the ADD_MONTHS function by 12 since there are 12 months in the year. Essentially thistechnique exploits the ADD_MONTHS function to return a date a specified number of dates into the future.■ Note See Recipe 7-3 for discussion of a corner case involving the use of ADD_MONTHS on a date that representsthe final day of that date’s month.You can use this same technique to subtract a number of years from the specified date by passing anegative integer value that represents the number of years you want to subtract. For instance, if youwanted to subtract five years from the date 06&#x2F;01&#x2F;2000, then pass a -5 to the function that was created inthe solution to this recipe. The following query demonstrates this strategy. \nCHAPTER 7  NUMBERS, STRINGS, AND DATES138select calculate_date_years(to_date(‘06&#x2F;01&#x2F;2000’,’MM&#x2F;DD&#x2F;YYYY’),-5) from dual; \nHere’s the result: \n06&#x2F;01&#x2F;1995 \nUsing the ADD_MONTHS function works well for adding or subtracting a rounded number of years.However, if you wanted to add one year and six months, then it would take another line of code to addthe number of months to the calculated date. The function in the next example is a modified version ofthe CALCULATE_DATE_YEARS function that allows you to specify a number of months to add or subtract aswell: \nCREATE OR REPLACE FUNCTION calculate_date_years (in_date DATE,                                              in_years IN NUMBER,                                              in_months IN NUMBER DEFAULT 0)RETURN DATE AS  new_date    DATE;BEGIN  IF in_date is NULL OR in_years is NULL THEN    RAISE NO_DATA_FOUND;  END IF;  new_date :&#x3D; ADD_MONTHS(in_date, 12 * in_years);  – Additional code to add the number of months to the calculated date  IF in_months !&#x3D; 0 THEN    new_date :&#x3D; ADD_MONTHS(new_date, in_months);  END IF;  RETURN new_date;END; \nUsing the new function, you can pass positive integer values for the number of years and thenumber of months to add years or months to the date, or you can pass negative values for each tosubtract years or months from the date. You can also use a combination of positive and negative integersfor each to obtain the desired date. Since the modified function contains a DEFAULT value of 0 for thenumber of months, it is possible to not specify a number of months, and you will achieve the same resultas the function in the solution to the recipe.As you can see, this function is a bit easier to follow, but it does not allow for one to enter a negativevalue to subtract from the date. All the techniques described within this section have their own merit.However, it is always a good rule of thumb to write software so that it is easy to maintain in the future.Using this rule of thumb, the most favored technique of the three would be to use the ADD_MONTHSfunction as demonstrated in the solution. Not only is this function easy to understand but also widelyused by others within the Oracle community.7-5. Determining the Interval Between Two DatesProblemYou want to determine the number of days between two dates. For example, working on an applicationto calculate credit card late fees, you are required to determine the number of days between any twogiven dates. The difference in days between the two dates will produce the number of days that thepayment is overdue.  CHAPTER 7  NUMBERS, STRINGS, AND DATES139SolutionSubtract the two dates using simple math to find the interval in days. In this solution, the example codesubtracts the current date from the due date to obtain the number of days that the payment is past due: \nCREATE OR REPLACE FUNCTION find_interval(from_date IN DATE,                                         to_date IN DATE)RETURN NUMBER ASBEGIN  RETURN abs(trunc(to_date) – trunc(from_date));END; \nThis function will return the difference between the two dates passed as arguments. Note that thenumber of days will be a decimal value. Although it is just as easy to subtract one date from anotherwithout the use of a helper function, sometimes it is useful to encapsulate the logic. This is especiallytrue if the same calculation will be performed multiple times throughout the application.How It WorksOracle includes the ability to subtract dates in order to find the difference between the two. You can usethis functionality within PL&#x2F;SQL code or SQL queries. The result of the calculation is the number offractional days between the two dates. That number can be rounded in order to find the number of days,or it can be formatted to determine the number of days, hours, minutes, and seconds.As it stands, the result from the subtraction of two will return the number of days between the givendates. If you were interested in returning the number of hours, minutes, or seconds between the twodates, then you could do so by applying some simple mathematics to the result of the subtraction. Forinstance, to find an interval in minutes, multiply the result by 24 * 60. The following functions show howthis technique can be used to create separate functions for returning each time interval: \nCREATE OR REPLACE FUNCTION find_interval_hours(from_date IN DATE,                     to_date IN DATE)RETURN NUMBER ASBEGIN RETURN abs(trunc(from_date) - trunc(to_date) )* 24;END; \nCREATE OR REPLACE FUNCTION find_interval_minutes(from_date IN DATE,                                         to_date IN DATE)RETURN NUMBER ASBEGIN  RETURN (from_date - to_date) * 24 * 60;END; \nCREATE OR REPLACE FUNCTION find_interval_seconds(from_date IN DATE,                                         to_date IN DATE)RETURN NUMBER ASBEGIN  RETURN (from_date - to_date) * 24 * 60 * 60;END;CHAPTER 7  NUMBERS, STRINGS, AND DATES140Each of these functions will return a decimal number that can be rounded. Now you can mix andmatch these functions as needed to return the desired time interval between two dates.7-6. Adding Hours, Minutes, Seconds, or Days to a Given DateProblemOne of your applications requires that you have the ability to add any number of days, hours, minutes, orseconds to a given date and time to produce a new date and time.SolutionCreate functions that add each of these time values to TIMESTAMP dataypes that are passed as anargument. Each of these functions will return the given time plus the amount of time that is passed in asargument. The following three functions will provide the ability to add hours, minutes, seconds, or daysto a given time. Each of these functions returns the calculated date and time using the TIMESTAMPdatatype.CREATE OR REPLACE FUNCTION calc_hours(time_to_change IN TIMESTAMP,                     timeval IN NUMBER)RETURN TIMESTAMP AS  new_time    TIMESTAMP;BEGIN \n  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,’HOUR’);  RETURN new_time;END;CREATE OR REPLACE FUNCTION calc_minutes(time_to_change IN TIMESTAMP,                     timeval IN NUMBER)RETURN TIMESTAMP AS  new_time    TIMESTAMP;BEGIN \n  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,’MINUTE’);  RETURN new_time;END;CREATE OR REPLACE FUNCTION calc_seconds(time_to_change IN TIMESTAMP,                     timeval IN NUMBER)RETURN TIMESTAMP AS  new_time    TIMESTAMP;BEGIN \n  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,’SECOND’);  RETURN new_time;END;  CHAPTER 7  NUMBERS, STRINGS, AND DATES141CREATE OR REPLACE FUNCTION calc_days(time_to_change IN TIMESTAMP,                     timeval IN NUMBER)RETURN TIMESTAMP as  new_time  TIMESTAMP;BEGIN  new_time :&#x3D; time_to_change + timeval;  RETURN new_time;END; \nAll of these functions operate in a similar fashion. You must input a date in the form of a TIMESTAMP,and the calculated TIMESTAMP will be returned.How It WorksWhen performing the calculation of times and dates in Oracle, you have plenty of options. Over theyears, Oracle Database has introduced newer functions to help alleviate some of the difficulties thatwere encountered when attempting date and time calculations in earlier versions of the database. Dateand time calculations can be as simple as adding an integer to the DATE or TIMESTAMP. They can also bedifficult when many multiplications and divisions occur within the same calculation. The solution to thisrecipe provides you with an easy way to add time to a given date using the NUMTODSINTERVAL function.The syntax for this function is as follows: \nNUMTODSINTERVAL(number, expression) \nThe expression that is passed to the function must be one of the following: HOUR, MINUTE, SECOND, orDAY. Technically, the functions created in the solution are capable of subtracting the time or day valuesfrom the given date as well. If you were to pass a negative number to the functions, then theNUMTODSINTERVAL would subtract that many units from the given date and time and return the result. Thefunctions in the solution also do not lock you into using a TIMESTAMP; if you were to pass a DATE type in asan argument, then it would work just as well.In the past, you used to only have the ability to use fractions to add or subtract hours, minutes, andseconds to a date. Over the next few examples, I will show you the sort of fractional mathematics thatyou may see in legacy code. You can add a fraction to a date or TIMESTAMP as both will return a result. Toadd hours to a date, use the fraction x&#x2F;24, where x is the number of hours (1–24) you want to add. Youcan subtract hours by using a negative value for x. This works because there are of course 24 hours inone day. The following example shows how you may see some legacy code using fractions to add hours. \n– Add 1 hour to the current dateresult :&#x3D; SYSDATE + 1&#x2F;24; \n– Add 5 hours to the current dateresult :&#x3D; CURRENT_TIMESTAMP + 5&#x2F;24; \nIt is possible to add minutes to a date using a similar technique with fractions. To add minutes, usethe fraction x&#x2F;24&#x2F;60, where x is the number of minutes (1–60) that you would like to add. Again, use anegative value in place of x in order to subtract that number of minutes from a date. This fraction worksbecause it divides the number assigned to x by the hours in the day and then divides that result by thenumber of minutes in an hour. The next figure shows an example of this technique. \n– Add 10 mintes to the current dateresult :&#x3D; SYSDATE + 10&#x2F;24&#x2F;60;CHAPTER 7  NUMBERS, STRINGS, AND DATES142– Add 30 minutes to the current dateresult :&#x3D; CURRENT_TIMESTAMP + 30&#x2F;24&#x2F;60; \nSimilarly, you can add seconds to a date by using the fraction x&#x2F;24&#x2F;3600. In this fraction, x is thenumber of seconds (1–60) that you want to add. Subtraction of seconds is possible by using a negativenumber for the x value. Just as with the other fractional calculations, this works because there are 3,600seconds in one hour. Therefore, the number assigned to x is divided by the number of hours in the day,and then that result is divided by the number of seconds in one hour. The next figure demonstratesadding seconds to the date using this technique: \n– Add 10 seconds to the current dateresult :&#x3D; SYSDATE + 10&#x2F;24&#x2F;3600; \n– Add 45 seconds to the current dateresult :&#x3D; CURRENT_TIMESTAMP + 45&#x2F;24&#x2F;3600; \nUsing the fractional mathematics, you can add each of the different fractions to the given date andachieve the same result. It is not uncommon for legacy code using fractional mathematics for datecalculation to look like the following: \n– Add 2 hours, 5 minutes, and 30 seconds to the current dateresult :&#x3D; SYSDATE + 2&#x2F;24 + 5&#x2F;24&#x2F;60 + 30&#x2F;24&#x2F;3600; \nThere are a number of ways to add time intervals to a given date. I recommend usingNUMTODSINTERVAL for performing mathematics on time values. In the past, this function was not available,so using fractional mathematics was the only way to add or subtract time from a given date. As shown inthe solution to this recipe, it is possible to encapsulate the logic inside of a PL&#x2F;SQL function. If this isdone, then you could change the implementation inside the function and someone using it would neverknow the difference. Date and time calculations can be made even easier to use by writing functions toencapsulate the logic.7-7. Returning the First Day of a Given MonthProblemYou want to have the ability to obtain the name of the first day for a given month.SolutionWrite a PL&#x2F;SQL function that accepts a date and applies the necessary functions to return the first day ofmonth for the given date. \nCREATE OR REPLACE FUNCTION first_day_of_month(in_date DATE)RETURN VARCHAR2 ISBEGIN  RETURN to_char(trunc(in_date,’MM’), ‘DD-MON-YYYY’);END; \nThe function created in this solution will return the first day of the month that is passed into itbecause it is passed into the TRUNC function.  CHAPTER 7  NUMBERS, STRINGS, AND DATES143How It WorksThe TRUNC function can be useful for returning information from a DATE type. In this case, it is used toreturn the first day of the month from the given date. The solution then converts the truncated datevalue to a character format and returns the result.The TRUNC function accepts two arguments, the first being the date that is to be truncated and thesecond being the format model. The format model is a series of characters that specifies how you wantto truncate the given date. Table 7-1 lists the format models along with a description of each.Table 7-1. Format Models for TRUNCFormat Model DescriptionMI Returns the nearest minuteHH, HH12, HH24 Returns the nearest hourD, DY, DAY Returns the first day of the weekW Returns the same day of the week as the first day of the monthIW Returns the same day of the week as the first day of ISO yearWW Returns the same day of the week as the first day of the yearRM, MM, MON, MONTH  Rounds to the nearest first day of the monthQ Rounds to the nearest quarterI, IY, IYYY Returns the ISO yearY, YY, YYY, SYEAR, YEAR, YYYY  Rounds to the nearest first day of the yearCC, SCC Returns one greater than the first two digits of a given four-digit year\nThe solution to this recipe returns the first day of the given month using the format model MM.7-8. Returning the Last Day of a Given MonthProblemYou want to have the ability to obtain the last day for a given month.CHAPTER 7  NUMBERS, STRINGS, AND DATES144SolutionUse the Oracle built-in LAST_DAY function to return the last day of the month for the date that you passinto it. The following example demonstrates a code block in which the LAST_DAY function is used toreturn the last day of the current month: \nDECLARE  last_day  VARCHAR2(20);BEGIN  select LAST_DAY(sysdate)  INTO last_day  FROM DUAL;  DBMS_OUTPUT.PUT_LINE(last_day);END;How It WorksThe LAST_DAY function is an easy way to retrieve the date for the last day of a given date. To use thefunction, pass in any date, and the last day of the month for the given date will be returned. The functioncan be useful in combination with other functions, especially for converting strings into dates and thendetermining the last day of the given month for the date given in string format. For example, thefollowing combination is used quite often: \nLAST_DAY(to_date(string_based_date,’MM&#x2F;DD&#x2F;YYYY’))7-9. Rounding a NumberProblemYou are interested in rounding a given number. For example, let’s say you are working on employeetimecards, and you want to round to the nearest tenth of an hour for every given hour amount.SolutionUse the Oracle built-in ROUND function to return the result that you desire. For this solution, you areworking with hours on employee timecards. To round to the nearest tenth, you would write a smallPL&#x2F;SQL function that uses the ROUND function and returns the result. The following exampledemonstrates this technique: \nCREATE OR REPLACE FUNCTION emp_labor_hours(time IN NUMBER)RETURN NUMBER ISBEGIN  RETURN ROUND(time, 1);END; \nThe time will be rounded to the nearest tenth in this example because a 1 is passed as the secondargument to the ROUND function.  CHAPTER 7  NUMBERS, STRINGS, AND DATES145How It WorksThe Oracle built-in ROUND function can be used for rounding numbers based upon a specified precisionlevel. To use the ROUND function, pass a number that you would like to round as the first argument, andpass the optional precision level as the second argument. If you do not specify a precision level, then thenumber will be rounded to the nearest integer. If the precision is specified, then the number will berounded to the number of decimal places specified by the precision argument.In the case of this solution, a 1 was specified for the precision argument, so the number will berounded to one decimal place. The precision can be up to eight decimal places. If you specify a precisionlarger than eight decimal places, then the precision will default to eight.7-10. Rounding a Datetime ValueProblemGiven a particular date and time, you want the ability to round the date.SolutionUse the ROUND function passing the date you want to round along with the format model for the unit youwant to round. For example, suppose that given a date and time, you want to the nearest day. To do this,you would pass in the date along with the DD format model. The following code block demonstrates thistechnique: \nBEGIN  DBMS_OUTPUT.PUT_LINE(to_char(ROUND (SYSDATE, ‘DD’),’MM&#x2F;DD&#x2F;YYYY - HH12:MI:SS’)); END; \nThe previous code block will return the current date and time rounded to the nearest day. Forexample, if it is before 12 p.m., then it will round the given date back to 12 a.m. on that date; otherwise, itwill round forward to 12 a.m. on the next date.How It WorksYou can also use the ROUND function for working with DATE types. To round a date using this function, youmust specify the date you want to have rounded as the first argument along with the format parameterfor the type of rounding you want to perform. Table 7-2 lists the different format parameters forperforming DATE rounding.CHAPTER 7  NUMBERS, STRINGS, AND DATES146Table 7-2. Format Parameters for DATE RoundingFormat Parameter DescriptionY, YYY, YYYY, YEAR, SYEAR, SYYYY  Rounds to the nearest yearI, IY, IYYY Rounds to the nearest ISO yearQ Rounds to the nearest quarterRM, MM, MON, MONTH Rounds to the nearest monthWW Rounds to the same day of the week as the first day of the yearIW Rounds to the same day of the week as the first day of the ISO yearW Rounds to the same day of the week as the first day of the monthJ, DD, DDD Rounds to the nearest dayD, DY, DAY  Rounds to the start day of the weekHH, HH12, HH24 Rounds to the nearest hourMI Rounds to the nearest minute \nIf you find that you are using the same date conversion in many places throughout your application,then it may make sense to create a function to encapsulate the call to the ROUND function. Doing so wouldenable a simple function call that can be used to return the date value you require rather thanremembering to use the correct format parameter each time.7-11. Tracking Time to a MillisecondProblemYou are interested in tracking time in a finely grained manner to the millisecond. For example, you wantto determine the exact time in which a particular change is made to the database.SolutionPerform simple mathematics with the current date time in order to determine the exact time down themillisecond. The following function accepts a timestamp and returns the |milliseconds: \nCREATE OR REPLACE FUNCTION capture_milliseconds(in_time TIMESTAMP)RETURN NUMBER IS  milliseconds    NUMBER;  CHAPTER 7  NUMBERS, STRINGS, AND DATES147BEGINselect sum(   (extract(hour from in_time))*3600+   (extract(minute from in_time))*60+   (extract(second from in_time)))*1000into MILLISECONDS from dual;RETURN milliseconds; \nEND;How It WorksIf your application requires a fine-grained accuracy for time, then you may want to track time inmilliseconds. Performing a calculation such as the one demonstrated in the solution to this recipe on agiven DATE or TIMESTAMP can do this. By combining the EXTRACT function with some calculations, thedesired milliseconds result can be achieved.The EXTRACT function is used to extract YEAR, MONTH, or DATE units from a DATE type. It can extractHOUR, MINUTE, or SECOND from a TIMESTAMP. Milliseconds can be calculated by obtaining the sum of thehours multiplied by 3600, the minutes multiplied by 60, and the seconds multiplied by 1000 from a givenTIMESTAMP. If you need to use milliseconds in your program, then I recommend creating a function suchas the one demonstrated in the solution to this recipe to encapsulate this logic.7-12. Associating a Time Zone with a Date and TimeProblemYou want to associate a time zone with a given date and time in order to be more precise.SolutionCreate a code block that declares a field as type TIMESTAMP WITH TIME ZONE. Assign a TIMESTAMP to thenewly declared field within the body of the code block. After doing so, the field that you declared willcontain the date and time of the TIMESTAMP that you assigned along with the associated time zone. Thefollowing example demonstrates a code block that performs this technique using the SYSTIMESTAMP: \nDECLARE  time   TIMESTAMP WITH TIME ZONE; BEGIN  time :&#x3D; SYSTIMESTAMP;  DBMS_OUTPUT.PUT_LINE(time); END; \nThe results that will be displayed via the call to DBMS_OUTPUT should resemble something similar tothe following: \n29-AUG-10 10.27.58.639000 AM -05:00 \nPL&#x2F;SQL procedure successfully completed.CHAPTER 7  NUMBERS, STRINGS, AND DATES148How It WorksPrior to the TIMESTAMP datatype being introduced in Oracle 9i, the DATE type was the only way to workwith dates. There were limited capabilities provided, and later the TIMESTAMP was created to fill thosegaps. For those needing to make use of time zones, Oracle created the TIMESTAMP WITH TIME ZONE andTIMESTAMP WITH LOCAL TIME ZONE datatypes. Both of these datatypes provide a time zone to beassociated with a given date, but they work a bit differently. When you specify the WITH TIME ZONEoption, the time zone information is stored within the database along with the hours, minutes, and soon. However, if you specify the WITH LOCAL TIME ZONE option, the time zone information is not storedwithin the database, but rather it is calculated each time against a baseline time zone, which determinesthe time zone of your current session.In the solution to this recipe, the time zone information is stored within the database along with therest of the date and time associated with the TIMESTAMP.7-13. Finding a Pattern Within a StringProblemYou want to find the number of occurrences of a particular pattern within a given string. For instance,you want to search for email addresses within a body of text.SolutionUse a regular expression to match a given string against the body of text and return the resulting count ofmatching occurrences. The following example searches through a given body of text and counts thenumber of email addresses it encounters. Any email address will be added to the tally because a regularexpression is used to compare the strings. \nCREATE OR REPLACE PROCEDURE COUNT_EMAIL_IN_TEXT(text_var     IN VARCHAR2) AS  counter    NUMBER :&#x3D; 0;  mail_pattern    VARCHAR2(15) :&#x3D; ‘\\w+@\\w+(.\\w+)+’;BEGIN  counter :&#x3D; REGEXP_COUNT(text_var, mail_pattern); \n  IF COUNTER &#x3D; 1 THEN    DBMS_OUTPUT.PUT_LINE(‘This passage provided contains 1 email address’);  ELSIF counter &gt; 1 THEN    DBMS_OUTPUT.PUT_LINE(‘This passage provided contains ‘||                     counter || ‘ email addresses’);  ELSE    DBMS_OUTPUT.PUT_LINE(‘This passage provided contains ‘ ||            ‘no email addresses’);  END IF;END; \nThe function in this example provides a single service because it counts the number of occurrencesof an email address in a given body of text and returns the result.  CHAPTER 7  NUMBERS, STRINGS, AND DATES149How It WorksYou can use regular expressions to help match strings of numbers, text, or alphanumeric values. Theyare sequences of characters and symbols that assimilate a pattern that can be used to match againststrings of text. A regular expression is similar to using the % symbol as a wildcard within a query, exceptthat a regular expression provides a pattern that text must match against. Please refer to online Oracledocumentation for a listing of the different options that can be used for creating regular expressionpatterns.  \nOracle introduced the REGEXP_COUNT function in Oracle 11g, which provides the functionality of countingthe number of occurrences of a given string within a given body of text. The syntax for the REGEXP_COUNTfunction is as follows: \nREGEXP_COUNT(source_text, pattern, position, options) \nThe source text for the function can be any string literal, variable, or column that has a datatype ofVARCHAR2, NVARCHAR2, CHAR, NCHAR, CLOB, or NCLOB. The pattern is a regular expression or a string of text thatwill be used to match against. The position specifies the placement within the source text where thesearch should begin. By default, the position is 1. The options include different useful matchingmodifiers; please refer to the Oracle regular expression support documentation athttp://download.oracle.com/docs/cd/E14072_01/server.112/e10592/ap_posix.htm#g693775 for a listingof the pattern matching modifiers that can be used as options.The REGEXP_COUNT function can be used within any Oracle SQL statement or PL&#x2F;SQL program. Thefollowing are a few more examples of using this function: \n– Count all occurrences of the letter ‘l’ in the word Helloresult :&#x3D; REGEXP_COUNT(‘hello’,’l’); \nReturns:  2 \n– Count the number of occurrences of the pattern ‘ells’ beginning at– the fifth character.result :&#x3D; REGEXP_COUNT(‘she sells sea shells by the sea shore’,                      ‘ells’,7,’c’); \nReturns: 1 \n– Count the number of words in the lineresult :&#x3D; REGEXP_COUNT(‘she sells sea shells by the sea shore’,                      ‘\\w+’); \nReturns: 8 \nAs you can see from these examples, the REGEXP_COUNT function is a great addition to the Oracleregular expression function familyCHAPTER 7  NUMBERS, STRINGS, AND DATES1507-14. Determining the Position of a Pattern Within a StringProblemYou want to return the position of a matching string within a body of text. Furthermore, you are want topattern match and therefore must invoke a regular expression function. For example, you need to find away to determine the position of a string that matches the pattern of a phone number.SolutionUse the REGEXP_INSTR function to use a regular expression to search a body of text to find the position ofa phone number. The following code block demonstrates this technique by looping through each of therows in the EMPLOYEES table and determining whether the employee phone number is USA orinternational:DECLARE  CURSOR emp_cur IS  SELECT *  FROM employees;  emp_rec       emp_cur%ROWTYPE;  position     NUMBER :&#x3D; 0;  counter        NUMBER :&#x3D; 0;  intl_count     NUMBER :&#x3D; 0;BEGIN  FOR emp_rec IN emp_cur LOOP  position :&#x3D; REGEXP_INSTR(emp_rec.phone_number,  ‘([[:digit:]]{3}).([[:digit:]]{3}).([[:digit:]]{4})’); \n  IF position &gt; 0 THEN    counter :&#x3D; counter + 1;  ELSE    intl_count :&#x3D; intl_count + 1;  END IF;  END LOOP;  DBMS_OUTPUT.PUT_LINE(‘Numbers within USA: ‘ || counter);  DBMS_OUTPUT.PUT_LINE(‘International Numbers: ‘ || intl_count);END;Result:Numbers within USA: 72International Numbers: 35PL&#x2F;SQL procedure successfully completed.  CHAPTER 7  NUMBERS, STRINGS, AND DATES151How It WorksIn the solution to this recipe, the function uses REGEXP_INSTR to find all telephone numbers that matchthe U.S. telephone number format. The field passed into REGEXP_INSTR is always going to return atelephone number, but that number may be in an international format or a U.S. format. If the pattern ofthe telephone number matches that of a U.S. format, then the counter for U.S. numbers is increased byone. Otherwise, the counter for the international numbers is increased by one. The reasonableassumption is that if a number is not a U.S. number, that it is an “international” number. UsingREGEXP_INSTR makes this a very easy function to implement.REGEXP_INSTR will return the position of the first or last character of the matching string dependingupon the value of the return option argument. This function provides the same functionality of INSTRexcept that it also allows the ability to use regular expression patterns. The syntax for this function is asfollows: \nREGEXP_INSTR(source_text, pattern, position, occurrence,                               return_option, match parameter, subexpression) \nAll but the source_text and pattern parameters are optional. The source_text is the string of text tobe searched. The pattern is a regular expression or string that will be matched against the source_text.The optional position argument is an integer that specifies on which character Oracle should start thesearch. The optional occurrence parameter specifies which occurrence of the pattern will have itsposition returned. The default occurrence argument is 1, which means that the position of the firstmatching string will be returnedThe optional return_option is used to specify special options that are outlined within the Oracleregular expression documentation that can be found athttp://download.oracle.com/docs/cd/E11882_01/server.112/e10592/ap_posix.htm#g693775. Theoptional match_parameter allows you to change the default matching behavior. The subexpressionparameter is optional, and it is an integer from 0 to 9 that indicates which subexpression in thesource_text will be the target of the function.7-15. Finding and Replacing Text Within a StringProblemYou want to replace each occurrence of a given string within a body of text.SolutionUse the REGEXP_REPLACE function to match a pattern of text against a given body of text, and replace allmatching occurrences with a new string. In the following function, the REGEXP_REPLACE function is usedto replace all occurrences of the JOB_TITLE ‘Programmer’ with the new title of ‘Developer.’ \nDECLARE  CURSOR job_cur IS  SELECT *  FROM jobs; \n  job_rec       job_cur%ROWTYPE;  new_job_title jobs.job_title%TYPE;BEGINCHAPTER 7  NUMBERS, STRINGS, AND DATES152  FOR job_rec IN job_cur LOOP    IF REGEXP_INSTR(job_rec.job_title,’Programmer’) &gt; 0 THEN      new_job_title :&#x3D; REGEXP_REPLACE(job_rec.job_title, ‘Programmer’,                                    ‘Developer’); \n  UPDATE jobs \n  SET job_title = new_job_title \n  WHERE job_id = job_rec.job_id; \n \n  DBMS_OUTPUT.PUT_LINE(job_rec.job_title || &#39; replaced with &#39; || \n     new_job_title); \nEND IF; \n\n END LOOP; \nEND; \nAlthough this particular example does not use any regular expression patterns, it could be adjustedto do so. To find more information and tables specifying the options that are available for creatingpatterns, please refer to the online Oracle documentation.The solution to this recipe prints out the revised text. Each occurrence of the ‘Programmer’ text isreplaced with ‘Developer’, and the newly generated string is returned into the NEW_REVIEW variable.How It WorksThe REGEXP_REPLACE function is a great way to find and replace strings within a body of text. The functioncan be used within any Oracle SQL statement or PL&#x2F;SQL code. The syntax for the function is as follows: \nREGEXP_REPLACE(source_text, pattern, replacement_string, position, occurrence, options) \nThe source text for the function can be any string literal, variable, or column that has a datatype ofVARCHAR2, NVARCHAR2, CHAR, NCHAR, CLOB, or NCLOB. The pattern is a regular expression or a string of text thatwill be used to match against. The replacement string is will replace each occurrence of the stringidentified by the source text. The optional position specifies the placement within the source text wherethe search should begin. By default, the position is 1. The optional occurrence argument is anonnegative integer that indicates the occurrence of the replace operation. If a 0 is specified, then allmatching occurrences will be replaced. If a positive integer is specified, then Oracle will replace thematch for that occurrence with the replacement string. The optional options argument includesdifferent useful matching modifiers; please refer to the online Oracle documentation for a listing of thepattern matching modifiers that can be used as options.■ Note Do not use REGEXP_REPLACE if the replacement can be performed with a regular UPDATE statement. SinceREGEXP_REPLACE uses regular expressions, it can be slower than a regular UPDATE.The following examples demonstrate how this function can be used within a PL&#x2F;SQL application ora simple query. This next bit of code demonstrates how to replace numbers that match those within thegiven set. \n  CHAPTER 7  NUMBERS, STRINGS, AND DATES153select REGEXP_REPLACE(‘abcdefghi’,’[acegi]’,’x’) from dual; \nReturns: xbxdxfxhx \nNext, we replace a Social Security Number with Xs. \nnew_ssn :&#x3D; REGEXP_REPLACE(‘123-45-6789’,’[[:digit:]]{3}-[[:digit:]]{2}-[[:digit:]]{4}’,’xxx-xxx-xxxx’); \nReturns: xxx-xxx-xxxx \nThe REGEXP_REPLACE function can be most useful when attempting to replace patterns of strings within agiven body of text such as the two previous examples have shown. As noted previously, if a standardUPDATE statement can be used to replace a value, then that should be the first choice, because regularexpressions perform slightly slower. \nC H A P T E R  8 \n   \n155Dynamic SQLOracle provides dynamic SQL as a means for generating DML or DDL at runtime. It can be useful whenthe full text of a SQL statement or query is not known until application runtime. Dynamic SQL can helpovercome some of the limitations of static SQL, such as generating a full SQL query based upon someuser-provided information or inserting into a specific table depending upon a user action within yourapplication. Simply put, the ability to use dynamic SQL within PL&#x2F;SQL applications provides a level offlexibility that is not attainable with the use of static SQL alone.Oracle allows dynamic SQL to be generated in two different ways: native dynamic SQL and throughthe use of the DBMS_SQL package. Each strategy has its own benefits as well as drawbacks. In comparison,native dynamic SQL is easier to use, it supports user-defined types, and it performs better than DBMS_SQL.On the other hand, DBMS_SQL supports some features that are not currently supported in native dynamicSQL such as the use of the SQL*Plus DESCRIBE command and the reuse of SQL statements. Each of thesemethodologies will be compared under various use cases within this chapter. By the end of the chapter,you should know what advantages each approach has to offer and which should be used in certaincircumstances.8-1. Executing a Single Row Query That Is Unknown at Compile TimeProblemYou need to query the database for a single row of data matched by the primary key value. However, youare unsure of what columns will need to be returned at runtime.Solution #1Use a native dynamic query to retrieve the columns of data that are determined by your application atruntime. After you determine what columns need to be returned, create a string that contains the SQLthat is needed to query the database. The following example demonstrates the concept of creating adynamic SQL query and then using native dynamic SQL to retrieve the single row that is returned. \nCREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS  emp_qry                VARCHAR2(500);  emp_first              employees.first_name%TYPE;  emp_last               employees.last_name%TYPE;  email                  employees.email%TYPE; \n  valid_id_count         NUMBER :&#x3D; 0;  valid_flag             BOOLEAN :&#x3D; TRUE;  temp_emp_info          VARCHAR2(50); \nCHAPTER 8  DYNAMIC SQL156BEGIN  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;  IF emp_info LIKE ‘%@%’ THEN    temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);    emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;  ELSE    SELECT COUNT(*)    INTO valid_id_count    FROM employees    WHERE employee_id &#x3D; emp_info; \nIF valid_id_count &gt; 0 THEN \n    temp_emp_info := emp_info; \n    emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; \nELSE \n    valid_flag := FALSE; \nEND IF; \n\n  END IF; \n  IF valid_flag &#x3D; TRUE THEN    EXECUTE IMMEDIATE emp_qry    INTO emp_first, emp_last, email    USING temp_emp_info; \nDBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); \n\n  ELSE    DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE SPECIFIED DOES ‘ ||                         ‘NOT MATCH ANY EMPLOYEE RECORD’);  END IF;END; \nAt runtime, the procedure creates a SQL query based upon the criteria that are passed into theprocedure by the invoking program. That query is then executed using the EXECUTE IMMEDIATE statementalong with the argument that will be substituted into the query WHERE clause.Solution #2Use the DBMS_SQL package to create a query based upon criteria that are specified at runtime. Theexample in this solution will query the employee table and retrieve data based upon the parameter thathas been passed into the procedure. The procedure will accept either a primary key ID or an employee e-mail address. The SQL statement that will be used to query the database will be determined at runtimebased upon what type of argument is used. \nCREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS  emp_qry                  VARCHAR2(500);  emp_first                employees.first_name%TYPE :&#x3D; NULL;  emp_last                 employees.last_name%TYPE :&#x3D; NULL;  email                    employees.email%TYPE :&#x3D; NULL; \n  valid_id_count           NUMBER :&#x3D; 0;  valid_flag               BOOLEAN :&#x3D; TRUE;  CHAPTER 8  DYNAMIC SQL157  temp_emp_info          VARCHAR2(50); \n  cursor_name            INTEGER;  row_ct                 INTEGER; \nBEGIN \n  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;  IF emp_info LIKE ‘%@%’ THEN    temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);    emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;  ELSE    SELECT COUNT(*)    INTO valid_id_count    FROM employees    WHERE employee_id &#x3D; emp_info; \nIF valid_id_count &gt; 0 THEN \n    temp_emp_info := emp_info; \n    emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :emp_info&#39;; \nELSE \n    valid_flag := FALSE; \nEND IF; \n\n  END IF; \n  IF valid_flag &#x3D; TRUE THEN    cursor_name :&#x3D; DBMS_SQL.OPEN_CURSOR;    DBMS_SQL.PARSE(cursor_name, emp_qry, DBMS_SQL.NATIVE);    DBMS_SQL.BIND_VARIABLE(cursor_name, ‘:emp_info’, temp_emp_info);    DBMS_SQL.DEFINE_COLUMN(cursor_name, 1, emp_first, 20);    DBMS_SQL.DEFINE_COLUMN(cursor_name, 2, emp_last, 25);    DBMS_SQL.DEFINE_COLUMN(cursor_name, 3, email, 25);    row_ct :&#x3D; DBMS_SQL.EXECUTE(cursor_name);  IF DBMS_SQL.FETCH_ROWS(cursor_name) &gt; 0 THEN      DBMS_SQL.COLUMN_VALUE (cursor_name, 1, emp_first);      DBMS_SQL.COLUMN_VALUE (cursor_name, 2, emp_last);      DBMS_SQL.COLUMN_VALUE (cursor_name, 3, email);      DBMS_OUTPUT.PUT_LINE(emp_first || ‘ ‘ || emp_last || ‘ - ‘ || email); \n  END IF; \n  ELSE    DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE SPECIFIED DOES ‘ ||                         ‘NOT MATCH ANY EMPLOYEE RECORD’);  END IF;  DBMS_SQL.CLOSE_CURSOR(cursor_name);  EXCEPTION    WHEN OTHERS THEN      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE SPECIFIED DOES ‘ ||                         ‘NOT MATCH ANY EMPLOYEE RECORD’); \nEND;CHAPTER 8  DYNAMIC SQL158How It Works #1Native dynamic SQL allows you to form a string of SQL text and then execute it via the EXECUTEIMMEDIATE statement. This is very useful when the columns, table names, or WHERE clause text is notknown at runtime. The program can build the SQL string as it needs to, and then the EXECUTE IMMEDIATEstatement will execute it. The format for the EXECUTE IMMEDIATE statement is as follows: \nEXECUTE IMMEDIATE sql_string[INTO variable_name1[, variable_name2, . . .]USING variable_name1[, variable_name2, . . .]]; \nThe EXECUTE IMMEDIATE statement requires only one parameter, which is a SQL string to execute.The remainder of the statement is optional. The INTO clause lists all the variables that a SQL query wouldreturn values into. The variables should be listed in the same order within the SQL string as they arelisted within the INTO clause. The USING clause lists all the variables that will be bound to the SQL stringat runtime. Bind variables are arguably one of the most valuable features of the PL&#x2F;SQL language. Eachvariable listed in the USING clause is bound to a bind variable within the SQL string. The order in whichthe variables are listed in the USING clause is the same order in which they will be bound within thestring. Take a look at the following example that uses two bind variables: \nEXECUTE IMMEDIATE ‘select email from employees ‘ ||                                       ‘where last_name &#x3D;:last ‘ ||                                       ‘and first_name &#x3D; :first’INTO v_emailUSING v_last, v_first; \nIn the example query, the variables contained within the USING clause are bound in order to the bindvariables within the SQL string. Bind variables are the cornerstone to developing robust, secure, andwell-performing software.How It Works #2The DBMS_SQL package can also be used to perform the same task. Each of the different techniques, nativedynamic SQL and DBMS_SQL, have their advantages and disadvantages. The major difference between theuse of DBMS_SQL and native dynamic SQL is how the dynamic SQL string is executed. In this example,DBMS_SQL package functions are used to process the SQL rather than EXECUTE IMMEDIATE. As you can see,the code is quite a bit lengthier than using EXECUTE IMMEDIATE, and it essentially returns the sameinformation. In this case, DBMS_SQL is certainly not the best choice. DBMS_SQL can become useful insituations where you do not know the SELECT list until runtime or when you are unsure of whichvariables must be bound to a SELECT or DML statement. On the other hand, you must use nativedynamic SQL if you intend to use the cursor variable attributes %FOUND, %NOTFOUND, %ISOPEN, or %ROWCOUNTwhen working with your cursor.■ Note Native dynamic SQL was introduced in Oracle 9i, because DBMS_SQL was overly complex for many of theroutine tasks that programmers perform. We consider use of native dynamic SQL as the technique of choice forworking with dynamic SQL. Use DBMS_SQL only when you have a specific need to do so.  CHAPTER 8  DYNAMIC SQL1598-2. Executing a Multiple Row Query That Is Unknown at CompileTimeProblemYour application requires a database table to be queried, but the filters for the WHERE clause are notknown until runtime. You have no idea how many rows will be returned by the query.Solution #1Create a native dynamic query using a SQL string that will be built at application runtime. Declare thequery using REF CURSOR, execute it by issuing an OPEN statement, and loop through the records using astandard loop, fetching the fields within each iteration of the loop. This technique is illustrated via thecode in the following example: \nDECLARE  emp_qry                 VARCHAR2(500);  TYPE                    cur_type IS REF CURSOR;  cur                     cur_type;  emp_first               employees.first_name%TYPE;  emp_last                employees.last_name%TYPE;  email                   employees.email%TYPE; \n  dept_id                 employees.department_id%TYPE :&#x3D; &amp;department_id; \nBEGIN  – DEPARTMENT_ID WILL NOT UNIQUELY DEFINE ANY ONE EMPLOYEE \n  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘ ||             ‘ WHERE DEPARTMENT_ID &#x3D; :id’; \n  OPEN cur FOR emp_qry USING dept_id;  LOOP    FETCH cur INTO emp_first, emp_last, email;   EXIT WHEN cur%NOTFOUND;    DBMS_OUTPUT.PUT_LINE(emp_first || ‘ ‘ || emp_last || ‘ - ‘ || email);  END LOOP;  CLOSE cur;END; \nThis example accepts a DEPARTMENT_ID as input, and it uses a bind variable to substitute the valuewithin the SQL string. Although the actual SQL string in this example does not require the use of adynamic query, it is a useful example to demonstrate the technique.Solution #2This same procedure can also be performed using the DBMS_SQL package. Although the native dynamicSQL solution is easier to understand and implement, the DBMS_SQL alternative offers some differentoptions that are not available when using the native method. The following example is a sample of aCHAPTER 8  DYNAMIC SQL160procedure that performs the same functionality as Solution #1 of this recipe. However, the procedure inthe following example uses the DBMS_SQL package to parse and execute the dynamic query rather thannative dynamic SQL.CREATE OR REPLACE PROCEDURE obtain_emp_detail(dept_id IN NUMBER) IS  emp_qry                 VARCHAR2(500);  emp_first               employees.first_name%TYPE :&#x3D; NULL;  emp_last                employees.last_name%TYPE :&#x3D; NULL;  email                   employees.email%TYPE :&#x3D; NULL;  cursor_name             INTEGER;  row_ct                  INTEGER;BEGIN \n emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘ ||             ‘ WHERE DEPARTMENT_ID &#x3D; :id’;    cursor_name :&#x3D; DBMS_SQL.OPEN_CURSOR;    DBMS_SQL.PARSE(cursor_name, emp_qry, DBMS_SQL.NATIVE);    DBMS_SQL.BIND_VARIABLE(cursor_name, ‘:id’, dept_id);    DBMS_SQL.DEFINE_COLUMN(cursor_name, 1, emp_first, 20);    DBMS_SQL.DEFINE_COLUMN(cursor_name, 2, emp_last, 25);    DBMS_SQL.DEFINE_COLUMN(cursor_name, 3, email, 25);    row_ct :&#x3D; DBMS_SQL.EXECUTE(cursor_name);    LOOP    IF DBMS_SQL.FETCH_ROWS(cursor_name) &gt; 0 THEN      DBMS_SQL.COLUMN_VALUE (cursor_name, 1, emp_first);      DBMS_SQL.COLUMN_VALUE (cursor_name, 2, emp_last);      DBMS_SQL.COLUMN_VALUE (cursor_name, 3, email);     DBMS_OUTPUT.PUT_LINE(emp_first || ‘ ‘ || emp_last || ‘ - ‘ || email);    ELSE      EXIT;    END IF;    END LOOP; \nDBMS_SQL.CLOSE_CURSOR(cursor_name);EXCEPTION    WHEN OTHERS THEN      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||                         ‘NOT MATCH ANY EMPLOYEE RECORD’);END;How It WorksThe use of native dynamic SQL in this solution is more or less equivalent to that which was performed inthe previous recipe. The largest difference lies in the use of the REF CURSOR as opposed to the EXECUTEIMMEDIATE statement. The REF CURSOR is used to create a cursor using a dynamic SQL string.Cursor variables can be either weakly typed or strongly typed. The cursor variable demonstrated inthe solution to this example of a weakly typed REF CURSOR, since the SQL string is not known until  CHAPTER 8  DYNAMIC SQL161runtime. A strongly typed cursor variable must be known at runtime. In this sense, a strongly typedcursor variable is very similar to a regular cursor.The REF CURSOR type must be declared first, and then the actual cursor variable that will be used inyour code should be declared using the REF CURSOR as its type. Next you have the OPEN statement. To tellOracle what SQL to use for the cursor, the OPEN statement should include a FOR clause indicating the SQLstring that the cursor should use. If there are any variables to bind into the query, the optional USINGclause should follow at the end of the OPEN statement.The subsequent cursor loop should work with the REF CURSOR in the same manner that you woulduse with regular cursor variables. Always FETCH the current record or its contents into a local record orseparate local variables. Next, perform the tasks that need to be completed. Lastly, ensure that youinclude an EXIT statement to indicate that the loop should be terminated after the last record has beenprocessed. The final step in the process is to close the cursor. After the cursor has been closed, it can beassigned a new SQL string since you are working with weakly typed REF CURSORs.As you can see, the example of using DBMS_SQL in Solution #2 of this recipe as opposed to theexample in Recipe 8-1 differs only because of the addition of a LOOP construct. Instead of displaying onlyone value, this example will loop through all the records that are returned from the query, and the loopwill exit when there are no remaining rows in the result. The example in Recipe 8-1 could entail the sameloop construct as the one shown in Solution #2 of this recipe, but it is only expected to return one rowsince the query is based upon a primary and unique key value.The choice for using DBMS_SQL as opposed to native dynamic SQL (NDS) depends on what you aretrying to achieve. DBMS_SQL will allow you to use a SQL string that is greater than 32KB in size, whereasnative dynamic SQL will not. However, there are other options for creating large SQL text strings andparsing them with native dynamic SQL. Please see Recipe 8-11 for more details.8-3. Writing a Dynamic INSERT StatementProblemYour application must insert data into a table, but you don’t know until runtime which columns you willinsert. For example, you are writing a procedure that will be used for saving records into the EMPLOYEEStable. However, the exact content to be saved is not known until runtime because the person who iscalling the procedure can decide whether they are including a DEPARTMENT_ID. If a DEPARTMENT_ID isincluded, then the department will be included in the INSERT.SolutionCreate a string at runtime that will contain the INSERT statement text to be executed. Use bind variablesto substitute the values that are to be inserted into the database table. The following procedure acceptsuser input for entry of a new employee record. Bind variables are used to substitute those values into theSQL. \nCREATE OR REPLACE PROCEDURE new_employee (   first     IN VARCHAR2,                                             last      IN VARCHAR2,                                             email     IN VARCHAR2,                                             phone     IN VARCHAR2,                                             hired     IN DATE,                                             job       IN VARCHAR2,                                             dept      IN NUMBER DEFAULT 0) AS                                             v_sql     VARCHAR2(1000);BEGINCHAPTER 8  DYNAMIC SQL162  IF dept !&#x3D; 0 THEN    v_sql :&#x3D; ‘INSERT INTO EMPLOYEES ( ‘ ||                   ‘employee_id, first_name, last_name, email, ‘ ||                   ‘phone_number, hire_date, job_id, department_id) ‘ ||                   ‘VALUES( ‘ ||                   ‘:id, :first, :last, :email, :phone, :hired, ‘ ||                   ‘:job_id, :dept)’; \nEXECUTE IMMEDIATE v_sql \nUSING employees_seq.nextval, first, last, email, phone, hired, job, dept; \n\n  ELSE    v_sql :&#x3D; ‘INSERT INTO EMPLOYEES ( ‘ ||                   ‘employee_id, first_name, last_name, email, ‘ ||                   ‘phone_number, hire_date, job_id) ‘ ||                   ‘VALUES( ‘ ||                   ‘:id, :first, :last, :email, :phone, :hired, ‘ ||                   ‘:job_id)’; \nEXECUTE IMMEDIATE v_sql \nUSING employees_seq.nextval, first, last, email, phone, hired, job; \n\n  END IF; \n  DBMS_OUTPUT.PUT_LINE(‘The employee has been successfully entered’);EXCEPTION  WHEN NO_DATA_FOUND THEN    DBMS_OUTPUT.PUT_LINE(‘YOU MUST SUPPLY A VALUE FOR DEPARTMENT’);  WHEN TOO_MANY_ROWS THEN    DBMS_OUTPUT.PUT_LINE(‘EMPLOYEE_ID ALREADY EXISTS’);END; \nIf the data entry clerk includes a department ID number for the employee when executing theNEW_EMPLOYEE procedure, then the INSERT statement will differ slightly than it would if no department IDwere provided. The basic native dynamic SQL in this example does not differ much from those examplesdemonstrated in Recipe 8-1 or Recipe 8-2 of this chapter.Solution #2The DBMS_SQL API can also be used to execute dynamic INSERT statements. Although dynamic DML is notusually performed with DBMS_SQL very often, it can still be useful in some circumstances. The followingexample performs the same task as Solution #1 to this recipe. However, it has been rewritten to useDBMS_SQL instead of native dynamic SQL. \nCREATE OR REPLACE PROCEDURE new_employee(first      IN VARCHAR2,                                         last       IN VARCHAR2,                                         email      IN VARCHAR2,                                         phone      IN VARCHAR2,                                         hired      IN DATE,                                         job        IN VARCHAR2,                                         dept       IN NUMBER DEFAULT 0)7  CHAPTER 8  DYNAMIC SQL163AS  v_sql    VARCHAR2(1000); \n  cursor_var            NUMBER :&#x3D; DBMS_SQL.OPEN_CURSOR;  rows_compelete NUMBER :&#x3D; 0;  next_emp              NUMBER :&#x3D; employee_seq.nextval;BEGIN \n  IF dept !&#x3D; 0 THEN    v_sql :&#x3D; ‘INSERT INTO EMPLOYEES ( ‘ ||                   ‘employee_id, first_name, last_name, email, ‘ ||                   ‘phone_number, hire_date, job_id, department_id) ‘ ||                   ‘VALUES( ‘ ||                   ‘:id, :first, :last, :email, :phone, :hired, ‘ ||                   ‘:job_id, :dept)’; \n  ELSE    v_sql :&#x3D; ‘INSERT INTO EMPLOYEES ( ‘ ||                   ‘employee_id, first_name, last_name, email, ‘ ||                   ‘phone_number, hire_date, job_id) ‘ ||                   ‘VALUES( ‘ ||                   ‘:id, :first, :last, :email, :phone, :hired, ‘ ||                   ‘:job_id)’;  END IF;  DBMS_SQL.PARSE(cursor_var, v_sql, DBMS_SQL.NATIVE);  DBMS_SQL.BIND_VARIABLE(cursor_var, 1, ‘:id’, next_emp);  DBMS_SQL.BIND_VARIABLE(cursor_var, 2, ‘:first’, first);  DBMS_SQL.BIND_VARIABLE(cursor_var, 3, ‘:last’, last);  DBMS_SQL.BIND_VARIABLE(cursor_var, 4, ‘:email’, email);  DBMS_SQL.BIND_VARIABLE(cursor_var, 5, ‘:phone’, phone);  DBMS_SQL.BIND_VARIABLE(cursor_var, 6, ‘:hired’);  DBMS_SQL.BIND_VARIABLE(cursor_var, 7, ‘:job’, job);  IF dept !&#x3D; 0 then    DBMS_SQL.BIND_VARIABLE(cursor_var, 8, ‘:dept’, dept);  END IF;  rows_complete :&#x3D; DBMS_SQL.EXECUTE(cursor_var);  DBMS_SQL.CLOSE_CURSOR(cursor_var);  DBMS_OUTPUT.PUT_LINE(‘The employee has been successfully entered’);END;How It WorksUsing native dynamic SQL, creating an INSERT statement is almost identical to working with a querystring. As a matter of fact, the only difference is that you will not be making use of the INTO clause withinthe EXECUTE IMMEDIATE statement. Standard PL&#x2F;SQL can be used to create the SQL statement string inorder to process an INSERT statement that contains column names, table names, or WHERE clause valuesthat are not known until runtime.CHAPTER 8  DYNAMIC SQL164■ Note If your SQL string contains any SQL that requires the use of single quotes, double up on the quotes.Placing a single quote immediately after another signals the parser to place a single quote into the string that youare creating.Similarly to SQL queries using dynamic SQL, you should use bind variables to substitute values intothe SQL statement string where needed. As a refresher, bind variables are used within SQL queries orstatements to act as placeholders for values that are to be substituted at runtime. A bind variable beginswith a colon and is then followed by the variable name. The EXECUTE IMMEDIATE statement implementsthe USING clause to list variables that contain values that will be substituted into the bind variables atruntime. The order in which the variables are listed in the USING clause must concur with the positioningof the bind variables within the SQL. The following is an example of an EXECUTE IMMEDIATE statement tobe used with a SQL statement such as an INSERT: \nEXECUTE IMMEDIATE sql_statement_string[USING variable1, variable2, etc]; \nIt is usually a good idea to include an EXCEPTION block at the end of any code block. This is especiallytrue when working with dynamic queries or statements. An Oracle error will be raised if the INSERTstatement within the SQL string is invalid. If an EXCEPTION block were added to catch OTHERS, then youcould provide a well-written error message that describes the exact issue at hand. In most cases, users ofyour application would prefer to see such a nice summary message rather than a cryptic Oracle errormessage.It is a good rule of thumb to maintain consistency throughout your application code. If you prefer touse native dynamic SQL, then try to use it in all cases where dynamic SQL is a requirement. Likewise,DBMS_SQL should be used throughout if you plan to make use of it instead. There are certain situationswhen you may want to mix the two techniques in order to obtain information or use features that are notavailable with one or the other. In Recipe 8-13, you will learn more about using both techniques withinthe same block of PL&#x2F;SQL code.8-4. Writing a Dynamic Update StatementProblemYour application needs to execute an update statement, and you are not sure of the columns to beupdated until runtime. For example, your application will modify employee records. You would like toconstruct an update statement that contains only the columns that have updated values.SolutionUse native dynamic SQL to execute a SQL statement string that you prepare at application runtime. Theprocedure in this example accepts employee record values as input. In this scenario, an application formallows user entry for many of the fields that are contained within the EMPLOYEES table so that a particularemployee record can be updated. The values that are changed on the form should be included in theUPDATE statement. The procedure queries the employee record and checks to see which values have beenupdated. Only the updated values are included in the text of the SQL string that is used for the update. \n  CHAPTER 8  DYNAMIC SQL165CREATE OR REPLACE PROCEDURE update_employees(id   IN employees.employee_id%TYPE,                                            first IN employees.first_name%TYPE,                                            last  IN employees.last_name%TYPE,                                            email IN employees.email%TYPE,                                            phone IN employees.phone_number%TYPE,                                            job   IN employees.job_id%TYPE,                                            salary IN employees.salary%TYPE,                                            commission_pct IN employees.commission_pct%TYPE,                                            manager_id IN employees.manager_id%TYPE,                                            department_id IN employees.department_id%TYPE) AS \n  emp_upd_rec   employees%ROWTYPE; \n  sql_string    VARCHAR2(1000); \n  set_count     NUMBER :&#x3D; 0;BEGIN \n  SELECT *  INTO emp_upd_rec  FROM employees  WHERE employee_id &#x3D; id; \n  sql_string :&#x3D; ‘UPDATE EMPLOYEES SET ‘; \n  IF first !&#x3D; emp_upd_rec.first_name THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, FIRST_NAME &#x3D;’ || first || ‘’’’;    ELSE      sql_string :&#x3D; sql_string || ‘ FIRST_NAME &#x3D;’ || first || ‘’’’;      set_count :&#x3D; set_count + 1;    END IF;  END IF; \n  IF last !&#x3D; emp_upd_rec.last_name THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, LAST_NAME &#x3D;’’’ || last || ‘’’’;    ELSE      sql_string :&#x3D; sql_string ||’ LAST_NAME &#x3D;’’’ ||  last || ‘’’’;      set_count :&#x3D; set_count + 1;    END IF;  END IF; \n  IF upper(email) !&#x3D; emp_upd_rec.email THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, EMAIL &#x3D;’’’ || upper(email) || ‘’’’;    ELSE      sql_string :&#x3D; sql_string ||’ EMAIL &#x3D;’’’ || upper(email) || ‘’’’;      set_count :&#x3D; set_count + 1;    END IF;CHAPTER 8  DYNAMIC SQL166  END IF; \n  IF upper(phone) !&#x3D; emp_upd_rec.phone_number THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, PHONE_NUMBER &#x3D;’’’ ||        upper(phone) || ‘’’’;    ELSE      sql_string :&#x3D; sql_string ||’ PHONE_NUMBER &#x3D;’’’ ||        upper(phone) || ‘’’’;      set_count :&#x3D; set_count + 1;    END IF;  END IF; \n  IF job !&#x3D; emp_upd_rec.job_id THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, JOB_ID &#x3D;’’’ || job || ‘’’’;    ELSE      sql_string :&#x3D; sql_string ||’ JOB_ID &#x3D;’’’ || job || ‘’’’;      set_count :&#x3D; set_count + 1;    END IF;  END IF; \n  IF salary !&#x3D; emp_upd_rec.salary THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, SALARY &#x3D;’ || salary;    ELSE      sql_string :&#x3D; sql_string ||’ SALARY &#x3D;’ || salary;      set_count :&#x3D; set_count + 1;    END IF;  END IF; \n  IF commission_pct !&#x3D; emp_upd_rec.commission_pct THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, COMMISSION_PCT &#x3D;’ ||               commission_pct;    ELSE      sql_string :&#x3D; sql_string ||’ COMMISSION_PCT &#x3D;’ ||               commission_pct;      set_count :&#x3D; set_count + 1;    END IF;  END IF; \n  IF manager_id !&#x3D; emp_upd_rec.manager_id THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, MANAGER_ID &#x3D;’ ||        manager_id;    ELSE      sql_string :&#x3D; sql_string ||’ MANAGER_ID &#x3D;’ ||        manager_id;      set_count :&#x3D; set_count + 1;    END IF;  END IF;  CHAPTER 8  DYNAMIC SQL167 \n   IF department_id !&#x3D; emp_upd_rec.department_id THEN    IF set_count &gt; 0 THEN      sql_string :&#x3D; sql_string ||’, DEPARTMENT_ID &#x3D;’ ||        department_id;    ELSE      sql_string :&#x3D; sql_string ||’ DEPARTMENT_ID &#x3D;’ ||        department_id;      set_count :&#x3D; set_count + 1;    END IF;  END IF; \n  sql_string :&#x3D; sql_string || ‘ WHERE employee_id &#x3D; ‘ || id; \n  IF set_count &gt; 0 THEN    EXECUTE IMMEDIATE sql_string;  ELSE    DBMS_OUTPUT.PUT_LINE(‘No update needed, ‘ ||        ‘all fields match original values’);  END IF; \nEXCEPTION  WHEN NO_DATA_FOUND THEN    DBMS_OUTPUT.PUT_LINE(‘No matching employee found’);  WHEN OTHERS THEN    DBMS_OUTPUT.PUT_LINE(‘Data entry error has occurred, ‘ ||                ‘please check values and try again’ || sql_string);END; \nExecution and Results: \nSQL&gt; exec update_employees(187,‘Anthony’,‘Cabrio’,‘ACABRIO’,‘650.509.4876’, ‘SH_CLERK’,6501,.08,121,50);No update needed, all fields match original values \nAs mentioned previously, this procedure accepts input from a user data entry form. The inputpertains to an existing employee’s database record. The values accepted as input are compared againstthose that already exist in the database, and if they are different, then they are added into the SQL UPDATEstatement that is dynamically created. This code could be simplified by creating a separate function totake care of comparing values and building the SQL string, but this procedure gives you a good idea ofhow dynamic SQL can be used to EXECUTE an UPDATE statement.CHAPTER 8  DYNAMIC SQL168How It WorksDynamic SQL statement execution is straightforward when using native dynamic SQL. The procedure inthe solution to this recipe creates a SQL string based upon certain criteria, after which it is executed withthe use of the EXECUTE IMMEDIATE statement.The EXECUTE IMMEDIATE statement works the same way for most DML statements. If you read Recipe8-3 on creating and running a dynamic INSERT statement, then you can see that executing an UPDATEstatement works in the same manner.Any values that need to be substituted into the SQL string should be coded as bind variables. Formore information regarding bind variables, please refer to Recipe 8-3. The format for executing anUPDATE statement with the EXECUTE IMMEDIATE statement is as follows: \nEXECUTE IMMEDIATE update_statement_string[USING variable1, variable2, etc]; \nJust as with the execution of the INSERT statement in Recipe 8-3, the EXECUTE IMMEDIATE statementrequires the use of the USING clause only if there are variables that need to be substituted into the SQLstatement at runtime.■ Note If you are able to write a static SQL UPDATE statement for your application, then do so. Use of dynamic SQLwill incur a small performance penalty.The DBMS_SQL package can also be used to work with dynamic SQL updates. However, this techniqueis not used very much since the introduction of native dynamic SQL in Oracle 9i. For an example of usingthe DBMS_SQL package with DML statements, please refer to Recipe 8-3. Although the example in Recipe8-3 demonstrates an INSERT statement, an UPDATE statement is processed the same way; only the SQLstring needs to be changed.8-5. Writing a Dynamic Delete StatementProblemYou need to create a procedure that will delete rows from a table. However, the exact SQL for deletingthe rows is not known until runtime. For instance, you need create a procedure to delete an employeefrom the EMPLOYEES table, but rather than limit the procedure to accepting only employee ID numbersfor employee identification, you also want to accept an e-mail address. The procedure will determinewhether an e-mail address or an ID has been passed and will construct the appropriate DELETEstatement.SolutionUse native dynamic SQL to process a string that is dynamically created based upon values that arepassed into the procedure. In the following example, a procedure is created that will build a dynamicSQL string to delete an employee record. The DELETE statement syntax may vary depending upon whattype of value is passed into the procedure. Valid entries include EMPLOYEE_ID values or EMAIL values.  CHAPTER 8  DYNAMIC SQL169 \nCREATE OR REPLACE PROCEDURE delete_employee(emp_value IN VARCHAR2) AS \n  is_number         NUMBER :&#x3D; 0;  valid_flag        BOOLEAN :&#x3D; FALSE;  sql_stmt          VARCHAR2(1000);  emp_count         NUMBER :&#x3D; 0;BEGIN  sql_stmt :&#x3D; ‘DELETE FROM EMPLOYEES ‘; \n  – DETERMINE IF emp_value IS NUMERIC, IF SO THEN QUERY  – DATABASE TO FIND OCCURRENCES OF MATCHING EMPLOYEE_ID  IF LENGTH(TRIM(TRANSLATE(emp_value, ‘ +-.0123456789’, ‘ ‘))) IS NULL THEN    SELECT COUNT(*)    INTO emp_count    FROM EMPLOYEES    WHERE EMPLOYEE_ID &#x3D; emp_value; \nIF emp_count &gt; 0 THEN \n  sql_stmt := sql_stmt || &#39;WHERE EMPLOYEE_ID = :emp_val&#39;; \n  valid_flag := TRUE; \nEND IF; \n\n  ELSE    SELECT COUNT(*)    INTO emp_count    FROM EMPLOYEES    WHERE EMAIL &#x3D; upper(emp_value); \nIF emp_count &gt; 0 THEN \n  sql_stmt := sql_stmt || &#39;WHERE EMAIL = :emp_val&#39;; \n  valid_flag := TRUE; \nELSE  \n  valid_flag := FALSE; \nEND IF; \n\n  END IF; \n  IF valid_flag &#x3D; TRUE THEN \nEXECUTE IMMEDIATE sql_stmt \nUSING emp_value; \n\nDBMS_OUTPUT.PUT_LINE(&#39;Employee has been deleted&#39;); \n\n  ELSE    DBMS_OUTPUT.PUT_LINE(‘No matching employee found, please try again’);  END IF; \nEND; \nThe procedure can be called by passing in either an EMPLOYEE_ID value or an EMAIL value. If amatching employee record is found, then it will be deleted from the database table.CHAPTER 8  DYNAMIC SQL170How It WorksDynamic SQL can be used to execute DELETE statements as well. In the solution to this recipe, a dynamicSQL string is built that will remove an employee entry that contains a matching EMPLOYEE_ID or EMAILvalue that is passed into the procedure as a parameter. The parameter is checked to find out whether it isa numeric or alphanumeric value by using a combination of the LENGTH, TRIM, and TRANSLATE functions. Ifit is numeric, then it is assumed to be an EMPLOYEE_ID value, and the database is queried to see whetherthere are any matches. If the parameter is found to be alphanumeric, then it is assumed to be an EMAILvalue, and the database is queried to see whether there are any matches. If matches are found in eithercase, then a dynamic SQL string is built to DELETE the matching record from the database.In this example, native dynamic SQL is used to perform the database operation. The DBMS_SQLpackage can also be used to perform this task using the same techniques that were demonstrated inRecipe 8-3.8-6. Returning Data from a Dynamic Query into a RecordProblemYou are writing a block of code that will need to use dynamic SQL to execute a query because the exactSQL string is not known until runtime. The query needs to return the entire contents of the table row sothat all columns of data can be used. You want to return the columns into a record variable.SolutionCreate a native dynamic SQL query to accommodate the SQL string that is unknown until runtime. FETCHthe data using BULK COLLECT into a table of records. Our solution example shows rows from the jobs tablebeing fetched into records, after which the individual record columns of data can be worked with. Thefollowing code block demonstrates this technique:CREATE OR REPLACE PROCEDURE obtain_job_info(min_sal  NUMBER DEFAULT 0,max_sal  NUMBER DEFAULT 0)AS  sql_text      VARCHAR2(1000);  TYPE job_tab IS TABLE OF jobs%ROWTYPE;  job_list      job_tab;  job_elem      jobs%ROWTYPE;  max_sal_temp  NUMBER;  filter_flag   BOOLEAN :&#x3D; FALSE;  cursor_var    NUMBER;  TYPE          cur_type IS REF CURSOR;  cur           cur_type;BEGIN  sql_text :&#x3D; ‘SELECT * ‘ ||              ‘FROM JOBS WHERE ‘ ||              ‘min_salary &gt;&#x3D; :min_sal ‘ ||              ‘and max_salary &lt;&#x3D; :max_sal’; \n  CHAPTER 8  DYNAMIC SQL171  IF max_sal &#x3D; 0 THEN    SELECT max(max_salary)    INTO max_sal_temp    FROM JOBS;  ELSE    max_sal_temp :&#x3D; max_sal;  END IF; \n  OPEN cur FOR sql_text USING min_sal, max_sal_temp;  FETCH cur BULK COLLECT INTO job_list;  CLOSE cur; \n  FOR i IN job_list.FIRST .. job_list.LAST LOOP    DBMS_OUTPUT.PUT_LINE(job_list(i).job_id || ‘ - ‘ || job_list(i).job_title);  END LOOP; \nEND; \nAs the salaries are obtained from the user input, they are used to determine how the bind variableswill be populated within the query. The SQL is then executed, and the results are traversed. Each recordis fetched and returned into a PL&#x2F;SQL table of job records using BULK_COLLECT, and then in turn, eachrecord is used to process the results. In this example, the data is simply printed out usingDBMS_OUTPUT.PUT_LINE, but any number of tasks could be completed with the data.How It WorksDynamic SQL can be processed in a number of ways. In this solution, a record type is created by usingthe %ROWTYPE attribute of the table that is being queried. In this case, the %ROWTYPE attribute of the JOBStable is being used as a record. The data that is returned from performing a SELECT * on the JOBS tablewill be stored within that record, and then it will be processed accordingly. The record is created usingthe following syntax: \nrecord_name     table_name%ROWTYPE; \nUsing this format, the record_name is any name of your choice that complies with PL&#x2F;SQL’s namingconventions. The table_name is the name of the table from which you will be gathering the data for eachcolumn, and the %ROWTYPE attribute is a special table attribute that creates a record type.To process each record, create a REF CURSOR using the dynamic SQL string and perform a BULKCOLLECT to fetch each row of data into a record in the table of JOBS records. The BULK COLLECT will load allof the resulting records at once into a PL&#x2F;SQL collection object. Once all the data has been retrieved intoan object, it can be processed accordingly. The BULK COLLECT is much more efficient than fetching eachrow from the table one-by-one using a LOOP construct.8-7. Executing a Dynamic Block of PL&#x2F;SQLProblemYou want to execute a specific stored procedure based upon events that occur within your application.Therefore, you need to provide the ability for your application to execute procedures that are unknownuntil runtime. In short, you want to execute PL&#x2F;SQL in the same dynamic manner as SQL.CHAPTER 8  DYNAMIC SQL172Solution #1Native dynamic SQL can be used to create and execute a block of code at runtime. This strategy can beused to create a dynamic block of code that executes a given procedure when an event occurs. In thisexample, a procedure is created that accepts an event identifier. An event handler within the applicationcan call upon this procedure passing an event identifier, and subsequently a procedure that can bedetermined via the identifier will be invoked. \n– Create first ProcedureCREATE OR REPLACE PROCEDURE TEST_PROCEDURE1 ASBEGIN  DBMS_OUTPUT.PUT_LINE(‘YOU HAVE EXECUTED PROCEDURE 1…’);END; \n– Create Second ProcedureCREATE OR REPLACE PROCEDURE TEST_PROCEDURE2 ASBEGIN  DBMS_OUTPUT.PUT_LINE(‘YOU HAVE EXECUTED PROCEDURE 2…’);END; \n– Create Event Handling ProcedureCREATE OR REPLACE PROCEDURE run_test(test_id  IN NUMBER DEFAULT 1) AS  sql_text  VARCHAR2(200);BEGIN  sql_text :&#x3D; ‘BEGIN ‘ ||              ‘  TEST_PROCEDURE’ || test_id || ‘; ‘ ||              ‘END;’; \n  EXECUTE IMMEDIATE sql_text; \nEND; \nWhen an event handler passes a given event number to this procedure, it dynamically creates a codeblock that is used to execute that procedure, passing the parameters the procedure needs. This solutionprovides the ultimate flexibility for creating an event handler within your applications.Solution #2DBMS_SQL can also be used to execute the same dynamic code. The following example demonstrates howthis is done. \nCREATE OR REPLACE PROCEDURE run_test(test_id  IN NUMBER DEFAULT 1) AS  sql_text  VARCHAR2(200);  cursor_var   NUMBER :&#x3D; DBMS_SQL.OPEN_CURSOR;  rows       NUMBER;BEGIN  sql_text :&#x3D; ‘BEGIN ‘ ||              ‘  TEST_PROCEDURE’ || test_id || ‘; ‘ ||              ‘END;’; \n  DBMS_SQL.PARSE(cursor_var, sql_text, DBMS_SQL.NATIVE);  CHAPTER 8  DYNAMIC SQL173  rows :&#x3D; DBMS_SQL.EXECUTE(cursor_var);  DBMS_SQL.CLOSE_CURSOR(cursor_var); \nEND;How It WorksNative dynamic SQL allows processing of a SQL statement via the EXECUTE IMMEDIATE statement. Thiscan be used to the advantage of the application and provide the ability to create dynamic blocks ofexecutable code. By doing so, you can create an application that allows more flexibility, which can helpensure that your code is more easily manageable.In the solution to this recipe, an unknown procedure name along with its parameters isconcatenated into a SQL string that forms a code block. This code block is then executed using theEXECUTE IMMEDIATE statement.Using native dynamic SQL, the array of parameters has to be manually processed to create the SQLstring and assign each of the array values to the USING clause of the EXECUTE IMMEDIATE statement. Thistechnique works quite well, but there is a different way to implement the same procedure.As far as comparing native dynamic SQL and DBMS_SQL for dynamic code block execution, whichcode is better? That is up to you to decide. If you are using native dynamic SQL for all other dynamic SQLprocessing within your application, then it is probably a good idea to stick with it instead of mixing bothtechniques. However, if you are working with some legacy code that perhaps includes a mixture of bothDBMS_SQL and native dynamic SQL, then you may prefer to write a dynamic code block using DBMS_SQLjust to save some time and processing.8-8. Creating a Table at RuntimeProblemYour application needs to have the ability to create tables based upon user input. The user has the abilityto add additional attributes to some of your application forms, and when this is done, a new attributetable needs to be created to hold the information.SolutionCreate a table at runtime using native dynamic SQL. Write a procedure that accepts a table name as anargument and then creates a SQL string including the DDL that is required for creating that table. Thetable structure will be hard-coded since the structure for an attribute table will always be the samewithin your application. The code that follows demonstrates this technique by creating a procedurenamed CREATE_ATTR_TABLE that dynamically creates attribute tables. \nCREATE OR REPLACE PROCEDURE create_attr_table(table_name      VARCHAR2) AS  BEGIN    EXECUTE IMMEDIATE ‘CREATE TABLE ‘ || table_name ||                                           ‘(ATTRIBUTE_ID     NUMBER PRIMARY KEY,                                             ATTRIBUTE_NAME   VARCHAR2(150) NOT NULL,                                             ATTRIBUTE_VALUE  VARCHAR2(150))’;  END create_attr_table; \nCHAPTER 8  DYNAMIC SQL174This procedure is invoked by the application whenever a user determines that additional attributesare required for a particular application form. That form will then have its own attribute table created,and the user can then provide additional fields&#x2F;attributes to customize the form as needed.How It WorksDynamic SQL can be used to create database objects at runtime. In this recipe, it is used to create tables.Native dynamic SQL is used in this example, and the EXECUTE IMMEDIATE statement performs the work.When creating a table at runtime, generate a string that contains the necessary SQL to create the object.Once that task has been completed, issue the EXECUTE IMMEDIATE statement passing the generated SQLstring. The format to use along with the EXECUTE IMMEDIATE statement to create objects is as follows: \n EXECUTE IMMEDIATE SQL_string; \nThe SQL_string in this example is a dynamically created string that will create an object. In the caseof creating objects, the USING clause is not used because you cannot use bind variables for substitutingobject names or attributes such as column names.■ Please use care when concatenating user input variables with SQL text because the technique poses a securityconcern. Specifically, you open the door to the much-dreaded SQL injection attack. Refer to Recipe 8-14 for moredetails and for information on protecting yourself.8-9. Altering a Table at RuntimeProblemYour application provides the ability to add attributes to forms in order to store additional information.You need to provide users with the ability to make those attribute fields larger or smaller based upontheir needs.SolutionCreate a procedure that will provide the ability to alter tables at runtime using native dynamic SQL. Theprocedure in this solution will accept two parameters, those being the table name to be altered and thecolumn name along with new type declaration. The procedure assembles a SQL string using thearguments provided by the user and then executes it using native dynamic SQL. The following codedemonstrates this solution: \nCREATE OR REPLACE PROCEDURE modify_table(tab_name    VARCHAR2,                                         tab_info    VARCHAR2) AS                                         sql_text    VARCHAR2(1000);BEGIN  sql_text :&#x3D; ‘ALTER TABLE ‘ || tab_name ||              ‘ MODIFY ‘ || tab_info;  DBMS_OUTPUT.PUT_LINE(sql_text);  CHAPTER 8  DYNAMIC SQL175  EXECUTE IMMEDIATE sql_text;  DBMS_OUTPUT.PUT_LINE(‘Table successfully altered…’);EXCEPTION  WHEN OTHERS THEN    DBMS_OUTPUT.PUT_LINE(‘An error has occurred, table not modified’);END; \nThe procedure determines whether the user-defined data is valid. If so, then the EXECUTE IMMEDIATEstatement executes the SQL string that was formed. Otherwise, the user will see an alert displayed.How It WorksSimilar to creating objects at runtime, Oracle provides the ability to alter objects using dynamic SQL.The same technique is used for constructing the SQL string as when creating an object, and that string iseventually executed via the EXECUTE IMMEDIATE statement. The EXECUTE IMMEDIATE statement for alteringa table at runtime uses no clause, because it is not possible to use bind variables with an ALTER TABLEstatement. If you try to pass in bind variable values, then you will receive an Oracle error.The following format should be used when issuing the EXECUTE IMMEDIATE statement for SQL textcontaining an ALTER TABLE statement: \nEXECUTE IMMEDIATE alter_table_sql_string; \nThe most important thing to remember when issuing a DDL statement using dynamic SQL is thatyou will need to concatenate all the strings and variables in order to formulate the final SQL string thatwill be executed. Bind variables will not work for substituting table names or column names&#x2F;attributes.8-10. Finding All Tables That Include a Specific Column ValueProblemYou are required to update all instances of a particular data column value across multiple tables withinyour database.SolutionSearch all user tables for the particular column you are interested in finding. Create a cursor that will beused to loop through all the results and execute a subsequent UPDATE statement in each iteration of theloop. The UPDATE statement will update all matching column values for the table that is current for thatiteration of the cursor.The following example shows how this technique can be performed. The procedure will be used tochange a manager ID when a department or job position changes management.  \nCREATE OR REPLACE PROCEDURE change_manager(current_manager_id NUMBER, \nnew_manager_id  NUMBER)AS \ncursor manager_tab_cur isselect table_namefrom user_tab_columnsCHAPTER 8  DYNAMIC SQL176where column_name &#x3D; ‘MANAGER_ID’and table_name not in (select view_name from user_views); \nrec_count            number :&#x3D; 0;ref_count            number :&#x3D; 0; \nBEGIN \n   – Print out the tables which will be updated \n   DBMS_OUTPUT.PUT_LINE(‘Tables referencing the selected MANAGER ID#:’ || current_manager_id); \n   FOR manager_rec IN manager_tab_cur LOOP      EXECUTE IMMEDIATE ‘select count(*) total ‘ ||                        ‘from ‘ || manager_rec.table_name ||                        ‘ where manager_id &#x3D; :manager_id_num’      INTO rec_count      USING current_manager_id; \n  if rec_count &gt; 0 then \n               DBMS_OUTPUT.PUT_LINE(manager_rec.table_name || &#39;: &#39; || rec_count); \n               ref_count := ref_count + 1; \n  end if; \n\n  rec_count := 0; \n\n   END LOOP; \n   if ref_count &gt; 0 then      DBMS_OUTPUT.PUT_LINE(‘Manager is referenced in ‘ || ref_count || ‘ tables.’);      DBMS_OUTPUT.PUT_LINE(‘…Now Changing the Manager Identifier…’);   end if; \n   – Perform the actual table updates \n   FOR manager_rec IN manager_tab_cur LOOP      EXECUTE IMMEDIATE ‘select count(*) total ‘ ||                                                  ‘from ‘ || manager_rec.table_name ||                                                  ‘ where manager_id &#x3D; :manager_id_num’      INTO rec_count      USING current_manager_id; \n  if rec_count &gt; 0 then \n\n     EXECUTE IMMEDIATE &#39;update &#39; || manager_rec.table_name || &#39; &#39; || \n                                                 &#39;set manager_id = :new_manager_id &#39; || \n                                                 &#39;where manager_id = :old_manager_id&#39; \n     USING new_manager_id, current_manager_id; \n\n  end if; \n\n  CHAPTER 8  DYNAMIC SQL177      rec_count :&#x3D; 0; \n   END LOOP; \n   – Print out the tables which still reference the manager number. \n   FOR manager_rec IN manager_tab_cur LOOP      EXECUTE IMMEDIATE ‘select count(*) total ‘ ||                        ‘from ‘ || manager_rec.table_name ||                        ‘ where manager_id &#x3D; :manager_id’      INTO rec_count      USING current_manager_id; \n  if rec_count &gt; 0 then \n               DBMS_OUTPUT.PUT_LINE(manager_rec.table_name || &#39;: &#39; || rec_count); \n               ref_count := ref_count + 1; \n  end if; \n\n  rec_count := 0; \n\n   END LOOP; \n   if ref_count &gt; 0 then      DBMS_OUTPUT.PUT_LINE(‘Manager #: ‘ || current_manager_id                           || ‘ is now referenced in ‘ ||                       ref_count || ‘ tables.’);      DBMS_OUTPUT.PUT_LINE(‘…There should be no tables listed above…’);   end if; \nend; \nSince MANAGER_ID depends upon a corresponding MANAGER_ID within the DEPARTMENTS table, you mustfirst ensure that the MANAGER_ID that you want to change to is designated to a department within thattable. In the following scenario, a manager is added to a department that does not have a manager.Afterward, the manager with ID of 205 is swapped for the newly populated manager. \nSQL&gt; update departments  2  set manager_id &#x3D; 241  3  where department_id &#x3D; 270; \n1 row updated. \nSQL&gt; exec change_manager(205, 241);Tables referencing the selected MANAGER ID#:205DEPARTMENTS: 1EMP: 1EMPLOYEES: 1Manager is referenced in 3 tables.…Now Changing the Manager Identifier…Manager #: 205 is now referenced in 3 tables.…There should be no tables listed above… \nCHAPTER 8  DYNAMIC SQL178PL&#x2F;SQL procedure successfully completed.■ Note If you attempt to swap a manager with one that is not associated with a department, then you will receivea foreign key error. This same concept holds true in the real world—ensure that constraints are reviewed beforeapplying this technique.If management decides to change a manager for a particular department, then this procedure willbe called. The caller will pass in the old manager’s ID number and the new manager’s ID number. Thisprocedure will then query all tables within the current schema for a matching current manager ID andupdate it to reflect the new ID number.How It WorksTo determine all instances of a specific column or database field, you must search all database tables forthat column name. Of course, this assumes that the database was created using the same name for thesame column in each different table. If columns containing the same data are named differently acrosstables, then this recipe’s technique will not work.■ Note Although most relational databases are set up with efficiency in mind and only populate data for a specificfield value into one database table column, there are some legacy databases that still use the same fields acrossmore than one table.As the solution to this recipe entails, assume that a column name is coded into the procedure, andall tables will then be searched to find out whether that column exists. You can perform the search usingthe built-in USER_TAB_COLUMNS data dictionary view. This view is comprised of column information for allthe tables within a particular schema. Querying any Oracle view that is prefixed with USER_ indicates thatthe view pertains to data contained within the current user’s schema only. Querying theUSER_TAB_COLUMNS view allows a table name and column name to be specified. In this case, since youneed to find all tables that contain a specific column, query the USER_TAB_COLUMNS view to return allinstances of TABLE_NAME where COLUMN_NAME is equal to the name that is passed into the procedure. Thisquery should be defined as a cursor variable so that it can be parsed via a FOR loop in the code block.■ Warning Be sure to exclude views from this process, or you may receive an error from attempting to update avalue that is contained within a view if it is not an updatable view.Now that the cursor is ready to parse all table names that contain a matching column, it is time toloop through the cursor and query each table that contains that column for a matching value. A user  CHAPTER 8  DYNAMIC SQL179passes two values into the procedure: current manager ID and new manager ID. In the solution to thisrecipe, each table that contains a matching column is queried so that you can see how many matcheswere found prior to the updates taking place. A counter is used to tally the number of matches foundthroughout the tables. Next, looping through the cursor again performs the actual updates. This time,the tables are each queried to find matches again, but when a match is found, then that table will beupdated so that the value is changed from the old value to the new value.Lastly, the cursor is parsed again, and each table is queried to find existing matches once again. Thislast loop is done for consistency and to ensure that all matches have been found and updated to thecurrent value. If any matches are found during this last loop, then all changes should be rolled back, andthe changes should be manually processed instead.This procedure can be updated to work with any column value change that may be needed. Thecode can also be shortened significantly if you do not want to perform verifications prior to and afterperforming an update.8-11 Storing Dynamic SQL in Large ObjectsProblemThe SQL code that you need to assemble at runtime is likely to exceed the 32KB limit that is bound toVARCHAR2 types. You need to be able to store dynamic SQL text in a type that will allow more for a largeamount of text.Solution #1Declare a CLOB variable, and store your SQL string within it. After the CLOB has been created, execute theSQL. This can be done using either native dynamic SQL or the DBMS_SQL package. For the example,assume that a block of text is being read from an external file, and it will be passed to a procedure to beprocessed. That text will be the SQL string that will be dynamically processed within the procedure.Since the external text file can be virtually any size, this text must be read into a CLOB data type and thenpassed to the procedure in this example for processing. The following procedure processes the CLOB asdynamic SQL.The first example demonstrates the parsing and execution of a dynamic SQL statement that hasbeen stored in a CLOB using the DBMS_SQL package. Note that this procedure does not return any value, soit is not meant for issuing queries but rather for executing code. \nCREATE OR REPLACE PROCEDURE execute_clob(sql_text CLOB) AS  sql_string    CLOB;  cur_var       BINARY_INTEGER;  ret_var       INTEGER;  return_value  VARCHAR2(100);BEGIN  sql_string :&#x3D; sql_text;  cur_var :&#x3D; DBMS_SQL.OPEN_CURSOR;  DBMS_SQL.PARSE(cur_var, sql_string, DBMS_SQL.NATIVE);  ret_var :&#x3D; DBMS_SQL.EXECUTE(cur_var);  DBMS_SQL.CLOSE_CURSOR(cur_var);END;CHAPTER 8  DYNAMIC SQL180Solution #2The second example is the same procedure written to use native dynamic SQL. You will notice that thecode is a bit shorter, and there is less work that needs to be done in order to complete the sametransaction.CREATE OR REPLACE PROCEDURE execute_clob_nds(sql_text    IN CLOB) AS  sql_string    CLOB;BEGIN  sql_string :&#x3D; sql_text;  EXECUTE IMMEDIATE sql_string;END;As noted previously, the native dynamic SQL is easier to follow and takes less code to implement.For the sake of maintaining a current code base, use of native dynamic SQL would be encouraged.However, DBMS_SQL is still available and offers different options as mentioned in the first recipes in thischapter.How It WorksOracle added some new features for working with dynamic SQL into the Oracle Database 11g release.Providing the ability to store dynamic SQL into a CLOB is certainly a useful addition. Prior to OracleDatabase 11g, the only way to dynamically process a string that was larger than 32KB was to concatenatetwo VARCHAR types that were at or near 32KB in size. The largest string that could be processed by nativedynamic SQL was 64KB. With the release of Oracle Database 11g, the CLOB (character large object) can beused in such cases, mitigating the need to concatenate two different variables to form the complete SQL.Using DBMS_SQL and its PARSE function, SQL that is stored within a CLOB can be easily processed. Thefollowing lines of code are the lines from the first solution that read and process the CLOB:cur_var :&#x3D; DBMS_SQL.OPEN_CURSOR;DBMS_SQL.PARSE(cur_var, v_sql, DBMS_SQL.NATIVE);ret_var :&#x3D; DBMS_SQL.EXECUTE(cur_var);DBMS_SQL.CLOSE_CURSOR(cur_var);The first line opens a new cursor using DBMS_SQL.OPEN_CURSOR. It assigns an integer to the cur_varvariable, which is then passed to the DBMS_SQL.PARSE procedure. DBMS_SQL.PARSE also accepts the SQLCLOB and a constant DBMS_SQL.NATIVE that helps discern the dialect that should be used to process theSQL. The dialect is also referred to as the language_flag, and it is used to determine how Oracle willprocess the SQL statement. Possible values include V6 for version 6 behavior, V7 for Oracle database 7behavior, and NATIVE to specify normal behavior for the database to which the program is connected.After the SQL has been parsed, it can be executed using the DBMS_SQL.EXECUTE function. This functionwill accept the cursor variable as input and execute the SQL. A code of 0 is returned if the SQL isexecuted successfully. Lastly, remember to close the cursor using DBMS_SQL.CLOSE_CURSOR and passingthe cursor variable to it.The example in Solution #2 of this recipe demonstrates the use of native dynamic SQL for executionof dynamic SQL text that is stored within a CLOB. Essentially no differences exist between the execution ofSQL text stored in a VARCHAR data type as opposed to SQL text stored within a CLOB for native dynamicSQL. The code is short and precise, and it is easy to read.  CHAPTER 8  DYNAMIC SQL1818-12. Passing NULL Values to Dynamic SQLProblemYou want to pass a NULL value to a dynamic query that you are using. For example, you want to query theEMPLOYEES table for all records that have a NULL MANAGER_ID value.SolutionCreate an uninitialized variable, and place it into the USING clause. In this example, a dynamic query iswritten and executed using native dynamic SQL. The dynamic query will retrieve all employees who donot currently have a manager assigned to their record. To retrieve the records that are required, theWHERE clause needs to filter the selection so that only records containing a NULL MANAGER_ID value arereturned. \nDECLARE  TYPE cur_type IS REF CURSOR;  cur                cur_type;  null_value         CHAR(1);  sql_string         VARCHAR2(150);  emp_rec            employees%ROWTYPE;BEGIN  sql_string :&#x3D; ‘SELECT * ‘ ||                    ‘FROM EMPLOYEES ‘ ||                    ‘WHERE MANAGER_ID IS :null_val’; \n  OPEN cur FOR sql_string USING null_value;  LOOP    FETCH cur INTO emp_rec;    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ‘ ‘ || emp_rec.last_name ||                                                        ‘ - ‘ || emp_rec.email);    EXIT WHEN cur%NOTFOUND;  END LOOP;  CLOSE cur; END; \nIn this solution, the bind variable :null_val has an uninitialized variable value substituted in itsplace. This will cause the query to evaluate the bind variable as a NULL value. All records that residewithin the EMPLOYEES table and do not have a MANAGER_ID assigned to them should be printed by theDBMS_OUTPUT package.How It WorksIt is not possible to simply pass a NULL value using native dynamic SQL. At least, you cannot pass a NULLas a literal. However, oftentimes it is useful to initialize a bind variable to null.An uninitialized variable in PL&#x2F;SQL inherently has the value of NULL. Hence, if you do not initialize avariable, then it will contain a NULL value. Passing an uninitialized variable via the EXECUTE IMMEDIATEstatement will have the same effect as substituting a NULL value for a bind variable.CHAPTER 8  DYNAMIC SQL1828-13. Switching Between DBMS_SQL and Native Dynamic SQLProblemYour consulting company is currently migrating all its applications from using DBMS_SQL to nativedynamic SQL. To help ensure that the migration can be done piecemeal, you want to provide the abilityto switch between the two different techniques so that legacy code can coexist with the newer nativedynamic SQL.SolutionWhen you need both the DBMS_SQL package and native dynamic SQL, you can switch between them usingthe DBMS_SQL.TO_REFCURSOR and DBMS_SQL.TO_CURSOR_NUMBER APIs. The DBMS_SQL.TO_REFCURSOR APIprovides the ability to execute dynamic SQL using the DBMS_SQL package and then convert the DBMS_SQLcursor to a REF CURSOR. The DBMS_SQL.TO_CURSOR_NUMBER API allows for executing dynamic SQL via a REFCURSOR and then converting to DBMS_SQL for data retrieval.The following example illustrates the usage of DBMS_SQL.TO_REFCURSOR. In the example, a simpledynamic query is being executed using DBMS_SQL, and the cursor is then being converted to a REF CURSOR. \nDECLARE  sql_string           CLOB;  cur_var              BINARY_INTEGER :&#x3D; DBMS_SQL.OPEN_CURSOR;  ref_cur              SYS_REFCURSOR;  return_value         BINARY_INTEGER;  cur_rec              jobs%ROWTYPE;  salary               NUMBER :&#x3D; &amp;salary;BEGIN  – Formulate query  sql_string :&#x3D; ‘SELECT * FROM JOBS ‘ ||                      ‘WHERE MAX_SALARY &gt;&#x3D; :sal’;  – Parse SQL  DBMS_SQL.PARSE(cur_var, sql_string, DBMS_SQL.NATIVE); \n  – Bind variable(s)  DBMS_SQL.BIND_VARIABLE(cur_var, ‘sal’, salary); \n  – Execute query and convert to REF CURSOR \n  return_value :&#x3D; DBMS_SQL.EXECUTE(cur_var);  ref_cur :&#x3D; DBMS_SQL.TO_REFCURSOR(cur_var);  DBMS_OUTPUT.PUT_LINE(‘Jobs that have a maximum salary over ‘ || salary);  LOOP    FETCH ref_cur INTO cur_rec;    DBMS_OUTPUT.PUT_LINE(cur_rec.job_id || ‘ - ‘ || cur_rec.job_title);    EXIT WHEN ref_cur%NOTFOUND;  END LOOP; \n  CLOSE ref_cur; \nEND;  CHAPTER 8  DYNAMIC SQL183 \nThe example prompts for the entry of a maximum salary via the :sal bind variable and the SQL*Plus&amp;salary substitution variable. The DBMS_SQL API then binds the maximum salary that was entered to thedynamic SQL string and executes the query to find all jobs that have a maximum salary greater than theamount that was entered. Once the query is executed, the cursor is converted to a REF CURSOR using theDBMS_SQL.TO_REFCURSOR API. Native dynamic SQL is then used to process the results of the query. As youcan see, the native dynamic SQL is much easier to read and process. The advantage of converting to aREF CURSOR is to have the ability to easily process code using native dynamic SQL but still have some ofthe advantages of using DBMS_SQL for querying the data. For instance, if the number of bind variables wasunknown until runtime, then DBMS_SQL would be required.A similar technique can be used if DBMS_SQL is required to process the results of a query. TheDBMS_SQL.TO_CURSOR_NUMBER API provides the ability to convert a cursor from a REF CURSOR to DBMS_SQL.The following example shows the same query on the JOBS table, but this time native dynamic SQL is usedto set up the query and execute it, and DBMS_SQL is used to describe the table structure. One of the nicefeatures of the DBMS_SQL API is that it is possible to describe the columns of a query that will be returned. \nDECLARE  sql_string         CLOB;  ref_cur            SYS_REFCURSOR;  cursor_var         BINARY_INTEGER;  cols_var           BINARY_INTEGER;  desc_var           DBMS_SQL.DESC_TAB;  v_job_id           NUMBER;  v_job_title        VARCHAR2(25);  salary             NUMBER(6) :&#x3D; &amp;salary;  return_val         NUMBER; \nBEGIN  – Formulate query  sql_string :&#x3D; ‘SELECT * FROM JOBS ‘ ||                          ‘WHERE MAX_SALARY &gt;&#x3D; :sal’;  – Open REF CURSOR  OPEN ref_cur FOR sql_string USING salary; \n  cursor_var :&#x3D; DBMS_SQL.TO_CURSOR_NUMBER(ref_cur);  DBMS_SQL.DESCRIBE_COLUMNS(cursor_var, cols_var, desc_var);  DBMS_SQL.CLOSE_CURSOR(cursor_var); \n  FOR x IN 1 .. cols_var LOOP    DBMS_OUTPUT.PUT_LINE(desc_var(x).col_name || ‘ - ‘ ||                           CASE desc_var(x).col_type                                      WHEN 1 THEN ‘VARCHAR2’                                      WHEN 2 THEN ‘NUMBER’                           ELSE ‘OTHER’                           END);  END LOOP;END; \nEach of these techniques has their place within the world of PL&#x2F;SQL programming. Using this typeof conversion is especially useful for enabling your application to use the features DBMS_SQL has to offerwithout compromising the ease and structure of native dynamic SQL.CHAPTER 8  DYNAMIC SQL184How It WorksOracle Database 11g added some new capabilities to dynamic SQL. One of those new features is theability to convert between native dynamic SQL and DBMS_SQL. DBMS_SQL provides some functionality thatis not offered by the newer and easier native dynamic SQL API. Now that Oracle Database 11g providesthe ability to make use of native dynamic SQL but still gain the advantages of using DBMS_SQL, Oracledynamic SQL is much more complete.The DBMS_SQL.TO_REFCURSOR API is used to convert SQL that is using DBMS_SQL into a REF CURSOR,which allows you to work with the resulting records using native dynamic SQL. To convert SQL to a REFCURSOR, you will use DBMS_SQL to parse the SQL, bind any variables, and finally to execute it. Afterward,you call DBMS_SQL.TO_REFCURSOR and pass the original DBMS_SQL cursor as an argument. This will return aREF CURSOR that can be used to work with the results from the query. The statement that performs theconversion contains DBMS_SQL.EXECUTE. The EXECUTE function accepts a DBMS_SQL cursor as an argument.As a result, a REF CURSOR is returned, and it can be used to work with the results from the dynamic query.Conversely, DBMS_SQL.TO_CURSOR_NUMBER can be used to convert a REF CURSOR into a DBMS_SQL cursor.You may choose to do this in order to use some additional functionality that DBMS_SQL has to offer suchas the ability to DESCRIBE an object (DESCRIBE is a SQL*Plus feature). As you can see in the secondexample, native dynamic SQL is used to open the REF CURSOR and bind the variable to the SQL. Once thishas been completed, the cursor is converted to DBMS_SQL using DBMS_SQL.TO_CURSOR_NUMBER and passingthe REF CURSOR. After this conversion is complete, you can utilize the DBMS_SQL API to work with theresulting cursor.8-14. Guarding Against SQL Injection AttacksProblemTo provide the best security for your application, you want to ensure that your dynamic SQL statementsare unable to be altered as a result of data entered from an application form.SolutionTake care to provide security against SQL injection attacks by validating user input prior and using it inyour dynamic SQL statements or queries. The easiest way to ensure that there are no maliciousinjections into your SQL is to make use of bind variables.The following code is an example of a PL&#x2F;SQL procedure that is vulnerable to SQL injection becauseit concatenates a variable that is populated with user input and does not properly validate the inputprior: \nCREATE OR REPLACE PROCEDURE check_password(username IN VARCHAR2) AS  sql_stmt    VARCHAR2(1000);  password    VARCHAR2(30);BEGIN sql_stmt :&#x3D; ‘SELECT password ‘ ||                       ‘FROM user_records ‘ ||                       ‘WHERE username &#x3D; ‘’’ || username || ‘’’;  EXECUTE sql_stmt  INTO password; \n  – PROCESS PASSWORDEND;  CHAPTER 8  DYNAMIC SQL185 \nTo properly code this example to guard against SQL injection, use bind variables. The following isthe same procedure that has been rewritten to make it invulnerable to SQL injection: \nCREATE OR REPLACE PROCEDURE check_password(username IN VARCHAR2) AS  sql_stmt    VARCHAR2(1000);  password    VARCHAR2(30);BEGIN  sql_stmt :&#x3D; ‘SELECT password ‘ ||              ‘FROM user_records ‘ ||              ‘WHERE username &#x3D; :username’; \n  EXECUTE sql_stmt  INTO password  USING username; \n  – PROCESS PASSWORDEND; \nMaking just a couple of minor changes can significantly increase the security against SQL injectionattacks.How It WorksSQL injection attacks can occur when data that is accepted as input from an application form isconcatenated into dynamic SQL queries or statements without proper validation. SQL injection is a formof malicious database attack that is caused by a user placing some code or escape characters into a formfield so that the underlying application SQL query or statement becomes affected in an undesirablemanner. In the solution to this recipe, all passwords stored in the USER_RECORDS table could becompromised if a malicious user were to place a line of text similar to the following into the form fieldfor the USERNAME: \n‘WHATEVER ‘’ OR username is NOT NULL–’ \nThe strange-looking text that you see here can cause major issues because it essentially changes thequery to read as follows: \nSELECT passwordFROM user_recordsWHERE username &#x3D; ‘WHATEVER ‘ OR username is NOT NULL; \nBind variables can be used to guard against SQL injection attacks, because their contents are notinterpreted at all by Oracle. The value of a bind variable is never parsed as part of the string containingthe SQL query or statement to be executed. Thus, the use of bind variables provides absolute protectionagainst SQL injection attacks.Another way to safeguard your code against SQL injection attacks is to validate user input to ensurethat it is not malicious. Only valid input should be used within a statement or query.There are ways to validate user input depending upon the type of input you are receiving. Forinstance, to verify the integrity of user input, you can use regular expressions. If you are expecting toreceive an e-mail address from a user input field, then the value that is passed into your code should beverified to ensure that it is in proper format of an e-mail address. Here’s an example:CHAPTER 8  DYNAMIC SQL186IF owa_pattern.match(email_variable,’^\\w{1,}[.,0-9,a-z,A-Z,]\\w{1,}’ ||           ‘[.,0-9,a-z,A-Z,]\\w{1,}’||           ‘@\\w{1,}[.,0-9,a-z,A-Z,]&#39; ||           ‘w{1,}[.,0-9,a-z,A-Z,]\\w{1,}[.,0-9,a-z,A-Z,_]\\w{1,}$’) then  – Perform valid transactionELSE  – Raise an error message \nIt is imperative that you do not allow users of your applications to see the Oracle error codes that arereturned by an error. Use proper exception handling (covered in Chapter 9) to ensure that you arecatching any possible exceptions and returning a vaguely descriptive error message to the user. It is notwise to allow Oracle errors or detailed error messages to be displayed because they will most likelyprovide a malicious user with valuable information for attacking your database.Using bind variables, validating user input, and displaying user-friendly and appropriate errormessages can help ensure that your database is not attacked. It is never an enjoyable experience toexplain to your users that all usernames and passwords were compromised. Time is much better spentsecuring your code than going back to clean up after a malicious attack.C H A P T E R  9 \n   \n187ExceptionsExceptions are a fundamental part of any well-written program. They are used to display user-friendlyerror messages when an error is raised by an application, nondefault exception handling, andsometimes recovery so that an application can continue. Surely you have seen your fair share of ORA-XXXXX error messages. Although these messages are extremely useful to a developer for debugging andcorrecting issues, they are certainly foreign to the average application user and can be downrightfrightening to see.Imagine that you are working with a significant number of updates via an application form, andafter you submit your 150th update, an Oracle error is displayed. Your first reaction would be of panic,hoping that you haven’t just lost all of the work you had completed thus far. By adding exceptionhandling to an application, you can ensure that exceptions are handled in an orderly fashion so that nowork is lost. You can also create a nicer error message to let the user know all changes have been savedup to this point so that sheer panic doesn’t set in when the exception is raised.Exceptions can also be raised as a means to provide informative detail regarding processes that areoccurring within your application. They are not merely restricted to being used when Oracle encountersan issue. You can raise your own exceptions as well when certain circumstances are encountered in yourapplication.Whatever the case may be, exception handling should be present in any production-qualityapplication code. This chapter will cover some basics of how to use exception handling in your code.Along the way, you will learn some key tips on how exception handling can make your life easier. In theend, you should be fully armed to implement exception handling for your applications.9-1. Trapping an ExceptionProblemA procedure in your application has the potential to cause an exception to be raised. Rather than let theprogram exit and return control to the host machine, you want to perform some cleanup to ensure dataintegrity, as well as display an informative error message.SolutionWrite an exception handler for your procedure so that the exception can be caught and you can performtasks that need to be completed and provide a more descriptive message. The following procedure isused to obtain employee information based upon a primary key value or an e-mail address. Beginningwith the EXCEPTION keyword in the following example, an exception-handling block has been added tothe end of the procedure in order to handle any exceptions that may occur when no matching record isfound. \nCHAPTER 9  EXCEPTIONS188CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS  emp_qry            VARCHAR2(500);  emp_first          employees.first_name%TYPE;  emp_last           employees.last_name%TYPE;  email              employees.email%TYPE; \n  valid_id_count     NUMBER :&#x3D; 0;  valid_flag         BOOLEAN :&#x3D; TRUE;  temp_emp_info      VARCHAR2(50); \nBEGIN  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;  IF emp_info LIKE ‘%@%’ THEN    temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);    emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;  ELSE    SELECT COUNT(*)    INTO valid_id_count    FROM employees    WHERE employee_id &#x3D; emp_info; \nIF valid_id_count &gt; 0 THEN \n    temp_emp_info := emp_info; \n    emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; \nELSE \n    valid_flag := FALSE; \nEND IF; \n\n  END IF; \n  IF valid_flag &#x3D; TRUE THEN    EXECUTE IMMEDIATE emp_qry    INTO emp_first, emp_last, email    USING temp_emp_info; \nDBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); \n\n  ELSE    DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||                         ‘NOT MATCH ANY EMPLOYEE RECORD’);  END IF; \n  EXCEPTION    WHEN NO_DATA_FOUND THEN      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||                         ‘NOT MATCH ANY EMPLOYEE RECORD’);    WHEN INVALID_NUMBER THEN      DBMS_OUTPUT.PUT_LINE(‘YOU MUST ENTER AN EMAIL ADDRESS INCLUDING ‘ ||                         ‘THE @ OR A POSITIVE INTEGER VALUE FOR THE ‘ ||                         ‘EMPLOYEE ID.’);END; \nHere are the results of calling the procedure with various arguments: \n  CHAPTER 9  EXCEPTIONS189SQL&gt; EXEC OBTAIN_EMP_DETAIL(000);THE INFORMATION YOU HAVE USED DOES NOT MATCH ANY EMPLOYEE RECORD \nPL&#x2F;SQL procedure successfully completed. \nSQL&gt; EXEC OBTAIN_EMP_DETAIL(‘TEST’);YOU MUST ENTER AN EMAIL ADDRESS INCLUDING THE @ OR A POSITIVE INTEGER VALUE FORTHE EMPLOYEE ID. \nPL&#x2F;SQL procedure successfully completed. \nSQL&gt; EXEC OBTAIN_EMP_DETAIL(200);Jennifer Whalen - JWHALEN \nPL&#x2F;SQL procedure successfully completed. \nThis procedure is essentially the same as the one demonstrated in Recipe 8-1. The difference is thatwhen an exception is raised, the control will go into the exception block. At that time, the code you placewithin the exception block will determine the next step to take as opposed to simply raising an Oracleerror and returning control to the calling procedure, calling function, or host environment.How It WorksTo perform remedial actions when an exception is raised, you should always make sure to code anexception handler if there is any possibility that an exception may be thrown. The sole purpose of anexception handler is to catch exceptions when they are raised and handle the outcome in a controlledfashion. There are two different types of exceptions that can be raised by a PL&#x2F;SQL application:internally defined and user defined. Oracle Database has a defined set of internal exceptions that can bethrown by a PL&#x2F;SQL application. Those exceptions are known as internally defined. It is also possible todefine your own exceptions, which are known as user defined.An exception-handling block is structured like a CASE statement in that a series of exceptions is listedfollowed by a separate set of statements to be executed for each outcome. The standard format for anexception-handling block is as follows: \nEXCEPTION  WHEN name_of_exception THEN    – One or more statements \nException blocks begin with the EXCEPTION keyword, followed by a series of WHEN..THEN clauses thatdescribe different possible exceptions along with the set of statements that should be executed if theexception is caught. The exception name can be one of the Oracle internally defined exceptions, or it canbe the name of an exception that has been declared within your code. To learn more about declaringexceptions, please see Recipe 9-3 in this chapter. In the solution to this recipe, the internally definedNO_DATA_FOUND exception is raised if an unknown e-mail address is entered into the procedure becausethere will be no rows returned from the query. When the exception block encounters the WHEN clause thatcorresponds with NO_DATA_FOUND, the statements immediately following the THEN keyword are executed.In this case, an error message is printed using the DBMS_OUTPUT package. However, in a real-worldapplication, this is where you will place any cleanup or error handling that should be done to helpmaintain the integrity of the data accessed by your application.An exception block can contain any number of WHEN..THEN clauses, and therefore, any number ofexceptions can each contain their own set of handler statements. Even if a simple message was to beCHAPTER 9  EXCEPTIONS190displayed, as is the case with the solution to this recipe, a different and more descriptive error messagecan be coded for each different exception that may possibly be raised. This situation is reflected in thesecond exception handler contained within the solution because it returns a different error messagethan the first.As mentioned previously, Oracle contains a number of internally defined exceptions. Table 9-1provides a list of the internally defined exceptions, along with a description of their usage.Table 9-1. Oracle Internal ExceptionsException Code DescriptionACCESS_INTO_NULL -6530 Values are assigned to an uninitialized object.CASE_NOT_FOUND -6592 No matching choice is available within CASE statement, and noELSE clause has been defined.COLLECTION_IS_NULL  -6531 Program attempts to apply collection methods other thanEXISTS to varray or a nested table that has not yet beeninitialized.CURSOR_ALREADY_OPEN -6511 Program attempts to open a cursor that is already open.DUP_VAL_ON_INDEX -1 Program attempts to store duplicate values in a unique indexcolumn.INVALID_CURSOR -1001 Program attempts to use a cursor operation that is allowed.INVALID_NUMBER -1722 Conversion of string into number is incorrect because of thestring not being a number.LOGIN_DEINIED -1017 Program attempts to log in to the database using an incorrectuser name and&#x2F;or password.NO_DATA_FOUND +100 SELECT statement returns no rows.NOT_LOGGED_ON -1012 Program attempts to issue a database call without beingconnected to the database.PROGRAM_ERROR -6501 Internal problem exists.ROWTYPE_MISMATCH -6504 Cursor variables are incompatible. A host cursor variable musthave a compatible return type that matches a PL&#x2F;SQL cursorvariable.SELF_IS_NULL -30625 Instance of object type is not initialized.STORAGE_ERROR -6500 PL&#x2F;SQL ran out of memory or was corrupted.  CHAPTER 9  EXCEPTIONS191Exception Code DescriptionSUBSCRIPT_BEYOND_COUNT  – 6533  Program references nested table or varray element using anindex number that goes beyond the number of elementswithin the object.SYS_INVALID_ROWID -1410  Conversion of character string into ROWID fails becausecharacter string does not represent a valid row ID.TIMEOUT_ON_RESOURCE -51  Oracle Database is waiting for resource, and timeout occurs.TOO_MANY_ROWS -1422  Attempts to select more than one row using a SELECT INTOstatement.VALUE_ERROR -6502  Program attempts to perform an invalid arithmetic,conversion, or truncation operation.ZERO_DIVIDE -1476  Program attempts to divide a number by zero. \nAn exception handler’s scope corresponds to its enclosing code block. They have the same scope asa variable would have within a code block. If your code contains a nested code block, an exceptionhandler that is contained within the nested code block can only handle exceptions raised within thatcode block. The outer code block can contain an exception handler that will handle exceptions for boththe outer code block and the nested code block. If an exception is raised within the nested code blockand there is no corresponding handler for an exception that has been raised within the nested codeblock, then the exception is propagated to the outer code block to look for a corresponding handlerthere. If no handler is found, then runtime will be passed to the procedure or function that called it orthe host system, which is what you do not want to have occur. The following code demonstrates anexample of using an exception handler within a nested code block: \nDECLARE  CURSOR emp_cur IS  SELECT *  FROM EMPLOYEES; \n  emp_rec emp_cur%ROWTYPE;BEGIN  FOR emp_rec IN emp_cur LOOP    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ‘ ‘ ||         emp_rec.last_name);    DECLARE      emp_dept  departments.department_name%TYPE;    BEGIN      SELECT department_name      INTO emp_dept      FROM departments      WHERE department_id &#x3D; emp_rec.department_id;      DBMS_OUTPUT.PUT_LINE(‘Department: ‘ || emp_dept);    EXCEPTIONCHAPTER 9  EXCEPTIONS192      WHEN NO_DATA_FOUND THEN        DBMS_OUTPUT.PUT_LINE(‘EXCEPTION IN INNER BLOCK’);    END;  END LOOP;EXCEPTION  WHEN NO_DATA_FOUND THEN   DBMS_OUTPUT.PUT_LINE(‘EXCEPTION IN OUTER BLOCK’);END; \nMultiple exceptions can be listed within the same exception handler if you want to execute the sameset of statements when either of them is raised. You can do this within the WHEN clause by including twoor more exception names and placing the OR keyword between them. Using this technique, if either ofthe exceptions that are contained within the clause is raised, then the set of statements that follows willbe executed. Let’s take a look at an exception handler that contains two exceptions within the samehandler: \nEXCEPTION  WHEN NO_DATA_FOUND OR INVALID_EMAIL_ADDRESS THEN    –  statements to execute  WHEN OTHERS THEN    –  statements to executeEND;■ Note You cannot place the AND keyword in between exceptions because no two exceptions can be raised at thesame time.It is easy to include basic exception handling in your application. Code an exception-handling blockat the end of each code block that may raise an exception. It is pertinent that you test your applicationunder various conditions to try to predict which possible exceptions may be raised; each of thosepossibilities should be accounted for within the exception-handling block of your code.9-2. Catching Unknown ExceptionsProblemSome exceptions are being raised when executing one of your procedures and you want to ensure thatall unforeseen exceptions are handled using an exception handler.SolutionUse an exception handler, and specify OTHERS for the exception name to catch all the exceptions thathave not been caught by previous handlers. In the following example, the same code from Recipe 9-1has been modified to add an OTHERS exception handler: \nCREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS  emp_qry                   VARCHAR2(500);  CHAPTER 9  EXCEPTIONS193  emp_first                 employees.first_name%TYPE;  emp_last                  employees.last_name%TYPE;  email                     employees.email%TYPE; \n  valid_id_count            NUMBER :&#x3D; 0;  valid_flag                BOOLEAN :&#x3D; TRUE;  temp_emp_info             VARCHAR2(50); \nBEGIN  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;  IF emp_info LIKE ‘%@%’ THEN    temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);    emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;  ELSE    SELECT COUNT(*)    INTO valid_id_count    FROM employees    WHERE employee_id &#x3D; emp_info; \nIF valid_id_count &gt; 0 THEN \n    temp_emp_info := emp_info; \n    emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; \nELSE \n    valid_flag := FALSE; \nEND IF; \n\n  END IF; \n  IF valid_flag &#x3D; TRUE THEN    EXECUTE IMMEDIATE emp_qry    INTO emp_first, emp_last, email    USING temp_emp_info; \nDBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); \n\n  ELSE    DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||                         ‘NOT MATCH ANY EMPLOYEE RECORD’);  END IF; \n  EXCEPTION    WHEN NO_DATA_FOUND THEN      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||                         ‘NOT MATCH ANY EMPLOYEE RECORD’);    WHEN OTHERS THEN      DBMS_OUTPUT.PUT_LINE(‘AN UNEXPECTED ERROR HAS OCCURRED, PLEASE ‘ ||                         ‘TRY AGAIN’);END; \nIn this example, if an unexpected exception were to be raised, then the program control wouldtransfer to the statements immediately following the WHEN OTHERS THEN clause.CHAPTER 9  EXCEPTIONS194■ Note In a real-world application, an exception should be manually reraised within the OTHERS handler. To learnmore about determining the exception that was raised, please see Recipe 9-4.How It WorksYou can use the OTHERS handler to catch all the exceptions that have not been previously handled by anynamed exception handler. It is a good idea to include an OTHERS handler with any exception handler sothat any unknown exceptions can be handled reasonably by your application. However, OTHERS shouldbe used only to assist developers in finding application bugs rather than as a catchall for any exception.The format for using the OTHERS handler is the same as it is with other named exceptions; the onlydifference is that it should be the last handler to be coded in the exception handler. The followingpseudocode depicts a typical exception handler that includes an OTHERS handler: \nEXCEPTION  WHEN named_exception1 THEN    – perform statements  WHEN named_exception2 THEN    – perform statements  WHEN OTHERS THEN    – perform statementsWHEN TO USE THE OTHERS HANDLERIt is important to note that the OTHERS handler is not used to avoid handling expected exceptions properly.Each exception that may possibly be raised should be handled within its own exception-handling block.The OTHERS handler should be used only to catch those exceptions that are not expected. Most often, theOTHERS handler is used to catch application bugs in order to assist a developer in finding and resolvingissues.As stated, the OTHERS handler will catch any exception that has not yet been caught by anotherhandler. It is very important to code a separate handler for each type of named exception that mayoccur. However, if you have one set of statements to run for any type of exception that may occur, then itis reasonable to include only an OTHERS exception handler to catch exceptions that are unexpected. If nonamed exceptions are handled and an exception handler includes only an OTHERS handler, then thestatements within that handler will be executed whenever any exception occurs within an application.9-3. Creating and Raising Named Programmer-Defined ExceptionsProblemYou want to alert the users of your application when a specific event occurs. The event does not raise anOracle exception, but it is rather an application-specific exception. You want to associate this event witha custom exception so that it can be raised whenever the event occurs.  CHAPTER 9  EXCEPTIONS195SolutionDeclare a named user-defined exception, and associate it with the event for which you are interested inraising an exception. In the following example, a user-defined exception is declared and raised within acode block. When the exception is raised, the application control is passed to the statements containedwithin the exception handler for the named user exception. \nCREATE OR REPLACE PROCEDURE salary_increase(emp_id IN NUMBER,                                            pct_increase IN NUMBER) AS \n  salary                employees.salary%TYPE;  max_salary            jobs.max_salary%TYPE;  INVALID_INCREASE      EXCEPTION; \nBEGIN \n  SELECT salary, max_salary  INTO salary, max_salary  FROM employees, jobs  WHERE employee_id &#x3D; emp_id  AND jobs.job_id &#x3D; employees.employee_id; \n  IF (salary + (salary * pct_increase)) &lt;&#x3D; max_salary THEN    UPDATE employees    SET salary &#x3D; (salary + (salary * pct_increase))    WHERE employee_id &#x3D; emp_id; \nDBMS_OUTPUT.PUT_LINE(&#39;SUCCESSFUL SALARY INCREASE FOR EMPLOYEE #: &#39; || \n      emp_id || \n      &#39;.  NEW SALARY = &#39; || salary + (salary * pct_increase)); \n      \n\n  ELSE    RAISE INVALID_INCREASE;  END IF; \nEXCEPTION  WHEN NO_DATA_FOUND THEN    DBMS_OUTPUT.PUT_LINE(‘UNSUCCESSFUL INCREASE, NO EMPLOYEE RECORD FOUND ‘ ||                  ‘FOR THE GIVEN ID’); \n  WHEN INVALID_INCREASE THEN    DBMS_OUTPUT.PUT_LINE(‘UNSUCCESSFUL INCREASE.  YOU CANNOT INCREASE THE ‘ ||                  ‘EMPLOYEE SALARY BY ‘ || pct_increase ||                  ‘PERCENT…PLEASE ENTER ‘ ||                  ‘A SMALLER INCREASE AMOUNT TO TRY AGAIN’); \n  WHEN OTHERS THENCHAPTER 9  EXCEPTIONS196    DBMS_OUTPUT.PUT_LINE(‘UNSUCCESSFUL INCREASE.  AN UNKNOWN ERROR HAS ‘||                  ‘OCCURRED, ‘ ||                  ‘PLEASE TRY AGAIN OR CONTACT ADMINISTRATOR’ || pct_increase); \nEND; \nAs you can see from the code, the exception block can accept one or more handlers. The nameduser exception is declared within the declaration section of the procedure, and the exception can beraised anywhere within the containing block.■ Note In a real-world application, an exception should be manually raised within the OTHERS handler. To learnmore about determining the exception that was raised, please see Recipe 9-4.How It WorksA PL&#x2F;SQL application can contain any number of custom exceptions. When a developer declares theirown exception, it is known as a user-defined exception. A user-defined exception must be declaredwithin the declaration section of a package, function, procedure, or anonymous code block. To declarean exception, use the following: \nexception_name  EXCEPTION; \nYou can provide any name as long as it applies to the standard naming convention and is not thesame as an internally defined exception name. It is a coding convention to code exception names usinguppercase lettering, but lowercase would work as well since PL&#x2F;SQL is not a case-sensitive language.To raise your exception, type the RAISE keyword followed by the name of the exception that youwant to raise. When the code executes the RAISE statement, control is passed to the exception handlerthat best matches the exception that was named in the statement. If no handler exists for the exceptionthat was raised, then control will be passed to the OTHERS handler, if it exists. In the worst-case scenario,if there are not any exception handlers that match the name that was provided in the RAISE statementand there has not been an OTHERS handler coded, then control will be passed back to the enclosing block,the calling code, or the host environment.The RAISE statement can also be used in a couple of other ways. It is possible to raise an exceptionthat has been declared within another package. To do so, fully qualify the name of the exception byprefixing it with the package name. The RAISE statement can also be used stand-alone to reraise anexception.As seen in the solution to this recipe, catching a named user exception is exactly the same ascatching an internally defined exception. Code the WHEN..THEN clause, naming the exception that youwant to catch. When the exception is raised, any statements contained within that particular exceptionhandler will be executed.  CHAPTER 9  EXCEPTIONS1979-4. Determining Which Error Occurred Inside the OTHERS HandlerProblemYour code is continually failing via an exception, and the OTHERS handler is being invoked. You need todetermine the exact cause of the exception so that it can be repaired.SolutionCode the OTHERS exception handler as indicated by Recipe 9-2, and use the SQLCODE andDBMS_UTILITY.FORMAT_ERROR_STACK functions to return the Oracle error code and message text for theexception that has been raised. The following example demonstrates the usage of these functions, alongwith the procedure that was used in Recipe 9-3, for obtaining the error code and message when theOTHERS handler is invoked. \nCREATE OR replace PROCEDURE salary_increase(emp_id       IN NUMBER,                                            pct_increase IN NUMBER)AS  salary              employees.salary%TYPE;  max_salary          jobs.max_salary%TYPE;  invalid_increase    EXCEPTION;  error_number        NUMBER;  error_message       VARCHAR2(1500);BEGIN  SELECT salary,         max_salary  INTO   salary, max_salary  FROM   employees,         jobs  WHERE  employee_id &#x3D; emp_id         AND jobs.job_id &#x3D; employees.employee_id;  \n  IF ( salary + ( salary * pct_increase ) ) &lt;&#x3D; max_salary THEN    UPDATE employees    SET    salary &#x3D; ( salary + ( salary * pct_increase ) )    WHERE  employee_id &#x3D; emp_id;  \ndbms_output.Put_line(&#39;SUCCESSFUL SALARY INCREASE FOR EMPLOYEE #: &#39;  \n                     || emp_id  \n                     || &#39;.  NEW SALARY = &#39;  \n                     || salary + ( salary * pct_increase ));  \n\n  ELSE    RAISE invalid_increase;  END IF;EXCEPTION  WHEN no_data_found THEN    dbms_output.Put_line(‘UNSUCCESSFUL INCREASE, NO EMPLOYEE RECORD FOUND ‘                     || ‘FOR THE ‘                     || ‘GIVEN ID’); WHEN invalid_increase THEN    dbms_output.Put_line(‘UNSUCCESSFUL INCREASE.  YOU CANNOT INCREASE THE ‘                     || ‘EMPLOYEE ‘CHAPTER 9  EXCEPTIONS198                     || ‘SALARY BY ‘                     || pct_increase                     || ‘ PERCENT…PLEASE ENTER ‘                     || ‘A SMALLER INCREASE AMOUNT TO TRY AGAIN’);WHEN OTHERS THEN           error_number :&#x3D; SQLCODE;  \n       error_message := DBMS_UTILITY.FORMAT_ERROR_STACK;  \n\ndbms_output.Put_line(&#39;UNSUCCESSFUL INCREASE.  AN UNKNOWN ERROR HAS &#39; \n                 || &#39;OCCURRED, &#39;  \n                 || &#39;PLEASE TRY AGAIN OR CONTACT ADMINISTRATOR&#39;  \n                 || &#39; Error #: &#39;  \n                 || error_number  \n                 || &#39; - &#39;  \n                 || error_message); \n\nEND;  \nWhen this procedure is executed, the following error will be returned: \nUNSUCCESSFUL INCREASE.  AN UNKNOWN ERROR HAS OCCURRED, PLEASE TRY AGAIN OR CONTACTADMINISTRATOR Error #: -1722 - ORA-01722: invalid number \nThis example intentionally raises an error in order to demonstrate the functionality of these utilities.A reference to the line number that raised the error may also be helpful. To learn more about writing anexception handler that returns line numbers, please see Recipe 9-9.How It WorksThe SQLCODE and DBMS_UTILITY.FORMAT_ERROR_STACK functions provide the means to determine whatcode and message had caused the last exception that was raised. The SQLCODE function will return theOracle error number for internal exceptions and +1 for a user-defined exception. TheDBMS_UTILITY.FORMAT_ERROR_STACK function will return the Oracle error message for any internalexception that is raised, and it will contain the text User-Defined Exception for any named userexception that is raised. A user-defined exception may receive a custom error number, as you will readabout in Recipe 9-9. In such cases, the SQLCODE function will return this custom error number if raised.To use these functions, you must assign them to a variable because they cannot be called outright.For instance, if you wanted to use the SQLCODE within a CASE statement, you would have to assign thefunction to a variable first. Once that has been done, you could use the variable that was assigned theSQLCODE in the statement.Oracle includes DBMS_UTILITY.FORMAT_ERROR_STACK, which can be used to return the error messageassociated with the current error. DBMS_UTILITY.FORMAT_ERROR_STACK can hold up to 1,899 characters, sothere is rarely a need to truncate the message it returns. SQLERRM is a similar function that can be used toreturn the error message, but it only allows messages up to 512 bytes to be displayed. Oftentimes,SQLERRM messages need to be truncated for display. Oracle recommends usingDBMS_UTILITY.FORMAT_ERROR_STACK over SQLERRM because this utility doesn’t have such a small messagelimitation.However, SQLERRM does have its place, because there are some benefits of using it. A handy feature ofSQLERRM is that you can pass an error number to it and retrieve the corresponding error message. Anyerror number that is passed to SQLERRM should be negative; otherwise, you will receive the message User-  CHAPTER 9  EXCEPTIONS199defined error. Table 9-2 displays the error number ranges and their corresponding messages usingSQLCODE and SQLERRM.Table 9-2. SQLCODE Return Codes and MeaningsCode DescriptionNegative Oracle Error Number  Internal Oracle exception0 No exceptions raised+1 User-defined exception+100 NO_DATA_FOUND-20000 to -20999 User-defined error with PRAGMA EXCEPTION_INIT■ Note PRAGMA EXCEPTION_INIT is used to associate an Oracle error number with an exception name.If you choose to use SQLERRM, the code is not much different from usingDBMS_UTILITY.FORMAT_ERROR_STACK, but you will probably need to include some code to truncate theresult. The next example demonstrates the same example that was used in the solution to this recipe, butit uses SQLERRM instead of DBMS_UTILITY.FORMAT_ERROR_STACK. \nCREATE OR replace PROCEDURE salary_increase(emp_id       IN NUMBER,                                            pct_increase IN NUMBER)AS  salary             employees.salary%TYPE;  max_salary         jobs.max_salary%TYPE;  invalid_increase   EXCEPTION;  error_number       NUMBER;  error_message      VARCHAR2(1500);BEGIN  SELECT salary,         max_salary  INTO   salary, max_salary  FROM   employees,         jobs  WHERE  employee_id &#x3D; emp_id         AND jobs.job_id &#x3D; employees.employee_id;  \n  IF ( salary + ( salary * pct_increase ) ) &lt;&#x3D; max_salary THEN    UPDATE employees    SET    salary &#x3D; ( salary + ( salary * pct_increase ) )    WHERE  employee_id &#x3D; emp_id;  \nCHAPTER 9  EXCEPTIONS200    dbms_output.Put_line(‘SUCCESSFUL SALARY INCREASE FOR EMPLOYEE #: ‘                         || emp_id                         || ‘.  NEW SALARY &#x3D; ‘                         || salary + ( salary * pct_increase ));  ELSE    RAISE invalid_increase;  END IF;EXCEPTION  WHEN no_data_found THEN    dbms_output.Put_line(‘UNSUCCESSFUL INCREASE, NO EMPLOYEE RECORD FOUND ‘                     || ‘FOR THE ‘                     || ‘GIVEN ID’); WHEN invalid_increase THEN    dbms_output.Put_line(‘UNSUCCESSFUL INCREASE.  YOU CANNOT INCREASE THE ‘                     || ‘EMPLOYEE ‘                     || ‘SALARY BY ‘                     || pct_increase                     || ‘ PERCENT…PLEASE ENTER ‘                     || ‘A SMALLER INCREASE AMOUNT TO TRY AGAIN’);WHEN OTHERS THEN           error_number :&#x3D; SQLCODE;           error_message :&#x3D; Substr(sqlerrm, 1, 150);dbms_output.Put_line(‘UNSUCCESSFUL INCREASE.  AN UNKNOWN ERROR HAS OCCURRED, ‘                     || ‘PLEASE TRY AGAIN OR CONTACT ADMINISTRATOR’                     || ‘ Error #: ‘                     || error_number                     || ‘ - ‘                     || error_message);END;There are some other tools that can be used to further diagnose which errors are being raised andeven to see the entire stack trace. These tools are further explained within Recipe 9-9. By combining thetechniques learned in this recipe with those you will learn about in Recipe 9-9, you are sure to have abetter chance of diagnosing your application issues.9-5. Raising User-Defined Exceptions Without an Exception HandlerProblemYour application includes some error handling that is specific to your application. For instance, youwant to ensure that the input value for a procedure is in the valid format to be an e-mail address. Ratherthan writing an exception handler for each user-defined exception, you want to simply raise theexception inline and provide an error number as well.SolutionThis scenario is perfect for using the RAISE_APPLICATION_ERROR procedure. Test the e-mail address that ispassed into the procedure to ensure that it follows certain criteria. If it does not contain a specific  CHAPTER 9  EXCEPTIONS201characteristic of a valid e-mail address, use the RAISE_APPLICATION_ERROR procedure to display anexception message to the user. Here’s an example: \nCREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_email IN VARCHAR2) IS  emp_qry       VARCHAR2(500);  emp_first     employees.first_name%TYPE;  emp_last      employees.last_name%TYPE;  email         employees.email%TYPE; \n  valid_id_count        NUMBER :&#x3D; 0;  valid_flag            BOOLEAN :&#x3D; TRUE;  temp_emp_info         VARCHAR2(50); \n  BEGIN    emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;    IF emp_email LIKE ‘%@%’ THEN      temp_emp_info :&#x3D; substr(emp_email,0,instr(emp_email,‘@’)-1);      emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_email’;    ELSIF emp_email NOT LIKE ‘%.mycompany.com’ THEN      RAISE_APPLICATION_ERROR(-20001, ‘Not a valid email address from ‘ ||                            ‘this company!’);    ELSE      RAISE_APPLICATION_ERROR(-20002, ‘Not a valid email address!’);    END IF; \nIF valid_flag = TRUE THEN \n  EXECUTE IMMEDIATE emp_qry \n  INTO emp_first, emp_last, email \n  USING temp_emp_info; \n\n  DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); \nELSE  \n  DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || \n                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); \nEND IF; \n\nEND; \nAs you can see, there is no exception handler in this example. When the conditions are met, anexception is raised inline via RAISE_APPLICATION_EXCEPTION.How It WorksThe RAISE_APPLICATION_EXCEPTION procedure can associate an error number with an error message. Theformat for calling the RAISE_APPLICATION_EXCEPTION procedure is as follows: \nRAISE_APPLICATION_EXCEPTION(exception_number,                           exception_message[, retain_error_stack]); \nwhere exception_number is a number within the range of -20000 to -20999, and exception_message is astring of text that is equal to or less than 2KB in length. The optional retain_error_stack is a BOOLEANCHAPTER 9  EXCEPTIONS202value that tells Oracle whether this exception should be added to the existing error stack or whether theerror stack should be wiped clean and this exception should be placed into it. By default, the value isFALSE, and all other exceptions are removed from the error stack, leaving this exception as the only onein the stack.When you invoke the procedure, the current block is halted immediately, and the exception israised. No further processing takes place within the current block, and control is passed to the programthat called the block or an enclosing block if the current block is nested. Therefore, if you need toperform any exception handling, then it needs to take place prior to callingRAISE_APPLICATION_EXCEPTION. There is no commit or rollback, so any updates or changes that have beenmade will be retained if you decide to issue a commit. Any OUT and IN OUT values, assuming you are in aprocedure or a function, will be reverted. This is important to keep in mind, because it will help youdetermine whether to use an exception handler or issue a call to RAISE_APPLICATION_ERROR.When calling RAISE_APPLICATION_EXCEPTION, you pass an error number along with an associatedexception message. Oracle sets aside the range of numbers from -20000 to -20999 for use by itscustomers for the purpose of declaring exceptions. Be sure to use a number within this range, or Oraclewill raise its own exception to let you know that you are out of line and using one of its proprietary errornumbers!■ Note There are some numbers within that range that are still used by Oracle-specific exceptions. Passing aTRUE value as the last argument in a call to RAISE_APPLICATION_EXCEPTION will retain any existing errors in theerror stack. Passing TRUE is a good idea for the purposes of debugging so that the stack trace can be used to helpfind the code that is raising the exception. Otherwise, the exception stack is cleared.One may choose to create a function or procedure that has the sole purpose of callingRAISE_APPLICATION_EXCEPTION to raise an exception and associate an error number with an exceptionmessage. This technique can become quite useful if you are interested in using a custom error numberfor your exceptions, but you still need to perform proper exception handling when errors occur. Youcould use the OTHERS exception handler to call the function or procedure that usesRAISE_APPLICATION_EXCEPTION, passing the error number and a proper exception message.9-6. Redirecting Control After an Exception Is RaisedProblemAfter an exception is raised within an application, usually the statements within the exception handlerare executed, and then control goes to the next statement in the calling program or outside the currentcode block. Rather than printing an error message and exiting your code block after an exception, youwant to perform some further activity. For instance, let’s say you are interested in logging the exceptionin a database table. You have a procedure for adding entries to the log table, and you want to make useof that procedure.  CHAPTER 9  EXCEPTIONS203SolutionInvoke the procedure from within the exception handler. When the exception is raised, program controlwill be passed to the appropriate handler. The handler itself can provide an exception message for theuser, but it will also call the procedure that is to be used for logging the exception in the database. Thefollowing example demonstrates this technique: \nCREATE OR REPLACE PROCEDURE log_error_messages(error_code  IN NUMBER,                                                message    IN VARCHAR2) ASPRAGMA AUTONOMOUS_TRANSACTION;BEGIN  DBMS_OUTPUT.PUT_LINE(message);  DBMS_OUTPUT.PUT_LINE(‘WRITING ERROR MESSAGE TO DATABASE’);END; \nCREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS  emp_qry                 VARCHAR2(500);  emp_first                employees.first_name%TYPE;  emp_last                   employees.last_name%TYPE;  email                         employees.email%TYPE; \n  valid_id_count         NUMBER :&#x3D; 0;  valid_flag                  BOOLEAN :&#x3D; TRUE;  temp_emp_info       VARCHAR2(50); \n BEGIN    emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;    IF emp_info LIKE ‘%@%’ THEN      temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);      emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;    ELSE      SELECT COUNT(*)      INTO valid_id_count      FROM employees      WHERE employee_id &#x3D; emp_info; \n  IF valid_id_count &gt; 0 THEN \n      temp_emp_info := emp_info; \n      emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; \n  ELSE \n      valid_flag := FALSE; \n  END IF; \nEND IF; \n\nIF valid_flag = TRUE THEN \n  EXECUTE IMMEDIATE emp_qry \n  INTO emp_first, emp_last, email \n  USING temp_emp_info; \n\n  DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); \nELSE  \n\nCHAPTER 9  EXCEPTIONS204      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||                           ‘NOT MATCH ANY EMPLOYEE RECORD’);    END IF; \nEXCEPTION \n  WHEN NO_DATA_FOUND THEN \n     \n    DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || \n                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); \n    log_error_messages(SQLCODE, DBMS_UTILITY.FORMAT_ERROR_STACK); \n     \n  WHEN OTHERS THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;AN UNEXPECTED ERROR HAS OCCURRED, PLEASE &#39; || \n                       &#39;TRY AGAIN&#39;); \n    log_error_messages(SQLCODE, DBMS_UTILITY.FORMAT_ERROR_STACK); \n\n END; \nIn this scenario, the log_error_messages procedure would be called from within each of theexception handlers. Since it is an autonomous transaction, the log_error_messages procedure willexecute without affecting the calling procedure. This ensures that no issues will arise iflog_error_messages were to raise an exception. Control of the application would be passed to thisprocedure for the processing, and then the program would exit.How It WorksIt is possible to redirect control of your code after an exception has been raised using varioustechniques. After an exception is raised and control is redirected to the handler, the statements withinthe handler are executed, and then that program ends. If the code block that contains the exceptionhandler is contained within enclosing code block, control will be passed to the next statement within theenclosing control block. Otherwise, the program will exit after statements are executed.To execute a particular action or series of processes after an exception has been raised, it is a usefultechnique to call a stored procedure or function from within the exception handler. In the solution tothis recipe, a logging procedure is called that will insert a row into the logging table after each exceptionis raised. This allows the program control to be passed to the procedure or function that is called, andwhen that body of code has completed execution, control is passed back to the exception handler. Thisis a very useful technique for logging exceptions but can also be used for various other tasks such assending an e-mail alert or performing some database cleanup.9-7. Raising Exceptions and Continuing ProcessingProblemThe application you are coding requires a series of INSERT, UPDATE, and DELETE statements to be called.You want to add proper exception handling to your code and also ensure that processing continues andall of the statements are executed even if an exception is raised.SolutionEnclose each statement within its own code block, and provide an exception handler for each of theblocks. When an exception is raised within one of the nested blocks, then control will be passed back to  CHAPTER 9  EXCEPTIONS205the main code block, and execution will continue. This style of coding is displayed in the followingexample: \nCREATE OR REPLACE PROCEDURE delete_employee (in_emp_id   IN NUMBER) AS  BEGIN    – ENTER INITIAL NESTED CODE BLOCK TO PERFORM DELETE    BEGIN        – DELETE EMP    EXCEPTION      WHEN NO_DATA_FOUND THEN         – perform statements    END; \n -- ENTER SECOND NESTED CODE BLOCK TO PERFORM LOG ENTRY \n BEGIN \n    -- LOG DELETION OF  EMP \nEXCEPTION \n  WHEN NO_DATA_FOUND THEN \n     -- perform statements \nEND; \n\nEXCEPTION WHEN OTHERS THEN  – perform statementsEND; \nAs this code stands, no exception will go on to become an unhanded exception because theoutermost code block contains an exception handler using the OTHERS exception name. Every nestedcode block contains a handler, so every exception that is encountered in this application will be caught.How It WorksScope plays an important role when designing your application’s exception-handling system. Whendoing so, you should think of your application and determine whether portions of the code need to beexecuted regardless of any exception being raised. If this is the case, then you will need to provide properexception handling and still ensure that the essential code is executed each run.The scope of an exception pertains to the code block in which the exception is declared. Once anexception has been encountered, program control halts immediately and is passed to the exceptionhandler for the current block. If there is not an exception handler in the current code block or if nohandler matches the exception that was raised, then control passes to the calling program or outercontrol block. Control is immediately passed to the exception handler of that program. If no exceptionhandler exists or matches the exception being raised, then the execution of that block halts, and theexception is raised to the next calling program or outer code block, and so on.This pattern can be followed any number of times. That is why the technique used in the solution tothis recipe works well. There is one main code block that embodies two nested code blocks. Each of theblocks contains essential statements that need to be run. If an exception is raised within the DELETEblock, then program control is passed back to its outer code block, and processing continues. In thiscase, both essential statements will always be executed, even if exceptions are raised.CHAPTER 9  EXCEPTIONS2069-8. Associating Error Numbers with Exceptions That Have No NameProblemYou want to associate an error number to those errors that do not have predefined names.SolutionMake use of PRAGMA EXCEPTION_INIT to tell the compiler to associate an Oracle error number with anexception name. This will allow the use of an easy-to-identify name rather than an obscure errornumber when working with the exception. The example in this recipe shows how an error number canbe associated with an exception name and how the exception can later be raised. \nCREATE OR REPLACE FUNCTION calculate_salary_hours(salary  IN NUMBER,                                              hours   IN NUMBER DEFAULT 1)RETURN NUMBER ASBEGIN  RETURN salary&#x2F;hours;END; \nDECLARE  DIVISOR_IS_ZERO  EXCEPTION;  PRAGMA EXCEPTION_INIT(DIVISOR_IS_ZERO, -1476);  per_hour      NUMBER;BEGIN  SELECT calculate_salary_hours(0,0)  INTO per_hour  FROM DUAL;EXCEPTION WHEN DIVISOR_IS_ZERO THEN  DBMS_OUTPUT.PUT_LINE(‘You cannot pass a zero for the number of hours’);END; \nThe exception declared within this example is associated with the ORA-01476 error code. When adivide-by-zero exception occurs, then the handler is executed.How It WorksPRAGMA EXCEPTION_INIT allows an error number to be associated with an error name. Thus, it provides aneasy way to handle those exceptions that are available only by default via an error number. It is mucheasier to identify an exception by name rather than by number, especially when you have been awayfrom the code base for some length of time.The PRAGMA EXCEPTION_INIT must be declared within the declaration section of your code. Theexception that is to be associated with the error number must be declared prior to the PRAGMAdeclaration. The format for using PRAGMA EXCEPTION_INIT is as follows: \nDECLARE  exception_name   EXCEPTION;  PRAGMA EXCEPTION_INIT(exception_name, &lt;&gt;);BEGIN  CHAPTER 9  EXCEPTIONS207  – Perform statementsEXCEPTION  WHEN exception_name THEN    – Perform error handlingEND; \nThe exception_name in this pseudocode refers to the name of the exception you are declaring. The&lt;&gt; is the number of the ORA-xxxxx error that you are associating with the exception. Inthe solution to this recipe, ORA-01476 is associated with the exception. That exception in particulardenotes divisor is equal to zero. When this exception is raised, it is easier to identify the cause of theerror via the DIVISOR_IS_ZERO identifier than by the -01476 code.Whenever possible, it is essential to provide an easy means of identification for portions of code thatmay be difficult to understand. Exception numbers by themselves are not easily identifiable unless yousee the exception often enough. Even then, an exception handler with the number -01476 in it seemsobscure. In this case, it is always best to associate a more common name to the exception so that thecode can instantly have meaning to someone who is unfamiliar with the code or to you when you needto maintain the code for years to come.9-9. Tracing an Exception to Its OriginProblemYour application continues to raise an exception that is being caught with the OTHERS handler. You’veused SQLCODE and DBMS_UTILITY.FORMAT_ERROR_STACK to help you find the cause of the exception but arestill unable to do so.SolutionUse the stack trace for the exception to trace the error back to its origination. In particular, useDBMS_UTILITY.FORMAT_ERROR_BACKTRACE and DBMS_UTILITY.FORMAT_CALL_TRACE to help you find the causeof the exception. The following solution demonstrates the use of FORMAT_ERROR_BACKTRACE: \nCREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS  emp_qry             VARCHAR2(500);  emp_first           employees.first_name%TYPE;  emp_last            employees.last_name%TYPE;  email               employees.email%TYPE; \n  valid_id_count      NUMBER :&#x3D; 0;  valid_flag          BOOLEAN :&#x3D; TRUE;  temp_emp_info       VARCHAR2(50); \n BEGIN    emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;    IF emp_info LIKE ‘%@%’ THEN      temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);      emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;    ELSE      SELECT COUNT(*)CHAPTER 9  EXCEPTIONS208      INTO valid_id_count      FROM employees      WHERE employee_id &#x3D; emp_info; \n  IF valid_id_count &gt; 0 THEN \n      temp_emp_info := emp_info; \n      emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; \n  ELSE \n      valid_flag := FALSE; \n  END IF; \nEND IF; \n\nIF valid_flag = TRUE THEN \n  EXECUTE IMMEDIATE emp_qry \n  INTO emp_first, emp_last, email \n  USING temp_emp_info; \n\n  DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); \nELSE  \n  DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || \n                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); \nEND IF; \n\nEXCEPTION \n  WHEN NO_DATA_FOUND THEN \n     \n    DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || \n                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); \n    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE); \n     \n  WHEN OTHERS THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;AN UNEXPECTED ERROR HAS OCCURRED, PLEASE &#39; || \n                       &#39;TRY AGAIN&#39;); \n    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE); \n\n END; \nHere are the results when calling within invalid argument information: \nSQL&gt; exec obtain_emp_detail(‘junea@’);THE INFORMATION YOU HAVE USED DOES NOT MATCH ANY EMPLOYEE RECORDORA-06512: at “OBTAIN_EMP_DETAIL”, line 32 \nPL&#x2F;SQL procedure successfully completed. \nAs you can see, the exact line number that caused the exception to be raised is displayed. This isespecially useful if you use a development environment that includes line numbering for your sourcecode. If not, then you can certainly count out the line numbers manually.Similarly, DBMS_UTILITY.FORMAT_CALL_STACK lists the object number, line, and object where the issuehad occurred. The following example uses the same procedure as the previous example, but this timeDBMS_UTILITY.FORMAT_CALL_STACK is used in the exception handler: \n  CHAPTER 9  EXCEPTIONS209CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS  emp_qry                VARCHAR2(500);  emp_first              employees.first_name%TYPE;  emp_last               employees.last_name%TYPE;  email                  employees.email%TYPE; \n  valid_id_count         NUMBER :&#x3D; 0;  valid_flag             BOOLEAN :&#x3D; TRUE;  temp_emp_info          VARCHAR2(50); \n BEGIN    emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;    IF emp_info LIKE ‘%@%’ THEN      temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);      emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;    ELSE      SELECT COUNT(*)      INTO valid_id_count      FROM employees      WHERE employee_id &#x3D; emp_info; \n  IF valid_id_count &gt; 0 THEN \n      temp_emp_info := emp_info; \n      emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; \n  ELSE \n      valid_flag := FALSE; \n  END IF; \nEND IF; \n\nIF valid_flag = TRUE THEN \n  EXECUTE IMMEDIATE emp_qry \n  INTO emp_first, emp_last, email \n  USING temp_emp_info; \n\n  DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); \nELSE  \n  DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || \n                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); \nEND IF; \n\nEXCEPTION \n  WHEN NO_DATA_FOUND THEN \n     \n    DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || \n                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); \n    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_CALL_STACK); \n     \n  WHEN OTHERS THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;AN UNEXPECTED ERROR HAS OCCURRED, PLEASE &#39; || \n                       &#39;TRY AGAIN&#39;); \n    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_CALL_STACK); \n\nCHAPTER 9  EXCEPTIONS210 END;Here are the results when calling within invalid argument information:SQL&gt; exec obtain_emp_detail(‘june@’);THE INFORMATION YOU HAVE USED DOES NOT MATCH ANY EMPLOYEE RECORD—– PL&#x2F;SQL Call Stack —–  object      line  object  handle    numbername24DD3280     47  procedure OBTAIN_EMP_DETAIL273AA66C      1anonymous blockPL&#x2F;SQL procedure successfully completed.Each of the two utilities demonstrated in this solution serves an explicit purpose—to assist you infinding the cause of exceptions in your applications.How It WorksOracle provides a few different utilities to help diagnose and repair issues with code. The utilitiesdiscussed in this recipe provide feedback regarding exceptions that have been raised within applicationcode. DBMS_UTILITY.FORMAT_ERROR_BACKTRACE is used to display the list of lines that goes back to the pointat which your application fails. This utility was added in Oracle Database 10g. Its ability to identify theexact line number where the code has failed can save the time of reading through each line to look forthe errors. Using this information along with the Oracle exception that is raised should give you enoughinsight to determine the exact cause of the problem.The result from DBMS_UTILITY.FORMAT_ERROR_BACKTRACE can be assigned to a variable since it is afunction. Most likely a procedure will be used to log the exceptions so that they can be reviewed at a latertime. Such a procedure could accept the variable containing the result fromDBMS_UTILITY.FORMAT_ERROR_BACKTRACE as input.The DBMS_UTILITY.FORMAT_CALL_STACK function is used to print out a formatted string of theexecution call stack or the sequence of calls for your application. It displays the different objects used,along with line numbers from which calls were made. It can be very useful for pinpointing those errorsthat you are having trouble resolving. It can also be useful for obtaining information regarding theexecution order of your application. If you are unsure of exactly what order processes are being called,this function will give you that information.Using a combination of these utilities when debugging and developing your code is a good practice.You may find it useful to create helper functions that contain calls to these utilities so that you can easilylog all stack traces into a database table or a file for later viewing. These can be of utmost importancewhen debugging issues or evaluating application execution.  CHAPTER 9  EXCEPTIONS2119-10. Displaying PL&#x2F;SQL Compiler WarningsProblemYou are interested in making your code more robust by ensuring that no issues will crop up as time goesby and the code evolves. You want to have the PL&#x2F;SQL compiler alert you of possible issues with yourcode.SolutionUse PL&#x2F;SQL compile-time warnings to alert you of possible issues with your code. Enable warnings foryour current session by issuing the proper ALTER SESSION statements or by using the DBMS_WARNINGpackage to do so. This solution will demonstrate each of these techniques to help you decide which willwork best for your debugging purposes.First let’s take a look at using ALTER SESSION to enable and configure warnings for yourenvironment. This technique can be very useful when you want to enable warnings for an entire session.The following example shows how to enable warnings and how to display them given a short code block: \nALTER SESSION SET PLSQL_WARNINGS &#x3D; ‘ENABLE:ALL’; \nCREATE OR REPLACE FUNCTION calculate_salary_hours(salary  IN NUMBER,                                                  hours   IN NUMBER DEFAULT 1)RETURN NUMBER ASBEGIN  RETURN salary&#x2F;hours;END; \nSHOW ERRORS; \nHere are the results from running create or replace function with all warnings enabled: \nErrors for FUNCTION CALCULATE_SALARY_HOURS: \nLINE&#x2F;COL ERROR 1&#x2F;1PLW-05018: unit CALCULATE_SALARY_HOURS omitted optional AUTHID clause; default value DEFINER used \nNext, let’s look at the DBMS_WARNINGS package. Use of this technique is more helpful if you are using adevelopment environment such as PL&#x2F;SQL Developer that compiles your code for you. The following isan example of performing the same CREATE OR REPLACE FUNCTION as earlier, but this time usingDBMS_WARNINGS: \nSQL&gt; CALL DBMS_WARNING.SET_WARNING_SETTING_STRING(‘ENABLE:ALL’,’SESSION’); \nCall completed. \nCHAPTER 9  EXCEPTIONS212SQL&gt; CREATE OR REPLACE FUNCTION calculate_salary_hours(salary  IN NUMBER,                                                  hours   IN NUMBER DEFAULT 1)RETURN NUMBER ASBEGIN  RETURN salary&#x2F;hours;END;&#x2F;  2    3    4    5    6    7   \nSP2-0806: Function created with compilation warnings \nSQL&gt; SHOW ERRORS;Errors for FUNCTION CALCULATE_SALARY_HOURS: \nLINE&#x2F;COL ERROR 1&#x2F;1PLW-05018: unit CALCULATE_SALARY_HOURS omitted optional AUTHID clause; default value DEFINER used \nBoth techniques provide similar results, but one can be set at the database level and the other canbe more useful for use in a development environment.How It WorksLearning about warnings against your code can help you solidify your code and repair it so that it canbecome more robust when it is used in a production environment. Although PL&#x2F;SQL warnings will notprevent the code from compiling and executing, they can certainly provide good insight to inform you ofplaces in your code that could possibly incur issues at a later time. As you have learned from the solutionto this recipe, there are two techniques that can be used to enable warnings for your application. Thoseare the use of ALTER SESSION statements and the DBMS_WARNINGS package. Both are valid techniques forenabling and disabling warnings, but each has its own set of strong points and drawbacks.The PLSQL_WARNINGS compilation parameter must be used to enable or disable warnings within asession. By setting it, you can control the types of warnings that are displayed, along with how muchinformation is displayed and even how it is displayed. This parameter can be set using the ALTER SESSIONstatement. The format for setting this parameter using ALTER SESSION is as follows: \nALTER SESSION SET PLSQL_WARNINGS &#x3D; “[ENABLE&#x2F;DISABLE:PARAMETER]” \nThe PLSQL_WARNINGS compilation parameter accepts a number of different parameters that each tellthe compiler what types of warnings to display and what to ignore. There are three different categories ofwarnings that can be used. Table 9-3 shows the different types of warnings along with their descriptions.  CHAPTER 9  EXCEPTIONS213Table 9-3. Warning CategoriesCategory DescriptionPERFORMANCE May hinder application performanceINFORMATIONAL May complicate application maintenance but contains no immediateissuesSECURE May cause unexpected or incorrect resultsALL Includes all the categories \nThe DBMS_WARNINGS package works in a similar fashion: it accepts the same arguments as thePLSQL_WARNINGS parameter. The difference is that you can control when the warnings are enabled ordisabled by placing the call to the package in locations that you choose. This does not matter muchwhen working via SQL*Plus, but if you are using a development environment such as Oracle SQLDeveloper, then DBMS_WARNINGS must be used. The format for calling this procedure is as follows: \nCALL DBMS_WARNING.SET_WARNING_SETTING_STRING(‘warning_category:value’,’scope’); \nThe categories are the same as PLSQL_WARNINGS, as are the values of the categories. The scope determineswhether the warnings will be used for the duration of the session or for all sessions. There are variousother options that can be used with the DBMS_WARNINGS package. To learn more about these options,please see the Oracle Database 11g documentation. \nC H A P T E R  10 \n   \n215PL&#x2F;SQL Collections and RecordsCollections are single-dimensional arrays of data all with the same datatype and are accessed by anindex; usually the index is a number, but it can be a string. Collections indexed by strings are commonlyknown as hash arrays.Records are groups of related data, each with its own field name and datatype, similar to tablesstored in the database. The record data structure in PL&#x2F;SQL allows you to manipulate data at the field orrecord level. PL&#x2F;SQL provides an easy method to define a record’s structure based on a database table’sstructure or a cursor. Combining records and collections provide a powerful programming advantagedescribed in the following recipes.10-1. Creating and Accessing a VARRAYProblemYou have a small, static list of elements that you initialize once and that would benefit from using in aloop body.SolutionPlace the elements into a varray (or varying array). Once initialized, a varray may be referenced by itsindex. Begin by declaring a datatype of varray with a fixed number of elements, and then declare thedatatype of the elements. Next, declare the variable that will hold the data using the newly defined type.For example, the following code creates a varying array to hold the abbreviations for the days of theweek: \nDECLARE \nTYPE    dow_type IS VARRAY(7) OF VARCHAR2(3);dow     dow_type :&#x3D; dow_type (‘Sun’, ‘Mon’, ‘Tue’, ‘Wed’, ‘Thu’, ‘Fri’, ‘Sat’); \nBEGIN \n   FOR i IN 1..dow.COUNT LOOP      DBMS_OUTPUT.PUT_LINE (dow(i));   END LOOP; \nEND; \nResults \nCHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS216SunMonTueWedThuFriSatHow It WorksThe type statement dow_type defines a data structure to store seven instances of VARCHAR2(3). This issufficient space to hold the abbreviations of the seven days of the week. The dow variable is defined as aVARRAY of the dow_type defined in the previous line. That definition invokes a built-in constructormethod to initialize values for each of the elements in the VARRAY.The FOR .. LOOP traverses the dow variable starting at the first element and ending with the last. TheCOUNT method returns the number of elements defined in a collection; in this recipe, there are sevenelements in the VARRAY, so the LOOP increments from one to seven. The DBMS_OUTPUT.PUT_LINE statementdisplays its value.A VARRAY is best used when you know the size the array and it will not likely change. The VARRAYconstruct also allows you to initialize its values in the declaration section.10-2. Creating and Accessing an Indexed TableProblemYou need to store a group of numbers for later processing in another procedure.SolutionCreate an indexed table using an integer index to reference the elements. For example, this recipe loadsvalues into an indexed table of numbers.  \nDECLARE \nTYPE    num_type IS TABLE OF number INDEX BY BINARY_INTEGER;nums    num_type;total   number; \nBEGIN \n   nums(1) :&#x3D; 127.56;   nums(2) :&#x3D; 56.79;   nums(3) :&#x3D; 295.34; \n   – call subroutine to process numbers;   – total :&#x3D; total_table (nums);END;  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS217How It WorksPL&#x2F;SQL tables are indexed collections of data of the same type. The datatype can be any of the built-indatatypes provided by PL&#x2F;SQL; in this example, the datatype is a number. Here are some things to noteabout the example:• The TYPE statement declares a TABLE of numbers.• The INDEX BY clause defines how the array is accessed, in this case by an INTEGER.• The array is populated by assigning values to specific indexes.Because the TABLE is INDEXED BY an INTEGER, there is no predefined limit on the index value, otherthan those imposed by Oracle, which is -231 – 231. Indexed tables are best suited for collections where thenumber of elements stored is not known until runtime.This recipe is an example of a TABLE indexed by an INTEGER. PL&#x2F;SQL provides for tables indexed bystrings as well. See Recipe 10-5 for an example.10-3. Creating Simple RecordsProblemYou need a PL&#x2F;SQL data structure to group related employee data to make manipulating the groupeasier.SolutionDefine a record structure of the related employee data, and then create a variable to hold the recordstructure. In this example, a simple RECORD structure is defined and initialized. \nDECLARE \nTYPE    rec_type IS RECORD (                last_name       varchar2(25),                department      varchar2(30),                salary          number );rec     rec_type; \nbegin \n   rec.last_name        :&#x3D; ‘Juno’;   rec.department       :&#x3D; ‘IT’;   rec.salary           :&#x3D; ‘5000’; \nEND;How It WorksRecord structures are created in PL&#x2F;SQL by using the TYPE statement along with a RECORD structureformat. The fields defined in the record structure can be, and often are, of different datatypes. Recordstructures use dot notation to access individual fields. Once defined, the rec_type record structure in thesolution can be used throughout the code to create as many instantiations of data structures as needed.CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS21810-4. Creating and Accessing Record CollectionsProblemYou need to load records from a database table or view into a simple data structure that would benefitfrom use in a loop body or to pass as a parameter to another function or procedure. You want to actupon sets of records as a single unit.SolutionUse a TYPE to define a TABLE based on the database table structure. The following example declares acursor and then uses it to declare the table of records. The result is a variable named recs that holds thedata fetched by the cursor. \nDECLARE \nCURSOR  driver ISSELECT  *FROM    employees; \nTYPE    emp_type IS TABLE OF driver%ROWTYPE INDEX BY BINARY_INTEGER;recs    emp_type;total   number :&#x3D; 0.0; \nBEGIN \n   OPEN DRIVER;   FETCH DRIVER BULK COLLECT INTO recs;   CLOSE DRIVER; \n   DBMS_OUTPUT.PUT_LINE (recs.COUNT || ‘ records found’); \n   FOR i in 1..recs.COUNT LOOP      total :&#x3D; total + recs(i).salary;   END LOOP; \nEND; \nWhen you execute this block of code, you will see a message such as the following: \n103 records foundHow It WorksThe TYPE statement defines a data structure using the attributes (columns) of the employees table aselements within the structure. The TABLE OF clause defines multiple instances of the record structure.The INDEX BY clause defines the index method, in this case an integer. Think of this structure as aspreadsheet with the rows being separate records from the database and the columns being theattributes (fields) in the database. The recipe works whether your cursor selects all the fields (SELECT *)or selects just a subset of fields from the table.  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS219The BULK COLLECT portion of the fetch statement is more efficient than looping through the data in astandard cursor loop because PL&#x2F;SQL switches control to the database just once to retrieve the data asopposed to switching to the database for each record retrieved in a cursor FOR .. LOOP. In a BULKCOLLECT, all records meeting the query condition are retrieved and stored in the data structure in a singleoperation. Once the records are retrieved, processing may occur in a standard FOR .. standard FOR ..LOOP.10-5. Creating and Accessing Hash Array CollectionsProblemYou want to use a single cursor to query employee data and sum the salaries across departments.SolutionYou can use two cursors—one to select all employees and the other to sum the salary grouping bydepartment. However, you can more easily and efficiently accomplish your task by using one cursor anda hashed collection. Define your cursor to select employee data, joined with the department table. Use ahash array collection to total by department by using the INDEX BY option to index your collection basedon the department name rather than an integer. The following code example illustrates this moreefficient approach: \nDECLARE \nCURSOR  driver ISSELECT  ee.employee_id, ee.first_name, ee.last_name, ee.salary, d.department_nameFROM    departments     d,        employees       eeWHERE   d.department_id &#x3D; ee.department_id; \nTYPE    total_type IS TABLE OF number INDEX BY departments.department_name%TYPE;totals  total_type; \ndept    departments.department_name%TYPE; \nBEGIN \n   FOR rec IN driver LOOP      – process paycheck      if NOT totals.EXISTS(rec.department_name) then  – create element in the array         totals(rec.department_name) :&#x3D; 0; – initialize to zero      end if; \n  totals(rec.department_name) := totals(rec.department_name) + nvl (rec.salary, 0); \n\n   END LOOP; \n   dept :&#x3D; totals.FIRST;   LOOP      EXIT WHEN dept IS NULL;      DBMS_OUTPUT.PUT_LINE (to_char (totals(dept),  ‘999,999.00’) || ‘ ‘ || dept);CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS220      dept :&#x3D; totals.NEXT(dept);   END LOOP;END;When you execute this block of code, you will see the following results:20,310.00 Accounting58,720.00 Executive51,600.00 Finance6,500.00 Human Resources19,000.00 Marketing2,345.34 Payroll10,000.00 Public Relations304,500.00 Sales156,400.00 Shipping35,295.00 Web DevelopmentsHow It WorksThe TOTAL_TYPES PL&#x2F;SQL type is defined as a collection of numbers that is indexed by the departmentname. Indexing by department name gives the advantage of automatically sorting the results bydepartment name.As new elements are created, using the EXISTS method, the index keys are automatically sorted byPL&#x2F;SQL. The totals are accumulated by department name as opposed to a numerical index, such asdepartment ID, which may not be sequential. This approach has the added advantage of not requiring aseparate collection for the department names.Once the employee paychecks are processed, the dept variable is initialized with the firstdepartment name from the totals array using the FIRST method. In this example, the first department isaccounting. A loop is required to process the remaining records. The NEXT method is used to find thenext department name—in alphabetical order—and this process repeats until all departments aredisplayed.10-6. Creating and Accessing Complex CollectionsProblemYou need a routine to load managers and their corresponding employees from the database and storethem in one data structure. The data must be loaded in a manner such that direct reports are associatedwith their manager. In addition, the number of direct reports for any given manager varies, so yourstructure to hold the manager&#x2F;employee relationships must handle any number of subordinates.SolutionCombine records and collections to define one data structure capable of storing all the data. PL&#x2F;SQLallows you to use data structures you create via the type statement as datatypes within other collections.Once your data structures are defined, use dot notation to distinguish attributes within the collections.Use the structure’s index to reference items within the table. For example:  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS221SET SERVEROUT ON SIZE 1000000 \nDECLARE \nTYPE    person_type IS RECORD (                employee_id     employees.employee_id%TYPE,                first_name      employees.first_name%TYPE,                last_name       employees.last_name%TYPE); \n  – a collection of peopleTYPE    direct_reports_type IS TABLE OF person_type INDEX BY BINARY_INTEGER;  \n  – the main record definition, which contains a collection of recordsTYPE    rec_type IS RECORD (                mgr             person_type,                emps            direct_reports_type); \nTYPE    recs_type IS TABLE OF rec_type INDEX BY BINARY_INTEGER;recs    recs_type; \nCURSOR  mgr_cursor IS  – finds all managersSELECT  employee_id, first_name, last_nameFROM    employeesWHERE   employee_id IN        (       SELECT  distinct manager_id                FROM    employees)ORDER BY last_name, first_name; \nCURSOR  emp_cursor (mgr_id integer) IS  – finds all direct reports for a managerSELECT  employee_id, first_name, last_nameFROM    employeesWHERE   manager_id &#x3D; mgr_idORDER BY last_name, first_name; \n  – temporary collection of records to hold the managers.TYPE            mgr_recs_type IS TABLE OF emp_cursor%ROWTYPE                                INDEX BY BINARY_INTEGER;mgr_recs        mgr_recs_type; \nBEGIN \n   OPEN mgr_cursor;   FETCH mgr_cursor BULK COLLECT INTO mgr_recs;   CLOSE mgr_cursor; \n   FOR i IN 1..mgr_recs.COUNT LOOP      recs(i).mgr :&#x3D; mgr_recs(i);  – move the manager record into the final structure \n    -- moves direct reports directly into the final structure \n  OPEN emp_cursor (recs(i).mgr.employee_id); \n  FETCH emp_cursor BULK COLLECT INTO recs(i).emps; \n  CLOSE emp_cursor; \n\nCHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS222   END LOOP; \n    -- traverse the data structure to display the manager and direct reports \n    -- note the use of dot notation within the data structure \n\n   FOR i IN 1..recs.COUNT LOOP      DBMS_OUTPUT.PUT_LINE (‘Manager: ‘ || recs(i).mgr.last_name);      FOR j IN 1..recs(i).emps.count LOOP         DBMS_OUTPUT.PUT_LINE (‘***   Employee: ‘ || recs(i).emps(j).last_name);      END LOOP;   END LOOP; \nEND;  \nExecuting this code block produces the following results: \nManager: Cambrault***   Employee: Bates***   Employee: Bloom***   Employee: Fox***   Employee: Kumar***   Employee: Ozer***   Employee: Smith…  &lt;&gt;Manager: Zlotkey***   Employee: Abel***   Employee: Grant***   Employee: Hutton***   Employee: Johnson***   Employee: Livingston***   Employee: TaylorHow It WorksCombining records with collections is one of the most powerful techniques for defining data structuresin PL&#x2F;SQL. It allows you to logically group common data, process large amounts of data efficiently, andseamlessly pass data between procedures and functions.The data structure contains a collection of managers; each manager contains a collection of directreports. Managers and direct reports are both person_type. Once your complex structure is defined, youcan use the BULK COLLECT feature to quickly fetch data from the database and load it into the structure.The BULK COLLECT of the MGR_CURSOR selects all persons who are managers at once and then loadsthem into the temporary structure MGR_RECS. Now that you have retrieved the records, it is easy to movethem into your final data structure. Looping through the manager records allows you to move the entiredata record for each manager via the RECS(I).MGR :&#x3D; MGR_RECS(I); statement. This statement movesevery element (field) from the MGR_RECS into the RECS structure.The EMP_CURSOR uses the managers’ ID to fetch the managers’ direct reports. The cursor is opened bypassing the managers’ ID, and then another BULK COLLECT is used to directly store the fetched data intothe data structure; no temporary data structure is needed because the structure of the fetched dataexactly matches the target data structure.Now that the data is stored in the data structure, it can be passed to another routine for processing.Grouping large sets of related data is an efficient method for exchanging data between routines. This  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS223helps separate data retrieval routines from business processing routines. It’s a very powerful feature inPL&#x2F;SQL, as you’ll see in the next recipe.10-7. Passing a Collection As a ParameterProblemYou want to pass a collection as a parameter to a procedure or function. For example, you have a datastructure that contains employee data, and you need to pass the data to a routine that prints employeepaychecks.SolutionCreate a collection of employee records to hold all employee data, and then pass the data to thesubroutine to process the paychecks. The TYPE statement defining the data structure must be visible tothe called procedure; therefore, it must be defined globally, prior to defining any procedure or functionthat uses it.In this example, employee data is fetched from the database into a collection and then passed to asubroutine for processing. \nset serverout on size 1000000 \nDECLARE \nCURSOR  driver ISSELECT  employee_id, first_name, last_name, salaryFROM    employeesORDER BY last_name, first_name; \nTYPE    emps_type IS TABLE OF driver%ROWTYPE;recs    emps_type; \n   PROCEDURE print_paycheck (emp_recs emps_type) IS \n   BEGIN \n  FOR i IN 1..emp_recs.COUNT LOOP \n     DBMS_OUTPUT.PUT (&#39;Pay to the order of: &#39;); \n     DBMS_OUTPUT.PUT (emp_recs(i).first_name || &#39; &#39; || emp_recs(i).last_name); \n     DBMS_OUTPUT.PUT_LINE (&#39; $&#39; || to_char (emp_recs(i).salary, &#39;FM999,990.00&#39;)); \n  END LOOP; \n\n   END;  \nBEGIN \n   OPEN driver;   FETCH driver BULK COLLECT INTO recs;   CLOSE driver; \nCHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS224   print_paycheck (recs); \nEND;  \nResults \nPay to the order of: Ellen Abel $11,000.00Pay to the order of: Sundar Ande $6,400.00Pay to the order of: Mozhe Atkinson $2,800.00… &lt;&gt;Pay to the order of: Alana Walsh $3,100.00Pay to the order of: Matthew Weiss $8,000.00Pay to the order of: Eleni Zlotkey $10,500.00How It WorksTYPE globally defines the data structure as a collection of records for use by the PL&#x2F;SQL block and theenclosed procedure. This declaration of both the type and the procedure at the same level—inside thesame code block—is necessary to allow the data to be passed to the function. The type and theprocedure are within the same scope, and thus the procedure can reference the type and accept valuesof the type.Defining the recs structure as a collection makes it much easier to pass large amounts of databetween routines with a single parameter. The data structure emps_type is defined as a collection ofemployee records that can be passed to any function or procedure that requires employee data forprocessing. This recipe is especially useful in that the logic of who receives a paycheck can be removedfrom the routine that does the printing or the routine that archives the payroll data, for example.10-8. Returning a Collection As a ParameterProblemRetrieving a collection of data is a common need. For example, you need a function that returns allemployee data and is easily called from any procedure.SolutionWrite a function that returns a complete collection of employee data. In this example, a package is usedto globally define a collection of employee records and return all employee data as a collection. \nCREATE OR REPLACE PACKAGE empData AS \ntype    emps_type is table of employees%ROWTYPE INDEX BY BINARY_INTEGER; \nFUNCTION get_emp_data RETURN emps_type; \nEND empData; \nCREATE OR REPLACE PACKAGE BODY empData as \nFUNCTION get_emp_data RETURN emps_type is  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS225 \ncursor  driver isselect  *from    employeesorder by last_name, first_name; \nrecs    emps_type; \nbegin \n   open driver;   FETCH driver BULK COLLECT INTO recs;   close driver; \n   return recs; \nend get_emp_data; \nend empData; \ndeclare \nemp_recs empData.emps_type; \nbegin \n   emp_recs :&#x3D; empData.get_emp_data;   dbms_output.put_line (‘Employee Records: ‘ || emp_recs.COUNT); \nEND;  \nExecuting this block of code produces the following results. \nEmployee Records: 103How It WorksBy defining a PACKAGE, the data structure emps_type is available for use by any package, procedure, orfunction that has access rights to it.1 The function get_emp_data within the common package contains allthe code necessary to fetch and return the employee data. This common routine can be used by multipleapplications that require the employee data for processing. This is a much more efficient method thancoding the same select statement in multiple applications.It is not uncommon to include business rules in this type of function; for example, the routine mayfetch only active employees. If the definition of an active employee changes, you need to update onlyone routine to fix all the applications that use it. \n1 To grant access rights, enter the following command: grant execute on empData to SCHEMA, where SCHEMA isthe user name that requires access. To grant access to every user in the database, use grant execute on empDatato PUBLIC;.CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS22610-9. Counting the Members in a CollectionProblemYou have a collection, and you need to determine the total number of elements in the collection.SolutionInvoke the built-in COUNT method on the collection. For example, the following code creates twocollections: a varying array and an INDEX BY array. The code then invokes the COUNT method on bothcollections, doing so before and after adding some records to each. \nDECLARE \nTYPE    vtype   IS VARRAY(3) OF DATE;TYPE    ctype   IS TABLE OF DATE INDEX BY BINARY_INTEGER; \nvdates  vtype :&#x3D; vtype (sysdate);cdates  ctype; \nBEGIN \n   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);   DBMS_OUTPUT.PUT_LINE (‘cdates size is: ‘ || cdates.COUNT); \n   FOR i IN 1..3 LOOP      cdates(i) :&#x3D; SYSDATE + 1;   END LOOP; \n   DBMS_OUTPUT.PUT_LINE (‘cdates size is: ‘ || cdates.COUNT); \nEND;  \nExecuting this block of code produces the following results: \nvdates size is: 1cdates size is: 0cdates size is: 3How It WorksThe variable vdates is initialized with one value, so its size is reported as 1 even though it is defined tohold a maximum of three values. The variable cdates is not initialized, so it is first reported with a size of \n\nThe loop creates and sets three collection values, which increases its count to 3.Assigning a value directly to cdates(i) is allowed because cdates is an INDEX BY collection.Assigning a value to vdates in the loop would cause an error because the array has only one definedvalue. See the EXTEND method later in this chapter for more information on assigning values to non-INDEXBY collections.  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS227The COUNT method is especially useful when used on a collection populated with a fetch from BULKCOLLECT statement to determine the number of records fetched or to process records in a FOR .. LOOP.10-10. Deleting a Record from a CollectionProblemYou need to randomly select employees from a collection. Using a random generator may select thesame employee more than once, so you need to remove the record from the collection before selectingthe next employee.SolutionInvoke the built-in DELETE method on the collection. For example, the following code creates a collectionof employees and then randomly selects one from the collection. The selected employee is removedfrom the collection using the DELETE method. This process is repeated until three employees have beenselected.\n\nDECLARE \nCURSOR  driver ISSELECT  last_nameFROM    employees; \nTYPE    rec_type IS TABLE OF driver%ROWTYPE INDEX BY BINARY_INTEGER;recs    rec_type;j       INTEGER; \nBEGIN \n   OPEN driver;   FETCH driver BULK COLLECT INTO recs;   CLOSE driver; \n   DBMS_RANDOM.INITIALIZE(TO_NUMBER (TO_CHAR (SYSDATE, ‘SSSSS’) ) ); \n   FOR i IN 1..3 LOOP–      Randomly select an employee      j :&#x3D; MOD (ABS (DBMS_RANDOM.RANDom), recs.COUNT) + 1;      DBMS_OUTPUT.PUT_LINE (recs(j).last_name); \n–      Move all employees up one postion in the collection      FOR k IN j+1..recs.COUNT LOOP         recs(k-1) :&#x3D; recs(k);      END LOOP; \n–      Remove the last element in the collection–      so the random number generator has the correct count.      recs.DELETE(recs.COUNT);   END LOOP;CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS228 \n   DBMS_RANDOM.TERMINATE; \nEND; \nExecuting this block of code produces the following results: \nOlsonChungSeoHow It WorksThe collection recs is populated with employee names via a BULK COLLECT. The FOR .. LOOP selects threeemployees at random by generating a random number between 1 and the number of records in thecollection. Once an employee is selected, their name is removed from the collection, and the DELETEmethod is used to reduce the number of elements, which changes the value returned by the COUNTmethod for the next randomly generated number.  Note: The DELETE method applies only to collections that are indexed. You can invoke DELETE only if thecollection’s underlying TYPE definition contains the INDEX BY clause.10-11. Checking Whether an Element ExistsProblemYou are processing elements in a collection but cannot be certain that each element exists. Referencingan element in a collection that does not exist will throw an exception. You want to avoid exceptions bytesting for existence before you access an element.SolutionUse the EXISTS method to test whether a collection has a value for a particular index value. In thefollowing solution, a table collection is created, and then the second element is deleted. It is importantto note that a deleted element or an element that was never initialized is not equivalent to an elementwith a null value. \nDECLARE \nTYPE ctype IS TABLE OF DATE INDEX BY BINARY_INTEGER; \ncdates ctype; \nBEGIN \n   FOR i IN 1..3 LOOP  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS229     cdates(i) :&#x3D; sysdate + i;   END LOOP; \n   cdates.DELETE(2); \n   FOR i IN 1..3 LOOP      IF cdates.EXISTS(i) then         DBMS_OUTPUT.PUT_LINE (‘cdates(‘ || i || ‘)&#x3D; ‘ || cdates(i) );      END IF;   END LOOP; \nEND;  \nExecuting this block of code produces the following results: \ncdates(1)&#x3D; 07-AUG-10cdates(3)&#x3D; 09-AUG-10How It WorksThe first loop creates and initializes the elements in the collection; the DELETE method removes thesecond element. Now we’re ready to loop through the data. The second loop tests for the existence of theelement index before attempting to use the variable. Attempting to access a value to an element in thecollection that does not exist throws an exception.If the first loop initialized the collection elements to NULL, the remaining would execute in exactlythe same manner. The only difference would be in the output from running the block of code. In thiscase, no dates would print. Referencing an element in a collection with a null value does not throw anexception because the indexed element exists, whereas referencing an element that does not exist doesthrow an exception. Here is the output in this example. Note neither solution prints an element forsubscript 2. \ncdates(1)&#x3D;cdates(3)&#x3D;10-12. Increasing the Size of a CollectionProblemYou have a VARRAY with a defined maximum size, but not all elements are initialized, and you need toadd more elements to the collection.SolutionUse the EXTEND method to create new elements within the predefined boundaries. The followingexample adds five elements using a loop: \nDECLARE \nTYPE    vtype   IS VARRAY(5) OF DATE;vdates  vtype :&#x3D; vtype (sysdate, sysdate+1, sysdate+2); – initialize 3 of the 5 elementsCHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS230BEGIN   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);   FOR i IN 1..5 LOOP      if NOT vdates.EXISTS(i) then         vdates.EXTEND;         vdates(i) :&#x3D; SYSDATE + i;      END IF;   END LOOP;   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);END;Executing this block of code produces the following results:vdates size is: 3vdates size is: 5How It WorksThe TYPE declaration defines a maximum of five elements in the collection, which is initialized with threevalues. The loop tests for the existence of the elements by index number. The EXTEND method allocatesstorage space for the new elements. Without the EXTEND statement preceding the assignment, Oracle willraise an error “ORA-06533: Subscript beyond count.” This occurs when the loop attempts to assign avalue to the fourth element in the collection.The EXTEND method applies to TABLE and VARRAY collections that are not indexed. In other words, theEXTEND method applies when the TABLE or VARRAY type definition does not contain the INDEX BYclause. To assign a value to a collection that is indexed, simply reference the collection using the indexvalue.10-13. Navigating CollectionsProblemYou need a routine to display sales totaled by region, which is stored in a collection of numbers, but thecollection is indexed by a character string. Using a LOOP from 1 to the maximum size will not work.SolutionUse the FIRST and LAST method to traverse the collection allowing PL&#x2F;SQL to supply the proper indexvalues. In this example, sales amounts are stored in a TABLE indexed by a string.DECLARETYPE    ntype   IS TABLE OF NUMBER INDEX BY VARCHAR2(5);nlist   ntype;idx     VARCHAR2(5);  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS231total   integer :&#x3D; 0; \nBEGIN \n   nlist(‘North’) :&#x3D; 100;   nlist(‘South’) :&#x3D; 125;   nlist(‘East’)  :&#x3D; 75;   nlist(‘West’)  :&#x3D; 75; \n   idx :&#x3D; nlist.FIRST;   LOOP      EXIT WHEN idx is null;      DBMS_OUTPUT.PUT_LINE (idx || ‘ &#x3D; ‘ || nlist(idx) );      total :&#x3D; total + nlist(idx);      idx   :&#x3D; nlist.NEXT(idx);   END LOOP; \n   DBMS_OUTPUT.PUT_LINE (‘Total: ‘ || total); \nEND;  \nExecuting this block of code produces the following results: \nEast &#x3D; 75North &#x3D; 100South &#x3D; 125West &#x3D; 75Total: 375How It WorksThe FIRST method returns the lowest index value in the collection. In this case, the value is East, becausethe collection is sorted alphabetically. The loop is entered with idx initialized to the first value in thecollection. The NEXT method returns the next index value alphabetically in the collection. The loopcontinues executing until the NEXT method returns a null value, which occurs after the last index value inthe collect is retrieved.To traverse the collection in reverse alphabetical order, simply initialize the idx value to nlist.LAST.Then replace the nlist.NEXT with nlist.PRIOR.  Note The FIRST, NEXT, PRIOR, and LAST methods are most useful with associative arrays but also work withcollections indexed by an integer.CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS23210-14. Trimming a CollectionProblemYou need to remove one or more items from the end of a non-INDEX BY collection. The DELETE methodwill not work because it applies only to INDEX BY collections.SolutionUse the TRIM method to remove one or more elements from the end of the collection. In this example, aVARRY is initialized with five elements. The TRIM method is used to remove elements from the end of thecollection. \nDECLARE \nTYPE    vtype   IS VARRAY(5) OF DATE;vdates  vtype :&#x3D; vtype (sysdate, sysdate+1, sysdate+2, sysdate+3, sysdate+4); \nBEGIN \n   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);   vdates.TRIM;   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);   vdates.TRIM(2);   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT); \nEND;  \nExecuting this block of code produces the following results: \nvdates size is: 5vdates size is: 4vdates size is: 2How It WorksThe TRIM method deletes elements from the end of the collection including elements not initialized. Itaccepts an optional parameter for the number of elements to delete; otherwise, it defaults to the lastelement. The TRIM method applies to TABLE and VARRAY collections that are not indexed. If the underlyingTYPE definition does not contain the INDEX BY clause, then you can invoke TRIM.The TRIM method is limited to removing elements from the end of a collection, whereas the DELETEmethod can remove elements anywhere in a collection. If you DELETE an element in the middle of acollection, then executing a FOR .. LOOP from one to the collection’s COUNT will not work properly. First,if you attempt to access the element that was deleted without checking whether it EXISTS, an exception isthrown. Second, the COUNT method will return a value that is less than the collection’s maximum indexvalue, which means the FOR .. LOOP will not process all elements in the collection.C H A P T E R  11 \n   \n233Automating Routine TasksOracle provides methods to schedule one-time and recurring jobs within the database, which isbeneficial when you want to automate repetitive tasks and run them at times when a DBA may not beavailable. This chapter provides recipes to help you get started scheduling jobs (especially PL&#x2F;SQL jobs),capturing output, sending e-mail notifications, and keeping data in sync with other databases.11-1. Scheduling Recurring JobsProblemYou want to schedule a PL&#x2F;SQL procedure to run at a fixed time or at fixed intervals.SolutionUse the EXEC DBMS_SCHEDULER.CREATE_JOB procedure to create and schedule one-time jobs and jobs thatrun on a recurring schedule. Suppose, for example, that you need to run a stored procedure namedcalc_commissions every night at 2:30 a.m. to calculate commissions based on the employees’ salaries.Normally, commissions would be based on sales, but the default HR schema doesn’t provide that table,so we’ll use an alternate calculation for demonstration purposes: \nEXEC DBMS_SCHEDULER.CREATE_JOB (               -           JOB_NAME&#x3D;&gt;’nighly_commissions’,     -           JOB_TYPE&#x3D;&gt;’STORED_PROCEDURE’,       -         JOB_ACTION&#x3D;&gt;’calc_commisions’,        -            ENABLED&#x3D;&gt;TRUE,                     -    REPEAT_INTERVAL&#x3D;&gt;’FREQ&#x3D;DAILY;INTERVAL&#x3D;1;BYHOUR&#x3D;02;BYMINUTE&#x3D;30’);How It WorksThe DBMS_SCHEDULER.CREATE_JOB procedure sets up a nightly batch job. JOB_NAME must be unique. TheJOB_TYPE, in this example, is STORED_PROCEDURE. This informs the scheduler the job is a PL&#x2F;SQL procedurestored in the database. In addition to scheduling a stored procedure, the scheduler can also execute aPL&#x2F;SQL_BLOCK, an external EXECUTABLE program, or a job CHAIN. See Recipe 11-6 for an example onscheduling job chains.The JOB_ACTION identifies the stored procedure to run. If the procedure is owned by anotherschema, then include the schema name, for example, HR.calc_commission. If the procedure is part of alarger package, include that as well, for example, HR.my_package.calc_commission.ENABLED is set to TRUE to tell the scheduler to run at the next scheduled time. By default, the ENABLEDparameter is FALSE and would require a call to the DBMS_SCHEDULER.ENABLE procedure to enable the job.CHAPTER 11  AUTOMATING ROUTINE TASKS234The REPEAT_INTERVAL is an important part of the CREATE_JOB routine. It identifies the frequency, inthis case DAILY. The INTERVAL tells scheduler to run the job every day, as opposed to 2 or 3, which wouldrun every other day, or every third day. The BYHOUR and BYMINUTE sections specifies the exact time of theday to run. In this example, the job will run at 2:30 a.m.The scheduled job, nightly_commissions, runs the stored procedure calc_commission, which readsthe data, calculates the commission, and stores the commission records. Running this job nightly keepsthe employees’ commission data current with respect to daily sales figures.11-2. E-mailing Output from a Scheduled JobProblemYou have a scheduled job that runs a stored procedure at a regular interval. The procedure producesoutput that ordinarily would be sent to the screen via the DBMS_OUTPUT.PUT_LINE procedure, but since itruns as a nightly batch job, you want to send the output to a distribution list as an e-mail message.SolutionSave the output in a CLOB variable and then send it to the target distribution list using theUTL_MAIL.SEND procedure. For example, suppose you want to audit the employee table periodically tofind all employees who have not been assigned to a department within the company. Here’s a procedureto do that: \nCREATE OR REPLACE PROCEDURE employee_audit AS \nCURSOR    driver IS    – find all employees not in a departmentSELECT    employee_id, first_name, last_nameFROM      employeesWHERE     department_id is nullORDER BY  last_name, first_name; \nbuffer        CLOB :&#x3D; null; – the e-mail message \nBEGIN \n   FOR rec IN driver LOOP    – generate the e-mail message      buffer :&#x3D; buffer  ||        rec.employee_id || ‘ ‘  ||        rec.last_name   || ‘, ‘ ||        rec.first_name  || chr(10);   END LOOP; \n–    Send the e-mail   IF buffer is not null THEN – there are employees without a department      buffer :&#x3D; ‘Employees with no Department’ || CHR(10) || CHR(10) || buffer; \n  UTL_MAIL.SEND ( \n          SENDER=&gt;&#39;someone@mycompany.com&#39;, \n      RECIPIENTS=&gt;&#39;audit_list@mycompany.com&#39;, \n         SUBJECT=&gt;&#39;Employee Audit Results&#39;, \n\n  CHAPTER 11  AUTOMATING ROUTINE TASKS235             MESSAGE&#x3D;&gt;buffer);   END IF; \nEND;How It WorksThe procedure is very straightforward in that it finds all employees with no department. When run as ascheduled job, calls to DBMS_OUTPUT.PUT_LINE won’t work because there is no “screen” to view the output.Instead, the output is collected in a CLOB variable to later use in the UTL_MAIL.SEND procedure. The key toremember in this recipe is there is no screen output from a stored procedure while running as ascheduled job. You must store the intended output and either write it to an operating system file or, as inthis example, send it to users in an e-mail.11-3. Using E-mail for Job Status NotificationProblemYou have a scheduled job that is running on a regular basis, and you need to know whether the job failsfor any reason.SolutionUse the ADD_JOB_EMAIL_NOTIFICATION procedure to set up an e-mail notification that sends an e-mailwhen the job fails to run successfully. Note, this solution builds on Recipe 11-1 where a nightly batch jobwas set up to calculate commissions. \nEXEC DBMS_SCHEDULER.ADD_JOB_EMAIL_NOTIFICATION (    -      JOB_NAME&#x3D;&gt;’nightly_commissions’, -    RECIPIENTS&#x3D;&gt; ‘&#x6d;&#x65;&#64;&#109;&#121;&#95;&#99;&#111;&#109;&#112;&#97;&#110;&#121;&#46;&#x63;&#x6f;&#109;,&#x64;&#105;&#x73;&#116;&#x5f;&#108;&#105;&#115;&#x74;&#x40;&#109;&#x79;&#x5f;&#99;&#x6f;&#x6d;&#112;&#97;&#x6e;&#121;&#x2e;&#99;&#x6f;&#109;‘);How It WorksThe previous recipe is the simplest example of automating e-mail in the event a job fails. TheADD_JOB_EMAIL_NOTIFICATION procedure accepts several parameters; however, the only requiredparameters are JOB_NAME and RECIPIENTS. The JOB_NAME must already exist from a previous call to theCREATE_JOB procedure (see Recipe 11-1 for an example). The RECIPIENTS is a comma-separated list of e-mail addresses to receive e-mail when an event occurs; by default the events that trigger an e-mail areJOB_FAILED, JOB_BROKEN, JOB_SCH_LIM_REACHED, JOB_CHAIN_STALLED, and JOB_OVER_MAX_DUR. Additionalevent parameters are JOB_ALL_EVENTS, JOB_COMPLETED, JOB_DISABLED, JOB_RUN_COMPLETED, JOB_STARTED,JOB_STOPPED, AND JOB_SUCCEEDED.The full format of the ADD_JOB_EMAIL_NOTIFICATION procedure accepts additional parameters, butthe default for each is sufficient to keep tabs on the running jobs. The body of the e-mail will return theerror messages required to debug the issue that caused the job to fail.To demonstrate the notification process, the commissions table was dropped after the job was setup to run. The database produced an e-mail with the following subject and body: \nSUBJECT: Oracle Scheduler Job Notification - HR.NIGHTLY_COMMISSIONS JOB_FAILEDBODY:Job: JYTHON.NIGHTLY_COMMISSIONSCHAPTER 11  AUTOMATING ROUTINE TASKS236Event: JOB_FAILEDDate: 28-AUG-10 03.15.30.102000 PM US&#x2F;CENTRALLog id: 1118Job class: DEFAULT_JOB_CLASSRun count: 1Failure count: 1Retry count: 0Error code: 6575Error message: ORA-06575: Package or function CALC_COMMISSIONS is in an invalid state11-4. Refreshing a Materialized View on a Timed IntervalProblemYou have a materialized view that must be refreshed on a scheduled basis to reflect changes made to theunderlying table.SolutionFirst, create the materialized view with a CREATE MATERIALIZED VIEW statement. In this example, amaterialized view is created consisting of the department and its total salary.: \nCREATE MATERIALIZED VIEW dept_salariesBUILD IMMEDIATEASSELECT department_id, SUM(salary) total_salaryFROM employeesGROUP BY department_id; \nDisplay the contents of the materialized view: \nSELECT *FROM dept_salariesORDER BY department_id; \nDEPARTMENT_ID TOTAL_SALARY \n\n       10         6500 \n       20        20200 \n       30        43500 \n       40         6500 \n       50       297100 \n       60        35000 \n       70        10000 \n       80       305600 \n       90        58000 \n      100        51600 \n      110        20300 \n                  7000 \n\n  CHAPTER 11  AUTOMATING ROUTINE TASKS237Use the EXEC DBMS_REFRESH.MAKE procedure to set up a refresh of the materialized view: \nEXEC DBMS_REFRESH.MAKE (‘HR_MVs’, ‘dept_salaries’, SYSDATE, ‘TRUNC(SYSDATE)+1’); \nChange the underlying data of the view.: \nUPDATE employeesSET salary &#x3D; salary * 1.03; \nCOMMIT; \nNote that the materialized view has not changed: \nSELECT *FROM dept_salariesORDER BY department_id; \nDEPARTMENT_ID TOTAL_SALARY \n\n       10         6500 \n       20        20200 \n       30        43500 \n       40         6500 \n       50       297100 \n       60        35000 \n       70        10000 \n       80       305600 \n       90        58000 \n      100        51600 \n      110        20300 \n                  7000 \n\nNext, manually refresh the materialized view: \nEXEC DBMS_REFRESH.REFRESH (‘HR_MVs’); \nThe materialized view now reflects the updated salaries: \nSELECT *FROM dept_salariesORDER BY department_id; \nDEPARTMENT_ID TOTAL_SALARY \n\n       10         6695 \n       20        20806 \n       30        44805 \n       40         6695 \n       50       306013 \n       60        36050 \n       70        10300 \n       80       314768 \n\nCHAPTER 11  AUTOMATING ROUTINE TASKS238           90        59740          100        53148          110        20909                      7210How It WorksThe DBMS_REFRESH.MAKE procedure creates a list of materialized views that refresh at a specified time.Although you could schedule a job that calls the DBMS_REFRESH.REFRESH procedure to refresh the view, theMAKE procedure simplifies this automated task. In addition, once your refresh list is created, you can lateradd more materialized views to the schedule using the DBMS_REFRESH.ADD procedure. The first argument of the DBMS_REFRESH.MAKE procedure specifies the name of this list; in thisexample, the list name is HR_MVs. This name must be unique among lists. The next parameter is a list ofall materialized views to refresh. The procedure accepts either a comma-separated string of materializedview names or an INDEX BY table, each containing a view name. If the list contains a view not owned bythe schema creating the list, then the view name must be qualified with the owner, for example,HR.dept_salaries. The third parameter specifies the first time the refresh will run. In this example,sysdate is used, so the refresh is immediate. The fourth parameter is the interval, which must be afunction that returns a date&#x2F;time for the next run time. This recipe uses ‘TRUNC(SYSDATE)+1’, whichcauses the refresh to run at midnight every night.In this example, the CREATE MATERIALIZED VIEW statement creates a simple materialized view of thetotal salary by departments, and the data is selected from the view to verify that it is populated withcorrect data. Note After adding a 3 percent raise to each employee’s salary, we continue to see a materialized view thatreflects the old data. The DBMS_REFRESH routine solves that problem.Although the refresh list was created, the content of the materialized view remains unchanged untilthe automatic update, which occurs every night at midnight. After the refresh occurs, the materializedview will reflect all changes made to employee salary since the last refresh occurred.The manual call to DBMS_REFRESH.REFRESH demonstrates how the content of the materialized viewchanges once the view is refreshed. Without the call to the REFRESH procedure, the content of thematerialized view remains unchanged until the next automated run of the REFRESH procedure.11-5. Synchronizing Data with a Remote Data SourceProblemYour database instance requires data that is readily available in another Oracle instance but cannot besynchronized with a materialized view, and you do not want to duplicate data entry.SolutionWrite a procedure that creates a connection to the remote HR database and performs the steps neededto synchronize the two databases. Then use the EXEC DBMS_SCHEDULER.CREATE_JOB procedure to run the  CHAPTER 11  AUTOMATING ROUTINE TASKS239procedure on a regular basis. Suppose, for example, that your Oracle Database instance requires datafrom the HR employee table, which is in another instance. In addition, your employee table containstables with foreign key references on the employee_id that prevents you from using a materialized viewto keep the HR employee table in synchronization.Create a database connection to the remote HR database, and then download the data on a regularbasis: \nCREATE DATABASE LINK hr_dataCONNECT TO hrIDENTIFIED BY hr_passwordUSING‘(DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;TCP)(HOST&#x3D;node_name)(PORT&#x3D;1521))(CONNECT_DATA&#x3D;(SERVICE_NAME&#x3D;hr_service_name)))’; \nCREATE OR REPLACE PROCEDURE sync_hr_data AS \nCURSOR    driver ISSELECT    *FROM    employees@hr_data; \nTYPE    recs_type IS TABLE OF driver%ROWTYPE INDEX BY BINARY_INTEGER;recs    recs_type; \nBEGIN \n   OPEN DRIVER;   FETCH DRIVER BULK COLLECT INTO recs;   CLOSE DRIVER; \n   FOR i IN 1..recs.COUNT LOOP      UPDATE employees      SET    first_name      &#x3D; recs(i).first_name,        last_name            &#x3D; recs(i).last_name,        email                &#x3D; recs(i).email,        phone_number         &#x3D; recs(i).phone_number,        hire_date            &#x3D; recs(i).hire_date,        job_id               &#x3D; recs(i).job_id,        salary               &#x3D; recs(i).salary,        commission_pct       &#x3D; recs(i).commission_pct,        manager_id           &#x3D; recs(i).manager_id,        department_id        &#x3D; recs(i).department_id      WHERE  employee_id     &#x3D; recs(i).employee_id      AND    (    NVL(first_name,’‘)  &lt;&gt; NVL(recs(i).first_name,’‘)       OR    last_name                 &lt;&gt; recs(i).last_name       OR    email                     &lt;&gt; recs(i).email       OR    NVL(phone_number,’‘)     &lt;&gt; NVL(recs(i).phone_number,’‘)       OR    hire_date                 &lt;&gt; recs(i).hire_date       OR    job_id                    &lt;&gt; recs(i).job_id       OR    NVL(salary,-1)            &lt;&gt; NVL(recs(i).salary,-1)       OR    NVL(commission_pct,-1)    &lt;&gt; NVL(recs(i).commission_pct,-1)       OR    NVL(manager_id,-1)        &lt;&gt; NVL(recs(i).manager_id,-1)       OR    NVL(department_id,-1)     &lt;&gt; NVL(recs(i).department_id,-1)CHAPTER 11  AUTOMATING ROUTINE TASKS240        );   END LOOP;– find all new rows in the HR database since the last refresh   INSERT INTO employees   SELECT *   FROM   employees@hr_data   WHERE  employee_id NOT IN (    SELECT    employee_id    FROM      employees);END sync_hr_data;EXEC DBMS_SCHEDULER.CREATE_JOB (            -          JOB_NAME&#x3D;&gt;’sync_HR_employees’,    -          JOB_TYPE&#x3D;&gt;’STORED_PROCEDURE’,     -        JOB_ACTION&#x3D;&gt;’sync_hr_data’,         -           ENABLED&#x3D;&gt;TRUE,                   -    REPEAT_INTERVAL&#x3D;&gt;’FREQ&#x3D;DAILY;INTERVAL&#x3D;1;BYHOUR&#x3D;00;BYMINUTE&#x3D;30’);How It WorksA database link is required to access the data. This recipe focuses more on the synchronization process,but the creation of the database link is demonstrated here. This link, when used, will remotely log intothe HR instance as the HR schema owner.The procedure sync_hr_data reads all records from the HR instances. It does so in a BULK COLLECTstatement, because this is the most efficient method to read large chunks of data, especially over aremote connection. The procedure then loops through each of the employee records updating the localrecords, but only if the data changed, because there is no need to issue the UPDATE unless something haschanged. The NVL is required in the WHERE clause to accommodate values that are NULL and change to anon-NULL value, or vice versa.The final step is to schedule the nightly job. The CREATE_JOB procedure of the DBMS_SCHEDULERpackage completes this recipe. The stored procedure sync_hr_data is executed nightly at 12:30 a.m. SeeRecipe 11-1 for more information on scheduling a nightly batch job.11-6. Scheduling a Job ChainProblemYou have several PL&#x2F;SQL procedures that must run in a fixed sequence—some steps sequentially, othersin parallel. If one step fails, processing should stop.SolutionUse the DBMS_SCHEDULER _CHAIN commands to create and define the order of execution of the chainedprocedures. Figure 11-1 depicts a simple example of a chain of procedures where the successfulcompletion of step 1 kicks off parallel executions of two additional steps. When the two parallel stepscompete successfully, the final step runs.  CHAPTER 11  AUTOMATING ROUTINE TASKS241 \nFigure 11-1. Flowchart representation of a job chain.The following code shows how you can use the CREATE_CHAIN, CREATE_PROGRAM, DEFINE_CHAIN_STEP,and DEFINE_CHAIN_RULE options to implement the order of execution shown in Figure 11-1. \n– Define the ChainBEGIN   DBMS_SCHEDULER.CREATE_CHAIN (    CHAIN_NAME    &#x3D;&gt; ‘Chain1’);END; \n– Create&#x2F;define the program to run in each stepBEGIN   DBMS_SCHEDULER.CREATE_PROGRAM (    PROGRAM_NAME    &#x3D;&gt; ‘Program1’,    PROGRAM_TYPE    &#x3D;&gt; ‘STORED_PROCEDURE’,    PROGRAM_ACTION  &#x3D;&gt; ‘Procedure1’,    ENABLED         &#x3D;&gt; true);END; \nBEGIN   DBMS_SCHEDULER.CREATE_PROGRAM (    PROGRAM_NAME    &#x3D;&gt; ‘Program2’,    PROGRAM_TYPE    &#x3D;&gt; ‘STORED_PROCEDURE’,    PROGRAM_ACTION  &#x3D;&gt; ‘Procedure2’,    ENABLED         &#x3D;&gt; true);END; \nBEGIN   DBMS_SCHEDULER.CREATE_PROGRAM (CHAPTER 11  AUTOMATING ROUTINE TASKS242    PROGRAM_NAME    &#x3D;&gt; ‘Program3’,    PROGRAM_TYPE    &#x3D;&gt; ‘STORED_PROCEDURE’,    PROGRAM_ACTION  &#x3D;&gt; ‘Procedure3’,    ENABLED         &#x3D;&gt; true);END; \nBEGIN   DBMS_SCHEDULER.CREATE_PROGRAM (    PROGRAM_NAME    &#x3D;&gt; ‘Program4’,    PROGRAM_TYPE    &#x3D;&gt; ‘STORED_PROCEDURE’,    PROGRAM_ACTION  &#x3D;&gt; ‘Procedure4’,    ENABLED         &#x3D;&gt; true);END; \n– Create each step using a unique nameBEGIN   DBMS_SCHEDULER.DEFINE_CHAIN_STEP (    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,    STEP_NAME    &#x3D;&gt; ‘Step1’,    PROGRAM_NAME &#x3D;&gt; ‘Program1’);END; \nBEGIN   DBMS_SCHEDULER.DEFINE_CHAIN_STEP (    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,    STEP_NAME    &#x3D;&gt; ‘Step2_1’,    PROGRAM_NAME &#x3D;&gt; ‘Program2’);END; \nBEGIN   DBMS_SCHEDULER.DEFINE_CHAIN_STEP (    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,    STEP_NAME    &#x3D;&gt; ‘Step2_2’,    PROGRAM_NAME &#x3D;&gt; ‘Program3’);END; \nBEGIN   DBMS_SCHEDULER.DEFINE_CHAIN_STEP (    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,    STEP_NAME    &#x3D;&gt; ‘Step3’,    PROGRAM_NAME &#x3D;&gt; ‘Program4’);END; \n– Define the step rules; which step runs first and their orderBEGIN   DBMS_SCHEDULER.DEFINE_CHAIN_RULE (    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,    CONDITION    &#x3D;&gt; ‘TRUE’,    ACTION       &#x3D;&gt; ‘START Step1’); \nEND; \n  CHAPTER 11  AUTOMATING ROUTINE TASKS243BEGIN   DBMS_SCHEDULER.DEFINE_CHAIN_RULE (    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,    CONDITION    &#x3D;&gt; ‘Step1 COMPLETED’,    ACTION       &#x3D;&gt; ‘START Step2_1, Step2_2’);END; \nBEGIN   DBMS_SCHEDULER.DEFINE_CHAIN_RULE (    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,    CONDITION    &#x3D;&gt; ‘Step2_1 COMPLETED AND Step2_2 COMPLETED’,    ACTION       &#x3D;&gt; ‘START Step3’);END; \nBEGIN   DBMS_SCHEDULER.DEFINE_CHAIN_RULE (    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,    CONDITION    &#x3D;&gt; ‘Step3 COMPLETED’,    ACTION       &#x3D;&gt; ‘END’);END; \n– Enable the chainBEGIN   DBMS_SCHEDULER.ENABLE (‘Chain1’);END;&#x2F; \n– Schedule a Job to run the chain every nightBEGIN   DBMS_SCHEDULE.CREATE_JOB (    JOB_NAME        &#x3D;&gt; ‘chain1_Job’,    JOB_TYPE        &#x3D;&gt; ‘CHAIN’,    JOB_ACTION      &#x3D;&gt; ‘Chain1’,    REPEAT_INTERVAL &#x3D;&gt; ‘freq&#x3D;daily;byhour&#x3D;3;byminute&#x3D;0;bysecond&#x3D;0’,    enabled         &#x3D;&gt; TRUE);END;How It WorksDefining and scheduling a job chain may seem daunting at first but can be broken down into thefollowing steps:Create the chain.Define each program that will run.Create each step in the chain.Create the rules that link the chain together.Enable the chain.Schedule the chain as a job to run a specific time or interval.CHAPTER 11  AUTOMATING ROUTINE TASKS244 \nThe DBMS_SCHEDULER.CREATE_CHAIN procedure creates a chain named as Chain1. Note The chain_name must be unique and will be used in subsequent steps.The DBMS_SCHEDULER.CREATE_PROGRAM procedure defines the executable code that will run. Theprograms defined here are run when a chain step is executed. The procedure accepts the followingparameters:• PROGRAM_NAME: A unique name to identify the program.• PROGRAM_TYPE : Valid values are plsql_block, stored_procedure, and executable.• PROGRAM_ACTION : Defines what code actually runs when executed based on thevalue for PROGRAM_TYPE. For a PROGRAM_TYPE of PLSQL_BLOCK, it is a text string of thePL&#x2F;SQL code to run. For a STORED_PROCEDURE, it is the name of an internal PL&#x2F;SQLprocedure. For an EXECUTABLE, it is the name of an external program.• ENABLE : Determines whether the program can be executed; the default is FALSE ifnot specified.The DBMS_SCHEDULER.DEFINE_CHAIN_STEP procedure defines each step in the chain. You must supplythe chain’s name as its first parameters, which was created in the DBMS_SCHEDULER.CREATE_CHAINprocedure, along with a unique name for the step in the chained process and the name of the PL&#x2F;SQLprogram to execute during the step. Note that the program is the name assigned in theDBMS_SCHEDULER.CREATE_PROGRAM procedure; it is not the name of your PL&#x2F;SQL program.The DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure defines how each step in the chain is linkedtogether. Arguably, this is the most difficult step in the process because you must define the starting andending steps in the chain properly. In addition, you must take care in defining links between sequentialsteps and parallel steps. Sketching a flow chart like the one shown in Figure 11-1 can aid in thesequencing of the chain steps.The DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure accepts the following parameters:• CHAIN_NAME: The name used when you created the chain.• CONDITION: An expression that must evaluate to a boolean expression and mustevaluate to true to perform the action. Possible test conditions are NOT_STARTED,SCHEDULED, RUNNING, PAUSED, STALLED, SUCCEEDED, FAILED, and STOPPED.• ACTION: The action to perform when the condition evaluates to true. Possibleactions are start a step, stop a step, or end the chain.• RULE_NAME: The name you want to give to the rule being created. If omitted, Oraclewill generate a unique name.• COMMENTS : Optional text to describe the rule.In this example, the first call to the DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure sets the conditionto TRUE and the action to START Step1. This causes step 1 to run immediately when the chain starts. Thenext call to the DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure defines the action to take when step 1  CHAPTER 11  AUTOMATING ROUTINE TASKS245completes successfully. In this example, steps 2.1 and 2.2 are started. Starting multiple stepssimultaneously allows you to schedule steps to run in parallel. In the third call to theDBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure, the condition waits for the successful completion ofsteps 2.1 and 2.2 and then starts step 3 as its action. The final call to theDBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure waits for the successful completion of step 3 and thenends the chain.If any step in the chain fails, the entire chained process stops at its next condition test. For example,if step 1 fails, steps 2.1 and 2.2 are never started. However, if steps 2.1 and 2.2 are running and step 2.1fails, step 2.2 will continue to run and may complete successfully, but step 3 will never run. You canaccount for chain failures and other conditions by testing for a condition such as NOT_STARTED,SCHEDULED, RUNNING, PAUSED, STALLED, FAILED, and STOPPED.The call to the procedure DBMS_SCHEDULER.ENABLE does just what you expect; it enables the chain torun. It is best to keep the chain disabled while defining the steps and rules. You can run the chainmanually with a call to the DBMS_SCHEDULE.RUN_CHAIN procedure or, as shown in this example, with a callto the DBMS_SCHEDULE.CREATE_JOB procedure. See Recipe 11-1 for more information on scheduling a job. \nC H A P T E R  12 \n   \n247Oracle SQL DeveloperTools can be useful for increasing productivity while developing code. They oftentimes allow you to takeshortcuts when coding by providing templates to start from or by providing autocompletion as wordsare typed. A good development tool can also be useful by incorporating several different utilities andfunctions into one development environment. Oracle SQL Developer is no exception, because itprovides functionality for database administrators and PL&#x2F;SQL developers alike. Functionalities includecreating database tables, importing and exporting data, managing and administering multipledatabases, and using robust PL&#x2F;SQL development tools.Oracle SQL Developer is an enterprise-level development environment, and it would take an entirebook to document each of its features. Rather than attempting to cover each of the available options, thischapter will focus on developing and maintaining Oracle PL&#x2F;SQL code using the tool. Along the way, youwill learn how to configure database connections and obtain information from database objects. In theend, you should feel comfortable developing PL&#x2F;SQL applications using the Oracle SQL Developerenvironment.12-1. Creating Standard and Privileged Database ConnectionsProblemYou want to create a persistent connection to your database from within Oracle SQL Developer usingboth privileged and standard accounts so that you can work with your database.SolutionOpen Oracle SQL Developer, and select New from the File menu. This will open the Create a Newwindow. Select the Database Connection option, and click OK. A New&#x2F;Select Database Connectionwindow opens, which has a list of existing database connections on the left side and an input form forcreating a new connection on the right side, as shown in Figure 12-1. \nCHAPTER 12  ORACLE SQL DEVELOPER248 \nFigure 12-1. Creating a database connectionIf you are creating a standard connection, choose the Basic connection type. If you are creating aprivileged connection as SYS, then choose the SYSDBA connection type. Once you have created aconnection, then you will be able to connect to the database via the user for which you have made aconnection and browse the objects belonging to that user’s schema.How It WorksBefore you can begin working with PL&#x2F;SQL code in Oracle SQL Developer, you must create a databaseconnection. Once created, this connection will remain in the database list that is located on the left sideof the Oracle SQL Developer environment. During the process of creating the connection, you can eitherselect the box to allow the password to be cached or keep it deselected so that you will be prompted toauthenticate each time you want to use the connection. From a security standpoint, it is advised that youleave the box unchecked so that you are prompted to authenticate for each use.Once the connection has been successfully established and you are authenticated, the world ofOracle SQL Developer is opened up, and you have a plethora of options available. At this point, you havethe ability to browse through all the database tables, views, stored programs, and other objects that areavailable to the user account that you used to initiate the connection to the database by simply using thetree menu located within the left pane of the environment. Figure 12-2 shows a sample of what you willsee when your database connection has been established. \n  CHAPTER 12  ORACLE SQL DEVELOPER249 \nFigure 12-2. Database connection in the navigator Note If you plan to develop PL&#x2F;SQL code for system events such as an AFTER LOGON trigger, you should create aseparate connection for the privileged user using SYSDBA. This will allow you to traverse the privileged databaseobjects.As mentioned in the introduction to this chapter, you will learn how to use those features providedby Oracle SQL Developer that are useful for PL&#x2F;SQL application development. This does not mean theother features offered by the environment are not useful, but it would take an entire book to cover eachfeature that Oracle SQL Developer has to offer. Indeed, there are entire books on the topic. This bookstrives to provide you with the education and concepts that you will need to know to develop completeand robust PL&#x2F;SQL applications using Oracle SQL Developer.12-2. Obtaining Information About TablesProblemYou are interested in learning more about a particular database table. You also want to look at systemtriggers and other privileged PL&#x2F;SQL objects.SolutionUse the Oracle SQL Developer navigator to select the table that you want to view information about, asdemonstrated in Figure 12-3.  \nCHAPTER 12  ORACLE SQL DEVELOPER250Figure 12-3. Viewing table informationThe editor window will then populate with a tab that consists of a worksheet and several subtabs.Each of these tabs provides different information about the table you are inspecting. Figure 12-4 showsthe Columns tab of the Table Editor.Figure 12-4. Table EditorHow It WorksOracle SQL Developer provides an excellent means for examining table metadata. When a table isselected within the database connection navigator, a worksheet becomes available that includes detailedinformation pertaining to the table characteristics and data. The first tab, which is labeled Columns,includes information about the table columns and each of their datatypes. This is most likely the tab thatyou will spend the most time in. It includes toolbar buttons that allow you to perform editing on thetable and to refresh the table view in the editor, and it even includes an extensive table manipulationmenu labeled Action that is a database administrator’s dream come true.Next, the Data tab provides a live view of the data that exists within the table. It also includes toolbarbuttons for inserting and deleting rows. This tab resembles a spreadsheet, and it allows differentcolumns to be edited and then committed to the database. For a PL&#x2F;SQL developer, it is most useful forediting data within a table that is being used for application debugging or testing purposes.The Triggers tab will be useful to PL&#x2F;SQL developers because it displays a selectable list of all tabletriggers. You can also create new triggers from the tab. Figure 12-5 shows the Triggers tab.  CHAPTER 12  ORACLE SQL DEVELOPER251 \nFigure 12-5. Triggers tab of editorWhen a trigger is selected on the Triggers tab, its DDL is displayed in a panel on the bottom half ofthe window. The green arrow button will allow the trigger to be executed, and the refresh specifies aninterval of time. You will learn more about trigger development in Recipe 12-11.Oracle SQL Developer provides very useful information regarding database tables for PL&#x2F;SQLdevelopers. It also provides convenient access for trigger development and manipulation.12-3. Enabling Output to Be DisplayedProblemYou want to display the results of DBMS_OUTPUT within Oracle SQL Developer.CHAPTER 12  ORACLE SQL DEVELOPER252SolutionEnable DBMS_OUTPUT for your connection via the Dbms Output pane. This pane resides on the lower-rightside of the IDE. Do so by selecting the green plus icon within the pane and then choosing the desiredconnection from the resulting dialog box. Figure 12-6 shows the connection dialog box. After selectingthe desired connection and then clicking the OK button, you will be prompted for a password for theconnection if you are not already connected. Once a successful password has been entered, thenDBMS_OUTPUT will be enabled for the specified connection. \nFigure 12-6. Select Connection dialog boxAfter enabling the DBMS_OUTPUT option, you will be able to see the output from DBMS_OUTPUT withinOracle SQL Developer. This can be very useful, especially for testing purposes.How It WorksThe easiest way to enable SERVEROUTPUT for a particular database connection is to enable DBMS_OUTPUTfrom within the Dbms Output window. Doing so will enable output to be displayed within the panewhen the code is executed.  Note For more information on the DBMS_OUTPUT package, please see Recipe 1-6.Selecting the Dbms Output option from the View menu will open the DBMS_OUTPUT pane. This panegives you several options that include the ability to save the script output, change the buffer size, andeven print the output. To enable SERVEROUTPUT via the pane, you must select the green plus symbol andchoose a database connection. You will see the correct script output if you run the script again afterenabling DBMS_OUTPUT via one of the two options we have discussed. Figure 12-7 shows the Dbms Outputpane. \n  CHAPTER 12  ORACLE SQL DEVELOPER253 \nFigure 12-7. Dbms Output paneOnce a connection has been established using the Dbms Output pane, all DBMS_OUTPUT code that isexecuted against that connection will be displayed within the pane. It is possible to have more than oneconnection established within the pane, and in this case different tabs can be used to select theconnection of your choice.12-4. Writing and Executing PL&#x2F;SQLProblemYou want to use Oracle SQL Developer to execute an anonymous block of code.SolutionEstablish a connection to the database of your choice, and the SQL worksheet will automatically open.Once the worksheet has opened, you can type the code directly into it. For the purposes of this recipe,type or copy&#x2F;paste the following anonymous block into a SQL worksheet: \nDECLARE  CURSOR emp_cur IS  SELECT * FROM employees; \n  emp_rec emp_cur%ROWTYPE;BEGIN  FOR emp_rec IN emp_cur LOOP    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ‘ ‘ || emp_rec.last_name);  END LOOP;END; \nFigure 12-8 shows the Oracle SQL Developer worksheet after this anonymous block has beenwritten into it. \nCHAPTER 12  ORACLE SQL DEVELOPER254 \nFigure 12-8. Oracle SQL Developer worksheet with PL&#x2F;SQL anonymous blockHow It WorksBy default, when you establish a connection within Oracle SQL Developer, a SQL worksheet for thatconnection is opened. This worksheet can be used to create anonymous code blocks, run SQLstatements, and create PL&#x2F;SQL code objects. The SQL worksheet is analogous to the SQLPlus commandprompt, although it does not allow all the same commands that are available using SQLPlus.If you want to open more than one SQL worksheet or a new worksheet for a connection, this can bedone in various ways. You can right-click (Ctrl+click) the database connection of your choice and thenselect Open SQL Worksheet from the menu. Another way to open a new worksheet is to use the SQLWorksheet option within the Tools menu. This will allow you to specify the connection of your choice toopen a worksheet against.As you type, you will notice that the worksheet will place all Oracle keywords into a different color.This helps distinguish between keywords and defined variables or stored programs. By default, thekeywords are placed into a bold blue text, but this color can be adjusted within the user Preferenceswindow that can be accessed from the Tools drop-down menu. Similarly, any text placed within singlequotes will appear in a different color. By default, this is also blue, except it is not bold.Besides the syntax coloring, there are some other features of the SQL worksheet that can help makeyour programming life easier. Oracle SQL Developer will provide autocompletion for some SQL andPL&#x2F;SQL statements. For instance, if you enter a package name and type a dot, all the package memberswill be displayed in the drop-down list. You can also press Ctrl+spacebar to manually activate theautocomplete drop-down list. After the drop-down list appears, you can use the arrow keys to choosethe option you want to use and then hit the Tab key. Oracle SQL Developer provides similarautocompletion for table and column names and even SQL statement GROUP BY and ORDER BY clauses.Take a look at Figure 12-9 to see the autocomplete feature in action. \n  CHAPTER 12  ORACLE SQL DEVELOPER255 \nFigure 12-9. Autocomplete drop-down listAnother feature that helps productivity is to use Oracle SQL Developer snippets. To learn moreabout snippets, please see Recipe 12-7. Within the SQL worksheet toolbar, there is a group of buttonsthat can be used to help increase programmer productivity. The group of buttons at the far-right side ofthe toolbar contains a button for making highlighted words uppercase, lowercase, and initial-cap. Thebutton that has an eraser on it can be used to quickly clear the SQL worksheet. There is also button thatcan be used to display the SQL History panel. This SQL History panel opens along the bottom of theOracle SQL Developer environment, and it contains all the SQL that has been entered into theworksheet. Double-clicking any line of the history will automatically add that SQL to the currentworksheet. Figure 12-10 shows the SQL History window. \nFigure 12-10. SQL History windowTo execute the SQL or PL&#x2F;SQL that is contained within the script, you can use the first two toolbaricons. The first icon in the toolbar (as shown in Figure 12-8) is a green arrow will execute the code that isin the worksheet and display the result in a separate pane. The second icon in the toolbar (as shown inFigure 12-8) that resembles a piece of paper with a green arrow in front will execute the code within theworksheet and then display the output in a pane that can be saved as script output.CHAPTER 12  ORACLE SQL DEVELOPER256 Note It is possible to have more than one SQL statement or PL&#x2F;SQL block within the SQL worksheet at the sametime. In doing so, only the highlighted code will be executed when the green arrow button is selected. If all thecode is selected, then a separate output pane will appear for the output of each block or statement. However, ifthe Script icon (paper with green arrow) is selected, then all the highlighted code will have its output displayed inthe resulting script output pane.Other toolbar options within the SQL worksheet include the ability to COMMIT or ROLLBACK changesthat are made, run an explain plan on the current code, or set up autotrace. The SQL worksheet is likeSQL*Plus with many additional features. It provides the power of many tools in one easy-to-useenvironment.12-5. Creating and Executing a ScriptProblemYou are interested in creating a PL&#x2F;SQL script using Oracle SQL Developer that will run against yourdatabase. Once it has been created, you want to save it and then execute it.SolutionEstablish a connection to the database for which you want to create a script. By default, the SQLworksheet for the selected database will open. To create a script, choose New from the File menu orselect the first icon on the left side of the toolbar that resembles a piece of paper with a plus sign. Next,select the SQL File option from the Create a New window. When the Create SQL File window opens, typein a file name for your script, and choose a directory in which to store it. For the purposes of thisdemonstration, choose the file name select_employees, browse and choose the desired storage location,and click OK. At this point, a new tab opens in the Oracle SQL Developer editor. This tab represents theSQL file you have just created. Type the following script into the editor for demonstration purposes: \nDECLARE  CURSOR emp_cur IS  SELECT * FROM employees; \n  emp_rec emp_cur%ROWTYPE;BEGIN  FOR emp_rec IN emp_cur LOOP    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ‘ ‘ || emp_rec.last_name);  END LOOP;END; \nAfter the script has been typed into the editor, your Oracle SQL Developer editor should resemblethat shown in Figure 12-11. Save your script by clicking the Save icon that looks like a disk, or chooseSave from the File menu.  CHAPTER 12  ORACLE SQL DEVELOPER257 \nFigure 12-11. Typing a script into the SQL editorTo execute the script, click the Run Script icon that is the second icon from the left above the editor,or press the F5 function key. You will be prompted to select a database connection. At this point, you canchoose an existing connection, create a new connection, or edit an existing connection. Choose thedatabase connection that coincides with the schema for this book. Once you select the connection, thescript will execute against the database, and you will see another pane appear in the lower half of theOracle SQL Developer window. This is the Script Output pane, and you should see a message that states“anonymous block completed.” The editor should now look like Figure 12-12. \nFigure 12-12. Anonymous block completedHow It WorksIn the solution to this recipe, you learned how to create and execute a script using Oracle SQLDeveloper. As you were typing the script, you may have noticed that the text being typed is color-coded.Oracle SQL Developer places PL&#x2F;SQL and SQL keywords into a different color text that can be chosenfrom within the preferences window, which is located within the Tools menu. The default color forkeywords is blue.When the script is executed, it prompts for a database connection to use. Once that connection hasbeen selected and established, then the script is run against the database. The script may not display anyCHAPTER 12  ORACLE SQL DEVELOPER258useful results by default, unless the SERVEROUTPUT has been enabled via the Dbms Output pane. To learnmore about enabling DBMS_OUTPUT, please see Recipe 12-3.When you select the Save option, the script is written to disk to a file having the name you specifiedearlier. To execute a saved script, open the File menu, and then select the Open option. A dialog box willopen that allows you to browse your file system for the script that you want to open. Once you havefound the script and opened it, a new tab is opened, and the script is loaded into that tab along with allthe options of an ordinary SQL worksheet (see Figure 12-13). \nFigure 12-13. Loaded script12-6. Accepting User Input for Substitution VariablesProblemYou want to create a PL&#x2F;SQL application that accepts user input from the keyboard. To test the input,you want to have Oracle SQL Developer prompt you for input.SolutionUse an ampersand in front of a text string just like in SQLPlus. Assign the resulting user variable to aPL&#x2F;SQL variable, or use the value inline.How It WorksJust as SQLPlus treats the ampersand as a token to denote user input, Oracle SQL Developer does thesame. When an ampersand is encountered, Oracle SQL Developer will display a pop-up box to promptthe user for the input. For example, type or copy and paste the following code into the SQL worksheet,and then select the Run Statement toolbar button. \nDECLARE    email     VARCHAR2(25);BEGIN  SELECT   email  INTO  email  FROM employees  WHERE employee_id &#x3D; &amp;emp_id; \n  DBMS_OUTPUT.PUT_LINE(‘Email Address for ID: ‘ || email);  CHAPTER 12  ORACLE SQL DEVELOPER259EXCEPTION  WHEN OTHERS THEN    DBMS_OUTPUT.PUT_LINE(‘An unknown error has occured, please try again.’);END; \nWhen the code is executed, you will be prompted to provide a value for the emp_id variable. Aseparate dialog box that looks like the one shown in Figure 12-14 is displayed. \nFigure 12-14. Entering substitution variableIf the value being accepted from the user is a string, then the ampersand-variable must be placedwithin single quotes. For example, &amp;last_name would be used to prompt for user entry of a string value.12-7. Saving Pieces of Code for Quick AccessProblemYou want to save a portion of code so that it can be made easily reusable by other PL&#x2F;SQL programs.  Tip This recipe also works for frequently used bits of SQL.SolutionUse the Snippets window to create the reusable piece of code and use it for access at a later time.How It WorksThe Snippets window can be accessed by selecting the View menu and then choosing the Snippetsoption. The Snippets window will open as a pane on the far-right side of the Oracle SQL Developerenvironment. The pane consists of a toolbar that includes a button used for creating a new snippet and abutton for editing an existing snippet. There is also a drop-down menu that consists of several menuoptions that organize each of the snippets into a different category. Figure 12-15 shows the Snippetspane. \nCHAPTER 12  ORACLE SQL DEVELOPER260Figure 12-15. SnippetsThe snippet is used by dragging its text onto a SQL worksheet or script. Once dragged onto theworksheet, the actual code is displayed in a template fashion. In some cases, you will need to change abit of the text to make it usable, but the reusable code that is provided by the snippet can greatly reducedevelopment time.You can add your own snippet by selecting the icon that resembles a piece of paper with a plus signon it from the Snippets panel. This opens the Save Snippet window (as shown in Figure 12-16) that givesyou the option of using one of the existing categories or typing a new one. You can also type a name andtooltip for the snippet. The name of the snippet will appear in the Snippets panel after it has been saved.The text of the snippet itself will be placed into the worksheet once you drag the name of your snippet toa worksheet or script.Figure 12-16. Save Snippet pane  CHAPTER 12  ORACLE SQL DEVELOPER261The Edit Snippet icon (the one with the pencil through it) brings up another window that allows youto choose an existing snippet to edit, create a new snippet, or delete a snippet. Only those snippets thatyou have created are available for editing. Figure 12-17 displays the Edit Snippets window. \nFigure 12-17. Edit Snippets windowThe snippets are actually saved within an XML file named UserSnippets.xml. This file is located inyour user sqldeveloper directory. This file can be transported to another machine and placed into thesqldeveloper directory so that the snippets can be made available in more than one place. This can beuseful if you have a group of developers who may want to share snippets. The ability to copy theUserSnippets.xml file into other user sqldeveloper directories and make the snippets available to otherusers can certainly be advantageous.Snippets can be useful for saving the time of typing a SQL or PL&#x2F;SQL construct. They can also bebeneficial if you do not remember the exact syntax of a particular piece of code. They provide quickaccess to template-based solutions.12-8. Creating a FunctionProblemYou want to create a function using Oracle SQL Developer.SolutionYou can manually create the function by typing the code into the SQL worksheet for the databaseconnection for which you want to create. You can also use the Create Function Wizard within OracleSQL Developer to provide some assistance throughout the function creation process. There are a couplepCHAPTER 12  ORACLE SQL DEVELOPER262of different ways to invoke the Create Function Wizard. If you go to the File menu and select New, theCreate a New window opens, and Function is one of the available options. You can also reach the samemenu by selecting the New toolbar button. Both of these paths will lead you to the same windowbecause after clicking OK, the Create PL&#x2F;SQL Function window will appear (Figure 12-18).  \nFigure 12-18. Create PL&#x2F;SQL Function windowA final way to invoke this same window is to establish a database connection and then expand theconnection navigator to list all subfolders and then right-click the Functions subfolder. One of theavailable options after doing so will be New Function.How It WorksIf using the SQL worksheet to create a function, you will need to type the code for creating your functioninto the editor and then click the Run button to compile and save the object. If any errors areencountered while compiling, they will appear in the Messages window along with the line number thatthey occurred on. The SQL worksheet works very well for those who are well accustomed to creatingfunctions. The Create Function Wizard may be the best choice for creating a function or those who liketo write less code. Note Using the Connections pane, you are able to browse both valid and invalid objects. An object may becomeinvalid if it is not compilable, becomes stale, or because of issues with other dependencies.Once within the Create PL&#x2F;SQL Function window, you will be able to name the function and specifyany parameters that will need to be used. The first parameter in the list is already defined by default, andit represents the function’s return value. You can change the return type by selecting from the list ofdatatype options within the Type column of the parameter listing.  CHAPTER 12  ORACLE SQL DEVELOPER263To add a new parameter, click the plus symbol on the right side of the window, and a new line willbe added to the parameter-listing table. You can then populate the name of the parameter, select adatatype and mode, and designate a default value if one should exist. After all parameters have beendeclared, click the OK button to continue.The function editor window will open, and it will contain the code that needs to be used for creationof the function that you have defined. All that is left to code will be any declarations and then the actualfunction code. The editor window contains a toolbar of options along with several tabs that can be usedto find out more information about a function once it has been created (Figure 12-19). \nFigure 12-19. The Function Editor windowThe remaining function declarations and code should be typed into the editor, and whencompleted, the Save toolbar button or menu option can be used to compile and save the function intothe database. If there are compilation errors upon saving, the errors will be displayed in a Compiler – Logwindow along with the line number on which the error occurred. By clicking the error in the window,your cursor will be placed on the line of code that needs to be repaired. Figure 12-20 shows the Compiler– Log window including a reference to an error in the code. \nFigure 12-20. Compilation errors in Function EditorOnce you have successfully compiled and saved the function into the database, it can be executedfor testing purposes using the green arrow icon within the Function Editor window. When you executeCHAPTER 12  ORACLE SQL DEVELOPER264the function, the Run PL&#x2F;SQL window will be displayed. If you defined any parameters for the function,you can supply values for them within the PL&#x2F;SQL Block portion of the window. You can then click OK toexecute the function using the value(s) you have defined within the window, and the results will bedisplayed in the Run Log window. The Run PL&#x2F;SQL window can also be used to save your test case to afile or restore a test case from disk. The test case incorporates all the text that is contained within thePL&#x2F;SQL block portion of the Run PL&#x2F;SQL window. This window is displayed in Figure 12-21. \nFigure 12-21. Run PL&#x2F;SQL windowYou can use the database navigator to display the functions contained within a particular databaseconnection. If you highlight a particular trigger and right-click it, then a menu containing several optionswill be displayed. This is shown in Figure 12-22. \nFigure 12-22. Using the navigator with functionsThe options provided can be used for administering or editing the selected function. The Editoption will open the Function Editor, and it will contain the code for the selected function. If the selectedfunction is not compiled successfully, then you can make changes to it and choose the Compile option  CHAPTER 12  ORACLE SQL DEVELOPER265within the right-click contextual menu to recompile the code. Similarly, the menu can be used to invokethe profiler, debug, or administer privileges for the function.12-9. Creating a Stored ProcedureProblemYou want to create a stored procedure using Oracle SQL Developer.SolutionYou can manually create a stored procedure by typing the code for creating your procedure into a SQL worksheetand executing it. You can also use the Create Procedure Wizard. To start the wizard, go to the File menu andselect the New option. Once the Create a New dialog box opens (Figure 12-23), select Procedure. \nFigure 12-23. Create a New dialog boxOnce you click OK, you will be prompted to select a database connection. Doing so will open theCreate PL&#x2F;SQL Procedure Wizard. Alternatively, you can connect to the database of your choice andthen expand the navigator so that all the objects within the database are available. Right-click theProcedures submenu, and select New Procedure, as shown in Figure 12-24. \nFigure 12-24. Right-click the Procedures submenu within a designated database connection.eCHAPTER 12  ORACLE SQL DEVELOPER266How It WorksYou can use the Create a New Wizard or SQL worksheet to create a new stored procedure. The wizard isbest suited for those who are new to PL&#x2F;SQL or not very familiar with the overall syntax for creating astored procedure. To use the wizard, select the File menu followed by the New option. At this point, youwill be presented with the Create a New window that allows several options for creating new databaseobjects or code. Select the Procedure option, and click OK. Oracle SQL Developer will now prompt youto select a database connection for which you will create the stored procedure. Select the connection ofyour choice, and click OK. The Create PL&#x2F;SQL Procedure window will open, and it will resemble Figure12-25. \nFigure 12-25. Create PL&#x2F;SQL Procedure windowThe Create PL&#x2F;SQL Procedure window provides a window that can be used to create a procedure.You can select a schema and name the procedure. There is a check box that allows you to create yourcode using all lowercase if you want. Using the green plus symbol on the right side of the window, youcan add a row of text to the Parameters window. By default, the parameter will be named PARAM1, and itwill be given a datatype of VARCHAR2 with a mode of IN. All of these options can be changed, including thename. You can add zero or more parameters to the list, and you can rearrange their order by selecting aparameter from the list and using the arrow buttons on the right side of the window. You can select theDDL tab to see the actual code for creating the stored procedure, along with all the parameters you havedefined. When finished, you can optionally choose to save your code to disk using the Save button andthen click OK to create the procedure.Once you have completed and saved the Create PL&#x2F;SQL Procedure form, the code is transferred to aSQL worksheet that is a procedure editor that contains buttons and tabs for working with the storedprocedure, as shown in Figure 12-26. \n  CHAPTER 12  ORACLE SQL DEVELOPER267 \nFigure 12-26. Stored Procedure WizardThe worksheet contains six tabs that can be used to find out more information about the storedprocedure that it contains. This information includes the grants that have been made on the procedure.Other information includes dependencies, references, details, and profiles. You can add code to theprocedure by typing into the editor. The editor will perform autocompletion where appropriate, andsnippets can be dragged into the editor.Next, copy the following procedure into the editor for testing purposes: \nCREATE OR REPLACE PROCEDURE INCREASE_WAGE(  EMPNO_IN IN NUMBER, PCT_INCREASE IN NUMBER) AS  emp_count    NUMBER :&#x3D; 0;  Results   VARCHAR2(50);BEGIN \n  SELECT count(*)  INTO EMP_COUNT  FROM EMPLOYEES  WHERE employee_id &#x3D; empno_in; \n  IF emp_count &gt; 0 THEN    UPDATE EMP    SET salary &#x3D; salary + (salary * PCT_INCREASE)    WHERE employee_id &#x3D; empno_in;    Results :&#x3D; ‘SUCCESSFUL INCREASE’;  ELSE    Results :&#x3D; ‘NO EMPLOYEE FOUND’;  END IF; \n  DBMS_OUTPUT.PUT_LINE(RESULTS);END; \nOnce the procedure has been coded, select the Save option from the File menu, or click the Saveicon that contains an image of a disk. This will compile and store the procedure into the database. Youcan alternatively use the Gears button to compile and save, which will produce the same results. If anycompilation errors are found, they will be displayed in a pane below the editor along with the linenumber on which the error was found (Figure 12-27). \nCHAPTER 12  ORACLE SQL DEVELOPER268 \nFigure 12-27. Compilation errorsIf you double-click the error message, the cursor will be placed into the line of code that containsthe error. In this case, you can see that the EMP table does not exist. Replace it with EMPLOYEES, and thenclick the Save button again. The procedure should now be successfully compiled and saved into thedatabase. If you select the Refresh icon above the navigator, the new procedure will appear within thelist of procedures for the database connection.To execute the procedure, right-click it within the navigator, and choose the Run option; this willcause the Run PL&#x2F;SQL window to open. This window is shown in Figure 12-28. \nFigure 12-28. Run PL&#x2F;SQL procedure windowAt this point, you have the option to save the file to disk or open another SQL file. If you want to testthe procedure, then you can assign some values to the parameters within this window. Assign the valuesdirectly within the code that is listed in the PL&#x2F;SQL Block section of the Run PL&#x2F;SQL window. When youclick OK, then the procedure will be executed. The results of the execution will be displayed in the logpane that is located below the editor pane.12-10. Creating a Package Header and BodyProblemYou want to create a package and store it into the database using Oracle SQL Developer.SolutionUse the Create Package Wizard, or type the PL&#x2F;SQL package code into a SQL worksheet. To start thewizard, go to the File menu, and select the New option. Once the Create a New dialog box opens, selectPackage, as shown in Figure 12-29.  CHAPTER 12  ORACLE SQL DEVELOPER269 \nFigure 12-29. Creating a new packageOnce you click OK, you will be prompted to select a database connection. This will open the CreatePL&#x2F;SQL Package Wizard. Alternatively, you can connect to the database of your choice and then expandthe navigator so that all the objects within the database are available. Right-click (Ctrl+click) thePackages submenu and select New Package.How It WorksCreating a new package with Oracle SQL Developer is much the same as creating other code objectsusing this tool. You can develop using the manual technique of writing all code using the SQL worksheet,or you can use the creation wizards that are provided by the tool. You can type the example code into aSQL worksheet for your data connection and click the Run Statement toolbar button to compile and savethe package into the database. You can also issue a Save As and save the code to a file on yourworkstation when writing code using the SQL worksheet.Alternatively, the wizard is useful for quickly creating the standard code for a package, and you canuse the editor to add the details that are specific to your package. Once you have opened the NewPackage Wizard, you will be prompted to enter a package name. For the purposes of this recipe, enterthe name PROCESS_EMPLOYEE_TIME, and click OK. If there is an existing object that has the same name,then you will be alerted via a red pop-up message (Figure 12-30). \nFigure 12-30. Naming the PL&#x2F;SQL package using creation wizardCHAPTER 12  ORACLE SQL DEVELOPER270 Note If you want to enter all code in lowercase for readability within the tool, you can select the check boxbefore clicking OK once the package has been named.  PL&#x2F;SQL is not a case-sensitive language, so case does notaffect code execution.After proceeding, the package editor is opened, and it contains some standard package creationcode using the name that you placed into the wizard. As you can see from Figure 12-31, the packageeditor contains several tabs, along with a search bar and Run, Debug, Compile, and Profile buttons.Enter the following example code into the text box on the Code tab:CREATE OR REPLACE PACKAGE process_employee_time IS  total_employee_salary              NUMBER;  PROCEDURE grant_raises(pct_increase IN NUMBER);  PROCEDURE INCREASE_WAGE (empno_in IN NUMBER,                           Pct_increase IN NUMBER) ;END;Figure 12-31. Package editor windowClick the Save button to compile and store the package into the database. Once this has beencompleted, then the package header should be successfully stored in the database. Next, a package bodywill need to be added in order to make the package functional. This can be done by expanding thePackage subfolder within the navigator. Once expanded, select the package for which you want to createa body. Right-click the selected package, and select the Create Body option (Figure 12-32).Figure 12-32. Creating a package body  CHAPTER 12  ORACLE SQL DEVELOPER271Next, the standard package body creation code will be added to an editor much like the SQLworksheet. You can now edit this code accordingly to ensure that it performs the correct actions. Typethe following package body into the editor, and then click the Save button to compile and store thepackage body: \nCREATE OR REPLACE PACKAGE BODY process_employee_time AS  PROCEDURE grant_raises (    pct_increase IN NUMBER) as      CURSOR emp_cur is      SELECT employee_id      FROM employees;    BEGIN      FOR emp_rec IN emp_cur LOOP        increase_wage(emp_rec.employee_id, pct_increase);      END LOOP;      DBMS_OUTPUT.PUT_LINE(‘All employees have received the salary increase’);  END grant_raises; \n PROCEDURE increase_wage (  empno_in IN NUMBER,  Pct_increase IN NUMBER) as  Emp_count    NUMBER :&#x3D; 0;  Results   VARCHAR2(50);BEGIN  SELECT count(*)  INTO emp_count  FROM employees  WHERE employee_id &#x3D; empno_in; \n  IF emp_count &gt; 0 THEN    UPDATE employees    SET salary &#x3D; salary + (salary * pct_increase)    WHERE employee_id &#x3D; empno_in; \nSELECT salary \nINTO total_employee_salary \nFROM employees \nWHERE employee_id = empno_in; \n\nResults := &#39;SUCCESSFUL INCREASE&#39;; \n\n  ELSE    Results :&#x3D; ‘NO EMPLOYEE FOUND’;  END IF;  DBMS_OUTPUT.PUT_LINE(results); \n END increase_wage;END process_employee_time; \nIf any compilation errors are encountered, an error window will be displayed providing the linenumber and specific error message that needs to be addressed. After any compile errors are repaired, thepackage body will be successfully created. You can then use the navigator to expand the package nameand see the package body listed within it. Right-clicking the package body in the navigator offers someCHAPTER 12  ORACLE SQL DEVELOPER272options such as Edit, Run, Compile, Profile, and Debug. You will learn more about debugging in Recipe12-12. The Edit option will open the package body editor if it is not already open. The Run option willopen the Run PL&#x2F;SQL window, which allows you to select a procedure or function to execute from thechosen package (Figure 12-33). \nFigure 12-33. Running the PL&#x2F;SQL packageOnce a function or procedure is chosen from the Run PL&#x2F;SQL window, it is executed using thevalues that are assigned to the variables within the PL&#x2F;SQL Block panel of the window (this code isautomatically generated by SQL*Developer). These values can be changed prior to running the packageby editing the code that is displayed within the panel. This window also provides the opportunity to savethe code to a file or load code from an existing file.Oracle SQL Developer makes developing PL&#x2F;SQL packages easy. All the tools that are needed tosuccessfully create, edit, and manage packages are available within the environment. Whether you are abeginner or seasoned expert, these tools will make package development and maintenance a breeze.12-11. Creating a TriggerProblemYou need to create a DML database trigger that validates data prior to inserting it into a table, and youwant to use Oracle SQL Developer to do so. For instance, you want to create a trigger that will validate ane-mail address prior to inserting a row into the EMPLOYEES table.SolutionUse the Create Trigger Wizard, type the PL&#x2F;SQL trigger code into a SQL worksheet, or use the triggeroptions that are available from the database table worksheet. To start the wizard, go to the File menuand select the New option. Once the Create a New dialog box opens, select Trigger. This will open theCreate Trigger window, as shown in Figure 12-34. \n  CHAPTER 12  ORACLE SQL DEVELOPER273 \nFigure 12-34. Creating a new triggerThe Create Trigger window simplifies the process of creating a trigger because it provides all theessential details that are required up front. Once the information has been completed, the trigger codecan be developed using the trigger editor window.How It WorksAs with all the other code creation techniques available in Oracle SQL Developer, there are variousdifferent ways to create a trigger. Using the SQL worksheet for a database connection is the best way tomanually create a trigger. To do so, you will need to open the SQL worksheet, type the trigger creationcode, and click the Run toolbar button to compile and save the code. The many wizards that areavailable for trigger creation can greatly simplify the process, especially if you are new to PL&#x2F;SQL or rustyon the details of trigger creation.As mentioned in the solution to the recipe, the Create Trigger window allows you to specify all thedetails for creating a trigger. You choose the type of trigger by selecting one of the options available fromthe drop-down menu. Different options become available in the window depending upon the type oftrigger you choose to create. By default, a table trigger is chosen. Using that option, you can select thetable from another drop-down list and choose whether the trigger should be executed on INSERT, UPDATE,or DELETE from the specified table. The wizard allows you to specify your own variable names forrepresenting old and new table values. The timing for trigger execution is determined by selectingBefore, Statement Level, After, or Row Level and specifying an optional WHEN clause. You can even specifywhether the trigger is to be executed based upon a specific column.If you attempt to enter a trigger name that matches an existing object in the database within thespecified schema, you will receive an error message, as shown in Figure 12-35. \nCHAPTER 12  ORACLE SQL DEVELOPER274 \nFigure 12-35. Create Trigger window–—object already existsAfter finishing with the Create Trigger Wizard and clicking the OK button, the initial trigger creationcode will be displayed in an editor (Figure 12-36). \nFigure 12-36. Trigger EditorType the following code into the editor, and hit the Save button to compile the code and save it intothe database: \nTRIGGER CHECK_EMAIL_ADDRESSBEFORE INSERT ON employeesFOR EACH ROWBEGIN  IF NOT INSTR(:new.email,‘@’) &gt; 0 THEN    RAISE_APPLICATION_ERROR(-20001, ‘INVALID EMAIL ADDRESS’);  END IF;END; \n  CHAPTER 12  ORACLE SQL DEVELOPER275The Save button will automatically compile the code, and the output will appear in the Messagespane below the editor, as shown in Figure 12-37. \nFigure 12-37. Messages logAfter the trigger has been successfully compiled and stored into the database, it can be highlightedin the navigator, and right-clicking it will reveal several options (Figure 12-38). \nFigure 12-38. Trigger optionsThese options help allow easy access for dropping, disabling, or enabling the trigger. Choosing theEdit option from this submenu will open the trigger in the editor window to allow for codemodifications.Using the Create Trigger Wizard in Oracle SQL Developer can greatly reduce the time it takes tocreate a database trigger. By selecting the appropriate options within the wizard, you will be left withonly the trigger functionality to code.CHAPTER 12  ORACLE SQL DEVELOPER27612-12. Debugging Stored CodeProblemOne of your stored procedures contains logical errors, and you want to use Oracle SQL Developer to helpyou find the cause.SolutionA few different options are available for debugging stored code within Oracle SQL Developer. Theenvironment includes a complete debugger that provides the ability to set breakpoints within the codeand modify variable values at runtime to investigate a problem with your code. There are several ways toinvoke the debugger for a particular piece of code. When a code object is opened within the editor, thetoolbar will contain a red “bug” icon that can be used to invoke the debugger (Figure 12-39).  \nFigure 12-39. Debugger iconThe right-click contextual menu within the navigator also contains a Debug option for proceduresand packages (Figure 12-40). \nFigure 12-40. Debugger option in NavigatorHow It WorksUsing the debugger is a great way to find issues with your code. The debugger enables the application tohalt processing at the designated breakpoints so that you can inspect the current values of variables andstep through each line of code so that issues can be pinpointed. Debugging PL&#x2F;SQL programs is amultistep process that consists of first setting breakpoints in code, followed by compiling the code fordebug, and lastly running the actual debugger. To use the debugger, the user who is running thedebugger must be granted some database permissions. The user must be granted the DEBUG ANYPROCEDURE privilege to have debug capabilities on any procedure or DEBUG  to allowdebugging capabilities on a single procedure. The DEBUG CONNECT SESSION privilege must also be grantedin order to allow access to the debugging session.  CHAPTER 12  ORACLE SQL DEVELOPER277After a user has been granted the proper permissions for debugging, the next step is to place abreakpoint (or several) into the code that will be debugged. For the purposes of this recipe, theINCREASE_WAGE procedure will be loaded into the procedure editor, and a breakpoint will be set byplacing the mouse cursor on the left margin of the editor window next to the line of code that you wantthe debugger to pause execution at. Once the cursor is in the desired location, click in the left margin toplace the breakpoint. Figure 12-41 shows a breakpoint that has been placed at the beginning of a SELECTstatement within the INCREASE_WAGE procedure. \nFigure 12-41. Setting a breakpointAfter one or more breakpoints have been placed, the code needs to be compiled for debug. To do so,use the icon in the editor toolbar for compiling, and select the Compile for Debug option. Once the codehas been compiled for debug, its icon in the navigator will adopt a green bug to indicate that it is readyfor debugging (Figure 12-42). \nFigure 12-42. Code ready for debugNext, the debugger can be started by selecting the debug icon within the editor or by right-clickingthe code within the navigator and selecting the Debug option. If the user who is debugging the codedoes not have appropriate permissions to debug, then error messages such as those shown in Figure 12-43 will be displayed. \nFigure 12-43. User not granted necessary permissionsAssuming that the user has the correct permissions to debug, the Debug PL&#x2F;SQL window will bedisplayed. This window provides information about the code that is being debugged including the targetCHAPTER 12  ORACLE SQL DEVELOPER278name, the parameters, and a PL&#x2F;SQL block that will be executed in order to debug the code. The codethat is contained within the PL&#x2F;SQL block portion of the screen can be modified so that the parametersbeing passed into the code (if any) can be set to the values you choose (Figure 12-44). In Figure 12-44,the values have been set to an EMPNO_IN value of 10 and a PCT_INCREASE value of .03. \nFigure 12-44. Debug PL&#x2F;SQL windowOnce the Debug PL&#x2F;SQL window has been completed with the desired values, click OK to begin thedebugger. This will cause Oracle SQL Developer to issue the DBMS_DEBUG_JDWP.CONNECT_TCP (hostname,port) command and start the debugging session. The debugger will start, and it will provide a number ofdifferent options, allowing you to step through the code one line at a time and see what the variablevalues are at any given point in time. You will see three tabs on the debugger: Data, Smart Data, andWatches. The Data tab is used for watching all the variables and their values as you walk through yourcode using the debugger. The Smart Data tab will keep track of only those variables that are part of thecurrent piece of code that is being executed. You can set watches to determine which variables that youwould like to keep track of. The inspector can be used to see the values within those variables you arewatching. You are also given the very powerful ability to modify the values at runtime as the code isexecuting. This provides the capability of determining how code will react to different values that arepassed into it.The Oracle SQL Developer debugger is a useful tool and provides an intuitive user interface over theDBMS_DEBUG_JDWP utility. Although this recipe covers only the basics to get you started, if you spend timeusing each feature of the debugger, then you will learn more powerful ways to help you maintain anddebug issues found in your code.12-13. Compiling Code Within the NavigatorProblemYou want to compile some PL&#x2F;SQL code within Oracle SQL Developer. In this solution, the navigationmenu of your Oracle SQL Developer environment contains code that has a red X on it. This means thecode needs to be compiled or that it contains an error.  CHAPTER 12  ORACLE SQL DEVELOPER279SolutionSelect the code that needs to be compiled, and right-click (Ctrl+click) it. A menu will be displayed thatlists several options. Select the Compile option from that menu (Figure 12-45). \nFigure 12-45. Compile optionHow It WorksThe Oracle SQL Developer navigation menu is very handy for quickly glancing at the code that adatabase contains. All the code that is successfully loaded into the database will contain a green checkmark, whereas any code that has a compilation error will contain a red X label. Sometimes code needs tosimply be recompiled in order to validate it and make it usable once again. This is most often the caseafter a database has just recently been migrated or updated. This can also occur if a particular piece ofcode depends upon another piece of code that has recently been modified, although Oracle Database11gR2 includes fine-grained dependencies that help alleviate this issue. Another event that may causecode to require recompilation is if an object that the code references such as a table or view has beenchanged. Whatever the case, Oracle SQL Developer makes it easy to recompile code by right-clicking itwithin the navigator and selecting Compile from the pop-up menu. Note Oracle Database 11g introduced the idea of fine-grained dependencies. This allows PL&#x2F;SQL objects toremain valid even if an object that they depend upon has changed, as long as the changes do not affect thePL&#x2F;SQL object. For instance, if a column has been removed from a table and object A depends upon that table butnot the specific column that was removed, then object A will remain valid.Once the compile task has been completed, a message will be displayed within the Messages panel tonote whether the compilation was successful. If there were any issues encountered, they will be listed,each on a separate line, within the Messages window. The messages will contain the error code, as wellas the line number that caused the exception to be raised. Double-clicking each error message will takeyou directly to the line of code that raised the exception so that you can begin working on repairs. \nC H A P T E R  13 \n   \n281Analyzing and ImprovingPerformanceThis chapter introduces several methods to help you analyze your code to improve its performance interms of runtime or memory usage. Many recipes use the DBMS_PROFILE package, which is supplied byOracle, to help in the analysis. It is a useful tool for identifying which lines of code consume the mostexecution time.13-1. Installing DBMS_PROFILERProblemYou want to analyze and diagnose your code to find bottlenecks and areas where excess execution timeis being spent, but the DBMS_PROFILER package is not installed.SolutionInstall the DBMS_PROFILER packages, and then create the tables and the Oracle sequence object they needin order to run. Once installed, you can use the DBMS_PROFILER package to help diagnose applicationperformance issues.Installing the PackagesTo install the DBMS_PROFILER packages, follow these steps:The packages are owned by the SYS account; therefore, it requires DBA loginaccess. Start by opening a SQL Plus connect with the connect sys command. Ifthe operation is successful, the system will respond with the message“Connected.”connect sys&#x2F;sys_pwd as sysdbaConnected.Once connected, run the profload.sql script that can be found within theRDBMS&#x2F;ADMIN directory contained in your Oracle Database home. The systemwill respond with a series of messages like those shown next.@[Oracle_Home]&#x2F;RDBMS&#x2F;ADMIN&#x2F;profload.sql \nYou should see the following output after executing the script:CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE282 \nPackage created.Grant succeeded.Synonym created.Library created.Package body created.Testing for correct installationSYS.DBMS_PROFILER successfully loaded.PL&#x2F;SQL procedure successfully completed.Finally, enter the grant execute command to ensure that all schemas within thedatabase have access to the DBMS_PROFILER package.grant execute on DBMS_PROFILER to PUBLIC;Grant succeeded.Creating the Profiler Tables and Sequence ObjectCreate the tables and Oracle sequence object you need for the profiler to run. Log into the account thatwants to use the profiler, and enter the following. The system will respond as follows: \n@[Oracle_Home]&#x2F;RDBMS&#x2F;ADMIN&#x2F;proftab.sqlHow It WorksThe first step creates the packages and makes them available for public access. The second creates therequired tables in the schema that wants to use the profiler. There are alternatives to this installationmethod based on needs and preferences.The DBA may, for example, want to grant execution privileges to specific users instead of everyone.Step 2 must be repeated for every user who wants to use the profiling tools. An alternative is for the DBAto create public synonyms for the tables and sequence created, thereby having only one copy of theprofiler table, in which case the solution changes as in the following example. In the following recipe,replace [Oracle_Home] with the exact path used to install the database software on your system. \nconnect sys&#x2F;sys_pwd as sysdba@[Oracle_Home]&#x2F;RDBMS&#x2F;ADMIN&#x2F;profload.sqlgrant execute on DBMS_PROFILER to USER1, USER2, USER3;@[Oracle_Home]&#x2F;RDBMS&#x2F;ADMIN&#x2F;proftab.sql \nCREATE PUBLIC SYNONYM plsql_profiler_data FOR plsql_profiler_data;CREATE PUBLIC SYNONYM plsql_profiler_units FOR plsql_profiler_units;CREATE PUBLIC SYNONYM plsql_profiler_runs FOR plsql_profiler_runs;CREATE PUBLIC SYNONYM plsql_profiler_runnumber FOR plsql_profiler_runnumber;  CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE28313-2. Identifying BottlenecksProblemYou notice that a PL&#x2F;SQL program is running slowly, and you need to identify what sections of the codeare causing it to perform poorly.SolutionUse the DBMS_PROFILER routines to analyze the code and find potential bottlenecks. In the followingexample, the profiler is used to collect statistics on a run of a program, and then a query displays thestatistics.  \nEXEC DBMS_PROFILER.START_PROFILER (‘Test1’, ‘Testing One’);EXEC sync_hr_data;    – the procedure identifed has having a bottleneckEXEC DBMS_PROFILER.FLUSH_DATA;EXEC DBMS_PROFILER.STOP_PROFILER; \nNow that the profile data is collected, you can query the underlying tables to see the results of theanalysis: \nCOL line# FORMAT 999COL hundredth FORMAT a6 \nSELECT    d.line#,          to_char (d.total_time&#x2F;10000000, ‘999.00’) hundredth,          s.textFROM    user_source      s,        plsql_profiler_data  d,        plsql_profiler_units u,        plsql_profiler_runs  rWHERE  r.run_comment     &#x3D; ‘Test1’ – run_comment matches the text in START_PROFILERAND    u.runid           &#x3D; r.runidAND    u.unit_owner      &#x3D; r.run_ownerAND    d.runid           &#x3D; r.runidAND    d.unit_number     &#x3D; u.unit_numberAND    s.name            &#x3D; u.unit_nameAND    s.line            &#x3D; d.line#ORDER BY d.line#; \nHere are the results of the previous query: \n 1     .00 PROCEDURE sync_hr_data AS 3     .00 CURSOR    driver is 4   11.58 SELECT    * 5     .00 FROM      employees@hr_data; 9    2.25    FOR recs IN driver LOOP10    1.64       UPDATE      employees15     .01 END sync_hr_data; \nCHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE284Here is the complete source code for the sync_hr_data procedure: \nCREATE OR REPLACE PROCEDURE sync_hr_data AS \nCURSOR    driver ISSELECT    *FROM      employees@hr_data; \nBEGIN \n   FOR recs IN driver LOOP      UPDATE employees      SET    first_name  &#x3D; recs.first_name      WHERE  employee_id &#x3D; recs.employee_id;   END LOOP; \nEND sync_hr_data;How It WorksThere are four steps necessary to collect statistics on a running procedure: \n\nCall the DBMS_PROFILER.START_PROFILER routine to begin the process ofcollecting statistics. The two parameters allow you to give the run a name anda comment. Unique names are not required, but that will make it easier toquery the results later. \nExecute the program you suspect has bottleneck issues; in this example, werun the sync_hr_data program.  \nExecute DBMS_PROFILER.FLUSH_DATA to write the data collected to the profilertables.  \nCall the DBMS_PROFILER.STOP_PROFILER routine to, as the name implies, stop thecollection of statistics.The query joins the profiler data with the source code lines to display executable lines and theexecution time, in hundredths of a second. The raw data stores time in nanoseconds. The query resultsshow three lines of code with actual execution time.The SELECT statement from the program unit in question, in which Oracle must establish a remoteconnection via a database link, consumes the majority of the execution time. The remainder of the timeis consumed by the FOR statement, which fetches each record from the remote database connection, andthe UPDATE statement, which writes the data to the local database.Selecting records in the loop and then updating them causes the program to switch context betweenPL&#x2F;SQL and the database engine. Each iteration of the LOOP causes this switch to occur. In this example,there were 107 employee records updated. The next recipe shows you how to improve the performanceof this procedure.  CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE28513-3. Speeding Up Read&#x2F;Write LoopsProblemYou have identified a loop that reads and writes large batches of data. You want to speed it up.SolutionUse a BULK COLLECT statement to fetch the target data records, and then use a FORALL loop to update thelocal database. For example, suppose you want to speed up the sync_hr_data procedure demonstratedin Chapter 11:\n\nCREATE OR REPLACE PROCEDURE sync_hr_data AS \nCURSOR    driver ISSELECT    *FROM      employees@hr_data; \nTYPE    recs_type IS TABLE OF driver%ROWTYPE INDEX BY BINARY_INTEGER;recs    recs_type; \nBEGIN \n   OPEN driver;   FETCH driver BULK COLLECT INTO recs;   CLOSE driver; \n   FORALL i IN 1..recs.COUNT      UPDATE    employees      SET       first_name    &#x3D; recs(i).first_name      WHERE     employee_id &#x3D; recs(i).employee_id; \nEND sync_hr_data; \nRun the profiler procedures to collect additional statistics: \nEXEC DBMS_PROFILER.START_PROFILER (‘Test2’, ‘Testing Two’);EXEC sync_hr_data;EXEC DBMS_PROFILER.FLUSH_DATA;EXEC DBMS_PROFILER.STOP_PROFILER; \nQuery the underlying tables to see the results of the analysis: \nCOL line# FORMAT 999COL hundreth FORMAT A6 \nSELECT    d.line#,          TO_CHAR (d.total_time&#x2F;10000000, ‘999.00’) hundreths,          s.textCHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE286FROM    user_source             s,        plsql_profiler_data     d,        plsql_profiler_units    u,        plsql_profiler_runs     rWHERE    r.run_comment     &#x3D; ‘Test2’AND      u.runid           &#x3D; r.runidAND      u.unit_owner      &#x3D; r.run_ownerAND      d.runid           &#x3D; r.runidAND      d.unit_number     &#x3D; u.unit_numberAND      s.name            &#x3D; u.unit_nameAND      s.line            &#x3D; d.line#ORDER BY d.line#; \n 1     .00 PROCEDURE sync_hr_data AS 3     .00 CURSOR    driver is 4   11.54 SELECT    * 5     .00 FROM      employees@hr_data;12     .00    OPEN driver;13    1.61    FETCH driver BULK COLLECT INTO recs;14     .01    CLOSE driver;16    1.15    FORALL i IN 1..recs.COUNT21     .00 END sync_hr_data;How It WorksThe procedure is updated from the previous recipe to use a BULK COLLECT statement to gather the datainto a collection. The update statement uses the FORALL command to pass the entire collection of data tothe Oracle engine for processing rather than updating one row at a time. BULK COLLECT and FORALL loopspass the entire dataset of the collections to the database engine for processing, unlike the loop in recipe13-2, where each iteration passes only one record at a time from the collection to the database. Theconstant switching back and forth between PL&#x2F;SQL and the database engine creates unnecessaryoverhead.Perform the following steps to collect statistics on the update procedure: \n\nRun the DBMS_PROFILER.START_PROFILER routine to begin the process ofcollecting statistics. You use the two parameters of the routine to give the run aname and to post a comment. Unique names are not required, but doing sowill make it easier to query the results later. \nRun the sync_hr_data program to collect statistics. \nRun the DBMS_PROFILER.FLUSH_DATA procedure to write the data collected to thetables. \nRun the DBMS_PROFILER.STOP_PROFILER routine to, as the name implies, stopthe collection of statistics.The query joins the profiler data, using the run name of Test2, with the source code lines to displayexecutable lines and the execution time, in hundredths of a second. The raw data stores time innanoseconds. The query results show three lines of code with actual execution time.Comparing these results with the previous recipe, we note a 28 percent improvement, 2.25 to 1.61,in fetching the records via the BULK COLLECT statement, and a 30 percent improvement, 1.64 to 1.15, inthe writing of the records via the FORALL statements. This improvement is realized while processing only  CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE287107 records. Greater gains can be realized with larger data sets, especially when selecting records via aremote database link as there are fewer context switches between PL&#x2F;SQL and the Oracle engine.13-4. Passing Large or Complex Collections as OUT ParametersProblemYou have a procedure or function that accepts one or more large or complex collections that are also OUTparameters, and you need a more efficient method to pass these variables.SolutionPass the parameters to your procedure or function by reference using the NOCOPY option on theprocedure or function declaration.\n\nCREATE OR REPLACE PACKAGE no_copy_test AS \n   TYPE rec_type IS TABLE OF all_objects%ROWTYPE INDEX BY BINARY_INTEGER;   PROCEDURE test; \nEND no_copy_test;&#x2F;show error \nCREATE OR REPLACE PACKAGE BODY no_copy_test AS \nPROCEDURE proc1 (rec_list IN OUT rec_type) ISBEGIN   FOR i IN 1..rec_list.COUNT LOOP      rec_list(i) :&#x3D; rec_list(i);   END LOOP;END; \nPROCEDURE proc2 (rec_list IN OUT NOCOPY  rec_type) ISBEGIN   FOR i IN 1..rec_list.COUNT LOOP      rec_list(i) :&#x3D; rec_list(i);   END LOOP;END; \nPROCEDURE test IS \nCURSOR  driver ISSELECT  *FROM    all_objects; \nrecs        rec_type;rec_count   integer; \nBEGINCHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE288 \n   OPEN driver;   FETCH DRIVER BULK COLLECT INTO recs;   CLOSE driver; \n   rec_count :&#x3D; recs.COUNT; \n   DBMS_OUTPUT.PUT_LINE (systimestamp);   proc1 (recs); – parameter passed by value   DBMS_OUTPUT.PUT_LINE (systimestamp);   proc2 (recs); – paramter passed by reference   DBMS_OUTPUT.PUT_LINE (systimestamp);END test; \nEND no_copy_test; \nset serverout on  – Enable output from DBMS_OUTPUT statementsEXEC no_copy_test.test; \nRunning the procedure produced the following output: \n03-NOV-10 05.05.14.865000000 PM -05:0003-NOV-10 05.05.14.880000000 PM -05:0003-NOV-10 05.05.14.880000000 PM -05:00How It WorksThe recipe utilizes the NOCOPY feature within PL&#x2F;SQL. It begins by defining two procedures within the testpackage. The first procedure, PROC1, accepts a collection of records using the default parameter-passingmethod, which is by VALUE. The second procedure, PROC2, is an exact copy of PROC1; however, itsparameter is passed using the NOCOPY option. In PROC1, the parameter is passed in by VALUE, which meansa copy of the entire collection is created in the REC_LIST variable within PROC1. In PROC2, the parameterdata is passed by REFERENCE. Passing a parameter by reference does not copy the data; rather, it uses theexisting data structure passed to it by the calling program. This method is more efficient for very largecollections in both running time and in memory usage.The output from the test shows the first procedure, which passed its parameter by VALUE took longerto run than the second procedure, which passed its parameter by REFERENCE. In this example, theUSER_OBJECTS table was used as the data for the parameter, which retrieved only 6,570 records. Largerperformance gains can be realized with more records and more complex data structures.13-5. Optimizing Computationally Intensive CodeProblemYou have computationally intensive code that you want to optimize to decrease its running time.SolutionRecompile the package, procedure, or function in native mode using the NATIVE setting: \n  CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE289ALTER PACKAGE my_package COMPILE BODY PLSQL_CODE_TYPE&#x3D;NATIVE REUSE SETTINGS;ALTER PROCEDURE my_procedure COMPILE PLSQL_CODE_TYPE&#x3D;NATIVE REUSE SETTINGS;ALTER FUNCTION my_function COMPILE PLSQL_CODE_TYPE&#x3D;NATIVE REUSE SETTINGS; \nHere is an example of a computationally intensive procedure. It uses the factorial function fromRecipe 17-4. \nCREATE OR REPLACE PROCEDURE factorial_test as \nfact    NUMBER; \nBEGIN \n   FOR i IN 1..100 LOOP      fact :&#x3D; factorial(33);   END LOOP; \nEND factorial_test; \n  – enable display of execution timeSET TIMING ON \n  – run the testEXEC factorial_test \nPL&#x2F;SQL procedure successfully completed.Elapsed: 00:00:01.18 \nNow, recompile the code using the NATIVE option and rerun the test, noting any change in runningtime: \nALTER PROCEDURE factorial_test COMPILE PLSQL_CODE_TYPE&#x3D;NATIVE REUSE SETTINGS; \nEXEC factorial_test \nPL&#x2F;SQL procedure successfully completed.Elapsed: 00:00:00.42How It WorksThe ALTER. . .COMPILE command invokes the compiler on the named object. The syntax differs slightlywhen recompiling a PACKAGE body in that the BODY clause follows the COMPILE statement. ThePLSQL_CODE_TYPE&#x3D;NATIVE clause compiles the code in NATIVE format, which runs faster than interpretedcode. The REUSE SETTINGS clause ensures the code will be recompiled in the same mode if it laterbecomes invalid and requires automatic recompilation.Native mode realizes the most benefit from computational intensive code; it has little effect on DMLstatements (in other words, SELECT, INSERT, UPDATE, and DELETE). In the previous example, the factorialfunction is called repeatedly to simulate a computationally intensive procedure. When the procedure iscompiled in the default, interpretive method, it completes its run in 1.18 seconds. When compiled inNATIVE mode, it completes in 0.42 seconds. This is a 64 percent improvement in running time!CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE29013-6. Improving Initial Execution Running TimeProblemYou have a procedure that you run frequently, and you want to improve its overall running time byminimizing its startup time.SolutionUse the DBMS_SHAPRED_POOL.KEEP procedure to keep a permanent copy of your code in the sharedmemory pool. For example, the following statement pins the procedure my_large_procedure in thedatabase’s shared memory pool:DBMS_SHARED_POOL.KEEP (   Name &#x3D;&gt; ‘my_large_procedure’,   flag &#x3D;&gt; ‘P’);How It WorksThe DBMS_SHARED_POOL.KEEP procedure permanently keeps your code in the shared memory pool. Bydefault, when PL&#x2F;SQL code is executed, Oracle must first read the entire block of code into memory if itisn’t already there from a previous execution. As additional procedures are executed, less recently usedcode in the shared memory pool begins to age. If there isn’t sufficient free space in the shared memorypool, older code is removed to make room.If large procedures are run frequently and are aging out of the shared memory pool, then pinningthe procedure in the shared memory pool can improve performance by removing the overheadnecessary to reload the procedure again and again.The first parameter of the DBMS_SHARED_POOL.KEEP procedure is the name of the object you want topin in the shared memory pool. The second parameter identifies the object type of the first parameter.The most commonly used values for FLAG are as follows:•P: The default, which specifies the object is a package, procedure, or function•T: Specifies the object is a trigger•Q: Specifies the object is a sequenceYou must have execute privileges on the DBMS_SHARED_POOL package to pin your code. An account withSYSDBA privileges must grant execute on DBMS_SHARED_POOL to your schema or to public.C H A P T E R  14 \n   \n291Using PL&#x2F;SQL on the WebOracle’s Application Server provides a powerful gateway that exposes your PL&#x2F;SQL procedures to webbrowsers. The gateway is defined using a Data Access Descriptor (DAD) that runs PL&#x2F;SQL code as eitherthe user defined in the DAD or as the user running the web application.Oracle provides a PL&#x2F;SQL Web Toolkit, which is a set of procedures and functions that generateHTML tags. In addition to making your code easier to read and manage, the toolkit sends the HTMLcode through Apache directly to the client web browser.The following recipes teach you how to write PL&#x2F;SQL procedures that produce interactive webpages. These recipes can be combined to create solutions for complex business applications.14-1. Running a PL&#x2F;SQL Procedure on the WebProblemYou’d like to make your PL&#x2F;SQL procedures accessible to users in a web browser via the OracleApplication Server.SolutionTo run a PL&#x2F;SQL procedure on the Web, you must first configure a Data Access Descriptor (DAD) withinthe Oracle Application Server to define the connection information required between mod_plsql withinthe Oracle Application Server and the Oracle database that holds the PL&#x2F;SQL procedures you wish torun. In this example the mod_plsql configuration file dads.conf (located in [Oracle_Home]\\Apache\\modplsql\\conf) is edited to define the DAD. \n&lt;Location &#x2F;DAD_NAME&gt;    SetHandler pls_handler    Order deny,allow    Deny from all    Allow from localhost node1.mycompany.com node2.mycompany.com    AllowOverride None \nPlsqlDatabaseUsername ORACLE_SCHEMA_NAME \nPlsqlDatabasePassword PASSWORD \nPlsqlDatabaseConnectString TNS_ENTRY \nPlsqlSessionStateManagement StatelessWithResetPackageState \nPlsqlMaxRequestsPerSession 1000 \nPlsqlFetchBufferSize 128 \nPlsqlCGIEnvironmentList QUERY_STRING \nPlsqlErrorStyle DebugStyle \n\nCHAPTER 14  USING PL&#x2F;SQL ON THE WEB292 \nYou may repeat the  data for additional DADs as required; perhaps one DAD for everymajor application. You must restart the Oracle Application Server for changes to the DAD configurationfile to take effect.How It WorksTo verify that your DAD is configured properly and will run your PL&#x2F;SQL code, log into the Oracledatabase defined in your DAD. The Oracle database account is defined in the PlsqlDatabaseUsername,PlsqlDatabasePassword and PlsqlDatabaseConnectString statements. Next, compile the following testprocedure. \ncreate or replace procedure test asbegin   htp.p (‘Hello World!’);end; \nFinally, point your web browser to http://node_name/DAD_NAME/test. Where node_name is thename of the machine where the Oracle Application Server is installed and DAD_NAME is the name assignedyour DAD in the  tag within the mod_plsql configuration file and test is the name of thePL&#x2F;SQL procedure create for this test. Your browser should respond with the text “Hello World!”The  tag within the dads.conf file defines the equivalent of a virtual directory withinApache. When a request reaches the Oracle iAS Apache web server containing the location name definedin the DAD, the PL&#x2F;SQL package or procedure specified in the remaining portion of the URL is executed.For example, if the URL is http://node.my_company.com/plsqlcgi/employee.rpt, plsqlcgi is theDAD_NAME, then employee is the package name and rpt is the procedure name. Calls to the PLSQL WebToolkit within the employee.rpt procedure send output directly to the client’s web browser.The SetHandler directive invokes mod_plsql within Apache to handle requests for the virtual pathdefined by the  tag. This directive is required to run PL&#x2F;SQL packages and proceduresthrough the Apache web server.The next three directives restrict access to the virtual path to the nodes specified on the Allow fromline. To allow access from any web browser in the world, replace these three directives with the followingtwo.• Order allow,deny• Allow from allThe PlsqlDatabase directives define the connection information mod_plsql needs to log into thedatabase. If the PlsqlDatabasePassword directive is supplied, Apache will automatically log into thedatabase when requests from web clients are processed. The TNS_ENTRY is used to complete the logininformation. If the PlsqlDatabasePassword directive is omitted, the Web browser prompts the user for ausername and password. The username entered by the user must exist in the database specified by theTNS_ENTRY name and the user must have execute privileges to the requested procedure. The proceduremust be accessible to the ORACLE_SCHEMA_NAME specified in PlsqlDatabaseUsername. In other words, theschema must own the procedure or, if owned by another schema, it must have execute privileges to theprocedure.  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB29314-2. Creating a Common Set of HTML Page Generation ProceduresProblemEvery web page you generate with a PL&#x2F;SQL procedure requires a common HTML tag to start andanother to finish every web page, and you do not wish to repeat the code to add those tags in everyprocedure you write for the Web.SolutionCreate a package that contains calls to the PL&#x2F;SQL Web Toolkit procedures that produce the HTML codenecessary to properly display a well-formed,1 HTML web page. In this example a package is created withtwo procedures, one to generate the HTML tags required to start a page and one to generate the closingHTML tags to finish a page. \nCREATE OR REPLACE PACKAGE common AS \n   PROCEDURE header (title VARCHAR2);   PROCEDURE footer; \nEND common; \nCREATE OR REPLACE PACKAGE BODY common AS \nPROCEDURE header (title VARCHAR2) IS \nBEGIN \n   htp.p (‘‘);   htp.htmlOpen;   htp.headOpen;   htp.meta (‘Content-Type’, null, ‘text&#x2F;html;’ ||              owa_util.get_cgi_env(‘REQUEST_IANA_CHARSET’) );   htp.meta (‘Pragma’, null, ‘no-cache’);   htp.Title (title);   htp.headClose;   htp.bodyOpen;   htp.header (2, title); \nEND HEADER; \nPROCEDURE footer IS \nBEGIN \n1 A well-formed HTML web page conforms to the standards defined by The World Wide Web Consortium(W3C). You can validate your HTML web pages at http://validator.w3.org/.CHAPTER 14  USING PL&#x2F;SQL ON THE WEB294– This is a great place to add legal disclaimers, about us, contact us, etc. links   htp.hr;  – horizontal line   htp.anchor (‘http://www.mynode.com/legal_statement.html&#39;, ‘Disclaimer’);   htp.anchor (‘http://www.mynode.com/About.html&#39;, ‘About Us’);   htp.bodyClose;   htp.htmlClose; \nEND footer; \nEND common;How It WorksRecipe 14-1 includes a test procedure to verify the DAD is setup correctly; however the test proceduredoes not produce a well-formed HTML page. Here is the updated example from Recipe 14-1, this timewith calls to the common header and footer procedures. \ncreate or replace procedure test asbegin   common.header (‘Test Page’);   htp.p (‘Hello World!’);   common.footer;end; \nThis procedure, when called from a web browser, produces the following HTML code. \n \n \n \n \nTest Page \n \nTest Page \nHello World! \n \n \n \nThe header routine generates the necessary opening HTML code to properly display a web page. Itbegins by setting the document type, then sending the opening  and  tags. It sets thecontent-type to the character set defined in the Apache environment variable, which is retrieved using acall to the PL&#x2F;SQL Web Toolkit’s owa_util.get_cgi_env routine. The Pragma  tag tells the browsernot to store the page’s content in its internal cache. This is useful when the PL&#x2F;SQL routine returns time-sensitive data because the users need to see real-time data. The remaining code sets the title in the user’sbrowser, opens the  tag and displays the title on the user’s web browser.The footer routine closes the  and  tags. As stated in the code’s comments, this is agood place to include any legal disclaimers or other useful text or links required for every web pagegenerated.Oftentimes when creating an application, you will create several procedures that will make use ofthe same code. You could copy the code throughout your procedures, but it is more efficient and safer to  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB295write once and use in many different places. The creation of a common codebase that is accessible toeach PL&#x2F;SQL object within a schema can be quite an effective solution for storing such code.14-3 Creating an Input FormProblemYou require a web page that accepts and processes data entered by users. The data should be collectedon the opening page and processed (stored in a table, used to update rows in a table, etc.) when the userclicks the Submit button.SolutionCreate a package using the Oracle PL&#x2F;SQL Web Toolkit to display a data entry form and process theresults. In this example a simple data entry form is created to collect employee information and send theuser’s input to a second procedure for processing.■ Note See Recipe 14-2 for more information on the common package, which is used in this recipe.CREATE OR REPLACE PACKAGE input_form AS \n   null_array OWA_UTIL.IDENT_ARR; \n   PROCEDURE html;   PROCEDURE submit (emp_id     VARCHAR2,                     gender     VARCHAR2 DEFAULT NULL,                     options    OWA_UTIL.IDENT_ARR DEFAULT null_array,                     comments   varchar2); \nEND input_form; \nCREATE OR REPLACE PACKAGE BODY input_form AS \nPROCEDURE html IS \ntype    options_type is varray(3) of varchar2(50);options options_type :&#x3D; options_type (‘I will attend the Team Meeting’,                        ‘I will attend the social event’,                        ‘I will attend the company tour’); \nBEGIN \n   common.header (‘Input Form’);   htp.formOpen (‘input_form.submit’, ‘POST’); \n   htp.p (‘Employee ID: ‘);CHAPTER 14  USING PL&#x2F;SQL ON THE WEB296   htp.formText (‘emp_id’, 9, 9);   htp.br; \n   htp.p (‘Gender: ‘);   htp.formRadio (‘gender’, ‘M’);   htp.p (‘Male’);   htp.formRadio (‘gender’, ‘F’);   htp.p (‘Female’);   htp.br; \n   FOR i IN 1..10 LOOP      htp.formCheckBox (‘options’, i);      htp.p (options(i));      htp.br;   END LOOP;   htp.br; \n   htp.p (‘COMMENTS: ‘);   htp.formTextArea (‘comments’, 5, 50);   htp.br; \n   htp.formSubmit;   htp.formClose;   common.footer; \nEND html; \nPROCEDURE submit (emp_id     VARCHAR2,                  gender     VARCHAR2 DEFAULT NULL,                  options    OWA_UTIL.IDENT_ARR DEFAULT null_array,                  comments   varchar2) is \nBEGIN \n   common.header (‘Input Results’);   htp.bold (‘You entered the following…’);   htp.br; \n   htp.p (‘Employee ID: ‘ || emp_id);   htp.br;   htp.p (‘Gender: ‘ || gender);   htp.br;   htp.p (‘Comments: ‘ || comments);   htp.br; \n   htp.bold (‘Options Selected…’);   htp.br;   FOR i IN 1..options.COUNT LOOP      htp.p (options(i));      htp.br;   END LOOP; \n  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB297   common.footer; \nEND submit; \nEND input_form;How It WorksAccess the web page using a link with an HTML anchor URL of http://node.mycompany.com/DAD_NAME/input_form.html.■ Note See Recipe 14-1 to define the DAD_NAME.The input_form package specification defines an empty collection named null_array as the typeOWA_UTIL.IDENT_ARR. It is used as the default value in the event the web form is submitted withoutchecking at least one of the check boxes. Without the default value for the input parameter options, thecall to input_form.submit will not work and returns an error to the user if no boxes are checked.■ Note See Recipe 14-9 for more information on viewing errors.The two procedures, html and submit, exposed in the package specification, are required to makethem visible to the PL&#x2F;SQL module within the Apache web server. It is important to note that it is notpossible to call procedures via a URL if they are not defined in the package specification.The html procedure generates the data entry form shown in Figure 14-1. It begins with a call toheader common procedure, which generates the opening HTML tags. The htp.formOpen call generatesthe  tag with the destination of the submit button to the submit procedure within the input_formpackage.The htp.p procedure call sends the data passed to it directly to the client’s web browser, thisprocedure should not be confused with the htp.para, which produces the  tag. The htp.br call sendsthe  tag to the client’s web browser.The remainder of the procedure generates several form elements that accept user input. Thehtp.formText call generates a simple text box that accepts nine bytes. The htp.formRadio routine is calledtwice with the same variable name in the first parameter. This defines the variable gender with one oftwo possible values, M or F. The call to htp.formCheckBox within the FOR…LOOP generates the checkboxes,each having a unique value returned if checked by the user. Only the values checked are sent in acollection to the submit routine. The call to htp.formTextArea creates a multi-line, text box 50 characterswide and 5 lines deep. See Table 14-1 for a list of common PL&#x2F;SQL Web Toolkit procedures that generateHTML form tags.The procedure ends with a calls to htp.formSubmit and htp.formClose, which generate the form’ssubmit button and the closing  tag. When the user clicks the submit button, the client’s webbrowser sends the data entered into the form to the submit routine within the input_form package. \nCHAPTER 14  USING PL&#x2F;SQL ON THE WEB298 \nFigure 14-1. Form generated by the input_form.html procedureTable 14-1. Common form procedures in the PL&#x2F;SQL Web ToolkitToolkit Procedure HTML Taghtp.formCheckbox htp.formClose htp.formHidden htp.formImage htp.formOpen htp.formPassword htp.formRadio htp.formReset htp.formSelectClose htp.formSelectOpen htp.formSelectOption htp.formSubmit   CHAPTER 14  USING PL&#x2F;SQL ON THE WEB299Toolkit Procedure  HTML Taghtp.formText htp.formTextarea htp.formTextareaClose htp.formTextareaOpen 14-4. Creating a Web–based Report Using PL&#x2F;SQL ProceduresProblemYou need to generate a web page report that displays the results of a database query.SolutionCreate a package with two procedures, one to accept a user’s input, and another to query the databaseand display the results. Suppose, for example, that you need a report that displays information for anemployee whose employee ID has been entered by an authorized user. This recipe uses the employeetable in the HR schema.■ Note When defining packages that contain procedures you wish to access via web browsers, you must includeeach procedure you wish to access in the package specification.  \n■ Note See Recipe 14-2 for more information on the common package, which is used in this recipe.CREATE OR REPLACE PACKAGE emp_rpt AS \n   PROCEDURE html;   PROCEDURE rpt (emp_id VARCHAR2); \nEND emp_rpt; \nCREATE OR REPLACE PACKAGE BODY emp_rpt AS \nPROCEDURE html IS \nBEGIN \nCHAPTER 14  USING PL&#x2F;SQL ON THE WEB300   common.header (‘Employee Report’);   htp.formOpen (‘emp_rpt.rpt’, ‘POST’);   htp.p (‘Employee ID:’);   htp.formText (‘emp_id’, 6, 6);   htp.formSubmit;   htp.formClose;   common.footer;  – See recipe 14-2 for the common package.END html;PROCEDURE show_row (label VARCHAR2, value VARCHAR2) ISBEGIN   htp.tableRowOpen (‘LEFT’, ‘TOP’);   htp.tableHeader (label, ‘RIGHT’);   htp.tableData (value);   htp.tableRowClose;END show_row;PROCEDURE rpt (emp_id VARCHAR2) ISCURSOR  driver ISSELECT  *FROM    employeesWHERE   employee_id &#x3D; emp_id;rec             driver%ROWTYPE;rec_found       BOOLEAN;BEGIN   common.header (‘Employee Report’); \n   OPEN driver;   FETCH driver INTO rec;   rec_found :&#x3D; driver%FOUND;   CLOSE driver;   IF rec_found THEN      htp.tableOpen;      show_row (‘Employee ID’, rec.employee_id);      show_row (‘First Name’, rec.first_name);      show_row (‘Last Name’, rec.last_name);      show_row (‘Email’, rec.email);      show_row (‘Phone’, rec.phone_number);      show_row (‘Hire Date’, rec.hire_date);      show_row (‘Salary’, rec.salary);      show_row (‘Commission %’, rec.commission_pct);      htp.tableClose;  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB301   ELSE      htp.header (3, ‘No such employee ID ‘ || emp_id);   END IF; \n   common.footer; – See recipe 14-2 for the common package. \nEXCEPTION   WHEN OTHERS THEN   htp.header (3, ‘Invalid employee ID. Click your browser’’s back button and try again.’);   common.footer; \nEND rpt; \nEND emp_rpt;How It WorksUsers access the web page using the URL http://node.mycompany.com/DAD_NAME/emp_rpt.html.■ Note See Recipe 14-1 for more on how to define the DAD_NAME.The package specification is defined with two procedures, html and rpt. Exposing these proceduresin the specification is required to make the PL&#x2F;SQL procedures available within Apache.Next, the package body is defined. The html procedure generates the data entry form. It generatesthe opening HTML code by calling the common.header routine defined in recipe 14-2. Next, it calls thehtp.formOpen to set the form’s action, which is to run the PL&#x2F;SQL procedure emp_rpt.rpt, when the userclicks the submit button and to send the form data in a POST method, as opposed to GET. A simpleprompt and a text box follows to allow the user to enter an employee ID. A call to form.submit,form.close and common.footer complete the HTML code.The show_row procedure is a handy subroutine to output one table row with two data cells. Itdisplays data on the client’s browser in a formatted table, making it more visually appealing.The rpt procedure accepts the user’s input in the emp_id parameter and uses it to query theemployee record. The common.header routine generates the opening HTML code. The cursor is openedand the data is fetched into the rec data structure. The rec_found variable stores the flag that identifies ifa record was fetched. It needs to be referenced after the fetch and before the close. If a record is found,the employee data is displayed in a two-column table, shown in Figure 14-2, otherwise a message is sentto the user that the employee ID is not valid.The exception is necessary to trap the error generated if the user enters a non-numeric employeeID. Another option is to validate the user’s input prior to using it in the cursor query.■ Note See recipe 14-10 for an example of validating user input.CHAPTER 14  USING PL&#x2F;SQL ON THE WEB302 \nFigure 14-2. Results from entering employee ID 200 on the previous data entry screen14-5. Displaying Data from TablesProblemYou wish to provide the results from an SQL SELECT statement to the users via a web browser.SolutionUse the Oracle PL&#x2F;SQL Web Toolkit to SELECT and display data. The owa_util.tablePrint procedureaccepts any table name for the ctable parameter. When this procedure is compiled in a schema with aDAD it can be accessed via the Web. This example displays information similar to the describe featurewithin SQL*Plus.■ Note See Recipe 14-1 to define a DAD and direct your browser to run your procedure.  \n■ Note See Recipe 14-2 for more information on the common package, which is used in this recipe.CREATE OR REPLACE PROCEDURE descr_emp IS \nBEGIN \n   common.header (‘The Employees Table’); \n   IF owa_util.tablePrint (             ctable&#x3D;&gt;’user_tab_columns’,        cattributes&#x3D;&gt;’BORDER’,  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB303           ccolumns&#x3D;&gt;’column_name, data_type, data_length, data_precision, nullable’,           cclauses&#x3D;&gt;’WHERE table_name&#x3D;’’EMPLOYEES’’ ORDER BY column_id’) then      NULL;   END IF; \n   common.footer; \nEND descr_emp;How It WorksUsers access the web page using the URL http://node.mycompany.com/DAD_NAME/emp_rpt.html. Thedescr_emp procedure calls the owa_util.tablePrint procedure, which is included in the PL&#x2F;SQL WebToolkit. The ctable parameter defines the table the owa_util.tablePrint procedure accesses to read thedata. The cattribributes parameter accepts options for the HTML  tag. The ccolumns parameterallows you to specify which columns to select from the named table. If no columns are specified, thenthe procedure shows all columns. The cclauses parameter allows you to add a where clause and&#x2F;or anorder by statement. If no where clause is specified, all rows are returned. The output is shown in Figure14-3. \nFigure 14-3. Results of the descr_emp procedure14-6. Creating a Web Form Dropdown List from a Database QueryProblemYour web form requires a dropdown list whose elements are drawn from a database table.CHAPTER 14  USING PL&#x2F;SQL ON THE WEB304SolutionUse the htp.formSelectOpen, htp.formSelectOption and htp.formSelectClose procedures in the PL&#x2F;SQLWeb Toolkit to generate the required HTML tags. For example, suppose you need to use the HR schemato create a dropdown list of job titles from the JOBS table. Here’s how you’d do it. \ncreate or replace procedure job_list as \ncursor  driver isselect  job_id, job_titlefrom    jobsorder by job_title; \nbegin \n   common.header (‘Job Title’);   htp.formSelectOpen (‘id’, ‘Job Title: ‘);   htp.formSelectOption (‘’, ‘SELECTED’); \n   for rec in driver LOOP      htp.formSelectOption (rec.job_title, cattributes&#x3D;&gt;’VALUE&#x3D;”‘ || rec.job_id || ‘“‘);   end LOOP; \n   htp.formSelectClose;   common.footer; \nend job_list; \nThis procedure produces the following web page. \nFigure 14-4. Dropdown list created by job_list procedure  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB305How It WorksThe htp.formSelectOpen procedure generates the HTML , which defines thedropdown list in the web browser. In addition the procedure uses the second parameter as the promptfor the dropdown list. In this example the prompt is Job Title:.The call to htp.formSelectOption procedure defines the elements of the dropdown list. The firstparameter is the text displayed in the list and the second parameter preselects the element in the listwhen it is first displayed. In this example the first call to the htp.formSelectOption procedure defines thedefault selected element in the list to an empty value.The subsequent calls to htp.formSelectOption that appear in the cursor for loop define theremaining elements in the dropdown list using the data selected from the JOBS table. The cattributesparameter is used to change the default value returned by the web browser when the element is selectedfrom the list.The call to htp.formSelectClose generates the  HTML tag to close the dropdown list.Dropdown lists usually appear within the  tags to accept user input and process that input on asubsequent page.■ Note See Recipe 14-3 for more information on creating an input form.14-7. Creating a Sortable Web ReportProblemYou need a report that displays data that is sorted by a field the user selects.SolutionCreate a package that prompts the user for a sort field, then generates the sorted output using the sortfield parameter in the ORDER BY section of the SELECT statement. In this example the user is prompted toselect a sort option on the EMPLOYEEs table. The options are to sort by last name, hire date, salary, oremployee ID.■ Note See Recipe 14-1 to define a DAD and direct your browser to run your procedure.  \n■ Note See Recipe 14-2 for more information on the common package, which is used in this recipe.CREATE OR REPLACE PACKAGE sorted AS \n   PROCEDURE html;CHAPTER 14  USING PL&#x2F;SQL ON THE WEB306   PROCEDURE rpt (sort_order VARCHAR2); \nEND sorted; \nCREATE OR REPLACE PACKAGE BODY sorted AS \nPROCEDURE html IS \nBEGIN \n   common.header (‘Sorted Report’);   htp.formOpen (‘sorted.rpt’, ‘POST’);   htp.formSelectOpen (‘sort_order’, ‘Select a Sort Order: ‘);   htp.formSelectOption (‘Last Name’);   htp.formSelectOption (‘Hire Date’);   htp.formSelectOption (‘Salary’);   htp.formSelectOption (‘Employee ID’);   htp.formSelectClose;   htp.formSubmit;   htp.formClose;   common.footer;END html; \nPROCEDURE rpt (sort_order VARCHAR2) IS \nCURSOR  driver ISSELECT  *FROM    employeesORDER BY DECODE (sort_order,                ‘Last Name’,   last_name,                ‘Hire Date’,   TO_CHAR (hire_date, ‘YYYYMMDD’),                ‘Salary’,      TO_CHAR (salary, ‘00000’),                ‘Employee ID’, TO_CHAR (employee_id, ‘00000’) ); \nBEGIN \n   common.header (‘Sorted Report by ‘||sort_order); – See recipe 14-2.   htp.tableOpen (‘BORDER’);   htp.tableRowOpen (‘LEFT’, ‘BOTTOM’);   htp.tableHeader (‘Name’);   htp.tableHeader (‘Hired’);   htp.tableHeader (‘Salary’);   htp.tableHeader (‘ID’);   htp.tableRowClose; \n   FOR rec IN driver LOOP      htp.tableRowOpen (‘LEFT’, ‘TOP’);      htp.tableData (rec.last_name);      htp.tableData (rec.hire_date);      htp.tableData (rec.salary);      htp.tableData (rec.employee_id);      htp.tableRowClose;  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB307   END LOOP; \n   htp.tableClose;   common.footer; \nEND rpt; \nEND sorted;How It WorksUsers access the web page using the URL http://node.mycompany.com/DAD_NAME/sorted.html.■ Note See Recipe 14-1 for more on how to to define the DAD_NAME.The package specification is defined by exposing two procedures, html and rpt. You must definethese procedures in the specification to make the PL&#x2F;SQL procedures available within Apache.Next, the package body is defined. The html procedure generates the data entry form. It generatesthe opening HTML code by calling the common.header routine defined in Recipe 14-2. Next, it calls thehtp.formOpen to set the form’s action when the user clicks the Submit button. The calls tohtp.formSelectOpen, htp.formSelectOption and htp.formSelectClose procedures create the dropdownlist for the user to select a sort order.■ Note See Recipe 14-6 for more information on how to create dropdown lists.A call to form.submit, form.close and common.footer complete the necessary HTML code. The formgenerated is shown in Figure 14-5.The rpt procedure accepts the sort_order parameter, which is used in the cursor to dynamicallydetermine the sort order on the EMPLOYEES table. The order by option in the select statement uses thedecode function to return the proper string needed for ordering based on the user’s input.The first set of parameters sent to the decode function, namely the first_name field, defines the datatype returned by the decode function. This is important to note as the remaining data types returnedfrom the decode function will be converted to strings to match the first_name. It is necessary to convertthe numeric and date fields to strings that sort properly. For example, if the default date string format isdd-Mon-yy, then the hire dates will sort by the day of the month first, then by the month’s abbreviationand year. The desired sort order is year, month, then day. \nCHAPTER 14  USING PL&#x2F;SQL ON THE WEB308 \nFigure 14-5. Initial data entry screen showing the sort options14-8. Passing Data Between Web PagesProblemYou have a multi-page data entry form in which the final page requires data entered on pages thatprecede it. You need to pass the data gathered on previous pages to the current page.SolutionPass the name&#x2F;value pairs from previous pages using the htp.formHidden procedure in the PL&#x2F;SQL WebToolkit. In this recipe each parameter is passed to the next form using hidden HTML elements. \nCREATE OR REPLACE PACKAGE multi AS \n   PROCEDURE page1;   PROCEDURE page2 (var1 varchar2);   PROCEDURE page3 (var1 varchar2, var2 varchar2);   PROCEDURE process (var1 varchar2, var2 varchar2, var3 varchar2); \nEND multi; \nCREATE OR REPLACE PACKAGE BODY multi AS \nPROCEDURE page1 IS \nbegin \n   htp.formOpen (‘multi.page2’, ‘POST’);   htp.p (‘Enter First Value:’);   htp.formText (‘var1’, 10, 10);   htp.formSubmit;   htp.formClose; \nEND page1; \nPROCEDURE page2 (var1 VARCHAR2) IS \n  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB309begin \n   htp.formOpen (‘multi.page3’, ‘POST’);   htp.formHidden (‘var1’, var1);   htp.p (‘Enter Second Value:’);   htp.formText (‘var2’, 10, 10);   htp.formSubmit;   htp.formClose; \nEND page2; \nPROCEDURE page3 (var1 VARCHAR2, var2 VARCHAR2) IS \nbegin \n   htp.formOpen (‘multi.process’, ‘POST’);   htp.formHidden (‘var1’, var1);   htp.formHidden (‘var2’, var2);   htp.p (‘Enter Third Value:’);   htp.formText (‘var3’, 10, 10);   htp.formSubmit;   htp.formClose; \nEND page3; \nPROCEDURE process (var1 varchar2, var2 varchar2, var3 varchar2) is \nBEGIN \n  htp.p (‘The three variables entered are…’);  htp.br; \n  htp.p (‘1&#x3D;’ || var1);  htp.br;  htp.p (‘2&#x3D;’ || var2);  htp.br;  htp.p (‘3&#x3D;’ || var3); \nEND process; \nEND multi;How It WorksUsers access the web page using the URL http://node.mycompany.com/DAD_NAME/multi.page1.■ Note See Recipe 14.1 to define the DAD_NAME.CHAPTER 14  USING PL&#x2F;SQL ON THE WEB310The page1 procedure within the mulit package prompts the user for an input value, which is passedto procedure page2 as its parameter, var1. The htp.formHidden call in the page2 procedure produces anHTML  tag of type HIDDEN. In this recipe it produces the following HTML code in the client’s webbrowser: , where xxx is the text the user entered on thefirst page of this multi-part form.The page2 procedure then accepts more user input into the form variable var2, which is passed topage3 along with var1 collected on the first input page. The third page accepts the final user input andpasses it to the process procedure, where final processing occurs.14-9. Viewing Errors for Debugging Web AppsProblemYou have a PL&#x2F;SQL package or procedure called from a web client that generates errors and you need toview the error message.SolutionChoose one of the following two solutions, depending on your circumstances.Solution #1If the package is in use in a production environment, then check the output of the Apache error log file.The log file location is defined in the httpd.conf configuration file. The default log file location is[oracle_home]\\Apache\\Apache\\logs directory. Open the log file and search for the errors generated witha timestamp that corresponds to the approximate time the error was generated.Solution #2If the application is in development or running in a non-production environment, change the defaulterror style within the DAD used to produce the web page that failed. The error style is defined in theDADS.CONF file located in [oracle_homme]\\Apache\\modplsql\\conf. Set the PlsqlErrorStyle to DebugStyle.■ Note See recipe 14-1 for more information on defining DADs.How It WorksSolution #1The PL&#x2F;SQL module within Apache logs all errors, complete with timestamps. New errors are written tothe end of the error log. This solution is recommended for production environments where the displayof Apache environment variables may pose security issues.  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB311Here’s an example of an error message written to the error log. In this example, a procedure wascalled from the Web but was missing required parameters. \n[error] [client 127.0.0.1] mod_plsql: &#x2F;DAD_NAME&#x2F;class_sched.list HTTP-404 \nclass_sched.list: SIGNATURE (parameter names) MISMATCHVARIABLES IN FORM NOT IN PROCEDURE:NON-DEFAULT VARIABLES IN PROCEDURE NOT IN FORM: THIS_ID, THIS_ID_TYPESolution #2Setting the PlsqlErrorStyle to DebugStyle causes Apache to display all PL&#x2F;SQL error messages on theclient’s web browser when the PL&#x2F;SQL routine fails. It displays the same error messages normally foundin the Apache log file plus a list of all Apache environment variables and their values. This solution isrecommended for non-production environments where errors are more likely to occur duringdevelopment and testing. It has the advantage of immediate, onscreen feedback for developers andtesters. \nThe following is an example of an error message written to the web browser. \nclass_sched.list: SIGNATURE (parameter names) MISMATCHVARIABLES IN FORM NOT IN PROCEDURE:NON-DEFAULT VARIABLES IN PROCEDURE NOT IN FORM: THIS_ID, THIS_ID_TYPE \n  DAD name: default  PROCEDURE  : class_sched.list  URL        : http://node.mycomp.com/DAD_NAME/class_sched.list  PARAMETERS :  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; \n  ENVIRONMENT: PLSQL_GATEWAY=WebDb \nGATEWAY_IVERSION=3 \n    &lt;&lt; snip &gt;&gt; \n\n14-10. Generating JavaScript via PL&#x2F;SQLProblemYour procedure requires JavaScript but you do not have access to the Oracle application server to storethe script file to make it accessible from Apache.SolutionUse the Oracle PL&#x2F;SQLWeb Toolkit to output JavaScript within your PL&#x2F;SQL procedure. There are twosteps to define and enable a JavaScript within your PL&#x2F;SQL procedure.CHAPTER 14  USING PL&#x2F;SQL ON THE WEB312First, define the JavaScript source on the web page that requires access to yourJavaScript routine using the HTML tag .Define a PL/SQL procedure to match the name of the  tag’s source (SRC)property.In the following example the html procedure defines the  tag with the source set toempID.js and the js procedure generates the JavaScript code. \nCREATE OR REPLACE PACKAGE empID IS \n   PROCEDURE html;   PROCEdURE js; \nEND empID; \nCREATE OR REPLACE PACKAGE BODY empID IS \nPROCEDURE html is \nBEGIN \n   common.header ('Employee Report'); -- See recipe 14-2 for the common package.   htp.p ('‘); \n   htp.formOpen (‘emp_rpt.rpt’, ‘POST’); – See recipe 14-4 for the emp_rpt pacakge.   htp.p (‘Employee ID:’);   htp.formText (‘emp_id’, 6, 6, cattributes&#x3D;&gt;’onChange&#x3D;”validateNumber(this.value);”‘); \n   htp.formSubmit;   htp.formClose;   common.footer; – See recipe 14-2 for the common package. \nEND html; \nPROCEDURE js is \nBEGIN \n   htp.p (‘ \nfunction validateNumber (theNumber) { \n   if ( isNaN (theNumber) ) {      alert (“You must enter a number for the Employee ID”);      return false; } \n   return true; \n  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB313}’); \nEND js; \nEND empID;How It WorksBegin by creating the package specification for empID, which exposes the html and js procedures. Nextcreate the package body with two procedures, html and js.The html procedure generates the opening HTML code with a call to common.header. Next, theprocedure generates a  tag that identifies the location of the JavaScript to include in the user’sbrowser. The  tag of this form is one of the few HTML tags not predefined in the PL/SQL WebToolkit.The  tag takes advantage of the owa_util package, which is also part of the PL/SQL WebToolkit, to dynamically generate the web address of the JavaScript using the settings of the Apacheenvironment values. This method avoids your having to hard-code the URL of the script into theprocedure and allows it to run in any environment—development, integration, production, etc. The URLgenerated references the JavaScript package defined later in the package body.Next, the html procedure generates the  tag with emp_rpt.rpt as its target. When the userclicks the Submit button the form will call the PL/SQL procedure emp_rpt.rpt defined in Recipe 14-4. Itwill not call a procedure within the empID package.The htp.formText routine contains an extra parameter to include the JavaScript necessary to runwhen the user changes the value in the emp_id field. Nearly every procedure in the htp package includesthe cattributes parameter, which provides for any additional option needed within the tag that is notalready defined in the existing parameters. Figure 14-6 shows the data entry form with a non-numericemployee ID; in this example the letter “o” was used instead of a zero. JavaScript pops up the errormessage shown.The js procedure consists of a simple print statement that contains the entire contents of theJavaScript code. JavaScript allows either single or double quotes for character strings. Using doublequotes in the JavaScript code avoids conflicts with the single quote requirements of PL/SQL. \nFigure 14-6. Error message generated by JavaScript when a non-numeric employee ID is enteredCHAPTER 14  USING PL/SQL ON THE WEB31414-11. Generating XML OutputProblemYou need to provide XML data for PL/SQL or other consumers of data from your Oracle database.SolutionUse Oracle’s built-in DBMS_XMLGEN package to extract data from the database in standard XML format andthen output the data through the Apache web server. In this example a generic procedure builds andoutputs XML formatted data based on the SQL query statement passed to it. This procedure can be usedin any application that requires XML output extracted from database tables. \nCREATE OR REPLACE PROCEDURE gen_xml (sql_stmt VARCHAR2) IS \nstring          VARCHAR2(4000);ipos            INTEGER;offset          INTEGER;n               INTEGER := 1; \nqryctx          dbms_xmlgen.ctxhandle;result          CLOB; \nBEGIN \n   qryctx := dbms_xmlgen.newcontext (sql_stmt);   result := dbms_xmlgen.getxml (qryctx);   dbms_xmlgen.closecontext (qryctx); \n   owa_util.mime_header ('text/xml', true);   LOOP      EXIT WHEN result IS NULL;      ipos := dbms_lob.instr (result, CHR(10), 1, n);      EXIT WHEN ipos = 0; \n  string := dbms_lob.substr (result, ipos-offset, offset); \n  htp.p (string); \n\n  offset    := ipos + 1; \n  n         := n + 1; \n\n   END LOOP; \n   IF result IS NULL THEN      htp.p ('');      htp.p ('');   END IF; \nEND gen_xml;  CHAPTER 14  USING PL/SQL ON THE WEB315How It WorksThe newcontext procedure in the dbms_xmlgen package executes the query passed to it in the firstparameter. The getxml procedure returns the data in XML format. Each row of data from the selectstatement is enclosed in the XML tags . Each field in the row is enclosed by its attribute (field)name in the database. For example, the employee ID is enclosed in the XML tag .The owa_util.mime_header is called to output the proper string to the client’s browser, indicating thecontent of the web page is in standard XML format. At this point it is sufficient to simply output the XMLdata returned by the call to xmlgen with an htp.p statement. However, this approach works only if thelength in bytes of the XML data does not exceed the maximum allowed by the htp.p procedure, which is32k. The LOOP breaks apart the XML data into smaller segments at each line break, CHR(10), insuring nocall to htp.p exceeds the maximum length.The final IF statement returns an empty XML tag set if the result of the query returns no rows.Without the empty tag set your Ajax call will fail because the Ajax call to parse the data from the XMLstructure requires the  tags.Here is an example of the XML output produced from Recipe 14-12. Only the first two data rowsretrieved are displayed. \n \n  \n  101 \n  Kochhar \n  \n  \n  102 \n  De Haan \n  \n \n14-12. Creating an Input Form with AJAX \nProblem \nYou need a web application that can interactively retrieve data based on partial data entered by the user. \nThe data must be retrieved before the user clicks the Submit button to process the page. \nSolution \nUse JavaScript and Ajax to dynamically retrieve data as the user enters data into the web form. This \nrecipe uses the EMPLOYEES table in the HR schema. \nThe data entry screen is built with all managers in a single dropdown list, which includes a call to a \nJavaScript procedure that invokes Ajax to retrieve subordinate data. Once the user selects a manager, the \nemployee dropdown list populates with the manager’s subordinates. The subordinates’ dropdown list is \ndefined with an ID, which is required by JavaScript to access the list and load the manager’s \nsubordinates. \nThe package contains the procedure xml, which is required to produce the XML data required by the \nAjax call. The PL/SQL procedure ajax.xml is called by the web browser within the AjaxMgr.js procedure. \n \nCREATE OR REPLACE PACKAGE ajax ISCHAPTER 14  USING PL/SQL ON THE WEB316 \n   PROCEDURE html;   PROCEDURE xml (ID INTEGER); \nEND ajax; \nCREATE OR REPLACE PACKAGE BODY ajax IS \nPROCEDURE html is \nCURSOR  driver ISSELECT  employee_id, last_nameFROM    employeesWHERE   employee_id in(       SELECT  DISTINCT manager_id        FROM    employees)ORDER BY last_name; \nBEGIN \n   common.header ('Manager/Employee Example'); -- See recipe 14-2 for the common package.   htp.p ('‘); \n   htp.formOpen (‘#’, ‘POST’);   htp.p (‘Select a Manager:’);   htp.formSelectOpen (‘mgr’, cattributes&#x3D;&gt;’onChange&#x3D;”loadEmployees(this.value);”‘);   htp.formSelectOption (‘’, ‘SELECTED’); \n   FOR rec IN driver LOOP      htp.formSelectOption (rec.last_name, cattributes&#x3D;&gt;’VALUE&#x3D;”‘||rec.employee_id||’”‘);   END LOOP; \n   htp.formSelectClose;   htp.br; \n   htp.p (‘Select a Subordinate:’);   htp.formSelectOpen (‘emp’, cattributes&#x3D;&gt;’ID&#x3D;”emp_list”‘);   htp.formSelectClose;   htp.br; \n   htp.formSubmit;   htp.formClose;   common.footer; \nEND html; \nPROCEDURE xml (ID INTEGER) IS \nBEGIN  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB317 \n– see recipe 14-11 for more information on the gen_xml procedure.   gen_xml (‘SELECT employee_id, last_name ‘    ||           ‘FROM employees ‘                    ||           ‘WHERE manager_id &#x3D; ‘ || ID          ||           ‘ ORDER by 1’); \nEND xml; \nEND ajax;How It WorksThe recipe begins by defining the package specification with two packages, html and xml. The htmlpackage generates the HTML data entry form and the xml procedure generates the XML data required bythe call to Ajax.The html procedure generates the opening HTML code with a call to common.header. Next, theprocedure generates a  tag that identifies the location of the JavaScript to include in the user’sbrowser. The  tag of this form is one of the few HTML tags not pre-defined in the PL/SQL WebToolkit.The  tag takes advantage of the owa_util package, which is also part of the PL/SQL WebToolkit. It dynamically generates the web address of the JavaScript based on Apache environmentvalues. This method avoids hard-coding the URL into the procedure and allows it to run in anyenvironment—development, integration, production, etc.■ Note The JavaScript, AjaxMgr.js, is included in the media but not reproduced here.An HTML form is opened with two dropdown lists defined. The first list is populated with the namesof all managers from the employees table. The second dropdown list is intentionally left empty. It will bepopulated at runtime when the user selects a manager from the first dropdown list. Figure 14-7 showsthe initial data entry screen generated by the html procedure, prior to the user selecting a manager fromthe manager’s dropdown list.The manager’s dropdown list, mgr, is created using the htp.formSelectOpen procedure with anadditional parameter to define the JavaScript to execute when the selected item in the list changes. Achange to the manager’s dropdown list invokes the JavaScript procedure loadEmployees, which wasdefined earlier in the  tag.The employee’s dropdown list, emp, is also created using the htp.formSelectOpen procedure with anadditional parameter to define the ID name of the object in the Web browser’s DOM2. This ID is requiredby the JavaScript to dynamically rebuild the employee dropdown list if the value in the managerdropdown list changes. Figure 14-8 shows the data entry form after a Manager is selected by the user.Note the Subordinate list is now populated. \n2 A DOM (Document Object Model) “is a cross-platform and language-independent convention forrepresenting and interacting with objects in HTML, XHTML and XML documents.” – Wikipedia.CHAPTER 14  USING PL/SQL ON THE WEB318The xml procedure calls the gen_xml procedure, created in Recipe 14-11, to generate the datarequired to populate the employee dropdown list via the Ajax call. The gen_xml procedure is generic inthat it only requires the select statement need to produce the XML output. \nFigure 14-7. Manager dropdown list with empty subordinate dropdown list \nFigure 14-8. Subordinate list after being populated by AjaxC H A P T E R  15 \n   \n319Java in the Database \nJava plays an important role in the application development space today. It has become increasinglypopular over the years, because it is cross-platform, powerful, and easy to learn. Although Javadevelopment is not directly related to PL/SQL, it is important for a PL/SQL developer to learn a bit aboutJava since there are some major benefits to using it to perform database tasks. Integrating the twolanguages when you’re building Oracle Database applications is a seamless effort. Oracle Database 11gcontains JVM compatibility with Java 1.5, which includes substantial changes to the Java language,making it an even more complementary development platform. Also starting with Oracle 11g, thedatabase includes a just-in-time compiler, which compiles Java bytecode into machine languageinstructions, making Java in the database run much faster. In 2010, Oracle acquired Sun Microsystems,so it now owns Java. This may help the database JVM compatibility remain in concert with the latestreleases.In this chapter, you will learn how to combine the power of PL/SQL development with Java codethat is stored within the database. You will learn how to create stored procedures, functions, and triggersusing the Java language. Running Java in the database is a substantial topic that has filled entire books,but in this chapter, we will focus only on using the Java types in conjunction with PL/SQL applications—which, after all, is the subject of this book. For complete documentation on using Java inside OracleDatabase, please see the Oracle Java developers guide athttp://download.oracle.com/docs/cd/E11882_01/java.112/e10588/toc.htm.15-1. Creating a Java Database ClassProblemYou want to write a Java class that will query the database and return a result.SolutionCreate a Java class that uses the Java Database Connectivity (JDBC) API to query the Oracle Database.For example, the Java class in the following example will query the EMPLOYEES table for all employees whobelong to the IT department. The example entails a complete Java class that is named Employees. Thisclass contains a method named getItEmps() that will become a Java stored procedure. The Employeesclass shown here will be stored into a file named Employees.java. \nimport java.sql.;import oracle.jdbc.; \npublic class Employees {  public static void getItEmps(){CHAPTER 15  JAVA IN THE DATABASE320      String firstName = null;      String lastName = null;      String email = null;      try {           Connection conn = DriverManager.                        getConnection(\"jdbc:default:connection:\");           String sql = \"SELECT FIRST_NAME, LAST_NAME, EMAIL \" +                        \"FROM EMPLOYEES \" +                        \"WHERE DEPARTMENT_ID = 60\";           PreparedStatement pstmt = conn.prepareStatement(sql);           ResultSet rset = pstmt.executeQuery();           while(rset.next()) {             firstName = rset.getString(1);             lastName = rset.getString(2);             email = rset.getString(3);             System.out.println(firstName + \" \" + lastName + \" \" +                                email);           }           pstmt.close();           rset.close();      } catch (SQLException ex){          System.err.println(\"ERROR: \" + ex);      }  };The following lines from SQL*Plus show how to execute this Java in the database, followed by theoutput from the program. Prior to executing the code, you must load it into the database and compile it.You will learn more about doing this in the next recipe. To learn more about executing Java in thedatabase, please see Recipe 15-5. For now, it is important to see the output that will result from asuccessful call to this Java program.SQL> exec get_it_emps;Alexander Hunold AHUNOLDBruce Ernst BERNSTDavid Austin DAUSTINValli Pataballa VPATABALDiana Lorentz DLORENTZPL/SQL procedure successfully completed.The Java class in this example performs a simple query and then prints the result. Although thisclass does not demonstrate the full potential of using Java, it is a good segue into Java databasedevelopment.How It WorksJava is a mature language that can be used in conjunction with PL/SQL. Sometimes it makes sense tocode portions of your application in Java, while in other instances it may make sense to code the entire  CHAPTER 15  JAVA IN THE DATABASE321application in Java. Both PL/SQL and Java can coexist in the same application, and you must use PL/SQLto access Java via the database.This recipe demonstrates how to create a simple Java class that queries the database for EMPLOYEErecords. The JDBC APIs provide a way for Java programs to methodically perform the tasks you willtypically want to complete whenever you access a database, whether it’s querying data, updatingrecords, or deleting rows.A Java class that you will use to access an Oracle Database as a stored procedure must adhere to afew standards. The class must be public, and each of its methods must be public and static. Failure tofollow these standards will render the class methods inaccessible for use as stored procedures.The first step taken in the solution to this recipe is to obtain a connection to the database. In a Javaclass that lives outside the database, obtaining a connection is a performance-intensive operation, andyou must pass a user name and password along with the database host name. However, obtaining aconnection using stored procedures is a bit different since they reside within the database itself. Theonly requirement is that you pass jdbc:default:connection to the getConnection() method. \nNext, the SQL query (sql) is formed as a String, and a PreparedStatement object (pstmt) is thencreated from it using the prepareStatement method. The prepared statement is what actually queries thedatabase. The next line of code in the solution issues the query by calling the executeQuery() method onthe prepared statement object, which returns a result set. The result set is what you need to use in orderto access the rows that have been returned via the query. Use a simple while loop to traverse the rows,and obtain each of the values from the result set within each iteration of the loop by indicating theposition of the column you want to retrieve. For instance, to obtain the FIRST_NAME, you will callrset.getString(1) because FIRST_NAME is the first column that is listed within the query.Lastly, the class in the solution closes the prepared statement and result set objects. Not doing somay cause issues such as memory leaks, although Java has a very efficient garbage collection system, soit should take care of this for you. Again, closing the objects is a form of good practice to ensure thatresources can be reallocated.The Oracle Java virtual machine (JVM) also supports the use of SQLJ for database access. Use ofSQLJ is beyond the scope of this book, but if you are interested in learning about it JVM, then please referto the Oracle Java Developer Guide, which can be found athttp://download.oracle.com/docs/cd/E11882_01/java.112/e10588/toc.htm.15-2. Loading a Java Database Class into a DatabaseProblemYou want to load a Java class into a schema within your Oracle Database.Solution #1You can use the CREATE JAVA command to load the Java source into the database by copying and pastingthe Java source into a SQL file. This is the easiest way to create a Java class and then load it into thedatabase if you are not working directly on the database server but rather remotely using an editor orSQL*Plus. The following lines of SQL code will load the Java class that was created in Recipe 15-1 into thedatabase using the CREATE JAVA command: \nCREATE OR REPLACE JAVA SOURCE NAMED \"Employees\" ASimport java.sql.;import oracle.jdbc.;CHAPTER 15  JAVA IN THE DATABASE322 \npublic class Employees {  public static void getItEmps(){      String firstName = null;      String lastName = null;      String email = null;      try {           Connection conn = DriverManager.                        getConnection(\"jdbc:default:connection:\");           String sql = \"SELECT FIRST_NAME, LAST_NAME, EMAIL \" +                        \"FROM EMPLOYEES \" +                        \"WHERE DEPARTMENT_ID = 60\"; \n       PreparedStatement pstmt = conn.prepareStatement(sql); \n       ResultSet rset = pstmt.executeQuery(); \n       while(rset.next()) &#123; \n         firstName = rset.getString(1); \n         lastName = rset.getString(2); \n         email = rset.getString(3); \n         System.out.println(firstName + &quot; &quot; + lastName + &quot; &quot; + \n                            email); \n       &#125; \n       pstmt.close(); \n       rset.close(); \n  &#125; catch (SQLException ex)&#123; \n      System.err.println(&quot;ERROR: &quot; + ex); \n      &#125; \n  &#125;           \n\n  };Next, you need to compile the code. To do so, use the ALTER JAVA CLASS  RESOLVE command.The following line of code compiles the Employees Java source: \nALTER JAVA CLASS \"Employees\" RESOLVE;Solution #2You can use the loadjava utility that is provided by Oracle in order to load Java code into the database.This situation works best if you are working directly on the database server and have access to theloadjava utility that is installed in the Oracle Database home. This utility is also nice to use if you alreadyhave the Java code stored in a file and do not want to copy and paste code into an editor or SQL*Plus.The following code demonstrates loading a Java source file named Employees.java using the loadjavautility: \nloadjava –user dbuser Employees.java \nAfter the command is issued, you will be prompted for the password to the user who you namedusing the –user option. By issuing the –resolve option, you will be loading the Java into the database andcompiling at the same time. This saves you the step of issuing the ALTER JAVA CLASS  RESOLVEcommand.  CHAPTER 15  JAVA IN THE DATABASE323How It WorksYou can load Java source code into the database directly using the CREATE JAVA SOURCE command. Thiswill load the source and make it accessible to the schema in which it was loaded. Once loaded, you cancreate a call specification for any of the class methods that you want to make into a stored procedure orfunction. The call specification maps the Java method names, parameter types, and return types to theirSQL counterparts. You will learn more about creating call specifications in Recipe 15-4. We recommendcompiling the source using the RESOLVE command before attempting to invoke any of its methods.However, if you do not issue the RESOLVE command, then Oracle Database will attempt to compile theJava source dynamically at runtime. Note A class name can be a maximum of 30 characters in length. If the specified name is more than 30characters in length, then Oracle will automatically shorten it for you and create and use a map to correlate thelong name with the shortened name. You can still specify the long name in most cases, and Oracle willautomatically convert that name to the shortened name for you. However, in some cases you will need to use theDBMS_JAVA.SHORTNAME('long_classname') function to map the name for you. Conversely, if you want to retrievethe long name by using its corresponding short name, you can use theDBMS_JAVA.LONGNAME('short_classname') function.The loadjava utility, which is the tool you use to implement the second solution, uses the CREATEJAVA command to load the Java into the database. It also allows you to specify the –resolve option,which will compile the code once it has been loaded. The advantage to using loadjava is that you canload Java source files directly into the database without the need to create a separate SQL file containingthe CREATE JAVA command or copy and paste the Java class into SQL*Plus. The downside is that youmust have access to the loadjava binary executable that resides on the Oracle Database server. Thisutility can also be used to load files of type .class, .sqlj. ,  .properties,  and .ser.If your code is unable to compile because of errors, then it will not execute if you attempt to invokeone of its methods. You must repair the error(s) and ensure that the code compiles successfully before itcan be used. If your code does not compile, then you can check the USER_ERRORS table to see whatissue(s) are preventing the code from compiling successfully. The USER_ERRORS table describes thecurrent errors on all the objects that are contained within the user’s schema. To learn more aboutquerying the USER_ERRORS table, please refer to Recipe 15-15.15-3. Loading a Compiled Java Class Into the DatabaseProblemYou want to load a compiled Java class into the database so that you can use one or more of its methodsas stored procedures.CHAPTER 15  JAVA IN THE DATABASE324SolutionUse the loadjava command-line utility to load the compiled Java class into the database. The followingline of code demonstrates how to use the loadjava utility to load a compiled Java class file namedEmployees.class into the database. \nloadjava -user dbuser -resolve Employees.classYou will be prompted to enter the password for the database user who you designated when issuingthe command.How It WorksThe loadjava utility can be used to load compiled Java class files into the database. To do so, you haveaccess to the binary loadjava utility executable. Usually this means you are located directly on theOracle Database server hosting the database that you want to load the Java into. Before you can invokethe loadjava utility, you should be sure that the ORACLE_SID for the target database has been set. If theserver on which you are located contains more than one Oracle home, then it is a good idea to also setthe ORACLE_HOME environment variable to be sure you will be invoking the correct version of the loadjavautility for your database. The loadjava utility is located within the bin directory of the Oracle Databasehome. The following statements show how to set these two environment variables on a Windowsmachine: \nSET ORACLE_SID=MYDATABASESET ORACLE_HOME=If you happen to be working on a Unix or Linux machine, the equivalent commands would be asfollows: \nsetenv ORACLE_SID = MYDATABASEsetenv ORACLE_HOME=  \nYou must have the following permissions in order to use the loadjava utility:• CREATE PROCEDURE• CREATE TABLE• Oracle.aurora.security.JServerPermission.loadLibraryInClass.classname \nSeveral options are at your disposal when using loadjava to load source or compiled class files intothe database. The –resolve option can be used to compile Java source and mark it as VALID within theOracle Database. The –resolver option can be used for locating other Java class files that your code isdependant upon. For a complete listing of loadjava options, please see the online Oracledocumentation, which can be found athttp://download.oracle.com/docs/cd/E11882_01/java.112/e10588/cheleven.htm#CACFHDJE. \nThe loadjava utility is a member of the DBMS_JAVA package, and it can be invoked directly fromwithin your PL/SQL code as well. To do this, issue a call to DBMS_JAVA.loadjava, and pass the optionsseparated by spaces. This is demonstrated by the following lines of text in SQL*Plus: \ncall dbms_java.loadjava(‘Employees.class’);  CHAPTER 15  JAVA IN THE DATABASE32515-4. Exposing a Java Class As a Stored ProcedureProblemYou have created a Java stored procedure and loaded it into the database, and now you want to access itvia PL/SQL.SolutionCreate a PL/SQL call specification for the Java class. The PL/SQL call specification will essentially wrapthe call to the Java class, enabling you to have access to the class from PL/SQL. The following codedemonstrates the creation of a call specification for the Java class that was created in Recipe 15-1 andloaded into the database in Recipe 15-2. \nCREATE OR REPLACE PROCEDURE get_it_emps AS LANGUAGE JAVANAME 'Employees.getItEmps()';How It WorksTo make the Java class accessible from the database, you must create a PL/SQL call specification(sometimes known as PL/SQL wrapper) for the stored Java code. A call specification maps a Java methodcall to a PL/SQL procedure so that the Java code can be called from the database directly. A callspecification also maps any parameters and return type to the Java code. To learn more about mappingparameters and return types, please see Recipe 15-7.The call specification for a Java stored procedure is a PL/SQL procedure itself that specifies ASLANGUAGE JAVA, followed by the name of the Java class and method that will be mapped to the procedurename. The name of the Java method to be invoked must be preceded by the Java class name thatcontains it. This is because the method has been defined as static, meaning it is a class method ratherthan an instance method. When a call to the specification is made, Oracle will automatically call theunderlying Java class method. Note Two types of methods can be created in a Java class: class methods and instance methods. Classmethods belong to the class, rather than to an instance of the class. This means the methods are instantiated oncefor each class. Instance methods belong to an instance of the class. This means that if a new instance of the classis created, a new method will be created with that instance. Class methods have access to class variables(otherwise known as static), whereas instance methods have access only to instance variables.15-5. Executing a Java Stored ProcedureProblemYou want to execute a Java stored procedure that you have created from within SQLPlus.CHAPTER 15  JAVA IN THE DATABASE326SolutionCall the PL/SQL call specification that maps to the Java stored procedure. The following SQLPlus codedemonstrates how to execute the Java class for which you created a call specification in Recipe 15-3. \nSQL> set serveroutput onSQL> call dbms_java.set_output(2000); \nCall completed. \nSQL> exec get_it_emps;Alexander Hunold AHUNOLDBruce Ernst BERNSTDavid Austin DAUSTINValli Pataballa VPATABALDiana Lorentz DLORENTZ \nPL/SQL procedure successfully completed.As you can see, when the code is executed, the results are returned to SQLPlus and displayed as if itwere the output of a PL/SQL procedure or function.How It WorksJava can be executed directly from within the database once a call specification has been made for thecorresponding Java method. Since the call specification is a PL/SQL procedure itself, you can invoke theunderlying Java just as if it were PL/SQL using the EXEC command from SQLPlus or call it from any otherPL/SQL block as if it were PL/SQL as illustrated in Recipe 15-6. To see any output from the Java, youmust set the buffer size appropriately to display it. If the buffer size is not set, then no output will bedisplayed. Similarly, if the buffer size is set too small, then only a portion of the output will be displayed.Personally, we recommend setting the output size to 2000 and moving up from there if needed. To setthe buffer size, issue this command: \nCALL DBMS_JAVA.SET_OUTPUT(buffer_size);The Java will be executed seamlessly and display the result, if any, just as if it were a PL/SQLresponse. In the solution to this recipe, the get_it_emps PL/SQL procedure is called. Since get_it_emps isa call specification, it will invoke the underlying Java class method getItEmps() that actually performs thequery and displays the content.15-6. Calling a Java Stored Procedure from PL/SQLProblemYou want to access a Java stored procedure from within one of your PL/SQL applications. For instance,you are creating a PL/SQL procedure, and you want to make a call to a Java stored procedure fromwithin it.  CHAPTER 15  JAVA IN THE DATABASE327SolutionMake a call to the Java stored procedure using the call specification that you created for it. The followingcode demonstrates a PL/SQL package that makes a call to a Java stored procedure and then resumesPL/SQL execution once the call has been made. \nCREATE OR REPLACE PROCEDURE employee_reports AS  CURSOR emp_cur IS  SELECT first_name, last_name, email  FROM employees  WHERE department_id = 50; \n  emp_rec    emp_cur%ROWTYPE;BEGIN  DBMS_OUTPUT.PUT_LINE('Employees from Shipping Department');  DBMS_OUTPUT.PUT_LINE('----------------------------------');  FOR emp_rec IN emp_cur LOOP    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ' ' ||                         emp_rec.last_name || ' ' ||                         emp_rec.email);  END LOOP; \n  DBMS_OUTPUT.PUT_LINE('==========================================');  DBMS_OUTPUT.PUT_LINE('Employees from IT Department');  DBMS_OUTPUT.PUT_LINE('----------------------------');  get_it_emps;END;This results in the following output: \nSQL> EXEC EMPLOYEE_REPORTSEmployees from Shipping Department \n\nMatthew Weiss MWEISSAdam Fripp AFRIPP…Alana Walsh AWALSHKevin Feeney KFEENEYDonald OConnell DOCONNELDouglas Grant DGRANT==========================================Employees from IT Department \n\nAlexander Hunold AHUNOLDBruce Ernst BERNSTDavid Austin DAUSTINValli Pataballa VPATABALDiana Lorentz DLORENTZ \nPL/SQL procedure successfully completed.CHAPTER 15  JAVA IN THE DATABASE328The call to the Java stored procedure from within the PL/SQL procedure is seamless. It is integratedinto the PL/SQL procedure body and invoked as if it were PL/SQL.How It WorksThe call specification publishes the Java stored procedure as if it were a PL/SQL procedure. This allowsfor seamless integration of Java stored procedures and PL/SQL. In the solution to this recipe, theEMPLOYEES table is queried via a PL/SQL cursor for all employees who belong to department 50. Thatcursor is then parsed, and the results are displayed. After the cursor results have been processed, a call ismade to the Java stored procedure getItEmps() using the call specification get_it_emps. The Java storedprocedure is executed, and its results are displayed along with those from the PL/SQL cursor processing.As you can see, Java can be executed from PL/SQL just as if it were native PL/SQL code. It can bevery useful to create database jobs utilizing Java stored procedures by developing a PL/SQL storedprocedure or anonymous block that makes a series of calls to different Java stored procedures orfunctions that perform the actual processing. PL/SQL and Java in the database can be verycomplementary to each other.15-7. Passing Parameters Between PL/SQL and JavaProblemYou want to pass parameters from PL/SQL to a Java stored procedure that expects them.SolutionCreate a call specification that accepts the same number of parameters as the number the Java storedprocedure expects. For this example, an additional method will be added to the Employee Java class thatwas created in Recipe 15-1. This method will be an enhanced version of the original method that willaccept a department ID as an input argument. It will then query the database for the employees whobelong to that department and display them.The following code is the enhanced Java method that will be added the Employees class containedwithin the Employees.java file: \npublic static void getItEmpsByDept(int departmentId){      String firstName = null;      String lastName = null;      String email = null;      try {           Connection conn = DriverManager.                        getConnection(\"jdbc:default:connection:\");           String sql = \"SELECT FIRST_NAME, LAST_NAME, EMAIL \" +                        \"FROM EMPLOYEES \" +                        \"WHERE DEPARTMENT_ID = ?\"; \n       PreparedStatement pstmt = conn.prepareStatement(sql); \n       pstmt.setInt(1, departmentId); \n       ResultSet rset = pstmt.executeQuery(); \n       while(rset.next()) &#123; \n         firstName = rset.getString(1); \n         lastName = rset.getString(2); \n\n  CHAPTER 15  JAVA IN THE DATABASE329             email = rset.getString(3);             System.out.println(firstName + \" \" + lastName + \" \" +                                email);           }           pstmt.close();           rset.close();      } catch (SQLException ex){          System.err.println(\"ERROR: \" + ex);          }  }Once this method has been added to the Employees class, then the Java source should be loaded intothe database using the technique demonstrated in Recipe 15-2. Note You must include the OR REPLACE clause of the CREATE JAVA statement if the Employees source isalready contained in the database. If you do not include this clause, then you will receive an Oracle error.Once the Java has been loaded into the database and compiled, you will need to create the callspecification that will be used by PL/SQL for accessing the Java stored procedure. The following codedemonstrates a call specification that will accept a parameter when invoked and pass it to the Javastored procedure: \nCREATE OR REPLACE PROCEDURE get_it_emps_by_dept(dept_id IN NUMBER) AS LANGUAGE JAVANAME 'Employees.getItEmpsByDept(int)';The procedure can now be called by passing a department ID value as such: \nSQL> exec get_it_emps_by_dept(60);Alexander Hunold AHUNOLDBruce Ernst BERNSTDavid Austin DAUSTINValli Pataballa VPATABALDiana Lorentz DLORENTZ \nPL/SQL procedure successfully completed.How It WorksThe call specification is what determines how a Java stored procedure or function’s arguments aremapped to PL/SQL arguments. To implement parameters, the call specification must match eachparameter in the stored procedure or function to an argument in the specification. As mentioned inprevious recipes, the call specification is a PL/SQL procedure itself, and each argument that is coded inthe specification matches an argument that is coded within the Java stored procedure.The datatypes that Java uses do not match those used in PL/SQL. In fact, a translation must takeplace when passing parameters listed as a PL/SQL datatype to a Java stored procedure that acceptsparameters as a Java datatype. If you are familiar enough with each of the two languages, the translationCHAPTER 15  JAVA IN THE DATABASE330is fairly straightforward. However, there are always those cases where one is not sure what datatype tomatch against. Table 15-1 lists some of the most common datatypes and how they map between Javaand PL/SQL. For a complete datatype map, please refer to the Oracle documentation athttp://download.oracle.com/docs/cd/B28359_01/java.111/b31225/chsix.htm#CHDFACEE.Table 15-1. Datatype MapSQL Datatype Java TypeCHAR oracle.sql.CHARVARCHAR java.lang.StringLONG java.lang.StringNUMBER java.lang.Integer,Java.lang.Float,Java.lang.Double,Java.math.BigDecimal,Java.lang.Byte,Oracle.sql.NUMBER,Java.lang.Short,DATE    oracle.sql.DATETIMESTAMP oracle.sql.TIMESTAMPTIMESTAMP WITH TIME ZONE oracle.sql.TIMESTAMPTZTIMESTAMP WITH LOCAL TIME ZONE  oracle.sql.TIMESTAMPLTZBLOB oracle.sql.BLOBCLOB oracle.sql.CLOBCreating a PL/SQL call specification that includes parameters must use the fully qualified Java classname when specifying the parameter datatypes in the Java class method signature. If an incorrectdatatype is specified, then an exception will be thrown. For instance, if you want to pass a VARCHAR2 fromPL/SQL to a Java stored procedure, the signature for the Java class method must accept an argument oftype java.lang.String. The following pseudocode demonstrates this type of call specification:CREATE OR REPLACE PROCEDURE procedure_name(value   VARCHAR2)AS LANGUAGE JAVANAME ‘JavaClass.javaMethod(java.lang.String)’;15-8. Creating and Calling a Java Database FunctionProblemYou want to create a database function using the Java language.  CHAPTER 15  JAVA IN THE DATABASE331SolutionCreate a function written in Java, and then create a call specification for the function. Ensure that the callspecification allows for the same number of parameters to pair up with the Java function and allows for areturning result. For this recipe, you will add a function to the Employees Java class that will accept anemployee ID and return that employee’s job title. The following code is the Java source for the functionnamed getEmpJobTitle: \npublic static String getEmpJobTitle(int empId){      String jobTitle = null;      try {           Connection conn = DriverManager.                        getConnection(\"jdbc:default:connection:\");           String sql = \"SELECT JOB_TITLE \" +                        \"FROM EMPLOYEES EMP, \" +            \"JOBS JOBS \" +                        \"WHERE EMP.EMPLOYEE_ID = ? \" +                         \"AND JOBS.JOB_ID = EMP.JOB_ID\"; \n       PreparedStatement pstmt = conn.prepareStatement(sql); \n       pstmt.setInt(1, empId); \n       ResultSet rset = pstmt.executeQuery(); \n       while(rset.next()) &#123; \n         jobTitle = rset.getString(1); \n       &#125; \n       pstmt.close(); \n       rset.close(); \n                      &#125; catch (SQLException ex)&#123; \n                                 System.err.println(&quot;ERROR: &quot; + ex); \n                                 jobTitle = &quot;N/A&quot;; \n      &#125; \n              if (jobTitle == null)&#123; \n                   jobTitle = &quot;N/A&quot;; \n             &#125; \n                                return jobTitle; \n\n  }Next is the call specification for the function: \nCREATE OR REPLACE FUNCTION get_emp_job_title(emp_id IN NUMBER)RETURN VARCHAR2 AS LANGUAGE JAVANAME 'Employees.getEmpJobTitle(int) return java.lang.String';The function can now be called just like a PL/SQL function would. The following lines of code showa SQL SELECT statement that calls the function passing an employee ID number of 200. \nSQL> select get_emp_job_title(200) from dual; \nGET_EMP_JOB_TITLE(200) Administration AssistantCHAPTER 15  JAVA IN THE DATABASE332How It WorksThe difference between a stored procedure and a stored function is that a function always returns avalue. In the Java language, a method may or may not return a value. The difference between a PL/SQLcall specification for a Java stored procedure and a PL/SQL call specifcation for a Java function is that thePL/SQL call specification will specify a return value if it is being used to invoke an underlying function.In the solution to this recipe, the example PL/SQL call specification returns a VARCHAR2 data type becausethe Java function that is being called will return a Java String.15-9. Creating a Java Database TriggerProblemYou want to create a database trigger that uses a Java stored procedure to do its work.SolutionCreate a Java stored procedure that does the work you require, and publish it as a Java stored procedure,making it accessible to PL/SQL. Once it’s published, write a standard PL/SQL trigger that calls the Javastored procedure.For example, suppose you need a trigger to audit INSERT events on the EMPLOYEES table and recordthem in another table. First, you must create the table that will be used to record each of the loggedevents. The following DDL creates one: \nCREATE TABLE EMPLOYEE_AUDIT_LOG (employee_id     NUMBER,enter_date      DATE);Next, you will need to code the Java stored procedure that you want to have executed each time anINSERT occurs on the EMPLOYEES table. Add the following Java method to the Employees class of previousrecipes in this chapter:public static void employeeAudit(int empId){      try {           Connection conn = DriverManager.                        getConnection(\"jdbc:default:connection:\");           String sql = \"INSERT INTO EMPLOYEE_AUDIT_LOG VALUES(\" +                    \"?, sysdate)\";           PreparedStatement pstmt = conn.prepareStatement(sql);           pstmt.setInt(1, empId);           pstmt.executeUpdate();       pstmt.close();       conn.commit(); \n  &#125; catch (SQLException ex)&#123; \n      System.err.println(&quot;ERROR: &quot; + ex); \n      &#125; \n   \n\n  }  CHAPTER 15  JAVA IN THE DATABASE333Next, the PL/SQL call specification for the Java stored procedure must be created. The following isthe code to implement the call specification: \nCREATE OR REPLACE PROCEDURE emp_audit(emp_id NUMBER)AS LANGUAGE JAVANAME 'Employees.employeeAudit(int)'; \nFinally, a trigger to call the EMP_AUDIT procedure must be created. The trigger will be executed onINSERT to the EMPLOYEES table. The following code will generate the trigger to call EMP_AUDIT: \nCREATE OR REPLACE TRIGGER emp_audit_insAFTER INSERT ON EMPLOYEESFOR EACH ROWCALL emp_audit(:new.employee_id);Once all these pieces have been successfully created within the database, the EMP_AUDIT_INS triggerwill be executed each time there is an INSERT made to the EMPLOYEES table. In turn, the trigger will call theEMP_AUDIT PL/SQL procedure, which calls the Java method contained within the Employees class. TheSQL*Plus output shown here demonstrates an INSERT into the EMPLOYEES table, followed by a query onthe EMPLOYEE_AUDIT_LOG table to show that the trigger has been invoked: \nSQL> insert into employees values(   employees_seq.nextval,   'Jane',   'Doe',   '&#x6a;&#97;&#x6e;&#x65;&#x2e;&#100;&#111;&#x65;&#x40;&#109;&#121;&#x63;&#111;&#109;&#x70;&#x61;&#110;&#121;&#46;&#x63;&#111;&#109;',   null,   sysdate,   'FI_MGR',   null,   null,   null,   null); \n1 row created. \nSQL> select * from employee_audit_log; \nEMPLOYEE_ID ENTER_DAT \n\n265 02-NOV-10 \n\nHow It WorksA Java-based trigger combines the power of Java code with the native ease of performing datamanipulation using PL/SQL triggers. Although creating a Java trigger requires more steps than usingnative PL/SQL, the Java code is portable. If your application is supported on more than one databaseplatform, this lets you write code once and deploy it in many environments. It also makes sense to codea trigger using Java if you require the use of Java libraries or technologies that are unavailable to PL/SQL.CHAPTER 15  JAVA IN THE DATABASE334In the solution to this recipe, a trigger was created that will insert a row into an audit table each timean INSERT is made on the EMPLOYEES table. The actual work is performed within a Java method that isadded to a Java class and loaded into the database. For more information on loading Java into thedatabase, please see Recipe 15-2. To invoke the stored Java method, you must create a PL/SQL callspecification, which maps the Java method to a PL/SQL stored procedure. The call specification canaccept zero, one, or many parameters, and it will seamlessly pass the parameters to the underlying Javamethod. The final step to creating a Java trigger is to code a PL/SQL trigger that invokes the PL/SQLstored procedure that was created.Creating a Java-based trigger entails a series of steps. Each piece of code depends upon the others,and like a domino effect, the trigger will call the procedure that in turn executes the Java method. Thissolution opens the world of Java libraries and thousands of possibilities to the standard PL/SQL trigger.15-10. Passing Data Objects from PL/SQL to JavaProblemYou have retrieved a row of data from the database using PL/SQL, and you want to populate a PL/SQLobject type with that data and then pass the populated data object to a Java procedure.SolutionCreate a PL/SQL object type, along with a call specification for the Java stored procedure that you wantto pass the object to. Ensure that the Java stored procedure accepts an object of type oracle.sql.STRUCTand that the call specification accepts the PL/SQL object type you have created. For this recipe, theexample will demonstrate the creation of a Java method that will accept an Employee object and returnthat employee’s corresponding department name. The Java code will be invoked from within a PL/SQLanonymous block that queries each employee, loads an Employee object with the data, passes the objectto the Java method, and returns the result.First, add the following Java method to the Employees class you’ve used with previous recipes in thischapter: \npublic static String getEmpDepartment(oracle.sql.STRUCT emp) { \nString deptName = null; \nBigDecimal employeeId = null; \ntry &#123; \n      Object[] attribs = emp.getAttributes(); \n   // Use indexes to grab individual attributes. \n   Object empId = attribs[0]; \n   try&#123; \n       employeeId = (BigDecimal) empId; \n   &#125; catch (ClassCastException cce) &#123; \n       System.out.println(cce); \n   &#125; \n   Connection conn = DriverManager. \n                    getConnection(&quot;jdbc:default:connection:&quot;); \n       String sql = &quot;SELECT DEPARTMENT_NAME &quot; +  \n                    &quot;FROM DEPARTMENTS DEPT, &quot; + \n        &quot;EMPLOYEES EMP &quot; + \n                    &quot;WHERE EMP.EMPLOYEE_ID = ? &quot; + \n\n  CHAPTER 15  JAVA IN THE DATABASE335            \"AND DEPT.DEPARTMENT_ID = EMP.DEPARTMENT_ID\"; \n       PreparedStatement pstmt = conn.prepareStatement(sql); \n       pstmt.setInt(1, employeeId.intValue()); \n       ResultSet rset = pstmt.executeQuery(); \n       while(rset.next()) &#123; \n         deptName = rset.getString(1); \n       &#125; \n       pstmt.close(); \n       rset.close(); \n  &#125; catch (java.sql.SQLException ex)&#123; \n      System.err.println(&quot;ERROR: &quot; + ex); \n      deptName = &quot;N/A&quot;; \n      &#125; \n  if (deptName == null)&#123; \n    deptName = &quot;N/A&quot;; \n  &#125; \n  return deptName; \n\n  }Next, create the PL/SQL object that will contain employee information. The following SQLstatement will create this object: \nCREATE TYPE Employee AS OBJECT (emp_id NUMBER(6),first VARCHAR2(20),last  VARCHAR2(25),email VARCHAR2(25),job VARCHAR2(10),dept NUMBER(4));Now you need to create the call specification for the Java method. Since the method is returning avalue, the call specification needs to be a PL/SQL function that accepts an Employee object and returns aString value. The following code demonstrates such a call specification for the getEmpDepartment Javamethod: \nCREATE OR REPLACE FUNCTION get_emp_department (emp Employee) RETURN VARCHAR2 ASLANGUAGE JAVANAME 'Employees.getEmpDepartment(oracle.sql.STRUCT) return java.lang.String';Finally, call the new Java function from within an anonymous block. The following PL/SQL blockuses a cursor to traverse the EMPLOYEES table and populates an Employee object with each iteration. Inturn, the object is passed to the Java stored procedure via the PL/SQL function GET_EMP_DEPARTMENT, andthe corresponding DEPARTMENT_NAME is returned. \nDECLARE  CURSOR emp_cur IS  SELECT * FROM EMPLOYEES; \n  emp_rec    emp_cur%ROWTYPE;CHAPTER 15  JAVA IN THE DATABASE336  emp        Employee;BEGIN  FOR emp_rec IN emp_cur LOOP    emp := Employee(emp_rec.employee_id,                    emp_rec.first_name,                    emp_rec.last_name,                    emp_rec.email,                    emp_rec.job_id,                    emp_rec.department_id);    DBMS_OUTPUT.PUT_LINE(emp.first || ' ' || emp.last || ' - ' ||            get_emp_department(emp));  END LOOP;END;How It WorksPassing objects to Java code should be second nature to you since Java is an object-oriented language.You can create PL/SQL objects as well and use them within your PL/SQL and Java mashup applications.The solution to this recipe demonstrated the creation of an Employee object in PL/SQL that was passed toJava.To accept a PL/SQL object type, Java code must use a parameter of type oracle.sql.STRUCT in placeof the object. The STRUCT object is basically a container that allows the contents to be accessed by callingthe getAttributes method. In the solution to this recipe, the oracle.sql.STRUCT object is accepted in theJava class as a parameter, and then the getAttributes method is called on it. This creates an array ofobjects that contains the data. The Java stored procedure accesses the object using the 0 index position,which is the first placeholder from the PL/SQL object. This position maps to the emp_id field in thePL/SQL object. The Java class then uses that emp_id to query the database and retrieve a correspondingDEPARTMENT_ID if it exists.The call specification must accept the PL/SQL object type as a parameter but use theoracle.sql.STRUCT object as the parameter in the Java source signature. When the object is passed to thePL/SQL call specification procedure, it will be converted into an oracle.sql.STRUCT object, which is adatatype that a Java class can accept.Organizing your data into objects can be useful, especially when the object you are creating doesnot match a table definition exactly. For instance, you could create an object that contains employeeinformation along with region information. There are no tables that contain both of these fields, so inorder to retrieve the information together, you are forced into either using a SQL query that containstable joins or creating a database view. In such a case, it may be easier to populate the object usingPL/SQL and then hand it off to the Java program for processing.15-11. Embedding a Java Class Into a PL/SQL PackageProblemYou are interested in creating a Java class and making each of its methods and attributes available toPL/SQL in an organized unit of code.SolutionUse a PL/SQL package to declare each of the attributes and methods that reside within the Java class,and then create separate call specifications for each of the Java methods within the PL/SQL package  CHAPTER 15  JAVA IN THE DATABASE337body. The following code demonstrates the creation of a PL/SQL package named EMP_PKG, whichdeclares each of the methods that reside within the Employee Java class and makes them available toPL/SQL via call specifications that are implemented within the package body.First, create the package header as follows: \nCREATE OR REPLACE PACKAGE EMP_PKG AS \nPROCEDURE get_it_emps; \nPROCEDURE get_it_emps_by_dept(dept_id IN NUMBER); \nPROCEDURE emp_audit(emp_id NUMBER); \n \nFUNCTION get_emp_job_title(emp_id IN NUMBER) RETURN VARCHAR2; \nFUNCTION get_emp_department (emp Employee) RETURN VARCHAR2; \n\nEND;Next, create the package body as follows, adding a call specification for each Java method orattribute you plan to use: \nCREATE PACKAGE BODY EMP_PKG AS \nPROCEDURE get_it_emps \nAS LANGUAGE JAVA \nNAME &#39;Employees.getItEmps()&#39;; \n \nPROCEDURE get_it_emps_by_dept(dept_id IN NUMBER) \nAS LANGUAGE JAVA \nNAME &#39;Employees.getItEmpsByDept(int)&#39;; \n \nPROCEDURE emp_audit(emp_id NUMBER) \nAS LANGUAGE JAVA \nNAME &#39;Employees.employeeAudit(int)&#39;; \n \nFUNCTION get_emp_job_title(emp_id IN NUMBER) RETURN VARCHAR2 \nAS LANGUAGE JAVA \nNAME &#39;Employees.getEmpJobTitle(int) return String&#39;; \n \nFUNCTION get_emp_department (emp Employee) RETURN VARCHAR2 \nAS LANGUAGE JAVA \nNAME &#39;Employees.getEmpDepartment(oracle.sql.STRUCT) return java.lang.String&#39;; \n\nEND;Now the package can be used to call each of the underlying Java stored procedures instead of havingseparate PL/SQL procedures and functions for each. The following anonymous block has been modifiedto make use of the PL/SQL package for calling GET_EMP_DEPARTMENT rather than a stand-alone function. \nDECLARE  CURSOR emp_cur IS  SELECT * FROM EMPLOYEES; \nCHAPTER 15  JAVA IN THE DATABASE338  emp_rec    emp_cur%ROWTYPE;  emp        Employee;BEGIN  FOR emp_rec IN emp_cur LOOP    emp := Employee(emp_rec.employee_id,                    emp_rec.first_name,                    emp_rec.last_name,                    emp_rec.email,                    emp_rec.job_id,                    emp_rec.department_id);    DBMS_OUTPUT.PUT_LINE(emp.first || ' ' || emp.last || ' - ' ||            emp_pkg.get_emp_department(emp));  END LOOP;END;How It WorksIn programming, it is a best practice to organize code in a way that makes it easy to maintain.  Placingrelated procedures and functions inside a single PL/SQL package is one such application of thatapproach. The same can be said for working with Java code in the database. A few Java storedprocedures or functions will not cause much trouble to maintain. However, once you start toaccumulate more than a handful within the same underlying Java class, then it is a good idea toconsolidate the call specifications into a single PL/SQL package.In the solution to this recipe, all the Java stored procedures that are contained within the EmployeesJava class have call specifications that are grouped into a single PL/SQL package. If you create onePL/SQL package containing call specifications per each Java class that is loaded into the database, youwill have a nicely organized environment. In some cases, you may have more than one Java class thatcontains the implementations that are to be used within a single PL/SQL application. In those cases, itmay make more sense to combine all call specifications into a single PL/SQL package.Using PL/SQL package to group call specifications is a good idea. Not only will this technique makefor easier maintenance, but it also makes for more uniform applications with consistent interfaces.15-12. Loading Java Libraries Into the DatabaseProblemYou want to create a Java class that utilizes some external Java libraries. To do so, you must load thoseexternal libraries into the database.SolutionUse the loadjava utility to store the external libraries into the database. In this example, a Java utilityclass containing a method that uses the JavaMail API to send e-mail will be loaded into the database. Themethod relies on some external Java libraries to use the JavaMail API. The following loadjava commandsdemonstrate the loading of three essential JAR files for using the JavaMail API: \nloadjava –u  mail.jarloadjava –u  standard.jarloadjava –u  activation.jar \n  CHAPTER 15  JAVA IN THE DATABASE339Next, load the Java source for the JavaUtils class into the database: \nCREATE OR REPLACE JAVA SOURCE NAMED \"JavaUtils\" ASimport java.util.;import java.util.logging.Level;import java.util.logging.Logger;import javax.activation.;import javax.mail.;import javax.mail.internet.;import javax.naming.*; \npublic class JavaUtils { \n public static void sendMail(String subject,            String recipient,            String message) {        try { \n        Properties props = System.getProperties(); \n        props.put(&quot;mail.from&quot;, &quot;me@mycompany.com&quot;); \n        props.put(&quot;mail.smtp.host&quot;,&quot;company.smtp.server&quot;); \n        Session session = Session.getDefaultInstance(props,null); \n        Message msg = new MimeMessage(session); \n        msg = new MimeMessage(session); \n        msg.setSubject(subject); \n        msg.setSentDate(new java.util.Date()); \n        msg.setFrom(); \n         \n        msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipient, \n\nfalse)); \n        MimeBodyPart body = new MimeBodyPart(); \n        body.setText(message); \n        Multipart mp = new MimeMultipart(); \n        mp.addBodyPart(body); \n        msg.setContent(mp); \n\n        Transport.send(msg); \n    &#125; catch (MessagingException ex) &#123; \n        Logger.getLogger(JavaUtils.class.getName()).log(Level.SEVERE, null, ex); \n    &#125;  \n&#125;; \n\nCompile the Java sources using the ALTER JAVA SOURCE command. The sources should compilewithout issues since the JAR files containing the required library references have been loaded into thedatabase. If the JAR files had not been loaded, then the class would not compile successfully. \nALTER JAVA SOURCE \"JavaUtils\" RESOLVE;Lastly, create the call specification for the sendMail Java stored procedure. In this case, a PL/SQLpackage will be created that contains the call specification for sendMail. \nCHAPTER 15  JAVA IN THE DATABASE340CREATE OR REPLACE PACKAGE JAVA_UTILS AS    PROCEDURE send_mail(subject VARCHAR2,                        recipient VARCHAR2,                        message VARCHAR2); \nEND;CREATE OR REPLACE PACKAGE BODY JAVA_UTILS AS    PROCEDURE send_mail(subject VARCHAR2,                        recipient VARCHAR2,                        message VARCHAR2)    AS LANGUAGE JAVA    NAME 'JavaUtils.sendMail(java.lang.String, java.lang.String, java.lang.String)'; \nEND;The stored procedure can now be executed using the following command:EXEC java_utils.send_mail('Test','&#109;&#x79;&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#109;&#121;&#x63;&#111;&#109;&#x70;&#x61;&#110;&#x79;&#46;&#99;&#111;&#x6d;','Test Message');If the message is sucessfully sent, you will see the following output:PL/SQL procedure successfully completed.How It WorksJava libraries are packaged into JAR files so that they can be easily distributed. The loadjava utility canbe used to load Java libraries into the database. To use the utility, download the JAR files that you want toload into the database, and place them into a directory that can be accessed by the database server.Open the command prompt or terminal, traverse into that directory, and execute the loadjava utility,using the –u flag to specify the database user and passing the name of the JAR file to load. If successful,the JAR file will be loaded into the schema that you indicated with the –u flag, and you may begin to usethe libraries contained in the JAR file within your stored Java code.The loadjava utility contains a number of options. For a complete listing of loadjava options, pleasesee the online Oracle documentation athttp://download.oracle.com/docs/cd/B28359_01/java.111/b31225/cheleven.htm.Additional options are not necessary to load a JAR file into the schema that you indicate with the -uflag. Since the JAR file consists of compiled Java libraries, there is no need to resolve the library onceloaded. As indicated in the solution to this recipe, you can begin to import classes from the libraries assoon as they have been loaded.15-13. Removing a Java ClassProblemYou want to drop a Java class from your database.  CHAPTER 15  JAVA IN THE DATABASE341SolutionIssue the SQL DROP JAVA command along with the schema and object name you want to drop. Forinstance, you want to drop the Java source for the Employees class. In this case, you would issue thefollowing command: \nDROP JAVA SOURCE “Employees”;How It WorksThere may come a time when you need to drop a Java class or sources from the database. For instance, ifyou no longer want to maintain or allow access to a particular Java class, it may make sense to drop it.The DROP JAVA SOURCE command does this by passing the name of the class or source as demonstratedwithin the solution to this recipe. Note Be careful not to drop a Java class if other Java procedures or PL/SQL call specifications depend upon it.Doing so will invalidate any dependent code, and you will receive an error if you try to execute. The data dictionaryprovides views, such as DBA_DEPENDENCIES, that can be queried in order to find dependent objects. \nAlternately, if you are on the database server, there is a dropjava utility that works in the samefashion as the loadjava utility that was demonstrated in Recipe 15-3. To use the dropjava utility, issuethe dropjava command at the command line, and pass the database connect string using the –u flagalong with the name of the Java class or source you want to drop. The following example demonstratesthe command to drop the Employees Java class using the dropjava utility. \ndropjava –u username/password@database_host:port:database_name Employees.classThe dropjava utility actually invokes the DROP JAVA SOURCE command. The downside to using theutility is that you must be located on the database server to use it. I recommend using the DROP JAVASOURCE command from SQLPlus if possible because it tends to make life easier if you are working withinSQLPlus on a machine that is remote from the server.15-14. Retrieving Database Metadata with JavaProblemYou are interested in retrieving some metadata regarding the database from within your Java storedprocedure. In this recipe, you want to list all the schemas within the database.SolutionCreate a Java stored procedure that utilizes the OracleDatabaseMetaData object to pull information fromthe connection. In the following example, a Java stored procedure is created that utilizes theCHAPTER 15  JAVA IN THE DATABASE342OracleDatabaseMetaData object to retrieve schema names from the Oracle connection. This Java methodwill be added to the JavaUtils class. \npublic static void listDatabaseSchemas() {        Connection conn = null;        try {            conn = DriverManager.getConnection(\"jdbc:default:connection:\");            OracleDatabaseMetaData meta = (OracleDatabaseMetaData) conn.getMetaData(); \n        if (meta == null) &#123; \n            System.out.println(&quot;Database metadata is unavailable&quot;); \n        &#125; else &#123; \n            ResultSet rs = meta.getSchemas(); \n            while (rs.next()) &#123; \n                System.out.println(rs.getString(1)); \n            &#125; \n        &#125; \n    &#125; catch (SQLException ex) &#123; \n        System.out.println(ex); \n    &#125;  \n&#125; \n\nThe output from the execution of this Java method will be a list of all database schemas.How It WorksSometimes it may be useful to use Java code for obtaining database metadata. One such instance mightarise when you are developing a Java class that needs to access database metadata. Your code will beeasier to maintain and read if you use Java to obtain the metadata rather than a PL/SQL procedure. TheOracleDatabaseMetaData object was created for that purpose. In the solution to this recipe, the metadataobject is used to retrieve a listing of all database schemas. However, several other methods can be calledon the OracleDatabaseMetaData object to obtain other useful database metadata. For instance,information about the underlying database tables or columns can also be obtained using this resource.For a complete listing of the different options available via the OracleDatabaseMetaData object, pleaserefer to the online documentation atwww.oracle.com/technology/docs/tech/java/sqlj_jdbc/doc_library/javadoc/oracle.jdbc.driver.OracleDatabaseMetaData.html. \nIn the solution to this recipe, a Java Connection object is obtained using jdbc:default:connection.The getMetaData method can be called on a Connection object and casted to an OracleDatabaseMetaDataobject type. This solution demonstrates this technique and then uses the object to retrieve informationabout the database.  CHAPTER 15  JAVA IN THE DATABASE34315-15. Querying the Database to Help Resolve JavaCompilation IssuesProblemYou are attempting to compile Java source within the database, and you are receiving an unsuccessfulresult. You need to determine the underlying issue to the problem that is preventing the Java sourcefrom compiling correctly.SolutionQuery the USER_ERRORS table to determine the cause of the compilation issue. For example, suppose theJavaUtils class source is loaded into the database with an incorrect variable name. This will cause acompiler error that will be displayed within the USER_ERRORS table. The following is an excerpt from aSQL*Plus session where an attempt has been made to compile the code: \nSQL> ALTER JAVA SOURCE \"JavaUtils\" RESOLVE; \nWarning: Java altered with compilation errors. \nSince compilation errors have occurred, query the USER_ERRORS table to determine the exact cause ofthe error so that it can be repaired. The following query demonstrates this technique: \nSQL> COL TEXT FOR A25SQL> SELECT NAME, TYPE, LINE, TEXT  2  FROM USER_ERRORS  3  WHERE TYPE LIKE 'JAVA%'; \nNAME                   TYPE          LINE TEXT \n\nJavaUtils               JAVA CLASS         0 ORA-29535: source require                               s recompilation \nJavaUtils               JAVA SOURCE         0 JavaUtils:51: cannot find                            symbol \nJavaUtils               JAVA SOURCE         0 symbol  : variable meJavaUtils               JAVA SOURCE         0 location: class JavaUtilsJavaUtils               JAVA SOURCE         0               ResultSet                            rs = me.getSchemas(); \nNAME                   TYPE          LINE TEXT \n\nJavaUtils               JAVA SOURCE         0                                 ^ \nJavaUtils               JAVA SOURCE         0 1 error \nCHAPTER 15  JAVA IN THE DATABASE3447 rows selected.How It WorksThe USER_ERRORS table contains the most recent errors generated by PL/SQL or Java code. It is the mostuseful way to determine the issues that are causing compilation errors when attempting to resolve Javasource errors. Unlike PL/SQL, you are unable to issue the SHOW ERRORS command to display the mostrecent compiler errors. The Java compiler, as well as the PL/SQL compiler, writes output to theUSER_ERRORS table, making it a beneficial tool when writing Java code for the database.C H A P T E R  16 \n   \n345Accessing PL/SQL from JDBC,HTTP, Groovy, and JythonJava programs run on a virtual machine known as the Java virtual machine (JVM). A version of the JVM isavailable for most operating systems and is deployed on millions of servers, desktops, phones, and evenBlu-ray players throughout the world. Because of the widespread availability of the JVM, Java isconsidered a portable language: you can essentially write Java code once and run it just about anywhere,whether it’s on a Linux box, a Mac, Android phone, or a Windows desktop.The JVM has evolved over time, and Java is no longer the only language that can run on it. Therehave been many languages implemented in Java that provide different features for those who enjoydeveloping applications for the JVM. Each of these languages has its own syntax and constructs, andmany of them can be viable alternatives for developing scripts, desktop applications, or enterprise-levelweb applications. As such, this chapter not only covers the ins and outs of accessing PL/SQL from Javaapplication code but also includes recipes for working with two popular dynamic languages that run onthe JVM: Jython and Groovy.This chapter is not intended to be an overall instruction set for using Java or any other language onthe JVM. It is meant for the purpose of demonstrating how to access PL/SQL code from within theselanguages. The Java online community is outstanding, and a plethora of resources are available on theWeb for learning about Java or other languages on the JVM. For more detailed information, pleaseconsult those resources, because this chapter will only provide solutions targeting PL/SQL integration.16-1. Accessing a PL/SQL Stored Procedure via JDBCProblemYou are writing a Java application that uses JDBC to access data, but you also want to call some PL/SQLstored procedures from within your Java application.SolutionUse the JDBC API to connect to the database, and then execute prepareCall(), passing a string to it thatconsists of a PL/SQL code block that calls the stored procedure. For example, consider a stand-aloneJava class that contains a method named increaseWage(). This method uses JDBC to obtain a databaseconnection, create a CallableStatement, and then invoke the PL/SQL stored procedure that passes in therequired variables. \nimport java.sql.;import oracle.jdbc.;CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON346 \npublic class EmployeeFacade { \n public void increaseWage() throws SQLException {  int ret_code;  Connection conn = null;  try {    //Load Oracle driver    DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());    //Obtain a connection \nconn = DriverManager.getConnection(&quot;jdbc:oracle:thin:@hostname:port_number:mydb&quot;, \n                                                                          &quot;user&quot;, \n\n\"password\");    int emp_id = 199;    double increase_pct = .02;    int upper_bound = 10000;    CallableStatement pstmt =    conn.prepareCall(\"begin increase_wage(?,?,?); end;\");    pstmt.setInt(1, emp_id);    pstmt.setDouble(2, increase_pct);    pstmt.setInt(3, upper_bound);    pstmt.executeUpdate(); \npstmt.close(); \nconn.commit(); \nconn.close(); \nSystem.out.println(&quot;Increase successful&quot;); \n\n  } catch (SQLException e) {ret_code = e.getErrorCode();    System.err.println(ret_code + e.getMessage()); conn.close();}  } \n  public static void main(String[] args){      EmployeeFacade facade = new EmployeeFacade();      try {          facade.increaseWage();      } catch (SQLException e){          System.err.println(\"A database exception has occurred.\");      }  }}Running this code within an integrated development environment such as NetBeans would result inthe following output: \nrun:Increase successfulBUILD SUCCESSFUL (total time: 4 seconds)The EmployeeFacade class contains a main() method that is used to initiate the execution of theincreaseWage() method. The increaseWage() method initializes three variables that are passed to theincrease_wage PL/SQL stored procedure using a CallableStatement. CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON347How It WorksIt is possible to invoke a PL/SQL stored procedure from a JDBC call just as if you were issuing a call fromPL/SQL. You can do so by passing a PL/SQL code block that contains the procedure call as a string to theJDBC connection. In the solution to the example we’ve chosen for this recipe, a Java class namedEmployeeFacade contains a method that makes a JDBC call to invoke a stored procedure. If you areunfamiliar with Java and database connectivity, you can see that using JDBC is very methodical. Thereare several steps that need to be taken in order to obtain a connection to the database, followed by thesteps to perform the database transaction and lastly to commit the changes and close all of the JDBCconstructs.Any Java work that is done using the JDBC API must include an exception handler for thejava.sql.SQLException. As the increaseWage() method demonstrates, the SQLException is handled usinga Java try-catch block. Prior to the try-catch block, a couple of variables are created that the rest of themethod will use. One of the variables is the java.sql.Connection, which is to be used to make aconnection to the database, execute the call, and then finally close the connection. In the next couple oflines, a try-catch block is started, and a connection is obtained to the Oracle Database using theDriverManager class. The getConnection() method accepts a JDBC URL pertaining to a database as wellas a user name and password. Note It is important to maintain a close watch on JDBC connections. They can be costly for performance, andonly a limited number of connections is usually available for use. For this reason, a connection should always beobtained, used, and then closed.If a connection is successfully made to the database, then a CallableStatement is created thatperforms all the work against the database. If you wanted to issue a query, then you would use aPreparedStatement instead because CallableStatements are most useful for making PL/SQL calls. Astring containing a PL/SQL code block is used to invoke the call to the PL/SQL stored procedure. The callis a bit different from native PL/SQL because it includes Java bind variables that represent theparameters that need to be passed into the procedure. A bind variable is represented by a question mark(?) character, and subsequent setter methods will be used to set values for each bind variable. After theCallableStatement’s prepareCall() method is invoked, variables are passed to the procedure using aseries of setXXX() methods on the CallableStatement. The set methods correlate with the type of datathat is being passed to the stored procedure, and they provide a positional parameter that maps thevariable to the bind variable position in the call. For instance, the first setInt(1, emp_id) methodcontains an integer variable, emp_id, and it will be passed to the bind variable in the first position withinthe call.After all the variables have been set, the executeUpdate() method is called in order to execute thecall to the procedure. If successful, program execution will continue. However, if unsuccessful for somereason, then a java.sql.SQLException will be thrown that will cause the execution of the Java program tobe passed to the catch block. Finally, if the transaction was a success, then the connection commits thetransaction, and the CallableStatement is closed, followed by the closing of the connection. You willnotice that the throws SQLException clause has been placed within the method declaration. When anyJava method contains a throws clause within the declaration, then you must code an exception handlerfor any Java code that calls the method. In this solution, the throws clause has been put into place tohandle any exceptions that may be raised when closing the connection within the exception-handlingCHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON348catch block. For more information on Java exception handling, please see the online documentationavailable at http://download.oracle.com/javase/tutorial/essential/exceptions/handling.html.The JDBC API can be used to call PL/SQL stored procedures by passing a PL/SQL code block in theform of a Java String to a CallableStatement object. The majority of the code using JDBC is spentcreating and closing the database connections as well as the CallableStatements. If you are unfamiliarwith JDBC, then you can learn more about it at www.oracle.com/technetwork/java/overview-141217.html. It can be used for creating small Java programs or enterprise-level Java applications. TheJDBC API has been around since the early days of Java, so it is quite mature and allows you to access thedatabase and your PL/SQL programs directly.16-2. Accessing a PL/SQL Stored Function from JDBCProblemYou want to utilize a PL/SQL function from a Java application that uses the JDBC API to connect to anOracle Database and returns a value to the Java application.SolutionUse the JDBC API and a CallableStatement to invoke the PL/SQL function by passing a Java Stringcontaining the function call to the CallableStatement. The following example demonstrates a Javamethod that accepts a parameter of type double and then makes a JDBC call to the PL/SQL functioncalc_quarter_hour using the parameter. It is assumed that this Java method is to be added into the classthat was created in Recipe 16-1. \npublic void calcQuarterHour(double hours)            throws SQLException {        float returnValue;        int ret_code;        Connection conn = null;        try {            //Load Oracle driver            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());            //Obtain a connection \n        conn = DriverManager.getConnection(&quot;jdbc:oracle:thin:@hostname:1521:mydb&quot;, \n                &quot;user&quot;, &quot;password&quot;); \n\n        CallableStatement pstmt = \n                conn.prepareCall(&quot;&#123;? = call calc_quarter_hour(?)&#125;&quot;); \n        \n        pstmt.registerOutParameter(1, java.sql.Types.FLOAT); \n        pstmt.setDouble(2, hours); \n        pstmt.execute(); \n        returnValue = pstmt.getFloat(1); \n        pstmt.close(); \n        conn.commit(); \n        conn.close(); \n        System.out.println(&quot;The calculated value: &quot; + returnValue); \n    &#125; catch (SQLException e) &#123; \n\n CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON349            ret_code = e.getErrorCode();            System.err.println(ret_code + e.getMessage());            conn.close();        }    }Update the main method from the class that was created in Recipe 16-1 to the following code inorder to make a call to the new calcQuarterHour method. \npublic static void main(String[] args) {        EmployeeFacade facade = new EmployeeFacade();        try {            facade.calcQuarterHour(7.667);        } catch (SQLException e) {            System.err.println(\"A database exception has occurred.\");        }    } \nRunning this code within an integrated development environment such as NetBeans would result inthe following output: \nrun:The calculated value: 7.75BUILD SUCCESSFUL (total time: 1 second) \nValues can be passed as parameters from Java to PL/SQL, and in turn, PL/SQL can pass returnvalues back to Java. This helps form a seamless integration between the two languages.How It WorksCalling a PL/SQL function from a JDBC application is not very much different from using native PL/SQL.The biggest difference is that you need to use the JDBC API to make the database call and to set andretrieve values from the database. The solution to this recipe contains a Java method that accepts adouble value representing a number of hours. The method connects to the Oracle Database using theJDBC, calls the PL/SQL function using a CallableStatement, and then returns the results.To make the connection, the database driver is first registered using theDriverManager.registerDriver() method and passing the appropriate driver for Oracle Database. Next,a connection is obtained using the DriverManager.getConnection() method by passing the URL for theOracle Database that will be used, along with the appropriate user name and password. In Recipe 16-1,obtaining JDBC connections is discussed in more detail. If you haven’t yet read Recipe 16-1 and areunfamiliar with JDBC, we recommend you read it for more information on this important aspect ofusing the JDBC API.Once a connection has been obtained, a CallableStatement is created by calling thejava.sql.Connection prepareCall() method and passing a Java String that contains the call to thePL/SQL function. The function call is in the following format: \n{? = call calc_quarter_hour(?)} \nThe String is surrounded by curly braces ({}), and the call to the PL/SQL function is preceded bythe ? = characters. The question mark (?) character represents a bind variable in a Java preparedstatement.  Bind variables are used to represent the returning value as well as the parameter value thatCHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON350will be passed into the function. The first ? character represents the returning value, whereas the ?character within the parentheses correlates to the parameter being passed to the function. The PL/SQLfunction is invoked using the call keyword followed by the function name.The next line of code registers the return value using the CallableStatementregisterOutParameter() method. This method accepts the bind variable position as its first argumentand accepts the datatype of the value as the second argument. In this example, the datatype isjava.sql.Types.FLOAT, which correlates to a PL/SQL float type. Many different types are available withinjava.sql.Types, and if you are using a Java integrated development environment (IDE) that containscode completion, then you should see a list of all available types after you type the trailing dot whendeclaring java.sql.Type. Next, the parameter that will be passed into the PL/SQL function is set bycalling the setDouble() method and passing the bind variable position along with the value. Lastly, theCallableStatement is executed by invoking the execute() method.If the function call is successful, then the return value of the function can be obtained by calling thegetFloat() method on the CallableStatement and passing the bind variable position. If you were callinga PL/SQL function that had a different return type, then you would use the getter method that correlatesto the return type. This method will return the value of the call, so it should be assigned to a Javavariable. In the solution, returnValue is the variable that is used to hold the value returned from thefunction call. Finally, the CallableStatement is closed, and the transaction is committed by calling thecommit() method on the java.sql.Connection.The entire method is enclosed within a Java exception-handling try-catch block. Code that iscontained within the try block may or may not throw an exception. If an exception is thrown, then it canbe caught by a subsequent catch block. For more information on Java exception handling, please see thedocumentation at http://download.oracle.com/javase/tutorial/essential/exceptions/handling.html.Interacting with PL/SQL functions from within a Java application can be quite powerful. You willgain the most benefit if the function that you are calling is working with the data. Any application that isnot stored in the database will incur at least a minor performance hit when working with the databasebecause of connections and round-trips to and from the database server. If you have a PL/SQL functionthat works with the database, then it can be more efficient to call the PL/SQL function from your Javaapplication rather than reproducing that function in Java code.16-3.  Accessing PL/SQL Web Procedures with HTTPProblemYou are developing a Java web application that uses an Oracle Database. You have already created aPL/SQL web application that displays some particular data from your database that is generated from aninput identifier. You want to use the PL/SQL web application to display that data by passing thenecessary input from the Java web application.SolutionWrite your PL/SQL web program to accept parameter values within a URL. Pass the values from yourJava web application to the PL/SQL application by embedding them within the URL that calls it. Whenthe URL is clicked, then it will redirect control to the PL/SQL application, passing the parameters thatare required to display the correct data. Suppose, for example, that you are writing a Java webapplication that generates a list of employees on a web page. Suppose further that you have alreadywritten PL/SQL web application that, given an employee_id, displays employee record details in abrowser. You want to combine that functionality with your Java program so that when you click one ofthe employees in the list generated by the Java web program, it passes the selected employee’s ID to the CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON351PL/SQL web program. In turn, the PL/SQL program will display the detail for that ticket. In the followingexample, the EMP_RPT package that was introduced in Recipe 14-4 is accessed via a Java Server Facespage. Note JSF is the Java standard for creation of server-side user interfaces. To learn more about this technology,please see the online documentation at www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html. \n \n \n&lt;body&gt; \n\n    &lt;ui:composition template=&quot;layout/my_layout.xhtml&quot;&gt; \n\n        &lt;ui:define name=&quot;body&quot;&gt; \n            &lt;f:view id=&quot;employeeView&quot;&gt; \n                &lt;h:form id=&quot;employeeResults&quot;&gt; \n                    &lt;center&gt; \n\n                        &lt;br/&gt; \n                        &lt;h:messages id=&quot;messages&quot; \n                                    errorClass=&quot;error&quot; \n                                    infoClass=&quot;info&quot; /&gt; \n                        &lt;br/&gt; \n                        &lt;span class=&quot;sub_head_sub&quot;&gt; \n                            Employee Listing \n                        &lt;/span&gt; \n                        &lt;br/&gt; \n                        &lt;br/&gt; \n\n                        &lt;h:dataTable id=&quot;employeeList&quot; \n                                     rows=&quot;20&quot; \n                                     value=&quot;#&#123;employeeList&#125;&quot; \n                                     var=&quot;emp&quot;&gt; \n                            &lt;f:facet name=&quot;header&quot;&gt; \n                                &lt;h:column &gt; \n                                    &lt;h:outputText value=&quot;First Name&quot;/&gt; \n                                &lt;/h:column&gt; \n                                &lt;h:column &gt; \n                                    &lt;h:outputText value=&quot;Last Name&quot;/&gt; \n\nCHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON352                                                                                                                                                                                     \n                            &lt;h:column id=&quot;firstNameCol&quot;&gt; \n                                &lt;h:outputText id=&quot;firstName&quot; value=&quot;#&#123;emp.firstName&#125;&quot;/&gt; \n                            &lt;/h:column&gt; \n                            &lt;h:column id=&quot;lastNameCol&quot;&gt; \n                                &lt;h:outputText id=&quot;lastName&quot; value=&quot;#&#123;emp.lastName&#125;&quot;/&gt; \n                            &lt;/h:column&gt; \n\n                            &lt;h:column id=&quot;emailCol&quot;&gt; \n                                &lt;h:outputLink value=&quot;http://my-oracle-application-\n\nserver:7778/DAD/emp_rpt.rpt\"                                            target=\"_blank\">                                                                                                                                                     \n                        &lt;/h:dataTable&gt; \n\n\n\n                    &lt;/center&gt; \n                &lt;/h:form&gt; \n\n            &lt;/f:view&gt; \n\n        &lt;/ui:define&gt; \n\n    &lt;/ui:composition&gt; \n\n&lt;/body&gt; \n\n \n \nThe JSF tags in this example would generate a web page that looks similar to Figure 16-1. However,it is important to note that JSF contains template functionality, so the look and feel of the user interfacecan be changed significantly if a different template were applied. CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON353 \nFigure 16-1.  Employee listing JSF web page \nFor the sake of brevity, the Java code will not be displayed, because it is not essential for thissolution. However, if you want to learn more about writing Java web applications utilizing the JavaServer Faces web framework, please see the online documentation available atwww.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html.When you look at the JSF page output on your monitor, you’ll see that the EMAIL column values areblue. This signifies that they are links that will take you to another page when selected with the mouse.In this case, the link will redirect users to a PL/SQL application that accepts the employee ID as inputand in turn displays a result. Figure 16-2 shows the output from the PL/SQL web application when the e-mail user name SKING is selected from the JSF page. \nCHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON354 \nFigure 16-2.  PL/SQL web application output \nHow It WorksDeveloping Java web applications and PL/SQL web applications can be quite different. However,accessing one from the other can be quite easy and can create powerful solutions. In this recipe, amashup consisting of a standard web URL passes data from a Java application to a PL/SQL storedprocedure, and then the PL/SQL stored procedure displays content via a web page.The PL/SQL stored procedure in this recipe utilizes the built-in UTL_HTTP package to display content inHTML format via the Web. The procedure accepts one argument, an EMPLOYEE_ID. The given EMPLOYEE_IDfield is used to query the database, and the content that is retrieved is displayed. The procedure isaccessible from the Web because a Data Access Descriptor (DAD) has been created on the web server,which allows access to a particular schema’s web-accessible content. Using the DAD, a URLincorporating the host name, the DAD, and the procedure to be used can access the stored procedure.Please see Recipe 14-1 to learn more about creating DADs. For more details regarding the creation ofweb content using PL/SQL, please refer to Chapter 14.The Java application Extensible Hypertext Markup Language (XHTML) page that is displayed in thesolution to this recipe creates a listing of employee names by querying the database using EJBtechnology. Enterprise Java Beans (EJB) is part of the Java Enterprise Edition stack that is used for objectrelational mapping of Java code and database entities. For more information regarding EJB technology,please refer to the documentation at www.oracle.com/technetwork/java/index-jsp-140203.html. The important code for this particular recipe is the web page code that resides within the JavaServer Faces XHTML page. The generated list of employee names is a list of URLs that contain the hostname of the Oracle Application Server, the DAD for the schema containing the PL/SQL you want toaccess, and the name of the PL/SQL stored procedure, which is EMP_RPT.RPT in this case. The URL alsocontains an embedded parameter that is passed to the stored procedure upon invocation. The followingcode shows an example of a URL that is generated by the Java application: \n \nThe code that generates this URL is written in Java Server Faces using Facelets markup, as shown \nhere: \n \n spool offWhat if one of your test cases fails? Suppose that one of the test cases for the FACTORIAL test hasbeen modified so that a failure will result. Following is the resulting output from a failed unit test.SQL> exec utPLSQL.test('factorial', recompile_in => FALSE). \n\n FFFFFFF   AA     III  L      U     U RRRRR   EEEEEEE F        A  A     I   L      U     U R    R  E F       A    A    I   L      U     U R     R E F      A      A   I   L      U     U R     R E FFFF   A      A   I   L      U     U RRRRRR  EEEECHAPTER 17  UNIT TESTING WITH UTPLSQL372 F      AAAAAAAA   I   L      U     U R   R   E F      A      A   I   L      U     U R    R  E F      A      A   I   L       U   U  R     R E F      A      A  III  LLLLLLL  UUU   R     R EEEEEEE.FAILURE: \"factorial\".Individual Test Case Results: \n\nSUCCESS - factorial.UT_FACTORIAL: ISNULL \"is NULL test\" Expected \"\" and got \"\" \n\n\nSUCCESS - factorial.UT_FACTORIAL: EQQUERY \"0! Test\" Result: Result set for\"select factorial(0) from dual does match that of \"select 1 from dual\" \n\n\nSUCCESS - factorial.UT_FACTORIAL: EQQUERY \"1! Test\" Result: Result set for\"select factorial(1) from dual does match that of \"select 1 from dual\" \n\n\nFAILURE - factorial.UT_FACTORIAL: EQQUERY \"N! Test\" Result: Result set for\"select FACTORIAL(5) from dual does  not match that of \"select 121 from dual\" \n\nErrors recorded in utPLSQL Error Log: \n\n CHAPTER 17  UNIT TESTING WITH UTPLSQL373 \n\nNONE FOUND \n\nPL/SQL procedure successfully completed.How It WorksThe utPLSQL framework makes it easy to execute all of the tests that you have setup within a unit testpackage; you need only to enter a utPLSQL.test command. In the solution to this recipe, the SETSERVEROUT ON command enables output from the DBMS_OUTPUT statements within the utPLSQL.testprocedure. Without this command you cannot view the results of the unit test. The call to theutPLSQL.test procedure passes two parameters, the first is the name of the unit test to run. Notice thatyou do not specify the name of the package built for the unit test. Instead, you pass the name of thefunction being tested. The second parameter tells the utPLSQL.test procedure not to recompile any ofthe code before running the test.17-6. Building a utPLSQL Test SuiteProblemYou have created numerous unit test procedures that you must run every time you modify your code.Running each test individually is both time-consuming and error-prone, as you may forget to run a testor two. You need a simple method to run all of your tests at once.SolutionUse the utsuite.add command of utPLSQL to build a test suite, use the utPackage.add command to addindividual unit tests to it, and then run the result. For example, here’s how to build a suite to run the unittests you developed in Recipes 17-3 and 17-4.Create the test suite.exec utSuite.add ('My Test Suite', 'Test all my functions');Add individual unit tests to the suite.exec utPackage.add ('My Test Suite', 'calc_quarter_hour');exec utPackage.add ('My Test Suite', 'factorial');Run the test suite. See recipe 17-7.How It WorksThe utSuite.add routine creates a new test suite using the text in the first parameter as its unique name.Note that the utPLSQL utility uppercases the suite name before saving, so take that into consideration, assuite names must be unique. The second parameter is descriptive text for your test suite.Once the suite is created, use the utPackage.add procedure to add existing unit tests to the suite. Thefirst parameter must match the name of an existing test suite. The second parameter is the name of theunit test to run. As more unit tests are developed, they can be added to the suite to provide an easymethod to run all tests at once.CHAPTER 17  UNIT TESTING WITH UTPLSQL37417-7. Running a utPLSQL Test SuiteProblemYou have defined a test suite and now wish to run the tests.SolutionUse the utPLSQL.testSuite routine to run your tests. For example, here’s how run the test suite definedin Recipe 17-6. \nexec utPLSQL.testSuite ('My Test Suite', recompile_in=>false); \nExecuting the above test suite produces the following results.SQL> exec utPLSQL.testSuite ('My Test Suite', recompile_in=>false);. \n\n   SSSS   U     U   CCC     CCC   EEEEEEE   SSSS     SSSS  S    S  U     U  C   C   C   C  E        S    S   S    S S        U     U C     C C     C E       S        S  S       U     U C       C       E        S        S   SSSS   U     U C       C       EEEE      SSSS     SSSS       S  U     U C       C       E             S        S        S U     U C     C C     C E              S        S  S    S   U   U   C   C   C   C  E        S    S   S    S   SSSS     UUU     CCC     CCC   EEEEEEE   SSSS     SSSS.SUCCESS: \"FACTORIAL\".Individual Test Case Results: \n\n CHAPTER 17  UNIT TESTING WITH UTPLSQL375SUCCESS - FACTORIAL.UT_FACTORIAL: ISNULL \"is NULL test\" Expected \"\" and got \"\" \n\n\nSUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY \"0! Test\" Result: Result set for \"selectfactorial(0) from dual does match that of \"select 1 from dual\" \n\n\nSUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY \"1! Test\" Result: Result set for \"selectfactorial(1) from dual does match that of \"select 1 from dual\" \n\n\nSUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY \"N! Test\" Result: Result set for \"selectFACTORIAL(5) from dual does match that of \"select 120 from dual\" \n\nErrors recorded in utPLSQL Error Log: \nNONE FOUND.   SSSS   U     U   CCC     CCC   EEEEEEE   SSSS     SSSS  S    S  U     U  C   C   C   C  E        S    S   S    S S        U     U C     C C     C E       S        S  S       U     U C       C       E        S        S   SSSS   U     U C       C       EEEE      SSSS     SSSS       S  U     U C       C       E             S        S        S U     U C     C C     C E              S        S  S    S   U   U   C   C   C   C  E        S    S   S    S   SSSS     UUU     CCC     CCC   EEEEEEE   SSSS     SSSSCHAPTER 17  UNIT TESTING WITH UTPLSQL376.SUCCESS: \"CALC_QUARTER_HOUR\".Individual Test Case Results: \n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: ISNULL \"NULL value\" Expected \"\" and got \"\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .10 rounds down\"Result: Result set for \"select calc_quarter_hour(6.10) from dual does match that of \"select6 from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .15 rounds up\" Result:Result set for \"select calc_quarter_hour(6.15) from dual does match that of \"select 6.25from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .35 rounds down\"Result: Result set for \"select calc_quarter_hour(6.35) from dual does match that of \"select6.25 from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .40 rounds up\" Result:Result set for \"select calc_quarter_hour(6.40) from dual does match that of \"select 6.5 fromdual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .65 rounds up\" Result:Result set for \"select calc_quarter_hour(6.65) from dual does match that of \"select 6.75from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .83 rounds down\"Result: Result set for \"select calc_quarter_hour(6.83) from dual does match that of \"select7 from dual\" CHAPTER 17  UNIT TESTING WITH UTPLSQL377 \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .92 rounds up\" Result:Result set for \"select calc_quarter_hour(6.92) from dual does match that of \"select 7 fromdual\" \n\nErrors recorded in utPLSQL Error Log: \nNONE FOUNDIf you happen to have a test fail, then the output of the test suite will display a failure message forthe unit test that failed. In the following output, one of the test cases for the FACTORIAL unit test fails. FFFFFFF   AA     III  L      U     U RRRRR   EEEEEEE F        A  A     I   L      U     U R    R  E F       A    A    I   L      U     U R     R E F      A      A   I   L      U     U R     R E FFFF   A      A   I   L      U     U RRRRRR  EEEE F      AAAAAAAA   I   L      U     U R   R   E F      A      A   I   L      U     U R    R  E F      A      A   I   L       U   U  R     R E F      A      A  III  LLLLLLL  UUU   R     R EEEEEEE.FAILURE: \"FACTORIAL\".Individual Test Case Results:CHAPTER 17  UNIT TESTING WITH UTPLSQL378 \n\nSUCCESS - FACTORIAL.UT_FACTORIAL: ISNULL \"is NULL test\" Expected \"\" and got \"\" \n\n\nSUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY \"0! Test\" Result: Result set for\"select factorial(0) from dual does match that of \"select 1 from dual\" \n\n\nSUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY \"1! Test\" Result: Result set for\"select factorial(1) from dual does match that of \"select 1 from dual\" \n\n\nFAILURE - FACTORIAL.UT_FACTORIAL: EQQUERY \"N! Test\" Result: Result set for\"select FACTORIAL(5) from dual does  not match that of \"select 121 from dual\" \n\nErrors recorded in utPLSQL Error Log: \nNONE FOUND.   SSSS   U     U   CCC     CCC   EEEEEEE   SSSS     SSSS  S    S  U     U  C   C   C   C  E        S    S   S    S S        U     U C     C C     C E       S        S  S       U     U C       C       E        S        S   SSSS   U     U C       C       EEEE      SSSS     SSSS       S  U     U C       C       E             S       S CHAPTER 17  UNIT TESTING WITH UTPLSQL379        S U     U C     C C     C E              S        S  S    S   U   U   C   C   C   C  E        S    S   S    S   SSSS     UUU     CCC     CCC   EEEEEEE   SSSS     SSSS.SUCCESS: \"CALC_QUARTER_HOUR\".Individual Test Case Results: \n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: ISNULL \"NULL value\" Expected\"\" and got \"\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .10 roundsdown\" Result: Result set for \"select calc_quarter_hour(6.10) from dual doesmatch that of \"select 6 from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .15 roundsup\" Result: Result set for \"select calc_quarter_hour(6.15) from dual does matchthat of \"select 6.25 from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .35 roundsdown\" Result: Result set for \"select calc_quarter_hour(6.35) from dual doesmatch that of \"select 6.25 from dual\" \n\n\nCHAPTER 17  UNIT TESTING WITH UTPLSQL380SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .40 roundsup\" Result: Result set for \"select calc_quarter_hour(6.40) from dual does matchthat of \"select 6.5 from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .65 roundsup\" Result: Result set for \"select calc_quarter_hour(6.65) from dual does matchthat of \"select 6.75 from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .83 roundsdown\" Result: Result set for \"select calc_quarter_hour(6.83) from dual doesmatch that of \"select 7 from dual\" \n\n\nSUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY \"Check that .92 roundsup\" Result: Result set for \"select calc_quarter_hour(6.92) from dual does matchthat of \"select 7 from dual\" \n\nErrors recorded in utPLSQL Error Log: \nNONE FOUNDPL/SQL procedure successfully completed. CHAPTER 17  UNIT TESTING WITH UTPLSQL381How It WorksThe utPLSQL.testSuite procedure steps though each unit test added using the utPackage.add procedureand executes each test. In turn, each test executes and sends its results to the screen. This is a quickmethod to run all tests and see the output on one screen capture. If one of the test cases within a unittest fails, all of the remaining tests in the suite will continue to execute, and the test that failed will benoted in the output. This is very useful as it will allow tests of many PL/SQL objects at once, and you willbe able to see which tests had issues and which did not.■ Hint Spool the output to a file if the number of tests exceeds the screen buffer’s capacity.17-8. Reconfiguring utPLSQL ParametersProblemYou would like to change some of the configurations for your utPLSQL install. For instance, you wouldlike to change the prefix for all of your unit test packages so that, instead of beginning with ut_, they allstart with test_.SolutionUse the utConfig package to alter the configurations for utPLSQL. For this solution, you will see howutConfig can be used to change the prefix that is used for all of your test packages. For example, here’show to change the prefix for your test packages from ut_ to test_ using the utConfig package for thecurrent schema. \n\nSQL> exec utConfig.setPrefix('test_'); \nPL/SQL procedure successfully completed. \nAfter executing the statement in the example, the utPLSQL unit test framework will look for testpackages beginning with the test_ prefix rather than ut_ within the current schema, until the prefix ischanged again using the utConfig package.How It WorksThe utPLSQL test framework can be configured to operate differently from its default manner bychanging options using the utConfig package. Changes can be made for the current schema only, or forall schemas within the database. In the solution to this recipe, you have seen that the prefix for testpackages is configurable. To change the prefix, pass the desired prefix in string format toutConfig.setPrefix(). The setPrefix() procedure also accepts an additional schema name that willspecify the schema to which the configuration option will be applied. If you do not pass a schema name,the changes will occur within the current schema. The actual format for executing theutConfig.setPrefix procedure is as follows: \nexec utConfig.setPrefix(desired_prefix, [schema]);CHAPTER 17  UNIT TESTING WITH UTPLSQL382There are many configurable options that can be changed using the utConfig package. Table 17-2shows the complete list of options.Table 17-2. utConfig Configuration OptionsOption DescriptionutConfig.autocompile Configure autocompile featureutConfig.registertest Configure the registration mode (manual or automatic)utConfig.setdateformat Configure the date format for the date portion of output file namesutConfig.setdelimiter Configure the V2 delimiterutConfig.setdir Configure the directory containing the test package codeutConfig.setfiledir Configure the directory for file outpututConfig.setfileextension Configure the file extension for output file namesutConfig.setfileinfo Configure all of the above file output related itemsutConfig.setincludeprogname Configure whether to include the name of the program being testedwithin output file namesutConfig.setprefix Configure the default unit test prefixutConfig.setreporter Configure the default Output ReporterutConfig.settester Configure whose configuration is usedutConfig.setuserprefix Configure the user prefix for output file namesutConfig.showfailuresonly Switch off the display for successful tests \nYou can set of the options shown here using a syntax similar to that shown for the setPrefix()procedure that was demonstrated in the solution to this recipe. For more information on using theconfigurations listed in Table 17-2, please see the online documentation that can be found at:http://utplsql.oracledeveloper.nl/. Along with configurable options, the utConfig package includessome functions that can be called to retrieve information regarding the unit test configuration for thedatabase or for a particular schema. Table 17-3 contains a listing of the options that utConfig makesavailable for obtaining information. CHAPTER 17  UNIT TESTING WITH UTPLSQL383Table 17-3. utConfig Informational OptionsOption Name DescriptionutConfig.autocompiling Returns autocompile flag valueutConfig.dateformat Returns date format used to construct output file namesutConfig.delimiter Returns V2 delimiterutConfig.dir Returns directory containing the test package codeutConfig.filedir Returns file output directoryutConfig.fileextension Returns output file name extensionutConfig.fileinfo Returns all file output—related itemsutConfig.getreporter Obtains name of the default Output Reporter to useutConfig.includeprogname Returns whether to include the name of the program being testedwithin file namesutConfig.prefix Returns default unit test prefix for your codeutConfig.registering Returns registration modeutConfig.showconfig Displays a schema configurationutConfig.showingfailuresonly Returns whether successful test results are displayedutConfig.tester Returns the schema whose configuration is usedutConfig.userprefix Returns the user prefix for output files \nThe functions can be called just as if they were standard functions within your schema. Some, suchas the utConfig.showconfig procedure, require you to set serveroutput on in order to display the output.The following excerpt from a SQL*Plus session shows a call to utConfig.showconfig. \nSQL> set serveroutput onSQL> exec utconfig.showconfig=============================================================utPLSQL Configuration for USERNAMEDirectory:Autcompile?Manual test registration?Prefix =CHAPTER 17  UNIT TESTING WITH UTPLSQL384Default reporter     =----- File Output settings:Output directory:User prefix     =Include progname?Date format     =File extension  =----- End File Output settings============================================================= \nPL/SQL procedure successfully completed. \nThe utConfig package contains a variety of configurable options that will allow you to adjust unittesting according to your specific needs. Out of the box, the utPLSQL testing framework contains defaultvalues for each of these options, so you may never need to touch utConfig, but the option is available ifyou need it. Another nice feature is that you can set configurable options for a specific schema. Doing sowill allow different schemas in the database to act differently when performing unit testing.17-9. Redirecting utPLSQL Test Results to a FileProblemYou are interested in writing the results of a unit test to a file.SolutionChange the setting of the setreporter option of utPLSQL so that output is redirected to a file instead ofDBMS_OUTPUT. Once the configuration has been altered, execute the unit tests for which you would like tohave the output captured to the file. After you’ve run your tests, close the file and change theconfiguration back to its default. In the following lines of code, all of the steps that are necessary forredirecting test results to a file are exhibited. For example, suppose that the database has a directory thathas already been enabled for use with the database named FILE_SYSTEM. \nSQL>  BEGIN  utconfig.setfiledir('FILE_SYSTEM');  -- Causes output to be redirected to file system  utconfig.setreporter('File');  utPLSQL.test('calc_quarter_hour');  -- Closes the fle  utfilereporter.close();  -- Returns output redirection to DBMS_OUTPUT  utconfig.setreporter('Output');END; \nPL/SQL procedure successfully completed. \nWhen the code block in this example is executed, a file will be created within the directoryrepresented by FILE_SYSTEM. The unit test for CALC_QUARTER_HOUR will then be executed and the resultswill be redirected to the newly created file. Lastly, the file will be closed and the output will be redirectedback to DBMS_OUTPUT. CHAPTER 17  UNIT TESTING WITH UTPLSQL385How It WorksOne of the configurable options of utPLSQL allows for the output of your unit tests to be redirected. Thechoices for displaying unit test results include Output, File, and HTML. The standard Output option isOutput , which causes output to be displayed within the SQLPlus environment using DBMS_OUTPUT. TheFile option allows for a file to be created and unit test results to be written to that file. Lastly, the HTMLoption allows for unit test results to be formatted into file in the format of an HTML table. In the solutionto this recipe, the use of the File output reporter is demonstrated.Prior to redirecting unit test output to a file, you must create a database directory using the CREATEDIRECTORY statement with a privileged account. For more information about creating directories, pleasesee the Oracle documentation that can be found at:http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/statements_5007.htm#SQLRF01207.Once you have created a database directory, you can use it to write the results of unit tests by setting thefile directory using the utConfig.setfiledir() procedure. This procedure accepts the name of thedatabase directory as a parameter. In the solution to this recipe, the directory is named FILE_SYSTEM. Toredirect the unit test output from utPLSQL, you must use the utConfig.setreporter() procedure. Thisprocedure accepts the name of the reporter that you would like to use for displaying output. As you cansee from the solution to this recipe, the File reporter is chosen to redirect the output to a file on the filesystem. It is also possible to create a custom reporter configuration that you can pass to theutConfig.setreporter() procedure. For more information about creating customized reporters, pleasesee the utPLSQL documentation that can be found at:http://utplsql.sourceforge.net/Doc/reporter.html.After the output has been redirected using utConfig.setreporter(), you can run as many tests asyou wish and all of the output will be directed to a file instead of to the SQLPlus command prompt. Inthe solution to this recipe, the CALC_QUARTER_HOUR function is tested. Once you have finished runningyour tests, you must close the output file in order to make it available for you to use. If you fail to closethe file, you will be unable to open it or use it because the database will maintain a lock on the file. Toclose the file, use issue utfilereporter.close(). Lastly, I recommend redirecting unit test output to thedefault Ouput option, which will cause it to be sent to DBMS_OUTPUT. By doing so, the next person who runsa unit test will receive the functionality that he or she expects by default, as the output will be directed tothe screen. It is a good idea to set the default output at the beginning of all test suites just to ensure thatyou know where the output will be directed. However, if you are the only person running unit tests, or ifyou prefer to maintain the File reporter as your default, then omit the final call toutConfig.setreporter() that is shown in this solution.Many times it can be useful to have unit test results redirected to an output file rather thandisplayed within the SQLPlus environment. For instance, if you are running unit tests during off hoursand would like to see the output, then it would be helpful to have it recorded to a file that can be viewedat a later time. Similarly, if you are running several unit tests, it may be easier to read through a file ratherthan scrolling through SQLPlus output. Whatever the requirement may be, utPLSQL makes it easy toredirect unit test output to a file or another device by creating a custom reporter.17-10. Automating Unit Tests for PL/SQL and Java Stored ProceduresUsing AntProblemYou wish to automatically run your unit tests for PL/SQL code and Java stored procedures each day andto write the results of the unit test to a file.CHAPTER 17  UNIT TESTING WITH UTPLSQL386SolutionUse Apache’s Ant build system to perform unit testing on your PL/SQL code. At the same time, Ant canbuild and compile any Java code that you will be using for your stored procedures. To do so, develop anAnt build script that will execute some SQL statements, automate your unit tests, and compile Javasource into a directory. For example, the following build.xml file is an example of such a build that canbe used to compile Java sources and execute unit tests on PL/SQL within a single Ant run. \n \n     \n        PLSQL Unit Test and Application Builder \n     \n   \n   \n   \n   \n   \n   \n \n   \n     \n     \n     \n   \n \n                 \n            call utconfig.setfiledir('FILE_SYSTEM');      call utconfig.setreporter('File');      call utPLSQL.test('calc_quarter_hour');      -- Closes the fle      call utfilereporter.close();      -- Returns output redirection to DBMS_OUTPUT      call utconfig.setreporter('Output'); \n&lt;/sql&gt; \n\n   \n CHAPTER 17  UNIT TESTING WITH UTPLSQL \n387 \n \n \nThis build script can be executed by issuing the ant command from within the terminal orcommand prompt. The results will resemble the following output.juneau$ antBuildfile: /Users/juneau/Documents/PLSQL_Recipes/sources/17/build.xml \ninit: \ncompile:    [javac] /Users/juneau/Documents/PLSQL_Recipes/sources/17/build.xml:22: warning:'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false forrepeatable builds \nunitTest:      [sql] Executing commands      [sql] 0 rows affected      [sql] 0 rows affected      [sql] 0 rows affected      [sql] 0 rows affected      [sql] 0 rows affected      [sql] 5 of 5 SQL statements executed successfully \nBUILD SUCCESSFULTotal time: 4 secondsCHAPTER 17  UNIT TESTING WITH UTPLSQL388How It WorksAutomating unit tests can be very helpful, especially if you are working on a project where there may bemore than one developer contributing code. The Apache Ant build system is useful for automatingbuilds and unit tests for Java projects. However, it can also be used to perform a myriad of other tasks,including issuing SQL statements, as seen in the solution to this recipe. Ant provides an entire build andunit test solution that is easy to use. To set up a build, all you need to do is install Ant on your machineand then create a build.xml file that consists of targets that Ant will use to build the project. Once youhave created a build file, then simply open a command prompt or terminal and traverse into thedirectory containing your build file. Once in the directory, issue the ant command and it willautomatically look for a file named build.xml that will provide Ant the sequence used for the build.Ant uses simple logic to determine the order of sequence that will be used to execute the targets thatare listed within the build.xml file. In the solution to this recipe, the build file contains three targets,init, compile, and unitTest. Ant will start the build by executing the target listed within the tag as the default. In this case, the default target is unitTest.  \n \n \nThe unitTest target contains a depends attribute, which lists the compile target. This tells Ant thatthe compile target should be executed first because unitTest depends upon its outcome.  \n \nConsequently, the compile target depends upon the init target, so init will be executed beforecompile.  \n \nThe order of target execution for the solution to this recipe will be the init target first, followed bythe compile target, and lastly the unitTest target. The project tag also contains an attribute namedbasedir. This attribute tells Ant where the build files should be located. In the solution to this recipe,basedir contains a period “.” that tells Ant to use the current directory.At the top of the build file, you can see that there is a  tag. This is used to provide abrief description of the tasks completed by the build file. There are also several  tags. Thesetags are used to define the variables that will be used within the build file. Each  tag contains aname attribute and either a value or location attribute.  \n   \n   \n   \n   \n   \n \nThe properties that use a value attribute are used to assign values to the property name, whereas theproperties that contain location attributes are used to assign a location to the property name. Propertiescan be referenced within the build file by using the following syntax: “${property_name}”. As you can seefrom the solution to this recipe, each target within the build file consists of a number of tasks in the formof XML tags. The init target creates a timestamp by using the  tag, and it creates a directory CHAPTER 17  UNIT TESTING WITH UTPLSQL389using the  tag and passing the name of a directory to be created. In this case, the directory namewill be named the same as the value that is assigned to the  tag that is named build.  \n \n     \n     \n     \n   \n \nThe compile target is used to compile all of the Java sources contained in the project. All of thesources should reside within a named directory that is located in the base directory of the Ant project.The compile target contains a single task using the  tag. This tag contains a src attribute thatdefines the location of the sources to be compiled, and a destdir attribute that tells Ant where to placethe resulting Java class files. An Ant project that builds a Java project may contain only this task, but canbuild several hundred Java class files. In the solution to this recipe, and for most Ant uses with PL/SQLprojects, however, the project will probably contain no Java source files or only a few at most. If a projectcontains no Java source files, then the target will be executed, but the  task will do nothing sincethere are not any sources to be compiled. \n               \nThe most important target in the solution to this recipe is the unitTest target. It consists of a singletask using the  tag. The sole purpose of the  task is to execute SQL within a designateddatabase. The  tag contains a driver attribute that is used to list the JDBC driver for the targetdatabase, a url attribute used to define the JDBC URL for the target database, a userid and passwordattribute for defining the database username and password, and a print attribute that tells Ant whetherto print the result sets from the SQL statements. In the solution to this recipe, the SQL that is required toexecute the unit tests is contained within the  opening and closing tags. This causes the unit tests tobe executed as if you were issuing these statements at the SQL*Plus command prompt. \n          call utconfig.setfiledir('FILE_SYSTEM');      call utconfig.setreporter('File');      call utPLSQL.test('calc_quarter_hour');      -- Closes the fle      call utfilereporter.close();      -- Returns output redirection to DBMS_OUTPUT      call utconfig.setreporter('Output');CHAPTER 17  UNIT TESTING WITH UTPLSQL390     \n   \nTo automate your Ant build, you will need to set up an operating system task that starts the Ant\nbuild. The task is very simple and needs to contain only very few lines. The following lines of code\ncontain batch script for the Windows operating system that can be used to invoke the Ant build. This\nassumes that the java.exe executable is contained within the PATH environment variable. \ncd C:/path_to_project_directory\nant \nYou will also need to ensure that the JDBC driver for the Oracle database is contained within your\nCLASSPATH. If you do not include the JDBC driver in the CLASSPATH, then you will receive an error when\nyou try to execute the build. When the Ant build is executed, a file will be placed onto the database server\nin the location designated by the FILE_SYSTEM database directory. The file will contain the results of the\nunit test execution. \nAnt is a complex build system that can be used for configuration and preparation of your builds and unit\ntests. It is a widely used build system, especially for organizations that do lots of Java development. As\nyou can see, it is easy to use, but does contain complexity in that there are a number of different tasks\nand attributes that can be used. This recipe does not even scratch the surface of everything that Ant can\ndo. However, there are lots of sources for documentation on Ant that can be found online as well as in\nbook format. To learn more about Ant, you can start by reading the online documentation that can be\nfound at: http://ant.apache.org/manual/. ","dateCreated":"2022-11-03T00:12:20+08:00","dateModified":"2022-11-05T17:08:59+08:00","datePublished":"2022-11-03T00:12:20+08:00","description":"摘要: 其实这个讲PLSQL有点基础","headline":"Oracle PLSQL Recipes","image":[null,"https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://simonteo58.github.io/2022/11/03/oracle/OraclePL_SQL_Recipes/"},"publisher":{"@type":"Organization","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://simonteo58.github.io/2022/11/03/oracle/OraclePL_SQL_Recipes/","thumbnailUrl":"https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"}</script>
    <meta name="description" content="摘要: 其实这个讲PLSQL有点基础">
<meta property="og:type" content="blog">
<meta property="og:title" content="Oracle PLSQL Recipes">
<meta property="og:url" content="https://simonteo58.github.io/2022/11/03/oracle/OraclePL_SQL_Recipes/index.html">
<meta property="og:site_name" content="CoffeeMan">
<meta property="og:description" content="摘要: 其实这个讲PLSQL有点基础">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png">
<meta property="article:published_time" content="2022-11-02T16:12:20.661Z">
<meta property="article:modified_time" content="2022-11-05T09:08:59.540Z">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/avatar.jpg"/>
    
    
    
        <meta property="og:image" content="https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-y9io9e1ok9lpsmk4fyk7quzstdgr6eztu8x2xr6n9iikjgfjbcqqpobdlqy8.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CoffeeMan
        </a>
    </div>
    
        
            <a
                class="header-right-picture open-algolia-search"
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/SimonTeo58"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/11289672/simon-teo"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/shiming_kirk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/kirk-zhang-424935235/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/zxc741208584@qq.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    "
             style="background-image:url('https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg');"
             data-behavior="2">
            
        </div>

            <div id="main" data-behavior="2"
                 class="hasCover
                        hasCoverMetaOut
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Oracle PLSQL Recipes
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-11-03T00:12:20+08:00">
	
		    Nov 03, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/oracle/">oracle</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>摘要: 其实这个讲PLSQL有点基础</p>
<span id="more"></span>

<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-PL-x2F-SQL-Fundamentals"><span class="toc-text">1 PL&#x2F;SQL Fundamentals</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%88%9B%E5%BB%BAplsql%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">1.1 创建plsql代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%9C%A8plsql%E7%A7%8D%E6%89%A7%E8%A1%8Cplsql%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">1.2 在plsql种执行plsql代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-store-code-in-script"><span class="toc-text">1.3 store code in script</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%89%A7%E8%A1%8C%E4%BD%A0%E7%9A%84%E8%84%9A%E6%9C%AC"><span class="toc-text">1.4 执行你的脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%8E%A5%E5%8F%97%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5%E4%BB%8E%E9%94%AE%E7%9B%98%E4%B8%AD"><span class="toc-text">1.5 接受用户的输入从键盘中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Displaying-Results-in-SQL-Plus"><span class="toc-text">1.6 Displaying Results in SQL*Plus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Commenting-Your-Code"><span class="toc-text">1.7 Commenting Your Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-Referencing-a-Block-of-Code"><span class="toc-text">1.8 Referencing a Block of Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-Referring-to-Variables-from-Nested-Blocks"><span class="toc-text">1.9. Referring to Variables from Nested Blocks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-Ignoring-Substitution-Variables"><span class="toc-text">1.10. Ignoring Substitution Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-Changing-the-Substitution-Variable-Character"><span class="toc-text">1.11. Changing the Substitution Variable Character</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-Creating-a-Variable-to-Match-a-Database-Column-Type"><span class="toc-text">1.12. Creating a Variable to Match a Database Column Type</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E7%A1%80sql"><span class="toc-text">2.基础sql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Retrieving-a-Single-Row-from-the-Database"><span class="toc-text">2.1 Retrieving a Single Row from the Database</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Qualifying-Column-and-Variable-Names%EF%BC%88%E5%8F%98%E9%87%8F%E5%92%8C%E8%A1%A8%E5%88%97%E5%90%8D%E7%9B%B8%E5%90%8C"><span class="toc-text">2.2. Qualifying Column and Variable Names（变量和表列名相同)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Declaring-Variable-Types-That-Match-Column-Types"><span class="toc-text">2.3. Declaring Variable Types That Match Column Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record"><span class="toc-text">2.4. Returning Queried Data into a PL&#x2F;SQL Record</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Creating-Your-Own-Records-to-Receive-Query-Results"><span class="toc-text">2.5. Creating Your Own Records to Receive Query Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Looping-Through-Rows-from-a-Query"><span class="toc-text">2.6. Looping Through Rows from a Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Obtaining-Environment-and-Session-Information"><span class="toc-text">2.7. Obtaining Environment and Session Information</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Formatting-Query-Results"><span class="toc-text">2.8. Formatting Query Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-Updating-Rows-Returned-by-a-Query"><span class="toc-text">2.9. Updating Rows Returned by a Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-Updating-Rows-Returned-by-a-Cursor"><span class="toc-text">2.10. Updating Rows Returned by a Cursor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-Deleting-Rows-Returned-by-a-Cursor"><span class="toc-text">2.11. Deleting Rows Returned by a Cursor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-Performing-a-Transaction"><span class="toc-text">2.12. Performing a Transaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-Ensuring-That-Multiple-Queries-%E2%80%9CSee%E2%80%9D-the-Same-Data"><span class="toc-text">2.13. Ensuring That Multiple Queries “See” the Same Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-Executing-One-Transaction-from-Within-Another"><span class="toc-text">2.14. Executing One Transaction from Within Another</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-Finding-and-Removing-Duplicate-Table-Rows"><span class="toc-text">2.15. Finding and Removing Duplicate Table Rows</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Looping-and-Logic"><span class="toc-text">3. Looping and Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Choosing-When-to-Execute-Code"><span class="toc-text">3.1. Choosing When to Execute Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Choosing-Between-Two-Mutually-Exclusive-Conditions"><span class="toc-text">3-2. Choosing Between Two Mutually Exclusive Conditions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Evaluating-Multiple-Mutually-Exclusive-Conditions"><span class="toc-text">3.3. Evaluating Multiple Mutually Exclusive Conditions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Driving-from-an-Expression-Having-Multiple-Outcomes"><span class="toc-text">3.4 Driving from an Expression Having Multiple Outcomes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Looping-Until-a-Specified-Condition-Is-Met"><span class="toc-text">3.5. Looping Until a Specified Condition Is Met</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Iterating-Cursor-Results-Until-All-Rows-Have-Been-Returned"><span class="toc-text">3.6. Iterating Cursor Results Until All Rows Have Been Returned</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Iterating-Until-a-Condition-Evaluates-to-FALSE"><span class="toc-text">3.7. Iterating Until a Condition Evaluates to FALSE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-Bypassing-the-Current-Loop-Iteration"><span class="toc-text">3.8.Bypassing the Current Loop Iteration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Iterating-a-Fixed-Number-of-Times"><span class="toc-text">3.9. Iterating a Fixed Number of Times</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-Iterating-in-Increments-Other-Than-One"><span class="toc-text">3.11 Iterating in Increments Other Than One</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-Stepping-Through-a-Loop-Based-on-Odd-Numbered-Increments"><span class="toc-text">3.12. Stepping Through a Loop Based on Odd-Numbered Increments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-Exiting-an-Outer-Loop-Prematurely"><span class="toc-text">3.13. Exiting an Outer Loop Prematurely</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-Jumping-to-a-Designated-Location-in-Code"><span class="toc-text">3.14. Jumping to a Designated Location in Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Functions-Packages-and-Procedures"><span class="toc-text">4. Functions, Packages,and Procedures</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Creating-a-Stored-Function"><span class="toc-text">4-1. Creating a Stored Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Executing-a-Stored-Function-from-a-Query"><span class="toc-text">4-2. Executing a Stored Function from a Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Optimizing-a-Function-That-Will-Always-Return-the-Same-Result-for-a-Given-Input"><span class="toc-text">4-3. Optimizing a Function That Will Always Return the Same Result for a Given Input</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Creating-a-Stored-Procedure"><span class="toc-text">4-4. Creating a Stored Procedure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Executing-a-Stored-Procedure"><span class="toc-text">4-5. Executing a Stored Procedure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Creating-Functions-Within-a-Procedure-or-Code-Block"><span class="toc-text">4-6. Creating Functions Within a Procedure or Code Block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-Passing-Parameters-by-Name"><span class="toc-text">4-7. Passing Parameters by Name</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-Setting-Default-Parameter-Values"><span class="toc-text">4-8. Setting Default Parameter Values</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-Collecting-Related-Routines-into-a-Single-Unit"><span class="toc-text">4-9. Collecting Related Routines into a Single Unit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-Writing-Initialization-Code-for-a-Package"><span class="toc-text">4-10. Writing Initialization Code for a Package</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-Granting-the-Ability-to-Create-and-Execute-Stored-Programs"><span class="toc-text">4-11. Granting the Ability to Create and Execute Stored Programs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-Executing-Packaged-Procedures-and-Functions"><span class="toc-text">4-12. Executing Packaged Procedures and Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-Creating-a-Public-Name-for-a-Stored-Program"><span class="toc-text">4-13. Creating a Public Name for a Stored Program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14-Executing-Package-Programs-in-Sequence"><span class="toc-text">4-14. Executing Package Programs in Sequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-15-Implementing-a-Failure-Flag"><span class="toc-text">4-15. Implementing a Failure Flag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-16-Forcing-Data-Access-to-Go-Through-Packages"><span class="toc-text">4-16. Forcing Data Access to Go Through Packages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-17-Executing-Stored-Code-Under-Your-Own-Privilege-Set"><span class="toc-text">4-17. Executing Stored Code Under Your Own Privilege Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-18-Accepting-Multiple-Parameter-Sets-in-One-Function"><span class="toc-text">4-18. Accepting Multiple Parameter Sets in One Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-19-Listing-the-Functions-Procedures-and-Packages-in-a-Schema"><span class="toc-text">4-19. Listing the Functions, Procedures, and Packages in a Schema</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-20-Viewing-Source-Code-for-Stored-Programs"><span class="toc-text">4-20. Viewing Source Code for Stored Programs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Triggers"><span class="toc-text">5. Triggers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Automatically-Generating-Column-Values-how-use-before-insert"><span class="toc-text">5-1. Automatically Generating Column Values(how use before insert)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Keeping-Related-Values-in-Sync"><span class="toc-text">5-2. Keeping Related Values in Sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Responding-to-an-Update-of-a-Specific-Table-Column"><span class="toc-text">5-3. Responding to an Update of a Specific Table Column</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Making-a-View-Updatable"><span class="toc-text">5-4. Making a View Updatable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Altering-the-Functionality-of-Applications"><span class="toc-text">5-5. Altering the Functionality of Applications</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Validating-Input-Data"><span class="toc-text">5-6. Validating Input Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-Scrubbing-v-%E7%94%A8%E5%8A%9B%E6%93%A6%E6%B4%97-Input-Data"><span class="toc-text">5-7. Scrubbing(v.用力擦洗) Input Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-Replacing-a-Column%E2%80%99s-Value"><span class="toc-text">5-8. Replacing a Column’s Value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-Triggering-on-a-System-Event"><span class="toc-text">5-9. Triggering on a System Event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-Triggering-on-a-Schema-Related-Event"><span class="toc-text">5-10. Triggering on a Schema-Related Event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-11-Firing-Two-Triggers-on-the-Same-Event"><span class="toc-text">5-11. Firing Two Triggers on the Same Event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-12-Creating-a-Trigger-That-Fires-on-Multiple-Events"><span class="toc-text">5-12. Creating a Trigger That Fires on Multiple Events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-13-Creating-a-Trigger-in-a-Disabled-State"><span class="toc-text">5-13. Creating a Trigger in a Disabled State</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Type-Conversion"><span class="toc-text">6.Type Conversion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Converting-a-String-to-a-Number"><span class="toc-text">6-1. Converting a String to a Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINE-x2F-COL"><span class="toc-text">LINE&#x2F;COL </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ERROR"><span class="toc-text">ERROR </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINE-x2F-COL-1"><span class="toc-text">LINE&#x2F;COL </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ERROR-1"><span class="toc-text">ERROR </span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">Test Page</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ENVIRONMENT"><span class="toc-text">  ENVIRONMENT: </span></a></li></ol>


<h1 id="1-PL-x2F-SQL-Fundamentals"><a href="#1-PL-x2F-SQL-Fundamentals" class="headerlink" title="1 PL&#x2F;SQL Fundamentals"></a>1 PL&#x2F;SQL Fundamentals</h1><h2 id="1-1-创建plsql代码块"><a href="#1-1-创建plsql代码块" class="headerlink" title="1.1 创建plsql代码块"></a>1.1 创建plsql代码块</h2><p>如和创建一个可以执行的plsql代码块？</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- demo 1
begin
  -- 中间写代码
end;

-- demo 2


declare

-- 定义变量

begin 
 -- 业务逻辑
end;</code></pre>

<p>在实际的开发当中，这些代码块会进行嵌套，第一层代码块定义的变量，内层的代码块也可以直接使用</p>
<h2 id="1-2-在plsql种执行plsql代码块"><a href="#1-2-在plsql种执行plsql代码块" class="headerlink" title="1.2 在plsql种执行plsql代码块"></a>1.2 在plsql种执行plsql代码块</h2><p>如何在sqlplus中执行plsql代码?</p>
<p>登录sqlplus就可以直接输入自己的代码，然后<code>end;</code>结束代码块，并且接着输入<code>/</code>,这时候sqlplus解释器就可以执行代码了。<br>但是有一点需要明确，如果你的代码块是以<code>declare</code>开头的，那么就会直接输出到屏幕</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">sql&gt; begin
DBMS_OUTPUT.put_line(&quot;hello world&quot;)
end;
&#x2F;</code></pre>

<p>但是如果你想创建package,function,procedure,可以使用如下语句，方便后面的调用</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; CREATE OR REPLACE PROCEDURE hello_world AS 
 BEGIN 
 DBMS_OUTPUT.PUT_LINE(&#39;Hello World&#39;); 
 END; 
 &#x2F; </code></pre>

<h2 id="1-3-store-code-in-script"><a href="#1-3-store-code-in-script" class="headerlink" title="1.3 store code in script"></a>1.3 store code in script</h2><p>如果你想通过sql脚本执行代码，该如何运行？</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SET SERVEROUTPUT ON;
DECLARE 
 counter NUMBER;
BEGIN 
  FOR counter IN REVERSE 0..10 LOOP 
  DBMS_OUTPUT.PUT_LINE (counter); 
  END LOOP; 
END;
&#x2F;</code></pre>
<p>你可以保存你的plsql代码在脚本里,重要一步是要保证你的文件扩展名是<code>.sql</code><br>SQL Developer supports a number of additionalextensions for more specific types of PL&#x2F;SQL. </p>
<h2 id="1-4-执行你的脚本"><a href="#1-4-执行你的脚本" class="headerlink" title="1.4 执行你的脚本"></a>1.4 执行你的脚本</h2><p>登录sqlplus，然后跳(Traverse)到你的脚本目录</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">@绝对路径
@相对路径
sqlplus username&#x2F;password@database my_stored_script.sql </code></pre>

<h2 id="1-5-接受用户的输入从键盘中"><a href="#1-5-接受用户的输入从键盘中" class="headerlink" title="1.5 接受用户的输入从键盘中"></a>1.5 接受用户的输入从键盘中</h2><p>sqlplus使用&amp;符号来接受来自键盘的输入</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 emp_count NUMBER; 
BEGIN 
 SELECT count(*) 
 INTO emp_count 
 FROM employees 
 WHERE department_id &#x3D; &amp;department_id; 
END; </code></pre>

<p>但是如果你想从键盘接受一个输入，但是后面又想继续使用，则可以使用如下方法</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 emp_count NUMBER; 
BEGIN 
  SELECT count(*) 
  INTO emp_count 
  FROM employees 
  WHERE department_id &#x3D; &amp;&amp;department_id; 
  DBMS_OUTPUT.PUT_LINE(&#39;The employee count is: &#39; || emp_count || 
  &#39; for the department with an ID of: &#39; || &amp;department_id); 
END;
</code></pre>

<p>另外还有一种方法就是定义变量来承接从键盘来的输入,但是要注意这个变量定义的类型,如果是numeric类型的，如果是varchar2类型则需要用<code>单引号</code>,见如下代码</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
    first varchar2(20); 
    last varchar2(25); 
    emp_last VARCHAR2(25) :&#x3D; &#39;&amp;last_name&#39;; 
    emp_count NUMBER; 
BEGIN 
    SELECT count(*) 
    INTO emp_count 
    FROM employees 
    WHERE last_name &#x3D; emp_last; 
 IF emp_count &gt; 1 THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;More than 1 employee exists with that name.&#39;); 
 ELSE 
    SELECT first_name, last_name 
    INTO first, last 
    FROM employees 
    WHERE last_name &#x3D; emp_last; 
    DBMS_OUTPUT.PUT_LINE(&#39;The matching employee is: &#39; || 
    first || &#39; &#39; || last); 
 END IF; 
EXCEPTION 
    WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;Please enter a different last name.&#39;); 
END; </code></pre>

<h2 id="1-6-Displaying-Results-in-SQL-Plus"><a href="#1-6-Displaying-Results-in-SQL-Plus" class="headerlink" title="1.6 Displaying Results in SQL*Plus"></a>1.6 Displaying Results in SQL*Plus</h2><p><code>SET SERVEROUTPUT ON</code> is issued, then the default buffer size is 20,000 bytes.<br>Any content that surpasses that size will be cut off. To increase the buffer, simply set the size of buffer<br>you’d like to use when turning the SERVEROUTPUT on: </p>
<h2 id="1-7-Commenting-Your-Code"><a href="#1-7-Commenting-Your-Code" class="headerlink" title="1.7 Commenting Your Code"></a>1.7 Commenting Your Code</h2><h2 id="1-8-Referencing-a-Block-of-Code"><a href="#1-8-Referencing-a-Block-of-Code" class="headerlink" title="1.8 Referencing a Block of Code"></a>1.8 Referencing a Block of Code</h2><p>如何引用一个代码块?</p>
<p>给一个代码块添加label标签,比如下面的代码</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
&lt;&lt;dept_block&gt;&gt;
DECLARE 
  dept_name varchar2(30); 
BEGIN 
  SELECT department_name 
  INTO dept_name 
  FROM departments 
  WHERE department_id &#x3D; 230;
  DBMS_OUTPUT.PUT_LINE(dept_name);
END dept_block;
</code></pre>

<h2 id="1-9-Referring-to-Variables-from-Nested-Blocks"><a href="#1-9-Referring-to-Variables-from-Nested-Blocks" class="headerlink" title="1.9. Referring to Variables from Nested Blocks"></a>1.9. Referring to Variables from Nested Blocks</h2><p>如果code block是嵌套关系那么该如何使用具有相同名字的变量,可以使用label来区分不同的变量名字</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;outer_block&gt;&gt;
DECLARE
  mgr_id NUMBER(6) :&#x3D; &#39;&amp;current_manager_id&#39;;
  dept_count number :&#x3D; 0;
BEGIN

SELECT count(*)
    INTO dept_count 
    FROM departments 
    WHERE manager_id &#x3D; outer_block.mgr_id;

 IF dept_count &gt; 0 THEN 
    &lt;&lt;inner_block&gt;&gt; 
    DECLARE 
      dept_name VARCHAR2(30); 
      mgr_id NUMBER(6):&#x3D; &#39;&amp;new_manager_id&#39;; 
    BEGIN 
    SELECT department_name 
    INTO dept_name 
    FROM departments 
    WHERE manager_id &#x3D; outer_block.mgr_id; 

    UPDATE departments 
    SET manager_id &#x3D; inner_block.mgr_id 
    WHERE manager_id &#x3D; outer_block.mgr_id; 
    DBMS_OUTPUT.PUT_LINE 
    (&#39;Department manager ID has been changed for &#39; || dept_name); 
    END inner_block; 
 ELSE 
    DBMS_OUTPUT.PUT_LINE(&#39;There are no departments listed for the manager&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;There are no departments listed for the manager&#39;); 
END outer_block; </code></pre>

<p>但是inner block创建的变量，outside block是不会读取到的,外部块变量在内部块中是可见的，而不需要完全限定名称，并且不需要块标签</p>
<h2 id="1-10-Ignoring-Substitution-Variables"><a href="#1-10-Ignoring-Substitution-Variables" class="headerlink" title="1.10. Ignoring Substitution Variables"></a>1.10. Ignoring Substitution Variables</h2><p>转义那些sqlplus使用的特殊字符</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; SET ESCAPE &#39;\&#39; 
SQL&gt; INSERT INTO DEPARTMENTS VALUES( 
  departments_seq.nextval, 
  &#39;Shipping \&amp; Receiving&#39;, 
  null, 
 null);</code></pre>

<p>还有另外一种</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; SET DEFINE OFF
INSERT INTO DEPARTMENTS VALUES( 
departments_seq.nextval, 
&#39;Importing &amp; Exporting&#39;, 
null, 
null); 
</code></pre>

<h2 id="1-11-Changing-the-Substitution-Variable-Character"><a href="#1-11-Changing-the-Substitution-Variable-Character" class="headerlink" title="1.11. Changing the Substitution Variable Character"></a>1.11. Changing the Substitution Variable Character</h2><p>如果你对改变替换变量符号(&amp;)为其他的符号</p>
<p>可以使用<code>set define ^</code>, 你也可以使用任意其他的符号来替换</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; SET DEFINE ^
SQL&gt; SELECT department_name 
     FROM departments 
     WHERE department_id &#x3D; ^dept_id;</code></pre>

<h2 id="1-12-Creating-a-Variable-to-Match-a-Database-Column-Type"><a href="#1-12-Creating-a-Variable-to-Match-a-Database-Column-Type" class="headerlink" title="1.12. Creating a Variable to Match a Database Column Type"></a>1.12. Creating a Variable to Match a Database Column Type</h2><p>如果向查数据库中某一个表的数据，该如何将查询结果赋值给变量呢？<br>可以使用<code>%type</code>关键字,会将一列的数据赋值给变量,而<code>%rowtype</code>则是返回一列的数据给变量</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
DECLARE
 dept_name departments.department_name%TYPE; 
 dept_id NUMBER(6) :&#x3D; &amp;department_id; 
BEGIN 
 SELECT department_name 
 INTO dept_name 
 FROM departments 
 WHERE department_id &#x3D; dept_id; 
 DBMS_OUTPUT.PUT_LINE(&#39;The department with the given ID is: &#39; || dept_name); 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No department for the given ID&#39;); 
END;</code></pre>

<h1 id="2-基础sql"><a href="#2-基础sql" class="headerlink" title="2.基础sql"></a>2.基础sql</h1><p><img src="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png" alt="图文无关,在写文章时听张学友的歌"></p>
<h2 id="2-1-Retrieving-a-Single-Row-from-the-Database"><a href="#2-1-Retrieving-a-Single-Row-from-the-Database" class="headerlink" title="2.1 Retrieving a Single Row from the Database"></a>2.1 Retrieving a Single Row from the Database</h2><p><strong>problem</strong></p>
<p>You are interested in returning one row from a database table via a query that searches for an exact<br>match.</p>
<p><strong>solution 1</strong><br>你可以使用<code>select ... into ...</code>语法</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
    first VARCHAR2(20);  -- varchar2(20)一定是要兼容的数据库表字段的
    last VARCHAR2(25); 
    email VARCHAR2(25); 
BEGIN 
    SELECT first_name, last_name, email 
    INTO first, last, email 
    FROM employees 
    WHERE employee_id &#x3D; 100; 
    DBMS_OUTPUT.PUT_LINE( 
    &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); 
EXCEPTION 
WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given ID&#39;); 
WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE(&#39;More than one employee matches the given ID&#39;); 
END; </code></pre>

<p><strong>solution 2</strong></p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR emp_cursor IS 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE employee_id &#x3D; &amp;emp_id; 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 OPEN emp_cursor; 
 FETCH emp_cursor INTO first, last, email; 
 IF emp_cursor%NOTFOUND THEN 
      RAISE NO_DATA_FOUND; 
 ELSE 
 -- Perform second fetch to see if more than one row is returned 
    FETCH emp_cursor INTO first, last, email; 
    IF emp_cursor%FOUND THEN 
      RAISE TOO_MANY_ROWS; 
    ELSE 
      DBMS_OUTPUT.PUT_LINE( 
      &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); 
      END IF;
 END IF; 
CLOSE emp_cursor; 
</code></pre>

<p><strong>how it works</strong></p>
<p>solution 1: One is to issue a SELECT…INTO statement,which is a statement designed to return just one row.<br>The other approach is to open a cursor, fetch the  one row, and close the cursor<br>solution 2: We keep an open mind on that point. Consider that if youare expecting exactly one row to be<br>returned, getting multiple rows back represents an exception case that you must somehow deal with.<br>The cursor-based solution makes it easy to simply ignore that exception case, but ignoring a condition<br>that you do not expect to occur does not change the fact that it has occurred. Although a cursor is used,<br>the cases where no data is returned or where too many rows are returnedgiven the user-supplied EMPLOYEE_ID<br>still remain a reality. However, since cursors are specifically designed to deal with zero rows or more<br>than one row coming back from a query, no exceptions will be raised if these situations occur. For this reason,<br>Solution #2 contains some conditional logic that is used to manually raise the desired exceptions.In the event that the user supplies the block with an invalid EMPLOYEE_ID, the cursor will not fetch any data. The %NOTFOUND attribute of the cursor will be checked to see whether the cursor successfully fetched data. If not, then the NO_DATA_FOUND exception is raised. If the cursor is successful in retrieving data, then a second FETCH statement is issued to see whether more than<br>one row will be returned. If more than one row is returned, then the TOO_MANY_ROWS exception is raised;<br>otherwise, the expected output is displayed. In any event, the output that is displayed using either of the<br>solutions will be the same whether successful or not.</p>
<h2 id="2-2-Qualifying-Column-and-Variable-Names（变量和表列名相同"><a href="#2-2-Qualifying-Column-and-Variable-Names（变量和表列名相同" class="headerlink" title="2.2. Qualifying Column and Variable Names（变量和表列名相同)"></a>2.2. Qualifying Column and Variable Names（变量和表列名相同)</h2><p><strong>Problem</strong><br>You have a variable and a column sharing the same name. You want to refer to both in the same SQL<br>statement.<br>For example, you decide that you’d like to search for records where LAST_NAME is not equal to a last<br>name that is provided by a user via an argument to a procedure call. Suppose you have declared a<br>variable LAST_NAME, and you want to alter the query to read as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SELECT first_name, last_name, email
 INTO first, last, email 
 FROM employees 
WHERE last_name &#x3D; last_name; </code></pre>
<p>How does PL&#x2F;SQL know which LAST_NAME you are referring to since both the table column name and<br>the variable name are the same? You need a way to differentiate your references. </p>
<p><strong>Solution</strong><br>You can use the dot notation to fully qualify the local variable name with the procedure name so that<br>PL&#x2F;SQL can differentiate between the two. The altered query, including the fully qualified<br>procedure_name.variable solution, would read as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE retrieve_emp_info(last_name IN VARCHAR2) AS 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 SELECT first_name, last_name, email 
 INTO first, last, email 
 FROM employees 
 WHERE last_name &#x3D; retrieve_emp_info.last_name; 
 DBMS_OUTPUT.PUT_LINE( 
 &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last_name || &#39; - &#39; || email); 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name &#39; || last_name); 
END; </code></pre>

<p><strong>How It Works</strong></p>
<p>PL&#x2F;SQL name resolution(方法) becomes very important in circumstances such as these, and by fully qualifying<br>the names, you can be sure that your code will work as expected. The solution used dot notation to fully<br>qualify the variable name. </p>
<p>The column name could have been qualified with the table name, as in EMPLOYEES.LAST_NAME.<br>However, there’s no need to qualify the column name in this case. Because the reference occurs within a<br>SELECT, the closest resolution for LAST_NAME becomes the table column of that name. So, in this particular<br>case, it is necessary only to qualify references to variable names in the enclosing PL&#x2F;SQL block. </p>
<p>If you are executing a simple BEGIN…END block, then you also have the option of fully qualifying the<br>variable using the dot notation along with the block label. For the purposes of this demonstration, let’s<br>say that the code block shown in the solution was labeled &lt;<emp_info>&gt;. You could then fully qualify a<br>variable named description as follows: </p>
<pre class="language-text" data-language="text"><code class="language-text">side note:
</code></pre>

<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;emp_info&gt;&gt;
DECLARE 
 last_name VARCHAR2(25) :&#x3D; &#39;Fay&#39;; 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 SELECT first_name, last_name, email 
 INTO first, last, email 
 FROM employees 
 WHERE last_name &#x3D; emp_info.last_name; 
END; </code></pre>

<p>In this example, the LAST_NAME that is declared in the code block is used within the SELECT..INTO<br>query, and it is fully qualified with the code block label.</p>
<text style="font-family:Courier New;color:red">

<p>summary: </br></p>
<ol>
<li>while code block contain same variable name as parameter, we could use “procedure”(including package name i though) name qualify parameter name at where clause statement.</li>
<li>actualy you could use table name qualify parameter name in code block, but no more works on it,due to in your select statement,<br>it had been qualified by table name.</li>
<li>and so on , if you use label on your code block, as case shown above</li>
</ol>
</text>

<h2 id="2-3-Declaring-Variable-Types-That-Match-Column-Types"><a href="#2-3-Declaring-Variable-Types-That-Match-Column-Types" class="headerlink" title="2.3. Declaring Variable Types That Match Column Types"></a>2.3. Declaring Variable Types That Match Column Types</h2><p><strong>Problem</strong><br>You want to declare some variables in your code block that match the same datatypes as some columns<br>in a particular table. If the datatype on one of those columns changes, you’d like the code block to<br>automatically update the variable type to match that of the updated column</p>
<p><strong>Note</strong><br>Sharp-eyed readers will notice that we cover this problem redundantly in Chapter 1. We cover this<br>problem here as well, because the solution is fundamental to working in PL&#x2F;SQL, especially to working with SQL in<br>PL&#x2F;SQL. We don’t want you to miss what we discuss in this recipe. It is that important.</p>
<p><strong>Solution</strong><br>Use the <code>%TYPE</code> attribute(n.属性) on table columns to identify(v.确定) the types of data that will be returned into your local variables. Instead of providing a hard-coded datatype for a variable, append %TYPE to the database column name. Doing so will apply the datatype from the specified column to the variable you are declaring.</p>
<p>In the following example, the same <code>SELECT INTO</code> query is issued, as in the previous problem, to retrieve an employee record from the database. However, in this case, the variables are declared using the <code>%TYPE</code> attribute rather than designating a specified datatype for each.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  first   employees.first_name%TYPE;
  last    employees.last_name%TYPE;
  email   employees.email%TYPE;
BEGIN 
SELECT 
  first_name, 
  last_name, 
  email INTO first, last, email 
FROM 
  employees 
WHERE 
  employee_id &#x3D; &amp; emp_id;
  DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email);
EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;No matching employee was found, please try again.&#39;);
WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&#39;An unknown error has occured, please try again.&#39;);
END;</code></pre>

<p>As you can see from the solution, the code block looks essentially the same as the one in the previous recipe. The only difference is that here the <code>%TYPE</code> attribute of each database column is being used in order to declare your local variable types.</p>
<p><strong>How It Works</strong><br>The <code>%TYPE</code> attribute can become a significant time-saver and savior for declaring variable types, especially if the underlying database column types are subject(会发生变化) to change. This attribute enables the local variable to assume the same datatype of its corresponding database column type at runtime. Retrieving several columns into local application variables can become tedious(<code>沉闷的</code>) if you need to continually verify that the datatypes of each variable are the same as those of the columns whose data they will consume.The<code>%TYPE</code> attribute can be used when defining variables, constants, fields, and parameters. Using <code>%TYPE</code> assures(<code>保证</code>) that the variables you declare will always remain synchronized with the datatypes of their corresponding columns.</p>
<text style="font-family:Courier New;color:red">
summary: </br>
at all above explained that we could use `%TYPE` attribute to define variable which the same as table datatype
</text>

<h2 id="2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record"><a href="#2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record" class="headerlink" title="2.4. Returning Queried Data into a PL&#x2F;SQL Record"></a>2.4. Returning Queried Data into a PL&#x2F;SQL Record</h2><p><strong>Problem</strong><br>Instead of retrieving only a select few columns via a database query, you’d rather return the entire<br>matching row. It can be a time-consuming task to replicate each of the table’s columns in your<br>application by creating a local variable for each along with selecting the correct datatypes. Although you<br>can certainly make use of the <code>%TYPE</code> attribute while declaring the variables, you’d rather retrieve the<br>entire row into a single object. Furthermore, you’d like the object that the data is going to be stored into<br>to have the ability to assume the same datatypes for each of the columns being returned just as you<br>would by using the <code>%TYPE</code> attribute.<br><strong>Solution</strong><br>Make use of the <code>%ROWTYPE</code> attribute for the particular database table that you are querying. The <code>%ROWTYPE</code><br>attribute returns a record type that represents a database row from the specified table. For instance, the<br>following example demonstrates how the %ROWTYPE attribute can store an entire employee table row for a<br>cursor: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 CURSOR emp_cur IS 
 SELECT * 
 FROM employees 
 WHERE employee_id &#x3D; &amp;emp_id; 
 -- Declaring a local variable using the ROWTYPE attribute 
 -- of the employees table 
 emp_rec employees%ROWTYPE; 
BEGIN 
 OPEN emp_cur; 
 FETCH emp_cur INTO emp_rec; 
 IF emp_cur%FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || emp_rec.first_name || &#39; &#39; || 
 emp_rec.last_name || &#39; - &#39; || emp_rec.email); 
 ELSE 
  DBMS_OUTPUT.PUT_LINE(&#39;No matching employee for the given ID&#39;);
 END IF; 
 CLOSE emp_cur; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given emp ID’); 
END; 
</code></pre>

<p><strong>How It Works</strong><br>The <code>%ROWTYPE</code> attribute represents an entire database table row as a record type. Each of the<br>corresponding table columns is represented within the record as a variable, and each variable in the<br>record inherits its type from the respective table column.<br>Using the <code>%ROWTYPE</code> attribute offers several advantages to declaring each variable individually. For<br>starters, declaring a single record type is much more productive than declaring several local variables to<br>correspond to each of the columns of a table. Also, if any of the table columns’ datatypes is ever<br>adjusted, then your code will not break because the <code>%ROWTYPE</code> attribute works in much the same manner<br>as the <code>%TYPE</code> attribute of a column in that it will automatically maintain the same datatypes as the<br>corresponding table columns. Therefore, if a column with a type of <code>VARCHAR2(10)</code> is changed to<br><code>VARCHAR2(100)</code>, that change will ripple(vt.在…上形成波痕) through into your record definition.<br>Using <code>%ROWTYPE</code> also makes your code much easier to read because you are not littering(n.乱丢废物) local<br>variables throughout. Instead, you can use the dot notation to reference each of the different columns<br>that the record type returned by <code>%ROWTYPE</code> consists of. For instance, in the solution, the <code>first_name</code>,<br><code>last_name</code>, and <code>email</code> columns are referenced from the <code>emp_rec</code> record type. </p>
<h2 id="2-5-Creating-Your-Own-Records-to-Receive-Query-Results"><a href="#2-5-Creating-Your-Own-Records-to-Receive-Query-Results" class="headerlink" title="2.5. Creating Your Own Records to Receive Query Results"></a>2.5. Creating Your Own Records to Receive Query Results</h2><p><strong>Problem</strong><br>You want to query the database, return several columns from one or more tables, and store them into<br>local variables of a code block for processing. Rather than placing the values of the columns into<br>separate variables, you want to create a single variable that contains all the values.<br><text style="font-family:Courier New;color:red"><br>summary: </br><br>return several columns from one or more tables.<br></text></p>
<p><strong>Solution</strong><br>Create a database RECORD containing variables to hold the data you want to retrieve from the database.<br>Since a RECORD can hold multiple variables of different datatypes, they work nicely for grouping data that<br>has been retrieved as a result of a query.<br>In the following example, the database is queried for the name and position of a player. The data<br>that is returned is used to populate(vt.居住于；构成人口) a PL&#x2F;SQL RECORD containing three separate variables: first name, last<br>name, and position. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
  TYPE emp_info IS RECORD(first employees.first_name%TYPE, 
                         last employees.last_name%TYPE, 
                         email employees.email%TYPE); 
  emp_info_rec emp_info;  -- 用emp_info 类型定义了emp_info_rec变量

BEGIN 
 SELECT first_name, last_name, email 
 INTO emp_info_rec 
 FROM employees 
 WHERE last_name &#x3D; &#39;Vargas&#39;; 
 DBMS_OUTPUT.PUT_LINE(&#39;The queried employee&#39;&#39;s email address is &#39; || emp_info_rec.email); 
 EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); 
END; </code></pre>

<p><strong>How It Works</strong><br>Records are useful for passing similar data around within an application, but they are also quite useful<br>for simply retrieving data and organizing it nicely as is the case with the solution to this recipe. To create<br>a record, you first declare a record TYPE. This declaration can consist of one or more different datatypes<br>that represent columns of one or more database tables. Once the record type is declared, you create a<br>variable and define it as an instance of the record type. This variable is then used to populate and work with the data stored in the record. </p>
<p><code>Cursor</code> work very well with records of data. When declaring a cursor, you can select particular<br>columns of data to return into your record. The record variable then takes on the type of cursor%ROWTYPE.<br>In the following example, a cursor is used to determine which fields you want to return from EMPLOYEES.<br>That cursor’s %ROWTYPE attribute is then used to define a record variable that is used for holding the<br>queried data. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR emp_cur IS 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE employee_id &#x3D; 100; 
 emp_rec emp_cur%ROWTYPE; 
BEGIN 
 OPEN emp_cur; 
 FETCH emp_cur INTO emp_rec; 
 IF emp_cur %FOUND THEN 
CLOSE emp_cur; 
 DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || 
 &#39;&#39;&#39;s email is &#39; || emp_rec.email); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the provided ID number&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); 
END; </code></pre>
<p>As you can see in this example, the cursor <code>%ROWTYPE</code> attribute creates a record type using the<br>columns that are queried by the cursor. The result is easy-to-read code that gains all the positive effects<br>of declaring record types via the <code>%ROWTYPE</code> attribute. </p>
<h2 id="2-6-Looping-Through-Rows-from-a-Query"><a href="#2-6-Looping-Through-Rows-from-a-Query" class="headerlink" title="2.6. Looping Through Rows from a Query"></a>2.6. Looping Through Rows from a Query</h2><p><strong>Problem</strong><br>A query that you are issuing to the database will return many rows. You want to loop through those rows<br>and process them accordingly. </p>
<p><strong>Solution #1</strong><br>There are a couple of different solutions for looping through rows from a query. One is to work directly<br>with a SELECT statement and use a FOR loop along with it. In the following example, you will see this<br>technique in action:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SET SERVEROUTPUT ON; 
BEGIN 
 FOR emp IN 
 ( 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE commission_pct is not NULL 
 ) 
 LOOP 
 DBMS_OUTPUT.PUT_LINE(emp.first_name || &#39; &#39; || emp.last_name || &#39; - &#39; || emp.email); 
 END LOOP; 
END; </code></pre>

<p><strong>Solution #2</strong><br>Similarly, you can choose to use a FOR loop along with a cursor. Here’s an example: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SET SERVEROUTPUT ON; 
DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, email 
 FROM employees 
WHERE commission_pct is not NULL; 
      emp_rec emp_cur%ROWTYPE;
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
 DBMS_OUTPUT.PUT_LINE( 
 emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_rec.email); 
 END LOOP; 
END; </code></pre>

<p><strong>How It Works</strong><br>The <code>loop</code> that is used in the first solution is also known as an implicit(adj.含蓄的,暗示的) cursor FOR loop. No variables need to be explicitly defined in that solution, because the FOR loop will automatically create a record using the results of the query. That record will take the name provided in the FOR variable_name IN clause. That<br>record variable can then be used to reference the different columns that are returned by the query. As demonstrated in the second solution to this recipe, a cursor is also a very useful way to loop through the results of a query. This technique is also known as an explicit cursor FOR loop. This technique is very similar to looping through the results of an explicitly listed query. Neither solution requires you to explicitly open and close a cursor. In both cases, the opening and<br>closing is done on your behalf by the FOR loop processing. As you can see, the <code>FOR loop</code> with the <code>SELECT query</code> in the first example is a bit more concise(adj.简明的,简洁的), and there are fewer lines of code. The first example also contains no declarations. In the second example, with the cursor, there are two declarations that account for more lines of code. However, using the cursor is a standard technique that provides for more reusable code. For instance, you can elect to use the cursor any number of times, and you’ll need to write the query only once when declaring the cursor. On the contrary, if you wanted to reuse the query in the first example, then you would have to rewrite it,<br>and having to write the same query multiple times opens the door to errors and inconsistencies. We recommend Solution #2. </p>
<h2 id="2-7-Obtaining-Environment-and-Session-Information"><a href="#2-7-Obtaining-Environment-and-Session-Information" class="headerlink" title="2.7. Obtaining Environment and Session Information"></a>2.7. Obtaining Environment and Session Information</h2><p><strong>Problem</strong><br>You want to obtain environment and session information such as the name and IP address of the<br>current user so that the values can be stored into local variables for logging purposes.<br><strong>Solution</strong><br>Make use of the <code>SYS_CONTEXT()</code> built-in function to query the database for the user’s information. Once you<br>have obtained the information, then store it into a local variable. At that point, you can do whatever<br>you’d like with it, such as save it in a logging table. The following code block demonstrates this<br>technique: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;obtain_user_info&gt;&gt;
DECLARE 
  username varchar2(100); 
  ip_address varchar2(100); 
BEGIN
  SELECT SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), SYS_CONTEXT(&#39;USERENV&#39;,&#39;IP_ADDRESS&#39;) 
  INTO username, ip_address 
  FROM DUAL; 
  DBMS_OUTPUT.PUT_LINE(&#39;The connected user is: &#39; || username || &#39;, and the IP address
  is &#39; || 
  ip_address); 
END; </code></pre>
<p>Once this code block has been run, then the user’s information should be stored into the local<br>variables that have been declared within it. </p>
<p><strong>How It Works</strong><br>You can use the <code>SYS_CONTEXT</code> function to obtain important information regarding the current user’s<br>environment, among other things. It is often times used for auditing(n.审计;查帐) purposes so that a particular code<br>block can grab(vi.攫取;夺取) important information about the connected user such as you’ve seen in the solution to<br>this recipe. The SYS_CONTEXT function allows you to define a namespace and then place parameters<br>within it so that they can be retrieved for use at a later time. The general syntax for the use of<br><code>SYS_CONTEXT</code> is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SYS_CONTEXT(&#39;namespace&#39;,&#39;parameter&#39;[,length]) </code></pre>
<p>A namespace can be any valid SQL identifier, and it must be created using the CREATE_CONTEXT<br>statement. The parameter must be a string or evaluate to a string, and it must be set using the<br>DBMS_SESSION.SET_CONTEXT procedure. The call to SYS_CONTEXT with a valid namespace and parameter<br>will result in the return of a value that has a VARCHAR2 datatype. The default maximum length of the<br>returned value is 256 bytes. However, this default maximum length can be overridden by specifying the<br>length when calling SYS_CONTEXT. The length is an optional parameter. The range of values for the length<br>is 1 to 4000, and if you specify an invalid value, then the default of 256 will be used.<br>The USERENV namespace is automatically available for use because it is a built-in namespace<br>provided by Oracle. The USERENV namespace contains session information for the current user. Table 2-1<br>lists the parameters that are available to use with the USERENV namespace.<br>Table 2-1. USERENV Parameter Listing </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- Parameter          Description 
ACTION                Identifies the position in the application name.
AUDITED_CURSORID      Returns the cursor ID of the SQL that triggered the audit. 
AUTHENTICATED_DATA    Returns the data being used to authenticate the user. 
AUTHENTICATION_TYPE   Identifies how the user was authenticated. 
BG_JOB_ID             If an Oracle Database background process was used to establish the connection, then this returns the job ID of the current session. If no 
                      background process was established, then NULL is returned. 
CLIENT_IDENTIFIER     Returns identifier that is set by the application. 
CLIENT_INFO           Returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. 
CURRENT_SCHEMA        Returns the current session’s default schema.
CURRENT_SCHEMAID      Returns the current schema’s identifier.
CURRENT_SQL           Returns the first 4KB of the triggering SQL.
DB_DOMAIN             Returns the value specified in the DB_DOMAIN parameter. 
DB_NAME               Returns the value specified in the DB_NAME parameter. 
DB_UNIQUE_NAME        Returns the value specified in the DB_UNIQUE_NAME parameter. 
ENTRYID               Returns the current audit entry number. 
EXTERNAL_NAME         Returns the external name of the database user. 
FG_JOB_ID             If an Oracle Database foreground process was used to establish the connection, then this returns the job ID of the current session. If no 
                      foreground process was established, then NULL is returned. 
GLOBAL_CONTEXT_MEMORY Returns the number being used by the globally accessed context in the 
                      System Global Area.   
HOST                  Returns the host name of the machine from which the client has connected. 
INSTANCE              Returns the instance ID number of the current instance. 
IP_ADDRESS            Returns the IP address of the machine from which the client has connected. 
ISDBA                 Returns TRUE if the user was authenticated as a DBA. 
LANG                  Returns the ISO abbreviation of the language name. 
LANGUAGE              Returns the language and territory used by the session, along with the 
                      character set. 
MODULE                Returns the application name. This name has to be set via the
                      DBMS_APPLICATION_INFO package. 
NETWORK_PROTOCOL      Returns the network protocol being used for communication. 
NLS_CALENDAR          Returns the current calendar of the current session. 
NLS_CURRENCY          Returns the currency of the current session. 
NLS_DATE_FORMAT       Returns the date format for the session. 
NLS_DATE_LANGUAGE     Returns the language being used for expressing dates. 
NLS_SORT              Returns the BINARY or linguistic sort basis. 
NLS_TERRITORY         Returns the territory of the current session. 
OS_USER               Returns the operating system user name of the client that initiated the 
                      session. 
PROXY_USER            Returns the name of the database that opened the current session on behalf 
                      of SESSION_USER. 
PROXY_USERID          Returns the identifier of the database user who opened the current session on behalf of the SESSION_USER. 
SERVICE_NAME          Returns the name of the service to which a given session is connected. 
SESSION_USER          Returns the database user name through which the current user is authenticated. 
SESSION_USERID        Returns the identifier of the database user name by which the current user is authenticated. 
SESSIONID             Returns the auditing session identifier. 
STATEMENTID           Returns the auditing statement identifier. 
TERMINAL              Returns the operating system identifier for the client of the current session. </code></pre>
<p>When <code>SYS_CONTEXT</code> is used within any query, it is most commonly issued against the <code>DUAL</code> table. The<br><code>DUAL</code> table is installed along with the data dictionary when the Oracle Database is created. This table is<br>really a dummy(adj.虚拟的,假的) table that contains one column that is appropriately named <code>DUMMY</code>. This column contains<br>the value <code>X</code>.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; desc dual;
 Name Null? Type 
 ----------------------------------------- -------- ---------------------------- 
DUMMY VARCHAR2(1) </code></pre>
<p>Among other things, <code>DUAL</code> is useful for obtaining values from the database when no actual table is<br>needed. Our solution case is such a situation.</p>
<h2 id="2-8-Formatting-Query-Results"><a href="#2-8-Formatting-Query-Results" class="headerlink" title="2.8. Formatting Query Results"></a>2.8. Formatting Query Results</h2><p><strong>Problem</strong><br>Your boss asks you to print the results from a couple of queries in a nicely formatted manner.<br><strong>Solution</strong><br>Use a combination of different built-in formatting functions along with the concatenation operator (||)<br>to create a nice-looking basic report. The RPAD and LPAD functions along with the concatenation operator<br>are used together in the following example that displays a list of employees from a company: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, phone_number 
 FROM employees; 
 emp_rec employees%ROWTYPE; 
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
 IF emp_rec.phone_number IS NOT NULL THEN 
 DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 35,&#39;.&#39;) || 
 emp_rec.phone_number); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || 
 &#39; does not have a phone number.&#39;); 
 END IF; 
 END LOOP; 
END; 
The following is another variant of the same report, but this time dashes are used instead of using 
dots to space out the report: 
DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, phone_number 
 FROM employees; 
 emp_rec employees%ROWTYPE; 
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
  IF emp_rec.phone_number IS NOT NULL THEN
  --CHECK FOR INTERNATIONAL PHONE NUMBERS
        IF length(emp_rec.phone_number) &gt; 12 THEN
          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,18));
        ELSE
          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,12));
        END IF;
      ELSE
        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;does not have a phone number.&#39;);
    END IF;
  END LOOP;
END;</code></pre>

<p><strong>How It Works</strong><br>The <code>RPAD</code> and <code>LPAD</code> functions are used to return the data in a formatted manner. The <code>RPAD</code> function takes a<br>string of text and pads it on the right by the number of spaces provided by the second parameter. The<br>syntax for the <code>RPAD</code> function is as follows:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">RPAD(input_text, n, character) -- append n piece characters on the right</code></pre>

<p>In this syntax, <code>n</code> is the number of spaces used to pad. Similarly, the <code>LPAD</code> function pads on the left of<br>the provided string. The syntax is exactly the same as <code>RPAD</code>; the only difference is the direction of the<br>padding. The combination of these two functions, along with the concatenation operator (<code>||</code>), provides<br>for some excellent formatting options.  </p>
<p>It is important to look at the data being returned before you try to format it, especially to consider<br>what formatting options will look best when generating output for presentation. In the case of the<br>examples in this recipe, the latter example would be the most reasonable choice of formatting for the<br>data being returned, since the phone number includes dots in it. The first example uses dots to space out<br>the report, so too many dots may make the output difficult to read. Know your data, and then choose the<br>appropriate PL&#x2F;SQL built-ins to format accordingly.  </p>
<p>Note When using <code>DBMS_OUTPUT</code> to display data, please be sure to pay attention to the size of the buffer. You can<br>set the buffer size from 2,000 to 1,000,000 bytes by passing the size you desire to the <code>DBMS_OUTPUT.ENABLE</code> procedure.<br>If you attempt to display content over this size limit, then Oracle will raise an exception.</p>
<p>Oracle provides a number of built-in functions to use when formatting strings. Two others that are<br>especially useful are <code>LTRIM(&lt;string&gt;)</code> and <code>RTRIM(&lt;string&gt;)</code>. These remove leading and trailing spaces,<br>respectively. See your Oracle SQL Reference manual for a complete list of available string functions.</p>
<h2 id="2-9-Updating-Rows-Returned-by-a-Query"><a href="#2-9-Updating-Rows-Returned-by-a-Query" class="headerlink" title="2.9. Updating Rows Returned by a Query"></a>2.9. Updating Rows Returned by a Query</h2><p><strong>Problem</strong><br>  You’ve queried the database and retrieved a row into a variable. You want to update some values<br>contained in the row and commit them to the database.<br><strong>Solution</strong><br>  First, retrieve the database row that you want to update. Second, update the values in the row that need<br>to be changed, and then issue an UPDATE statement to modify the database with the updated values. In<br>the following example, a procedure is created that queries a table of employees for a particular<br>employee. The resulting employee’s department ID is then updated with the new one unless the<br>employee is already a member of the given department.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE change_emp_dept(emp_id IN NUMBER, 
 dept_id IN NUMBER) AS 
 emp_row employees%ROWTYPE; 
 dept departments.department_name%TYPE; 
 rec_count number :&#x3D; 0; 
BEGIN 
 SELECT count(*) 
 INTO rec_count 
 FROM employees 
 WHERE employee_id &#x3D; emp_id; 
 IF rec_count &#x3D; 1 THEN 
 SELECT * 
 INTO emp_row 
 FROM employees 
 WHERE employee_id &#x3D; emp_id; 
 IF emp_row.department_id !&#x3D; dept_id THEN 
 emp_row.department_id :&#x3D; dept_id; 
 UPDATE employees SET ROW &#x3D; emp_row 
 WHERE employee_id &#x3D; emp_id; 
 SELECT department_name 
 INTO dept 
 from departments 
 WHERE department_id &#x3D; dept_id; 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || emp_row.first_name || &#39; &#39; || 
 emp_row.last_name || &#39; is now in department: &#39; || dept); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee is already in that department...no change&#39;); 
 END IF; 
ELSIF rec_count &gt; 1 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee ID you entered is not unique&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee records match the given employee ID&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Invalid employee or department ID, try again&#39;); 
 WHEN OTHERS THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Unsuccessful change, please check ID numbers and try again&#39;); 
END; </code></pre>
<p>As you can see, the example queries the database into a record declared using the <code>%ROWTYPE</code><br>attribute. The value that needs to be updated is then modified using the data contained in the record.<br>Lastly, using the SET ROW clause updates the table with the modified record.<br><strong>How It Works</strong><br>As you’ve seen in the solution to the recipe, it is possible to update the values of a row returned by a<br>query using the <code>UPDATE...SET</code> ROW syntax. In many cases, using a single <code>UPDATE</code> statement can solve this<br>type of transaction. However, in some scenarios where you need to evaluate the current value of a<br>particular column, then this solution is the correct choice.</p>
<p>Using the <code>UPDATE</code> ROW statement, you can update entire database rows with a single variable of either<br>the <code>%ROWTYPE</code> or <code>RECORD</code> type. The <code>UPDATE</code> statement also allows you to return values after the update by<br>adding the <code>RETURNING</code> clause to the end of the statement followed(v.跟着,听从) by the column names to return and the<br>variables that will receive their values. Take a look at this next example:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 first        employees.first_name%TYPE; 
 last         employees.last_name%TYPE; 
 new_salary   employees.salary%TYPE; 
BEGIN 
 UPDATE employees 
 SET salary &#x3D; salary + (salary * .03) 
 WHERE employee_id &#x3D; 100  RETURNING first_name, last_name,salary INTO first, last, new_salary; 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || first || &#39; &#39; || last || &#39; now has a salary of: &#39; || new_salary); 
END; </code></pre>
<p>As you can see, the example outputs the new values that are the result of the update statement.<br>Using the RETURNING clause saves a step in that you are not required to requery the table after the update<br>in order to display the updated results.</p>
<h2 id="2-10-Updating-Rows-Returned-by-a-Cursor"><a href="#2-10-Updating-Rows-Returned-by-a-Cursor" class="headerlink" title="2.10. Updating Rows Returned by a Cursor"></a>2.10. Updating Rows Returned by a Cursor</h2><p><strong>Problem</strong><br>You’ve created a cursor to use for querying your data. You want to loop through the results using a cursor for loop and update the data as needed.<br><strong>Solution</strong><br>Use the <code>WHERE_CURRENT_OF</code> clause within your loop to update the current data row in the iteration. In the<br>following example, the EMPLOYEES table is queried for all employees in a particular department. The<br>results of the query are then iterated using a FOR loop, and the salary is increased for each employee<br>record that is returned.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
DECLARE 
 CURSOR emp_sal_cur IS 
 SELECT * 
 FROM employees 
 WHERE department_id &#x3D; 60 
 FOR UPDATE;        --cursor should use &#96;FOR UPDATE&#96; clause statement

 emp_sal_rec emp_sal_cur%ROWTYPE; -- cursor also would define varable using ROWTYPE keyword

 BEGIN 
 FOR emp_sal_rec IN emp_sal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;Old Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); 
    UPDATE employees 
    SET salary &#x3D; salary + (salary * .025) 
    WHERE CURRENT OF emp_sal_cur;  -- current of your_cursor
 END LOOP; 

 -- Display the updated salaries 
 FOR emp_sal_rec IN emp_sal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;New Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); 
 END LOOP; 
END;
</code></pre>
<p>An update on the <code>EMPLOYEES</code> table occurs with each iteration of the loop. The second loop in this<br>example simply displays the new salary result for each employee that was returned by the cursor query.<br><strong>How It Works</strong><br>Updating values when iterating a cursor can be handy(adj.便利的,手边的), especially when working with a number of(大量) rows.<br>There is one main difference between a cursor that allows updating and one(cursor) that does not. That<br>difference is the addition of the <code>FOR UPDATE</code> clause in the cursor declaration. By using the <code>FOR UPDATE</code><br>clause of the <code>SELECT</code> statement, you are causing the database to lock the rows that have been read by the<br>query. This lock is to ensure that nobody else can modify the rows while you are working with them. The<br>lock creates a read-only block on the table rows so that if someone else attempts to modify them while<br>you have them locked, then they will have to wait until you have performed either a <code>COMMIT</code> or a <code>ROLLBACK</code>.<br>The <code>FOR UPDATE</code> clause has an optional <code>NOWAIT</code> keyword. By including this keyword, you will ensure<br>that your query does not block your transaction if someone else already has the rows that you are<br>querying blocked. The <code>NOWAIT</code> keyword tells Oracle not to wait if the requested rows are already locked,<br>and control is immediately passed back to your program so that it can continue to run. If the <code>NOWAIT</code><br>keyword is omitted and the rows are already locked, then your program will stop and wait until the lock<br>has been released.</p>
<p>You can use the cursor with any style of loop, as you’ve seen in previous recipes. No matter which<br>type of loop you choose, the <code>UPDATE</code> must be coded using the <code>WHERE CURRENT OF your_cursor</code> clause to update the<br>current row in the cursor iteration. You will need to be sure to commit the changes after this block has<br>been run, and in many circumstances the <code>COMMIT</code> statement can be coded into this block once it has been<br>tested and verified to work correctly. As with any <code>UPDATE</code> statement, if you fail to <code>COMMIT</code> your changes,<br>then the UPDATE will not save any changes to the database, and the updated data will be visible to your<br>schema only until you disconnect. Issuing a <code>COMMIT</code> after your <code>UPDATE</code> statements have been issued is also<br>a good practice in this case because it will release the lock on the rows you had queried via the cursor so<br>that someone else can update them if needed. If you determine the data that was updated by the code<br>block is incorrect, then a <code>ROLLBACK</code> will also release the lock.</p>
<text style="font-family:Courier New;color:red">

<p>summary:</br></p>
<ol>
<li>if you wanna update data of cursor that returned by select, you can use <code>WHERE CURRENT OF emp_sal_cur</code> and <code>for update</code></li>
<li>By using the <code>FOR UPDATE</code> clause of the <code>SELECT</code> statement,data lock is data level</li>
<li>wether <code>FOR UPDATE</code> clause update table data or cursor only?(it should be commit changes for table)</li>
<li>if you fail to <code>COMMIT</code> your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to your<br>schema only until you disconnec</li>
<li><code>COMMIT</code> and <code>ROLLBACK</code> either release lock</li>
</ol>
</text> 

<h2 id="2-11-Deleting-Rows-Returned-by-a-Cursor"><a href="#2-11-Deleting-Rows-Returned-by-a-Cursor" class="headerlink" title="2.11. Deleting Rows Returned by a Cursor"></a>2.11. Deleting Rows Returned by a Cursor</h2><p><strong>Problem</strong><br>There are a series of database rows that you’d like to delete. You’ve created a cursor <code>FOR LOOP</code>, and you want to delete some or all rows that have been queried with the cursor.<br><strong>Solution</strong><br>Use a <code>DELETE</code> statement within a <code>FOR LOOP</code> to delete the rows that are retrieved by the <code>cursor</code>. If you create a cursor using the <code>FOR UPDATE</code> clause, then you will be able to use the <code>WHERE CURRENT OF</code> clause along with the <code>DELETE</code> statement to eliminate the current row within each iteration of the cursor. The following example shows how this can be done to remove all job history for a given department ID:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE remove_job_history(dept_id IN NUMBER) AS 

 CURSOR job_history_cur IS 
 SELECT * 
 FROM job_history 
 WHERE department_id &#x3D; dept_id 
 FOR UPDATE; 
    job_history_rec job_history_cur%ROWTYPE; 
 BEGIN 
  FOR job_history_rec IN job_history_cur LOOP 
    DELETE FROM job_history WHERE CURRENT OF job_history_cur; 
    DBMS_OUTPUT.PUT_LINE(&#39;Job history removed for department &#39; || dept_id); 
  END LOOP; 
END; </code></pre>
<p>Using this technique, the job history for the department with the given ID will be removed from the <code>JOB_HISTORY</code> table.</p>
<p><strong>How It Works</strong><br>Much like updating rows using a cursor, the deletion of rows uses the <code>WHERE CURRENT OF</code> clause within the <code>DELETE</code> statement to remove each row. The cursor query must contain the <code>FOR UPDATE</code> clause in order to lock the rows that you are reading until a <code>COMMIT</code> or <code>ROLLBACK</code> has been issued. As mentioned in the previous recipe, the <code>NOWAIT</code> keyword is optional, and it can be used to allow control to be immediately returned to your program if someone else already has locks on the rows that you are interested in updating. In each iteration of the loop, the DELETE statement is used along with the <code>WHERE CURRENT OF</code> clause to remove the current cursor record from the database. Once the loop has been completed, then all the rows that had been queried via the cursor should have been deleted. This technique is especially useful if you are going to be performing some further processing on each of the records and then deleting them. One such case would be if you wanted to write each of the records to a history table prior to deleting them. In any case, the cursor <code>FOR loop</code> deletion technique is a great way to remove rows from the database and work with the data along the way.</p>
<h2 id="2-12-Performing-a-Transaction"><a href="#2-12-Performing-a-Transaction" class="headerlink" title="2.12. Performing a Transaction"></a>2.12. Performing a Transaction</h2><p><strong>Problem</strong><br>You need to complete a series of <code>INSERT</code> or <code>UPDATE</code> statements in order to process a complete transaction. In doing so, you need to ensure that if one of the statements fails, that all of the statements are canceled so that the transaction is not partially processed.<br><strong>Solution</strong><br>Use the transaction control mechanisms that are part of PL&#x2F;SQL, as well as SQL itself, in order to control your transactions. When all your statements have been completed successfully, issue a <code>COMMIT</code> to make them final. On the other hand, if one of the statements does not complete successfully, then perform a <code>ROLLBACK</code> to undo all the other changes that have been made and bring the database back to the state that it was in prior(美[‘praɪɚ],adj.优先的,在先的,在前的) to the transaction occurring.In the following example, the code block entails the body of a script that is to be executed in order to create a new department and add some employees to it. The department change involves an INSERT and UPDATE statement to complete.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 -- Query all programmers who make more than 4000 
 -- as they will be moved to the new &#39;Web Development&#39; department 
 CURSOR new_dept_cur IS 
    SELECT * 
    FROM employees 
    WHERE job_id &#x3D; &#39;IT_PROG&#39;
    AND salary &gt; 4000 
    FOR UPDATE; 
 new_dept_rec         new_dept_cur%ROWTYPE; 
 current_department   departments.department_id%TYPE; 
BEGIN 
 -- Create a new department 
 INSERT INTO departments values( 
                                DEPARTMENTS_SEQ.nextval, -- Department ID (sequence value) 
                                &#39;Web Development&#39;, -- Department Title 
                                103 -- Manager ID 
                                1700); -- Location ID 
 -- Obtain the current department ID…the new department ID 
 SELECT DEPARTMENTS_SEQ.currval 
 INTO current_department 
 FROM DUAL; 

 -- Assign all employees to the new department 
 FOR new_dept_rec IN new_dept_cur LOOP 
      UPDATE employees 
      SET department_id &#x3D; current_department 
      WHERE CURRENT OF new_dept_cur; 
 END LOOP;

 COMMIT;
      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); 
END;</code></pre>
<p>As you can see, a transaction was performed in this block of code. It is important to roll back changes if errors occur along the way so that the transaction is not partially completed.</p>
<p><strong>How It Works</strong><br>Transaction control is built into the Oracle Database. Any database changes that are made within a code block are visible to the current session only until a COMMIT has been made. The changes that have been made by the statements can be rolled back via the ROLLBACK command up until the point that a COMMIT is issued. Oracle uses table and row locks to ensure that data that has been updated in one session cannot be seen in another session until a COMMIT occurs. A transaction is started when the first statement after the last COMMIT or ROLLBACK is processed or when a session is created. It ends when a COMMIT or ROLLBACK occurs. A transaction is not bound to a single code block, and any code block may contain one or more transactions. Oracle provides a SAVEPOINT command, which places a marker at the current database state so as to allow you to roll back to that point in time in a transaction. Oracle Database automatically issues a SAVEPOINT prior to processing the first statement in any transaction.</p>
<p>As a rule of thumb, it is always a good idea to have exception handling in place in case an exceptionoccurs. However, if an unhandled exception occurs, then the database will roll back the statement that caused the exception, not the entire transaction. Therefore, it is up to the program to handle exceptions and issue the ROLLBACK command if the entire transaction should be undone. If a database crashes and goes down during a transaction, then when the database is restarted, all uncommitted statements are rolled back. All transactions are completed when a COMMIT or ROLLBACK is issued.</p>
<h2 id="2-13-Ensuring-That-Multiple-Queries-“See”-the-Same-Data"><a href="#2-13-Ensuring-That-Multiple-Queries-“See”-the-Same-Data" class="headerlink" title="2.13. Ensuring That Multiple Queries “See” the Same Data"></a>2.13. Ensuring That Multiple Queries “See” the Same Data</h2><p><strong>Problem</strong><br>You are issuing a set of queries against the database, and you need to ensure that none of the table rows change throughout the course of the queries being made.<br><strong>Solution</strong><br>Set up a read-only transaction in which the current transaction will see the data only as an unchanged snapshot in time. To do so, use the SET TRANSACTION statement to begin a read-only transaction and establish a snapshot of the data so it will be consistent and unchanged from all other updates being made. For instance, the following example displays a block that sets up read-only queries against the database for dollar values from a bank account:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 daily_atm_total NUMBER(12,2); 
 weekly_atm_total NUMBER(12,2); 
BEGIN 
 COMMIT; -- ends previous transaction 
 SET TRANSACTION READ ONLY NAME &#39;ATM Weekly Summary&#39;; 
 SELECT SUM (wd_amt) INTO daily_atm_total FROM atm_withdrawals 
 WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE, &#39;MM-DD-YYYY&#39;); 
 SELECT SUM (weekly_total) INTO weekly_atm_total FROM atm_withdrawals 
 WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE - 7, &#39;MM-DD-YYYY&#39;); 
 DBMS_OUTPUT.PUT_LINE(daily_atm_total || &#39; - &#39; || weekly_atm_total); 
 COMMIT; -- ends read-only transaction 
END; </code></pre>
<p>Querying the database using read-only transactions will ensure that someone will see the correct values in a situation such as the one depicted(vt.描述,描画) in this example.</p>
<p><strong>How It Works</strong><br>often times there are situations when you need to ensure that the data being queried throughout a transaction’s life cycle is unchanged by other users’ updates. The classic case is when someone goes to withdraw money from the bank and their spouse(n.配偶) is at an ATM machine depositing into the account at the same time. If read consistency were not in place, the individual may view their account balance and see that there was plenty of money to withdraw, and then they’d go to take the money out and receive an error because the spouse had canceled the deposit(美 [dɪ’pɑzɪt]n.存款,押金) instead. A read-only transaction allows for read consistency until a <code>COMMIT</code> has been issued. If the spouse had confirmed the deposit, then the next query on the account would reflect the additional funds (assuming that the bank were to release them to the account in real time).<br>Situations such as these require that you provide an environment that is essentially isolated from the outside world. You can use the SET TRANSACTION command to start a read-only transaction, set an isolation level, and assign the current transaction to a <code>rollback</code> segment. The SET TRANSACTION statement must be the first statement in a read-only transaction, and it can appear only once in the transaction. Note that there are some statement restrictions when using a read-only transaction. Only <code>SELECT INTO</code>, <code>OPEN</code>, <code>FETCH</code>, <code>CLOSE</code>, <code>LOCK TABLE</code>, <code>COMMIT</code>, and <code>ROLLBACK</code> statements can be used; other statements are not allowed.</p>
<h2 id="2-14-Executing-One-Transaction-from-Within-Another"><a href="#2-14-Executing-One-Transaction-from-Within-Another" class="headerlink" title="2.14. Executing One Transaction from Within Another"></a>2.14. Executing One Transaction from Within Another</h2><p>(nested tracsaction)<br><strong>Problem</strong><br>You are executing a transaction, and you are faced with the need to suspend your current work, issue a completely separate transaction, and then pick up your current work. For example, say you want to log entries into a log table. The log entries should be persisted separately from the current transaction such that if the transaction fails or is rolled back, the log entries will still be completed.<br><strong>Solution</strong><br>Start an autonomous transaction to make the log entry. This will ensure that the log entry is performed separately from the current transaction. In the following example, an employee is deleted from the EMPLOYEES table. Hence, a job is ended, and the job history must be recorded into the <code>JOB_HISTORY</code> table. In the case that something fails within the transaction, the log entry into the <code>JOB_HISTORY</code> table must be intact(adj.完整的,原封不动的). This log entry cannot be rolled back because it is performed using an autonomous transaction.The code to encapsulate(美 [ɪn’kæpsjə’let],vt.压缩,将…装入胶囊) the autonomous transaction needs to be placed into a named block that can be called when the logging needs to be performed. The following piece of code creates a PL&#x2F;SQL procedure that performs the log entry using an autonomous transaction. (You will learn more about procedures in Chapter 4.) Specifically notice(n.通知,布告) the declaration of <code>PRAGMA AUTONOMOUS_TRANSACTION</code>. That pragma specifies that the procedure executes as a separate transaction, independent of any calling transaction.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE log_job_history ( emp_id IN 
                                              employees.employee_id%TYPE, 
                                              Job_id IN jobs.job_id%TYPE, 
                                              Department_id IN employees.department_id%TYPE, 
                                              employee_start IN DATE) AS 
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN 
 INSERT INTO job_history 
 VALUES (emp_id, 
 employee_start, 
 sysdate, 
 job_id, 
 department_id); 
 COMMIT; 
END;
</code></pre>
<p>The <code>LOG_JOB_HISTORY</code> procedure inserts an entry into the log table separately from the transaction that is taking place in the calling code block. The following code performs the job termination, and it calls the <code>log_substitution</code> procedure to record the history:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR dept_removal_cur IS 
    SELECT * 
    FROM employees 
    WHERE department_id &#x3D; 10 
    FOR UPDATE; 
 dept_removal_rec dept_removal_cur%ROWTYPE; 
BEGIN 
 -- Delete all employees from the database who reside in department 10 
 FOR dept_removal_rec IN dept_removal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;DELETING RECORD NOW&#39;); 
    DELETE FROM employees WHERE CURRENT OF dept_removal_cur; 
    -- Log the termination 
    log_job_history(dept_removal_rec.employee_id, 
                      dept_removal_rec.job_id, 
                      dept_removal_rec.department_id, 
                      dept_removal_rec.hire_date);
 END LOOP; 
    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); 
EXCEPTION 
 -- Handles all errors 
 WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been rolled back due to errors, please try again.&#39;); 
    ROLLBACK; 
END;</code></pre>
<p>If this code block is executed and then rolled back, the entry into the job history table remains,because it is performed as a separate, autonomous transaction.<br><strong>How It Works</strong><br>An autonomous transaction is a transaction that is called by another transaction and that runs separately from the calling transaction. Autonomous transactions commit or roll back without affecting the calling transaction. They also have the full functionality of regular transactions; they merely(adv.仅仅,只不过,只是) run separately from the main transaction. They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.</p>
<p>An autonomous transaction must be created with a top-level code block, trigger, procedure,function, or stand-alone named piece of code. In the solution, you saw that a procedure was created to run as an autonomous transaction. That is because it is not possible to create an autonomous transaction within a nested code block. To name a transaction as autonomous, you must place the statement PRAGMA AUTONOMOUS_TRANSACTION within the declaration section of a block encompassing(adj.包含的,包容的,环绕) the transaction. To end the transaction, perform a COMMIT or ROLLBACK.</p>
<text style="font-family:Courier New;color:red">

<p>summary: </br></p>
<ol>
<li>They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.</li>
</ol>
</text>

<h2 id="2-15-Finding-and-Removing-Duplicate-Table-Rows"><a href="#2-15-Finding-and-Removing-Duplicate-Table-Rows" class="headerlink" title="2.15. Finding and Removing Duplicate Table Rows"></a>2.15. Finding and Removing Duplicate Table Rows</h2><p><strong>Problem</strong><br>You have found that for some reason your database contains a table that has duplicate records. You areworking with a database that unfortunately does not use primary key values, so you must manually enforce data integrity. You need a way to remove the duplicate records. However, any query you write to remove one record will also remove its duplicate.<br><strong>Solution</strong><br>The solution to this issue involves two steps. First you need to query the database to find all duplicaterows, and then you need to run a statement to delete one of each duplicate record that is found.The following code block queries the EMPLOYEES table for duplicate rows. When a duplicate is found,it is returned along with a count of duplicates found.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;duplicate_emp_qry&gt;&gt;
DECLARE
CURSOR emp_cur IS
  SELECT *
  FROM employees
  ORDER BY employee_id;
  emp_count
  number :&#x3D; 0;
  total_count
  number :&#x3D; 0;
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;You will see each duplicated employee listed more &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;than once in the list below. This will allow you to &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;review the list and ensure that indeed...there are more &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;than one of these employee records in the table.&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;Duplicated Employees: &#39;);
-- Loop through each player in the table
FOR emp_rec IN emp_cur LOOP
-- Select the number of records in the table that have the same ID as the current record
SELECT count(*)
INTO emp_count
FROM employees
WHERE employee_id &#x3D; emp_rec.employee_id;
-- If the count is greater than one then a duplicate has been found, so print it out.
IF emp_count &gt; 1 THEN 
 DBMS_OUTPUT.PUT_LINE(emp_rec.employee_id || &#39; - &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_count); 
 total_count :&#x3D; total_count + 1; 
 END IF; 
 END LOOP; 
END;</code></pre>
<p>If the table includes a duplicate, then it is printed out as follows:<br>You will see each duplicated employee listed more than once in the list below. This will allow you to review the list and ensure that indeed…there are more<br>than one of these employees in the table.<br>Duplicated Employees:<br>100 - Steven King - 2<br>100 – Steven King - 2<br>PL&#x2F;SQL procedure successfully completed.  </p>
<p>Next, you need to delete the duplicated rows that have been found. The following DELETE statement<br>will ensure that one of the duplicates is removed:<br>DELETE FROM employees A WHERE ROWID &gt; (<br>SELECT min(rowid) FROM employees B<br>WHERE A.employee_id &#x3D; B.employee_id);</p>
<p><strong>How It Works</strong><br>Usually using primary keys prohibits the entry of duplicate rows into a database table. However, many legacy databases still in use today do not include such constraints. In rare situations, a duplicate key and values are entered into the database that can cause issues when querying data or assigning values. The method shown in the solution for finding duplicate rows is very basic. The solution loops through each record in the table, and during each pass, it queries the table for the number of records found that match the current record’s EMPLOYEE_ID. If the number found is greater than one, then you know that you have found a duplicate. The solution presented here for finding duplicates will work on any table provided that you have a column of data that should contain logically unique values. In the example, each record should contain a different EMPLOYEE_ID, so if there is more than one record with the same EMPLOYEE_ID value, then a duplicate is found. If the table you are working with does not contain any unique columns, then you can concatenate a number of columns in order to obtain a unique combination. For instance, if EMPLOYEES did not contain an EMPLOYEE_ID column, then you could concatenate the FIRST_NAME, LAST_NAME, and EMAIL columns to obtain a unique combination. More likely than not, there will not be two employees in the table with the same name and e-mail address. The second part of the solution involves removing one or more duplicate records from the set. To do so, you have to look at a pseudocolumn known as the ROWID. The ROWID is a pseudocolumn (invisible column) that is found in each table in an Oracle Database that uniquely identifies each row. By comparing these unique ROWID values, you can delete just one of the records, not both. The DELETE statement actually finds the rows that contain the same uniquely identified column(s) and then removes the row with the larger ROWID value.</p>
<h1 id="3-Looping-and-Logic"><a href="#3-Looping-and-Logic" class="headerlink" title="3. Looping and Logic"></a>3. Looping and Logic</h1><h2 id="3-1-Choosing-When-to-Execute-Code"><a href="#3-1-Choosing-When-to-Execute-Code" class="headerlink" title="3.1. Choosing When to Execute Code"></a>3.1. Choosing When to Execute Code</h2><p><strong>Problem</strong><br>Your code contains a condition, and you are interested in executing code to perform specific actions if the condition evaluates to <code>TRUE</code>, <code>FALSE</code>, or <code>NULL</code>.<br><strong>Solution</strong><br>Use an <code>IF-THEN</code> statement to evaluate an expression (or condition) and determine which code to execute<br>as a result. The following example depicts a very simple <code>IF-THEN</code> statement that evaluates one variable to see whether it contains a larger value than another variable. If so, then the statements contained within the <code>IF-THEN</code> statement are executed; otherwise, they are ignored. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 value_one NUMBER :&#x3D; &amp;value_one; 
 value_two NUMBER :&#x3D; &amp;value_two; 
BEGIN 
 IF value_one &gt; value_two THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;value_one is greater than value_two&#39;); 
 END IF; 
END; </code></pre>
<p>As you can see from the example, if value_one is greater than value_two, a line of output will be printed stating so. Otherwise, the IF statement is bypassed, and processing continues.<br><strong>How It Works</strong><br>As shown in the solution, the general format for the IF-THEN statement is as follows:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">IF condition THEN
 Statements to be executed 
 …
END IF; </code></pre>
<p>The <code>IF-THEN</code> statement is one of the most frequently used conditional statements. If a given condition evaluates to <code>TRUE</code>, then the code contained within the IF-THEN statement is executed. If the condition evaluates to FALSE or NULL, then the statement is exited. However, it is possible to incorporate(vt.包含,吸收) a different set of statements if the condition is not satisfied. Please see Recipe 3-2 for an example. Any number of <code>IF-THEN</code> statements can be nested within one another. The statements within the <code>IF-THEN</code> will be executed if the condition that is specified evaluates to <code>TRUE</code>.</p>
<h2 id="3-2-Choosing-Between-Two-Mutually-Exclusive-Conditions"><a href="#3-2-Choosing-Between-Two-Mutually-Exclusive-Conditions" class="headerlink" title="3-2. Choosing Between Two Mutually Exclusive Conditions"></a>3-2. Choosing Between Two Mutually Exclusive Conditions</h2><p><strong>Problem</strong><br>You have two conditions that are mutually(美 [‘mjutʃuəli]adv.互相地,互助) exclusive. You want to execute one set of statements if the<br>first condition evaluates to TRUE. Otherwise, if the first condition is FALSE or NULL, then execute a different<br>set of statements.<br><strong>Solution</strong><br>Use an IF-ELSE statement to evaluate the condition and execute the statements that correspond to it if<br>the condition evaluates to TRUE. In the following example, a given employee ID is used to query the<br>EMPLOYEES table. If that employee exists, then the employee record will be retrieved. If not found, then a<br>message will be displayed stating that no match was found. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 employee employees%ROWTYPE; 
 emp_count number :&#x3D; 0; 
BEGIN 
 SELECT count(*) 
 INTO emp_count 
 FROM employees 
 WHERE employee_id &#x3D; 100; 
 IF emp_count &gt; 0 THEN 
 SELECT * 
 INTO employee 
 FROM employees 
 WHERE employee_id &#x3D; 100; 
 IF employee.manager_id IS NOT NULL THEN 
 DBMS_OUTPUT.PUT_LINE(employee.first_name || &#39; &#39; || employee.last_name || 
 &#39; has an assigned manager.&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(employee.first_name || &#39; &#39; || employee.last_name || 
 &#39; does not have an assigned manager.&#39;); 
END IF; 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;The given employee ID does not match any records, &#39;|| 
 &#39; please try again&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Try another employee ID.&#39;); 
END; </code></pre>
<p>In the real world, the employee ID would not be hard-coded into the example. However, this example provides a good scenario for evaluating mutually exclusive conditions and also nesting IF statements.<br><strong>How It Works</strong><br>The <code>IF-ELSE</code> statement syntax is basically the same as the <code>IF-THEN</code> syntax, except that a different set of<br>statements is executed in the ELSE clause when the condition evaluates to FALSE or NULL. Therefore, if the<br>first condition is FALSE or NULL, then the control automatically drops down into the statements contained<br>within the ELSE clause and executes them.</p>
<h2 id="3-3-Evaluating-Multiple-Mutually-Exclusive-Conditions"><a href="#3-3-Evaluating-Multiple-Mutually-Exclusive-Conditions" class="headerlink" title="3.3. Evaluating Multiple Mutually Exclusive Conditions"></a>3.3. Evaluating Multiple Mutually Exclusive Conditions</h2><p><strong>Problem</strong><br>Your application has multiple conditions to evaluate, and each of them is mutually exclusive. If one of<br>the conditions evaluates to FALSE, you’d like to evaluate the next one. You want that process to continue<br>until there are no more conditions.<br>Two solutions are possible: one using IF and the other using <code>CASE</code>.</p>
<p><strong>Solution #1</strong><br>Use an <code>IF-ELSIF-ELSE</code> statement to perform an evaluation of all mutually exclusive conditions. The following example is a SQL*Plus script that queries how many countries are in a specified region.</p>
<p>If the region that is typed as input when the following example executes matches any of the regions specified by the conditions in the IF statement, then subsequent statements are executed. However, a default message is displayed if the input does not match any region.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 Region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; 
 country_count number :&#x3D; 0; 
BEGIN 
 IF upper(region) &#x3D; &#39;EUROPE&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 1; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Europe region.&#39;); 
 ELSIF upper(region) &#x3D; &#39;AMERICAS&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 2; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Americas region.&#39;); 
 ELSIF upper(region) &#x3D; &#39;ASIA&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 3; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Asia region.&#39;); 
 ELSIF upper(region) &#x3D; &#39;MIDDLE EAST AND AFRICA&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 4; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Middle East and Africa region.&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); 
 END IF; 
END; </code></pre>
<p><strong>Solution #2</strong><br>You can use the searched <code>CASE</code> statement to evaluate a boolean expression to determine which statements to execute among multiple, mutually exclusive conditions. The next example is a SQL*Plus script that performs the same tasks as <strong>Solution #1</strong> but this time using a searched <code>CASE</code> statement:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; 
 country_count number :&#x3D; 0; 
BEGIN 
 CASE 
 WHEN upper(region) &#x3D; &#39;EUROPE&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 1; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Europe region.&#39;); 
 WHEN upper(region) &#x3D; &#39;AMERICAS&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 2; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Americas region.&#39;); 
 WHEN upper(region) &#x3D; &#39;ASIA&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 3; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Asia region.&#39;); 
 WHEN upper(region) &#x3D; &#39;MIDDLE EAST AND AFRICA&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 4; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Middle East and Africa region.&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); 
 END CASE; 
END; 
</code></pre>
<p><strong>How It Works</strong><br>IF-ELSIF-ELSE can be used to evaluate any number of conditions. It functions such that if the first<br>condition in the IF-ELSIF-ELSE statement evaluates to TRUE, then the statements within its block are<br>executed, and all others are bypassed. Similarly, if the first condition evaluates to FALSE and the second<br>condition evaluates to TRUE, then the second condition’s statements will be executed, others will be<br>ignored, and so on.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CASE
 WHEN &lt;&lt;boolean_expression&gt;&gt; THEN &lt;&lt;statements&gt;&gt; 
[ELSE statements]; </code></pre>


<h2 id="3-4-Driving-from-an-Expression-Having-Multiple-Outcomes"><a href="#3-4-Driving-from-an-Expression-Having-Multiple-Outcomes" class="headerlink" title="3.4 Driving from an Expression Having Multiple Outcomes"></a>3.4 Driving from an Expression Having Multiple Outcomes</h2><p><strong>Problem</strong><br>You have a single expression that yields multiple outcomes. You are interested in evaluating the expression and performing a different set of statements depending upon the outcome.<br><strong>Solution</strong><br>Use a CASE statement to evaluate your expression, and decide which set of statements to execute depending upon the outcome. In the following example, a SQL*Plus script accepts a region entry, which is being evaluated to determine the set of statements to be executed. Based upon the value of the region, the corresponding set of statements is executed, and once those statements have been executed, then the control is passed to the statement immediately following the CASE statement. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; 
 country_count number :&#x3D; 0; 
BEGIN 
 CASE upper(region) 
 WHEN &#39;EUROPE&#39; THEN 
    SELECT count(*) 
    INTO country_count 
    FROM countries 
    WHERE region_id &#x3D; 1; 
    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Europe region.&#39;); 
 WHEN &#39;AMERICAS&#39; THEN 
    SELECT count(*) 
    INTO country_count 
    FROM countries 
    WHERE region_id &#x3D; 2; 
    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; ||&#39;the Americas region.&#39;); 
 WHEN &#39;ASIA&#39; THEN 
    SELECT count(*) 
    INTO country_count 
    FROM countries 
    WHERE region_id &#x3D; 3; 
    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Asia region.&#39;); 
 WHEN &#39;MIDDLE EAST AND AFRICA&#39; THEN 
    SELECT count(*) 
    INTO country_count 
    FROM countries 
    WHERE region_id &#x3D; 4; 
    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Middle East and Africa region.&#39;); 
 ELSE 
    DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); 
 END CASE; 
END; 
</code></pre>

<p><strong>How It Works</strong><br>There are two different types of CASE statements that can be used—those being the searched CASE and the simple CASE statement. The solution to this recipe demonstrates the simple CASE. For an example of a searched CASE statement, please see Recipe 3-3.</p>
<p>The simple CASE statement begins with the keyword CASE followed by a single expression called a selector. The selector is evaluated one time, and it can evaluate to any PL&#x2F;SQL type other than BLOB, BFILE, an object type, a record, or a collection type. The selector is followed by a series of WHEN clauses. The WHEN clauses are evaluated sequentially to determine whether the value of the selector equals the result from any of the WHEN clause expressions. If a match is found, then the corresponding WHEN clause is executed.</p>
<p>The CASE statement can include any number of WHEN clauses, and much like an IF statement, it can be followed with a trailing ELSE clause that will be executed if none of the WHEN expressions matches. If the ELSE clause is omitted, a predefined exception will be raised if the CASE statement does not match any of the WHEN clauses. The END CASE keywords end the statement.</p>
<h2 id="3-5-Looping-Until-a-Specified-Condition-Is-Met"><a href="#3-5-Looping-Until-a-Specified-Condition-Is-Met" class="headerlink" title="3.5. Looping Until a Specified Condition Is Met"></a>3.5. Looping Until a Specified Condition Is Met</h2><p><strong>Problem</strong><br>You want to loop through a set of statements until a specified condition evaluates to true.<br><strong>Solution</strong><br>Use a simple <code>LOOP</code> statement along with an <code>EXIT</code> clause to define a condition that will end the iteration.<br>The following example shows a simple LOOP that will print out each employee with a department_id equal<br>to 90:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
CURSOR emp_cur IS
SELECT *
FROM employees
WHERE department_id &#x3D; 90;
emp_rec employees%ROWTYPE;

BEGIN
OPEN emp_cur;
LOOP
  FETCH emp_cur into emp_rec;
  IF emp_cur%FOUND THEN
    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;-&#39;|| emp_rec.email);
  ELSE
    EXIT;
  END IF;
END LOOP;
CLOSE emp_cur;
END;
</code></pre>

<p>As you can see from the example, the cursor is opened prior to the start of the loop. Inside the loop,<br>the cursor is fetched into emp_rec, and emp_rec is evaluated to see whether it contains anything using the<br>cursor %FOUND attribute. If emp_cur%FOUND is FALSE, then the loop is exited using the EXIT keyword.<br><strong>How It Works</strong><br>The simple LOOP structure is very easy to use for generating a loop in your code. The LOOP keyword is used<br>to start the loop, and the END LOOP keywords are used to terminate it. Every simple loop must contain an<br>EXIT or GOTO statement; otherwise, the loop will become infinite and run indefinitely.<br>You can use a couple of different styles for the EXIT. When used alone, the EXIT keyword causes a<br>loop to be terminated immediately, and control is passed to the first statement following the loop. You<br>can use the EXIT-WHEN statement to terminate the loop based upon the evaluation of a condition after the<br>WHEN statement. If the condition evaluates to TRUE, then the loop is terminated; otherwise, it will<br>continue.<br>The following example shows the same LOOP as the example in the solution, but instead of using an<br>IF statement to evaluate the content of emp_rec, the <code>EXIT-WHEN</code> statement is used:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
CURSOR emp_cur IS
SELECT *
FROM employees
WHERE department_id &#x3D; 90;
emp_rec employees%ROWTYPE;
BEGIN
OPEN emp_cur;
 LOOP 
 FETCH emp_cur into emp_rec; 
 EXIT WHEN emp_cur%NOTFOUND; 
      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39;-&#39; || emp_rec.email); 
 END LOOP; 
 CLOSE emp_cur; 
END; </code></pre>
<p>You can use a loop to iterate over any number of things including cursors or collections of data. As<br>you will see in some of the coming recipes, different forms of loops work better in different<br>circumstances. </p>
<h2 id="3-6-Iterating-Cursor-Results-Until-All-Rows-Have-Been-Returned"><a href="#3-6-Iterating-Cursor-Results-Until-All-Rows-Have-Been-Returned" class="headerlink" title="3.6. Iterating Cursor Results Until All Rows Have Been Returned"></a>3.6. Iterating Cursor Results Until All Rows Have Been Returned</h2><p><strong>Problem</strong><br>You have created a cursor and retrieved a number of rows from the database. As a result, you want to<br>loop through the results and do some processing on them.<br><strong>Solution</strong><br>Use a standard FOR loop to iterate through the records. Within each iteration of the loop, process the<br>current record. The following code shows the use of a FOR loop to iterate through the records retrieved<br>from the cursor and display each employee name and e-mail. Each iteration of the loop returns an<br>employee with the job_id of ‘ST_MAN’, and the loop will continue to execute until the cursor has been<br>exhausted.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 CURSOR emp_cur IS 
 SELECT * 
 FROM employees 
 WHERE job_id &#x3D; &#39;ST_MAN&#39;; 
 emp_rec employees%ROWTYPE; 
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
 DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || 
 &#39; - &#39; || emp_rec.email); 
 END LOOP; 
END; </code></pre>

<p>Here are the results:<br>Matthew Weiss - MWEISS<br>Adam Fripp - AFRIPP<br>Payam Kaufling - PKAUFLIN<br>Shanta Vollman - SVOLLMAN<br>Kevin Mourgos - KMOURGOS<br>PL&#x2F;SQL procedure successfully completed</p>
<p>As you can see, the employee records that meet the specified criteria are displayed.</p>
<h2 id="3-7-Iterating-Until-a-Condition-Evaluates-to-FALSE"><a href="#3-7-Iterating-Until-a-Condition-Evaluates-to-FALSE" class="headerlink" title="3.7. Iterating Until a Condition Evaluates to FALSE"></a>3.7. Iterating Until a Condition Evaluates to FALSE</h2><p><strong>Problem</strong><br>You want to iterate over a series of statements until a specified condition no longer evaluates to TRUE.<br><strong>Solution</strong><br>Use a WHILE statement to test the condition, and execute the series of statements if the condition<br>evaluates to TRUE; otherwise, skip the statements completely. The following example shows a WHILE<br>statement evaluating the current value of a variable and looping through until the value of the variable<br>reaches ten. Within the loop, this variable is being multiplied by two and printing out its current value.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 myValue NUMBER :&#x3D; 1; 
BEGIN 
WHILE myValue &lt; 10 LOOP 
 DBMS_OUTPUT.PUT_LINE(&#39;The current value is: &#39; || myValue); 
 myValue :&#x3D; myValue * 2; 
 END LOOP;
END;</code></pre>

<p>Here are the results:<br>The current value is: 1<br>The current value is: 2<br>The current value is: 4<br>The current value is: 8<br>PL&#x2F;SQL procedure successfully completed.<br>The important thing to note in this example is that the value of myValue is increased with each<br>iteration of the loop as to eventually meet the condition specified in the <code>WHILE</code> loop.</p>
<p><strong>How It Works</strong><br>The WHILE loop tests a condition at the top of the loop, and if it evaluates to TRUE, then the statements within the loop are executed, and control is returned to the start of the loop where the condition is tested again. If the condition does not evaluate to TRUE, the loop is bypassed, and control goes to the next statement after the END LOOP. If the condition never fails, then an infinite loop is formed, so it is important to ensure that the condition will eventually evaluate to FALSE. It is important to note that the statements in the loop will never be executed if the condition evaluates to FALSE during the first pass. This situation is different from the simple loop that always<br>iterates at least once because the EXIT condition is usually evaluated elsewhere in the loop. To ensure that a WHILE loop is always executed at least one time, you must ensure that the condition evaluates to TRUE at least once. One way to do this is to use a flag variable that is evaluated with each iteration of the loop. Set the flag equal to FALSE prior to starting the loop, and then set it to TRUE when a certain condition is met inside the loop. The following pseudocode depicts such a solution:</p>
<pre class="language-none"><code class="language-none">BEGIN 
 flag &#x3D; FALSE; 
 WHILE flag &#x3D; TRUE LOOP 
Perform statements 
 flag &#x3D; Boolean expression; 
 END LOOP; 
END; </code></pre>
<p>As mentioned previously, the boolean expression that is assigned to the flag in this case must<br>eventually evaluate to FALSE; otherwise, an infinite loop will occur.</p>
<h2 id="3-8-Bypassing-the-Current-Loop-Iteration"><a href="#3-8-Bypassing-the-Current-Loop-Iteration" class="headerlink" title="3.8.Bypassing the Current Loop Iteration"></a>3.8.Bypassing the Current Loop Iteration</h2><p><strong>Problem</strong><br>If a specified conditional statement evaluates to TRUE, you want to terminate the current loop iteration of<br>the loop early and start the next iteration immediately.<br><strong>Solution</strong><br>Use a CONTINUE statement along with a condition to end the current iteration. In the following example, a loop is used to iterate through the records in the employees table. The primary reason for the loop is to print out a list of employees who receive a salary greater than 15,000. If an employee does not receive more than 15,000, then nothing is printed out, and the loop continues to the next iteration.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
    CURSOR emp_cur is 
    SELECT * 
    FROM employees; 
    emp_rec emp_cur%ROWTYPE; 
BEGIN 
    DBMS_OUTPUT.PUT_LINE(&#39;Employees with salary &gt; 15000: &#39;); 
OPEN emp_cur;
 LOOP 
 FETCH emp_cur INTO emp_rec; 
 EXIT WHEN emp_cur%NOTFOUND; 
 IF emp_rec.salary &lt; 15000 THEN 
 CONTINUE;
 ELSE 
    DBMS_OUTPUT.PUT_LINE(&#39;Employee: &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name); 
 END IF; 
 END LOOP; 
 CLOSE emp_cur; 
END; </code></pre>

<p>Here are some sample results:<br>Employees with salary &gt; 15000:<br>Employee: Steven King<br>Employee: Neena Kochhar<br>Employee: Lex De Haan<br>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>You can use the CONTINUE statement in any loop to unconditionally halt execution of the current iteration<br>of the loop and move to the next. As shown in the solution, the CONTINUE statement is usually<br>encompassed within some conditional statement so that it is invoked only when that certain condition<br>is met. </p>
<p>You can use the CONTINUE statement along with a label in order to jump to a specified point in the<br>program. Rather than merely using CONTINUE to bypass the current loop iteration, specifying a label will<br>allow you to resume programming in an outer loop. For more information regarding the use of the<br>CONTINUE statement along with labels in nested loops, please see Recipe 3-13.<br>As an alternative to specifying CONTINUE from within an IF statement, you can choose to write a<br>CONTINUE WHEN statement. For example, the following two approaches yield identical results: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql"> IF team_rec.total_points &lt; 10 THEN 
 CONTINUE; 
or 
 CONTINUE WHEN rec.total_points &lt; 10; </code></pre>

<p>Using the <code>CONTINUE WHEN</code> format, the loop will stop its current iteration if the condition in the WHEN<br>clause is met. Otherwise, the iteration will ignore the statement altogether.</p>
<h2 id="3-9-Iterating-a-Fixed-Number-of-Times"><a href="#3-9-Iterating-a-Fixed-Number-of-Times" class="headerlink" title="3.9. Iterating a Fixed Number of Times"></a>3.9. Iterating a Fixed Number of Times</h2><p><strong>Problem</strong><br>You are interested in executing the contents of a loop a specified number of times. For example, you are<br>interested in executing a loop ten times, and you need to number each line of output in the range by the<br>current loop index.<br><strong>Solution</strong><br>Write a FOR loop. Use a variable to store the current index of the loop while looping through a range of<br>numbers from one to ten in ascending order. The following lines of code will iterate ten times through a<br>loop and print out the current index in each pass:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
 FOR idx IN 1..10 LOOP 
 DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx); 
 END LOOP; 
END;</code></pre>
<pre class="language-none"><code class="language-none">Here is the result: 
The current index is: 1 
The current index is: 2 
The current index is: 3 
The current index is: 4 
The current index is: 5 
The current index is: 6 
The current index is: 7 
The current index is: 8 
The current index is: 9
The current index is: 10</code></pre>
<p>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>The FOR loop will increment by one through the given range for each iteration until it reaches the end.<br>The loop is opened using the keyword FOR, followed by a variable that will be used as the index for the<br>loop. Following the index variable is the IN keyword, which is used to signify that the index variable<br>should increment one by one through the given range, which is listed after the IN keyword. The loop is<br>terminated using the END LOOP keywords.<br>Each statement contained within the loop is executed once for each iteration of the loop. The index<br>variable can be used within the loop, but it cannot be changed. As shown in the solution, you may use<br>the index for printing purposes, and it is oftentimes used in calculations as well.<br>The REVERSE keyword should be placed directly after the IN keyword and before the range that you<br>specify. The REVERSE keyword has no effect when working with cursors. If you need to iterate through<br>cursor results in a specific order, then specify an ORDER BY clause in your SELECT statement. </p>
<h2 id="3-11-Iterating-in-Increments-Other-Than-One"><a href="#3-11-Iterating-in-Increments-Other-Than-One" class="headerlink" title="3.11 Iterating in Increments Other Than One"></a>3.11 Iterating in Increments Other Than One</h2><p>3-11. Iterating in Increments Other Than One<br><strong>Problem</strong><br>Rather than iterating through a range of numbers one at a time, you want to increment by some other<br>value. For example, you might want to increment through even values such as 2, 4, 6, and so forth.<br><strong>Solution</strong><br>Multiply the loop index by two (or by whatever other multiplier you need) to achieve the effect of<br>incrementing through all even numbers. As you can see in the following example, an even number is<br>always generated when the index is multiplied by two: </p>
<pre class="language-none"><code class="language-none">BEGIN 
 FOR idx IN 1..5 LOOP 
 DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx*2); 
 END LOOP; 
END;</code></pre>
<p>Here is the result:<br>The current index is: 2<br>The current index is: 4<br>The current index is: 6<br>The current index is: 8<br>The current index is: 10<br>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>Unlike some other languages, PL&#x2F;SQL does not include a STEP clause that can be used while looping. To<br>work around that limitation, you will need to write your own stepping algorithm. In the solution to this<br>recipe, you can see that the algorithm was quite easy; you simply multiply the index by two to achieve<br>the desired result. In this solution, assigning the range of 1..5 as the index produces the effect of iterating<br>through all even numbers from 2..10 when the current index is multiplied by two.<br>Using similar techniques, you can increment through ranges of numbers in various intervals.<br>However, sometimes this can become troublesome if you are attempting to step by anything other than<br>even numbers. You can see an example of this in the next recipe.</p>
<h2 id="3-12-Stepping-Through-a-Loop-Based-on-Odd-Numbered-Increments"><a href="#3-12-Stepping-Through-a-Loop-Based-on-Odd-Numbered-Increments" class="headerlink" title="3.12. Stepping Through a Loop Based on Odd-Numbered Increments"></a>3.12. Stepping Through a Loop Based on Odd-Numbered Increments</h2><p><strong>Problem</strong><br>Rather than iterating through a range of numbers by even increments, you prefer to loop through the<br>range using odd increments.<br><strong>Solution</strong><br>Use the built-in MOD function to determine whether the current index is odd. If it is odd, then print out<br>the value; otherwise, continue to the next iteration. The following example shows how to implement this<br>solution:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
 FOR idx IN 1..10 LOOP 
 IF MOD(idx,2) !&#x3D; 0 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx); 
 END IF; 
 END LOOP; 
END; </code></pre>

<p>Results:<br>The current index is: 1<br>The current index is: 3<br>The current index is: 5<br>The current index is: 7<br>The current index is: 9<br>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>The solution depicts one possible workaround for a STEP replacement. Using the MOD function to<br>determine whether a number is odd works quite well. The MOD function, otherwise known as the modulus<br>function, is used to return the remainder from the division of the two numbers that are passed into the<br>function. Therefore, this function is useful for determining even or odd numbers. In this case, if any<br>value is returned from MOD, then the number is assumed to be odd, and the statements within the IF<br>statement will be executed.<br>Such a technique may be useful in the case of iterating through a collection of data such as a table. If<br>you want to grab every other record from the collection, then performing a stepping solution such as this<br>or the solution from Recipe 3-11 will allow you to achieve the desired result. You could easily use the<br>resulting index from this technique as the index for a collection.</p>
<h2 id="3-13-Exiting-an-Outer-Loop-Prematurely"><a href="#3-13-Exiting-an-Outer-Loop-Prematurely" class="headerlink" title="3.13. Exiting an Outer Loop Prematurely"></a>3.13. Exiting an Outer Loop Prematurely</h2><p><strong>Problem</strong><br>Your code contains a nested loop, and you want the inner loop to have the ability to exit from both loops<br>and stop iteration completely.<br><strong>Solution</strong><br>Use loop labels for both loops and then reference either loop within an EXIT statement by following the<br>EXIT keyword with a loop label. The following example prints out a series of numbers. During each<br>iteration, the inner loop will increment until it reaches an odd number. At that point, it will pass control<br>to the outer loop again. The outer loop will be exited when the index for the inner loop is greater than or<br>equal to the number ten. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
 &lt;&lt;outer&gt;&gt; for idx1 in 1 .. 10 loop 
 &lt;&lt;inner&gt;&gt; for idx2 in 1 .. 10 loop 
 dbms_output.put(idx2); 
 exit inner when idx2 &gt; idx1 * 2; 
 exit outer when idx2 &#x3D; 10; 
 END LOOP; 
 DBMS_OUTPUT.NEW_LINE; 
 END LOOP; 
 DBMS_OUTPUT.NEW_LINE; 
END;</code></pre>
<p>Results:<br>123<br>12345<br>1234567<br>123456789<br>12345678910<br>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>Any loop in PL&#x2F;SQL can be labeled using a similar style to labels for code blocks. The label can be any<br>valid identifier surrounded by angle brackets before the loop, and optionally the identifier can be placed<br>at the end after the END LOOP clause. The result of such a labeling mechanism is that you will have a<br>distinct start and end to the loops and more control over loop execution.<br>In the solution to this recipe, the label helps identify the outer loop so that it can be terminated with<br>the EXIT clause. Without a label, the EXIT will terminate the innermost FOR loop. However, the label can<br>also be used to help identify the loop’s index. In the solution, this is not necessary because the outer loop<br>index was named differently than the inner loop index. If both indexes were named the same, then you<br>could use the loop label along with the index name to fully qualify the index. The following example<br>demonstrates this technique:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN
&lt;&lt;outer&gt;&gt; FOR idx IN 1 .. 10 LOOP
&lt;&lt;inner&gt;&gt; FOR idx IN 1 .. 10 LOOP
  DBMS_OUTPUT.PUT(inner.idx);
EXIT inner WHEN inner.idx &gt; outer.idx * 2;
EXIT outer WHEN inner.idx &#x3D; 10;
END LOOP;
  DBMS_OUTPUT.NEW_LINE;
END LOOP;
  DBMS_OUTPUT.NEW_LINE;
END;</code></pre>

<p>This code will display the same results as the example given in the solution to this recipe. The only<br>difference is that in this example the index name is the same in both the inner and outer loops. An<br>alternative technique to end the current iteration of an inner loop is to use the CONTINUE statement. A<br>CONTINUE statement can reference the label of a loop that is within the same scope. Therefore, an inner<br>loop can exit its current iteration and proceed to an outer loop, as the following example demonstrates:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
BEGIN
&lt;&lt;outer&gt;&gt; for idx1 in 1 .. 10 loop
&lt;&lt;inner&gt;&gt; for idx2 in 1 .. 10 loop
dbms_output.put(idx2);
exit inner when idx2 &gt; idx1 * 2;
exit outer when idx2 &#x3D; 10;
END LOOP;
CONTINUE outer;
END LOOP;
DBMS_OUTPUT.NEW_LINE;
END;</code></pre>
<p>In this example, the same code that is used in the solution to this recipe is rewritten to incorporate a<br>CONTINUE statement. This statement is used to move control of execution back to the outer loop. When<br>the CONTINUE statement is reached, execution of the current loop is immediately halted, and processing<br>continues to the loop designated by the label.</p>
<h2 id="3-14-Jumping-to-a-Designated-Location-in-Code"><a href="#3-14-Jumping-to-a-Designated-Location-in-Code" class="headerlink" title="3.14. Jumping to a Designated Location in Code"></a>3.14. Jumping to a Designated Location in Code</h2><p><strong>Problem</strong><br>You want your code to stop executing and jump to a different, designated location.<br><strong>Solution</strong><br>Use a GOTO statement along with a label name to cause code execution to jump into the position where<br>the label is located.<br>The following example shows the GOTO statement in action. The user is prompted to enter a numeric<br>value, and that value is then evaluated to determine whether it is greater than ten. In either case, a<br>message is printed, and then the code jumps to the end_msg label. If the number entered is a negative<br>number, then the code jumps to the bad_input label where an error message is printed.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 in_number number :&#x3D; 0; 
BEGIN 
 in_number :&#x3D; &#39;&amp;input_number&#39;; 
 IF in_number &gt; 10 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The number you entered is greater than ten&#39;); 
 GOTO end_msg; 
 ELSIF in_number &lt;&#x3D; 10 and in_number &gt; 0 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The number you entered is less than or equal to ten&#39;); 
 GOTO end_msg; 
 ELSE 
 -- Entered a negative number 
 GOTO bad_input; 
 END IF; 
 &lt;&lt; bad_input &gt;&gt; 
 DBMS_OUTPUT.PUT_LINE(&#39;Invalid input. No negatives allowed.&#39;); 
 &lt;&lt; end_msg &gt;&gt; 
 DBMS_OUTPUT.PUT_LINE(&#39;Thank you for playing..&#39;); 
END; </code></pre>
<p><strong>How It Works</strong><br>The GOTO statement is used to branch code unconditionally. Code can be branched to any label within<br>the same scope as the GOTO. In the solution, the GOTO statement causes the code to branch to a parent<br>code block. You could just as easily branch to a loop within the current or outer block. However, you<br>cannot branch to a label within a subblock, IF statement, or LOOP. </p>
<p>You should use this statement sparingly because arbitrary branching makes code difficult to read. Use<br>conditional statements to branch whenever possible, because that’s why they were put into the<br>language. As you can see from the solution, the same code could have been written printing the “Invalid<br>number” message within the ELSE clause. There are usually better alternatives to using GOTO. </p>
<h1 id="4-Functions-Packages-and-Procedures"><a href="#4-Functions-Packages-and-Procedures" class="headerlink" title="4. Functions, Packages,and Procedures"></a>4. Functions, Packages,and Procedures</h1><p>PL&#x2F;SQL applications are composed of functions, procedures, and packages. Functions are PL&#x2F;SQL<br>programs that accept zero or more parameters and always return a result. Procedures are similar to<br>functions, but they are not required to return a result. Packages are a combination of related functions,<br>procedures, types, and variables. Each of these PL&#x2F;SQL components helps formulate the basis for small<br>and large applications alike. They differ from anonymous blocks that have been covered in previous<br>recipes because they are all named routines that are stored within the database. Together, they provide<br>the advantage of reusable code that can be called from any schema in the database to which you’ve<br>granted the appropriate access.<br>Let’s say you have a few lines of code that perform some calculations on a number and return a<br>result. Will these calculations help you anywhere else? If so, then you should probably encapsulate this<br>code in a function. Maybe you have a nightly script that you use as a batch job to load and execute.<br>Perhaps this script can be turned into a stored procedure and Oracle Scheduler can kick it off each night.<br>What about tasks that use more than one procedure or function? Can these be combined at all? A<br>PL&#x2F;SQL package would probably be a good choice in this case. After reading through the recipes in this<br>chapter, you should be able to answer these questions at the drop of a hat.<br>■ Note We mention job scheduling in our introduction to this chapter. However, we actually address that topic in<br>Chapter 11, which is an entire chapter dedicated to running PL&#x2F;SQL jobs, whether for application purposes or for<br>database maintenance. </p>
<h2 id="4-1-Creating-a-Stored-Function"><a href="#4-1-Creating-a-Stored-Function" class="headerlink" title="4-1. Creating a Stored Function"></a>4-1. Creating a Stored Function</h2><p><strong>Problem</strong><br>One of your programs is using a few lines of code repeatedly for performing a calculation. Rather than<br>using the same lines of code numerous times throughout your application, it makes more sense to<br>encapsulate(美[ɪn’kæpsjə’let]vt.压缩;将…装入胶囊) the functionality into a common routine that can be called and reused time and time again.<br><strong>Solution</strong><br>Create a stored function to encapsulate your code, and save it into the database. Once stored in the<br>database, any user with execution privileges can invoke the function. Let’s take a look at a function to<br>give you an idea of how they work.<br>In this example, the function is used to round a given number to the nearest quarter. This function<br>works well for accepting a decimal value for labor hours and rounding to the nearest quarter hour. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- at return part and no paramter name just a type
CREATE OR REPLACE FUNCTION CALC_QUARTER_HOUR(HOURS IN NUMBER) RETURN NUMBER AS  
  CALCULATED_HOURS NUMBER :&#x3D; 0; 
BEGIN 
  
   -- if HOURS is greater than one, then calculate the decimal portion 
   -- based upon quarterly hours  
 IF HOURS &gt; 1 THEN 
  -- calculate the modulus of the HOURS variable and compare it to • 
  -- fractional values 
    IF MOD(HOURS, 1) &lt;&#x3D;.125 THEN 
       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1); 
    ELSIF MOD(HOURS, 1) &gt; .125 AND MOD(HOURS,1) &lt;&#x3D; .375 THEN 
       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.25,1); 
    ELSIF MOD(HOURS, 1) &gt; .375 AND MOD(HOURS,1) &lt;&#x3D; .625 THEN 
       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.50,1); 
    ELSIF MOD(HOURS, 1) &gt; .63 AND MOD(HOURS,1) &lt;&#x3D; .825 THEN 
       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.75,1); 
    ELSE 
       CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); 
       
    END IF; 
     
  ELSE 
    -- if HOURS is less than one, then calculate the entire value• 
    -- based upon quarterly hours 
    IF HOURS &gt; 0 AND HOURS &lt;&#x3D;.375 THEN 
        CALCULATED_HOURS :&#x3D; .25; 
    ELSIF HOURS &gt; .375 AND HOURS &lt;&#x3D; .625 THEN 
        CALCULATED_HOURS :&#x3D; .5; 
    ELSIF HOURS &gt; .625 AND HOURS &lt;&#x3D; .825 THEN 
        CALCULATED_HOURS :&#x3D; .75; 
    ELSE 
        CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); 
    END IF; 
     
  END IF; 
   
  RETURN CALCULATED_HOURS; 
   
END CALC_QUARTER_HOUR; </code></pre>
<p>This function accepts one value as input, a decimal value representing a number of hours worked.<br>The function then checks to see whether the value is greater than one, and if so, it performs a series of<br>manipulations to round the value to the nearest quarter hour. If the value is not greater than one, then<br>the function rounds the given fraction to the nearest quarter.<br>■ Note See Recipe 4-2 for an example showing the execution of this function. </p>
<p><strong>How It Works</strong><br>A function is a named body of code that is stored within the database and returns a value. Functions are<br>often used to encapsulate logic so that it can be reused. A function can accept zero or more parameters<br>and always returns a value. A function is comprised of a header, an execution section containing<br>statements, and an optional exception block.<br>For example, the header for our solution function is as follows:  </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION CALC_QUARTER_HOUR(HOURS IN NUMBER) RETURN NUMBER AS  </code></pre>
<p>The OR REPLACE clause is optional, but in practice it is something you’ll most always want. Specifying<br>OR REPLACE will replace a function that is already under the same name in the same schema. (A function<br>name must be unique within its schema.)<br>Functions can take zero or more parameters, which can be any datatype including collections. You<br>will learn more about collections in Chapter 10. Our example function takes one parameter, a NUMBER<br>representing some number of hours.<br>The parameters that can be passed to a function can be declared in three different ways, namely, as<br>IN, OUT, and IN OUT. The difference between these three declaration types is that parameters declared as<br>IN are basically read-only, OUT parameters are write-only, and IN OUT parameters are read-write. The<br>value of an OUT parameter is initially NULL but can contain a value after the function has returned.<br>Similarly, the value of an IN OUT can be modified within the function, but IN parameters cannot.<br>■ Note Typically you want only IN parameters for a function. If you find yourself creating a function with OUT or IN<br>OUT parameters, then reconsider and think about creating a stored procedure instead. This is not a hard-and-fast<br>requirement, but it is generally good practice for a function to return only one value.<br>The declaration section of the function begins directly after the header, and unlike the anonymous<br>block, you do not include the DECLARE keyword at the top of this section. Just like the anonymous block,<br>the declaration section is where you will declare any variables, types, or cursors for your function. Our<br>declaration section defines a single variable:<br> <pre class="language-sql" data-language="sql"><code class="language-sql">CALCULATED_HOURS NUMBER :&#x3D; 0; </code></pre><br>Following the declaration is the executable section, which is laid out exactly like that of an<br>anonymous block. The only difference with a function is that it always includes a RETURN statement. It<br>can return a value of any datatype as long as it is the same datatype specified in the RETURN clause of the<br>header.<br>Following the return clause can be an optional EXCEPTION block to handle any errors that were<br>encountered in the function. The following example is the same function that was demonstrated in the<br>solution to this recipe, except that it has an added EXCEPTION block. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION CALC_QUARTER_HOUR(HOURS IN NUMBER) 
 RETURN NUMBER AS  
  CALCULATED_HOURS NUMBER :&#x3D; 0; 
BEGIN 
  
   -- if HOURS is greater than one, then calculate the decimal portion 
 
  -- based upon quarterly hours  
 IF HOURS &gt; 1 THEN 
  -- calculate the modulus of the HOURS variable and compare it to  
 
  -- fractional values 
    IF MOD(HOURS, 1) &lt;&#x3D;.125 THEN 
       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1); 
    ELSIF MOD(HOURS, 1) &gt; .125 AND MOD(HOURS,1) &lt;&#x3D; .375 THEN 
       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.25,1); 
    ELSIF MOD(HOURS, 1) &gt; .375 AND MOD(HOURS,1) &lt;&#x3D; .625 THEN 
       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.50,1); 
    ELSIF MOD(HOURS, 1) &gt; .63 AND MOD(HOURS,1) &lt;&#x3D; .825 THEN 
       CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.75,1); 
    ELSE 
       CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); 
       
    END IF; 
     
  ELSE 
    -- if HOURS is less than one, then calculate the entire value 
 
    -- based upon quarterly hours 
    IF HOURS &gt; 0 AND HOURS &lt;&#x3D;.375 THEN 
        CALCULATED_HOURS :&#x3D; .25; 
    ELSIF HOURS &gt; .375 AND HOURS &lt;&#x3D; .625 THEN 
        CALCULATED_HOURS :&#x3D; .5; 
    ELSIF HOURS &gt; .625 AND HOURS &lt;&#x3D; .825 THEN 
        CALCULATED_HOURS :&#x3D; .75; 
    ELSE 
        CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); 
    END IF; 
     
  END IF; 
   
  RETURN CALCULATED_HOURS; 
 
EXCEPTION 
  WHEN VALUE_ERROR THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;VALUE ERROR RAISED, TRY AGAIN&#39;); 
    RETURN -1; 
  WHEN OTHERS THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;UNK ERROR RAISED, TRY AGAIN&#39;); 
    RETURN -1; 
END CALC_QUARTER_HOUR; </code></pre>
<p>Again, don’t fret if you are unfamiliar with how to handle exceptions, because they will be discussed<br>in detail later in the book. At this point, it is important to know that you have the ability to declare<br>exceptions that can be caught by code so that your program can process abnormalities or errors<br>accordingly.<br>Functions are important not only for encapsulation but also for reuse. As a matter of fact, the<br>function defined within the solution uses other built-in PL&#x2F;SQL functions within them. There are entire<br>libraries that consist of functions that are helpful for performing various transactions. Functions are a<br>fundamental part of PL&#x2F;SQL programming, just as they are in any other language. It is up to you to<br>ensure that your database is stocked with plenty of useful functions that can be used in your current and<br>future applications. </p>
<h2 id="4-2-Executing-a-Stored-Function-from-a-Query"><a href="#4-2-Executing-a-Stored-Function-from-a-Query" class="headerlink" title="4-2. Executing a Stored Function from a Query"></a>4-2. Executing a Stored Function from a Query</h2><p><strong>Problem</strong><br>You want to invoke a function from an SQL query. For example, you want to take the quarter-hour<br>rounding function from Recipe 4-1 and invoke it on hourly values in a database table.<br><strong>Solution</strong><br>Write a query and invoke the function on values returned by the SELECT statement. In the following lines,<br>the function that was written in the previous recipe will be called. The results of calling the function from<br>within a query are as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; select calc_quarter_hour(.17) from dual; 
 
CALC_QUARTER_HOUR(.17) 
---------------------- 
  .25 
 
SQL&gt; select calc_quarter_hour(1.3) from dual; 
 
CALC_QUARTER_HOUR(1.3) 
---------------------- 
 1.25 </code></pre>
<p><strong>How It Works</strong><br>There are a few ways in which a function can be called, one of which is via a query. A function can be<br>executed inline via a SELECT statement, as was the case with the solution to this recipe. A function can<br>also be executed by assigning it to a variable within an anonymous block or another function&#x2F;procedure.<br>Since all functions return a value, this works quite well. For instance, the following QTR_HOUR variable can<br>be assigned the value that is returned from the function: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  qtr_hour          NUMBER; 
BEGIN 
  qtr_hour :&#x3D; calc_quarter_hour(1.3); 
  DBMS_OUTPUT.PUT_LINE(qtr_hour); 
END; 
 
You can also execute a function as part of an expression. In the following statement, you can see 
that TOTAL_HOURS is calculated by adding the bill total to the value returned from the function: 
 
DECLARE 
  total_hours           NUMBER; 
  hours                 NUMBER :&#x3D; 8; 
BEGIN 
  total_hours :&#x3D; hours + calc_quarter_hour(3.2); 
  DBMS_OUTPUT.PUT_LINE(total_hours); 
END; </code></pre>
<p>The way in which your program calls a function depends on its needs. If you need to simply return<br>some results from the database and apply a function to each of the results, then use a query. You may<br>have an application that needs to pass a value to a function and use the result at some later point, in<br>which case assigning the function to a variable would be a good choice for this case. Whatever the case<br>may be, functions provide convenient calling mechanisms to cover most use cases. </p>
<h2 id="4-3-Optimizing-a-Function-That-Will-Always-Return-the-Same-Result-for-a-Given-Input"><a href="#4-3-Optimizing-a-Function-That-Will-Always-Return-the-Same-Result-for-a-Given-Input" class="headerlink" title="4-3. Optimizing a Function That Will Always Return the Same Result for a Given Input"></a>4-3. Optimizing a Function That Will Always Return the Same Result for a Given Input</h2><p><strong>Problem</strong><br>You want to create a function that will return the same result whenever a given input, or set of inputs, is<br>presented to it. You want the database to optimize based upon that deterministic nature.<br><strong>Solution</strong><br>Specify the DETERMINISTIC keyword when creating the function to indicate that the function will always<br>return the same result for a given input. For instance, you want to return a specific manager name based<br>upon a given manager ID. Furthermore, you want to optimize for the fact that any given input will<br>always return the same result. The following example demonstrates a function that does so by specifying<br>the DETERMINISTIC keyword:  </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION manager_name(mgr_id IN NUMBER) 
RETURN VARCHAR2 
DETERMINISTIC IS 
  first_name     employees.first_name%TYPE; 
  last_name      employees.last_name%TYPE; 
BEGIN 
  IF mgr_id IS NOT NULL THEN 
    SELECT first_name, last_name 
    INTO first_name, last_name 
    FROM EMPLOYEES 
    WHERE employee_id &#x3D; mgr_id; 
 
    RETURN first_name || &#39; &#39; || last_name; 
  ELSE 
    RETURN &#39;N&#x2F;A&#39;; 
  END IF; 
EXCEPTION 
  WHEN NO_DATA_FOUND THEN 
    RETURN &#39;N&#x2F;A&#39;; 
END; </code></pre>
<p>This function will return the manager name for a matching EMPLOYEE_ID. If there are no matches for<br>the EMPLOYEE_ID found, then N&#x2F;A will be returned.<br><strong>How It Works</strong><br>A deterministic function is one that always returns the same resulting value as long as the parameters<br>that are passed in are the same. This type of function can be useful for improving performance. The<br>function will be executed only once for any given set of parameters. This means that if the same<br>parameters are passed to this function in subsequent calls, then the function will be bypassed and return<br>the cached value from the last execution using those parameters. This can really help in cases where<br>calculations are being performed and repeated calls to the function may take a toll on performance.<br>The DETERMINISTIC clause is required in a couple of cases. In the event that you are calling a function<br>in an expression of a function-based index, you need to write the function as DETERMINISTIC, or you will<br>receive errors. Similarly, a function must be made DETERMINISTIC if it is being called in an expression of a<br>materialized view query or if the view is marked as ENABLE QUERY REWRITE or REFRESH FAST. </p>
<h2 id="4-4-Creating-a-Stored-Procedure"><a href="#4-4-Creating-a-Stored-Procedure" class="headerlink" title="4-4. Creating a Stored Procedure"></a>4-4. Creating a Stored Procedure</h2><p><strong>Problem</strong></p>
<p>There is a database task that you are performing on a regular basis. Rather than executing a script that<br>contains lines of PL&#x2F;SQL code each time you execute the task, you want to store the code in the database<br>so that you can simply execute the task by name or so that you can schedule it to execute routinely via<br>Oracle Scheduler. </p>
<p>■ Note See Chapter 11 for information on scheduling PL&#x2F;SQL jobs using Oracle Scheduler. </p>
<p><strong>Solution</strong><br>Place the code that is used to perform your task within a stored procedure. The following example<br>creates a procedure named INCREASE_WAGE to update the employee table by giving a designated<br>employee a pay increase. Of course, you will need to execute this procedure for each eligible employee<br>in your department. Storing the code in a procedure makes the task easier to perform. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE INCREASE_WAGE (empno_in IN NUMBER, 
                                           pct_increase IN NUMBER, 
                                           upper_bound IN NUMBER) AS 
  emp_count    NUMBER :&#x3D; 0; 
  emp_sal      employees.salary%TYPE; 
   
  Results   VARCHAR2(50); 
  
BEGIN 
    SELECT salary 
    INTO emp_sal 
    FROM employees 
    WHERE employee_id &#x3D; empno_in; 
     
    IF emp_sal &lt; upper_bound 
    AND round(emp_sal + (emp_sal * pct_increase), 2) &lt; upper_bound THEN 
     
        UPDATE employees 
        SET salary &#x3D; round(salary + (salary * pct_increase),2) 
        WHERE employee_id &#x3D; empno_in; 
         
        results :&#x3D; &#39;SUCCESSFUL INCREASE&#39;; 
    ELSE 
        results :&#x3D; &#39;EMPLOYEE MAKES TOO MUCH, DECREASE RAISE PERCENTAGE&#39;; 
    END IF; 
     
  DBMS_OUTPUT.PUT_LINE(results);
EXCEPTION 
  WHEN NO_DATA_FOUND THEN 
    RAISE_APPLICATION_ERROR(-20001, &#39;No employee match for the given ID&#39;);
END; 
The following are the results from executing the procedure for employee number 198. In the
example, the employee is being given a 3 percent increase and an upper bound of $5,000. 
BEGIN 
  increase_wage(198,.03,5000);
END; </code></pre>
<p>SUCCESSFUL INCREASE<br>Statement processed. </p>
<p><strong>How It Works</strong><br>In the example, the procedure accepts three parameters: the employee number, the percent of increase<br>they will receive, and an upper salary bound. You can then invoke the procedure by name, passing in the<br>required parameters.<br>The procedure first searches the database for the provided employee number. If a record for that<br>employee is found, then the employee record is queried for the current salary. If the salary is less than<br>the upper bound and the resulting new salary will still be less than the upper bound, then the increase<br>will be applied via an UPDATE statement. If the employee is not found, then an alert message will be<br>displayed. As you can see, this procedure can be called for any individual employee, and it will increase<br>their wage accordingly as long as the increase stays within the bound.<br>Stored procedures can be used to encapsulate functionality and store code in the database data<br>dictionary. Much like a function, they can accept zero or more values as parameters, including<br>collections. A stored procedure is structured in much the same way as a function in that it includes a<br>header, an executable section, and an optional exception-handling block. However, a procedure cannot<br>include a RETURN clause in the header, and it does not return a value.<br>For example, in the solution to this recipe, the procedure contains the following header: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE INCREASE_WAGE (empno_in IN NUMBER, 
                                           pct_increase IN NUMBER, 
                                           upper_bound IN NUMBER) AS </code></pre>
<p>The header uses the OR REPLACE clause to indicate that this procedure should replace any procedure<br>with the same name that already exists. The procedure accepts three parameters, and although all of<br>them are NUMBER type, any datatype can be accepted as a parameter. The declaration section comes after<br>the header, and any cursors, variables, or exceptions that need to be declared should be taken care of in<br>that section. Next, the actual work that the procedure will do takes place between the BEGIN and END<br>keywords. Note that the header does not contain a RETURNS clause since procedures cannot return any<br>values.<br>The advantage of using procedures is that code can be encapsulated into a callable named routine<br>in the data dictionary and can be called by many users. To create a procedure in your schema, you must<br>have the CREATE PROCEDURE system privilege. You can create a stored procedure in another schema if you<br>have the CREATE ANY PROCEDURE system privilege. </p>
<h2 id="4-5-Executing-a-Stored-Procedure"><a href="#4-5-Executing-a-Stored-Procedure" class="headerlink" title="4-5. Executing a Stored Procedure"></a>4-5. Executing a Stored Procedure</h2><p><strong>Problem</strong><br>You want to execute a stored procedure from SQL*Plus. </p>
<p><strong>Solution</strong><br>Open SQL*Plus, and connect to the database schema that contains the procedure you are interested in<br>executing. Execute the procedure by issuing the following command: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">EXEC procedure_name([param1, param2,...]); </code></pre>

<p>For instance, to execute the procedure that was created in Recipe 4-3, you would issue the following<br>command:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">EXEC increase_wage(198, .03, 5000); </code></pre>

<p>This would invoke the <code>INCREASE_WAGE</code> procedure, passing three parameters: EMPLOYEE_ID, a<br>percentage of increase, and an upper salary bound.</p>
<p>You can also execute a stored procedure by creating a simple anonymous block that contains the<br>procedure call, as depicted(vt.描述,描画) in the following code:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
  procedure_name([param1, param2,…]); 
END; </code></pre>

<p>Using this technique, invoking the stored procedure that was created in Recipe 4-3 would resemble<br>the following: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
  increase_wage(198,.03,5000); 
END; </code></pre>

<p>Both techniques work equally well, but the latter would be better to use if you wanted to execute<br>more than one procedure or follow up with more PL&#x2F;SQL statements. If you are running a single<br>procedure from SQL*Plus, then using <code>EXEC</code> is certainly a good choice. </p>
<p><strong>How It Works</strong></p>
<p>A stored procedure can be executed using the <code>EXEC</code> keyword. You can also type <code>EXECUTE</code> entirely. Both the<br>long and shortened versions will work.  </p>
<p>It is also possible to execute a procedure that is contained within other schemas, if the current user<br>has execute privileges on that procedure. In such a scenario, use dot notation to qualify the procedure<br>name. Here’s an example: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">EXEC different_schema.increase_wage(emp_rec.employee_id, pct_increase, upper_bound); </code></pre>

<p>■ Note To learn more about privileges regarding stored programs, please take a look at Recipe 4-11.<br>A procedure can also be invoked from within another procedure by simply typing the name and<br>placing the parameters inside parentheses, if there are any. For instance, the following lines of code<br>demonstrate calling a procedure from within another procedure. The procedure in this example invokes<br>the procedure that was shown in Recipe 4-3. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE grant_raises (pct_increase IN NUMBER, 
                                          upper_bound IN NUMBER) as 
  CURSOR emp_cur is 
  SELECT employee_id, first_name, last_name 
  FROM employees; 
BEGIN 
  -- loop through each record in the employees table 
  FOR emp_rec IN emp_cur LOOP
      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name);
      -- inside A invoke B procedure
      increase_wage(emp_rec.employee_id, pct_increase, upper_bound); 
  END LOOP; 
END;  </code></pre>

<p>The procedure <code>GRANT_RAISES</code> applies an increase across the board to all employees. It loops through<br>all employee records, and the <code>INCREASE_WAGE</code> procedure is called with each iteration. The procedure is<br>called without the use of the <code>EXEC</code> keyword since it is being invoked by another procedure rather than<br>directly from the SQL*Plus command line.</p>
<p><strong>summary</strong></p>
<ol>
<li>execute procedure by EXEC statement directly</li>
<li>using anonymous code block within procedure name</li>
<li>inside A procedure invoke B procedure</li>
</ol>
<h2 id="4-6-Creating-Functions-Within-a-Procedure-or-Code-Block"><a href="#4-6-Creating-Functions-Within-a-Procedure-or-Code-Block" class="headerlink" title="4-6. Creating Functions Within a Procedure or Code Block"></a>4-6. Creating Functions Within a Procedure or Code Block</h2><p><strong>Problem</strong></p>
<p>You want to create some functions within a stored procedure. You want the functions to be local to the<br>procedure, available only from the procedure’s code block.</p>
<p><strong>Solution</strong><br>Create a stored procedure, and then create functions within the declaration section. The internal<br>functions will accept parameters and return values just as an ordinary(adj.普通的,平凡) stored function would, except that the scope of the functions will be constrained to the outer code block or to the procedure. The procedure<br>that is demonstrated in this solution embodies two functions. One of the functions is used to calculate<br>the federal tax for an employee paycheck, while the other calculates the state tax. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE calc_employee_paycheck(emp_id IN NUMBER) as 
  emp_rec          employees%ROWTYPE; 
  paycheck_total   NUMBER; 
 
-- function for state tax 
  FUNCTION calc_state (sal IN NUMBER)  
    RETURN NUMBER IS 
  BEGIN 
    RETURN sal *  .08; 
  END; 

-- function for federal tax 
 FUNCTION calc_federal (sal IN NUMBER)  
    RETURN NUMBER IS 
  BEGIN 
    RETURN sal *  .12; 
  END; 
 
BEGIN 
  DBMS_OUTPUT.PUT_LINE(&#39;Calculating paycheck with taxes&#39;); 
  SELECT * 
  INTO emp_rec 
  FROM employees 
  WHERE employee_id &#x3D; emp_id; 
 
  paycheck_total :&#x3D; emp_rec.salary - calc_state(emp_rec.salary) - 
                    calc_federal(emp_rec.salary); 
 
 DBMS_OUTPUT.PUT_LINE(&#39;The paycheck total for &#39; || emp_rec.last_name || 
    &#39; is &#39; || paycheck_total); 
CHAPTER 4  FUNCTIONS, PACKAGES, AND PROCEDURES 
74 
EXCEPTION 
  WHEN NO_DATA_FOUND THEN 
    RAISE_APPLICATION_ERROR(-20001, 
    &#39;No matching employee for the given ID&#39;); 
END;</code></pre>

<p><strong>How It Works</strong></p>
<p>Functions and procedures too can be contained within other bodies of code. Creating a function<br>within a declaration section will make the function accessible to the block that contains it. The<br>declaration of the function is the same as when you are creating a stored function, with the exception of<br>the <code>CREATE OR REPLACE</code> keywords. Any variables that are declared inside the function will be accessible<br>only to that function, not to the containing object.<br>Creating a function or procedure inside a PL&#x2F;SQL code block can be useful when you want to make<br>a function that is only to be used by the containing object. However, if you find that the body of the<br>embedded function may change frequently, then coding a separate stored function may prove to be<br>more efficient.</p>
<h2 id="4-7-Passing-Parameters-by-Name"><a href="#4-7-Passing-Parameters-by-Name" class="headerlink" title="4-7. Passing Parameters by Name"></a>4-7. Passing Parameters by Name</h2><p><strong>Problem</strong></p>
<p>You have a procedure in your database that accepts a large number of parameters. When calling the<br>procedure, you would rather not worry that the positioning of the parameters is correct. </p>
<p><strong>Solution</strong></p>
<p>Rather than trying to pass all the parameters to the procedure in the correct order, you can pass them by<br>name. The code in this solution calls a procedure that accepts six parameters, and it passes the<br>parameters by name rather than in order.<br>Procedure Declaration: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">PROCEDURE process_emp_paycheck(EMP_ID IN NUMBER, 
   PAY_CODE IN NUMBER, 
   SICK_USED IN NUMBER, 
   VACATION_USED IN NUMBER, 
   FEDERAL_TAX IN NUMBER, 
   STATE_TAX IN NUMBER); 
Procedure Execution: 
EXEC process_emp_paycheck(EMP_ID&#x3D;&gt;10, 
   PAY_CODE&#x3D;&gt;10, 
   VACATION_USED&#x3D;&gt;8.0, 
   SICK_USED&#x3D;&gt;8.0, 
   STATE_TAX&#x3D;&gt;.06, 
   FEDERAL_TAX&#x3D;&gt;.08); </code></pre>
<p>As you can see, by passing the parameters by name, they do not need to follow the same positional<br>ordering as they do within the declaration of the procedure.</p>
<p><strong>How It Works</strong><br>To pass a parameter by name, you list the parameter name followed by an arrow (consisting of an equal<br>sign and a greater-than symbol) pointing to the value you are passing. The following pseudocode depicts<br>this technique:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">procedure_name(parameter&#x3D;&gt;value); </code></pre>

<p>Although it can be more verbose to use named parameters, passing parameters by name can be very<br>handy when there are several parameters to pass because you do not need to worry about passing them<br>in the correct order. It is also helpful because it increases readability.<br>Both procedures and functions can accept positional and named parameters. Neither notation is<br>superior to the other, so which one you choose to use is completely dependant upon the procedure or<br>function that is currently being called. However, named parameters are a safe choice if trying to<br>maintain consistency with procedure calls throughout your application or your organization.<br>Although not recommended, you can use both positional and named notation when passing<br>parameters within the same call. When doing so, you need to place the parameters that you want to pass<br>using positional notation first, followed by the parameters that you want to pass using named notation.<br>The following execution illustrates using both positional and named notation while passing parameters<br>to the PROCESS_EMP_PAYCHECK procedure: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">EXEC process_emp_paycheck(198, 10, 0, 
   SICK_USED&#x3D;&gt;4.0, 
   STATE_TAX&#x3D;&gt;.05, 
   FEDERAL_TAX&#x3D;&gt; .04); </code></pre>

<p>This particular call passed both of the first parameters by position, those being EMP_ID and PAY_CODE.<br>The last three parameters are passed by named notation. </p>
<p>summary :  </p>
<ol>
<li>if you specify parameter name , then would ignore order of you define parameter</li>
</ol>
<h2 id="4-8-Setting-Default-Parameter-Values"><a href="#4-8-Setting-Default-Parameter-Values" class="headerlink" title="4-8. Setting Default Parameter Values"></a>4-8. Setting Default Parameter Values</h2><p><strong>Problem</strong><br>You want to create a procedure that accepts several parameters. However, some of those parameters<br>should be made optional and contain default values.  </p>
<p><strong>Solution</strong><br>You can allow the procedure caller to omit the parameters if default values are declared for the variables<br>within the procedure. The following example shows a procedure declaration that contains default<br>values: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">PROCEDURE process_emp_paycheck(EMP_ID IN NUMBER, 
   PAY_CODE IN NUMBER, 
   SICK_USED IN NUMBER, 
   VACATION_USED IN NUMBER, 
   FEDERAL_TAX IN NUMBER DEFAULT .08,  -- could ignore value
   STATE_TAX IN NUMBER DEFAULT .035);  -- could ignore value</code></pre>

<p>And here is an example execution: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">EXEC process_emp_paycheck(EMP_ID&#x3D;&gt;10, 
                           PAY_CODE&#x3D;&gt;10, 
                           VACATION_USED&#x3D;&gt;8.0, 
                           SICK_USED&#x3D;&gt;8.0); </code></pre>

<p>Since the procedure contains default values, the parameters can be omitted when the procedure is<br>called. </p>
<p><strong>How It Works</strong><br>The ability to provide a default value for a variable declaration is optional. To do so, you must provide<br>the declaration of the variable with the keyword DEFAULT followed by the value, as shown in the solution<br>to this recipe. If a default value is declared, then you needn’t specify a value for the parameter when the<br>function or procedure is called. If you do specify a value for a parameter that has a default value, the<br>specified value overrides the default.</p>
<h2 id="4-9-Collecting-Related-Routines-into-a-Single-Unit"><a href="#4-9-Collecting-Related-Routines-into-a-Single-Unit" class="headerlink" title="4-9. Collecting Related Routines into a Single Unit"></a>4-9. Collecting Related Routines into a Single Unit</h2><p><strong>Problem</strong><br>You have a number of procedures and functions that formulate(vt.规划;用公式表示) an entire application when used<br>together. Rather than defining each subprogram individually, you prefer to combine all of them into a<br>single, logically related entity.  </p>
<p><strong>Solution</strong><br>Create a PL&#x2F;SQL package that in turn declares(vt.宣布,声明) and defines each of the procedures together as an<br>organized entity. You declare each of the subprograms in the package specification (otherwise known as<br>a header) and define them in the package body.<br>The following example shows the creation of a PL&#x2F;SQL package containing two procedures and a<br>variable.</p>
<p>First, you create the package specification: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PACKAGE process_employee_time IS  
  total_employee_salary  NUMBER; -- global variable inside 
  PROCEDURE grant_raises(pct_increase IN NUMBER, 
                                              upper_bound IN NUMBER); 
  PROCEDURE increase_wage (empno_in IN NUMBER, 
                           pct_increase IN NUMBER, 
                           upper_bound IN NUMBER) ; 
END; </code></pre>
<p>The specification lists the procedures, functions, and variables that you want to be visible from<br>outside the package. Think of the specification as the external interface to your package.<br>Next, create the package body: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PACKAGE BODY process_employee_time IS 

  PROCEDURE grant_raises (pct_increase IN NUMBER, 
                          upper_bound IN NUMBER) as 
  CURSOR emp_cur is 
  SELECT employee_id, first_name, last_name 
  FROM employees; 
BEGIN
  -- loop through each record in the employees table 
  FOR emp_rec IN emp_cur LOOP 
      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name); 
      increase_wage(emp_rec.employee_id, pct_increase, upper_bound); 
  END LOOP; 
END;  

 PROCEDURE INCREASE_WAGE (empno_in IN NUMBER, 
                          pct_increase IN NUMBER, 
                          upper_bound IN NUMBER) AS 
  emp_count    NUMBER :&#x3D; 0; 
  emp_sal      employees.salary%TYPE; 
   
  Results   VARCHAR2(50); 
   
BEGIN 
 
  SELECT count(*) 
  INTO emp_count 
  FROM employees 
  WHERE employee_id &#x3D; empno_in; 
  
  IF emp_count &gt; 0 THEN 
    -- IF EMPLOYEE FOUND, THEN OBTAIN RECORD 
    SELECT salary 
    INTO emp_sal 
    FROM employees 
    WHERE employee_id &#x3D; empno_in; 
     
    IF emp_sal &lt; upper_bound AND round(emp_sal + (emp_sal * pct_increase), 2) &lt; 
 upper_bound THEN 
     
        UPDATE employees 
        SET salary &#x3D; round(salary + (salary * pct_increase),2) 
        WHERE employee_id &#x3D; empno_in; 
         
        results :&#x3D; &#39;SUCCESSFUL INCREASE&#39;; 
    ELSE 
        results :&#x3D; &#39;EMPLOYEE MAKES TOO MUCH, DECREASE RAISE PERCENTAGE&#39;; 
    END IF; 
     
  ELSE 
    Results :&#x3D; &#39;NO EMPLOYEE FOUND&#39;; 
  END IF; 
 
  DBMS_OUTPUT.PUT_LINE(results); 
 
  END; 
END; </code></pre>

<p>The package in this example declares a global variable and two procedures within the package<br>specification. The package body then defines both of the procedures and assigns a value to the variable<br>that was declared in the specification. Procedures defined within the package body are defined in the<br>same manner as they would be if they were stand-alone procedures. The difference is that now these two<br>procedures are contained in a single package entity and are therefore related to each other and can<br>share variables declared globally within the package. </p>
<p><strong>How It Works</strong><br>A PL&#x2F;SQL package can be useful for organizing code into a single construct. Usually the code consists of<br>a grouping of variables, types, cursors, functions, and procedures that perform actions that are logically<br>related to one another. Packages consist of a specification and a body, both of which are stored<br>separately in the data dictionary. The specification contains the declarations for each of the variables,<br>types, subprograms, and so on, that are defined in the package. The body contains the implementations<br>for each of the subprograms and cursors that are included in the specification, and it can also include<br>implementations for other functions and procedures that are not in the specification. You’ll learn more<br>about this in other recipes.</p>
<p>Most packages contain both a specification and a body, and in these cases the specification acts as<br>the interface to the constructs implemented within the body. The items that are included in the<br>specification are available to the public and can be used outside the package. Not all packages contain a<br>body. If there are only declarations of variables or constants in the package, then there is no need for a<br>body to implement anything. Other PL&#x2F;SQL objects outside the package can reference any variables that<br>are declared in the specification. In other words, declaring a variable within a PL&#x2F;SQL package<br>specification essentially creates a global variable.</p>
<p>■ Note Global variables should be used wisely(adv.明智地;聪明地). The use of global variables can complicate matters when tracking<br>down problems or debugging your code. If global variables are used, then it can be hard to determine where<br>values have been set and where initialization of such variables occurs. Following the rules of encapsulation and<br>using local variables where possible can make your life easier.<br>Procedures and functions defined within the package body may call each other, and they can be<br>defined in any order as long as they have been declared within the package specification. If any of the<br>procedures or functions have not been declared in the specification, then they must be defined in the<br>package body prior to being called by any of the other procedures or functions.</p>
<p>You can change any implementations within a package body without recompiling the specification.<br>This becomes very important when you have other objects in the database that depend on a particular<br>package because it is probably not a good idea to change a package specification during normal business<br>hours when a package is in use by others. Doing so may result in unusable objects, and the package<br>users could begin to see errors. However, if changes need to be made to the code within the package<br>body, then you can change that code without affecting public-facing constructs of a package.<br>Packages are one of the most important constructs that you can create in PL&#x2F;SQL. You will use<br>packages to combine common code objects for almost any significant application that you write. It is<br>possible to create entire applications without the use of a package, but doing so can create a<br>maintenance nightmare because you will begin to see a pool of procedures and functions being created<br>within your database, and it will be difficult to remember which constructs are used for different tasks.<br>Packages are especially handy when writing PL&#x2F;SQL web applications, and you will learn all about doing<br>summary:  </p>
<ol>
<li>package differenates individual prodcdure is that pacakge could define global variable and shared each other</li>
<li>could including function not within specification</li>
<li>there are declarations of variables or constants, so no need to struct package body</li>
</ol>
<h2 id="4-10-Writing-Initialization-Code-for-a-Package"><a href="#4-10-Writing-Initialization-Code-for-a-Package" class="headerlink" title="4-10. Writing Initialization Code for a Package"></a>4-10. Writing Initialization Code for a Package</h2><p><strong>Problem</strong><br>You want to execute some code each time a particular PL&#x2F;SQL package is instantiated in a session. </p>
<p><strong>Solution</strong><br>Create an initialization block for the package in question. By doing so, you will have the ability to execute<br>code each time the package is initialized. The following example shows the same package that was<br>constructed in Recipe 4-7. However, this time the package contains an initialization block. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PACKAGE BODY process_employee_time IS 
 
  PROCEDURE grant_raises (pct_increase IN NUMBER, 
                          upper_bound IN NUMBER) as 
  CURSOR emp_cur is 
  SELECT employee_id, first_name, last_name 
  FROM employees; 
  BEGIN 
  -- loop through each record in the employees table 
   FOR emp_rec IN emp_cur LOOP 
      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name); 
      increase_wage(emp_rec.employee_id, pct_increase, upper_bound); 
   END LOOP; 
  END grant_raises;  
 
 
  PROCEDURE increase_wage (empno_in IN NUMBER, 
                          pct_increase IN NUMBER, 
                          upper_bound IN NUMBER) AS 
  emp_count    NUMBER :&#x3D; 0; 
  emp_sal      employees.salary%TYPE; 
   
  Results   VARCHAR2(50); 
   
  BEGIN 
 
  SELECT count(*) 
  INTO emp_count 
  FROM employees 
  WHERE employee_id &#x3D; empno_in; 
  
  IF emp_count &gt; 0 THEN 
    -- IF EMPLOYEE FOUND, THEN OBTAIN RECORD 
    SELECT salary 
    INTO emp_sal 
    FROM employees 
    WHERE employee_id &#x3D; empno_in; 
     
    IF emp_sal &lt; upper_bound AND round(emp_sal + (emp_sal * pct_increase), 2) &lt; 
 upper_bound THEN 
     
        UPDATE employees 
        SET salary &#x3D; round(salary + (salary * pct_increase),2) 
        WHERE employee_id &#x3D; empno_in; 
         
        results :&#x3D; &#39;SUCCESSFUL INCREASE&#39;; 
    ELSE 
        results :&#x3D; &#39;EMPLOYEE MAKES TOO MUCH, DECREASE RAISE PERCENTAGE&#39;; 
    END IF; 
     
  ELSE 
    Results :&#x3D; &#39;NO EMPLOYEE FOUND&#39;; 
  END IF; 
  DBMS_OUTPUT.PUT_LINE(results); 
  END increase_wage; 

BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;EXECUTING THE INITIALIZATION BLOCK&#39;);
END;</code></pre>
<p>The initialization block in this example is the last code block within the package body. In this case,<br>that block lies in the final three lines. </p>
<p><strong>How It Works</strong></p>
<p>The initialization block for the package in the solution displays a line of text to indicate that the<br>initialization block has been executed. The initialization block will execute once per session, the first<br>time the package is used in that session. If you were to create this package in your session and invoke<br>one of its members, you would see the message print. Although an initialization message is not very<br>useful, there are several good reasons to use an initialization block. One such reason is to perform a<br>query to obtain some data for the session. </p>
<p>summary:  </p>
<ol>
<li>more like java construct function and golang init() function</li>
<li>code struct for initialization<pre class="language-sql" data-language="sql"><code class="language-sql">create or replace package XXXX () is
BEGIN
    DBMS_OUTPUT.PUT_LINE(&#39;EXECUTING THE INITIALIZATION BLOCK&#39;);
END;</code></pre></li>
</ol>
<h2 id="4-11-Granting-the-Ability-to-Create-and-Execute-Stored-Programs"><a href="#4-11-Granting-the-Ability-to-Create-and-Execute-Stored-Programs" class="headerlink" title="4-11. Granting the Ability to Create and Execute Stored Programs"></a>4-11. Granting the Ability to Create and Execute Stored Programs</h2><p><strong>Problem</strong><br>You want to grant someone the ability to create and execute stored programs. </p>
<p><strong>Solution</strong><br>To grant the ability for a user to create a procedure, function, or package, you must log in to the database<br>with a privileged account and grant the CREATE PROCEDURE privilege to the user. Here’s an example: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">GRANT CREATE PROCEDURE TO user; </code></pre>

<p>Similarly, to grant permissions for execution of a procedure, package, or function, you must log in<br>with a privileged account and grant the user EXECUTE permissions on a particular procedure, function, or<br>package. Here’s an example: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">GRANT EXECUTE ON schema_name.program_name TO schema;</code></pre>

<p><strong>How It Works</strong></p>
<p>Before a user can create stored code, the user must be given permission to do so. The solution shows the<br>straightforward approach. The database administrator logs in and grants <code>CREATE PROCEDURE</code> to the<br>schema owner. The schema owner can then log in and create stored code in their schema.<br>A schema owner can always execute stored code in the schema. However, application users do not<br>generally log in as schema owners because of the security risks inherent in doing so. Thus, you will<br>commonly be faced with the need to grant other users execute access on stored code. You do that by<br>granting <code>EXECUTE</code> privileges, as shown in the second solution example.  </p>
<p>summary :  </p>
<ol>
<li>let A account access B schema objects by execute <code>GRANT EXECUTE ON schema_name.program_name TO schema;</code></li>
</ol>
<h2 id="4-12-Executing-Packaged-Procedures-and-Functions"><a href="#4-12-Executing-Packaged-Procedures-and-Functions" class="headerlink" title="4-12. Executing Packaged Procedures and Functions"></a>4-12. Executing Packaged Procedures and Functions</h2><p><strong>Problem</strong><br>You want to execute one of the procedures or functions contained within a package. </p>
<p><strong>Solution</strong><br>Use the package_name.object_name notation to execute a particular code object within a package. For<br>instance, the following block of code executes the GRANT_RAISES procedure that is contained within the<br>PROCESS_EMPLOYEE_TIME package. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
    process_employee_time.grant_raises(.03,4000); 
END; </code></pre>

<p>The previous code block executes the <code>GRANT_RAISES</code> function, passing <code>.03</code> for the percentage of<br>increase and 4000 for the upper bound. </p>
<p>*<strong>How It Works</strong><br>Dot notation is used for accessing members of a package. Similar to other languages such as Java, dot<br>notation can be used to access any publically accessible member of the package. Any variable, function,<br>or procedure that is contained in the package specification can be accessed using the dot notation.<br>Therefore, if your package contained a constant variable within its specification that you wanted to<br>access, it would be possible to do so from outside the package.<br>For a schema to access and execute package members, it must have the appropriate permissions. To<br>grant EXECUTE permission on a package that you own, use the following syntax: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">GRANT EXECUTE ON package_name TO user_name; </code></pre>

<p>Dot notation works from within other procedures or functions. It can also be used from the<br>SQL*Plus command line using the EXEC command.<br>■ Note In most cases, if a package is being used by another schema, then it is a good idea to create a public<br>synonym for that package within the database. This will help decrease issues while attempting to reference the<br>package and its programs from the different schema because you will not need to specify the schema name in<br>order to qualify the call. Please see Recipe 4-13 for more information regarding public synonyms.<br>summary:  </p>
<ol>
<li>a good way is to create synonyms</li>
</ol>
<h2 id="4-13-Creating-a-Public-Name-for-a-Stored-Program"><a href="#4-13-Creating-a-Public-Name-for-a-Stored-Program" class="headerlink" title="4-13. Creating a Public Name for a Stored Program"></a>4-13. Creating a Public Name for a Stored Program</h2><p><strong>Problem</strong><br>You want to allow for any schema to have the ability to reference a particular stored program that is<br>contained(adj.泰然自若的;从容的;被控制的) within your schema. For instance, the CALC_EMPLOYEE_PAYCHECK procedure should be<br>executable for any of the administrative users of the database. You want these users to have the ability to<br>simply call the procedure rather than preceding the procedure name with the schema using the dot<br>notation. </p>
<p><strong>Solution</strong><br>Create a public synonym for the function, procedure, or package. This will allow any user that has<br>EXECUTE privileges on the stored program to call it without specifying the schema name first. Instead, the<br>invoker need only reference the synonym.<br>In the following example, the user AdminUser does not have direct access to the<br>CALC_EMPLOYEE_PAYCHECK procedure, so they must fully qualify the name of the package using the schema<br>name for which the procedure resides. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; exec application_account.calc_employee_paycheck(200); 
Calculating paycheck with taxes 
The paycheck total for Whalen is 5200.8 
 
PL&#x2F;SQL procedure successfully completed. </code></pre>

<p>Next, the database administrator will create a public synonym for the procedure:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; CREATE PUBLIC SYNONYM calc_employee_paycheck 
           FOR application_user.calc_employee_paycheck; </code></pre>

<p>Now any user with execute privileges on the procedure can invoke it without fully qualifying the<br>name since a public synonym named CALC_EMPLOYEE_PAYCHECK has been created. This is demonstrated in<br>the next lines of code. Again, the user AdminUser is now logged into the system and executes the<br>procedure. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; exec calc_employee_paycheck(206); 
Calculating paycheck with taxes 
The paycheck total for Gietz is 6640.8 
 
PL&#x2F;SQL procedure successfully completed. </code></pre>

<p>As you can see, the procedure name no longer requires the schema name to fully qualify it before<br>being invoked. </p>
<p><strong>How It Works</strong><br>Creating public synonyms is a useful technique for allowing any user to have access to a stored piece of<br>code without knowing which schema the code belongs to. Any user who has EXECUTE privileges on the<br>code can invoke it without fully qualifying the name. Instead, the invoker specifies the synonym name.<br>An account must be granted the CREATE PUBLIC SYNONYM privilege in order to create a public<br>synonym. It’s actually common for database administrators to take care of creating such synonyms.<br>To create a synonym, execute the following statement, replacing the PUB_SYNONYM_NAME identifier<br>with the name of your choice and replacing SCHEMA.STORED_PROGRAM with the schema name and program<br>that you want to make publically accessible: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE PUBLIC SYNONYM pub_synonym_name FOR schema.stored_program; </code></pre>

<p>The public synonym name does not have to be the same as the actual stored program name, but it is<br>conventional to keep them the same, and it makes things consistent and the names easier to remember.<br>If you begin to have synonym names that differ from the actual program names, then confusion will<br>eventually set in.</p>
<p>■ Note Creating a synonym does not give execute access. Creating a public synonym provides only a global name<br>that avoids the need for dot notation. Invokers of a procedure or function still must be granted EXECUTE access, as<br>shown in Recipe 4-11. </p>
<p>summary:  </p>
<ol>
<li>grant read&#x2F;write user access right to execute procedure without schema name</li>
<li>if you want to setup w&#x2F;r account for schema account.<ol>
<li>create public synonym name for application account</li>
<li>grant execute&#x2F;select&#x2F;update … on package_name on write_user&#x2F;read_user</li>
</ol>
</li>
</ol>
<h2 id="4-14-Executing-Package-Programs-in-Sequence"><a href="#4-14-Executing-Package-Programs-in-Sequence" class="headerlink" title="4-14. Executing Package Programs in Sequence"></a>4-14. Executing Package Programs in Sequence</h2><p><strong>Problem</strong><br>You have created a package that contains all the necessary procedures and functions for your program.<br>Although you can invoke each of these subprograms individually using the<br><code>package_name.subprogram_name</code> notation, it would be beneficial to execute all of them at the same time<br>by issuing a single statement. </p>
<p><strong>Solution</strong><br>Create a driver procedure within your PL&#x2F;SQL package that will be used to initiate all the subprograms in turn, and run your entire program. In the following example, a procedure named driver is created inside<br>a package, and it will invoke all the other package subprograms in turn:<br>First, create the specification: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PACKAGE synchronize_data IS 
  PROCEDURE driver; 
END; </code></pre>
<p>Then, create the body: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PACKAGE BODY synchronize_data IS 
  PROCEDURE query_remote_data IS 
    BEGIN 
      --statements go here 
      DBMS_OUTPUT.PUT_LINE(&#39;QUERYING REMOTE DATA&#39;); 
    END query_remote_data;  
 
  PROCEDURE obtain_new_record_list IS 
    BEGIN 
      --statements go here 
      DBMS_OUTPUT.PUT_LINE(&#39;NEW RECORD LIST&#39;); 
    END obtain_new_record_list;  
 
  PROCEDURE obtain_updated_record_list IS 
    BEGIN 
      --statements go here 
      DBMS_OUTPUT.PUT_LINE(&#39;UPDATED RECORD LIST&#39;); 
    END obtain_updated_record_list;  
 
  PROCEDURE sync_local_data IS 
    BEGIN 
      --statements go here 
      DBMS_OUTPUT.PUT_LINE(&#39;SYNC LOCAL DATA&#39;); 
    END sync_local_data;  
   
  PROCEDURE driver IS 
  BEGIN 
    query_remote_data; 
    obtain_new_record_list; 
    obtain_updated_record_list; 
    sync_local_data; 
  END driver; 
END synchronize_data; </code></pre>

<p>The driver procedure initiates all the other procedures in the order that they should be executed. To<br>initiate the packaged program, you now make a call to the driver procedure as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
   synchronize_data.driver; 
END;</code></pre>
<p>One statement invokes the driver procedure. That procedure in turn invokes the other procedures<br>in the proper sequence.  </p>
<p><strong>How It Works</strong><br>By creating a single procedure that can be called in order to execute all the other subprograms in turn,<br>you eliminate the potential for calling subprograms in the incorrect order. This will also allow you the<br>convenience of making one call as opposed to numerous calls each time you want to execute the task(s)<br>involved. And, if you create the other subprograms as private procedures and functions, then you<br>eliminate the risk of a developer invoking them out of order. That’s because you only make the driver<br>procedure public, and you know that the driver invokes in the correct sequence.<br>Oftentimes, packages are used to hold all the database constructs that make up an entire process. In<br>the solution to this recipe, the package entails(vt.使需要.必需) a database synchronization process, and each procedure<br>within performs a separate piece of the synchronization. When executed in the correct order, the<br>procedures together perform the complete synchronization task.<br>One could just as easily create a script or manually invoke each package program separately just as<br>the driver procedure does in this case. However, you open the door to error when you write the logic of<br>invoking the sequence of procedures from multiple places. Another important factor is that the driver<br>can also be used to perform any additional initialization that must be done prior to executing each<br>procedure. Similarly, additional processing can be done in between each procedure call, such as<br>printing out the current status of the program. The driver procedure essentially provides another layer<br>of abstraction that you can take advantage of. The package can be initialized using the default package<br>initialization; then additional initialization or statements can be provided within the driver procedure,<br>and the program caller doesn’t need to know about them.<br>summary: </p>
<ol>
<li>Another important factor is that the driver can also be used to perform any additional initialization that must be done prior to executing each procedure</li>
<li>you can take advantage of. The package can be initialized using the default package initialization</li>
</ol>
<h2 id="4-15-Implementing-a-Failure-Flag"><a href="#4-15-Implementing-a-Failure-Flag" class="headerlink" title="4-15. Implementing a Failure Flag"></a>4-15. Implementing a Failure Flag</h2><p><strong>Problem</strong><br>You want to create a boolean variable to determine whether one of the subprograms in the package has<br>generated an error. If an error has been generated by one of the subprograms, then the variable will be<br>set to TRUE. This flag will be evaluated in the driver procedure to determine whether the updates<br>performed by the package should be committed or rolled back. </p>
<p><strong>Solution</strong><br>Declare a global variable at the package level, and it will be accessible to all objects within. You can do<br>this by declaring the variable within the package body. The following package illustrates such a variable,<br>where the variable has been declared within the package body so that it is available for all objects in the<br>package only. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PACKAGE synchronize_data 
PROCEDURE driver; 
END; 
 
CREATE OR REPLACE PACKAGE BODY synchronize_data IS 
  error_flag BOOLEAN :&#x3D; FALSE; 
 
  PROCEDURE query_remote_data is 
     Cursor remote_db_query is 
     SELECT * 
     FROM my_remote_data@remote_db; 
    
     remote_db_rec employees%ROWTYPE; 
 
  BEGIN 
    OPEN remote_db_query; 
    LOOP 
      FETCH remote_db_query INTO remote_db_rec; 
      EXIT WHEN remote_db_query%NOTFOUND; 
    IF remote_db_query%NOTFOUND THEN 
      error_flag :&#x3D; TRUE; 
    ELSE 
      -- PERFORM PROCESSING 
      DBMS_OUTPUT.PUT_LINE(&#39;QUERY REMOTE DATA&#39;); 
    END IF; 
    END LOOP; 
    CLOSE remote_db_query; 
  END query_remote_data; 
 
  PROCEDURE obtain_new_record_list IS 
    BEGIN 
      --statements go here 
      DBMS_OUTPUT.PUT_LINE(&#39;NEW RECORD LIST&#39;); 
    END obtain_new_record_list;  
 
  PROCEDURE obtain_updated_record_list IS 
    BEGIN 
      --statements go here 
      DBMS_OUTPUT.PUT_LINE(&#39;UPDATED RECORD LIST&#39;); 
    END obtain_updated_record_list;  
 
  PROCEDURE sync_local_data IS 
    BEGIN 
      --statements go here 
      DBMS_OUTPUT.PUT_LINE(&#39;SYNC LOCAL DATA&#39;); 
    END sync_local_data;  
 
 
  PROCEDURE driver IS 
  BEGIN 
    query_remote_data; 
    IF error_flag &#x3D; TRUE THEN 
      GOTO error_check; 
    END IF; 
     
    obtain_new_record_list; 
    IF error_flag &#x3D; TRUE THEN 
      GOTO error_check; 
    END IF; 
 
    obtain_updated_record_list; 
    IF error_flag &#x3D; TRUE THEN 
      GOTO error_check; 
    END IF; 
 
    sync_local_data; 
 
    -- If any errors were found then roll back all updates 
    &lt;&lt;error_check&gt;&gt; 
    DBMS_OUTPUT.PUT_LINE(&#39;Checking transaction status&#39;); 
    IF error_flag &#x3D; TRUE THEN 
      ROLLBACK; 
      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been rolled back.&#39;); 
   ELSE 
      COMMIT; 
      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been processed.&#39;); 
    END IF; 
 
  END driver; 
END;</code></pre>
<p><strong>How It Works</strong><br>Declaring variables in the package body outside any procedures or functions allows them to become<br>accessible to all subprograms within the package. If one or more of the subprograms changes such a<br>variable’s value, then the changed value will be seen throughout the entire package.<br>As depicted in the example, you can see that the variable is referenced several times throughout the<br>package. If you had a requirement to make a variable global to all PL&#x2F;SQL objects outside the package as<br>well, then you can declare the variable within the package specification. As mentioned in Recipe 4-8,<br>anything declared in the package specification is publically available to any PL&#x2F;SQL object outside as<br>well as within the package body. </p>
<h2 id="4-16-Forcing-Data-Access-to-Go-Through-Packages"><a href="#4-16-Forcing-Data-Access-to-Go-Through-Packages" class="headerlink" title="4-16. Forcing Data Access to Go Through Packages"></a>4-16. Forcing Data Access to Go Through Packages</h2><p><strong>Problem</strong><br>You have defined all subprograms and packages for a particular application, and you want to allow other<br>users to access these constructs and execute the program but not have access to any data tables directly. </p>
<p><strong>Solution</strong><br>Define all the packages, procedures, and functions for your program within a single schema that has<br>access to all the data. All user access should be made from separate schemas, and they should be granted<br>execute privileges on the PL&#x2F;SQL objects but not access to the tables themselves.<br>For instance, if you want to control access to a package named PROCESS_EMPLOYEE_TIME, that package<br>along with all required tables, types, and sequences should be loaded into an application schema that<br>has the appropriate permissions required to access the data. For the purposes of this recipe, the<br>application schema name is EMP.<br>Next, create a role by which to manage the privileges needed to invoke the package’s procedures<br>and functions. Grant EXECUTE privileges to that role. Grant that role to application users.<br>Your application users will now be able to execute the procedures and functions within the package.<br>Those procedures and functions can in turn update the database tables in the package’s schema.<br>However, users will not have direct access to those tables. All updates must flow through the package. </p>
<p><strong>How It Works</strong><br>To control an application’s data, it is important to restrict access to the tables. The solution in this recipe<br>shows how to create a package in the same schema that contains the application tables. The package<br>thus has access to those tables. Users, however, do not have table-level access.<br>After creating the package, you can grant EXECUTE access on the package to application users. Users<br>can then invoke packaged procedures and functions, and those procedures and functions in turn can<br>modify the data in the tables. However, users have no direct access to the tables.<br>By forcing users to go through packaged procedures and functions, you limit users to using a<br>defined interface that remains under your control. You now have some amount of freedom to modify the<br>underlying tables. So long as you do not change the package interface, you can make changes to the<br>underlying tables without disrupting the application. </p>
<p>summary:  </p>
<ol>
<li>big, deep, comprehensive,topic to disuss</li>
<li>allow you must through package to access tables</li>
</ol>
<h2 id="4-17-Executing-Stored-Code-Under-Your-Own-Privilege-Set"><a href="#4-17-Executing-Stored-Code-Under-Your-Own-Privilege-Set" class="headerlink" title="4-17. Executing Stored Code Under Your Own Privilege Set"></a>4-17. Executing Stored Code Under Your Own Privilege Set</h2><p><strong>Problem</strong><br>You have loaded all of an application’s objects into a single application schema. However, you do not<br>want packages, procedures, and functions to execute as the schema owner. Instead, you want stored<br>code to execute with the privileges and access of the user who is invoking that code.<br><strong>Solution</strong><br>Use invoker’s rights by providing the <code>AUTHID</code> property within the declaration of your program. If the<br>AUTHID property is specified when defining a package, procedure, or function, then you have the ability<br>to specify whether the program should be invoked using the <code>CURRENT_USER</code> privileges or the <code>DEFINER</code><br>privileges. In the case of this solution, you would rather use the CURRENT_USER privileges to ensure that<br>the user does not have the same level of access as the schema owner. The default is DEFINER.<br>The following code shows how to create a procedure for changing a password, and it uses the AUTHID<br>property to ensure that the procedure will be run using the CURRENT_USER’s privilege set. This particular<br>procedure uses dynamic SQL to create a SQL statement. To learn more about using dynamic SQL, please<br>see Chapter 8.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE change_password(username IN VARCHAR2, 
                                                                                                                    
                                          new_password IN VARCHAR2)
AUTHID CURRENT_USER IS 
 
sql_stmt VARCHAR2(100); 

BEGIN 
    sql_stmt :&#x3D; &#39;ALTER USER &#39; ||  username || &#39; IDENTIFIED BY &#39; || new_password; 
    
    EXECUTE IMMEDIATE sql_stmt; 
END; </code></pre>
<p>When the user executes this procedure, it will be executed using their own set of permissions. This<br>will prevent them from changing anyone else’s password unless they have the ability to do so under their<br>allotted(v.分配;指派;拨给) permission set.  </p>
<p><strong>How It Works</strong><br>Invoker’s rights are a great way to secure your application if you are planning to limit access to the<br>CURRENT_USER’s privilege set. To allow for invoker’s rights to be set into place, the AUTHID property must<br>be used with the CURRENT_USER keyword in the definition of a stored PL&#x2F;SQL unit. This property affects<br>the name resolution and privilege set for that unit. You can find the value of the AUTHID property if you<br>take a look at the USER_PROCEDURES data dictionary view.<br>Using the invoker’s rights methodology is a great way to protect a program as long as the users<br>access the program with their own database account. If each user within the database has their own<br>account, then they can be granted the required level of access via database roles. The AUTHID property<br>can constrain the execution of code to the current user’s privilege set. Because of that, if a user does not<br>have the privileges that are required to execute a particular program, then they will not have access.<br>Simply put, invoker’s rights are a good means of securing your code as long as the approach is used<br>correctly.</p>
<p>summary:  </p>
<ol>
<li>must execute code by your access right</li>
</ol>
<h2 id="4-18-Accepting-Multiple-Parameter-Sets-in-One-Function"><a href="#4-18-Accepting-Multiple-Parameter-Sets-in-One-Function" class="headerlink" title="4-18. Accepting Multiple Parameter Sets in One Function"></a>4-18. Accepting Multiple Parameter Sets in One Function</h2><p><strong>Problem</strong><br>You want to give a function the ability to accept multiple parameter types instead of being constrained<br>to a particular datatype or number of parameters. For example, you want to create a single function that<br>can accept either one or two parameters and that will perform a slightly(adv.些微地,轻微地) different action depending upon<br>the number of parameters you pass it.  </p>
<p><strong>Solution</strong><br>Use overloading to create multiple functions that are named the same and perform similar functionality<br>but accept a different number of parameters, different ordering of parameters, or parameters of different<br>types. In this recipe, you will see a function named squared that takes a number and returns its value<br>squared. Similarly, there is another function also named squared that accepts two numbers instead of<br>one. This second function is the overloaded version of the original squared. Here is the code for the two<br>functions: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- Returns the square of the number passed in 
CREATE OR REPLACE FUNCTION squared (in_num IN NUMBER) 
RETURN NUMBER AS 
  -- variables
BEGIN 
  RETURN in_num * in_num; 
END; </code></pre>
<pre class="language-sql" data-language="sql"><code class="language-sql"> -- Returns the squared sum of two numbers 
CREATE OR REPLACE FUNCTION squared (in_num IN NUMBER, 
                                    in_num_two IN NUMBER) 
    RETURN NUMBER AS 
BEGIN 
  RETURN (in_num + in_num_two) * (in_num + in_num_two);  
END; </code></pre>

<p>another type </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION squared (in_num IN NUMBER, 
                                    in_num_two IN NUMBER
                                    out_number_three out NUMBER) 
    RETURN NUMBER AS 
NOK   NUMBER;

BEGIN 
  out_number_three :&#x3D; (in_num + in_num_two) * (in_num + in_num_two);  
  RETURN NOK;  
END; 
</code></pre>
<p>You can see that each of the previous functions accepts a different number of parameters, but they<br>both perform similar tasks. This is a good illustration for using function overloading because someone<br>using this function would expect a similar result to be returned whether calling the function with one<br>parameter or two. </p>
<p><strong>How It Works</strong><br>Like many other programming languages, PL&#x2F;SQL offers an overloading(重载) of functions. This makes it<br>possible to name more than one function by the same name but give each of them different parameter<br>types, different parameter ordering, or a different number of parameters. This is also known as changing<br>the function signature. A signature for a function consists of the object name and its parameter list. By<br>overloading, you have the ability to allow more flexibility to those using the function. For instance, if you<br>place both of the squared functions into a package named MATH_API, then someone using this package<br>can simply call the function passing whatever they require and still receive a usable result without<br>actually knowing the implementation details.<br>Using overloading to create multiple functions or procedures by the same name can become<br>troublesome if overused. Be careful that your package is not littered with too many overloaded<br>procedures or functions because maintenance on such a code base can become a nightmare.<br>Overloading has its good use cases, but if it can be avoided by using technique that is easier to follow,<br>then it is a good idea to go the simpler route. </p>
<h2 id="4-19-Listing-the-Functions-Procedures-and-Packages-in-a-Schema"><a href="#4-19-Listing-the-Functions-Procedures-and-Packages-in-a-Schema" class="headerlink" title="4-19. Listing the Functions, Procedures, and Packages in a Schema"></a>4-19. Listing the Functions, Procedures, and Packages in a Schema</h2><p><strong>Problem</strong><br>Your team has defined a number of functions, procedures, and packages within a schema. You want to<br>generate a listing of all functions, procedures, and packages at the end of each day to evaluate<br>productivity. </p>
<p><strong>Solution</strong><br>Use the USER_OBJECTS table to return the program list and prefix packages, procedures, and functions for<br>the same program with the same first word to make them easier to find.<br>This first example will return a list of all procedure names that reside within the EMP schema and that<br>have a name that is prefixed with EMPTIME: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SELECT OBJECT_NAME 
FROM USER_OBJECTS 
WHERE OBJECT_TYPE &#x3D; &#39;PROCEDURE;
WHERE OBJECT_NAME like &#39;EMPTIME%&#39;; </code></pre>

<p>The next query will return a list of all function names that reside within the schema: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SELECT OBJECT_NAME 
FROM USER_OBJECTS 
WHERE OBJECT_TYPE &#x3D; &#39;FUNCTION&#39;; </code></pre>

<p>Lastly, the following query will return a listing of all package names that reside within the schema: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SELECT OBJECT_NAME 
FROM USER_OBJECTS 
WHERE OBJECT_TYPE &#x3D; &#39;PACKAGE&#39;;</code></pre>
<blockquote>
<p>get_DDL() </p>
</blockquote>
<p><strong>How It Works</strong><br>Oracle Database contains many views that contain data useful for application development. Using the<br>USER_OBJECTS table can be very handy when searching for objects within the database. By prefixing like<br>objects with the same first word, it can make searching for a particular selection of objects rather easy.<br>USER_OBJECTS provides the ability to find a certain object type by specifying the OBJECT_TYPE within<br>the query. If no OBJECT_TYPE is specified, then all objects for the schema will be returned.</p>
<h2 id="4-20-Viewing-Source-Code-for-Stored-Programs"><a href="#4-20-Viewing-Source-Code-for-Stored-Programs" class="headerlink" title="4-20. Viewing Source Code for Stored Programs"></a>4-20. Viewing Source Code for Stored Programs</h2><p><strong>Problem</strong><br>You want to retrieve the code for your stored functions, procedures, triggers, and packages. </p>
<p><strong>Solution</strong><br>Use the <code>DBMS_METADATA</code> package to assist(vi.参加) you in fetching the information. In this case, you will use the<br><code>DBMS_METADATA.GET_DDL</code> procedure to obtain the code for a stored function. In the following code, the<br>DBMS_METADATA package is used to return the DDL for the CALC_QUARTER_HOUR function: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SELECT DBMS_METADATA.GET_DDL(&#39;FUNCTION&#39;,&#39;CALC_QUARTER_HOUR&#39;) FROM DUAL; </code></pre>

<p>The query illustrated previously should produce results that are similar to the following as long as<br>you have the <code>CALC_QUARTER_HOUR</code> function loaded in your database: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION &quot;MY_SCHEMA&quot;.&quot;CALC_QUARTER_HOUR&quot; (HOURS IN NUMBER) 
RETURN NUMBER AS 
   CALCULATED_HOURS NUMBER :&#x3D; 0; 
BEGIN 
   IF HOURS &gt; 1 THEN 
        IF MOD(HOURS, 1) &lt;&#x3D;.125 THEN 
          CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1); 
        ELSIF MOD(HOURS, 1) &gt; .125 AND MOD(HOURS,1) &lt;&#x3D; .375 THEN 
          CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.25,1); 
       ELSIF MOD(HOURS, 1) &gt; .375 AND MOD(HOURS,1) &lt;&#x3D; .625 THEN 
          CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.50,1); 
       ELSIF MOD(HOURS, 1) &gt; .63 AND MOD(HOURS,1) &lt;&#x3D; .825 THEN 
          CALCULATED_HOURS :&#x3D; substr(to_char(HOURS),0,1) + MOD(.75,1); 
       ELSE 
          CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); 
       END IF; 
   ELSE 
       IF HOURS &gt; 0 AND HOURS &lt;&#x3D;.375 THEN 
         CALCULATED_HOURS :&#x3D; .25; 
       ELSIF HOURS &gt; .375 AND HOURS &lt;&#x3D; .625 THEN 
         CALCULATED_HOURS :&#x3D; .5; 
       ELSIF HOURS &gt; .625 AND HOURS &lt;&#x3D; .825 THEN 
         CALCULATED_HOURS :&#x3D; .75; 
       ELSE 
         CALCULATED_HOURS :&#x3D; ROUND(HOURS,1); 
       END IF; 
   END IF; 
   RETURN CALCULATED_HOURS; 
 END CALC_QUARTER_HOUR; </code></pre>
<p>The GET_DDL function returns the code that can be used to re-create the procedure or function. This<br>can be a good way to debug code that you may not have authored and do not have on hand.<br>■ Note The GET_DDL function will not format the code. Rather, it will be returned as a single string of text. By<br>default, the buffer will not be large enough to display all of the DDL. You can change the buffer size by issuing the<br>SET LONG buffersize within SQL*Plus, substituting buffersize with a large integer value. </p>
<p><strong>How It Works</strong><br>You can use the DBMS_METADATA package to retrieve various pieces of information from the database. The<br>solution to this recipe demonstrated how to fetch the DDL for a function. There is an abundance of<br>information that can be obtained by using the DBMS_METADATA package, and <code>GET_DDL</code> barely scratches the<br>surface. </p>
<p>The GET_DDL function can return the code for each different type of object. To retrieve a the code for<br>an object using GET_DDL, use the following syntax: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SELECT DBMS_METADATA.GET_DDL(&#39;object_type&#39;,&#39;object_name&#39;, &#39;schema&#39;) FROM DUAL; </code></pre>
<p>The OBJECT_TYPE can be the name of any database object type, including TABLE. For the purposes of<br>PL&#x2F;SQL code, the OBJECT_TYPE can be FUNCTION, PROCEDURE, PACKAGE, or TRIGGER. The SCHEMA parameter is<br>optional and does not have to be specified if the object resides within the caller’s schema.<br>Using DBMS_METADATA, you can obtain complete database object definitions from the database<br>dictionary via the retrieval subprograms. To learn more about the DBMS_METADATA package and obtain a<br>listing of available subprograms, please refer to the online Oracle documentation at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/B28359_01/appdev.111/b28419/d_metada.htm#ARPLS640">http://download.oracle.com/docs/cd/B28359_01/appdev.111/b28419/d_metada.htm#ARPLS640</a>, which<br>goes into detail regarding each of the subprogram functionalities. </p>
<p>summary:  </p>
<pre class="language-text" data-language="text"><code class="language-text">It has always been a huge pain to punch the DDL for tables, indexes and stored procedures into a flat file. Oracle now has a dbms_metadata package with a get_ddl function to copy DDL syntax out of the dictionary.

With all of the new storage clauses and advanced parameters, getting table and index definitions has always been a huge problem.  Hence, prior to Oracle, the DBA was generally forced to keep the DDL source code in a special library.  This makes life difficult because the DBA is now forced to maintain and manage versions of tables and index DDL separately from the data dictionary.

Oracle, the DBA will be able to keep all table and index definitions inside the data dictionary (where they belong), and use the get_ddl function to punch-out a copy whenever they need to migrate the object.

Below we see that the get_ddl function is very simple to use, only requiring the object_type and the object_name as import parameter.  Also, make sure to set linesize to a large value, because get_ddl returns a CLOB datatype, and you want SQL*Plus to be able to display the result set.

Set lines 90000

Spool sales_table_ddl.sql

Select dbms_metadata.get_ddl('TABLE','SALES','schema') from dual;

Spool off;

If you like Oracle tuning, you might enjoy my latest book "Oracle Tuning: The Definitive Reference" by Rampant TechPress.  It's only $41.95 (I don't think it is right to charge a fortune for books!) and you can buy it right now at this link:</code></pre>

<h1 id="5-Triggers"><a href="#5-Triggers" class="headerlink" title="5. Triggers"></a>5. Triggers</h1><p>Triggers play an important role in any database developer’s or database administrator’s career. They<br>provide the ability to execute code upon the occurrence of defined database, schema, or system events.<br>Triggers can be useful for enhancing applications by providing database capabilities when a table event<br>occurs, providing alerts on system event occurrences, and so much more. Triggers are an enormous<br>topic because they are very intricate constructs. However, even though triggers can open up a world of<br>possibilities, they are easy to use.<br>In this chapter, you will see recipes demonstrating the many different capabilities that triggers<br>provide to you. If you are interested in learning how to create code that executes upon a database table–<br>level event, then this is the chapter for you. If you want to learn how to create an intricate alerting system<br>that will send e-mail and create logs upon system events, then look at the recipes in this chapter.<br>Triggers are intricate building blocks that can provide an enormous benefit to our databases and<br>applications as a whole. By learning how to incorporate these recipes into your applications, you will be<br>able to solve many issues and enhance a number of your application features. Triggers can be one of the<br>most useful tools to add to a DBA or application developer’s arsenal. </p>
<h2 id="5-1-Automatically-Generating-Column-Values-how-use-before-insert"><a href="#5-1-Automatically-Generating-Column-Values-how-use-before-insert" class="headerlink" title="5-1. Automatically Generating Column Values(how use before insert)"></a>5-1. Automatically Generating Column Values(how use before insert)</h2><p><strong>Problem</strong><br>You want to automatically generate certain column values for newly inserted rows. For example, one of your tables includes a date field that you want to have populated with the current date when a record is inserted. </p>
<p><strong>Solution</strong><br>Create a trigger that executes BEFORE INSERT on the table. The trigger will capture the system date and populate this date field with it prior to inserting the row into the database. The following code demonstrates how to create a trigger that provides this type of functionality for your application. In the example, the EMPLOYEES table is going to have its HIRE_DATE populated with the current date when a record is inserted into the EMPLOYEES table. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE or REPLACE TRIGGER populate_hire_date 
BEFORE INSERT ON employees 
    FOR EACH ROW 
DECLARE 
BEGIN 
    :new.hire_date :&#x3D; sysdate; -- new.hire_date  means user&#39;s data
END; </code></pre>

<p>A BEFORE INSERT trigger has access to data before it is inserted into the table. This example<br>demonstrates a useful technique for using this type of trigger. </p>
<p><strong>How It Works</strong><br>You can use triggers to execute code when a DML statement, DDL statement, or system event occurs.<br>This recipe demonstrates a trigger that executes when a DML event occurs. Specifically, the trigger that<br>was created for this recipe is fired BEFORE a row is inserted into the EMPLOYEES table. Any DDL event<br>trigger can be created to fire BEFORE or AFTER a row is inserted, updated, or deleted from a database table.<br>This flexibility allows a developer or DBA the luxury of executing code either before or directly after the<br>values are inserted into the database.<br>The syntax for creating a trigger that will execute before an insert on a particular table is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE or REPLACE TRIGGER trigger_name 
BEFORE INSERT 
    ON table_name 
    [ FOR EACH ROW ] 
DECLARE 
    -- variable declarations 
BEGIN 
    -- trigger code 
EXCEPTION 
    WHEN ... 
    -- exception handling 
END; </code></pre>
<p>The CREATE OR REPLACE TRIGGER statement will do just what it says, either create the trigger in the<br>current schema if none is specified or replace it if another trigger by that name already exists. The trigger<br>name must be unique among other triggers within the same schema. Although it is possible to name a<br>trigger the same as an existing table, we do not recommend doing so. Different triggers by the same<br>name can coexist in the same database if they are in different schemas.<br>The BEFORE INSERT clause is what tells Oracle when the trigger should be executed before a row is<br>inserted into the table. The other option for insert triggers is AFTER INSERT, which causes the trigger to be<br>executed after a row is inserted into the table. You will learn more about AFTER INSERT triggers in<br>another recipe within this chapter. The optional <code>FOR EACH ROW</code> clause determines whether the trigger will<br>be executed once for each row that is affected or once when the statement is executed. Essentially this<br>clause determines whether it will become a row-level trigger or a statement level-trigger. The FOR EACH<br>ROW clause can have a significant impact on the outcome of an UPDATE trigger. You will learn more about<br>UPDATE triggers in the next recipe.<br>The code that follows the optional FOR EACH ROW clause is the DECLARE section. Much like that of a<br>procedure, this section of the trigger is used to declare any variables, types, or cursors that will be used<br>by the trigger body. The body of the trigger also resembles(类似) that of a procedure. The trigger body is a<br>standard code block that opens with the BEGIN keyword and ends with the END keyword. Any of the<br>keywords and constructs that can be used within other PL&#x2F;SQL code blocks can also be used in triggers.<br>There are a couple of differences between the trigger and other code blocks in PL&#x2F;SQL. First, a<br>trigger is limited to 32KB in size. This is a bit of a limitation; however, it does not prevent a trigger from<br>invoking other named code blocks. For example, you can write a trigger to invoke stored procedures and<br>functions that are much longer than 32KB in size.  </p>
<p>Second, the <code>INSERT trigger</code> has access to data values prior to insertion in the database via the <code>:NEW</code><br>qualifier. This qualifier is what provides the power to the trigger construct. Using the <code>:NEW</code> qualifier along<br>with a table column name allows you to access the value that is going to be placed into that column via<br>the INSERT statement that has just occurred. In the solution to is recipe, using <code>:NEW.FIRST_NAME</code> and<br><code>:NEW.LAST_NAME</code> allows you to reference the values that are going to be inserted into the FIRST_NAME and<br>LAST_NAME columns before it occurs. This provides the ability to change the values or check the values for<br>error prior to insertion. </p>
<p>In the case of the solution to this recipe, the HIRE_DATE will always be made the same as the date in<br>which the record is inserted into the database. Even if the HIRE_DATE is set to some date in the past, this<br>trigger will automatically assign SYSDATE to it and override the original value. Now, this may not be very<br>practical example because the data entry clerk may not be inputting the data on the same day as the<br>hire, but it does provide an effective learning tool for this type of situation. If you wanted to modify the<br>trigger to be more realistic, then you could add an IF statement to check and see whether<br>:NEW.HIRE_DATE already had a value. If it does, then that value is inserted into the database, but if left<br>blank, then SYSDATE could be used. Such an example would be a more practical real-life solution. </p>
<p>summary:  </p>
<ol>
<li>32KB in size but you could  invoke function and procedure that more that 32kb</li>
<li>:NEW.FIRST_NAME allow you access data that you gonna insert</li>
<li>Even if the HIRE_DATE is set to some date in the past, this trigger will automatically assign SYSDATE to it and override the original value</li>
</ol>
<h2 id="5-2-Keeping-Related-Values-in-Sync"><a href="#5-2-Keeping-Related-Values-in-Sync" class="headerlink" title="5-2. Keeping Related Values in Sync"></a>5-2. Keeping Related Values in Sync</h2><p><strong>Problem</strong><br>You want to keep related values in sync that happen to be stored in separate tables. For example, say you<br>are updating the salary level for a number of jobs within the JOBS table. However, in doing so, you will<br>need to update the salaries within the EMPLOYEES table for employees having those jobs. In short, if you<br>update the salary range for a job, then you want to automatically update salaries to ensure that they fall<br>within the new range.  </p>
<p>■ Note When we use the term related in this problem description, we do not necessarily mean related in the<br>relational sense that one commonly thinks about. There is no referential integrity issue in our scenario. Rather, we<br>are instituting a business rule that says that employees automatically get salary bumps in response to changing<br>salary ranges. Not all businesses would choose to institute such a rule. In fact, we suspect most businesses would<br>not do such a thing.  </p>
<p><strong>Solution</strong><br>Create an AFTER UPDATE trigger on the primary table. In our example, create such a trigger to be executed<br>after the JOBS table has been updated. This trigger will obtain the updated salary from the JOBS table and<br>modify the data within the EMPLOYEES table accordingly. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER job_salary_update 
AFTER UPDATE 
    ON jobs 
FOR EACH ROW 
DECLARE 
 
  CURSOR emp_cur IS 
  SELECT * FROM employees  
  WHERE job_id &#x3D; :new.job_id 
  AND salary &lt; :new.min_salary FOR UPDATE; 
 
  emp_rec  emp_cur%ROWTYPE; 
 
BEGIN 
 
    FOR emp_rec IN emp_cur LOOP 
        UPDATE employees 
        SET salary &#x3D; :new.min_salary 
        WHERE CURRENT OF emp_cur; 
    END LOOP; 
 
END; </code></pre>

<p>Since this example uses an AFTER UPDATE trigger, you have access to both the :NEW and :OLD data value<br>qualifiers. This can be very advantageous, as you’ll learn in the next section. </p>
<p><strong>How It Works</strong><br>The update trigger provides the same type of functionality as an INSERT trigger. The syntax for an update<br>trigger is almost identical to that of an insert trigger, other than the BEFORE UPDATE or AFTER UPDATE<br>clause. A BEFORE UPDATE trigger is executed prior to an update on a database table. On the contrary, the<br>AFTER UPDATE executes after an update has been made to a table.<br>The optional FOR EACH ROW clause can make a great deal of difference when issuing an update<br>trigger. If used, this clause tells Oracle to execute the trigger one time for every row that is updated. This<br>is quite useful for capturing or modifying data as it is being updated. If the FOR EACH ROW clause is<br>omitted, the trigger is executed one time either prior to or after the UPDATE has taken place. Without the<br>FOR EACH ROW clause, the trigger is not executed once for each row but rather one time only for each<br>UPDATE statement that is issued.<br>As mentioned previously in this recipe, update triggers have access to the :OLD and :NEW qualifiers.<br>The qualifiers allow the trigger to obtain the values of data that are being updated prior to (:OLD) and<br>after (:NEW) the update has been made. Generally, update triggers are most useful for obtaining and<br>modifying data values as the update is occurring. Update triggers, along with every other type of trigger,<br>should be used judiciously because too many triggers on a table can become problematic.<br>For example, the solution to this recipe demonstrates a trigger in which a salary change in the JOBS<br>table causes a trigger to execute. The trigger will be executed only if the JOBS table is updated. The cursor<br>that is declared will select all the records within the EMPLOYEES table that contain a SALARY that is lower<br>than the new MIN_SALARY for the corresponding JOB_ID. In the body of the trigger, the cursor result set is<br>iterated, and each record is updated so that the SALARY is adjusted to the new MIN_SALARY amount for that<br>job.<br>If that trigger contains another update statement that modifies values in the EMPLOYEES table, then<br>you must be sure that the EMPLOYEES table does not contain an update trigger that modifies values within<br>the JOBS table. Otherwise, a vicious cycle could occur in which one trigger is causing another trigger to<br>execute, which in turn causes the initial trigger to execute again, and so on. This may even cause an<br>ORA-xxxxx error if Oracle detects a recursive loop.<br>Update triggers can provide the best of both worlds because you have access to data values before<br>and after they have been updated. </p>
<h2 id="5-3-Responding-to-an-Update-of-a-Specific-Table-Column"><a href="#5-3-Responding-to-an-Update-of-a-Specific-Table-Column" class="headerlink" title="5-3. Responding to an Update of a Specific Table Column"></a>5-3. Responding to an Update of a Specific Table Column</h2><p><strong>Problem</strong><br>You want to automatically update some particular values within a table based upon another update that<br>has been made on a specific column of another table. For instance, assume that management has<br>decided to change some positions around within your organization. A new manager is coming to one of<br>the current manager positions, so several employees will receive a new manager. You need to find a way<br>to update several employee records to change their manager from the old one to the new one.  </p>
<p><strong>Solution</strong><br>Create an AFTER UPDATE trigger that will be executed only when the MANAGER_ID column is updated. The<br>following trigger uses a cursor to obtain the employees that are supervised(adj.有监督的) by the old manager. The<br>trigger then determines whether the MANAGER_ID column has been updated, and if so, it loops through<br>each employee who has the old manager in their record, and it updates the MANAGER_ID column to reflect<br>the new manager’s ID. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER dept_mgr_update 
AFTER UPDATE OF manager_id   -- column name
    ON departments  --table
FOR EACH ROW 
DECLARE 
  CURSOR emp_cur IS 
  SELECT * 
  FROM EMPLOYEES 
  WHERE manager_id &#x3D; :old.manager_id 
  FOR UPDATE; 
BEGIN 
 
   
     FOR emp_rec IN emp_cur LOOP 
        UPDATE employees 
        SET manager_id &#x3D; :new.manager_id 
        WHERE CURRENT OF emp_cur; 
     END LOOP; 
   
END; </code></pre>
<p>This trigger will be executed only if the MANAGER_ID column of the DEPARTMENTS table is updated.<br>Triggers that have this ability provide for better database performance, because the trigger is not<br>executed each time the DEPARTMENTS table has been updated. </p>
<p><strong>How It Works</strong><br>Triggers can specify columns that must have their values updated in order to cause the trigger to<br>execute. This allows the developer to have finer-grained control over when the trigger executes. You can<br>take a few different strategies in order to cause a trigger to execute upon an update of a specified<br>column. As is demonstrated in the solution to this recipe, you can specify the column in the trigger<br>declaration. This is one of the easiest approaches to take, and it causes the trigger to execute only if that<br>specified column is updated. Alternatively, you can use a conditional predicate in the trigger body to<br>determine whether the row you had specified in the declaration is indeed being updated. A conditional<br>predicate can be used along with a specified column name to determine whether a specified action is<br>being performed on the named column. You can use three conditional predicates, INSERTING, UPDATING,<br>and DELETING. Therefore, a conditional predicate such as the following can be used to determine whether<br>a specified column is being updated by the current statement: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">IF UPDATING (&#39;my_column&#39;) THEN 
  -- Some statements 
END IF; </code></pre>

<p>Using a conditional predicate(vt.断定为) ensures that the code in the THEN clause is executed only if a specified<br>action is occurring against the named column. These predicates can also be used along with other<br>conditions to have finer-grained control over your statements. For instance, if you want to ensure that a<br>column was being updated and also that the current date does not match some end date, then you can<br>combine those two conditions with an AND boolean operator. The following code demonstrates this type<br>of conditional statement: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">IF UPDATING (&#39;my_column&#39;) AND end_date &gt; SYSDATE THEN 
  -- Some statements 
END IF; </code></pre>

<p>If you prefer to use the technique demonstrated in the solution to this recipe, then you can still<br>check to ensure that the specified column is being updated by using the <code>IF UPDATING</code> predicate without<br>the column name specified. This technique would look like the following statement:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">IF UPDATING THEN 
  --some statements 
END IF; </code></pre>

<p>As mentioned in the solution to this recipe, specifying a specific column can help decrease the<br>amount of times that the trigger is fired because it is executed only when the specified column has been<br>updated. Another advantage to using this level of constraint within your triggers is that you can add<br>more triggers to the table if needed. For instance, if you needed to create another trigger to fire AFTER<br>UPDATE on another column on the same table, then it would be possible to do so with less chance of a<br>conflict. On the contrary(adj.相反的), if you were using a simple AFTER UPDATE trigger, then chances of a conflict are<br>more likely to occur. </p>
<p>summary:  </p>
<ol>
<li>three types of update checking</li>
</ol>
<h2 id="5-4-Making-a-View-Updatable"><a href="#5-4-Making-a-View-Updatable" class="headerlink" title="5-4. Making a View Updatable"></a>5-4. Making a View Updatable</h2><p><strong>Problem</strong><br>You are working with a database view, and it needs to be updated. However, the view is not a simple<br>view and is therefore read-only. If you tried to update a column value on the view, then you would<br>receive an error. </p>
<p><strong>Solution</strong><br>Use an <code>INSTEAD OF</code> trigger to specify the result of an update against the view, thus making the view<br>updatable. For example, let’s begin with the following view definition: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE VIEW EMP_JOB_VIEW AS 
  SELECT EMP.employee_ID, EMP.first_name, EMP.last_name, 
         EMP.email, JOB.job_title, 
         DEPT.department_name 
  FROM employees EMP, 
       jobs JOB, 
       departments DEPT 
  WHERE JOB.job_id &#x3D; EMP.job_id 
  AND DEPT.department_id &#x3D; EMP.department_id 
  ORDER BY EMP.last_name;  </code></pre>

<p>Given the EMP_JOB_VIEW just shown, if you attempt to make an update to a column, then you will<br>receive an error. The following demonstrates the consequences of attempting to update the<br>DEPARTMENT_NAME column of the view. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; update emp_job_view 
  2  set department_name &#x3D; &#39;dept&#39; 
  3  where department_name &#x3D; &#39;Sales&#39;; 
where department_name &#x3D; &#39;Sales&#39; 
      * 
ERROR at line 3: 
ORA-01779: cannot modify a column which maps to a non key-preserved table </code></pre>
<p>However, using the <code>INSTEAD OF</code> clause, you can create a trigger to implement the logic for an UPDATE<br>statement issued against the view. Here’s an example:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER update_emp_view 
INSTEAD OF UPDATE ON emp_job_view 
REFERENCING NEW AS NEW   -- note
FOR EACH ROW 
DECLARE 
  emp_rec                        employees%ROWTYPE; 
 
  title                          jobs.job_title%TYPE; 
  dept_name                      departments.department_name%TYPE; 
BEGIN 
 
    SELECT * 
    INTO emp_rec 
    FROM employees 
    WHERE employee_id &#x3D; :new.employee_id; 
 
    UPDATE jobs 
    SET job_title &#x3D; :new.job_title 
    WHERE job_id &#x3D; emp_rec.job_id; 
 
    UPDATE departments 
    SET department_name &#x3D; :new.department_name 
    WHERE department_id &#x3D; emp_rec.department_id; 
     
    UPDATE employees 
    SET email &#x3D; :new.email, 
    first_name &#x3D; :new.first_name, 
    last_name &#x3D; :new.last_name 
    WHERE employee_id &#x3D; :new.employee_id;
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;No matching record exists&#39;); 
END; </code></pre>

<p>The following are the results of issuing an update on the view when the UPDATE_EMP_VIEW trigger is in<br>place. The UPDATE is issued, and the INSTEAD OF trigger executes instead of the database’s built-in logic.<br>The result is that the rows containing a DEPARTMENT_NAME of Sales will be updated in the view. Hence, the<br>underlying(v.放在…的下面) row in the DEPARTMENTS table is updated to reflect the change.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; update emp_job_view 
  2  set department_name &#x3D; &#39;Sales Dept&#39; 
  3  where department_name &#x3D; &#39;Sales&#39;; 
34 rows updated. </code></pre>
<p>If you were to query the view after performing the update, then you would see that the view data has<br>been updated to reflect the requested change. If you read through the code in the trigger body, you can<br>see the magician behind the curtain(n.幕;窗帘).</p>
<p><strong>How It Works</strong><br>Oftentimes it is beneficial to have access to view data via a trigger event. However, there are some views<br>that are read-only, and data manipulation(n.操纵;操作) is not allowed. Views that include any of the following<br>constructs are not updatable and therefore require the use of an <code>INSTEAD OF</code> trigger for manipulation: </p>
<pre class="language-none"><code class="language-none">•SET 
•DISTINCT 
•GROUP BY, ORDER BY, CONNECT BY 
•MODEL 
•START WITH 
•Subquery within a SELECT or containing the WITH READ ONLY clause 
•Collection expressions 
•Aggregate or analytic functions </code></pre>
<p>A trigger that has been created with the INSTEAD OF clause allows you to declare a view name to be acted<br>upon, and then once the specified event occurs, the trigger is fired, which causes the actual INSERT,<br>UPDATE, or DELETE statement to occur. The trigger body actually acts upon the real tables behind the<br>scenes using the values that have been specified in the action.<br>The format for the <code>INSTEAD OF</code> trigger is the same as any other trigger with the addition of the<br>INSTEAD OF clause. You can see in the solution to this recipe that an additional clause has been specified,<br>namely, <code>REFERENCING NEW AS NEW</code>. The <code>REFERENCING</code> clause can be used by triggers to specify how you<br>want to prefix <code>:NEW</code> or <code>:OLD</code> values. This allows you to use any alias for <code>:NEW</code> or <code>:OLD</code>, so it is possible to<br>reference a new value using <code>:blah.my_value</code> if you used the following clause when you declared your<br>trigger: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">REFERENCING NEW AS BLAH </code></pre>

<p>Although there is no real magic at work behind an INSTEAD OF trigger, they do abstract some of the<br>implementation details away from the typical user such that working with a view is no different from<br>working with an actual table. </p>
<p>summary:  </p>
<ol>
<li>(the changes of view be reflected at basic table)</li>
</ol>
<h2 id="5-5-Altering-the-Functionality-of-Applications"><a href="#5-5-Altering-the-Functionality-of-Applications" class="headerlink" title="5-5. Altering the Functionality of Applications"></a>5-5. Altering the Functionality of Applications</h2><p><strong>Problem</strong><br>You want to modify a third-party application, but you are not in a position to change the source code.<br>Either you are not allowed to change the source or you simply do not have access to make changes.<br>As an example, let’s consider a form in one application used to create jobs within the JOBS table. You<br>want to enhance the application so that mail is sent to all the administrative staff members when a new<br>job is created. However, your company does not own the license to modify the source code of the<br>application.</p>
<p><strong>Solution</strong><br>You can often use triggers to add functionality to an application behind the scenes, without modifying<br>application code. Sometimes you have to think creatively to come up with a trigger or blend of triggers<br>that accomplishes your goal.<br>You can solve our example problem by creating a trigger that will execute after an insert has been made<br>on the JOBS table. This trigger will obtain the information regarding the job that was just created and<br>send an e-mail containing that information to all administrative personnel. In the following trigger,<br>some necessary information regarding the new job entry is obtained and processed by the SEND_EMAIL<br>procedure, which in turn sends the mail.<br>First, here is the code for the trigger: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER send_job_alert 
  AFTER INSERT ON jobs 
  FOR EACH ROW 
DECLARE 
  to_address                    varchar2(50) :&#x3D; &#39;admin_list@mycompany.com&#39;; 
  v_subject                     varchar2(100) :&#x3D; &#39;New job created: &#39; || :new.job_title; 
  v_message                     varchar2(2000); 
BEGIN 
 
  v_message :&#x3D; &#39;There has been a new job created with an ID of &#39; || :new.job_id ||  
               &#39; and a title of &#39; || :new.job_title || &#39;.  The salary range is: &#39; || 
               :new.min_salary || &#39; – &#39; || :new.max_salary; 
   -- Initiate the send_email procedure 
  SEND_EMAIL(to_address, v_subject,  v_message); 
               
END; </code></pre>
<p>Next is the stored procedure that actually sends the e-mail: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE send_email(to_address IN VARCHAR2, 
                                        subject IN VARCHAR2, 
                                        message IN VARCHAR2) AS 
BEGIN 
   UTL_MAIL.send(sender &#x3D;&gt; &#39;me@address.com&#39;, 
            recipients &#x3D;&gt; to_address, 
               subject &#x3D;&gt; subject, 
               message &#x3D;&gt; message, 
             mime_type &#x3D;&gt; &#39;text; charset&#x3D;us-ascii&#39;); 
END; </code></pre>

<p>A trigger has the ability to call any other PL&#x2F;SQL named block as long as it is in the same schema or<br>the schema that contains the trigger has the correct privileges to access the named block in the other<br>schema. </p>
<p><strong>How It Works</strong></p>
<p>The ability to use triggers for altering third-party applications can be extremely beneficial. Using a DML<br>trigger on INSERT, UPDATE, or DELETE of a particular table is a good way to control what occurs with<br>application data once a database event occurs. This technique will be transparent to any application<br>users because the trigger would most likely be executed when the user saves a record via a button that is<br>built into the application. </p>
<p>Although creating database triggers to alter functionality can be beneficial, you must also be careful<br>not to create a trigger that will have an adverse effect on the application. For instance, if you create a<br>trigger that updates some data that has been entered and the application is expecting to do something<br>different with the data, then the application may not work as expected. One way to remedy(vt.补救;治疗;纠正) this issue<br>would be to create an autonomous transaction. Autonomous transactions ensure that an application<br>continues to run even if a dependent body of code fails. In this case, an autonomous transaction could<br>prevent a failed trigger from crashing an application. To learn more about using autonomous<br>transactions, please refer to Recipe 2-13. </p>
<p>Another issue that could arise is one where too many triggers are created on the same table for the<br>same event. You must be careful when creating triggers and be aware of all other triggers that will be<br>executed during the same event. By default, Oracle does not fire triggers in any specific order, and the<br>execution order can vary each time the database event occurs. Do not create triggers that depend upon<br>other triggers, because your application will eventually fail! If you must create two or more triggers that<br>execute on the same table for the same event, then please ensure that you are using proper techniques<br>to make the triggers execute in the correct order. For more information on this topic, please refer to<br>Recipe 5-11. </p>
<p>The trigger in this particular recipe called a stored procedure. This was done so that the trigger body<br>performed a specific task and remained concise. Triggers can call as many stored procedures as<br>required, as long as the trigger itself is less than or equal to 32KB in size. The stored procedure in the<br>solution to this recipe is used to send an e-mail. As such, maintaining a separate procedure to perform<br>the task of sending e-mail will allow the trigger body to remain concise, and the procedure can also be<br>used elsewhere if needed.<br>USING ORACLE’S UTL_MAIL PACKAGE<br>The e-mail in the solution to this recipe is sent using Oracle’s UTL_MAIL package. You will learn more<br>about using this package in a later chapter, but for the purposes of testing this recipe, it is important to<br>know that the UTL_MAIL package is not enabled by default. To install it, you must log in as the SYS user<br>and execute the utlmail.sql and prvtmail.plb scripts that reside within the<br><code>$ORACLE_HOME/rdbms/admin</code> directory.<br>An outgoing mail server must also be defined by setting the SMTP_OUT_SERVER initialization parameter<br>prior to use.</p>
<p>summary:  </p>
<ol>
<li>You must be careful when creating triggers and be aware of all other triggers that will be executed during the same event,Do not create triggers that depend upon<br>other triggers</li>
<li>triggers invoked no order</li>
<li><code>UTL_MAIL</code> PACKAGE is good tool send out mail</li>
</ol>
<h2 id="5-6-Validating-Input-Data"><a href="#5-6-Validating-Input-Data" class="headerlink" title="5-6. Validating Input Data"></a>5-6. Validating Input Data</h2><p><strong>Problem</strong><br>You want to validate data before allowing it to be inserted into a table. If the input data does not pass<br>your business-rules test, you want the INSERT statement to fail. For example, you want to ensure that an<br>e-mail address field in the EMPLOYEE table never contains the domain portion of an e-mail address, in<br>other words, that it never contains the @ character or anything following the @ character. </p>
<p>■ Note Recipe 5-7 presents an alternative solution to this same problem that involves silently cleansing erroneous<br>data as it is inserted.  </p>
<p><strong>Solution</strong><br>Generally speaking, do validation using BEFORE triggers, because that lets you trap(vt.诱捕;使…受限制) errors prior to changes<br>being made to the data. For this recipe, you can write a BEFORE INSERT trigger to examine the e-mail<br>address for any new employee. Raise an error if that address contains an @ character. The following<br>example demonstrates a trigger that uses this technique. If an attempt to enter an invalid e-mail address<br>occurs, an error will be raised. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER check_email_address 
BEFORE INSERT ON employees 
FOR EACH ROW 
BEGIN 
  IF NOT INSTR(:new.email,&#39;@&#39;) &gt; 0 THEN 
    RAISE_APPLICATION_ERROR(-20001, &#39;INVALID EMAIL ADDRESS&#39;); 
  END IF; 
END; </code></pre>

<p><strong>How It Works</strong><br>A BEFORE INSERT trigger is useful for performing the validation of data before it is inserted into the<br>database. In the solution to this recipe, a trigger is created that will check to ensure that a string that<br>supposedly(adv.可能;按照推测) contains an e-mail address does indeed have an @ character within it. The trigger uses the<br>Oracle built-in <code>INSTR</code> function inside a conditional statement to determine whether the @ character<br>exists. If the character does not exist within the string, then the trigger will raise a user-defined error<br>message. On the other hand, if the string does contain the character, then the trigger will not do<br>anything. Coding a trigger for validation of data is quite common. Although the solution to this recipe checks<br>to ensure that an e-mail address is valid, you could write similar triggers to perform similar validation on<br>other datatypes. </p>
<h2 id="5-7-Scrubbing-v-用力擦洗-Input-Data"><a href="#5-7-Scrubbing-v-用力擦洗-Input-Data" class="headerlink" title="5-7. Scrubbing(v.用力擦洗) Input Data"></a>5-7. Scrubbing(v.用力擦洗) Input Data</h2><p><strong>Problem</strong><br>You are interested in examining(检查) and correcting user input prior to it being inserted into a database table.  </p>
<p><strong>Solution</strong><br>Use a BEFORE INSERT trigger to scrub the data prior to allowing it to be inserted into the table. By using a<br>trigger, you will have access to the data before it is inserted, which will provide you with the ability to<br>assess the data before it is persisted.<br>In this particular example, a trigger is being used to examine the data that was entered on a form for<br>insertion into the EMPLOYEES table. The e-mail field is being validated to ensure that it is in a valid format.<br>In particular, the e-mail field for the EMPLOYEES table includes only the address portion(n.部分;一份) to the left of the @<br>symbol. This trigger ensures that even if someone had entered the entire e-mail address, then only the<br>valid portion would be inserted into the database. The following example demonstrates this<br>functionality: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER check_email_address 
BEFORE INSERT ON employees 
FOR EACH ROW 
DECLARE 
  temp_email              employees.email%TYPE :&#x3D; :new.email; 
BEGIN 
  IF INSTR(temp_email,&#39;@&#39;) &gt; 0 THEN 
    temp_email :&#x3D; SUBSTR(:new.email, 0, INSTR(temp_email, &#39;@&#39;)-1); 
  END IF; 
 :new.email :&#x3D; temp_email; 
END; </code></pre>

<p>The trigger in this example uses a couple of different PL&#x2F;SQL built-in functions to ensure that the<br>data being inserted into the EMPLOYEES.EMAIL table is formatted correctly.</p>
<p><strong>How It Works</strong></p>
<p>BEFORE INSERT triggers work very nicely for verifying data prior to inserting it into the database. Since<br>insert triggers have access to the <code>:NEW</code> qualifier, the values that are going to be inserted into the database<br>table can be tested to ensure that they conform(vi.符合;遵照) to the proper standards and can then be manipulated(v.操作) if<br>need be. When used in a BEFORE trigger, the <code>:NEW</code> value can be altered, allowing triggers to change values<br>prior to when they are inserted. The <code>:OLD</code> qualifier will allow one to access the <code>NULL</code> old values, but they<br>cannot be changed. </p>
<p>Validating data with triggers can be very useful if used appropriately. As a rule of thumb, you should<br>not attempt to create triggers for validating data that can be performed declaratively. For instance, if you<br>need to ensure that a column of data is never NULL, then you should place a NOT NULL constraint on that<br>column.There are only a couple of circumstances where you are required to enforce(vt. 实施，执行；强迫，强制) constraints within<br>triggers, and those are as follows:<br>• If you do not have access to the database objects to alter the table and add constraints because doing so would cause issues with a program that is in place<br>• If the business logic cannot be reflected in a simple, declarative trigger<br>• If your application requires a constraint to be enforced only part of the time</p>
<p>In all other circumstances, try to use database-level constraints because that is their job, and it can<br>be done much more efficiently than using a trigger. However, trigger validation is perfect for situations<br>such as those depicted in the solution to this recipe, where complex business rules must be validated<br>that are not possible with built-in constraints.</p>
<p>summary:  </p>
<ol>
<li>above three rules must be clear</li>
<li><code>INSTR</code>‘s functionality</li>
<li>try to use database-level constraints because that is their job, and it can be done much more efficiently than using a trigger</li>
</ol>
<h2 id="5-8-Replacing-a-Column’s-Value"><a href="#5-8-Replacing-a-Column’s-Value" class="headerlink" title="5-8. Replacing a Column’s Value"></a>5-8. Replacing a Column’s Value</h2><p><strong>Problem</strong><br>You want to verify that a column value is in the correct format when it is entered into the database.  If it<br>is not in the correct format, then you want to adjust the value so that it is in the correct format before<br>inserting into the database. For example, upon creation of an employee record, it is essential that the e-<br>mail address follows a certain format.  If the e-mail address is not uniform with other employee e-mail<br>addresses, then it needs to be adjusted.  You want to write a trigger that ensures that the new employee<br>EMAIL value will be in the correct format. </p>
<p><strong>Solution</strong><br>Check the format using a BEFORE trigger. For this recipe, use a BEFORE INSERT trigger to determine<br>whether the new EMAIL value is in the correct format.  If it is not, then adjust the value accordingly so that<br>the new e-mail address will start with the first letter of the employee’s first name, followed by the<br>employee’s last name.  If the new e-mail address is not unique, then a number must be added to the end<br>of it to ensure that it will be unique.<br>The following trigger demonstrates a BEFORE INSERT trigger that checks and updates the EMAIL value<br>as described. This trigger will be fired whenever someone inserts values into the EMPLOYEES table. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER populate_emp_email 
BEFORE INSERT ON employees 
FOR EACH ROW 
DECLARE 
  email_count          NUMBER :&#x3D; 0; 
  success_flag         BOOLEAN :&#x3D; FALSE; 
  temp_email           employees.email%TYPE; 
  email_idx            NUMBER :&#x3D; 0; 
BEGIN 
  -- check to see if the email address is in the correct format 
  IF :new.email !&#x3D; UPPER(SUBSTR(:new.first_name,0,1) || :new.last_name) THEN   --- more like linux style
    -- check the database to ensure that the new email address will be unique 
    temp_email :&#x3D; UPPER(SUBSTR(:new.first_name,0,1) || :new.last_name); 
    WHILE success_flag &#x3D; FALSE LOOP 
        SELECT COUNT(*) 
        INTO email_count 
        FROM employees 
        WHERE email &#x3D; temp_email; 
         
        -- if it is unique then end the loop 
        IF email_count &#x3D; 0 THEN 
          success_flag :&#x3D; TRUE; 
        -- if not unique, then add the index number to the end and check again 
        ELSE 
          temp_email :&#x3D; UPPER(SUBSTR(:new.first_name,0,1) || :new.last_name) || email_idx; 
        END IF; 
        email_idx :&#x3D; email_idx + 1; 
    END LOOP; 
    :new.email :&#x3D; temp_email; 
  END IF; 
 
END; </code></pre>

<p>The value of the e-mail address must always follow the same format, and this trigger ensures that<br>the any new EMAIL values will follow that format. If the new EMAIL value does follow the correct format,<br>then it will be inserted into the database without changes, but if it does not follow the correct format,<br>then this trigger will adjust the value accordingly. </p>
<p><strong>How It Works</strong><br>Another frequent usage of triggers is to replace a value that someone is trying to insert into the database<br>with some other value. Much like ensuring data integrity, you must write to the :NEW qualifier value in<br>order to replace another value that was entered. When the :NEW value is overwritten, then that new value<br>is inserted into the database instead of the original value. The BEFORE trigger acts as an interceptor where<br>the values that are entered are intercepted prior to reaching the database table. The trigger has full reign<br>to change values as needed as long as the values that are changed by the trigger still maintain the<br>necessary requirements to meet the database table constraints that have been defined.<br>Any DML trigger can include multiple trigger events, including INSERT, UPDATE, or DELETE events. Any<br>combination of these three events can be used to fire a trigger. The events that are to be used for firing a<br>trigger must be listed with the OR keyword between them. The following line of code is an example of<br>using all three events on a BEFORE trigger: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEFORE INSERT OR UPDATE OR DELETE ON employees </code></pre>

<p>The events can be in any order within the BEFORE clause. Any combination of these three events can<br>also be used with the AFTER trigger. The main difference between the BEFORE and AFTER triggers is what<br>type of access each has to the :NEW and :OLD qualifiers. Table 4-1 lists the different types of triggers and<br>their subsequent access to the qualifiers.<br>Table 4-1. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">Trigger Types and Qualifier Acccess 
Trigger Type :NEW :OLD 
BEFORE Writeable Always contains NULL 
AFTER Not writeable  Always contains populated values 
INSERT Contains values  Contains NULL 
DELETE Contains NULL  Contains populated values 
UPDATE Contains populated values Contains populated values </code></pre>

<p>A BEFORE trigger has write access to values using the :NEW qualifier, and AFTER triggers do not since<br>the data has already been inserted or updated in the table. INSERT triggers have meaningful access to<br>values with the :NEW qualifier only; variables using the :OLD qualifier will be NULL. UPDATE triggers have<br>meaningful access to values using both the :NEW and :OLD qualifiers. DELETE triggers have meaningful<br>access only to values using the :old qualifier; values using the :new qualifier will be NULL.<br>Performing tasks such as replacing values with triggers should be used only on an as-needed basis.<br>This type of trigger can cause confusion for those who do not have access to the trigger code. It is also<br>important to ensure that triggers do not act upon each other in order to avoid mutating table errors. This<br>can occur if one trigger is updating the values of a table and another trigger is attempting to examine the<br>values of the table at the same time.</p>
<p>summary:  </p>
<ol>
<li>BEFORE trigger has write access,  AFTER triggers do not</li>
<li>DELETE triggers have meaningful access only to values using the :old qualifier; values using the :new qualifier will be NULL</li>
<li>INSERT triggers have meaningful access to values with the :NEW qualifier only; variables using the :OLD qualifier will be NULL</li>
<li>UPDATE triggers have meaningful access to values using both the :NEW and :OLD qualifiers</li>
</ol>
<h2 id="5-9-Triggering-on-a-System-Event"><a href="#5-9-Triggering-on-a-System-Event" class="headerlink" title="5-9. Triggering on a System Event"></a>5-9. Triggering on a System Event</h2><p><strong>Problem</strong><br>You want to write a trigger that executes on a system event such as a login. For example, you want to<br>increase security a bit for your database and ensure that users are logging into the database only during<br>the week. In an effort to help control security, you want to receive an e-mail alert if someone logs into<br>the database on the weekend. </p>
<p><strong>Solution</strong><br>Create a system-level trigger that will log an event into a table if anyone logs into the database during off-<br>hours. To notify you as promptly as possible, it may also be a good idea to send an e-mail when this<br>event occurs. To create a system-level trigger, use the AFTER LOGON ON DATABASE clause in your trigger<br>definition.<br>The first step in creating this solution is to create an audit table. In the audit table you will want to<br>capture the IP address of the user’s machine, the time and date of the login, and the authenticated<br>username. The following code will create a table to hold this information: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE TABLE login_audit_table( 
ID                        NUMBER PRIMARY KEY,   -- Populated by sequence number 
login_audit_seq 
AUDIT_DATE                DATE NOT NULL, 
AUDIT_USER          VARCHAR2(50) NOT NULL, 
AUDIT_IP            VARCHAR2(50) NOT NULL, 
AUDIT_HOST          VARCHAR2(50) NOT NULL); </code></pre>
<p>Now that the auditing table has been created, it is time to create the trigger. The following code<br>demonstrates the creation of a logon trigger: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER login_audit_event 
AFTER LOGON ON DATABASE 
DECLARE 
  v_subject                      VARCHAR2(100) :&#x3D; &#39;User login audit event triggered&#39;; 
  v_message                      VARCHAR2(1000); 
BEGIN 
  INSERT INTO login_audit_table values( 
    Login_audit_seq.nextval, 
    Sysdate, 
    SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USERID&#39;), 
    SYS_CONTEXT(&#39;USERENV&#39;,&#39;IP_ADDRESS&#39;), 
    SYS_CONTEXT(&#39;USERENV&#39;,&#39;HOST&#39;)); 
    v_message :&#x3D; &#39;User &#39; || SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USERID&#39;) || 
                           &#39; logged into the database at &#39; || sysdate || &#39; from host &#39; ||  
                SYS_CONTEXT(&#39;USERENV&#39;,&#39;HOST&#39;); 
 
 
    SEND_email(&#39;DBA-GROUP@mycompany.com&#39;, 
                        v_subject, 
                        v_message); 
 
END; </code></pre>

<p>This simple trigger will fire each time someone logs into the database. To reduce the overhead of<br>this trigger being initiated during normal business hours, this trigger should be disabled during normal<br>business hours. It is possible to create a stored procedure that disables and enables the trigger and then<br>schedule that procedure to be executed at certain times. However, if there are only a few users who will<br>be logging into the database each day, then trigger controls such as these are not necessary. </p>
<p><strong>How It Works</strong><br>Triggers are a great way to audit system events on a database. There are several types of system triggers: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">• AFTER STARTUP 
• BEFORE SHUTDOWN 
• AFTER LOGON 
• BEFORE LOGOFF 
• AFTER SUSPEND 
• AFTER SERVERERROR 
• AFTER DB_ROLE_CHANGE </code></pre>
<p>Each of these system events can be correlated to a trigger when the trigger includes the ON DATABASE<br>clause, as shown here: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE system_trigger 
trigger_type ON DATABASE 
…   </code></pre>
<p>System triggers fire once for each correlating system event that occurs. Therefore, if there is a system<br>trigger defined for both the LOGON and LOGOFF events, each will be fired one time for every user who logs<br>onto or off the database. System triggers are excellent tools for helping audit database system events.<br>Notice that the different system events have access only to certain types of events. For instance, STARTUP<br>triggers can be fired only after the event occurs. This is because the Oracle Database is not available<br>before STARTUP, so it would be impossible to fire a trigger beforehand. Similarly, SHUTDOWN triggers have<br>access to the BEFORE event only because the database is unavailable after SHUTDOWN.<br>In the solution to this recipe, the trigger is intended to execute once after each login to the database.<br>The trigger will insert some values from the current session into an auditing table, and it will send an e-<br>mail to the DBA group. It should be noted that Oracle Database provides some auditing capabilities to<br>perform similar activities right out of the box. In fact, Oracle 11g turns on auditing by default for every<br>database. However, the auditing options that are available via Oracle do not allow for sending e-mail as<br>our solution does. You may prefer to use Oracle’s internal auditing features for storing the audit trail and<br>combine them with auditing triggers such as the one in this recipe for simply sending an e-mail when<br>the event occurs.<br>The SERVERERROR event is fired whenever an Oracle server error occurs. The SERVERERROR event can<br>be useful for detecting user SQL errors or logging system errors. However, there are a few cases in which<br>an Oracle server error does not trigger this event. Those Oracle errors are as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">• ORA-01403:  No data found 
• ORA-01422:  Exact fetch returns more than requested number of rows 
• ORA-01423:  Error encountered while checking for extra rows in exact fetch 
• ORA-01034:  ORACLE not available 
• ORA-04030:  Out of process memory when trying to allocate bytes </code></pre>
<p>System event triggers can assist a DBA in administration of the database. These triggers can also<br>help developers if SQL errors are triggering SERVERERROR events and notifying of possible SQL problems<br>in the application. </p>
<p>summary:  </p>
<ol>
<li>System triggers are excellent tools for helping audit database system events</li>
<li>the different system events have access only to certain types of events</li>
<li>SHUTDOWN triggers have access to the BEFORE event only because the database is unavailable after SHUTDOWN</li>
<li>oracle contains itself audit subsystem that us powerful</li>
</ol>
<h2 id="5-10-Triggering-on-a-Schema-Related-Event"><a href="#5-10-Triggering-on-a-Schema-Related-Event" class="headerlink" title="5-10. Triggering on a Schema-Related Event"></a>5-10. Triggering on a Schema-Related Event</h2><p><strong>Problem</strong><br>You want to trigger on an event related to a change in a database schema. For example, if someone drops<br>a database table on accident, it could cause much time and grief attempting to restore and recover data<br>to its original state. Rather than doing so, you want to place a control mechanism into the database that<br>will ensure that administrators cannot delete essential tables. </p>
<p><strong>Solution</strong><br>Use a PL&#x2F;SQL database trigger to raise an exception and send an alert to the DBA if someone attempts to<br>drop a table. This will prevent any tables from inadvertently being dropped, and it will also allow the<br>administrator to know whether someone is potentially trying to drop tables. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER ddl_trigger
BEFORE CREATE OR ALTER OR DROP 
ON SCHEMA 
DECLARE 
  evt              VARCHAR2(2000); 
  v_subject        VARCHAR2(100) :&#x3D; &#39;Drop table attempt&#39;; 
  v_message        VARCHAR2(1000);
BEGIN 
  SELECT ora_sysevent 
  INTO evt 
  FROM dual; 
  IF evt &#x3D; &#39;DROP&#39; THEN 
   RAISE_APPLICATION_ERROR(-20900, &#39;UNABLE TO DROP TABLE, &#39; || 
           &#39;EVENT HAS BEEN LOGGED&#39;); 
  END IF; 
  v_message :&#x3D; &#39;Table drop attempted by: &#39;||  
    SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USERID&#39;); 
  SEND_EMAIL(&#39;DBA-GROUP@mycompany.com&#39;, 
             v_subject, 
             v_message);
END;</code></pre>
<p>In this situation, both the user who attempts to drop the table and the members of the DBA-GROUP<br>mailing list will be notified. </p>
<p><strong>How It Works</strong><br>You can use triggers to log or prevent certain database activities from occurring. In this recipe, you saw<br>how to create a trigger that will prevent a table from being dropped. The trigger will be executed prior to<br>any CREATE, ALTER, or DROP within the current schema. Within the body of the trigger, the event is checked<br>to see whether it is a DROP, and actions are taken if so.<br>■ Note To be even more fine-grained, it is possible to specify a particular schema for the trigger to use.  Doing so<br>would look like the following: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEFORE CREATE ALTER OR DROP ON HR.SCHEMA 
… </code></pre>

<p>There are several other DDL trigger operations that can be used to help administer a database or<br>application. The following are these operations along with the type of trigger that can be used with it: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEFORE &#x2F; AFTER ALTER 
BEFORE &#x2F; AFTER ANALYZE 
BEFORE &#x2F; AFTER ASSOCIATE STATISTICS 
BEFORE &#x2F; AFTER AUDIT 
BEFORE &#x2F; AFTER COMMENT 
BEFORE &#x2F; AFTER CREATE 
BEFORE &#x2F; AFTER DDL 
BEFORE &#x2F; AFTER DISASSOCIATE STATISTICS 
BEFORE &#x2F; AFTER DROP 
BEFORE &#x2F; AFTER GRANT 
BEFORE &#x2F; AFTER NOAUDIT 
BEFORE &#x2F; AFTER RENAME 
BEFORE &#x2F; AFTER REVOKE 
BEFORE &#x2F; AFTER TRUNCATE 
AFTER SUSPEND </code></pre>

<p>All DDL triggers can be fired using either BEFORE or AFTER event types. In most cases, triggers that are<br>fired before a DDL event occurs are used to prevent the event from happening. On the other hand,<br>triggers that are fired after an event occurs usually log information or send an e-mail. In the solution to<br>this recipe, a combination of those two situations exists. The BEFORE event type was used because the<br>trigger is being used to prevent the tables from being dropped. However, logging or e-mailing can also<br>occur to advise interested parties of the event. Typically a logging event occurs with an AFTER trigger so<br>that the event has already occurred and the database is in a consistent state prior to the logging. </p>
<h2 id="5-11-Firing-Two-Triggers-on-the-Same-Event"><a href="#5-11-Firing-Two-Triggers-on-the-Same-Event" class="headerlink" title="5-11. Firing Two Triggers on the Same Event"></a>5-11. Firing Two Triggers on the Same Event</h2><p><strong>Problem</strong><br>There is a requirement to create a trigger to enter the SYSDATE into the HIRE_DATE column of the<br>LOCATIONS table. However, there is already a trigger in place that is fired BEFORE INSERT on the table, and<br>you do not want the two triggers to conflict. </p>
<p><strong>Solution</strong><br>Use the FOLLOWS clause to ensure the ordering of the execution of the triggers. The following example<br>shows the creation of two triggers that are to be executed BEFORE INSERT on the EMPLOYEES table.<br>First, we’ll create a trigger to verify that a new employee’s salary falls within range: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER verify_emp_salary 
BEFORE INSERT ON employees 
FOR EACH ROW 
DECLARE 
  v_min_sal     jobs.min_salary%TYPE; 
  v_max_sal     jobs.max_salary%TYPE; 
BEGIN 
  SELECT min_salary, max_salary 
  INTO v_min_sal, v_max_sal 
  FROM JOBS 
  WHERE JOB_ID &#x3D; :new.JOB_ID; 
 
  IF :new.salary &gt; v_max_sal THEN 
    RAISE_APPLICATION_ERROR(-20901, 
       &#39;You cannot give a salary greater than the max in this category&#39;); 
  ELSIF :new.salary &lt; v_min_sal THEN 
    RAISE_APPLICATION_ERROR(-20902, 
       &#39;You cannot give a salary less than the min in this category&#39;); 
  END IF; 
END; </code></pre>
<p>Next, you’ll create a trigger to force the hire date to be the current date: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE or REPLACE TRIGGER populate_hire_date 
BEFORE INSERT 
    ON employees 
    FOR EACH ROW 
FOLLOWS verify_emp_salary 
DECLARE 
BEGIN 
    :new.hire_date :&#x3D; sysdate; 
END; </code></pre>
<p>Since it does not make sense to change the hire date if the record will not be inserted, you want the<br>VERIFY_EMP_SALARY trigger to fire first. The FOLLOWS clause in the POPULATE_HIRE_DATE trigger ensures that<br>this will be the case. </p>
<p><strong>How It Works</strong><br>Oracle 11g introduced the <code>FOLLOWS</code> clause into the Oracle trigger that allows you to specify the ordering in<br>which triggers should execute. The FOLLOWS clause specifies the trigger that should fire prior to the trigger<br>being created. In other words, if you specify the FOLLOWS clause when creating a trigger, then you should<br>name a trigger that you want to have executed prior to your new trigger. Hence, if you specify a trigger in<br>the FOLLOWS clause that does not already exist, you will receive a compile error. </p>
<p>■ Note The <code>PRECEDES</code>(v.领先(precede的三单形式);在…之先) clause was introduced in Oracle 11g as well. You can use this clause to specify the<br>opposite situation that is resolved using the FOLLOWS clause. If you specify <code>PRECEDES</code> instead of <code>FOLLOWS</code>, then the<br>trigger being created will fire prior to the trigger that you specify after the <code>PRECEDES</code> clause.<br>By default, Oracle triggers fire in any arbitrary ordering. In the past, there was no way to guarantee<br>the order in which triggers were to be executed. The addition of the <code>FOLLOWS</code> clause now allows you to do<br>so. However, it is important that you do not make triggers dependent upon each other. Doing so could<br>cause issues of one of the triggers were to be dropped for some reason. It is bad design to create a trigger<br>that depends on the successful completion of another trigger, so the <code>FOLLOWS</code> clause should be used only<br>in situations where there is no dependency. </p>
<p>summary:  </p>
<ol>
<li>if you wanna make sure two triggers keep up order to be executed, please use follow clause</li>
<li>dependent triggers is bad design</li>
</ol>
<h2 id="5-12-Creating-a-Trigger-That-Fires-on-Multiple-Events"><a href="#5-12-Creating-a-Trigger-That-Fires-on-Multiple-Events" class="headerlink" title="5-12. Creating a Trigger That Fires on Multiple Events"></a>5-12. Creating a Trigger That Fires on Multiple Events</h2><p><strong>Problem</strong><br>You have logic that is very similar for two different events. Thus, you want to combine that logic into a<br>single trigger that fires for both. For example, let’s assume that we want to create a single trigger on the<br>EMPLOYEES table with code to fire after each row that is inserted or modified and also with code to fire at<br>the end of each of those statements’ executions. </p>
<p><strong>Solution</strong><br>Use a compound(adj.复合的;混合的) trigger to combine all the triggers into a single body of code. The trigger in this solution<br>will execute based upon various timing points. It will execute AFTER EACH ROW in the EMPLOYEES table has<br>been updated, as well as AFTER the entire update statement has been executed. The AFTER EACH ROW<br>section of the trigger will audit the inserts and updates made on the table, and the AFTER STATEMENT<br>section of the trigger will send notification to the DBA regarding audits that have occurred on the table.<br>The following code shows the creation of a compound trigger that comprises(vt.包含;由…组成) each of these two<br>triggers into one body of code: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER emp_table_auditing 
  FOR INSERT OR UPDATE ON employees 
    COMPOUND TRIGGER 
  -- Global variable section 
  table_upd_count       NUMBER :&#x3D; 0; 
  table_id_start        employees.employee_id%TYPE; 
 
  AFTER EACH ROW IS 
  BEGIN 
    SELECT MAX(employee_id) 
    INTO table_id_start 
    FROM employees; 
 
    IF INSERTING THEN 
      
      INSERT INTO update_access_log VALUES( 
        update_access_seq.nextval, 
        SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), 
        sysdate, 
        NULL, 
        :new.salary, 
        &#39;EMPLOYEES - INSERT&#39;, 
        &#39;SALARY&#39;); 
      table_upd_count :&#x3D; table_upd_count + 1; 
 
 
    ELSIF UPDATING THEN 
      IF :old.salary !&#x3D; :new.salary THEN 
        INSERT INTO update_access_log VALUES( 
          update_access_seq.nextval, 
          SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), 
          sysdate, 
          :old.salary, 
          :new.salary, 
          &#39;EMPLOYEES - UPDATE&#39;, 
          &#39;SALARY&#39;); 
        table_upd_count :&#x3D; table_upd_count + 1; 
      END IF; 
    END IF;    
 
  END AFTER EACH ROW; 
 
  AFTER STATEMENT IS 
    v_subject                     VARCHAR2(100) :&#x3D; &#39;Employee Table Update&#39;; 
    v_message                     VARCHAR2(2000); 
  BEGIN 
         
    v_message :&#x3D; &#39;There have been &#39; || table_upd_count || 
     &#39; changes made to the employee table starting with ID #&#39; || 
     table_id_start; 
 
    SEND_EMAIL(&#39;DBA-GROUP@my_company.com&#39;, 
               v_subject, 
               v_message); 
  END AFTER STATEMENT; 
 
END emp_table_auditing; 
</code></pre>
<p>The insert and update events are audited via the trigger that is coded using the AFTER EACH ROW<br>clause, and then the AFTER STATEMENT trigger sends a notification to alert the DBA of each audit. The two<br>triggers share a global variable that is declared prior to the code for the first trigger. </p>
<p><strong>How It Works</strong></p>
<p>Prior to Oracle 11g, there was no easy way to create multiple triggers that were able to share the same global<br>variable. The compound trigger was introduced with the release of Oracle 11g, and it allows multiple triggers for<br>the same table to be embodied within a single trigger. Compound triggers allow you to code different timing<br>points within the same trigger; those different events are as follows in logical execution order: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">• BEFORE STATEMENT 
• BEFORE EACH ROW 
• AFTER EACH ROW 
• AFTER STATEMENT </code></pre>
<p>Each of these timing points allows for the declaration of different trigger execution points. Using a<br>compound trigger allows you to create a trigger that performs some actions: BEFORE INSERT on a table<br>and AFTER INSERT on a table all within the same trigger body. In the case of the solution to this recipe, an<br>AFTER UPDATE trigger is coded within the same compound trigger as an AFTER STATEMENT trigger. The<br>logical order of execution allows you to code triggers that depend upon others using this technique. In<br>other recipes within this chapter, you have learned that it is not good programming practice to code<br>triggers that depend upon each other. This is mainly because if one trigger is invalidated or dropped,<br>then the other trigger that depends on it will automatically be invalidated. Since a compound trigger is<br>one body of code, either the entire trigger is valid or invalid. Therefore, the failure points between two<br>trigger bodies are removed.<br>In the solution, the AFTER STATEMENT trigger depends upon the AFTER EACH ROW trigger. If the AFTER<br>EACH ROW trigger does not audit anything, then the AFTER STATEMENT trigger will still fire, but it will send<br>an e-mail that signifies zero rows have been changed. The two trigger bodies are able to share access to<br>global variables, types, and cursors via the use of the global declaration section. Anything declared<br>within this section is visible to all triggers within the compound trigger body, so in the case of this<br>solution, you can use the first AFTER EACH ROW to update the value of the global variable, which is then in<br>turn used within the AFTER STATEMENT trigger. The overall compound trigger structure is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER trigger_name 
   FOR trigger_action ON table_name 
     COMPOUND TRIGGER 
    -- Global declaration section 
   global_variable VARCHAR2(10); 
  BEFORE STATEMENT IS 
  BEGIN 
     NULL; 
 -- Statements go here. 
  END BEFORE STATEMENT; 
  
  BEFORE EACH ROW IS 
  BEGIN 
    NULL; 
-- Statements go here.   
  END BEFORE EACH ROW; 
  
  AFTER EACH ROW IS  
  BEGIN 
     NULL; 
-- Statements go here. 
  END AFTER EACH ROW; 
  
  AFTER STATEMENT IS 
  BEGIN 
    NULL; 
 -- Statements go here. 
  END AFTER STATEMENT; 
  
  END trigger_name;  </code></pre>
<p>Compound triggers can be very useful for incorporating several different timed(different stage data change) events on the same<br>database table. Not only do they allow for easier maintenance because all code resides within one trigger<br>body, but they also allow for shared variables among the trigger events as well as more robust<br>dependency management. </p>
<h2 id="5-13-Creating-a-Trigger-in-a-Disabled-State"><a href="#5-13-Creating-a-Trigger-in-a-Disabled-State" class="headerlink" title="5-13. Creating a Trigger in a Disabled State"></a>5-13. Creating a Trigger in a Disabled State</h2><p><strong>Problem</strong><br>After a planning meeting, your company has decided that it would be a great idea to create a trigger to<br>send notification of updates to employee salaries. Since the trigger will be tied into the system-wide k<br>database application, you want to ensure that it compiles before enabling it so that it will not affect the<br>rest of the application.  </p>
<p><strong>Solution</strong><br>Create a trigger that is in a disabled state by default. This will afford you the opportunity to ensure that<br>the trigger has compiled successfully before you enable it. Use the new DISABLE clause to ensure that<br>your trigger is in DISABLED state by default.<br>The following trigger sends messages to employees when their salary is changed. The trigger is<br>disabled by default to ensure that the application is not adversely affected if there is a compilation error. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER send_salary_notice 
AFTER UPDATE OF SALARY ON employees 
FOR EACH ROW 
DISABLE 
DECLARE 
  v_subject     VARCHAR2(100) :&#x3D; &#39;Salary Update Has Occurrred&#39;; 
  v_message     VARCHAR2(2000); 
BEGIN 
  v_message :&#x3D; &#39;Your salary has been increased from &#39; || 
             :old.salary || &#39; to &#39; || :new.salary || &#39;.&#39;  || 
             &#39;If you have any questions or complaints, please &#39; || 
             &#39;do not contact the DBA.&#39;; 
 
  SEND_EMAIL(:new.email || &#39;@mycompany.com&#39;, 
             v_subject, 
             v_message); 
END;   </code></pre>
<p>On an annual basis, this trigger can be enabled via the following syntax: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">ALTER TRIGGER send_salary_notice ENABLE; </code></pre>

<p>It can then be disabled again using the same syntax: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">ALTER TRIGGER send_salary_notice DISABLE; </code></pre>

<p><strong>How It Works</strong><br>Another welcome new feature with Oracle 11g is the ability to create triggers that are DISABLED by default.<br>The syntax for creating a trigger in this fashion is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE TRIGGER trigger_name 
ON UPDATE OR INSERT OR DELETION OF table_name 
[FOR EACH ROW] 
DISABLED 
DECLARE 
  -- Declarations go here. 
BEGIN 
  -- Statements go here. 
END; </code></pre>
<p>The new DISABLED clause is used upon creation of a trigger. By default, a trigger is ENABLED by creation,<br>and this clause allows for the opposite to hold true. </p>
<h1 id="6-Type-Conversion"><a href="#6-Type-Conversion" class="headerlink" title="6.Type Conversion"></a>6.Type Conversion</h1><p>Type conversion takes place in almost every PL&#x2F;SQL program. It is important to know how to convert<br>from one datatype to another so that your applications can contain more versatility. Not only are<br>datatype conversions important to developers, but they can also be a godsend to database<br>administrators. Type conversion can occur when moving data around from one table to another. It is<br>also very common when obtaining data from input forms and performing calculations upon it.<br>Whatever your use may be, this chapter will get you headed into the right direction with a handful of<br>useful recipes. If your application works with dates or numbers, you will most likely find this chapter<br>useful. There are two forms of datatype conversion: explicit conversion and implicit conversion. Explicit<br>datatype conversion is what you will learn about in the following recipes. Using explicit conversion, you<br>tell Oracle how you want types to be converted. Implicit conversion is automatically performed by<br>Oracle. There are many datatypes that can be converted using implicit type conversion. However, it is<br>not recommended that you rely on implicit conversion, because you never know exactly how Oracle will<br>convert something. The recipes in this chapter will show you more reliable explicit conversion<br>techniques that will give you the ability to convert types in such a way that your application will be rock<br>solid. </p>
<h2 id="6-1-Converting-a-String-to-a-Number"><a href="#6-1-Converting-a-String-to-a-Number" class="headerlink" title="6-1. Converting a String to a Number"></a>6-1. Converting a String to a Number</h2><p>Problem<br>You need to convert some strings into numbers. For instance, your application contains several strings<br>that are entered via a user input screen. These strings need to be converted into numbers so that they<br>can be used to perform calculations.<br>Solution<br>Use the TO_NUMBER function to explicitly convert the VARCHAR2 field into a NUMBER. The following examples<br>demonstrate the use of TO_NUMBER by showing how to convert some currency values taken from the user<br>interface into numbers for storage in the database.<br>The first example demonstrates the conversion of a variable with a datatype of VARCHAR2 into a<br>NUMBER: </p>
<p>DECLARE<br>  in_dollars              VARCHAR2(10) :&#x3D; &amp;dollars;<br>  dollars_formatted  NUMBER;<br>BEGIN<br>  – Assume that IN_DOLLARS is the user input in VARCHAR2 format<br>  dollars_formatted :&#x3D; TO_NUMBER(in_dollars, ‘9G999D99’);<br>  DBMS_OUTPUT.PUT_LINE(dollars_formatted);<br>CHAPTER 6  TYPE CONVERSION<br>120<br>END;<br>The TO_NUMBER function returns a number from a VARCHAR2 format. The previous example<br>demonstrates the typical usage of this function.<br>How It Works<br>The TO_NUMBER function provides an explicit way to convert strings into NUMBER format in PL&#x2F;SQL.<br>Although most string to NUMBER conversion is implicit via Oracle Database, it is always a best practice to<br>explicitly use the TO_NUMBER function to ensure that your code will not break at some point in the future.<br>The format for using the function is as follows:<br>TO_NUMBER(expression [, format [, ‘nls’ ] ])<br>The expression can be a value of type BINARY_DOUBLE, CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The<br>optional format is a mask that can be used to help format the expression value into a number. The mask<br>is a string of characters that represents the format of the string value that is contained in the expression<br>value. Table 6-1 shows the most commonly used format mask characters:<br>Table 6-1. Common Formatting Mask Characters<br>Character Description<br>9 Represents a numeric character<br>DRepresents a decimal point<br>GRepresents a comma<br>Although the use of a formatting mask is optional, it is a good idea to include it if you know the<br>format of the string. Doing so will help Oracle convert your value into a number more accurately. Lastly,<br>you can use the optional nls settings to set the NLS_LANGUAGE that is to be used to convert the string, the<br>NLS_CURRENCY, or any of the other NLS session parameters. Use of the nls parameter is not very common.<br>■ Note For a complete listing of available session NLS parameters, issue the following query: SELECT * FROM<br>NLS_SESSION_PARAMETERS.<br>It is also possible to convert strings into numbers using the CAST function. However, for direct string<br>to number conversion, the TO_NUMBER function is the best tool for the job since it is straightforward and<br>easy to maintain. For more information on the CAST function, please take a look at Recipe 6-5.<br>  CHAPTER 6  TYPE CONVERSION<br>121<br>6-2. Converting a String to a Date<br>Problem<br>You need to convert some strings into DATE types. Let’s say you have a requirement to insert date types<br>into a database table column from one of your applications. The user is allowed to enter a date using<br>your application’s web page, but it is in a string format after the user submits the page. You need to<br>convert this date from a string to a date type.<br>Solution<br>Use the TO_DATE function to convert the string values into the DATE type. This will allow your application<br>to accept the date string in any format and convert it to a DATE type for you. The next example shows how<br>to use the TO_DATE function: </p>
<p>my_val      DATE :&#x3D; TO_DATE(‘06&#x2F;12&#x2F;2010’,’MM&#x2F;DD&#x2F;YYYY’); </p>
<p>You can convert the string through assignment, as shown in the preceding example, or directly<br>within a query, as shown in the next example: </p>
<p>SELECT TO_DATE(‘December 31, 2010’, ‘Month DD, YYYY’) FROM DUAL; </p>
<p>As you can see, it is possible to convert multiple string formats into DATE types.<br>How It Works<br>The TO_DATE function is arguably the most widely used conversion function in Oracle. Whether you are<br>using the function to convert dates for proper formatting within a SQL query or you are accepting and<br>converting user input, this function is extremely helpful for getting your data into the Oracle DATE<br>format. The syntax for using this function is as follows: </p>
<p>TO_DATE(expression[, format[,’nls’]]) </p>
<p>The syntax is much like that of the other Oracle conversion functions in that it accepts a required<br>expression or string and two optional parameters. The optional format is used to specify the format of<br>the string and to assist Oracle in converting the value into a DATE type. Table 6-2 shows many of the more<br>common characters that can be used to specify the date format. See the Oracle SQL Reference for a<br>complete list of formatting characters.<br>Table 6-2. Date Formatting Characters<br>Character Description<br>MM Represents the numeric month.<br>MON Represents an abbreviated month name.<br>MONTH Represents the entire month name.<br>CHAPTER 6  TYPE CONVERSION<br>122<br>Character Description<br>DD Represents the numeric day of the month.<br>DY Abbreviation representing the day of the week.<br>YY Represents the two-digit year.<br>YYYY Represents the four-digit year.<br>RR Represents the rounded two-digit year. The year is rounded in the range 1950 to 2049 to<br>assist with two-digit years such as 10. A two-digit year less than 50 will result in a four-<br>digit year such as 2010.<br>AM or PM  Represents the meridian indicator.<br>HH Represents the hour of the day in 12-hour time format.<br>HH24 Represents the hour of the day in 24-hour time format.<br>MI Represents the minutes in time.<br>SS Represents the seconds in time. </p>
<p>The standard, or default, date format in Oracle is DD-MON-YY, though your database administrator<br>does have the ability to change that default format. If you want to convert a string that is in the default<br>format into a DATE type, then the mask is not required. The following example demonstrates this<br>capability: </p>
<p>TO_DATE(‘27-MAY-10’); </p>
<p>On the contrary, if you want to convert a string that is in a format that is different from the standard,<br>then you must make use of a mask. The solution to this recipe depicts this type of behavior. Dates are<br>also in care of time in Oracle, so if you want to display the time in your date, then it is possible to do so<br>using the proper format mask. The following conversion will include both the date and the time: </p>
<p> TO_DATE(‘05&#x2F;25&#x2F;2010 07:35AM’,’MM&#x2F;DD&#x2F;YYYY HH:MIAM’) </p>
<p>The TO_DATE conversion function is most often used when inserting or updating data. If you have a<br>table column that has a DATE type, then you cannot place a string into that column unless it is in the<br>standard date format. To get the data from an entry screen into the database, the TO_DATE function is<br>usually used to convert the string into a date while the value is being inserted or updated.<br>It is also possible to convert strings to dates using the CAST function. For more information on the<br>use of the CAST function, please see Recipe 6-5.<br>  CHAPTER 6  TYPE CONVERSION<br>123<br>6-3. Converting a Number to a String<br>Problem<br>You need to alter some numbers into a currency format for display. Given a set of numbers, your<br>application will perform a calculation and then convert the outcome into currency format, which will be<br>a string type.<br>Solution<br>Use the TO_CHAR conversion function to obtain a nicely formatted currency string. The following code<br>block accepts a number, performs a calculation, and then converts the number to a string: </p>
<p>CREATE OR REPLACE FUNCTION CALCULATE_BILL(bill_amount IN NUMBER)<br> RETURN VARCHAR2 AS<br>  tax                     NUMBER  :&#x3D; .12;<br>  tip                     NUMBER  :&#x3D; .2;<br>  total_bill              NUMBER  :&#x3D; 0;<br>BEGIN<br>  total_bill :&#x3D; bill_amount + (bill_amount * tax);<br>  total_bill :&#x3D; total_bill + (total_bill * tip);<br>  return to_char(total_bill, ‘$999.00’);<br>END; </p>
<p>When a bill amount is passed to the CALCULATE_BILL function, a nicely formatted dollar amount will<br>be returned. If you were to pass 24.75 to the function, it would return $33.26.<br>How It Works<br>The TO_CHAR function works much like the other Oracle TO_ conversion functions in that it accepts a<br>number value along with an optional format mask and nls language value. Table 6-3 describes the more<br>commonly used formatting mask characters for numbers.<br>Table 6-3. Common Formatting Mask Characters<br>Character Description<br>9 Represents a numeric character that displays only if a value is present<br>. Represents a decimal point<br>, Represents a comma<br>$ Represents a dollar sign<br>0 Represents a numeric character that will always display, even if null </p>
<p>As you can see from the solution to this recipe, the format mask of $999.00 is chosen. Why not use<br>the mask of $999.99 for the conversion? By using the 0 instead of the 9, you ensure that the cents value<br>CHAPTER 6  TYPE CONVERSION<br>124<br>will always be present. Even if the cents value is zero, you will still get a .00 at the end of your string.<br>Essentially, the 0 character forces Oracle to pad with zeros rather than spaces.<br>You can also pad with zero characters to the left of the decimal. Here’s an example: </p>
<p>select to_char(82,’0000099’) from dual; </p>
<p>That results in the following: </p>
<p>0000082 </p>
<p>It is also possible to convert numbers to strings using the CAST function, although TO_CHAR makes for<br>code that is easier to read and maintain. For more information on the use of the CAST function, please<br>see recipe 6-5.<br>6-4. Converting a Date to a String<br>Problem<br>You want to convert a date into a nicely formatted string value. For example, you are converting a legacy<br>application from another database vendor into a web-based Oracle application. A few of the fields on the<br>web form are dates. The users of the application expect to see the dates in a specific format, so you need<br>the dates to be formatted in a particular manner for display.<br>Solution<br>Use the TO_CHAR function using the date masks. The TO_CHAR function offers many formatting options for<br>returning a string from a DATE value. The following function accepts an EMPLOYEE_ID value and returns a<br>representation of the HIRE_DATE spelled out. </p>
<p>CREATE OR REPLACE PROCEDURE obtain_emp_hire_date(emp_id IN NUMBER)<br> AS<br> emp_hire_date    employees.hire_date%TYPE;<br> emp_first        employees.first_name%TYPE;<br> emp_last         employees.last_name%TYPE;<br>BEGIN<br>  SELECT hire_date, first_name, last_name<br>  INTO emp_hire_date, emp_first, emp_last<br>  FROM employees<br>  WHERE employee_id &#x3D; emp_id; </p>
<p>  DBMS_OUTPUT.PUT_LINE(emp_first || ‘ ‘ || emp_last ||<br>        ‘ was hired on: ‘ ||<br>        TO_CHAR(emp_hire_date, ‘DAY MONTH DDTH YYYY’));<br>EXCEPTION<br>  WHEN NO_DATA_FOUND THEN<br>    DBMS_OUTPUT.PUT_LINE(‘No employee found for the given ID’);<br>END; </p>
<p>If you pass the employee ID of 200 to this function, then it will return a result in the following<br>format:<br>  CHAPTER 6  TYPE CONVERSION<br>125<br>Jennifer Whalen was hired on: THURSDAY   SEPTEMBER 17TH 1987 </p>
<p>PL&#x2F;SQL procedure successfully completed.<br>How It Works<br>As shown in the previous recipe, the TO_CHAR function accepts a NUMBER or DATE value and returns a nicely<br>formatted string. Using the many formatting masks that are available, you can return a string-based<br>representation in a number of ways. As demonstrated in the solutions to this recipe and the previous<br>one, the TO_CHAR function works a bit differently than the other conversion functions because the<br>formatting mask is used to help produce the final string. Other conversion functions use the formatting<br>mask to represent the format of the string you are passing in. In other words, TO_CHAR produces the<br>formatted strings, whereas the other conversion functions accept them and produce a different<br>datatype.<br>Table 6-4 lists some of the most commonly used characters for converting dates into strings.<br>Table 6-4. Date Formatting Mask Characters<br>Characters Description<br>YYYY Represents the four-digit year<br>YEAR Represents the spelled-out year<br>YYY Represents the last three digits of the year<br>YY Represents the last two digits of the year<br>Y Represents the last digit of the year<br>IYY Represents the last three digits of the ISO year<br>IY Represents the last two digits of the ISO year<br>I Represents the last digit of the ISO year<br>Q Represents the quarter of the year<br>MM Represents the month of the year<br>MON Represents the abbreviated month name<br>MONTH Represents the spelled-out month name padded with blanks<br>RM Represents the Roman numeral month<br>WW Represents the week of the year<br>CHAPTER 6  TYPE CONVERSION<br>126<br>Characters Description<br>W Represents the week of the month<br>IW Represents the ISO week of the year<br>D Represents the day of the week<br>DAY Represents the name of the day<br>DD Represents the day of the month<br>DDD Represents the day of the year<br>DY Represents the abbreviated name of the day<br>J Represents the Julian day<br>HH Represents the hour of the day (1–12)<br>HH12 Represents the hour of the day (1–12); same as HH<br>HH24 Represents the hour of the day (0–23)<br>MI Represents the minute of the hour (0–59)<br>SS Represents the second (0–59)<br>SSSSS Represents the seconds past midnight (0–86399)<br>FF Represents the fractional seconds </p>
<p>There are several formatting options, as you can see. It is best to spend some time with each of the<br>different combinations to decide upon which one works best for your solution.<br>PL&#x2F;SQL can make date formatting easy, because it is possible to create your own function that<br>returns a date formatted per your application’s requirements. Sometimes it is difficult to remember all<br>the different formatting options that are available for dates. It can also be quite painful to reference a<br>table such as Table 6-4 each time you want to format a date string. You can instead create your own<br>conversion function to support just the formats that you use, and no others. Such a function greatly<br>reduces the possibility for error, thus enhancing consistency in how your application formats dates.<br>The function in the following example accepts two parameters: the date to be converted and a string<br>that specifies the output format. The second argument is limited to only four, easy-to-remember values:<br>LONG, SHORT, STD, and DASH. </p>
<p>– Returns a date string formatted per the style<br>– that is passed into it.  The possible style strings<br>– are as follows:<br>  CHAPTER 6  TYPE CONVERSION<br>127<br>–   LONG &#x3D;&gt; The spelled out date<br>–   SHORT &#x3D;&gt; The abbreviated date<br>–   STD or blank &#x3D;&gt; The standard date format mm&#x2F;dd&#x2F;yyyy<br>–   DASH &#x3D;&gt; The standard format with dashes mm-dd-yyyy<br>CREATE OR REPLACE FUNCTION FORMAT_DATE(in_date IN DATE,<br>                                       style IN VARCHAR2)<br> RETURN VARCHAR2 AS<br> formatted_date    VARCHAR2(100);<br>BEGIN<br>  CASE style<br>    WHEN ‘LONG’ THEN<br>        formatted_date :&#x3D; TO_CHAR(in_date, ‘DAY MONTH DDTH YYYY’);<br>    WHEN ‘SHORT’ THEN<br>        formatted_date :&#x3D; TO_CHAR(in_date, ‘DY MON DDTH YYYY’);<br>    WHEN ‘DASH’ THEN<br>        formatted_date :&#x3D; TO_CHAR(in_date, ‘MM-DD-YYYY’);<br>    ELSE<br>        formatted_date :&#x3D; TO_CHAR(in_date, ‘MM&#x2F;DD&#x2F;YYYY’);<br>  END CASE;<br>  RETURN formatted_date;<br>END; </p>
<p>This function is nice because you only need to remember a short string that is used to represent the<br>date format that you’d like to return.<br>It is also possible to convert dates to strings using the CAST function. For more information on the<br>use of the CAST function, please see Recipe 6-5.<br>6-5. Converting Strings to Timestamps<br>Problem<br>You are working with a series of strings. You want to convert them into timestamps.<br>Solution<br>Use the TO_TIMESTAMP function to convert the strings into timestamps. In this example, a trigger is<br>created that will log an INSERT into the JOBS table. The logging table consists of two columns. The first<br>column is used to store the date of the transaction, and it is of type TIMESTAMP WITH LOCAL TIME ZONE.<br>The second column is used to contain a DESCRIPTION of type VARCHAR2. The trigger that performs the<br>logging needs to combine a sysdate and a time zone value into a string prior to converting it into a<br>TIMESTAMP.<br>First, let’s create the table that will be used to log the changes on the JOBS table: </p>
<p>CREATE TABLE time_log<br>(job_time              TIMESTAMP WITH LOCAL TIME ZONE,<br> description           VARCHAR2(2000)); </p>
<p>Next, a simple function is created that will return the time zone for a given city code. The function<br>will return time zones for Chicago, Orlando, or San Jose because these are the different cities where our<br>imaginary industry has offices.<br>CHAPTER 6  TYPE CONVERSION<br>128<br>CREATE OR REPLACE FUNCTION find_tz (city IN VARCHAR2)<br>RETURN NUMBER IS<br>  tz          NUMBER :&#x3D; 0;<br>BEGIN<br>  IF city &#x3D; ‘CHI’ THEN<br>    tz :&#x3D; -5;<br>  ELSIF city &#x3D; ‘ORD’ THEN<br>    tz :&#x3D; -4;<br>  ELSIF city &#x3D; ‘SJ’ THEN<br>    tz :&#x3D; -7;<br>  END IF;<br>  RETURN tz;<br>END; </p>
<p>The last piece of code is the trigger that performs the INSERT on the logging table. This trigger<br>performs a conversion of a string to a TIMESTAMP using the TO_TIMESTAMP_TZ function. </p>
<p>CREATE OR REPLACE TRIGGER log_job_history<br>AFTER INSERT ON jobs<br>FOR EACH ROW<br>DECLARE<br>  my_ts  VARCHAR2(25) :&#x3D; to_char(sysdate, ‘YYYY-MM-DD HH:MI:SS’);<br>BEGIN<br>  my_ts :&#x3D; my_ts || ‘ ‘ || find_tz(‘CHI’); </p>
<p>  INSERT INTO time_log values(<br>    TO_TIMESTAMP_TZ(my_ts, ‘YYYY-MM-DD HH:MI:SS TZH:TZM’),<br>    ‘INSERT’<br>  ); </p>
<p>END; </p>
<p>In this example, the trigger is hard-coded to assume a Chicago entry, but in reality this information<br>would have been obtained from the user’s session. However, since that code is out of scope for this<br>recipe, the hard-coded city does the trick.<br>How It Works<br>Similar to other Oracle conversion functions, the TO_TIMESTAMP_TZ and TO_TIMESTAMP functions accept<br>two arguments. The first argument is a string value containing a date value in text form. The second<br>argument is a format model that is used to coerce the given string value into the TIMESTAMP or TIMESTAMP<br>WITH LOCAL TIME ZONE datatype. The TO_TIMESTAMP_TZ conversion will accept and convert a time zone<br>along with the TIMESTAMP, whereas the TO_TIMESTAMP function will not account for a time zone.<br>The format model is very similar to that of the TO_CHAR and TO_DATE functions. The format model will<br>differ depending upon the format of the date that you want to convert. In the solution to this recipe, the<br>format included a standard Oracle date along with a time zone. For a complete listing of all possible<br>format model characters, please refer to the Oracle SQL Reference manual.<br>  CHAPTER 6  TYPE CONVERSION<br>129<br>6-6. Writing ANSI-Compliant Conversions<br>Problem<br>You want to convert strings to dates using an ANSI-compliant methodology.<br>Solution<br>Use the CAST function, because it is ANSI-compliant. In this example, a procedure is written that will<br>select each of the rows within the JOB_HISTORY table that fall within a specified date range. The dates will<br>be converted into strings, and other information will be appended to the converted dates. This<br>procedure will produce a simple report to display the JOB_HISTORY. </p>
<p>CREATE OR REPLACE PROCEDURE job_history_rpt(in_start_date IN DATE,<br>                                            in_end_date IN DATE) AS<br>  CURSOR job_history_cur IS<br>  SELECT CAST(hist.start_date AS VARCHAR2(12)) || ‘ - ‘ ||<br>         CAST(hist.end_date AS VARCHAR2(12)) || ‘: ‘ ||<br>         emp.first_name || ‘ ‘ || emp.last_name || ‘ - ‘ ||<br>         job_title || ‘ ‘ || department_name as details<br>  FROM jobs jobs,<br>       job_history hist,<br>       employees emp,<br>       departments dept<br>  WHERE hist.start_date &gt;&#x3D; in_start_date<br>  AND hist.end_date &lt;&#x3D; in_end_date<br>  AND jobs.job_id &#x3D; hist.job_id<br>  AND emp.employee_id &#x3D; hist.employee_id<br>  AND dept.department_id &#x3D; hist.department_id; </p>
<p>  job_history_rec     job_history_cur%ROWTYPE; </p>
<p>BEGIN<br>  DBMS_OUTPUT.PUT_LINE(‘JOB HISTORY REPORT FOR ‘ ||<br>    in_start_date || ‘ to ‘ || in_end_date);<br>  FOR job_history_rec IN job_history_cur LOOP<br>    DBMS_OUTPUT.PUT_LINE(job_history_rec.details);<br>  END LOOP;<br>END; </p>
<p>Given the start date of September 1, 1989, the resulting output from this procedure will resemble the<br>following: </p>
<p>SQL&gt; exec job_history_rpt(to_date(‘01-SEP-1989’,’DD-MON-YYYY’),sysdate);<br>JOB HISTORY REPORT FOR 01-SEP-89 to 01-SEP-10<br>13-JAN-93 - 24-JUL-98: Lex De Haan - Programmer IT<br>21-SEP-89 - 27-OCT-93: Neena Kochhar - Public Accountant Accounting<br>28-OCT-93 - 15-MAR-97: Neena Kochhar - Accounting Manager Accounting<br>17-FEB-96 - 19-DEC-99: Michael Hartstein - Marketing Representative Marketing<br>CHAPTER 6  TYPE CONVERSION<br>130<br>24-MAR-98 - 31-DEC-98: Jonathon Taylor - Sales Representative Sales<br>01-JAN-99 - 31-DEC-99: Jonathon Taylor - Sales Manager Sales<br>01-JUL-94 - 31-DEC-98: Jennifer Whalen - Public Accountant Executive<br>PL&#x2F;SQL procedure successfully completed.<br>How It Works<br>The CAST function can be used to easily convert datatypes. However, there is no real benefit to using CAST<br>as opposed to TO_NUMBER or TO_CHAR in most cases. The format for the CAST function is as follows:<br>CAST(expression AS type_name)<br>You can use this function to convert between different datatypes. Table 6-5 lists the different to and<br>from datatypes that the CAST function can handle.<br>Table 6-5. CAST Function Converstion Table<br>CAST from Datatype To Datatype<br>CHAR, VARCHAR2 CHAR, VARCHAR2<br>NUMBER<br>DATETIME&#x2F;INTERVAL<br>RAW<br>ROWID, UROWID<br>NUMBER CHAR, VARCHAR2<br>NUMBER<br>NCHAR, NVARCHAR2<br>DATETIME&#x2F;INTERVAL CHAR, VARCHAR2<br>DATETIME&#x2F;INTERVAL<br>NCHAR, NVARCHAR2<br>RAW CHAR, VARCHAR2<br>RAW<br>NCHAR, NVARCHAR2<br>ROWID, UROWID CHAR, VARCHAR2<br>ROWID, UROWID<br>NCHAR, NVARCHAR2<br>NCHAR, NVARCHAR2 NCHAR, NVARCHAR2<br>The CAST function offers advantages to the TO_ conversion functions in some cases. For instance, if<br>you are attempting to write SQL that is 100 percent ANSI-compliant, then you should use the CAST<br>function because the Oracle conversion functions are not compliant. However, PL&#x2F;SQL itself is not<br>ANSI-compliant, so the CAST function offers no advantages while writing PL&#x2F;SQL code.<br>The following are a few more examples of using the CAST function:<br>  CHAPTER 6  TYPE CONVERSION<br>131 </p>
<p>– Convert date to VARCHAR2<br>SELECT CAST(‘05-MAY-2010’ AS VARCHAR2(15)) FROM DUAL; </p>
<p>– Convert string to NUMBER<br>SELECT CAST(‘1024’ AS NUMBER) FROM DUAL; </p>
<p>– Convert string to ROWID<br>SELECT CAST(‘AAYyVSADsAAAAFLAAA’ AS ROWID) FROM DUAL; </p>
<p>If you prefer to have more control over your conversions, the Oracle TO_ conversion functions are<br>the way to go. They allow you to provide a format mask to control the conversion formatting.<br>6-7. Implicitly Converting Between PLS_INTEGER and NUMBER<br>Problem<br>You want to convert a number to PLS_INTEGER datatype so that calculations can be performed.<br>Solution<br>In this case, allow Oracle to do the footwork and implicitly convert between the two datatypes. In the<br>following example, the function accepts a NUMBER, converts it to PLS_INTEGER, and performs a calculation<br>returning the result. The function converts to PLS_INTEGER in order to gain a performance boost. </p>
<p>CREATE OR REPLACE FUNCTION mass_energy_calc (mass IN NUMBER,<br>                                             energy IN NUMBER)<br>RETURN PLS_INTEGER IS<br>  new_mass    PLS_INTEGER :&#x3D; mass;<br>  new_energy  PLS_INTEGER :&#x3D; energy;<br>BEGIN<br>  RETURN ((new_mass * new_energy) * (new_mass * new_energy));<br>EXCEPTION<br>  WHEN OTHERS THEN<br>    RETURN -1;<br>END; </p>
<p>The function will accept NUMBER values, automatically convert them into PLS_INTEGER, and return a<br>PLS_INTEGER type.<br>How It Works<br>Implicit conversion occurs when Oracle automatically converts from one datatype to another. Oracle<br>will implicitly convert some datatypes but not others. As per the solution to this recipe, one of the<br>datatypes that supports implicit conversion is PLS_INTEGER. As a matter of fact, PLS_INTEGER cannot be<br>converted using the TO_NUMBER function; so in this case, implicit is the best way to convert a PLS_INTEGER<br>datatype to anything else. However, if there is a way to explicitly convert the datatype from one to<br>another, then that is the recommended approach. You cannot be certain of the results when Oracle is<br>automatically converting for you; explicit conversion allows you to have more control.<br>CHAPTER 6  TYPE CONVERSION<br>132<br>The PLS_INTEGER datatype can be advantageous over using a NUMBER in some cases. For instance, a<br>PLS_INTEGER has performance advantages when compared to a NUMBER for doing calculations because<br>they use machine arithmetic as opposed to library arithmetic. Additionally, the PLS_INTEGER datatype<br>requires less storage than its counterparts. In the solution to this recipe, the function takes advantage of<br>the faster calculation speed that is possible using PLS_INTEGER.<br>C H A P T E R  7 </p>
<p>   </p>
<p>133<br>Numbers, Strings, and Dates<br>Every PL&#x2F;SQL program uses one or more datatypes. This chapter focuses on some details that you<br>should know when working with data in the form of numbers, strings, and dates. Each recipe in this<br>chapter provides a basic tip for working with these datatypes. From basic string concatenation to more<br>advanced regular expression processing, you’ll learn some techniques for getting things done in an<br>effective manner. You’ll learn about date calculations as well. When you’re done with this chapter, you’ll<br>be ready to move on to the more advanced recipes later in the chapters to follow.<br>7-1. Concatenating Strings<br>Problem<br>You have two or more text strings, or variables containing strings, that you want to combine.<br>Solution<br>Use the concatenation operator to append the strings. In the following example, you can see that two<br>variables are concatenated to a string of text to form a single string of text: </p>
<p>DECLARE<br>  CURSOR emp_cur IS<br>  SELECT employee_id, first_name, last_name<br>  FROM EMPLOYEES<br>  WHERE HIRE_DATE &gt; TO_DATE(‘01&#x2F;01&#x2F;2000’,’MM&#x2F;DD&#x2F;YYYY’); </p>
<p>  emp_rec       emp_cur%ROWTYPE;<br>  emp_string    VARCHAR2(150);<br>BEGIN<br>  DBMS_OUTPUT.PUT_LINE(‘EMPLOYEES HIRED AFTER 01&#x2F;01&#x2F;2000’);<br>  DBMS_OUTPUT.PUT_LINE(‘&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;’);<br>  FOR emp_rec IN emp_cur LOOP<br>        emp_string :&#x3D; emp_rec.first_name || ‘ ‘ ||<br>                      emp_rec.last_name || ‘ - ‘ ||<br>                      ‘ID #: ‘ || emp_rec.employee_id; </p>
<pre><code>    DBMS_OUTPUT.PUT_LINE(emp_string); 
</code></pre>
<p>  END LOOP;<br>END; </p>
<p>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>134<br>You can see that the example uses the concatenation operator || to formulate a string of text that<br>contains each employee’s first name, last name, and employee ID number.<br>How It Works<br>As you have seen in the solution to this recipe, the concatenation operator is used for concatenating<br>strings within your PL&#x2F;SQL applications. When the concatenation operator is used to concatenate<br>numbers with strings, the numbers are automatically converted into strings and then concatenated.<br>Similarly, an automatic conversion occurs with dates before being concatenated.<br>7-2. Adding Some Number of Days to a Date<br>Problem<br>You want to add a number of days to a given date. For example, you are developing an application that<br>calculates shipping dates for a company’s products. In this case, your application is processing<br>shipments, and you need to calculate a date that is 14 days from the current date.<br>Solution<br>Treat the number of days as an integer, and add that integer to your DATE value. The following lines of<br>code show how this can be done: </p>
<p>DECLARE<br>  ship_date    DATE :&#x3D; SYSDATE + 14;<br>BEGIN<br>  DBMS_OUTPUT.PUT_LINE(‘The shipping date for any products ‘||<br>                       ‘that are ordered today is ‘ || ship_date);<br>END; </p>
<p>The result that is displayed for this example will be 14 days past your current date.<br>If you wanted to encapsulate this logic within a function, then it would be easy to do. The following<br>function takes a date and a number as arguments. The function will perform simple mathematics and<br>return the result. </p>
<p>CREATE OR REPLACE FUNCTION calculate_days(date_to_change  IN DATE,<br>                                          number_of_days  IN NUMBER)<br>RETURN DATE IS<br>BEGIN<br>  RETURN date_to_change + number_of_days;<br>END; </p>
<p>Notice that the name of the function does not include the word add, such as ADD_DAYS. That was<br>done on purpose because this function not only allows addition of days to a date, but if a negative<br>number is passed in as an argument, then it will also subtract the number of days from the given date.<br>How It Works<br>Since calculations such as these are the most common date calculations performed, Oracle makes them<br>easy to do. If a number is added to or subtracted from a DATE value, Oracle Database will add or subtract<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>135<br>that number of days from the date value. DATE types can have numbers added to them, and they can also<br>have numbers subtracted from them. Multiplication and division do not work because it is not possible<br>to perform such a calculation on a date. For example, it doesn’t mean anything to speak of multiplying a<br>date by some value.<br>If you are developing an application that always performs an addition or subtraction using the same<br>number of days, it may be helpful to create a function such as the one demonstrated in the solution to<br>this recipe. For instance, if you were developing a billing application and always required a date that was<br>30 days into the future of the current date, then you could create a function named BILLING_DATE and<br>hard-code the 30 days into it. This is not necessary, but if your business or application depended upon it,<br>then it may be a good idea to encapsulate logic to alleviate possible data entry errors.<br>7-3. Adding a Number of Months to a Date<br>Problem<br>You want to add some number of months to a date. For example, you are developing a payment<br>application for a company, and it requires payments every six months. You need to enable the<br>application to calculate the date six months in the future of the current date.<br>■ Note This recipe’s solution also works for subtracting months. Simply “add” a negative number of months.<br>Solution<br>Use the ADD_MONTHS function to add six months onto the given date.  Doing so will enable your<br>application to create bills for future payments.  This technique is demonstrated in the following<br>example: </p>
<p>DECLARE<br>  new_date    DATE;<br>BEGIN<br>  new_date :&#x3D; ADD_MONTHS(sysdate,6);<br>  DBMS_OUTPUT.PUT_LINE(‘The newly calculated date is: ‘ || new_date);<br>END; </p>
<p>This simple technique will enable you to add a number of months to any given date. As with any<br>other logic, this could easily be encapsulated into a function for the specific purpose of producing a<br>billing date that was six months into the future of the current date. Such a function may look something<br>like the next example: </p>
<p>CREATE OR REPLACE FUNCTION calc_billing_date IS<br>BEGIN<br>  RETURN ADD_MONTHS(sysdate, 6);<br>END; </p>
<p>Although this function does not do much besides encapsulate logic, it is a good idea to code such<br>functions when developing a larger application where this type of calculation may be performed several<br>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>136<br>times. It will help to maintain consistency and alleviate maintenance issues if the date calculation ever<br>needs to change. You could simply make the change within the function rather than visiting all the<br>locations in the code that use the function.<br>How It Works<br>Oracle provides the ADD_MONTHS function to assist with date calculations. This function has two<br>purposes—to add or subtract a specified number of months from the given date. The syntax for use of<br>the ADD_MONTHS function is as follows: </p>
<p>ADD_MONTHS(date, integer) </p>
<p>You can also use the function to subtract months from the given date. If the function is passed a<br>negative integer in place of the month’s argument, then that number of months will be subtracted from<br>the date. The following example demonstrates this functionality: </p>
<p>DECLARE<br>  new_date    DATE;<br>BEGIN<br>  new_date :&#x3D; ADD_MONTHS(sysdate,-2);<br>  DBMS_OUTPUT.PUT_LINE(‘The newly calculated date is: ‘ || new_date);<br>END; </p>
<p>As you can see from the example in Figure 7-3, the negative integer is the only change made to the<br>code in order to achieve a subtraction of months rather than an addition. As a result, the example in this<br>figure will return the current date minus two months.<br>In the case that you are attempting to add months to a date that represents the last day of the<br>month, the ADD_MONTHS function works a bit differently than you might expect. For instance, if it is August<br>31 and you want to add one month, then you would expect the calculation to resolve to September 31,<br>which is not possible. However, ADD_MONTHS is smart enough to return the last day of September in this<br>case. The following code provides a demonstration: </p>
<p>DECLARE<br>  new_date    DATE;<br>BEGIN<br>  new_date :&#x3D; ADD_MONTHS(to_date(‘08&#x2F;31&#x2F;2010’,’MM&#x2F;DD&#x2F;YYYY’),1);<br>  DBMS_OUTPUT.PUT_LINE(‘The last day of next month is: ‘ || new_date);<br>END; </p>
<p>The following is the resulting output: </p>
<p>The last day of next month is: 30-SEP-10 </p>
<p>PL&#x2F;SQL procedure successfully completed.<br>In general, if your source date is the late day of its month, then your result date will be forced to the<br>last day of its respective month. Adding one month to September 30, for example, will yield October 31.<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>137<br>7-4. Adding Years to a Date<br>Problem<br>You are developing an application that requires date calculations to be performed. You need to<br>determine how to add to a specified date. You may also want to subtract years.<br>Solution<br>Create a function that will calculate a new date based upon the number of years that you have specified.<br>If you want to subtract a number of years from a date, then pass a negative value for the number of years.<br>The following code implements this functionality: </p>
<p>CREATE OR REPLACE FUNCTION calculate_date_years (in_date DATE,<br>                                    in_years NUMBER)<br>RETURN DATE AS<br>  new_date    DATE;<br>BEGIN<br>  IF in_date is NULL OR in_years is NULL THEN<br>    RAISE NO_DATA_FOUND;<br>  END IF;<br>  new_date :&#x3D; ADD_MONTHS(in_date, 12 * in_years);<br>  RETURN new_date;<br>END; </p>
<p>The example function expects to receive a date and a number of years to add or subtract as<br>arguments. If one of those arguments is left out, then PL&#x2F;SQL will raise an ORA-06553 error, and the<br>example also raises a special NO_DATA_FOUND error if one or both of the arguments are NULL. The return<br>value will be the input date but in the newly calculated year.<br>How It Works<br>Oracle provides a couple of different ways to calculate dates based upon the addition or subtraction of<br>years. One such technique is to use the ADD_MONTHS function that was discussed in Recipe 7-3, as the<br>solution to this recipe demonstrates. Simple mathematics allow you to multiply the number of years<br>passed into the ADD_MONTHS function by 12 since there are 12 months in the year. Essentially this<br>technique exploits the ADD_MONTHS function to return a date a specified number of dates into the future.<br>■ Note See Recipe 7-3 for discussion of a corner case involving the use of ADD_MONTHS on a date that represents<br>the final day of that date’s month.<br>You can use this same technique to subtract a number of years from the specified date by passing a<br>negative integer value that represents the number of years you want to subtract. For instance, if you<br>wanted to subtract five years from the date 06&#x2F;01&#x2F;2000, then pass a -5 to the function that was created in<br>the solution to this recipe. The following query demonstrates this strategy. </p>
<p>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>138<br>select calculate_date_years(to_date(‘06&#x2F;01&#x2F;2000’,’MM&#x2F;DD&#x2F;YYYY’),-5) from dual; </p>
<p>Here’s the result: </p>
<p>06&#x2F;01&#x2F;1995 </p>
<p>Using the ADD_MONTHS function works well for adding or subtracting a rounded number of years.<br>However, if you wanted to add one year and six months, then it would take another line of code to add<br>the number of months to the calculated date. The function in the next example is a modified version of<br>the CALCULATE_DATE_YEARS function that allows you to specify a number of months to add or subtract as<br>well: </p>
<p>CREATE OR REPLACE FUNCTION calculate_date_years (in_date DATE,<br>                                              in_years IN NUMBER,<br>                                              in_months IN NUMBER DEFAULT 0)<br>RETURN DATE AS<br>  new_date    DATE;<br>BEGIN<br>  IF in_date is NULL OR in_years is NULL THEN<br>    RAISE NO_DATA_FOUND;<br>  END IF;<br>  new_date :&#x3D; ADD_MONTHS(in_date, 12 * in_years);<br>  – Additional code to add the number of months to the calculated date<br>  IF in_months !&#x3D; 0 THEN<br>    new_date :&#x3D; ADD_MONTHS(new_date, in_months);<br>  END IF;<br>  RETURN new_date;<br>END; </p>
<p>Using the new function, you can pass positive integer values for the number of years and the<br>number of months to add years or months to the date, or you can pass negative values for each to<br>subtract years or months from the date. You can also use a combination of positive and negative integers<br>for each to obtain the desired date. Since the modified function contains a DEFAULT value of 0 for the<br>number of months, it is possible to not specify a number of months, and you will achieve the same result<br>as the function in the solution to the recipe.<br>As you can see, this function is a bit easier to follow, but it does not allow for one to enter a negative<br>value to subtract from the date. All the techniques described within this section have their own merit.<br>However, it is always a good rule of thumb to write software so that it is easy to maintain in the future.<br>Using this rule of thumb, the most favored technique of the three would be to use the ADD_MONTHS<br>function as demonstrated in the solution. Not only is this function easy to understand but also widely<br>used by others within the Oracle community.<br>7-5. Determining the Interval Between Two Dates<br>Problem<br>You want to determine the number of days between two dates. For example, working on an application<br>to calculate credit card late fees, you are required to determine the number of days between any two<br>given dates. The difference in days between the two dates will produce the number of days that the<br>payment is overdue.<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>139<br>Solution<br>Subtract the two dates using simple math to find the interval in days. In this solution, the example code<br>subtracts the current date from the due date to obtain the number of days that the payment is past due: </p>
<p>CREATE OR REPLACE FUNCTION find_interval(from_date IN DATE,<br>                                         to_date IN DATE)<br>RETURN NUMBER AS<br>BEGIN<br>  RETURN abs(trunc(to_date) – trunc(from_date));<br>END; </p>
<p>This function will return the difference between the two dates passed as arguments. Note that the<br>number of days will be a decimal value. Although it is just as easy to subtract one date from another<br>without the use of a helper function, sometimes it is useful to encapsulate the logic. This is especially<br>true if the same calculation will be performed multiple times throughout the application.<br>How It Works<br>Oracle includes the ability to subtract dates in order to find the difference between the two. You can use<br>this functionality within PL&#x2F;SQL code or SQL queries. The result of the calculation is the number of<br>fractional days between the two dates. That number can be rounded in order to find the number of days,<br>or it can be formatted to determine the number of days, hours, minutes, and seconds.<br>As it stands, the result from the subtraction of two will return the number of days between the given<br>dates. If you were interested in returning the number of hours, minutes, or seconds between the two<br>dates, then you could do so by applying some simple mathematics to the result of the subtraction. For<br>instance, to find an interval in minutes, multiply the result by 24 * 60. The following functions show how<br>this technique can be used to create separate functions for returning each time interval: </p>
<p>CREATE OR REPLACE FUNCTION find_interval_hours(from_date IN DATE,<br>                     to_date IN DATE)<br>RETURN NUMBER AS<br>BEGIN<br> RETURN abs(trunc(from_date) - trunc(to_date) )* 24;<br>END; </p>
<p>CREATE OR REPLACE FUNCTION find_interval_minutes(from_date IN DATE,<br>                                         to_date IN DATE)<br>RETURN NUMBER AS<br>BEGIN<br>  RETURN (from_date - to_date) * 24 * 60;<br>END; </p>
<p>CREATE OR REPLACE FUNCTION find_interval_seconds(from_date IN DATE,<br>                                         to_date IN DATE)<br>RETURN NUMBER AS<br>BEGIN<br>  RETURN (from_date - to_date) * 24 * 60 * 60;<br>END;<br>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>140<br>Each of these functions will return a decimal number that can be rounded. Now you can mix and<br>match these functions as needed to return the desired time interval between two dates.<br>7-6. Adding Hours, Minutes, Seconds, or Days to a Given Date<br>Problem<br>One of your applications requires that you have the ability to add any number of days, hours, minutes, or<br>seconds to a given date and time to produce a new date and time.<br>Solution<br>Create functions that add each of these time values to TIMESTAMP dataypes that are passed as an<br>argument. Each of these functions will return the given time plus the amount of time that is passed in as<br>argument. The following three functions will provide the ability to add hours, minutes, seconds, or days<br>to a given time. Each of these functions returns the calculated date and time using the TIMESTAMP<br>datatype.<br>CREATE OR REPLACE FUNCTION calc_hours(time_to_change IN TIMESTAMP,<br>                     timeval IN NUMBER)<br>RETURN TIMESTAMP AS<br>  new_time    TIMESTAMP;<br>BEGIN </p>
<p>  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,’HOUR’);<br>  RETURN new_time;<br>END;<br>CREATE OR REPLACE FUNCTION calc_minutes(time_to_change IN TIMESTAMP,<br>                     timeval IN NUMBER)<br>RETURN TIMESTAMP AS<br>  new_time    TIMESTAMP;<br>BEGIN </p>
<p>  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,’MINUTE’);<br>  RETURN new_time;<br>END;<br>CREATE OR REPLACE FUNCTION calc_seconds(time_to_change IN TIMESTAMP,<br>                     timeval IN NUMBER)<br>RETURN TIMESTAMP AS<br>  new_time    TIMESTAMP;<br>BEGIN </p>
<p>  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,’SECOND’);<br>  RETURN new_time;<br>END;<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>141<br>CREATE OR REPLACE FUNCTION calc_days(time_to_change IN TIMESTAMP,<br>                     timeval IN NUMBER)<br>RETURN TIMESTAMP as<br>  new_time  TIMESTAMP;<br>BEGIN<br>  new_time :&#x3D; time_to_change + timeval;<br>  RETURN new_time;<br>END; </p>
<p>All of these functions operate in a similar fashion. You must input a date in the form of a TIMESTAMP,<br>and the calculated TIMESTAMP will be returned.<br>How It Works<br>When performing the calculation of times and dates in Oracle, you have plenty of options. Over the<br>years, Oracle Database has introduced newer functions to help alleviate some of the difficulties that<br>were encountered when attempting date and time calculations in earlier versions of the database. Date<br>and time calculations can be as simple as adding an integer to the DATE or TIMESTAMP. They can also be<br>difficult when many multiplications and divisions occur within the same calculation. The solution to this<br>recipe provides you with an easy way to add time to a given date using the NUMTODSINTERVAL function.<br>The syntax for this function is as follows: </p>
<p>NUMTODSINTERVAL(number, expression) </p>
<p>The expression that is passed to the function must be one of the following: HOUR, MINUTE, SECOND, or<br>DAY. Technically, the functions created in the solution are capable of subtracting the time or day values<br>from the given date as well. If you were to pass a negative number to the functions, then the<br>NUMTODSINTERVAL would subtract that many units from the given date and time and return the result. The<br>functions in the solution also do not lock you into using a TIMESTAMP; if you were to pass a DATE type in as<br>an argument, then it would work just as well.<br>In the past, you used to only have the ability to use fractions to add or subtract hours, minutes, and<br>seconds to a date. Over the next few examples, I will show you the sort of fractional mathematics that<br>you may see in legacy code. You can add a fraction to a date or TIMESTAMP as both will return a result. To<br>add hours to a date, use the fraction x&#x2F;24, where x is the number of hours (1–24) you want to add. You<br>can subtract hours by using a negative value for x. This works because there are of course 24 hours in<br>one day. The following example shows how you may see some legacy code using fractions to add hours. </p>
<p>– Add 1 hour to the current date<br>result :&#x3D; SYSDATE + 1&#x2F;24; </p>
<p>– Add 5 hours to the current date<br>result :&#x3D; CURRENT_TIMESTAMP + 5&#x2F;24; </p>
<p>It is possible to add minutes to a date using a similar technique with fractions. To add minutes, use<br>the fraction x&#x2F;24&#x2F;60, where x is the number of minutes (1–60) that you would like to add. Again, use a<br>negative value in place of x in order to subtract that number of minutes from a date. This fraction works<br>because it divides the number assigned to x by the hours in the day and then divides that result by the<br>number of minutes in an hour. The next figure shows an example of this technique. </p>
<p>– Add 10 mintes to the current date<br>result :&#x3D; SYSDATE + 10&#x2F;24&#x2F;60;<br>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>142<br>– Add 30 minutes to the current date<br>result :&#x3D; CURRENT_TIMESTAMP + 30&#x2F;24&#x2F;60; </p>
<p>Similarly, you can add seconds to a date by using the fraction x&#x2F;24&#x2F;3600. In this fraction, x is the<br>number of seconds (1–60) that you want to add. Subtraction of seconds is possible by using a negative<br>number for the x value. Just as with the other fractional calculations, this works because there are 3,600<br>seconds in one hour. Therefore, the number assigned to x is divided by the number of hours in the day,<br>and then that result is divided by the number of seconds in one hour. The next figure demonstrates<br>adding seconds to the date using this technique: </p>
<p>– Add 10 seconds to the current date<br>result :&#x3D; SYSDATE + 10&#x2F;24&#x2F;3600; </p>
<p>– Add 45 seconds to the current date<br>result :&#x3D; CURRENT_TIMESTAMP + 45&#x2F;24&#x2F;3600; </p>
<p>Using the fractional mathematics, you can add each of the different fractions to the given date and<br>achieve the same result. It is not uncommon for legacy code using fractional mathematics for date<br>calculation to look like the following: </p>
<p>– Add 2 hours, 5 minutes, and 30 seconds to the current date<br>result :&#x3D; SYSDATE + 2&#x2F;24 + 5&#x2F;24&#x2F;60 + 30&#x2F;24&#x2F;3600; </p>
<p>There are a number of ways to add time intervals to a given date. I recommend using<br>NUMTODSINTERVAL for performing mathematics on time values. In the past, this function was not available,<br>so using fractional mathematics was the only way to add or subtract time from a given date. As shown in<br>the solution to this recipe, it is possible to encapsulate the logic inside of a PL&#x2F;SQL function. If this is<br>done, then you could change the implementation inside the function and someone using it would never<br>know the difference. Date and time calculations can be made even easier to use by writing functions to<br>encapsulate the logic.<br>7-7. Returning the First Day of a Given Month<br>Problem<br>You want to have the ability to obtain the name of the first day for a given month.<br>Solution<br>Write a PL&#x2F;SQL function that accepts a date and applies the necessary functions to return the first day of<br>month for the given date. </p>
<p>CREATE OR REPLACE FUNCTION first_day_of_month(in_date DATE)<br>RETURN VARCHAR2 IS<br>BEGIN<br>  RETURN to_char(trunc(in_date,’MM’), ‘DD-MON-YYYY’);<br>END; </p>
<p>The function created in this solution will return the first day of the month that is passed into it<br>because it is passed into the TRUNC function.<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>143<br>How It Works<br>The TRUNC function can be useful for returning information from a DATE type. In this case, it is used to<br>return the first day of the month from the given date. The solution then converts the truncated date<br>value to a character format and returns the result.<br>The TRUNC function accepts two arguments, the first being the date that is to be truncated and the<br>second being the format model. The format model is a series of characters that specifies how you want<br>to truncate the given date. Table 7-1 lists the format models along with a description of each.<br>Table 7-1. Format Models for TRUNC<br>Format Model Description<br>MI Returns the nearest minute<br>HH, HH12, HH24 Returns the nearest hour<br>D, DY, DAY Returns the first day of the week<br>W Returns the same day of the week as the first day of the month<br>IW Returns the same day of the week as the first day of ISO year<br>WW Returns the same day of the week as the first day of the year<br>RM, MM, MON, MONTH  Rounds to the nearest first day of the month<br>Q Rounds to the nearest quarter<br>I, IY, IYYY Returns the ISO year<br>Y, YY, YYY, SYEAR, YEAR, YYYY  Rounds to the nearest first day of the year<br>CC, SCC Returns one greater than the first two digits of a given four-digit year</p>
<p>The solution to this recipe returns the first day of the given month using the format model MM.<br>7-8. Returning the Last Day of a Given Month<br>Problem<br>You want to have the ability to obtain the last day for a given month.<br>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>144<br>Solution<br>Use the Oracle built-in LAST_DAY function to return the last day of the month for the date that you pass<br>into it. The following example demonstrates a code block in which the LAST_DAY function is used to<br>return the last day of the current month: </p>
<p>DECLARE<br>  last_day  VARCHAR2(20);<br>BEGIN<br>  select LAST_DAY(sysdate)<br>  INTO last_day<br>  FROM DUAL;<br>  DBMS_OUTPUT.PUT_LINE(last_day);<br>END;<br>How It Works<br>The LAST_DAY function is an easy way to retrieve the date for the last day of a given date. To use the<br>function, pass in any date, and the last day of the month for the given date will be returned. The function<br>can be useful in combination with other functions, especially for converting strings into dates and then<br>determining the last day of the given month for the date given in string format. For example, the<br>following combination is used quite often: </p>
<p>LAST_DAY(to_date(string_based_date,’MM&#x2F;DD&#x2F;YYYY’))<br>7-9. Rounding a Number<br>Problem<br>You are interested in rounding a given number. For example, let’s say you are working on employee<br>timecards, and you want to round to the nearest tenth of an hour for every given hour amount.<br>Solution<br>Use the Oracle built-in ROUND function to return the result that you desire. For this solution, you are<br>working with hours on employee timecards. To round to the nearest tenth, you would write a small<br>PL&#x2F;SQL function that uses the ROUND function and returns the result. The following example<br>demonstrates this technique: </p>
<p>CREATE OR REPLACE FUNCTION emp_labor_hours(time IN NUMBER)<br>RETURN NUMBER IS<br>BEGIN<br>  RETURN ROUND(time, 1);<br>END; </p>
<p>The time will be rounded to the nearest tenth in this example because a 1 is passed as the second<br>argument to the ROUND function.<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>145<br>How It Works<br>The Oracle built-in ROUND function can be used for rounding numbers based upon a specified precision<br>level. To use the ROUND function, pass a number that you would like to round as the first argument, and<br>pass the optional precision level as the second argument. If you do not specify a precision level, then the<br>number will be rounded to the nearest integer. If the precision is specified, then the number will be<br>rounded to the number of decimal places specified by the precision argument.<br>In the case of this solution, a 1 was specified for the precision argument, so the number will be<br>rounded to one decimal place. The precision can be up to eight decimal places. If you specify a precision<br>larger than eight decimal places, then the precision will default to eight.<br>7-10. Rounding a Datetime Value<br>Problem<br>Given a particular date and time, you want the ability to round the date.<br>Solution<br>Use the ROUND function passing the date you want to round along with the format model for the unit you<br>want to round. For example, suppose that given a date and time, you want to the nearest day. To do this,<br>you would pass in the date along with the DD format model. The following code block demonstrates this<br>technique: </p>
<p>BEGIN<br>  DBMS_OUTPUT.PUT_LINE(to_char(ROUND (SYSDATE, ‘DD’),’MM&#x2F;DD&#x2F;YYYY - HH12:MI:SS’));<br> END; </p>
<p>The previous code block will return the current date and time rounded to the nearest day. For<br>example, if it is before 12 p.m., then it will round the given date back to 12 a.m. on that date; otherwise, it<br>will round forward to 12 a.m. on the next date.<br>How It Works<br>You can also use the ROUND function for working with DATE types. To round a date using this function, you<br>must specify the date you want to have rounded as the first argument along with the format parameter<br>for the type of rounding you want to perform. Table 7-2 lists the different format parameters for<br>performing DATE rounding.<br>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>146<br>Table 7-2. Format Parameters for DATE Rounding<br>Format Parameter Description<br>Y, YYY, YYYY, YEAR, SYEAR, SYYYY  Rounds to the nearest year<br>I, IY, IYYY Rounds to the nearest ISO year<br>Q Rounds to the nearest quarter<br>RM, MM, MON, MONTH Rounds to the nearest month<br>WW Rounds to the same day of the week as the first day of the year<br>IW Rounds to the same day of the week as the first day of the ISO year<br>W Rounds to the same day of the week as the first day of the month<br>J, DD, DDD Rounds to the nearest day<br>D, DY, DAY  Rounds to the start day of the week<br>HH, HH12, HH24 Rounds to the nearest hour<br>MI Rounds to the nearest minute </p>
<p>If you find that you are using the same date conversion in many places throughout your application,<br>then it may make sense to create a function to encapsulate the call to the ROUND function. Doing so would<br>enable a simple function call that can be used to return the date value you require rather than<br>remembering to use the correct format parameter each time.<br>7-11. Tracking Time to a Millisecond<br>Problem<br>You are interested in tracking time in a finely grained manner to the millisecond. For example, you want<br>to determine the exact time in which a particular change is made to the database.<br>Solution<br>Perform simple mathematics with the current date time in order to determine the exact time down the<br>millisecond. The following function accepts a timestamp and returns the |milliseconds: </p>
<p>CREATE OR REPLACE FUNCTION capture_milliseconds(in_time TIMESTAMP)<br>RETURN NUMBER IS<br>  milliseconds    NUMBER;<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>147<br>BEGIN<br>select sum(<br>   (extract(hour from in_time))*3600+<br>   (extract(minute from in_time))*60+<br>   (extract(second from in_time)))*1000<br>into MILLISECONDS from dual;<br>RETURN milliseconds; </p>
<p>END;<br>How It Works<br>If your application requires a fine-grained accuracy for time, then you may want to track time in<br>milliseconds. Performing a calculation such as the one demonstrated in the solution to this recipe on a<br>given DATE or TIMESTAMP can do this. By combining the EXTRACT function with some calculations, the<br>desired milliseconds result can be achieved.<br>The EXTRACT function is used to extract YEAR, MONTH, or DATE units from a DATE type. It can extract<br>HOUR, MINUTE, or SECOND from a TIMESTAMP. Milliseconds can be calculated by obtaining the sum of the<br>hours multiplied by 3600, the minutes multiplied by 60, and the seconds multiplied by 1000 from a given<br>TIMESTAMP. If you need to use milliseconds in your program, then I recommend creating a function such<br>as the one demonstrated in the solution to this recipe to encapsulate this logic.<br>7-12. Associating a Time Zone with a Date and Time<br>Problem<br>You want to associate a time zone with a given date and time in order to be more precise.<br>Solution<br>Create a code block that declares a field as type TIMESTAMP WITH TIME ZONE. Assign a TIMESTAMP to the<br>newly declared field within the body of the code block. After doing so, the field that you declared will<br>contain the date and time of the TIMESTAMP that you assigned along with the associated time zone. The<br>following example demonstrates a code block that performs this technique using the SYSTIMESTAMP: </p>
<p>DECLARE<br>  time   TIMESTAMP WITH TIME ZONE;<br> BEGIN<br>  time :&#x3D; SYSTIMESTAMP;<br>  DBMS_OUTPUT.PUT_LINE(time);<br> END; </p>
<p>The results that will be displayed via the call to DBMS_OUTPUT should resemble something similar to<br>the following: </p>
<p>29-AUG-10 10.27.58.639000 AM -05:00 </p>
<p>PL&#x2F;SQL procedure successfully completed.<br>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>148<br>How It Works<br>Prior to the TIMESTAMP datatype being introduced in Oracle 9i, the DATE type was the only way to work<br>with dates. There were limited capabilities provided, and later the TIMESTAMP was created to fill those<br>gaps. For those needing to make use of time zones, Oracle created the TIMESTAMP WITH TIME ZONE and<br>TIMESTAMP WITH LOCAL TIME ZONE datatypes. Both of these datatypes provide a time zone to be<br>associated with a given date, but they work a bit differently. When you specify the WITH TIME ZONE<br>option, the time zone information is stored within the database along with the hours, minutes, and so<br>on. However, if you specify the WITH LOCAL TIME ZONE option, the time zone information is not stored<br>within the database, but rather it is calculated each time against a baseline time zone, which determines<br>the time zone of your current session.<br>In the solution to this recipe, the time zone information is stored within the database along with the<br>rest of the date and time associated with the TIMESTAMP.<br>7-13. Finding a Pattern Within a String<br>Problem<br>You want to find the number of occurrences of a particular pattern within a given string. For instance,<br>you want to search for email addresses within a body of text.<br>Solution<br>Use a regular expression to match a given string against the body of text and return the resulting count of<br>matching occurrences. The following example searches through a given body of text and counts the<br>number of email addresses it encounters. Any email address will be added to the tally because a regular<br>expression is used to compare the strings. </p>
<p>CREATE OR REPLACE PROCEDURE COUNT_EMAIL_IN_TEXT(text_var     IN VARCHAR2) AS<br>  counter    NUMBER :&#x3D; 0;<br>  mail_pattern    VARCHAR2(15) :&#x3D; ‘\w+@\w+(.\w+)+’;<br>BEGIN<br>  counter :&#x3D; REGEXP_COUNT(text_var, mail_pattern); </p>
<p>  IF COUNTER &#x3D; 1 THEN<br>    DBMS_OUTPUT.PUT_LINE(‘This passage provided contains 1 email address’);<br>  ELSIF counter &gt; 1 THEN<br>    DBMS_OUTPUT.PUT_LINE(‘This passage provided contains ‘||<br>                     counter || ‘ email addresses’);<br>  ELSE<br>    DBMS_OUTPUT.PUT_LINE(‘This passage provided contains ‘ ||<br>            ‘no email addresses’);<br>  END IF;<br>END; </p>
<p>The function in this example provides a single service because it counts the number of occurrences<br>of an email address in a given body of text and returns the result.<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>149<br>How It Works<br>You can use regular expressions to help match strings of numbers, text, or alphanumeric values. They<br>are sequences of characters and symbols that assimilate a pattern that can be used to match against<br>strings of text. A regular expression is similar to using the % symbol as a wildcard within a query, except<br>that a regular expression provides a pattern that text must match against. Please refer to online Oracle<br>documentation for a listing of the different options that can be used for creating regular expression<br>patterns.  </p>
<p>Oracle introduced the REGEXP_COUNT function in Oracle 11g, which provides the functionality of counting<br>the number of occurrences of a given string within a given body of text. The syntax for the REGEXP_COUNT<br>function is as follows: </p>
<p>REGEXP_COUNT(source_text, pattern, position, options) </p>
<p>The source text for the function can be any string literal, variable, or column that has a datatype of<br>VARCHAR2, NVARCHAR2, CHAR, NCHAR, CLOB, or NCLOB. The pattern is a regular expression or a string of text that<br>will be used to match against. The position specifies the placement within the source text where the<br>search should begin. By default, the position is 1. The options include different useful matching<br>modifiers; please refer to the Oracle regular expression support documentation at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/E14072_01/server.112/e10592/ap_posix.htm#g693775">http://download.oracle.com/docs/cd/E14072_01/server.112/e10592/ap_posix.htm#g693775</a> for a listing<br>of the pattern matching modifiers that can be used as options.<br>The REGEXP_COUNT function can be used within any Oracle SQL statement or PL&#x2F;SQL program. The<br>following are a few more examples of using this function: </p>
<p>– Count all occurrences of the letter ‘l’ in the word Hello<br>result :&#x3D; REGEXP_COUNT(‘hello’,’l’); </p>
<p>Returns:  2 </p>
<p>– Count the number of occurrences of the pattern ‘ells’ beginning at<br>– the fifth character.<br>result :&#x3D; REGEXP_COUNT(‘she sells sea shells by the sea shore’,<br>                      ‘ells’,7,’c’); </p>
<p>Returns: 1 </p>
<p>– Count the number of words in the line<br>result :&#x3D; REGEXP_COUNT(‘she sells sea shells by the sea shore’,<br>                      ‘\w+’); </p>
<p>Returns: 8 </p>
<p>As you can see from these examples, the REGEXP_COUNT function is a great addition to the Oracle<br>regular expression function family<br>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>150<br>7-14. Determining the Position of a Pattern Within a String<br>Problem<br>You want to return the position of a matching string within a body of text. Furthermore, you are want to<br>pattern match and therefore must invoke a regular expression function. For example, you need to find a<br>way to determine the position of a string that matches the pattern of a phone number.<br>Solution<br>Use the REGEXP_INSTR function to use a regular expression to search a body of text to find the position of<br>a phone number. The following code block demonstrates this technique by looping through each of the<br>rows in the EMPLOYEES table and determining whether the employee phone number is USA or<br>international:<br>DECLARE<br>  CURSOR emp_cur IS<br>  SELECT *<br>  FROM employees;<br>  emp_rec       emp_cur%ROWTYPE;<br>  position     NUMBER :&#x3D; 0;<br>  counter        NUMBER :&#x3D; 0;<br>  intl_count     NUMBER :&#x3D; 0;<br>BEGIN<br>  FOR emp_rec IN emp_cur LOOP<br>  position :&#x3D; REGEXP_INSTR(emp_rec.phone_number,<br>  ‘([[:digit:]]{3}).([[:digit:]]{3}).([[:digit:]]{4})’); </p>
<p>  IF position &gt; 0 THEN<br>    counter :&#x3D; counter + 1;<br>  ELSE<br>    intl_count :&#x3D; intl_count + 1;<br>  END IF;<br>  END LOOP;<br>  DBMS_OUTPUT.PUT_LINE(‘Numbers within USA: ‘ || counter);<br>  DBMS_OUTPUT.PUT_LINE(‘International Numbers: ‘ || intl_count);<br>END;<br>Result:<br>Numbers within USA: 72<br>International Numbers: 35<br>PL&#x2F;SQL procedure successfully completed.<br>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>151<br>How It Works<br>In the solution to this recipe, the function uses REGEXP_INSTR to find all telephone numbers that match<br>the U.S. telephone number format. The field passed into REGEXP_INSTR is always going to return a<br>telephone number, but that number may be in an international format or a U.S. format. If the pattern of<br>the telephone number matches that of a U.S. format, then the counter for U.S. numbers is increased by<br>one. Otherwise, the counter for the international numbers is increased by one. The reasonable<br>assumption is that if a number is not a U.S. number, that it is an “international” number. Using<br>REGEXP_INSTR makes this a very easy function to implement.<br>REGEXP_INSTR will return the position of the first or last character of the matching string depending<br>upon the value of the return option argument. This function provides the same functionality of INSTR<br>except that it also allows the ability to use regular expression patterns. The syntax for this function is as<br>follows: </p>
<p>REGEXP_INSTR(source_text, pattern, position, occurrence,<br>                               return_option, match parameter, subexpression) </p>
<p>All but the source_text and pattern parameters are optional. The source_text is the string of text to<br>be searched. The pattern is a regular expression or string that will be matched against the source_text.<br>The optional position argument is an integer that specifies on which character Oracle should start the<br>search. The optional occurrence parameter specifies which occurrence of the pattern will have its<br>position returned. The default occurrence argument is 1, which means that the position of the first<br>matching string will be returned<br>The optional return_option is used to specify special options that are outlined within the Oracle<br>regular expression documentation that can be found at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/E11882_01/server.112/e10592/ap_posix.htm#g693775">http://download.oracle.com/docs/cd/E11882_01/server.112/e10592/ap_posix.htm#g693775</a>. The<br>optional match_parameter allows you to change the default matching behavior. The subexpression<br>parameter is optional, and it is an integer from 0 to 9 that indicates which subexpression in the<br>source_text will be the target of the function.<br>7-15. Finding and Replacing Text Within a String<br>Problem<br>You want to replace each occurrence of a given string within a body of text.<br>Solution<br>Use the REGEXP_REPLACE function to match a pattern of text against a given body of text, and replace all<br>matching occurrences with a new string. In the following function, the REGEXP_REPLACE function is used<br>to replace all occurrences of the JOB_TITLE ‘Programmer’ with the new title of ‘Developer.’ </p>
<p>DECLARE<br>  CURSOR job_cur IS<br>  SELECT *<br>  FROM jobs; </p>
<p>  job_rec       job_cur%ROWTYPE;<br>  new_job_title jobs.job_title%TYPE;<br>BEGIN<br>CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>152<br>  FOR job_rec IN job_cur LOOP<br>    IF REGEXP_INSTR(job_rec.job_title,’Programmer’) &gt; 0 THEN<br>      new_job_title :&#x3D; REGEXP_REPLACE(job_rec.job_title, ‘Programmer’,<br>                                    ‘Developer’); </p>
<pre><code>  UPDATE jobs 
  SET job_title = new_job_title 
  WHERE job_id = job_rec.job_id; 
 
  DBMS_OUTPUT.PUT_LINE(job_rec.job_title || &#39; replaced with &#39; || 
     new_job_title); 
END IF; 
</code></pre>
<p> END LOOP; </p>
<p>END; </p>
<p>Although this particular example does not use any regular expression patterns, it could be adjusted<br>to do so. To find more information and tables specifying the options that are available for creating<br>patterns, please refer to the online Oracle documentation.<br>The solution to this recipe prints out the revised text. Each occurrence of the ‘Programmer’ text is<br>replaced with ‘Developer’, and the newly generated string is returned into the NEW_REVIEW variable.<br>How It Works<br>The REGEXP_REPLACE function is a great way to find and replace strings within a body of text. The function<br>can be used within any Oracle SQL statement or PL&#x2F;SQL code. The syntax for the function is as follows: </p>
<p>REGEXP_REPLACE(source_text, pattern, replacement_string, position, occurrence, options) </p>
<p>The source text for the function can be any string literal, variable, or column that has a datatype of<br>VARCHAR2, NVARCHAR2, CHAR, NCHAR, CLOB, or NCLOB. The pattern is a regular expression or a string of text that<br>will be used to match against. The replacement string is will replace each occurrence of the string<br>identified by the source text. The optional position specifies the placement within the source text where<br>the search should begin. By default, the position is 1. The optional occurrence argument is a<br>nonnegative integer that indicates the occurrence of the replace operation. If a 0 is specified, then all<br>matching occurrences will be replaced. If a positive integer is specified, then Oracle will replace the<br>match for that occurrence with the replacement string. The optional options argument includes<br>different useful matching modifiers; please refer to the online Oracle documentation for a listing of the<br>pattern matching modifiers that can be used as options.<br>■ Note Do not use REGEXP_REPLACE if the replacement can be performed with a regular UPDATE statement. Since<br>REGEXP_REPLACE uses regular expressions, it can be slower than a regular UPDATE.<br>The following examples demonstrate how this function can be used within a PL&#x2F;SQL application or<br>a simple query. This next bit of code demonstrates how to replace numbers that match those within the<br>given set. </p>
<p>  CHAPTER 7  NUMBERS, STRINGS, AND DATES<br>153<br>select REGEXP_REPLACE(‘abcdefghi’,’[acegi]’,’x’) from dual; </p>
<p>Returns: xbxdxfxhx </p>
<p>Next, we replace a Social Security Number with Xs. </p>
<p>new_ssn :&#x3D; REGEXP_REPLACE(‘123-45-6789’,’[[:digit:]]{3}-[[:digit:]]{2}-[[:digit:]]{4}’,’xxx-<br>xxx-xxxx’); </p>
<p>Returns: xxx-xxx-xxxx </p>
<p>The REGEXP_REPLACE function can be most useful when attempting to replace patterns of strings within a<br>given body of text such as the two previous examples have shown. As noted previously, if a standard<br>UPDATE statement can be used to replace a value, then that should be the first choice, because regular<br>expressions perform slightly slower. </p>
<p>C H A P T E R  8 </p>
<p>   </p>
<p>155<br>Dynamic SQL<br>Oracle provides dynamic SQL as a means for generating DML or DDL at runtime. It can be useful when<br>the full text of a SQL statement or query is not known until application runtime. Dynamic SQL can help<br>overcome some of the limitations of static SQL, such as generating a full SQL query based upon some<br>user-provided information or inserting into a specific table depending upon a user action within your<br>application. Simply put, the ability to use dynamic SQL within PL&#x2F;SQL applications provides a level of<br>flexibility that is not attainable with the use of static SQL alone.<br>Oracle allows dynamic SQL to be generated in two different ways: native dynamic SQL and through<br>the use of the DBMS_SQL package. Each strategy has its own benefits as well as drawbacks. In comparison,<br>native dynamic SQL is easier to use, it supports user-defined types, and it performs better than DBMS_SQL.<br>On the other hand, DBMS_SQL supports some features that are not currently supported in native dynamic<br>SQL such as the use of the SQL*Plus DESCRIBE command and the reuse of SQL statements. Each of these<br>methodologies will be compared under various use cases within this chapter. By the end of the chapter,<br>you should know what advantages each approach has to offer and which should be used in certain<br>circumstances.<br>8-1. Executing a Single Row Query That Is Unknown at Compile Time<br>Problem<br>You need to query the database for a single row of data matched by the primary key value. However, you<br>are unsure of what columns will need to be returned at runtime.<br>Solution #1<br>Use a native dynamic query to retrieve the columns of data that are determined by your application at<br>runtime. After you determine what columns need to be returned, create a string that contains the SQL<br>that is needed to query the database. The following example demonstrates the concept of creating a<br>dynamic SQL query and then using native dynamic SQL to retrieve the single row that is returned. </p>
<p>CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS<br>  emp_qry                VARCHAR2(500);<br>  emp_first              employees.first_name%TYPE;<br>  emp_last               employees.last_name%TYPE;<br>  email                  employees.email%TYPE; </p>
<p>  valid_id_count         NUMBER :&#x3D; 0;<br>  valid_flag             BOOLEAN :&#x3D; TRUE;<br>  temp_emp_info          VARCHAR2(50); </p>
<p>CHAPTER 8  DYNAMIC SQL<br>156<br>BEGIN<br>  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;<br>  IF emp_info LIKE ‘%@%’ THEN<br>    temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);<br>    emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;<br>  ELSE<br>    SELECT COUNT(*)<br>    INTO valid_id_count<br>    FROM employees<br>    WHERE employee_id &#x3D; emp_info; </p>
<pre><code>IF valid_id_count &gt; 0 THEN 
    temp_emp_info := emp_info; 
    emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; 
ELSE 
    valid_flag := FALSE; 
END IF; 
</code></pre>
<p>  END IF; </p>
<p>  IF valid_flag &#x3D; TRUE THEN<br>    EXECUTE IMMEDIATE emp_qry<br>    INTO emp_first, emp_last, email<br>    USING temp_emp_info; </p>
<pre><code>DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); 
</code></pre>
<p>  ELSE<br>    DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE SPECIFIED DOES ‘ ||<br>                         ‘NOT MATCH ANY EMPLOYEE RECORD’);<br>  END IF;<br>END; </p>
<p>At runtime, the procedure creates a SQL query based upon the criteria that are passed into the<br>procedure by the invoking program. That query is then executed using the EXECUTE IMMEDIATE statement<br>along with the argument that will be substituted into the query WHERE clause.<br>Solution #2<br>Use the DBMS_SQL package to create a query based upon criteria that are specified at runtime. The<br>example in this solution will query the employee table and retrieve data based upon the parameter that<br>has been passed into the procedure. The procedure will accept either a primary key ID or an employee e-<br>mail address. The SQL statement that will be used to query the database will be determined at runtime<br>based upon what type of argument is used. </p>
<p>CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS<br>  emp_qry                  VARCHAR2(500);<br>  emp_first                employees.first_name%TYPE :&#x3D; NULL;<br>  emp_last                 employees.last_name%TYPE :&#x3D; NULL;<br>  email                    employees.email%TYPE :&#x3D; NULL; </p>
<p>  valid_id_count           NUMBER :&#x3D; 0;<br>  valid_flag               BOOLEAN :&#x3D; TRUE;<br>  CHAPTER 8  DYNAMIC SQL<br>157<br>  temp_emp_info          VARCHAR2(50); </p>
<p>  cursor_name            INTEGER;<br>  row_ct                 INTEGER; </p>
<p>BEGIN </p>
<p>  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;<br>  IF emp_info LIKE ‘%@%’ THEN<br>    temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);<br>    emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;<br>  ELSE<br>    SELECT COUNT(*)<br>    INTO valid_id_count<br>    FROM employees<br>    WHERE employee_id &#x3D; emp_info; </p>
<pre><code>IF valid_id_count &gt; 0 THEN 
    temp_emp_info := emp_info; 
    emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :emp_info&#39;; 
ELSE 
    valid_flag := FALSE; 
END IF; 
</code></pre>
<p>  END IF; </p>
<p>  IF valid_flag &#x3D; TRUE THEN<br>    cursor_name :&#x3D; DBMS_SQL.OPEN_CURSOR;<br>    DBMS_SQL.PARSE(cursor_name, emp_qry, DBMS_SQL.NATIVE);<br>    DBMS_SQL.BIND_VARIABLE(cursor_name, ‘:emp_info’, temp_emp_info);<br>    DBMS_SQL.DEFINE_COLUMN(cursor_name, 1, emp_first, 20);<br>    DBMS_SQL.DEFINE_COLUMN(cursor_name, 2, emp_last, 25);<br>    DBMS_SQL.DEFINE_COLUMN(cursor_name, 3, email, 25);<br>    row_ct :&#x3D; DBMS_SQL.EXECUTE(cursor_name);<br>  IF DBMS_SQL.FETCH_ROWS(cursor_name) &gt; 0 THEN<br>      DBMS_SQL.COLUMN_VALUE (cursor_name, 1, emp_first);<br>      DBMS_SQL.COLUMN_VALUE (cursor_name, 2, emp_last);<br>      DBMS_SQL.COLUMN_VALUE (cursor_name, 3, email);<br>      DBMS_OUTPUT.PUT_LINE(emp_first || ‘ ‘ || emp_last || ‘ - ‘ || email); </p>
<p>  END IF; </p>
<p>  ELSE<br>    DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE SPECIFIED DOES ‘ ||<br>                         ‘NOT MATCH ANY EMPLOYEE RECORD’);<br>  END IF;<br>  DBMS_SQL.CLOSE_CURSOR(cursor_name);<br>  EXCEPTION<br>    WHEN OTHERS THEN<br>      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE SPECIFIED DOES ‘ ||<br>                         ‘NOT MATCH ANY EMPLOYEE RECORD’); </p>
<p>END;<br>CHAPTER 8  DYNAMIC SQL<br>158<br>How It Works #1<br>Native dynamic SQL allows you to form a string of SQL text and then execute it via the EXECUTE<br>IMMEDIATE statement. This is very useful when the columns, table names, or WHERE clause text is not<br>known at runtime. The program can build the SQL string as it needs to, and then the EXECUTE IMMEDIATE<br>statement will execute it. The format for the EXECUTE IMMEDIATE statement is as follows: </p>
<p>EXECUTE IMMEDIATE sql_string<br>[INTO variable_name1[, variable_name2, . . .]<br>USING variable_name1[, variable_name2, . . .]]; </p>
<p>The EXECUTE IMMEDIATE statement requires only one parameter, which is a SQL string to execute.<br>The remainder of the statement is optional. The INTO clause lists all the variables that a SQL query would<br>return values into. The variables should be listed in the same order within the SQL string as they are<br>listed within the INTO clause. The USING clause lists all the variables that will be bound to the SQL string<br>at runtime. Bind variables are arguably one of the most valuable features of the PL&#x2F;SQL language. Each<br>variable listed in the USING clause is bound to a bind variable within the SQL string. The order in which<br>the variables are listed in the USING clause is the same order in which they will be bound within the<br>string. Take a look at the following example that uses two bind variables: </p>
<p>EXECUTE IMMEDIATE ‘select email from employees ‘ ||<br>                                       ‘where last_name &#x3D;:last ‘ ||<br>                                       ‘and first_name &#x3D; :first’<br>INTO v_email<br>USING v_last, v_first; </p>
<p>In the example query, the variables contained within the USING clause are bound in order to the bind<br>variables within the SQL string. Bind variables are the cornerstone to developing robust, secure, and<br>well-performing software.<br>How It Works #2<br>The DBMS_SQL package can also be used to perform the same task. Each of the different techniques, native<br>dynamic SQL and DBMS_SQL, have their advantages and disadvantages. The major difference between the<br>use of DBMS_SQL and native dynamic SQL is how the dynamic SQL string is executed. In this example,<br>DBMS_SQL package functions are used to process the SQL rather than EXECUTE IMMEDIATE. As you can see,<br>the code is quite a bit lengthier than using EXECUTE IMMEDIATE, and it essentially returns the same<br>information. In this case, DBMS_SQL is certainly not the best choice. DBMS_SQL can become useful in<br>situations where you do not know the SELECT list until runtime or when you are unsure of which<br>variables must be bound to a SELECT or DML statement. On the other hand, you must use native<br>dynamic SQL if you intend to use the cursor variable attributes %FOUND, %NOTFOUND, %ISOPEN, or %ROWCOUNT<br>when working with your cursor.<br>■ Note Native dynamic SQL was introduced in Oracle 9i, because DBMS_SQL was overly complex for many of the<br>routine tasks that programmers perform. We consider use of native dynamic SQL as the technique of choice for<br>working with dynamic SQL. Use DBMS_SQL only when you have a specific need to do so.<br>  CHAPTER 8  DYNAMIC SQL<br>159<br>8-2. Executing a Multiple Row Query That Is Unknown at Compile<br>Time<br>Problem<br>Your application requires a database table to be queried, but the filters for the WHERE clause are not<br>known until runtime. You have no idea how many rows will be returned by the query.<br>Solution #1<br>Create a native dynamic query using a SQL string that will be built at application runtime. Declare the<br>query using REF CURSOR, execute it by issuing an OPEN statement, and loop through the records using a<br>standard loop, fetching the fields within each iteration of the loop. This technique is illustrated via the<br>code in the following example: </p>
<p>DECLARE<br>  emp_qry                 VARCHAR2(500);<br>  TYPE                    cur_type IS REF CURSOR;<br>  cur                     cur_type;<br>  emp_first               employees.first_name%TYPE;<br>  emp_last                employees.last_name%TYPE;<br>  email                   employees.email%TYPE; </p>
<p>  dept_id                 employees.department_id%TYPE :&#x3D; &amp;department_id; </p>
<p>BEGIN<br>  – DEPARTMENT_ID WILL NOT UNIQUELY DEFINE ANY ONE EMPLOYEE </p>
<p>  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘ ||<br>             ‘ WHERE DEPARTMENT_ID &#x3D; :id’; </p>
<p>  OPEN cur FOR emp_qry USING dept_id;<br>  LOOP<br>    FETCH cur INTO emp_first, emp_last, email;<br>   EXIT WHEN cur%NOTFOUND;<br>    DBMS_OUTPUT.PUT_LINE(emp_first || ‘ ‘ || emp_last || ‘ - ‘ || email);<br>  END LOOP;<br>  CLOSE cur;<br>END; </p>
<p>This example accepts a DEPARTMENT_ID as input, and it uses a bind variable to substitute the value<br>within the SQL string. Although the actual SQL string in this example does not require the use of a<br>dynamic query, it is a useful example to demonstrate the technique.<br>Solution #2<br>This same procedure can also be performed using the DBMS_SQL package. Although the native dynamic<br>SQL solution is easier to understand and implement, the DBMS_SQL alternative offers some different<br>options that are not available when using the native method. The following example is a sample of a<br>CHAPTER 8  DYNAMIC SQL<br>160<br>procedure that performs the same functionality as Solution #1 of this recipe. However, the procedure in<br>the following example uses the DBMS_SQL package to parse and execute the dynamic query rather than<br>native dynamic SQL.<br>CREATE OR REPLACE PROCEDURE obtain_emp_detail(dept_id IN NUMBER) IS<br>  emp_qry                 VARCHAR2(500);<br>  emp_first               employees.first_name%TYPE :&#x3D; NULL;<br>  emp_last                employees.last_name%TYPE :&#x3D; NULL;<br>  email                   employees.email%TYPE :&#x3D; NULL;<br>  cursor_name             INTEGER;<br>  row_ct                  INTEGER;<br>BEGIN </p>
<p> emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘ ||<br>             ‘ WHERE DEPARTMENT_ID &#x3D; :id’;<br>    cursor_name :&#x3D; DBMS_SQL.OPEN_CURSOR;<br>    DBMS_SQL.PARSE(cursor_name, emp_qry, DBMS_SQL.NATIVE);<br>    DBMS_SQL.BIND_VARIABLE(cursor_name, ‘:id’, dept_id);<br>    DBMS_SQL.DEFINE_COLUMN(cursor_name, 1, emp_first, 20);<br>    DBMS_SQL.DEFINE_COLUMN(cursor_name, 2, emp_last, 25);<br>    DBMS_SQL.DEFINE_COLUMN(cursor_name, 3, email, 25);<br>    row_ct :&#x3D; DBMS_SQL.EXECUTE(cursor_name);<br>    LOOP<br>    IF DBMS_SQL.FETCH_ROWS(cursor_name) &gt; 0 THEN<br>      DBMS_SQL.COLUMN_VALUE (cursor_name, 1, emp_first);<br>      DBMS_SQL.COLUMN_VALUE (cursor_name, 2, emp_last);<br>      DBMS_SQL.COLUMN_VALUE (cursor_name, 3, email);<br>     DBMS_OUTPUT.PUT_LINE(emp_first || ‘ ‘ || emp_last || ‘ - ‘ || email);<br>    ELSE<br>      EXIT;<br>    END IF;<br>    END LOOP; </p>
<p>DBMS_SQL.CLOSE_CURSOR(cursor_name);<br>EXCEPTION<br>    WHEN OTHERS THEN<br>      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||<br>                         ‘NOT MATCH ANY EMPLOYEE RECORD’);<br>END;<br>How It Works<br>The use of native dynamic SQL in this solution is more or less equivalent to that which was performed in<br>the previous recipe. The largest difference lies in the use of the REF CURSOR as opposed to the EXECUTE<br>IMMEDIATE statement. The REF CURSOR is used to create a cursor using a dynamic SQL string.<br>Cursor variables can be either weakly typed or strongly typed. The cursor variable demonstrated in<br>the solution to this example of a weakly typed REF CURSOR, since the SQL string is not known until<br>  CHAPTER 8  DYNAMIC SQL<br>161<br>runtime. A strongly typed cursor variable must be known at runtime. In this sense, a strongly typed<br>cursor variable is very similar to a regular cursor.<br>The REF CURSOR type must be declared first, and then the actual cursor variable that will be used in<br>your code should be declared using the REF CURSOR as its type. Next you have the OPEN statement. To tell<br>Oracle what SQL to use for the cursor, the OPEN statement should include a FOR clause indicating the SQL<br>string that the cursor should use. If there are any variables to bind into the query, the optional USING<br>clause should follow at the end of the OPEN statement.<br>The subsequent cursor loop should work with the REF CURSOR in the same manner that you would<br>use with regular cursor variables. Always FETCH the current record or its contents into a local record or<br>separate local variables. Next, perform the tasks that need to be completed. Lastly, ensure that you<br>include an EXIT statement to indicate that the loop should be terminated after the last record has been<br>processed. The final step in the process is to close the cursor. After the cursor has been closed, it can be<br>assigned a new SQL string since you are working with weakly typed REF CURSORs.<br>As you can see, the example of using DBMS_SQL in Solution #2 of this recipe as opposed to the<br>example in Recipe 8-1 differs only because of the addition of a LOOP construct. Instead of displaying only<br>one value, this example will loop through all the records that are returned from the query, and the loop<br>will exit when there are no remaining rows in the result. The example in Recipe 8-1 could entail the same<br>loop construct as the one shown in Solution #2 of this recipe, but it is only expected to return one row<br>since the query is based upon a primary and unique key value.<br>The choice for using DBMS_SQL as opposed to native dynamic SQL (NDS) depends on what you are<br>trying to achieve. DBMS_SQL will allow you to use a SQL string that is greater than 32KB in size, whereas<br>native dynamic SQL will not. However, there are other options for creating large SQL text strings and<br>parsing them with native dynamic SQL. Please see Recipe 8-11 for more details.<br>8-3. Writing a Dynamic INSERT Statement<br>Problem<br>Your application must insert data into a table, but you don’t know until runtime which columns you will<br>insert. For example, you are writing a procedure that will be used for saving records into the EMPLOYEES<br>table. However, the exact content to be saved is not known until runtime because the person who is<br>calling the procedure can decide whether they are including a DEPARTMENT_ID. If a DEPARTMENT_ID is<br>included, then the department will be included in the INSERT.<br>Solution<br>Create a string at runtime that will contain the INSERT statement text to be executed. Use bind variables<br>to substitute the values that are to be inserted into the database table. The following procedure accepts<br>user input for entry of a new employee record. Bind variables are used to substitute those values into the<br>SQL. </p>
<p>CREATE OR REPLACE PROCEDURE new_employee (   first     IN VARCHAR2,<br>                                             last      IN VARCHAR2,<br>                                             email     IN VARCHAR2,<br>                                             phone     IN VARCHAR2,<br>                                             hired     IN DATE,<br>                                             job       IN VARCHAR2,<br>                                             dept      IN NUMBER DEFAULT 0) AS<br>                                             v_sql     VARCHAR2(1000);<br>BEGIN<br>CHAPTER 8  DYNAMIC SQL<br>162<br>  IF dept !&#x3D; 0 THEN<br>    v_sql :&#x3D; ‘INSERT INTO EMPLOYEES ( ‘ ||<br>                   ‘employee_id, first_name, last_name, email, ‘ ||<br>                   ‘phone_number, hire_date, job_id, department_id) ‘ ||<br>                   ‘VALUES( ‘ ||<br>                   ‘:id, :first, :last, :email, :phone, :hired, ‘ ||<br>                   ‘:job_id, :dept)’; </p>
<pre><code>EXECUTE IMMEDIATE v_sql 
USING employees_seq.nextval, first, last, email, phone, hired, job, dept; 
</code></pre>
<p>  ELSE<br>    v_sql :&#x3D; ‘INSERT INTO EMPLOYEES ( ‘ ||<br>                   ‘employee_id, first_name, last_name, email, ‘ ||<br>                   ‘phone_number, hire_date, job_id) ‘ ||<br>                   ‘VALUES( ‘ ||<br>                   ‘:id, :first, :last, :email, :phone, :hired, ‘ ||<br>                   ‘:job_id)’; </p>
<pre><code>EXECUTE IMMEDIATE v_sql 
USING employees_seq.nextval, first, last, email, phone, hired, job; 
</code></pre>
<p>  END IF; </p>
<p>  DBMS_OUTPUT.PUT_LINE(‘The employee has been successfully entered’);<br>EXCEPTION<br>  WHEN NO_DATA_FOUND THEN<br>    DBMS_OUTPUT.PUT_LINE(‘YOU MUST SUPPLY A VALUE FOR DEPARTMENT’);<br>  WHEN TOO_MANY_ROWS THEN<br>    DBMS_OUTPUT.PUT_LINE(‘EMPLOYEE_ID ALREADY EXISTS’);<br>END; </p>
<p>If the data entry clerk includes a department ID number for the employee when executing the<br>NEW_EMPLOYEE procedure, then the INSERT statement will differ slightly than it would if no department ID<br>were provided. The basic native dynamic SQL in this example does not differ much from those examples<br>demonstrated in Recipe 8-1 or Recipe 8-2 of this chapter.<br>Solution #2<br>The DBMS_SQL API can also be used to execute dynamic INSERT statements. Although dynamic DML is not<br>usually performed with DBMS_SQL very often, it can still be useful in some circumstances. The following<br>example performs the same task as Solution #1 to this recipe. However, it has been rewritten to use<br>DBMS_SQL instead of native dynamic SQL. </p>
<p>CREATE OR REPLACE PROCEDURE new_employee(first      IN VARCHAR2,<br>                                         last       IN VARCHAR2,<br>                                         email      IN VARCHAR2,<br>                                         phone      IN VARCHAR2,<br>                                         hired      IN DATE,<br>                                         job        IN VARCHAR2,<br>                                         dept       IN NUMBER DEFAULT 0)<br>7<br>  CHAPTER 8  DYNAMIC SQL<br>163<br>AS<br>  v_sql    VARCHAR2(1000); </p>
<p>  cursor_var            NUMBER :&#x3D; DBMS_SQL.OPEN_CURSOR;<br>  rows_compelete NUMBER :&#x3D; 0;<br>  next_emp              NUMBER :&#x3D; employee_seq.nextval;<br>BEGIN </p>
<p>  IF dept !&#x3D; 0 THEN<br>    v_sql :&#x3D; ‘INSERT INTO EMPLOYEES ( ‘ ||<br>                   ‘employee_id, first_name, last_name, email, ‘ ||<br>                   ‘phone_number, hire_date, job_id, department_id) ‘ ||<br>                   ‘VALUES( ‘ ||<br>                   ‘:id, :first, :last, :email, :phone, :hired, ‘ ||<br>                   ‘:job_id, :dept)’; </p>
<p>  ELSE<br>    v_sql :&#x3D; ‘INSERT INTO EMPLOYEES ( ‘ ||<br>                   ‘employee_id, first_name, last_name, email, ‘ ||<br>                   ‘phone_number, hire_date, job_id) ‘ ||<br>                   ‘VALUES( ‘ ||<br>                   ‘:id, :first, :last, :email, :phone, :hired, ‘ ||<br>                   ‘:job_id)’;<br>  END IF;<br>  DBMS_SQL.PARSE(cursor_var, v_sql, DBMS_SQL.NATIVE);<br>  DBMS_SQL.BIND_VARIABLE(cursor_var, 1, ‘:id’, next_emp);<br>  DBMS_SQL.BIND_VARIABLE(cursor_var, 2, ‘:first’, first);<br>  DBMS_SQL.BIND_VARIABLE(cursor_var, 3, ‘:last’, last);<br>  DBMS_SQL.BIND_VARIABLE(cursor_var, 4, ‘:email’, email);<br>  DBMS_SQL.BIND_VARIABLE(cursor_var, 5, ‘:phone’, phone);<br>  DBMS_SQL.BIND_VARIABLE(cursor_var, 6, ‘:hired’);<br>  DBMS_SQL.BIND_VARIABLE(cursor_var, 7, ‘:job’, job);<br>  IF dept !&#x3D; 0 then<br>    DBMS_SQL.BIND_VARIABLE(cursor_var, 8, ‘:dept’, dept);<br>  END IF;<br>  rows_complete :&#x3D; DBMS_SQL.EXECUTE(cursor_var);<br>  DBMS_SQL.CLOSE_CURSOR(cursor_var);<br>  DBMS_OUTPUT.PUT_LINE(‘The employee has been successfully entered’);<br>END;<br>How It Works<br>Using native dynamic SQL, creating an INSERT statement is almost identical to working with a query<br>string. As a matter of fact, the only difference is that you will not be making use of the INTO clause within<br>the EXECUTE IMMEDIATE statement. Standard PL&#x2F;SQL can be used to create the SQL statement string in<br>order to process an INSERT statement that contains column names, table names, or WHERE clause values<br>that are not known until runtime.<br>CHAPTER 8  DYNAMIC SQL<br>164<br>■ Note If your SQL string contains any SQL that requires the use of single quotes, double up on the quotes.<br>Placing a single quote immediately after another signals the parser to place a single quote into the string that you<br>are creating.<br>Similarly to SQL queries using dynamic SQL, you should use bind variables to substitute values into<br>the SQL statement string where needed. As a refresher, bind variables are used within SQL queries or<br>statements to act as placeholders for values that are to be substituted at runtime. A bind variable begins<br>with a colon and is then followed by the variable name. The EXECUTE IMMEDIATE statement implements<br>the USING clause to list variables that contain values that will be substituted into the bind variables at<br>runtime. The order in which the variables are listed in the USING clause must concur with the positioning<br>of the bind variables within the SQL. The following is an example of an EXECUTE IMMEDIATE statement to<br>be used with a SQL statement such as an INSERT: </p>
<p>EXECUTE IMMEDIATE sql_statement_string<br>[USING variable1, variable2, etc]; </p>
<p>It is usually a good idea to include an EXCEPTION block at the end of any code block. This is especially<br>true when working with dynamic queries or statements. An Oracle error will be raised if the INSERT<br>statement within the SQL string is invalid. If an EXCEPTION block were added to catch OTHERS, then you<br>could provide a well-written error message that describes the exact issue at hand. In most cases, users of<br>your application would prefer to see such a nice summary message rather than a cryptic Oracle error<br>message.<br>It is a good rule of thumb to maintain consistency throughout your application code. If you prefer to<br>use native dynamic SQL, then try to use it in all cases where dynamic SQL is a requirement. Likewise,<br>DBMS_SQL should be used throughout if you plan to make use of it instead. There are certain situations<br>when you may want to mix the two techniques in order to obtain information or use features that are not<br>available with one or the other. In Recipe 8-13, you will learn more about using both techniques within<br>the same block of PL&#x2F;SQL code.<br>8-4. Writing a Dynamic Update Statement<br>Problem<br>Your application needs to execute an update statement, and you are not sure of the columns to be<br>updated until runtime. For example, your application will modify employee records. You would like to<br>construct an update statement that contains only the columns that have updated values.<br>Solution<br>Use native dynamic SQL to execute a SQL statement string that you prepare at application runtime. The<br>procedure in this example accepts employee record values as input. In this scenario, an application form<br>allows user entry for many of the fields that are contained within the EMPLOYEES table so that a particular<br>employee record can be updated. The values that are changed on the form should be included in the<br>UPDATE statement. The procedure queries the employee record and checks to see which values have been<br>updated. Only the updated values are included in the text of the SQL string that is used for the update. </p>
<p>  CHAPTER 8  DYNAMIC SQL<br>165<br>CREATE OR REPLACE PROCEDURE update_employees(id   IN employees.employee_id%TYPE,<br>                                            first IN employees.first_name%TYPE,<br>                                            last  IN employees.last_name%TYPE,<br>                                            email IN employees.email%TYPE,<br>                                            phone IN employees.phone_number%TYPE,<br>                                            job   IN employees.job_id%TYPE,<br>                                            salary IN employees.salary%TYPE,<br>                                            commission_pct IN employees.commission_pct%TYPE,<br>                                            manager_id IN employees.manager_id%TYPE,<br>                                            department_id IN employees.department_id%TYPE)<br> AS </p>
<p>  emp_upd_rec   employees%ROWTYPE; </p>
<p>  sql_string    VARCHAR2(1000); </p>
<p>  set_count     NUMBER :&#x3D; 0;<br>BEGIN </p>
<p>  SELECT *<br>  INTO emp_upd_rec<br>  FROM employees<br>  WHERE employee_id &#x3D; id; </p>
<p>  sql_string :&#x3D; ‘UPDATE EMPLOYEES SET ‘; </p>
<p>  IF first !&#x3D; emp_upd_rec.first_name THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, FIRST_NAME &#x3D;’ || first || ‘’’’;<br>    ELSE<br>      sql_string :&#x3D; sql_string || ‘ FIRST_NAME &#x3D;’ || first || ‘’’’;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>  END IF; </p>
<p>  IF last !&#x3D; emp_upd_rec.last_name THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, LAST_NAME &#x3D;’’’ || last || ‘’’’;<br>    ELSE<br>      sql_string :&#x3D; sql_string ||’ LAST_NAME &#x3D;’’’ ||  last || ‘’’’;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>  END IF; </p>
<p>  IF upper(email) !&#x3D; emp_upd_rec.email THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, EMAIL &#x3D;’’’ || upper(email) || ‘’’’;<br>    ELSE<br>      sql_string :&#x3D; sql_string ||’ EMAIL &#x3D;’’’ || upper(email) || ‘’’’;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>CHAPTER 8  DYNAMIC SQL<br>166<br>  END IF; </p>
<p>  IF upper(phone) !&#x3D; emp_upd_rec.phone_number THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, PHONE_NUMBER &#x3D;’’’ ||<br>        upper(phone) || ‘’’’;<br>    ELSE<br>      sql_string :&#x3D; sql_string ||’ PHONE_NUMBER &#x3D;’’’ ||<br>        upper(phone) || ‘’’’;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>  END IF; </p>
<p>  IF job !&#x3D; emp_upd_rec.job_id THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, JOB_ID &#x3D;’’’ || job || ‘’’’;<br>    ELSE<br>      sql_string :&#x3D; sql_string ||’ JOB_ID &#x3D;’’’ || job || ‘’’’;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>  END IF; </p>
<p>  IF salary !&#x3D; emp_upd_rec.salary THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, SALARY &#x3D;’ || salary;<br>    ELSE<br>      sql_string :&#x3D; sql_string ||’ SALARY &#x3D;’ || salary;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>  END IF; </p>
<p>  IF commission_pct !&#x3D; emp_upd_rec.commission_pct THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, COMMISSION_PCT &#x3D;’ ||<br>               commission_pct;<br>    ELSE<br>      sql_string :&#x3D; sql_string ||’ COMMISSION_PCT &#x3D;’ ||<br>               commission_pct;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>  END IF; </p>
<p>  IF manager_id !&#x3D; emp_upd_rec.manager_id THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, MANAGER_ID &#x3D;’ ||<br>        manager_id;<br>    ELSE<br>      sql_string :&#x3D; sql_string ||’ MANAGER_ID &#x3D;’ ||<br>        manager_id;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>  END IF;<br>  CHAPTER 8  DYNAMIC SQL<br>167 </p>
<p>   IF department_id !&#x3D; emp_upd_rec.department_id THEN<br>    IF set_count &gt; 0 THEN<br>      sql_string :&#x3D; sql_string ||’, DEPARTMENT_ID &#x3D;’ ||<br>        department_id;<br>    ELSE<br>      sql_string :&#x3D; sql_string ||’ DEPARTMENT_ID &#x3D;’ ||<br>        department_id;<br>      set_count :&#x3D; set_count + 1;<br>    END IF;<br>  END IF; </p>
<p>  sql_string :&#x3D; sql_string || ‘ WHERE employee_id &#x3D; ‘ || id; </p>
<p>  IF set_count &gt; 0 THEN<br>    EXECUTE IMMEDIATE sql_string;<br>  ELSE<br>    DBMS_OUTPUT.PUT_LINE(‘No update needed, ‘ ||<br>        ‘all fields match original values’);<br>  END IF; </p>
<p>EXCEPTION<br>  WHEN NO_DATA_FOUND THEN<br>    DBMS_OUTPUT.PUT_LINE(‘No matching employee found’);<br>  WHEN OTHERS THEN<br>    DBMS_OUTPUT.PUT_LINE(‘Data entry error has occurred, ‘ ||<br>                ‘please check values and try again’ || sql_string);<br>END; </p>
<p>Execution and Results: </p>
<p>SQL&gt; exec update_employees(187,<br>‘Anthony’,<br>‘Cabrio’,<br>‘ACABRIO’,<br>‘650.509.4876’,<br> ‘SH_CLERK’<br>,6501,<br>.08,<br>121,<br>50);<br>No update needed, all fields match original values </p>
<p>As mentioned previously, this procedure accepts input from a user data entry form. The input<br>pertains to an existing employee’s database record. The values accepted as input are compared against<br>those that already exist in the database, and if they are different, then they are added into the SQL UPDATE<br>statement that is dynamically created. This code could be simplified by creating a separate function to<br>take care of comparing values and building the SQL string, but this procedure gives you a good idea of<br>how dynamic SQL can be used to EXECUTE an UPDATE statement.<br>CHAPTER 8  DYNAMIC SQL<br>168<br>How It Works<br>Dynamic SQL statement execution is straightforward when using native dynamic SQL. The procedure in<br>the solution to this recipe creates a SQL string based upon certain criteria, after which it is executed with<br>the use of the EXECUTE IMMEDIATE statement.<br>The EXECUTE IMMEDIATE statement works the same way for most DML statements. If you read Recipe<br>8-3 on creating and running a dynamic INSERT statement, then you can see that executing an UPDATE<br>statement works in the same manner.<br>Any values that need to be substituted into the SQL string should be coded as bind variables. For<br>more information regarding bind variables, please refer to Recipe 8-3. The format for executing an<br>UPDATE statement with the EXECUTE IMMEDIATE statement is as follows: </p>
<p>EXECUTE IMMEDIATE update_statement_string<br>[USING variable1, variable2, etc]; </p>
<p>Just as with the execution of the INSERT statement in Recipe 8-3, the EXECUTE IMMEDIATE statement<br>requires the use of the USING clause only if there are variables that need to be substituted into the SQL<br>statement at runtime.<br>■ Note If you are able to write a static SQL UPDATE statement for your application, then do so. Use of dynamic SQL<br>will incur a small performance penalty.<br>The DBMS_SQL package can also be used to work with dynamic SQL updates. However, this technique<br>is not used very much since the introduction of native dynamic SQL in Oracle 9i. For an example of using<br>the DBMS_SQL package with DML statements, please refer to Recipe 8-3. Although the example in Recipe<br>8-3 demonstrates an INSERT statement, an UPDATE statement is processed the same way; only the SQL<br>string needs to be changed.<br>8-5. Writing a Dynamic Delete Statement<br>Problem<br>You need to create a procedure that will delete rows from a table. However, the exact SQL for deleting<br>the rows is not known until runtime. For instance, you need create a procedure to delete an employee<br>from the EMPLOYEES table, but rather than limit the procedure to accepting only employee ID numbers<br>for employee identification, you also want to accept an e-mail address. The procedure will determine<br>whether an e-mail address or an ID has been passed and will construct the appropriate DELETE<br>statement.<br>Solution<br>Use native dynamic SQL to process a string that is dynamically created based upon values that are<br>passed into the procedure. In the following example, a procedure is created that will build a dynamic<br>SQL string to delete an employee record. The DELETE statement syntax may vary depending upon what<br>type of value is passed into the procedure. Valid entries include EMPLOYEE_ID values or EMAIL values.<br>  CHAPTER 8  DYNAMIC SQL<br>169 </p>
<p>CREATE OR REPLACE PROCEDURE delete_employee(emp_value IN VARCHAR2) AS </p>
<p>  is_number         NUMBER :&#x3D; 0;<br>  valid_flag        BOOLEAN :&#x3D; FALSE;<br>  sql_stmt          VARCHAR2(1000);<br>  emp_count         NUMBER :&#x3D; 0;<br>BEGIN<br>  sql_stmt :&#x3D; ‘DELETE FROM EMPLOYEES ‘; </p>
<p>  – DETERMINE IF emp_value IS NUMERIC, IF SO THEN QUERY<br>  – DATABASE TO FIND OCCURRENCES OF MATCHING EMPLOYEE_ID<br>  IF LENGTH(TRIM(TRANSLATE(emp_value, ‘ +-.0123456789’, ‘ ‘))) IS NULL THEN<br>    SELECT COUNT(*)<br>    INTO emp_count<br>    FROM EMPLOYEES<br>    WHERE EMPLOYEE_ID &#x3D; emp_value; </p>
<pre><code>IF emp_count &gt; 0 THEN 
  sql_stmt := sql_stmt || &#39;WHERE EMPLOYEE_ID = :emp_val&#39;; 
  valid_flag := TRUE; 
END IF; 
</code></pre>
<p>  ELSE<br>    SELECT COUNT(*)<br>    INTO emp_count<br>    FROM EMPLOYEES<br>    WHERE EMAIL &#x3D; upper(emp_value); </p>
<pre><code>IF emp_count &gt; 0 THEN 
  sql_stmt := sql_stmt || &#39;WHERE EMAIL = :emp_val&#39;; 
  valid_flag := TRUE; 
ELSE  
  valid_flag := FALSE; 
END IF; 
</code></pre>
<p>  END IF; </p>
<p>  IF valid_flag &#x3D; TRUE THEN </p>
<pre><code>EXECUTE IMMEDIATE sql_stmt 
USING emp_value; 

DBMS_OUTPUT.PUT_LINE(&#39;Employee has been deleted&#39;); 
</code></pre>
<p>  ELSE<br>    DBMS_OUTPUT.PUT_LINE(‘No matching employee found, please try again’);<br>  END IF; </p>
<p>END; </p>
<p>The procedure can be called by passing in either an EMPLOYEE_ID value or an EMAIL value. If a<br>matching employee record is found, then it will be deleted from the database table.<br>CHAPTER 8  DYNAMIC SQL<br>170<br>How It Works<br>Dynamic SQL can be used to execute DELETE statements as well. In the solution to this recipe, a dynamic<br>SQL string is built that will remove an employee entry that contains a matching EMPLOYEE_ID or EMAIL<br>value that is passed into the procedure as a parameter. The parameter is checked to find out whether it is<br>a numeric or alphanumeric value by using a combination of the LENGTH, TRIM, and TRANSLATE functions. If<br>it is numeric, then it is assumed to be an EMPLOYEE_ID value, and the database is queried to see whether<br>there are any matches. If the parameter is found to be alphanumeric, then it is assumed to be an EMAIL<br>value, and the database is queried to see whether there are any matches. If matches are found in either<br>case, then a dynamic SQL string is built to DELETE the matching record from the database.<br>In this example, native dynamic SQL is used to perform the database operation. The DBMS_SQL<br>package can also be used to perform this task using the same techniques that were demonstrated in<br>Recipe 8-3.<br>8-6. Returning Data from a Dynamic Query into a Record<br>Problem<br>You are writing a block of code that will need to use dynamic SQL to execute a query because the exact<br>SQL string is not known until runtime. The query needs to return the entire contents of the table row so<br>that all columns of data can be used. You want to return the columns into a record variable.<br>Solution<br>Create a native dynamic SQL query to accommodate the SQL string that is unknown until runtime. FETCH<br>the data using BULK COLLECT into a table of records. Our solution example shows rows from the jobs table<br>being fetched into records, after which the individual record columns of data can be worked with. The<br>following code block demonstrates this technique:<br>CREATE OR REPLACE PROCEDURE obtain_job_info(min_sal  NUMBER DEFAULT 0,<br>max_sal  NUMBER DEFAULT 0)<br>AS<br>  sql_text      VARCHAR2(1000);<br>  TYPE job_tab IS TABLE OF jobs%ROWTYPE;<br>  job_list      job_tab;<br>  job_elem      jobs%ROWTYPE;<br>  max_sal_temp  NUMBER;<br>  filter_flag   BOOLEAN :&#x3D; FALSE;<br>  cursor_var    NUMBER;<br>  TYPE          cur_type IS REF CURSOR;<br>  cur           cur_type;<br>BEGIN<br>  sql_text :&#x3D; ‘SELECT * ‘ ||<br>              ‘FROM JOBS WHERE ‘ ||<br>              ‘min_salary &gt;&#x3D; :min_sal ‘ ||<br>              ‘and max_salary &lt;&#x3D; :max_sal’; </p>
<p>  CHAPTER 8  DYNAMIC SQL<br>171<br>  IF max_sal &#x3D; 0 THEN<br>    SELECT max(max_salary)<br>    INTO max_sal_temp<br>    FROM JOBS;<br>  ELSE<br>    max_sal_temp :&#x3D; max_sal;<br>  END IF; </p>
<p>  OPEN cur FOR sql_text USING min_sal, max_sal_temp;<br>  FETCH cur BULK COLLECT INTO job_list;<br>  CLOSE cur; </p>
<p>  FOR i IN job_list.FIRST .. job_list.LAST LOOP<br>    DBMS_OUTPUT.PUT_LINE(job_list(i).job_id || ‘ - ‘ || job_list(i).job_title);<br>  END LOOP; </p>
<p>END; </p>
<p>As the salaries are obtained from the user input, they are used to determine how the bind variables<br>will be populated within the query. The SQL is then executed, and the results are traversed. Each record<br>is fetched and returned into a PL&#x2F;SQL table of job records using BULK_COLLECT, and then in turn, each<br>record is used to process the results. In this example, the data is simply printed out using<br>DBMS_OUTPUT.PUT_LINE, but any number of tasks could be completed with the data.<br>How It Works<br>Dynamic SQL can be processed in a number of ways. In this solution, a record type is created by using<br>the %ROWTYPE attribute of the table that is being queried. In this case, the %ROWTYPE attribute of the JOBS<br>table is being used as a record. The data that is returned from performing a SELECT * on the JOBS table<br>will be stored within that record, and then it will be processed accordingly. The record is created using<br>the following syntax: </p>
<p>record_name     table_name%ROWTYPE; </p>
<p>Using this format, the record_name is any name of your choice that complies with PL&#x2F;SQL’s naming<br>conventions. The table_name is the name of the table from which you will be gathering the data for each<br>column, and the %ROWTYPE attribute is a special table attribute that creates a record type.<br>To process each record, create a REF CURSOR using the dynamic SQL string and perform a BULK<br>COLLECT to fetch each row of data into a record in the table of JOBS records. The BULK COLLECT will load all<br>of the resulting records at once into a PL&#x2F;SQL collection object. Once all the data has been retrieved into<br>an object, it can be processed accordingly. The BULK COLLECT is much more efficient than fetching each<br>row from the table one-by-one using a LOOP construct.<br>8-7. Executing a Dynamic Block of PL&#x2F;SQL<br>Problem<br>You want to execute a specific stored procedure based upon events that occur within your application.<br>Therefore, you need to provide the ability for your application to execute procedures that are unknown<br>until runtime. In short, you want to execute PL&#x2F;SQL in the same dynamic manner as SQL.<br>CHAPTER 8  DYNAMIC SQL<br>172<br>Solution #1<br>Native dynamic SQL can be used to create and execute a block of code at runtime. This strategy can be<br>used to create a dynamic block of code that executes a given procedure when an event occurs. In this<br>example, a procedure is created that accepts an event identifier. An event handler within the application<br>can call upon this procedure passing an event identifier, and subsequently a procedure that can be<br>determined via the identifier will be invoked. </p>
<p>– Create first Procedure<br>CREATE OR REPLACE PROCEDURE TEST_PROCEDURE1 AS<br>BEGIN<br>  DBMS_OUTPUT.PUT_LINE(‘YOU HAVE EXECUTED PROCEDURE 1…’);<br>END; </p>
<p>– Create Second Procedure<br>CREATE OR REPLACE PROCEDURE TEST_PROCEDURE2 AS<br>BEGIN<br>  DBMS_OUTPUT.PUT_LINE(‘YOU HAVE EXECUTED PROCEDURE 2…’);<br>END; </p>
<p>– Create Event Handling Procedure<br>CREATE OR REPLACE PROCEDURE run_test(test_id  IN NUMBER DEFAULT 1) AS<br>  sql_text  VARCHAR2(200);<br>BEGIN<br>  sql_text :&#x3D; ‘BEGIN ‘ ||<br>              ‘  TEST_PROCEDURE’ || test_id || ‘; ‘ ||<br>              ‘END;’; </p>
<p>  EXECUTE IMMEDIATE sql_text; </p>
<p>END; </p>
<p>When an event handler passes a given event number to this procedure, it dynamically creates a code<br>block that is used to execute that procedure, passing the parameters the procedure needs. This solution<br>provides the ultimate flexibility for creating an event handler within your applications.<br>Solution #2<br>DBMS_SQL can also be used to execute the same dynamic code. The following example demonstrates how<br>this is done. </p>
<p>CREATE OR REPLACE PROCEDURE run_test(test_id  IN NUMBER DEFAULT 1) AS<br>  sql_text  VARCHAR2(200);<br>  cursor_var   NUMBER :&#x3D; DBMS_SQL.OPEN_CURSOR;<br>  rows       NUMBER;<br>BEGIN<br>  sql_text :&#x3D; ‘BEGIN ‘ ||<br>              ‘  TEST_PROCEDURE’ || test_id || ‘; ‘ ||<br>              ‘END;’; </p>
<p>  DBMS_SQL.PARSE(cursor_var, sql_text, DBMS_SQL.NATIVE);<br>  CHAPTER 8  DYNAMIC SQL<br>173<br>  rows :&#x3D; DBMS_SQL.EXECUTE(cursor_var);<br>  DBMS_SQL.CLOSE_CURSOR(cursor_var); </p>
<p>END;<br>How It Works<br>Native dynamic SQL allows processing of a SQL statement via the EXECUTE IMMEDIATE statement. This<br>can be used to the advantage of the application and provide the ability to create dynamic blocks of<br>executable code. By doing so, you can create an application that allows more flexibility, which can help<br>ensure that your code is more easily manageable.<br>In the solution to this recipe, an unknown procedure name along with its parameters is<br>concatenated into a SQL string that forms a code block. This code block is then executed using the<br>EXECUTE IMMEDIATE statement.<br>Using native dynamic SQL, the array of parameters has to be manually processed to create the SQL<br>string and assign each of the array values to the USING clause of the EXECUTE IMMEDIATE statement. This<br>technique works quite well, but there is a different way to implement the same procedure.<br>As far as comparing native dynamic SQL and DBMS_SQL for dynamic code block execution, which<br>code is better? That is up to you to decide. If you are using native dynamic SQL for all other dynamic SQL<br>processing within your application, then it is probably a good idea to stick with it instead of mixing both<br>techniques. However, if you are working with some legacy code that perhaps includes a mixture of both<br>DBMS_SQL and native dynamic SQL, then you may prefer to write a dynamic code block using DBMS_SQL<br>just to save some time and processing.<br>8-8. Creating a Table at Runtime<br>Problem<br>Your application needs to have the ability to create tables based upon user input. The user has the ability<br>to add additional attributes to some of your application forms, and when this is done, a new attribute<br>table needs to be created to hold the information.<br>Solution<br>Create a table at runtime using native dynamic SQL. Write a procedure that accepts a table name as an<br>argument and then creates a SQL string including the DDL that is required for creating that table. The<br>table structure will be hard-coded since the structure for an attribute table will always be the same<br>within your application. The code that follows demonstrates this technique by creating a procedure<br>named CREATE_ATTR_TABLE that dynamically creates attribute tables. </p>
<p>CREATE OR REPLACE PROCEDURE create_attr_table(table_name      VARCHAR2) AS<br>  BEGIN<br>    EXECUTE IMMEDIATE ‘CREATE TABLE ‘ || table_name ||<br>                                           ‘(ATTRIBUTE_ID     NUMBER PRIMARY KEY,<br>                                             ATTRIBUTE_NAME   VARCHAR2(150) NOT NULL,<br>                                             ATTRIBUTE_VALUE  VARCHAR2(150))’;<br>  END create_attr_table; </p>
<p>CHAPTER 8  DYNAMIC SQL<br>174<br>This procedure is invoked by the application whenever a user determines that additional attributes<br>are required for a particular application form. That form will then have its own attribute table created,<br>and the user can then provide additional fields&#x2F;attributes to customize the form as needed.<br>How It Works<br>Dynamic SQL can be used to create database objects at runtime. In this recipe, it is used to create tables.<br>Native dynamic SQL is used in this example, and the EXECUTE IMMEDIATE statement performs the work.<br>When creating a table at runtime, generate a string that contains the necessary SQL to create the object.<br>Once that task has been completed, issue the EXECUTE IMMEDIATE statement passing the generated SQL<br>string. The format to use along with the EXECUTE IMMEDIATE statement to create objects is as follows: </p>
<p> EXECUTE IMMEDIATE SQL_string; </p>
<p>The SQL_string in this example is a dynamically created string that will create an object. In the case<br>of creating objects, the USING clause is not used because you cannot use bind variables for substituting<br>object names or attributes such as column names.<br>■ Please use care when concatenating user input variables with SQL text because the technique poses a security<br>concern. Specifically, you open the door to the much-dreaded SQL injection attack. Refer to Recipe 8-14 for more<br>details and for information on protecting yourself.<br>8-9. Altering a Table at Runtime<br>Problem<br>Your application provides the ability to add attributes to forms in order to store additional information.<br>You need to provide users with the ability to make those attribute fields larger or smaller based upon<br>their needs.<br>Solution<br>Create a procedure that will provide the ability to alter tables at runtime using native dynamic SQL. The<br>procedure in this solution will accept two parameters, those being the table name to be altered and the<br>column name along with new type declaration. The procedure assembles a SQL string using the<br>arguments provided by the user and then executes it using native dynamic SQL. The following code<br>demonstrates this solution: </p>
<p>CREATE OR REPLACE PROCEDURE modify_table(tab_name    VARCHAR2,<br>                                         tab_info    VARCHAR2) AS<br>                                         sql_text    VARCHAR2(1000);<br>BEGIN<br>  sql_text :&#x3D; ‘ALTER TABLE ‘ || tab_name ||<br>              ‘ MODIFY ‘ || tab_info;<br>  DBMS_OUTPUT.PUT_LINE(sql_text);<br>  CHAPTER 8  DYNAMIC SQL<br>175<br>  EXECUTE IMMEDIATE sql_text;<br>  DBMS_OUTPUT.PUT_LINE(‘Table successfully altered…’);<br>EXCEPTION<br>  WHEN OTHERS THEN<br>    DBMS_OUTPUT.PUT_LINE(‘An error has occurred, table not modified’);<br>END; </p>
<p>The procedure determines whether the user-defined data is valid. If so, then the EXECUTE IMMEDIATE<br>statement executes the SQL string that was formed. Otherwise, the user will see an alert displayed.<br>How It Works<br>Similar to creating objects at runtime, Oracle provides the ability to alter objects using dynamic SQL.<br>The same technique is used for constructing the SQL string as when creating an object, and that string is<br>eventually executed via the EXECUTE IMMEDIATE statement. The EXECUTE IMMEDIATE statement for altering<br>a table at runtime uses no clause, because it is not possible to use bind variables with an ALTER TABLE<br>statement. If you try to pass in bind variable values, then you will receive an Oracle error.<br>The following format should be used when issuing the EXECUTE IMMEDIATE statement for SQL text<br>containing an ALTER TABLE statement: </p>
<p>EXECUTE IMMEDIATE alter_table_sql_string; </p>
<p>The most important thing to remember when issuing a DDL statement using dynamic SQL is that<br>you will need to concatenate all the strings and variables in order to formulate the final SQL string that<br>will be executed. Bind variables will not work for substituting table names or column names&#x2F;attributes.<br>8-10. Finding All Tables That Include a Specific Column Value<br>Problem<br>You are required to update all instances of a particular data column value across multiple tables within<br>your database.<br>Solution<br>Search all user tables for the particular column you are interested in finding. Create a cursor that will be<br>used to loop through all the results and execute a subsequent UPDATE statement in each iteration of the<br>loop. The UPDATE statement will update all matching column values for the table that is current for that<br>iteration of the cursor.<br>The following example shows how this technique can be performed. The procedure will be used to<br>change a manager ID when a department or job position changes management.  </p>
<p>CREATE OR REPLACE PROCEDURE change_manager(current_manager_id NUMBER, </p>
<p>new_manager_id  NUMBER)<br>AS </p>
<p>cursor manager_tab_cur is<br>select table_name<br>from user_tab_columns<br>CHAPTER 8  DYNAMIC SQL<br>176<br>where column_name &#x3D; ‘MANAGER_ID’<br>and table_name not in (select view_name from user_views); </p>
<p>rec_count            number :&#x3D; 0;<br>ref_count            number :&#x3D; 0; </p>
<p>BEGIN </p>
<p>   – Print out the tables which will be updated </p>
<p>   DBMS_OUTPUT.PUT_LINE(‘Tables referencing the selected MANAGER ID#:’ ||<br> current_manager_id); </p>
<p>   FOR manager_rec IN manager_tab_cur LOOP<br>      EXECUTE IMMEDIATE ‘select count(*) total ‘ ||<br>                        ‘from ‘ || manager_rec.table_name ||<br>                        ‘ where manager_id &#x3D; :manager_id_num’<br>      INTO rec_count<br>      USING current_manager_id; </p>
<pre><code>  if rec_count &gt; 0 then 
               DBMS_OUTPUT.PUT_LINE(manager_rec.table_name || &#39;: &#39; || rec_count); 
               ref_count := ref_count + 1; 
  end if; 

  rec_count := 0; 
</code></pre>
<p>   END LOOP; </p>
<p>   if ref_count &gt; 0 then<br>      DBMS_OUTPUT.PUT_LINE(‘Manager is referenced in ‘ || ref_count || ‘ tables.’);<br>      DBMS_OUTPUT.PUT_LINE(‘…Now Changing the Manager Identifier…’);<br>   end if; </p>
<p>   – Perform the actual table updates </p>
<p>   FOR manager_rec IN manager_tab_cur LOOP<br>      EXECUTE IMMEDIATE ‘select count(*) total ‘ ||<br>                                                  ‘from ‘ || manager_rec.table_name ||<br>                                                  ‘ where manager_id &#x3D; :manager_id_num’<br>      INTO rec_count<br>      USING current_manager_id; </p>
<pre><code>  if rec_count &gt; 0 then 

     EXECUTE IMMEDIATE &#39;update &#39; || manager_rec.table_name || &#39; &#39; || 
                                                 &#39;set manager_id = :new_manager_id &#39; || 
                                                 &#39;where manager_id = :old_manager_id&#39; 
     USING new_manager_id, current_manager_id; 

  end if; 
</code></pre>
<p>  CHAPTER 8  DYNAMIC SQL<br>177<br>      rec_count :&#x3D; 0; </p>
<p>   END LOOP; </p>
<p>   – Print out the tables which still reference the manager number. </p>
<p>   FOR manager_rec IN manager_tab_cur LOOP<br>      EXECUTE IMMEDIATE ‘select count(*) total ‘ ||<br>                        ‘from ‘ || manager_rec.table_name ||<br>                        ‘ where manager_id &#x3D; :manager_id’<br>      INTO rec_count<br>      USING current_manager_id; </p>
<pre><code>  if rec_count &gt; 0 then 
               DBMS_OUTPUT.PUT_LINE(manager_rec.table_name || &#39;: &#39; || rec_count); 
               ref_count := ref_count + 1; 
  end if; 

  rec_count := 0; 
</code></pre>
<p>   END LOOP; </p>
<p>   if ref_count &gt; 0 then<br>      DBMS_OUTPUT.PUT_LINE(‘Manager #: ‘ || current_manager_id<br>                           || ‘ is now referenced in ‘ ||<br>                       ref_count || ‘ tables.’);<br>      DBMS_OUTPUT.PUT_LINE(‘…There should be no tables listed above…’);<br>   end if; </p>
<p>end; </p>
<p>Since MANAGER_ID depends upon a corresponding MANAGER_ID within the DEPARTMENTS table, you must<br>first ensure that the MANAGER_ID that you want to change to is designated to a department within that<br>table. In the following scenario, a manager is added to a department that does not have a manager.<br>Afterward, the manager with ID of 205 is swapped for the newly populated manager. </p>
<p>SQL&gt; update departments<br>  2  set manager_id &#x3D; 241<br>  3  where department_id &#x3D; 270; </p>
<p>1 row updated. </p>
<p>SQL&gt; exec change_manager(205, 241);<br>Tables referencing the selected MANAGER ID#:205<br>DEPARTMENTS: 1<br>EMP: 1<br>EMPLOYEES: 1<br>Manager is referenced in 3 tables.<br>…Now Changing the Manager Identifier…<br>Manager #: 205 is now referenced in 3 tables.<br>…There should be no tables listed above… </p>
<p>CHAPTER 8  DYNAMIC SQL<br>178<br>PL&#x2F;SQL procedure successfully completed.<br>■ Note If you attempt to swap a manager with one that is not associated with a department, then you will receive<br>a foreign key error. This same concept holds true in the real world—ensure that constraints are reviewed before<br>applying this technique.<br>If management decides to change a manager for a particular department, then this procedure will<br>be called. The caller will pass in the old manager’s ID number and the new manager’s ID number. This<br>procedure will then query all tables within the current schema for a matching current manager ID and<br>update it to reflect the new ID number.<br>How It Works<br>To determine all instances of a specific column or database field, you must search all database tables for<br>that column name. Of course, this assumes that the database was created using the same name for the<br>same column in each different table. If columns containing the same data are named differently across<br>tables, then this recipe’s technique will not work.<br>■ Note Although most relational databases are set up with efficiency in mind and only populate data for a specific<br>field value into one database table column, there are some legacy databases that still use the same fields across<br>more than one table.<br>As the solution to this recipe entails, assume that a column name is coded into the procedure, and<br>all tables will then be searched to find out whether that column exists. You can perform the search using<br>the built-in USER_TAB_COLUMNS data dictionary view. This view is comprised of column information for all<br>the tables within a particular schema. Querying any Oracle view that is prefixed with USER_ indicates that<br>the view pertains to data contained within the current user’s schema only. Querying the<br>USER_TAB_COLUMNS view allows a table name and column name to be specified. In this case, since you<br>need to find all tables that contain a specific column, query the USER_TAB_COLUMNS view to return all<br>instances of TABLE_NAME where COLUMN_NAME is equal to the name that is passed into the procedure. This<br>query should be defined as a cursor variable so that it can be parsed via a FOR loop in the code block.<br>■ Warning Be sure to exclude views from this process, or you may receive an error from attempting to update a<br>value that is contained within a view if it is not an updatable view.<br>Now that the cursor is ready to parse all table names that contain a matching column, it is time to<br>loop through the cursor and query each table that contains that column for a matching value. A user<br>  CHAPTER 8  DYNAMIC SQL<br>179<br>passes two values into the procedure: current manager ID and new manager ID. In the solution to this<br>recipe, each table that contains a matching column is queried so that you can see how many matches<br>were found prior to the updates taking place. A counter is used to tally the number of matches found<br>throughout the tables. Next, looping through the cursor again performs the actual updates. This time,<br>the tables are each queried to find matches again, but when a match is found, then that table will be<br>updated so that the value is changed from the old value to the new value.<br>Lastly, the cursor is parsed again, and each table is queried to find existing matches once again. This<br>last loop is done for consistency and to ensure that all matches have been found and updated to the<br>current value. If any matches are found during this last loop, then all changes should be rolled back, and<br>the changes should be manually processed instead.<br>This procedure can be updated to work with any column value change that may be needed. The<br>code can also be shortened significantly if you do not want to perform verifications prior to and after<br>performing an update.<br>8-11 Storing Dynamic SQL in Large Objects<br>Problem<br>The SQL code that you need to assemble at runtime is likely to exceed the 32KB limit that is bound to<br>VARCHAR2 types. You need to be able to store dynamic SQL text in a type that will allow more for a large<br>amount of text.<br>Solution #1<br>Declare a CLOB variable, and store your SQL string within it. After the CLOB has been created, execute the<br>SQL. This can be done using either native dynamic SQL or the DBMS_SQL package. For the example,<br>assume that a block of text is being read from an external file, and it will be passed to a procedure to be<br>processed. That text will be the SQL string that will be dynamically processed within the procedure.<br>Since the external text file can be virtually any size, this text must be read into a CLOB data type and then<br>passed to the procedure in this example for processing. The following procedure processes the CLOB as<br>dynamic SQL.<br>The first example demonstrates the parsing and execution of a dynamic SQL statement that has<br>been stored in a CLOB using the DBMS_SQL package. Note that this procedure does not return any value, so<br>it is not meant for issuing queries but rather for executing code. </p>
<p>CREATE OR REPLACE PROCEDURE execute_clob(sql_text CLOB) AS<br>  sql_string    CLOB;<br>  cur_var       BINARY_INTEGER;<br>  ret_var       INTEGER;<br>  return_value  VARCHAR2(100);<br>BEGIN<br>  sql_string :&#x3D; sql_text;<br>  cur_var :&#x3D; DBMS_SQL.OPEN_CURSOR;<br>  DBMS_SQL.PARSE(cur_var, sql_string, DBMS_SQL.NATIVE);<br>  ret_var :&#x3D; DBMS_SQL.EXECUTE(cur_var);<br>  DBMS_SQL.CLOSE_CURSOR(cur_var);<br>END;<br>CHAPTER 8  DYNAMIC SQL<br>180<br>Solution #2<br>The second example is the same procedure written to use native dynamic SQL. You will notice that the<br>code is a bit shorter, and there is less work that needs to be done in order to complete the same<br>transaction.<br>CREATE OR REPLACE PROCEDURE execute_clob_nds(sql_text    IN CLOB) AS<br>  sql_string    CLOB;<br>BEGIN<br>  sql_string :&#x3D; sql_text;<br>  EXECUTE IMMEDIATE sql_string;<br>END;<br>As noted previously, the native dynamic SQL is easier to follow and takes less code to implement.<br>For the sake of maintaining a current code base, use of native dynamic SQL would be encouraged.<br>However, DBMS_SQL is still available and offers different options as mentioned in the first recipes in this<br>chapter.<br>How It Works<br>Oracle added some new features for working with dynamic SQL into the Oracle Database 11g release.<br>Providing the ability to store dynamic SQL into a CLOB is certainly a useful addition. Prior to Oracle<br>Database 11g, the only way to dynamically process a string that was larger than 32KB was to concatenate<br>two VARCHAR types that were at or near 32KB in size. The largest string that could be processed by native<br>dynamic SQL was 64KB. With the release of Oracle Database 11g, the CLOB (character large object) can be<br>used in such cases, mitigating the need to concatenate two different variables to form the complete SQL.<br>Using DBMS_SQL and its PARSE function, SQL that is stored within a CLOB can be easily processed. The<br>following lines of code are the lines from the first solution that read and process the CLOB:<br>cur_var :&#x3D; DBMS_SQL.OPEN_CURSOR;<br>DBMS_SQL.PARSE(cur_var, v_sql, DBMS_SQL.NATIVE);<br>ret_var :&#x3D; DBMS_SQL.EXECUTE(cur_var);<br>DBMS_SQL.CLOSE_CURSOR(cur_var);<br>The first line opens a new cursor using DBMS_SQL.OPEN_CURSOR. It assigns an integer to the cur_var<br>variable, which is then passed to the DBMS_SQL.PARSE procedure. DBMS_SQL.PARSE also accepts the SQL<br>CLOB and a constant DBMS_SQL.NATIVE that helps discern the dialect that should be used to process the<br>SQL. The dialect is also referred to as the language_flag, and it is used to determine how Oracle will<br>process the SQL statement. Possible values include V6 for version 6 behavior, V7 for Oracle database 7<br>behavior, and NATIVE to specify normal behavior for the database to which the program is connected.<br>After the SQL has been parsed, it can be executed using the DBMS_SQL.EXECUTE function. This function<br>will accept the cursor variable as input and execute the SQL. A code of 0 is returned if the SQL is<br>executed successfully. Lastly, remember to close the cursor using DBMS_SQL.CLOSE_CURSOR and passing<br>the cursor variable to it.<br>The example in Solution #2 of this recipe demonstrates the use of native dynamic SQL for execution<br>of dynamic SQL text that is stored within a CLOB. Essentially no differences exist between the execution of<br>SQL text stored in a VARCHAR data type as opposed to SQL text stored within a CLOB for native dynamic<br>SQL. The code is short and precise, and it is easy to read.<br>  CHAPTER 8  DYNAMIC SQL<br>181<br>8-12. Passing NULL Values to Dynamic SQL<br>Problem<br>You want to pass a NULL value to a dynamic query that you are using. For example, you want to query the<br>EMPLOYEES table for all records that have a NULL MANAGER_ID value.<br>Solution<br>Create an uninitialized variable, and place it into the USING clause. In this example, a dynamic query is<br>written and executed using native dynamic SQL. The dynamic query will retrieve all employees who do<br>not currently have a manager assigned to their record. To retrieve the records that are required, the<br>WHERE clause needs to filter the selection so that only records containing a NULL MANAGER_ID value are<br>returned. </p>
<p>DECLARE<br>  TYPE cur_type IS REF CURSOR;<br>  cur                cur_type;<br>  null_value         CHAR(1);<br>  sql_string         VARCHAR2(150);<br>  emp_rec            employees%ROWTYPE;<br>BEGIN<br>  sql_string :&#x3D; ‘SELECT * ‘ ||<br>                    ‘FROM EMPLOYEES ‘ ||<br>                    ‘WHERE MANAGER_ID IS :null_val’; </p>
<p>  OPEN cur FOR sql_string USING null_value;<br>  LOOP<br>    FETCH cur INTO emp_rec;<br>    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ‘ ‘ || emp_rec.last_name ||<br>                                                        ‘ - ‘ || emp_rec.email);<br>    EXIT WHEN cur%NOTFOUND;<br>  END LOOP;<br>  CLOSE cur;<br> END; </p>
<p>In this solution, the bind variable :null_val has an uninitialized variable value substituted in its<br>place. This will cause the query to evaluate the bind variable as a NULL value. All records that reside<br>within the EMPLOYEES table and do not have a MANAGER_ID assigned to them should be printed by the<br>DBMS_OUTPUT package.<br>How It Works<br>It is not possible to simply pass a NULL value using native dynamic SQL. At least, you cannot pass a NULL<br>as a literal. However, oftentimes it is useful to initialize a bind variable to null.<br>An uninitialized variable in PL&#x2F;SQL inherently has the value of NULL. Hence, if you do not initialize a<br>variable, then it will contain a NULL value. Passing an uninitialized variable via the EXECUTE IMMEDIATE<br>statement will have the same effect as substituting a NULL value for a bind variable.<br>CHAPTER 8  DYNAMIC SQL<br>182<br>8-13. Switching Between DBMS_SQL and Native Dynamic SQL<br>Problem<br>Your consulting company is currently migrating all its applications from using DBMS_SQL to native<br>dynamic SQL. To help ensure that the migration can be done piecemeal, you want to provide the ability<br>to switch between the two different techniques so that legacy code can coexist with the newer native<br>dynamic SQL.<br>Solution<br>When you need both the DBMS_SQL package and native dynamic SQL, you can switch between them using<br>the DBMS_SQL.TO_REFCURSOR and DBMS_SQL.TO_CURSOR_NUMBER APIs. The DBMS_SQL.TO_REFCURSOR API<br>provides the ability to execute dynamic SQL using the DBMS_SQL package and then convert the DBMS_SQL<br>cursor to a REF CURSOR. The DBMS_SQL.TO_CURSOR_NUMBER API allows for executing dynamic SQL via a REF<br>CURSOR and then converting to DBMS_SQL for data retrieval.<br>The following example illustrates the usage of DBMS_SQL.TO_REFCURSOR. In the example, a simple<br>dynamic query is being executed using DBMS_SQL, and the cursor is then being converted to a REF CURSOR. </p>
<p>DECLARE<br>  sql_string           CLOB;<br>  cur_var              BINARY_INTEGER :&#x3D; DBMS_SQL.OPEN_CURSOR;<br>  ref_cur              SYS_REFCURSOR;<br>  return_value         BINARY_INTEGER;<br>  cur_rec              jobs%ROWTYPE;<br>  salary               NUMBER :&#x3D; &amp;salary;<br>BEGIN<br>  – Formulate query<br>  sql_string :&#x3D; ‘SELECT * FROM JOBS ‘ ||<br>                      ‘WHERE MAX_SALARY &gt;&#x3D; :sal’;<br>  – Parse SQL<br>  DBMS_SQL.PARSE(cur_var, sql_string, DBMS_SQL.NATIVE); </p>
<p>  – Bind variable(s)<br>  DBMS_SQL.BIND_VARIABLE(cur_var, ‘sal’, salary); </p>
<p>  – Execute query and convert to REF CURSOR </p>
<p>  return_value :&#x3D; DBMS_SQL.EXECUTE(cur_var);<br>  ref_cur :&#x3D; DBMS_SQL.TO_REFCURSOR(cur_var);<br>  DBMS_OUTPUT.PUT_LINE(‘Jobs that have a maximum salary over ‘ || salary);<br>  LOOP<br>    FETCH ref_cur INTO cur_rec;<br>    DBMS_OUTPUT.PUT_LINE(cur_rec.job_id || ‘ - ‘ || cur_rec.job_title);<br>    EXIT WHEN ref_cur%NOTFOUND;<br>  END LOOP; </p>
<p>  CLOSE ref_cur; </p>
<p>END;<br>  CHAPTER 8  DYNAMIC SQL<br>183 </p>
<p>The example prompts for the entry of a maximum salary via the :sal bind variable and the SQL*Plus<br>&amp;salary substitution variable. The DBMS_SQL API then binds the maximum salary that was entered to the<br>dynamic SQL string and executes the query to find all jobs that have a maximum salary greater than the<br>amount that was entered. Once the query is executed, the cursor is converted to a REF CURSOR using the<br>DBMS_SQL.TO_REFCURSOR API. Native dynamic SQL is then used to process the results of the query. As you<br>can see, the native dynamic SQL is much easier to read and process. The advantage of converting to a<br>REF CURSOR is to have the ability to easily process code using native dynamic SQL but still have some of<br>the advantages of using DBMS_SQL for querying the data. For instance, if the number of bind variables was<br>unknown until runtime, then DBMS_SQL would be required.<br>A similar technique can be used if DBMS_SQL is required to process the results of a query. The<br>DBMS_SQL.TO_CURSOR_NUMBER API provides the ability to convert a cursor from a REF CURSOR to DBMS_SQL.<br>The following example shows the same query on the JOBS table, but this time native dynamic SQL is used<br>to set up the query and execute it, and DBMS_SQL is used to describe the table structure. One of the nice<br>features of the DBMS_SQL API is that it is possible to describe the columns of a query that will be returned. </p>
<p>DECLARE<br>  sql_string         CLOB;<br>  ref_cur            SYS_REFCURSOR;<br>  cursor_var         BINARY_INTEGER;<br>  cols_var           BINARY_INTEGER;<br>  desc_var           DBMS_SQL.DESC_TAB;<br>  v_job_id           NUMBER;<br>  v_job_title        VARCHAR2(25);<br>  salary             NUMBER(6) :&#x3D; &amp;salary;<br>  return_val         NUMBER; </p>
<p>BEGIN<br>  – Formulate query<br>  sql_string :&#x3D; ‘SELECT * FROM JOBS ‘ ||<br>                          ‘WHERE MAX_SALARY &gt;&#x3D; :sal’;<br>  – Open REF CURSOR<br>  OPEN ref_cur FOR sql_string USING salary; </p>
<p>  cursor_var :&#x3D; DBMS_SQL.TO_CURSOR_NUMBER(ref_cur);<br>  DBMS_SQL.DESCRIBE_COLUMNS(cursor_var, cols_var, desc_var);<br>  DBMS_SQL.CLOSE_CURSOR(cursor_var); </p>
<p>  FOR x IN 1 .. cols_var LOOP<br>    DBMS_OUTPUT.PUT_LINE(desc_var(x).col_name || ‘ - ‘ ||<br>                           CASE desc_var(x).col_type<br>                                      WHEN 1 THEN ‘VARCHAR2’<br>                                      WHEN 2 THEN ‘NUMBER’<br>                           ELSE ‘OTHER’<br>                           END);<br>  END LOOP;<br>END; </p>
<p>Each of these techniques has their place within the world of PL&#x2F;SQL programming. Using this type<br>of conversion is especially useful for enabling your application to use the features DBMS_SQL has to offer<br>without compromising the ease and structure of native dynamic SQL.<br>CHAPTER 8  DYNAMIC SQL<br>184<br>How It Works<br>Oracle Database 11g added some new capabilities to dynamic SQL. One of those new features is the<br>ability to convert between native dynamic SQL and DBMS_SQL. DBMS_SQL provides some functionality that<br>is not offered by the newer and easier native dynamic SQL API. Now that Oracle Database 11g provides<br>the ability to make use of native dynamic SQL but still gain the advantages of using DBMS_SQL, Oracle<br>dynamic SQL is much more complete.<br>The DBMS_SQL.TO_REFCURSOR API is used to convert SQL that is using DBMS_SQL into a REF CURSOR,<br>which allows you to work with the resulting records using native dynamic SQL. To convert SQL to a REF<br>CURSOR, you will use DBMS_SQL to parse the SQL, bind any variables, and finally to execute it. Afterward,<br>you call DBMS_SQL.TO_REFCURSOR and pass the original DBMS_SQL cursor as an argument. This will return a<br>REF CURSOR that can be used to work with the results from the query. The statement that performs the<br>conversion contains DBMS_SQL.EXECUTE. The EXECUTE function accepts a DBMS_SQL cursor as an argument.<br>As a result, a REF CURSOR is returned, and it can be used to work with the results from the dynamic query.<br>Conversely, DBMS_SQL.TO_CURSOR_NUMBER can be used to convert a REF CURSOR into a DBMS_SQL cursor.<br>You may choose to do this in order to use some additional functionality that DBMS_SQL has to offer such<br>as the ability to DESCRIBE an object (DESCRIBE is a SQL*Plus feature). As you can see in the second<br>example, native dynamic SQL is used to open the REF CURSOR and bind the variable to the SQL. Once this<br>has been completed, the cursor is converted to DBMS_SQL using DBMS_SQL.TO_CURSOR_NUMBER and passing<br>the REF CURSOR. After this conversion is complete, you can utilize the DBMS_SQL API to work with the<br>resulting cursor.<br>8-14. Guarding Against SQL Injection Attacks<br>Problem<br>To provide the best security for your application, you want to ensure that your dynamic SQL statements<br>are unable to be altered as a result of data entered from an application form.<br>Solution<br>Take care to provide security against SQL injection attacks by validating user input prior and using it in<br>your dynamic SQL statements or queries. The easiest way to ensure that there are no malicious<br>injections into your SQL is to make use of bind variables.<br>The following code is an example of a PL&#x2F;SQL procedure that is vulnerable to SQL injection because<br>it concatenates a variable that is populated with user input and does not properly validate the input<br>prior: </p>
<p>CREATE OR REPLACE PROCEDURE check_password(username IN VARCHAR2) AS<br>  sql_stmt    VARCHAR2(1000);<br>  password    VARCHAR2(30);<br>BEGIN<br> sql_stmt :&#x3D; ‘SELECT password ‘ ||<br>                       ‘FROM user_records ‘ ||<br>                       ‘WHERE username &#x3D; ‘’’ || username || ‘’’;<br>  EXECUTE sql_stmt<br>  INTO password; </p>
<p>  – PROCESS PASSWORD<br>END;<br>  CHAPTER 8  DYNAMIC SQL<br>185 </p>
<p>To properly code this example to guard against SQL injection, use bind variables. The following is<br>the same procedure that has been rewritten to make it invulnerable to SQL injection: </p>
<p>CREATE OR REPLACE PROCEDURE check_password(username IN VARCHAR2) AS<br>  sql_stmt    VARCHAR2(1000);<br>  password    VARCHAR2(30);<br>BEGIN<br>  sql_stmt :&#x3D; ‘SELECT password ‘ ||<br>              ‘FROM user_records ‘ ||<br>              ‘WHERE username &#x3D; :username’; </p>
<p>  EXECUTE sql_stmt<br>  INTO password<br>  USING username; </p>
<p>  – PROCESS PASSWORD<br>END; </p>
<p>Making just a couple of minor changes can significantly increase the security against SQL injection<br>attacks.<br>How It Works<br>SQL injection attacks can occur when data that is accepted as input from an application form is<br>concatenated into dynamic SQL queries or statements without proper validation. SQL injection is a form<br>of malicious database attack that is caused by a user placing some code or escape characters into a form<br>field so that the underlying application SQL query or statement becomes affected in an undesirable<br>manner. In the solution to this recipe, all passwords stored in the USER_RECORDS table could be<br>compromised if a malicious user were to place a line of text similar to the following into the form field<br>for the USERNAME: </p>
<p>‘WHATEVER ‘’ OR username is NOT NULL–’ </p>
<p>The strange-looking text that you see here can cause major issues because it essentially changes the<br>query to read as follows: </p>
<p>SELECT password<br>FROM user_records<br>WHERE username &#x3D; ‘WHATEVER ‘ OR username is NOT NULL; </p>
<p>Bind variables can be used to guard against SQL injection attacks, because their contents are not<br>interpreted at all by Oracle. The value of a bind variable is never parsed as part of the string containing<br>the SQL query or statement to be executed. Thus, the use of bind variables provides absolute protection<br>against SQL injection attacks.<br>Another way to safeguard your code against SQL injection attacks is to validate user input to ensure<br>that it is not malicious. Only valid input should be used within a statement or query.<br>There are ways to validate user input depending upon the type of input you are receiving. For<br>instance, to verify the integrity of user input, you can use regular expressions. If you are expecting to<br>receive an e-mail address from a user input field, then the value that is passed into your code should be<br>verified to ensure that it is in proper format of an e-mail address. Here’s an example:<br>CHAPTER 8  DYNAMIC SQL<br>186<br>IF owa_pattern.match(email_variable,’^\w{1,}[.,0-9,a-z,A-Z,<em>]\w{1,}’ ||<br>           ‘[.,0-9,a-z,A-Z,</em>]\w{1,}’||<br>           ‘@\w{1,}[.,0-9,a-z,A-Z,<em>]&#39; ||<br>           ‘w{1,}[.,0-9,a-z,A-Z,</em>]\w{1,}[.,0-9,a-z,A-Z,_]\w{1,}$’) then<br>  – Perform valid transaction<br>ELSE<br>  – Raise an error message </p>
<p>It is imperative that you do not allow users of your applications to see the Oracle error codes that are<br>returned by an error. Use proper exception handling (covered in Chapter 9) to ensure that you are<br>catching any possible exceptions and returning a vaguely descriptive error message to the user. It is not<br>wise to allow Oracle errors or detailed error messages to be displayed because they will most likely<br>provide a malicious user with valuable information for attacking your database.<br>Using bind variables, validating user input, and displaying user-friendly and appropriate error<br>messages can help ensure that your database is not attacked. It is never an enjoyable experience to<br>explain to your users that all usernames and passwords were compromised. Time is much better spent<br>securing your code than going back to clean up after a malicious attack.<br>C H A P T E R  9 </p>
<p>   </p>
<p>187<br>Exceptions<br>Exceptions are a fundamental part of any well-written program. They are used to display user-friendly<br>error messages when an error is raised by an application, nondefault exception handling, and<br>sometimes recovery so that an application can continue. Surely you have seen your fair share of ORA-<br>XXXXX error messages. Although these messages are extremely useful to a developer for debugging and<br>correcting issues, they are certainly foreign to the average application user and can be downright<br>frightening to see.<br>Imagine that you are working with a significant number of updates via an application form, and<br>after you submit your 150th update, an Oracle error is displayed. Your first reaction would be of panic,<br>hoping that you haven’t just lost all of the work you had completed thus far. By adding exception<br>handling to an application, you can ensure that exceptions are handled in an orderly fashion so that no<br>work is lost. You can also create a nicer error message to let the user know all changes have been saved<br>up to this point so that sheer panic doesn’t set in when the exception is raised.<br>Exceptions can also be raised as a means to provide informative detail regarding processes that are<br>occurring within your application. They are not merely restricted to being used when Oracle encounters<br>an issue. You can raise your own exceptions as well when certain circumstances are encountered in your<br>application.<br>Whatever the case may be, exception handling should be present in any production-quality<br>application code. This chapter will cover some basics of how to use exception handling in your code.<br>Along the way, you will learn some key tips on how exception handling can make your life easier. In the<br>end, you should be fully armed to implement exception handling for your applications.<br>9-1. Trapping an Exception<br>Problem<br>A procedure in your application has the potential to cause an exception to be raised. Rather than let the<br>program exit and return control to the host machine, you want to perform some cleanup to ensure data<br>integrity, as well as display an informative error message.<br>Solution<br>Write an exception handler for your procedure so that the exception can be caught and you can perform<br>tasks that need to be completed and provide a more descriptive message. The following procedure is<br>used to obtain employee information based upon a primary key value or an e-mail address. Beginning<br>with the EXCEPTION keyword in the following example, an exception-handling block has been added to<br>the end of the procedure in order to handle any exceptions that may occur when no matching record is<br>found. </p>
<p>CHAPTER 9  EXCEPTIONS<br>188<br>CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS<br>  emp_qry            VARCHAR2(500);<br>  emp_first          employees.first_name%TYPE;<br>  emp_last           employees.last_name%TYPE;<br>  email              employees.email%TYPE; </p>
<p>  valid_id_count     NUMBER :&#x3D; 0;<br>  valid_flag         BOOLEAN :&#x3D; TRUE;<br>  temp_emp_info      VARCHAR2(50); </p>
<p>BEGIN<br>  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;<br>  IF emp_info LIKE ‘%@%’ THEN<br>    temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);<br>    emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;<br>  ELSE<br>    SELECT COUNT(*)<br>    INTO valid_id_count<br>    FROM employees<br>    WHERE employee_id &#x3D; emp_info; </p>
<pre><code>IF valid_id_count &gt; 0 THEN 
    temp_emp_info := emp_info; 
    emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; 
ELSE 
    valid_flag := FALSE; 
END IF; 
</code></pre>
<p>  END IF; </p>
<p>  IF valid_flag &#x3D; TRUE THEN<br>    EXECUTE IMMEDIATE emp_qry<br>    INTO emp_first, emp_last, email<br>    USING temp_emp_info; </p>
<pre><code>DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); 
</code></pre>
<p>  ELSE<br>    DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||<br>                         ‘NOT MATCH ANY EMPLOYEE RECORD’);<br>  END IF; </p>
<p>  EXCEPTION<br>    WHEN NO_DATA_FOUND THEN<br>      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||<br>                         ‘NOT MATCH ANY EMPLOYEE RECORD’);<br>    WHEN INVALID_NUMBER THEN<br>      DBMS_OUTPUT.PUT_LINE(‘YOU MUST ENTER AN EMAIL ADDRESS INCLUDING ‘ ||<br>                         ‘THE @ OR A POSITIVE INTEGER VALUE FOR THE ‘ ||<br>                         ‘EMPLOYEE ID.’);<br>END; </p>
<p>Here are the results of calling the procedure with various arguments: </p>
<p>  CHAPTER 9  EXCEPTIONS<br>189<br>SQL&gt; EXEC OBTAIN_EMP_DETAIL(000);<br>THE INFORMATION YOU HAVE USED DOES NOT MATCH ANY EMPLOYEE RECORD </p>
<p>PL&#x2F;SQL procedure successfully completed. </p>
<p>SQL&gt; EXEC OBTAIN_EMP_DETAIL(‘TEST’);<br>YOU MUST ENTER AN EMAIL ADDRESS INCLUDING THE @ OR A POSITIVE INTEGER VALUE FOR<br>THE EMPLOYEE ID. </p>
<p>PL&#x2F;SQL procedure successfully completed. </p>
<p>SQL&gt; EXEC OBTAIN_EMP_DETAIL(200);<br>Jennifer Whalen - JWHALEN </p>
<p>PL&#x2F;SQL procedure successfully completed. </p>
<p>This procedure is essentially the same as the one demonstrated in Recipe 8-1. The difference is that<br>when an exception is raised, the control will go into the exception block. At that time, the code you place<br>within the exception block will determine the next step to take as opposed to simply raising an Oracle<br>error and returning control to the calling procedure, calling function, or host environment.<br>How It Works<br>To perform remedial actions when an exception is raised, you should always make sure to code an<br>exception handler if there is any possibility that an exception may be thrown. The sole purpose of an<br>exception handler is to catch exceptions when they are raised and handle the outcome in a controlled<br>fashion. There are two different types of exceptions that can be raised by a PL&#x2F;SQL application:<br>internally defined and user defined. Oracle Database has a defined set of internal exceptions that can be<br>thrown by a PL&#x2F;SQL application. Those exceptions are known as internally defined. It is also possible to<br>define your own exceptions, which are known as user defined.<br>An exception-handling block is structured like a CASE statement in that a series of exceptions is listed<br>followed by a separate set of statements to be executed for each outcome. The standard format for an<br>exception-handling block is as follows: </p>
<p>EXCEPTION<br>  WHEN name_of_exception THEN<br>    – One or more statements </p>
<p>Exception blocks begin with the EXCEPTION keyword, followed by a series of WHEN..THEN clauses that<br>describe different possible exceptions along with the set of statements that should be executed if the<br>exception is caught. The exception name can be one of the Oracle internally defined exceptions, or it can<br>be the name of an exception that has been declared within your code. To learn more about declaring<br>exceptions, please see Recipe 9-3 in this chapter. In the solution to this recipe, the internally defined<br>NO_DATA_FOUND exception is raised if an unknown e-mail address is entered into the procedure because<br>there will be no rows returned from the query. When the exception block encounters the WHEN clause that<br>corresponds with NO_DATA_FOUND, the statements immediately following the THEN keyword are executed.<br>In this case, an error message is printed using the DBMS_OUTPUT package. However, in a real-world<br>application, this is where you will place any cleanup or error handling that should be done to help<br>maintain the integrity of the data accessed by your application.<br>An exception block can contain any number of WHEN..THEN clauses, and therefore, any number of<br>exceptions can each contain their own set of handler statements. Even if a simple message was to be<br>CHAPTER 9  EXCEPTIONS<br>190<br>displayed, as is the case with the solution to this recipe, a different and more descriptive error message<br>can be coded for each different exception that may possibly be raised. This situation is reflected in the<br>second exception handler contained within the solution because it returns a different error message<br>than the first.<br>As mentioned previously, Oracle contains a number of internally defined exceptions. Table 9-1<br>provides a list of the internally defined exceptions, along with a description of their usage.<br>Table 9-1. Oracle Internal Exceptions<br>Exception Code Description<br>ACCESS_INTO_NULL -6530 Values are assigned to an uninitialized object.<br>CASE_NOT_FOUND -6592 No matching choice is available within CASE statement, and no<br>ELSE clause has been defined.<br>COLLECTION_IS_NULL  -6531 Program attempts to apply collection methods other than<br>EXISTS to varray or a nested table that has not yet been<br>initialized.<br>CURSOR_ALREADY_OPEN -6511 Program attempts to open a cursor that is already open.<br>DUP_VAL_ON_INDEX -1 Program attempts to store duplicate values in a unique index<br>column.<br>INVALID_CURSOR -1001 Program attempts to use a cursor operation that is allowed.<br>INVALID_NUMBER -1722 Conversion of string into number is incorrect because of the<br>string not being a number.<br>LOGIN_DEINIED -1017 Program attempts to log in to the database using an incorrect<br>user name and&#x2F;or password.<br>NO_DATA_FOUND +100 SELECT statement returns no rows.<br>NOT_LOGGED_ON -1012 Program attempts to issue a database call without being<br>connected to the database.<br>PROGRAM_ERROR -6501 Internal problem exists.<br>ROWTYPE_MISMATCH -6504 Cursor variables are incompatible. A host cursor variable must<br>have a compatible return type that matches a PL&#x2F;SQL cursor<br>variable.<br>SELF_IS_NULL -30625 Instance of object type is not initialized.<br>STORAGE_ERROR -6500 PL&#x2F;SQL ran out of memory or was corrupted.<br>  CHAPTER 9  EXCEPTIONS<br>191<br>Exception Code Description<br>SUBSCRIPT_BEYOND_COUNT  – 6533  Program references nested table or varray element using an<br>index number that goes beyond the number of elements<br>within the object.<br>SYS_INVALID_ROWID -1410  Conversion of character string into ROWID fails because<br>character string does not represent a valid row ID.<br>TIMEOUT_ON_RESOURCE -51  Oracle Database is waiting for resource, and timeout occurs.<br>TOO_MANY_ROWS -1422  Attempts to select more than one row using a SELECT INTO<br>statement.<br>VALUE_ERROR -6502  Program attempts to perform an invalid arithmetic,<br>conversion, or truncation operation.<br>ZERO_DIVIDE -1476  Program attempts to divide a number by zero. </p>
<p>An exception handler’s scope corresponds to its enclosing code block. They have the same scope as<br>a variable would have within a code block. If your code contains a nested code block, an exception<br>handler that is contained within the nested code block can only handle exceptions raised within that<br>code block. The outer code block can contain an exception handler that will handle exceptions for both<br>the outer code block and the nested code block. If an exception is raised within the nested code block<br>and there is no corresponding handler for an exception that has been raised within the nested code<br>block, then the exception is propagated to the outer code block to look for a corresponding handler<br>there. If no handler is found, then runtime will be passed to the procedure or function that called it or<br>the host system, which is what you do not want to have occur. The following code demonstrates an<br>example of using an exception handler within a nested code block: </p>
<p>DECLARE<br>  CURSOR emp_cur IS<br>  SELECT *<br>  FROM EMPLOYEES; </p>
<p>  emp_rec emp_cur%ROWTYPE;<br>BEGIN<br>  FOR emp_rec IN emp_cur LOOP<br>    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ‘ ‘ ||<br>         emp_rec.last_name);<br>    DECLARE<br>      emp_dept  departments.department_name%TYPE;<br>    BEGIN<br>      SELECT department_name<br>      INTO emp_dept<br>      FROM departments<br>      WHERE department_id &#x3D; emp_rec.department_id;<br>      DBMS_OUTPUT.PUT_LINE(‘Department: ‘ || emp_dept);<br>    EXCEPTION<br>CHAPTER 9  EXCEPTIONS<br>192<br>      WHEN NO_DATA_FOUND THEN<br>        DBMS_OUTPUT.PUT_LINE(‘EXCEPTION IN INNER BLOCK’);<br>    END;<br>  END LOOP;<br>EXCEPTION<br>  WHEN NO_DATA_FOUND THEN<br>   DBMS_OUTPUT.PUT_LINE(‘EXCEPTION IN OUTER BLOCK’);<br>END; </p>
<p>Multiple exceptions can be listed within the same exception handler if you want to execute the same<br>set of statements when either of them is raised. You can do this within the WHEN clause by including two<br>or more exception names and placing the OR keyword between them. Using this technique, if either of<br>the exceptions that are contained within the clause is raised, then the set of statements that follows will<br>be executed. Let’s take a look at an exception handler that contains two exceptions within the same<br>handler: </p>
<p>EXCEPTION<br>  WHEN NO_DATA_FOUND OR INVALID_EMAIL_ADDRESS THEN<br>    –  statements to execute<br>  WHEN OTHERS THEN<br>    –  statements to execute<br>END;<br>■ Note You cannot place the AND keyword in between exceptions because no two exceptions can be raised at the<br>same time.<br>It is easy to include basic exception handling in your application. Code an exception-handling block<br>at the end of each code block that may raise an exception. It is pertinent that you test your application<br>under various conditions to try to predict which possible exceptions may be raised; each of those<br>possibilities should be accounted for within the exception-handling block of your code.<br>9-2. Catching Unknown Exceptions<br>Problem<br>Some exceptions are being raised when executing one of your procedures and you want to ensure that<br>all unforeseen exceptions are handled using an exception handler.<br>Solution<br>Use an exception handler, and specify OTHERS for the exception name to catch all the exceptions that<br>have not been caught by previous handlers. In the following example, the same code from Recipe 9-1<br>has been modified to add an OTHERS exception handler: </p>
<p>CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS<br>  emp_qry                   VARCHAR2(500);<br>  CHAPTER 9  EXCEPTIONS<br>193<br>  emp_first                 employees.first_name%TYPE;<br>  emp_last                  employees.last_name%TYPE;<br>  email                     employees.email%TYPE; </p>
<p>  valid_id_count            NUMBER :&#x3D; 0;<br>  valid_flag                BOOLEAN :&#x3D; TRUE;<br>  temp_emp_info             VARCHAR2(50); </p>
<p>BEGIN<br>  emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;<br>  IF emp_info LIKE ‘%@%’ THEN<br>    temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);<br>    emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;<br>  ELSE<br>    SELECT COUNT(*)<br>    INTO valid_id_count<br>    FROM employees<br>    WHERE employee_id &#x3D; emp_info; </p>
<pre><code>IF valid_id_count &gt; 0 THEN 
    temp_emp_info := emp_info; 
    emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; 
ELSE 
    valid_flag := FALSE; 
END IF; 
</code></pre>
<p>  END IF; </p>
<p>  IF valid_flag &#x3D; TRUE THEN<br>    EXECUTE IMMEDIATE emp_qry<br>    INTO emp_first, emp_last, email<br>    USING temp_emp_info; </p>
<pre><code>DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); 
</code></pre>
<p>  ELSE<br>    DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||<br>                         ‘NOT MATCH ANY EMPLOYEE RECORD’);<br>  END IF; </p>
<p>  EXCEPTION<br>    WHEN NO_DATA_FOUND THEN<br>      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||<br>                         ‘NOT MATCH ANY EMPLOYEE RECORD’);<br>    WHEN OTHERS THEN<br>      DBMS_OUTPUT.PUT_LINE(‘AN UNEXPECTED ERROR HAS OCCURRED, PLEASE ‘ ||<br>                         ‘TRY AGAIN’);<br>END; </p>
<p>In this example, if an unexpected exception were to be raised, then the program control would<br>transfer to the statements immediately following the WHEN OTHERS THEN clause.<br>CHAPTER 9  EXCEPTIONS<br>194<br>■ Note In a real-world application, an exception should be manually reraised within the OTHERS handler. To learn<br>more about determining the exception that was raised, please see Recipe 9-4.<br>How It Works<br>You can use the OTHERS handler to catch all the exceptions that have not been previously handled by any<br>named exception handler. It is a good idea to include an OTHERS handler with any exception handler so<br>that any unknown exceptions can be handled reasonably by your application. However, OTHERS should<br>be used only to assist developers in finding application bugs rather than as a catchall for any exception.<br>The format for using the OTHERS handler is the same as it is with other named exceptions; the only<br>difference is that it should be the last handler to be coded in the exception handler. The following<br>pseudocode depicts a typical exception handler that includes an OTHERS handler: </p>
<p>EXCEPTION<br>  WHEN named_exception1 THEN<br>    – perform statements<br>  WHEN named_exception2 THEN<br>    – perform statements<br>  WHEN OTHERS THEN<br>    – perform statements<br>WHEN TO USE THE OTHERS HANDLER<br>It is important to note that the OTHERS handler is not used to avoid handling expected exceptions properly.<br>Each exception that may possibly be raised should be handled within its own exception-handling block.<br>The OTHERS handler should be used only to catch those exceptions that are not expected. Most often, the<br>OTHERS handler is used to catch application bugs in order to assist a developer in finding and resolving<br>issues.<br>As stated, the OTHERS handler will catch any exception that has not yet been caught by another<br>handler. It is very important to code a separate handler for each type of named exception that may<br>occur. However, if you have one set of statements to run for any type of exception that may occur, then it<br>is reasonable to include only an OTHERS exception handler to catch exceptions that are unexpected. If no<br>named exceptions are handled and an exception handler includes only an OTHERS handler, then the<br>statements within that handler will be executed whenever any exception occurs within an application.<br>9-3. Creating and Raising Named Programmer-Defined Exceptions<br>Problem<br>You want to alert the users of your application when a specific event occurs. The event does not raise an<br>Oracle exception, but it is rather an application-specific exception. You want to associate this event with<br>a custom exception so that it can be raised whenever the event occurs.<br>  CHAPTER 9  EXCEPTIONS<br>195<br>Solution<br>Declare a named user-defined exception, and associate it with the event for which you are interested in<br>raising an exception. In the following example, a user-defined exception is declared and raised within a<br>code block. When the exception is raised, the application control is passed to the statements contained<br>within the exception handler for the named user exception. </p>
<p>CREATE OR REPLACE PROCEDURE salary_increase(emp_id IN NUMBER,<br>                                            pct_increase IN NUMBER) AS </p>
<p>  salary                employees.salary%TYPE;<br>  max_salary            jobs.max_salary%TYPE;<br>  INVALID_INCREASE      EXCEPTION; </p>
<p>BEGIN </p>
<p>  SELECT salary, max_salary<br>  INTO salary, max_salary<br>  FROM employees, jobs<br>  WHERE employee_id &#x3D; emp_id<br>  AND jobs.job_id &#x3D; employees.employee_id; </p>
<p>  IF (salary + (salary * pct_increase)) &lt;&#x3D; max_salary THEN<br>    UPDATE employees<br>    SET salary &#x3D; (salary + (salary * pct_increase))<br>    WHERE employee_id &#x3D; emp_id; </p>
<pre><code>DBMS_OUTPUT.PUT_LINE(&#39;SUCCESSFUL SALARY INCREASE FOR EMPLOYEE #: &#39; || 
      emp_id || 
      &#39;.  NEW SALARY = &#39; || salary + (salary * pct_increase)); 
      
</code></pre>
<p>  ELSE<br>    RAISE INVALID_INCREASE;<br>  END IF; </p>
<p>EXCEPTION<br>  WHEN NO_DATA_FOUND THEN<br>    DBMS_OUTPUT.PUT_LINE(‘UNSUCCESSFUL INCREASE, NO EMPLOYEE RECORD FOUND ‘ ||<br>                  ‘FOR THE GIVEN ID’); </p>
<p>  WHEN INVALID_INCREASE THEN<br>    DBMS_OUTPUT.PUT_LINE(‘UNSUCCESSFUL INCREASE.  YOU CANNOT INCREASE THE ‘ ||<br>                  ‘EMPLOYEE SALARY BY ‘ || pct_increase ||<br>                  ‘PERCENT…PLEASE ENTER ‘ ||<br>                  ‘A SMALLER INCREASE AMOUNT TO TRY AGAIN’); </p>
<p>  WHEN OTHERS THEN<br>CHAPTER 9  EXCEPTIONS<br>196<br>    DBMS_OUTPUT.PUT_LINE(‘UNSUCCESSFUL INCREASE.  AN UNKNOWN ERROR HAS ‘||<br>                  ‘OCCURRED, ‘ ||<br>                  ‘PLEASE TRY AGAIN OR CONTACT ADMINISTRATOR’ || pct_increase); </p>
<p>END; </p>
<p>As you can see from the code, the exception block can accept one or more handlers. The named<br>user exception is declared within the declaration section of the procedure, and the exception can be<br>raised anywhere within the containing block.<br>■ Note In a real-world application, an exception should be manually raised within the OTHERS handler. To learn<br>more about determining the exception that was raised, please see Recipe 9-4.<br>How It Works<br>A PL&#x2F;SQL application can contain any number of custom exceptions. When a developer declares their<br>own exception, it is known as a user-defined exception. A user-defined exception must be declared<br>within the declaration section of a package, function, procedure, or anonymous code block. To declare<br>an exception, use the following: </p>
<p>exception_name  EXCEPTION; </p>
<p>You can provide any name as long as it applies to the standard naming convention and is not the<br>same as an internally defined exception name. It is a coding convention to code exception names using<br>uppercase lettering, but lowercase would work as well since PL&#x2F;SQL is not a case-sensitive language.<br>To raise your exception, type the RAISE keyword followed by the name of the exception that you<br>want to raise. When the code executes the RAISE statement, control is passed to the exception handler<br>that best matches the exception that was named in the statement. If no handler exists for the exception<br>that was raised, then control will be passed to the OTHERS handler, if it exists. In the worst-case scenario,<br>if there are not any exception handlers that match the name that was provided in the RAISE statement<br>and there has not been an OTHERS handler coded, then control will be passed back to the enclosing block,<br>the calling code, or the host environment.<br>The RAISE statement can also be used in a couple of other ways. It is possible to raise an exception<br>that has been declared within another package. To do so, fully qualify the name of the exception by<br>prefixing it with the package name. The RAISE statement can also be used stand-alone to reraise an<br>exception.<br>As seen in the solution to this recipe, catching a named user exception is exactly the same as<br>catching an internally defined exception. Code the WHEN..THEN clause, naming the exception that you<br>want to catch. When the exception is raised, any statements contained within that particular exception<br>handler will be executed.<br>  CHAPTER 9  EXCEPTIONS<br>197<br>9-4. Determining Which Error Occurred Inside the OTHERS Handler<br>Problem<br>Your code is continually failing via an exception, and the OTHERS handler is being invoked. You need to<br>determine the exact cause of the exception so that it can be repaired.<br>Solution<br>Code the OTHERS exception handler as indicated by Recipe 9-2, and use the SQLCODE and<br>DBMS_UTILITY.FORMAT_ERROR_STACK functions to return the Oracle error code and message text for the<br>exception that has been raised. The following example demonstrates the usage of these functions, along<br>with the procedure that was used in Recipe 9-3, for obtaining the error code and message when the<br>OTHERS handler is invoked. </p>
<p>CREATE OR replace PROCEDURE salary_increase(emp_id       IN NUMBER,<br>                                            pct_increase IN NUMBER)<br>AS<br>  salary              employees.salary%TYPE;<br>  max_salary          jobs.max_salary%TYPE;<br>  invalid_increase    EXCEPTION;<br>  error_number        NUMBER;<br>  error_message       VARCHAR2(1500);<br>BEGIN<br>  SELECT salary,<br>         max_salary<br>  INTO   salary, max_salary<br>  FROM   employees,<br>         jobs<br>  WHERE  employee_id &#x3D; emp_id<br>         AND jobs.job_id &#x3D; employees.employee_id;  </p>
<p>  IF ( salary + ( salary * pct_increase ) ) &lt;&#x3D; max_salary THEN<br>    UPDATE employees<br>    SET    salary &#x3D; ( salary + ( salary * pct_increase ) )<br>    WHERE  employee_id &#x3D; emp_id;  </p>
<pre><code>dbms_output.Put_line(&#39;SUCCESSFUL SALARY INCREASE FOR EMPLOYEE #: &#39;  
                     || emp_id  
                     || &#39;.  NEW SALARY = &#39;  
                     || salary + ( salary * pct_increase ));  
</code></pre>
<p>  ELSE<br>    RAISE invalid_increase;<br>  END IF;<br>EXCEPTION<br>  WHEN no_data_found THEN<br>    dbms_output.Put_line(‘UNSUCCESSFUL INCREASE, NO EMPLOYEE RECORD FOUND ‘<br>                     || ‘FOR THE ‘<br>                     || ‘GIVEN ID’); WHEN invalid_increase THEN<br>    dbms_output.Put_line(‘UNSUCCESSFUL INCREASE.  YOU CANNOT INCREASE THE ‘<br>                     || ‘EMPLOYEE ‘<br>CHAPTER 9  EXCEPTIONS<br>198<br>                     || ‘SALARY BY ‘<br>                     || pct_increase<br>                     || ‘ PERCENT…PLEASE ENTER ‘<br>                     || ‘A SMALLER INCREASE AMOUNT TO TRY AGAIN’);<br>WHEN OTHERS THEN<br>           error_number :&#x3D; SQLCODE;  </p>
<pre><code>       error_message := DBMS_UTILITY.FORMAT_ERROR_STACK;  

dbms_output.Put_line(&#39;UNSUCCESSFUL INCREASE.  AN UNKNOWN ERROR HAS &#39; 
                 || &#39;OCCURRED, &#39;  
                 || &#39;PLEASE TRY AGAIN OR CONTACT ADMINISTRATOR&#39;  
                 || &#39; Error #: &#39;  
                 || error_number  
                 || &#39; - &#39;  
                 || error_message); 
</code></pre>
<p>END;  </p>
<p>When this procedure is executed, the following error will be returned: </p>
<p>UNSUCCESSFUL INCREASE.  AN UNKNOWN ERROR HAS OCCURRED, PLEASE TRY AGAIN OR CONTACT<br>ADMINISTRATOR Error #: -1722 - ORA-01722: invalid number </p>
<p>This example intentionally raises an error in order to demonstrate the functionality of these utilities.<br>A reference to the line number that raised the error may also be helpful. To learn more about writing an<br>exception handler that returns line numbers, please see Recipe 9-9.<br>How It Works<br>The SQLCODE and DBMS_UTILITY.FORMAT_ERROR_STACK functions provide the means to determine what<br>code and message had caused the last exception that was raised. The SQLCODE function will return the<br>Oracle error number for internal exceptions and +1 for a user-defined exception. The<br>DBMS_UTILITY.FORMAT_ERROR_STACK function will return the Oracle error message for any internal<br>exception that is raised, and it will contain the text User-Defined Exception for any named user<br>exception that is raised. A user-defined exception may receive a custom error number, as you will read<br>about in Recipe 9-9. In such cases, the SQLCODE function will return this custom error number if raised.<br>To use these functions, you must assign them to a variable because they cannot be called outright.<br>For instance, if you wanted to use the SQLCODE within a CASE statement, you would have to assign the<br>function to a variable first. Once that has been done, you could use the variable that was assigned the<br>SQLCODE in the statement.<br>Oracle includes DBMS_UTILITY.FORMAT_ERROR_STACK, which can be used to return the error message<br>associated with the current error. DBMS_UTILITY.FORMAT_ERROR_STACK can hold up to 1,899 characters, so<br>there is rarely a need to truncate the message it returns. SQLERRM is a similar function that can be used to<br>return the error message, but it only allows messages up to 512 bytes to be displayed. Oftentimes,<br>SQLERRM messages need to be truncated for display. Oracle recommends using<br>DBMS_UTILITY.FORMAT_ERROR_STACK over SQLERRM because this utility doesn’t have such a small message<br>limitation.<br>However, SQLERRM does have its place, because there are some benefits of using it. A handy feature of<br>SQLERRM is that you can pass an error number to it and retrieve the corresponding error message. Any<br>error number that is passed to SQLERRM should be negative; otherwise, you will receive the message User-<br>  CHAPTER 9  EXCEPTIONS<br>199<br>defined error. Table 9-2 displays the error number ranges and their corresponding messages using<br>SQLCODE and SQLERRM.<br>Table 9-2. SQLCODE Return Codes and Meanings<br>Code Description<br>Negative Oracle Error Number  Internal Oracle exception<br>0 No exceptions raised<br>+1 User-defined exception<br>+100 NO_DATA_FOUND<br>-20000 to -20999 User-defined error with PRAGMA EXCEPTION_INIT<br>■ Note PRAGMA EXCEPTION_INIT is used to associate an Oracle error number with an exception name.<br>If you choose to use SQLERRM, the code is not much different from using<br>DBMS_UTILITY.FORMAT_ERROR_STACK, but you will probably need to include some code to truncate the<br>result. The next example demonstrates the same example that was used in the solution to this recipe, but<br>it uses SQLERRM instead of DBMS_UTILITY.FORMAT_ERROR_STACK. </p>
<p>CREATE OR replace PROCEDURE salary_increase(emp_id       IN NUMBER,<br>                                            pct_increase IN NUMBER)<br>AS<br>  salary             employees.salary%TYPE;<br>  max_salary         jobs.max_salary%TYPE;<br>  invalid_increase   EXCEPTION;<br>  error_number       NUMBER;<br>  error_message      VARCHAR2(1500);<br>BEGIN<br>  SELECT salary,<br>         max_salary<br>  INTO   salary, max_salary<br>  FROM   employees,<br>         jobs<br>  WHERE  employee_id &#x3D; emp_id<br>         AND jobs.job_id &#x3D; employees.employee_id;  </p>
<p>  IF ( salary + ( salary * pct_increase ) ) &lt;&#x3D; max_salary THEN<br>    UPDATE employees<br>    SET    salary &#x3D; ( salary + ( salary * pct_increase ) )<br>    WHERE  employee_id &#x3D; emp_id;  </p>
<p>CHAPTER 9  EXCEPTIONS<br>200<br>    dbms_output.Put_line(‘SUCCESSFUL SALARY INCREASE FOR EMPLOYEE #: ‘<br>                         || emp_id<br>                         || ‘.  NEW SALARY &#x3D; ‘<br>                         || salary + ( salary * pct_increase ));<br>  ELSE<br>    RAISE invalid_increase;<br>  END IF;<br>EXCEPTION<br>  WHEN no_data_found THEN<br>    dbms_output.Put_line(‘UNSUCCESSFUL INCREASE, NO EMPLOYEE RECORD FOUND ‘<br>                     || ‘FOR THE ‘<br>                     || ‘GIVEN ID’); WHEN invalid_increase THEN<br>    dbms_output.Put_line(‘UNSUCCESSFUL INCREASE.  YOU CANNOT INCREASE THE ‘<br>                     || ‘EMPLOYEE ‘<br>                     || ‘SALARY BY ‘<br>                     || pct_increase<br>                     || ‘ PERCENT…PLEASE ENTER ‘<br>                     || ‘A SMALLER INCREASE AMOUNT TO TRY AGAIN’);<br>WHEN OTHERS THEN<br>           error_number :&#x3D; SQLCODE;<br>           error_message :&#x3D; Substr(sqlerrm, 1, 150);<br>dbms_output.Put_line(‘UNSUCCESSFUL INCREASE.  AN UNKNOWN ERROR HAS OCCURRED, ‘<br>                     || ‘PLEASE TRY AGAIN OR CONTACT ADMINISTRATOR’<br>                     || ‘ Error #: ‘<br>                     || error_number<br>                     || ‘ - ‘<br>                     || error_message);<br>END;<br>There are some other tools that can be used to further diagnose which errors are being raised and<br>even to see the entire stack trace. These tools are further explained within Recipe 9-9. By combining the<br>techniques learned in this recipe with those you will learn about in Recipe 9-9, you are sure to have a<br>better chance of diagnosing your application issues.<br>9-5. Raising User-Defined Exceptions Without an Exception Handler<br>Problem<br>Your application includes some error handling that is specific to your application. For instance, you<br>want to ensure that the input value for a procedure is in the valid format to be an e-mail address. Rather<br>than writing an exception handler for each user-defined exception, you want to simply raise the<br>exception inline and provide an error number as well.<br>Solution<br>This scenario is perfect for using the RAISE_APPLICATION_ERROR procedure. Test the e-mail address that is<br>passed into the procedure to ensure that it follows certain criteria. If it does not contain a specific<br>  CHAPTER 9  EXCEPTIONS<br>201<br>characteristic of a valid e-mail address, use the RAISE_APPLICATION_ERROR procedure to display an<br>exception message to the user. Here’s an example: </p>
<p>CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_email IN VARCHAR2) IS<br>  emp_qry       VARCHAR2(500);<br>  emp_first     employees.first_name%TYPE;<br>  emp_last      employees.last_name%TYPE;<br>  email         employees.email%TYPE; </p>
<p>  valid_id_count        NUMBER :&#x3D; 0;<br>  valid_flag            BOOLEAN :&#x3D; TRUE;<br>  temp_emp_info         VARCHAR2(50); </p>
<p>  BEGIN<br>    emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;<br>    IF emp_email LIKE ‘%@%’ THEN<br>      temp_emp_info :&#x3D; substr(emp_email,0,instr(emp_email,‘@’)-1);<br>      emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_email’;<br>    ELSIF emp_email NOT LIKE ‘%.mycompany.com’ THEN<br>      RAISE_APPLICATION_ERROR(-20001, ‘Not a valid email address from ‘ ||<br>                            ‘this company!’);<br>    ELSE<br>      RAISE_APPLICATION_ERROR(-20002, ‘Not a valid email address!’);<br>    END IF; </p>
<pre><code>IF valid_flag = TRUE THEN 
  EXECUTE IMMEDIATE emp_qry 
  INTO emp_first, emp_last, email 
  USING temp_emp_info; 

  DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); 
ELSE  
  DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || 
                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); 
END IF; 
</code></pre>
<p>END; </p>
<p>As you can see, there is no exception handler in this example. When the conditions are met, an<br>exception is raised inline via RAISE_APPLICATION_EXCEPTION.<br>How It Works<br>The RAISE_APPLICATION_EXCEPTION procedure can associate an error number with an error message. The<br>format for calling the RAISE_APPLICATION_EXCEPTION procedure is as follows: </p>
<p>RAISE_APPLICATION_EXCEPTION(exception_number,<br>                           exception_message[, retain_error_stack]); </p>
<p>where exception_number is a number within the range of -20000 to -20999, and exception_message is a<br>string of text that is equal to or less than 2KB in length. The optional retain_error_stack is a BOOLEAN<br>CHAPTER 9  EXCEPTIONS<br>202<br>value that tells Oracle whether this exception should be added to the existing error stack or whether the<br>error stack should be wiped clean and this exception should be placed into it. By default, the value is<br>FALSE, and all other exceptions are removed from the error stack, leaving this exception as the only one<br>in the stack.<br>When you invoke the procedure, the current block is halted immediately, and the exception is<br>raised. No further processing takes place within the current block, and control is passed to the program<br>that called the block or an enclosing block if the current block is nested. Therefore, if you need to<br>perform any exception handling, then it needs to take place prior to calling<br>RAISE_APPLICATION_EXCEPTION. There is no commit or rollback, so any updates or changes that have been<br>made will be retained if you decide to issue a commit. Any OUT and IN OUT values, assuming you are in a<br>procedure or a function, will be reverted. This is important to keep in mind, because it will help you<br>determine whether to use an exception handler or issue a call to RAISE_APPLICATION_ERROR.<br>When calling RAISE_APPLICATION_EXCEPTION, you pass an error number along with an associated<br>exception message. Oracle sets aside the range of numbers from -20000 to -20999 for use by its<br>customers for the purpose of declaring exceptions. Be sure to use a number within this range, or Oracle<br>will raise its own exception to let you know that you are out of line and using one of its proprietary error<br>numbers!<br>■ Note There are some numbers within that range that are still used by Oracle-specific exceptions. Passing a<br>TRUE value as the last argument in a call to RAISE_APPLICATION_EXCEPTION will retain any existing errors in the<br>error stack. Passing TRUE is a good idea for the purposes of debugging so that the stack trace can be used to help<br>find the code that is raising the exception. Otherwise, the exception stack is cleared.<br>One may choose to create a function or procedure that has the sole purpose of calling<br>RAISE_APPLICATION_EXCEPTION to raise an exception and associate an error number with an exception<br>message. This technique can become quite useful if you are interested in using a custom error number<br>for your exceptions, but you still need to perform proper exception handling when errors occur. You<br>could use the OTHERS exception handler to call the function or procedure that uses<br>RAISE_APPLICATION_EXCEPTION, passing the error number and a proper exception message.<br>9-6. Redirecting Control After an Exception Is Raised<br>Problem<br>After an exception is raised within an application, usually the statements within the exception handler<br>are executed, and then control goes to the next statement in the calling program or outside the current<br>code block. Rather than printing an error message and exiting your code block after an exception, you<br>want to perform some further activity. For instance, let’s say you are interested in logging the exception<br>in a database table. You have a procedure for adding entries to the log table, and you want to make use<br>of that procedure.<br>  CHAPTER 9  EXCEPTIONS<br>203<br>Solution<br>Invoke the procedure from within the exception handler. When the exception is raised, program control<br>will be passed to the appropriate handler. The handler itself can provide an exception message for the<br>user, but it will also call the procedure that is to be used for logging the exception in the database. The<br>following example demonstrates this technique: </p>
<p>CREATE OR REPLACE PROCEDURE log_error_messages(error_code  IN NUMBER,<br>                                                message    IN VARCHAR2) AS<br>PRAGMA AUTONOMOUS_TRANSACTION;<br>BEGIN<br>  DBMS_OUTPUT.PUT_LINE(message);<br>  DBMS_OUTPUT.PUT_LINE(‘WRITING ERROR MESSAGE TO DATABASE’);<br>END; </p>
<p>CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS<br>  emp_qry                 VARCHAR2(500);<br>  emp_first                employees.first_name%TYPE;<br>  emp_last                   employees.last_name%TYPE;<br>  email                         employees.email%TYPE; </p>
<p>  valid_id_count         NUMBER :&#x3D; 0;<br>  valid_flag                  BOOLEAN :&#x3D; TRUE;<br>  temp_emp_info       VARCHAR2(50); </p>
<p> BEGIN<br>    emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;<br>    IF emp_info LIKE ‘%@%’ THEN<br>      temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);<br>      emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;<br>    ELSE<br>      SELECT COUNT(*)<br>      INTO valid_id_count<br>      FROM employees<br>      WHERE employee_id &#x3D; emp_info; </p>
<pre><code>  IF valid_id_count &gt; 0 THEN 
      temp_emp_info := emp_info; 
      emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; 
  ELSE 
      valid_flag := FALSE; 
  END IF; 
END IF; 

IF valid_flag = TRUE THEN 
  EXECUTE IMMEDIATE emp_qry 
  INTO emp_first, emp_last, email 
  USING temp_emp_info; 

  DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); 
ELSE  
</code></pre>
<p>CHAPTER 9  EXCEPTIONS<br>204<br>      DBMS_OUTPUT.PUT_LINE(‘THE INFORMATION YOU HAVE USED DOES ‘ ||<br>                           ‘NOT MATCH ANY EMPLOYEE RECORD’);<br>    END IF; </p>
<pre><code>EXCEPTION 
  WHEN NO_DATA_FOUND THEN 
     
    DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || 
                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); 
    log_error_messages(SQLCODE, DBMS_UTILITY.FORMAT_ERROR_STACK); 
     
  WHEN OTHERS THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;AN UNEXPECTED ERROR HAS OCCURRED, PLEASE &#39; || 
                       &#39;TRY AGAIN&#39;); 
    log_error_messages(SQLCODE, DBMS_UTILITY.FORMAT_ERROR_STACK); 
</code></pre>
<p> END; </p>
<p>In this scenario, the log_error_messages procedure would be called from within each of the<br>exception handlers. Since it is an autonomous transaction, the log_error_messages procedure will<br>execute without affecting the calling procedure. This ensures that no issues will arise if<br>log_error_messages were to raise an exception. Control of the application would be passed to this<br>procedure for the processing, and then the program would exit.<br>How It Works<br>It is possible to redirect control of your code after an exception has been raised using various<br>techniques. After an exception is raised and control is redirected to the handler, the statements within<br>the handler are executed, and then that program ends. If the code block that contains the exception<br>handler is contained within enclosing code block, control will be passed to the next statement within the<br>enclosing control block. Otherwise, the program will exit after statements are executed.<br>To execute a particular action or series of processes after an exception has been raised, it is a useful<br>technique to call a stored procedure or function from within the exception handler. In the solution to<br>this recipe, a logging procedure is called that will insert a row into the logging table after each exception<br>is raised. This allows the program control to be passed to the procedure or function that is called, and<br>when that body of code has completed execution, control is passed back to the exception handler. This<br>is a very useful technique for logging exceptions but can also be used for various other tasks such as<br>sending an e-mail alert or performing some database cleanup.<br>9-7. Raising Exceptions and Continuing Processing<br>Problem<br>The application you are coding requires a series of INSERT, UPDATE, and DELETE statements to be called.<br>You want to add proper exception handling to your code and also ensure that processing continues and<br>all of the statements are executed even if an exception is raised.<br>Solution<br>Enclose each statement within its own code block, and provide an exception handler for each of the<br>blocks. When an exception is raised within one of the nested blocks, then control will be passed back to<br>  CHAPTER 9  EXCEPTIONS<br>205<br>the main code block, and execution will continue. This style of coding is displayed in the following<br>example: </p>
<p>CREATE OR REPLACE PROCEDURE delete_employee (in_emp_id   IN NUMBER) AS<br>  BEGIN<br>    – ENTER INITIAL NESTED CODE BLOCK TO PERFORM DELETE<br>    BEGIN<br>        – DELETE EMP<br>    EXCEPTION<br>      WHEN NO_DATA_FOUND THEN<br>         – perform statements<br>    END; </p>
<pre><code> -- ENTER SECOND NESTED CODE BLOCK TO PERFORM LOG ENTRY 
 BEGIN 
    -- LOG DELETION OF  EMP 
EXCEPTION 
  WHEN NO_DATA_FOUND THEN 
     -- perform statements 
END; 
</code></pre>
<p>EXCEPTION WHEN OTHERS THEN<br>  – perform statements<br>END; </p>
<p>As this code stands, no exception will go on to become an unhanded exception because the<br>outermost code block contains an exception handler using the OTHERS exception name. Every nested<br>code block contains a handler, so every exception that is encountered in this application will be caught.<br>How It Works<br>Scope plays an important role when designing your application’s exception-handling system. When<br>doing so, you should think of your application and determine whether portions of the code need to be<br>executed regardless of any exception being raised. If this is the case, then you will need to provide proper<br>exception handling and still ensure that the essential code is executed each run.<br>The scope of an exception pertains to the code block in which the exception is declared. Once an<br>exception has been encountered, program control halts immediately and is passed to the exception<br>handler for the current block. If there is not an exception handler in the current code block or if no<br>handler matches the exception that was raised, then control passes to the calling program or outer<br>control block. Control is immediately passed to the exception handler of that program. If no exception<br>handler exists or matches the exception being raised, then the execution of that block halts, and the<br>exception is raised to the next calling program or outer code block, and so on.<br>This pattern can be followed any number of times. That is why the technique used in the solution to<br>this recipe works well. There is one main code block that embodies two nested code blocks. Each of the<br>blocks contains essential statements that need to be run. If an exception is raised within the DELETE<br>block, then program control is passed back to its outer code block, and processing continues. In this<br>case, both essential statements will always be executed, even if exceptions are raised.<br>CHAPTER 9  EXCEPTIONS<br>206<br>9-8. Associating Error Numbers with Exceptions That Have No Name<br>Problem<br>You want to associate an error number to those errors that do not have predefined names.<br>Solution<br>Make use of PRAGMA EXCEPTION_INIT to tell the compiler to associate an Oracle error number with an<br>exception name. This will allow the use of an easy-to-identify name rather than an obscure error<br>number when working with the exception. The example in this recipe shows how an error number can<br>be associated with an exception name and how the exception can later be raised. </p>
<p>CREATE OR REPLACE FUNCTION calculate_salary_hours(salary  IN NUMBER,<br>                                              hours   IN NUMBER DEFAULT 1)<br>RETURN NUMBER AS<br>BEGIN<br>  RETURN salary&#x2F;hours;<br>END; </p>
<p>DECLARE<br>  DIVISOR_IS_ZERO  EXCEPTION;<br>  PRAGMA EXCEPTION_INIT(DIVISOR_IS_ZERO, -1476);<br>  per_hour      NUMBER;<br>BEGIN<br>  SELECT calculate_salary_hours(0,0)<br>  INTO per_hour<br>  FROM DUAL;<br>EXCEPTION WHEN DIVISOR_IS_ZERO THEN<br>  DBMS_OUTPUT.PUT_LINE(‘You cannot pass a zero for the number of hours’);<br>END; </p>
<p>The exception declared within this example is associated with the ORA-01476 error code. When a<br>divide-by-zero exception occurs, then the handler is executed.<br>How It Works<br>PRAGMA EXCEPTION_INIT allows an error number to be associated with an error name. Thus, it provides an<br>easy way to handle those exceptions that are available only by default via an error number. It is much<br>easier to identify an exception by name rather than by number, especially when you have been away<br>from the code base for some length of time.<br>The PRAGMA EXCEPTION_INIT must be declared within the declaration section of your code. The<br>exception that is to be associated with the error number must be declared prior to the PRAGMA<br>declaration. The format for using PRAGMA EXCEPTION_INIT is as follows: </p>
<p>DECLARE<br>  exception_name   EXCEPTION;<br>  PRAGMA EXCEPTION_INIT(exception_name, &lt;<exception_code>&gt;);<br>BEGIN<br>  CHAPTER 9  EXCEPTIONS<br>207<br>  – Perform statements<br>EXCEPTION<br>  WHEN exception_name THEN<br>    – Perform error handling<br>END; </p>
<p>The exception_name in this pseudocode refers to the name of the exception you are declaring. The<br>&lt;<exception_code>&gt; is the number of the ORA-xxxxx error that you are associating with the exception. In<br>the solution to this recipe, ORA-01476 is associated with the exception. That exception in particular<br>denotes divisor is equal to zero. When this exception is raised, it is easier to identify the cause of the<br>error via the DIVISOR_IS_ZERO identifier than by the -01476 code.<br>Whenever possible, it is essential to provide an easy means of identification for portions of code that<br>may be difficult to understand. Exception numbers by themselves are not easily identifiable unless you<br>see the exception often enough. Even then, an exception handler with the number -01476 in it seems<br>obscure. In this case, it is always best to associate a more common name to the exception so that the<br>code can instantly have meaning to someone who is unfamiliar with the code or to you when you need<br>to maintain the code for years to come.<br>9-9. Tracing an Exception to Its Origin<br>Problem<br>Your application continues to raise an exception that is being caught with the OTHERS handler. You’ve<br>used SQLCODE and DBMS_UTILITY.FORMAT_ERROR_STACK to help you find the cause of the exception but are<br>still unable to do so.<br>Solution<br>Use the stack trace for the exception to trace the error back to its origination. In particular, use<br>DBMS_UTILITY.FORMAT_ERROR_BACKTRACE and DBMS_UTILITY.FORMAT_CALL_TRACE to help you find the cause<br>of the exception. The following solution demonstrates the use of FORMAT_ERROR_BACKTRACE: </p>
<p>CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS<br>  emp_qry             VARCHAR2(500);<br>  emp_first           employees.first_name%TYPE;<br>  emp_last            employees.last_name%TYPE;<br>  email               employees.email%TYPE; </p>
<p>  valid_id_count      NUMBER :&#x3D; 0;<br>  valid_flag          BOOLEAN :&#x3D; TRUE;<br>  temp_emp_info       VARCHAR2(50); </p>
<p> BEGIN<br>    emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;<br>    IF emp_info LIKE ‘%@%’ THEN<br>      temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);<br>      emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;<br>    ELSE<br>      SELECT COUNT(*)<br>CHAPTER 9  EXCEPTIONS<br>208<br>      INTO valid_id_count<br>      FROM employees<br>      WHERE employee_id &#x3D; emp_info; </p>
<pre><code>  IF valid_id_count &gt; 0 THEN 
      temp_emp_info := emp_info; 
      emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; 
  ELSE 
      valid_flag := FALSE; 
  END IF; 
END IF; 

IF valid_flag = TRUE THEN 
  EXECUTE IMMEDIATE emp_qry 
  INTO emp_first, emp_last, email 
  USING temp_emp_info; 

  DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); 
ELSE  
  DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || 
                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); 
END IF; 

EXCEPTION 
  WHEN NO_DATA_FOUND THEN 
     
    DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || 
                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); 
    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE); 
     
  WHEN OTHERS THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;AN UNEXPECTED ERROR HAS OCCURRED, PLEASE &#39; || 
                       &#39;TRY AGAIN&#39;); 
    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE); 
</code></pre>
<p> END; </p>
<p>Here are the results when calling within invalid argument information: </p>
<p>SQL&gt; exec obtain_emp_detail(‘junea@’);<br>THE INFORMATION YOU HAVE USED DOES NOT MATCH ANY EMPLOYEE RECORD<br>ORA-06512: at “OBTAIN_EMP_DETAIL”, line 32 </p>
<p>PL&#x2F;SQL procedure successfully completed. </p>
<p>As you can see, the exact line number that caused the exception to be raised is displayed. This is<br>especially useful if you use a development environment that includes line numbering for your source<br>code. If not, then you can certainly count out the line numbers manually.<br>Similarly, DBMS_UTILITY.FORMAT_CALL_STACK lists the object number, line, and object where the issue<br>had occurred. The following example uses the same procedure as the previous example, but this time<br>DBMS_UTILITY.FORMAT_CALL_STACK is used in the exception handler: </p>
<p>  CHAPTER 9  EXCEPTIONS<br>209<br>CREATE OR REPLACE PROCEDURE obtain_emp_detail(emp_info IN VARCHAR2) IS<br>  emp_qry                VARCHAR2(500);<br>  emp_first              employees.first_name%TYPE;<br>  emp_last               employees.last_name%TYPE;<br>  email                  employees.email%TYPE; </p>
<p>  valid_id_count         NUMBER :&#x3D; 0;<br>  valid_flag             BOOLEAN :&#x3D; TRUE;<br>  temp_emp_info          VARCHAR2(50); </p>
<p> BEGIN<br>    emp_qry :&#x3D; ‘SELECT FIRST_NAME, LAST_NAME, EMAIL FROM EMPLOYEES ‘;<br>    IF emp_info LIKE ‘%@%’ THEN<br>      temp_emp_info :&#x3D; substr(emp_info,0,instr(emp_info,‘@’)-1);<br>      emp_qry :&#x3D; emp_qry || ‘WHERE EMAIL &#x3D; :emp_info’;<br>    ELSE<br>      SELECT COUNT(*)<br>      INTO valid_id_count<br>      FROM employees<br>      WHERE employee_id &#x3D; emp_info; </p>
<pre><code>  IF valid_id_count &gt; 0 THEN 
      temp_emp_info := emp_info; 
      emp_qry := emp_qry || &#39;WHERE EMPLOYEE_ID = :id&#39;; 
  ELSE 
      valid_flag := FALSE; 
  END IF; 
END IF; 

IF valid_flag = TRUE THEN 
  EXECUTE IMMEDIATE emp_qry 
  INTO emp_first, emp_last, email 
  USING temp_emp_info; 

  DBMS_OUTPUT.PUT_LINE(emp_first || &#39; &#39; || emp_last || &#39; - &#39; || email); 
ELSE  
  DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || 
                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); 
END IF; 

EXCEPTION 
  WHEN NO_DATA_FOUND THEN 
     
    DBMS_OUTPUT.PUT_LINE(&#39;THE INFORMATION YOU HAVE USED DOES &#39; || 
                       &#39;NOT MATCH ANY EMPLOYEE RECORD&#39;); 
    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_CALL_STACK); 
     
  WHEN OTHERS THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;AN UNEXPECTED ERROR HAS OCCURRED, PLEASE &#39; || 
                       &#39;TRY AGAIN&#39;); 
    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_CALL_STACK); 
</code></pre>
<p>CHAPTER 9  EXCEPTIONS<br>210<br> END;<br>Here are the results when calling within invalid argument information:<br>SQL&gt; exec obtain_emp_detail(‘june@’);<br>THE INFORMATION YOU HAVE USED DOES NOT MATCH ANY EMPLOYEE RECORD<br>—– PL&#x2F;SQL Call Stack —–<br>  object      line  object<br>  handle    number<br>name<br>24DD3280     47  procedure OBTAIN_EMP_DETAIL<br>273AA66C      1<br>anonymous block<br>PL&#x2F;SQL procedure successfully completed.<br>Each of the two utilities demonstrated in this solution serves an explicit purpose—to assist you in<br>finding the cause of exceptions in your applications.<br>How It Works<br>Oracle provides a few different utilities to help diagnose and repair issues with code. The utilities<br>discussed in this recipe provide feedback regarding exceptions that have been raised within application<br>code. DBMS_UTILITY.FORMAT_ERROR_BACKTRACE is used to display the list of lines that goes back to the point<br>at which your application fails. This utility was added in Oracle Database 10g. Its ability to identify the<br>exact line number where the code has failed can save the time of reading through each line to look for<br>the errors. Using this information along with the Oracle exception that is raised should give you enough<br>insight to determine the exact cause of the problem.<br>The result from DBMS_UTILITY.FORMAT_ERROR_BACKTRACE can be assigned to a variable since it is a<br>function. Most likely a procedure will be used to log the exceptions so that they can be reviewed at a later<br>time. Such a procedure could accept the variable containing the result from<br>DBMS_UTILITY.FORMAT_ERROR_BACKTRACE as input.<br>The DBMS_UTILITY.FORMAT_CALL_STACK function is used to print out a formatted string of the<br>execution call stack or the sequence of calls for your application. It displays the different objects used,<br>along with line numbers from which calls were made. It can be very useful for pinpointing those errors<br>that you are having trouble resolving. It can also be useful for obtaining information regarding the<br>execution order of your application. If you are unsure of exactly what order processes are being called,<br>this function will give you that information.<br>Using a combination of these utilities when debugging and developing your code is a good practice.<br>You may find it useful to create helper functions that contain calls to these utilities so that you can easily<br>log all stack traces into a database table or a file for later viewing. These can be of utmost importance<br>when debugging issues or evaluating application execution.<br>  CHAPTER 9  EXCEPTIONS<br>211<br>9-10. Displaying PL&#x2F;SQL Compiler Warnings<br>Problem<br>You are interested in making your code more robust by ensuring that no issues will crop up as time goes<br>by and the code evolves. You want to have the PL&#x2F;SQL compiler alert you of possible issues with your<br>code.<br>Solution<br>Use PL&#x2F;SQL compile-time warnings to alert you of possible issues with your code. Enable warnings for<br>your current session by issuing the proper ALTER SESSION statements or by using the DBMS_WARNING<br>package to do so. This solution will demonstrate each of these techniques to help you decide which will<br>work best for your debugging purposes.<br>First let’s take a look at using ALTER SESSION to enable and configure warnings for your<br>environment. This technique can be very useful when you want to enable warnings for an entire session.<br>The following example shows how to enable warnings and how to display them given a short code block: </p>
<p>ALTER SESSION SET PLSQL_WARNINGS &#x3D; ‘ENABLE:ALL’; </p>
<p>CREATE OR REPLACE FUNCTION calculate_salary_hours(salary  IN NUMBER,<br>                                                  hours   IN NUMBER DEFAULT 1)<br>RETURN NUMBER AS<br>BEGIN<br>  RETURN salary&#x2F;hours;<br>END; </p>
<p>SHOW ERRORS; </p>
<p>Here are the results from running create or replace function with all warnings enabled: </p>
<p>Errors for FUNCTION CALCULATE_SALARY_HOURS: </p>
<h2 id="LINE-x2F-COL"><a href="#LINE-x2F-COL" class="headerlink" title="LINE&#x2F;COL "></a>LINE&#x2F;COL </h2><h2 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR "></a>ERROR </h2><p>1&#x2F;1<br>PLW-05018: unit CALCULATE_SALARY_HOURS omitted optional AUTHID clause;<br> default value DEFINER used </p>
<p>Next, let’s look at the DBMS_WARNINGS package. Use of this technique is more helpful if you are using a<br>development environment such as PL&#x2F;SQL Developer that compiles your code for you. The following is<br>an example of performing the same CREATE OR REPLACE FUNCTION as earlier, but this time using<br>DBMS_WARNINGS: </p>
<p>SQL&gt; CALL DBMS_WARNING.SET_WARNING_SETTING_STRING(‘ENABLE:ALL’,’SESSION’); </p>
<p>Call completed. </p>
<p>CHAPTER 9  EXCEPTIONS<br>212<br>SQL&gt; CREATE OR REPLACE FUNCTION calculate_salary_hours(salary  IN NUMBER,<br>                                                  hours   IN NUMBER DEFAULT 1)<br>RETURN NUMBER AS<br>BEGIN<br>  RETURN salary&#x2F;hours;<br>END;<br>&#x2F;  2    3    4    5    6    7   </p>
<p>SP2-0806: Function created with compilation warnings </p>
<p>SQL&gt; SHOW ERRORS;<br>Errors for FUNCTION CALCULATE_SALARY_HOURS: </p>
<h2 id="LINE-x2F-COL-1"><a href="#LINE-x2F-COL-1" class="headerlink" title="LINE&#x2F;COL "></a>LINE&#x2F;COL </h2><h2 id="ERROR-1"><a href="#ERROR-1" class="headerlink" title="ERROR "></a>ERROR </h2><p>1&#x2F;1<br>PLW-05018: unit CALCULATE_SALARY_HOURS omitted optional AUTHID clause; default v<br>alue DEFINER used </p>
<p>Both techniques provide similar results, but one can be set at the database level and the other can<br>be more useful for use in a development environment.<br>How It Works<br>Learning about warnings against your code can help you solidify your code and repair it so that it can<br>become more robust when it is used in a production environment. Although PL&#x2F;SQL warnings will not<br>prevent the code from compiling and executing, they can certainly provide good insight to inform you of<br>places in your code that could possibly incur issues at a later time. As you have learned from the solution<br>to this recipe, there are two techniques that can be used to enable warnings for your application. Those<br>are the use of ALTER SESSION statements and the DBMS_WARNINGS package. Both are valid techniques for<br>enabling and disabling warnings, but each has its own set of strong points and drawbacks.<br>The PLSQL_WARNINGS compilation parameter must be used to enable or disable warnings within a<br>session. By setting it, you can control the types of warnings that are displayed, along with how much<br>information is displayed and even how it is displayed. This parameter can be set using the ALTER SESSION<br>statement. The format for setting this parameter using ALTER SESSION is as follows: </p>
<p>ALTER SESSION SET PLSQL_WARNINGS &#x3D; “[ENABLE&#x2F;DISABLE:PARAMETER]” </p>
<p>The PLSQL_WARNINGS compilation parameter accepts a number of different parameters that each tell<br>the compiler what types of warnings to display and what to ignore. There are three different categories of<br>warnings that can be used. Table 9-3 shows the different types of warnings along with their descriptions.<br>  CHAPTER 9  EXCEPTIONS<br>213<br>Table 9-3. Warning Categories<br>Category Description<br>PERFORMANCE May hinder application performance<br>INFORMATIONAL May complicate application maintenance but contains no immediate<br>issues<br>SECURE May cause unexpected or incorrect results<br>ALL Includes all the categories </p>
<p>The DBMS_WARNINGS package works in a similar fashion: it accepts the same arguments as the<br>PLSQL_WARNINGS parameter. The difference is that you can control when the warnings are enabled or<br>disabled by placing the call to the package in locations that you choose. This does not matter much<br>when working via SQL*Plus, but if you are using a development environment such as Oracle SQL<br>Developer, then DBMS_WARNINGS must be used. The format for calling this procedure is as follows: </p>
<p>CALL DBMS_WARNING.SET_WARNING_SETTING_STRING(‘warning_category:value’,’scope’); </p>
<p>The categories are the same as PLSQL_WARNINGS, as are the values of the categories. The scope determines<br>whether the warnings will be used for the duration of the session or for all sessions. There are various<br>other options that can be used with the DBMS_WARNINGS package. To learn more about these options,<br>please see the Oracle Database 11g documentation. </p>
<p>C H A P T E R  10 </p>
<p>   </p>
<p>215<br>PL&#x2F;SQL Collections and Records<br>Collections are single-dimensional arrays of data all with the same datatype and are accessed by an<br>index; usually the index is a number, but it can be a string. Collections indexed by strings are commonly<br>known as hash arrays.<br>Records are groups of related data, each with its own field name and datatype, similar to tables<br>stored in the database. The record data structure in PL&#x2F;SQL allows you to manipulate data at the field or<br>record level. PL&#x2F;SQL provides an easy method to define a record’s structure based on a database table’s<br>structure or a cursor. Combining records and collections provide a powerful programming advantage<br>described in the following recipes.<br>10-1. Creating and Accessing a VARRAY<br>Problem<br>You have a small, static list of elements that you initialize once and that would benefit from using in a<br>loop body.<br>Solution<br>Place the elements into a varray (or varying array). Once initialized, a varray may be referenced by its<br>index. Begin by declaring a datatype of varray with a fixed number of elements, and then declare the<br>datatype of the elements. Next, declare the variable that will hold the data using the newly defined type.<br>For example, the following code creates a varying array to hold the abbreviations for the days of the<br>week: </p>
<p>DECLARE </p>
<p>TYPE    dow_type IS VARRAY(7) OF VARCHAR2(3);<br>dow     dow_type :&#x3D; dow_type (‘Sun’, ‘Mon’, ‘Tue’, ‘Wed’, ‘Thu’, ‘Fri’, ‘Sat’); </p>
<p>BEGIN </p>
<p>   FOR i IN 1..dow.COUNT LOOP<br>      DBMS_OUTPUT.PUT_LINE (dow(i));<br>   END LOOP; </p>
<p>END; </p>
<p>Results </p>
<p>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>216<br>Sun<br>Mon<br>Tue<br>Wed<br>Thu<br>Fri<br>Sat<br>How It Works<br>The type statement dow_type defines a data structure to store seven instances of VARCHAR2(3). This is<br>sufficient space to hold the abbreviations of the seven days of the week. The dow variable is defined as a<br>VARRAY of the dow_type defined in the previous line. That definition invokes a built-in constructor<br>method to initialize values for each of the elements in the VARRAY.<br>The FOR .. LOOP traverses the dow variable starting at the first element and ending with the last. The<br>COUNT method returns the number of elements defined in a collection; in this recipe, there are seven<br>elements in the VARRAY, so the LOOP increments from one to seven. The DBMS_OUTPUT.PUT_LINE statement<br>displays its value.<br>A VARRAY is best used when you know the size the array and it will not likely change. The VARRAY<br>construct also allows you to initialize its values in the declaration section.<br>10-2. Creating and Accessing an Indexed Table<br>Problem<br>You need to store a group of numbers for later processing in another procedure.<br>Solution<br>Create an indexed table using an integer index to reference the elements. For example, this recipe loads<br>values into an indexed table of numbers.  </p>
<p>DECLARE </p>
<p>TYPE    num_type IS TABLE OF number INDEX BY BINARY_INTEGER;<br>nums    num_type;<br>total   number; </p>
<p>BEGIN </p>
<p>   nums(1) :&#x3D; 127.56;<br>   nums(2) :&#x3D; 56.79;<br>   nums(3) :&#x3D; 295.34; </p>
<p>   – call subroutine to process numbers;<br>   – total :&#x3D; total_table (nums);<br>END;<br>  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS<br>217<br>How It Works<br>PL&#x2F;SQL tables are indexed collections of data of the same type. The datatype can be any of the built-in<br>datatypes provided by PL&#x2F;SQL; in this example, the datatype is a number. Here are some things to note<br>about the example:<br>• The TYPE statement declares a TABLE of numbers.<br>• The INDEX BY clause defines how the array is accessed, in this case by an INTEGER.<br>• The array is populated by assigning values to specific indexes.<br>Because the TABLE is INDEXED BY an INTEGER, there is no predefined limit on the index value, other<br>than those imposed by Oracle, which is -231 – 231. Indexed tables are best suited for collections where the<br>number of elements stored is not known until runtime.<br>This recipe is an example of a TABLE indexed by an INTEGER. PL&#x2F;SQL provides for tables indexed by<br>strings as well. See Recipe 10-5 for an example.<br>10-3. Creating Simple Records<br>Problem<br>You need a PL&#x2F;SQL data structure to group related employee data to make manipulating the group<br>easier.<br>Solution<br>Define a record structure of the related employee data, and then create a variable to hold the record<br>structure. In this example, a simple RECORD structure is defined and initialized. </p>
<p>DECLARE </p>
<p>TYPE    rec_type IS RECORD (<br>                last_name       varchar2(25),<br>                department      varchar2(30),<br>                salary          number );<br>rec     rec_type; </p>
<p>begin </p>
<p>   rec.last_name        :&#x3D; ‘Juno’;<br>   rec.department       :&#x3D; ‘IT’;<br>   rec.salary           :&#x3D; ‘5000’; </p>
<p>END;<br>How It Works<br>Record structures are created in PL&#x2F;SQL by using the TYPE statement along with a RECORD structure<br>format. The fields defined in the record structure can be, and often are, of different datatypes. Record<br>structures use dot notation to access individual fields. Once defined, the rec_type record structure in the<br>solution can be used throughout the code to create as many instantiations of data structures as needed.<br>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>218<br>10-4. Creating and Accessing Record Collections<br>Problem<br>You need to load records from a database table or view into a simple data structure that would benefit<br>from use in a loop body or to pass as a parameter to another function or procedure. You want to act<br>upon sets of records as a single unit.<br>Solution<br>Use a TYPE to define a TABLE based on the database table structure. The following example declares a<br>cursor and then uses it to declare the table of records. The result is a variable named recs that holds the<br>data fetched by the cursor. </p>
<p>DECLARE </p>
<p>CURSOR  driver IS<br>SELECT  *<br>FROM    employees; </p>
<p>TYPE    emp_type IS TABLE OF driver%ROWTYPE INDEX BY BINARY_INTEGER;<br>recs    emp_type;<br>total   number :&#x3D; 0.0; </p>
<p>BEGIN </p>
<p>   OPEN DRIVER;<br>   FETCH DRIVER BULK COLLECT INTO recs;<br>   CLOSE DRIVER; </p>
<p>   DBMS_OUTPUT.PUT_LINE (recs.COUNT || ‘ records found’); </p>
<p>   FOR i in 1..recs.COUNT LOOP<br>      total :&#x3D; total + recs(i).salary;<br>   END LOOP; </p>
<p>END; </p>
<p>When you execute this block of code, you will see a message such as the following: </p>
<p>103 records found<br>How It Works<br>The TYPE statement defines a data structure using the attributes (columns) of the employees table as<br>elements within the structure. The TABLE OF clause defines multiple instances of the record structure.<br>The INDEX BY clause defines the index method, in this case an integer. Think of this structure as a<br>spreadsheet with the rows being separate records from the database and the columns being the<br>attributes (fields) in the database. The recipe works whether your cursor selects all the fields (SELECT *)<br>or selects just a subset of fields from the table.<br>  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS<br>219<br>The BULK COLLECT portion of the fetch statement is more efficient than looping through the data in a<br>standard cursor loop because PL&#x2F;SQL switches control to the database just once to retrieve the data as<br>opposed to switching to the database for each record retrieved in a cursor FOR .. LOOP. In a BULK<br>COLLECT, all records meeting the query condition are retrieved and stored in the data structure in a single<br>operation. Once the records are retrieved, processing may occur in a standard FOR .. standard FOR ..<br>LOOP.<br>10-5. Creating and Accessing Hash Array Collections<br>Problem<br>You want to use a single cursor to query employee data and sum the salaries across departments.<br>Solution<br>You can use two cursors—one to select all employees and the other to sum the salary grouping by<br>department. However, you can more easily and efficiently accomplish your task by using one cursor and<br>a hashed collection. Define your cursor to select employee data, joined with the department table. Use a<br>hash array collection to total by department by using the INDEX BY option to index your collection based<br>on the department name rather than an integer. The following code example illustrates this more<br>efficient approach: </p>
<p>DECLARE </p>
<p>CURSOR  driver IS<br>SELECT  ee.employee_id, ee.first_name, ee.last_name, ee.salary, d.department_name<br>FROM    departments     d,<br>        employees       ee<br>WHERE   d.department_id &#x3D; ee.department_id; </p>
<p>TYPE    total_type IS TABLE OF number INDEX BY departments.department_name%TYPE;<br>totals  total_type; </p>
<p>dept    departments.department_name%TYPE; </p>
<p>BEGIN </p>
<p>   FOR rec IN driver LOOP<br>      – process paycheck<br>      if NOT totals.EXISTS(rec.department_name) then  – create element in the array<br>         totals(rec.department_name) :&#x3D; 0; – initialize to zero<br>      end if; </p>
<pre><code>  totals(rec.department_name) := totals(rec.department_name) + nvl (rec.salary, 0); 
</code></pre>
<p>   END LOOP; </p>
<p>   dept :&#x3D; totals.FIRST;<br>   LOOP<br>      EXIT WHEN dept IS NULL;<br>      DBMS_OUTPUT.PUT_LINE (to_char (totals(dept),  ‘999,999.00’) || ‘ ‘ || dept);<br>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>220<br>      dept :&#x3D; totals.NEXT(dept);<br>   END LOOP;<br>END;<br>When you execute this block of code, you will see the following results:<br>20,310.00 Accounting<br>58,720.00 Executive<br>51,600.00 Finance<br>6,500.00 Human Resources<br>19,000.00 Marketing<br>2,345.34 Payroll<br>10,000.00 Public Relations<br>304,500.00 Sales<br>156,400.00 Shipping<br>35,295.00 Web Developments<br>How It Works<br>The TOTAL_TYPES PL&#x2F;SQL type is defined as a collection of numbers that is indexed by the department<br>name. Indexing by department name gives the advantage of automatically sorting the results by<br>department name.<br>As new elements are created, using the EXISTS method, the index keys are automatically sorted by<br>PL&#x2F;SQL. The totals are accumulated by department name as opposed to a numerical index, such as<br>department ID, which may not be sequential. This approach has the added advantage of not requiring a<br>separate collection for the department names.<br>Once the employee paychecks are processed, the dept variable is initialized with the first<br>department name from the totals array using the FIRST method. In this example, the first department is<br>accounting. A loop is required to process the remaining records. The NEXT method is used to find the<br>next department name—in alphabetical order—and this process repeats until all departments are<br>displayed.<br>10-6. Creating and Accessing Complex Collections<br>Problem<br>You need a routine to load managers and their corresponding employees from the database and store<br>them in one data structure. The data must be loaded in a manner such that direct reports are associated<br>with their manager. In addition, the number of direct reports for any given manager varies, so your<br>structure to hold the manager&#x2F;employee relationships must handle any number of subordinates.<br>Solution<br>Combine records and collections to define one data structure capable of storing all the data. PL&#x2F;SQL<br>allows you to use data structures you create via the type statement as datatypes within other collections.<br>Once your data structures are defined, use dot notation to distinguish attributes within the collections.<br>Use the structure’s index to reference items within the table. For example:<br>  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS<br>221<br>SET SERVEROUT ON SIZE 1000000 </p>
<p>DECLARE </p>
<p>TYPE    person_type IS RECORD (<br>                employee_id     employees.employee_id%TYPE,<br>                first_name      employees.first_name%TYPE,<br>                last_name       employees.last_name%TYPE); </p>
<p>  – a collection of people<br>TYPE    direct_reports_type IS TABLE OF person_type INDEX BY BINARY_INTEGER;  </p>
<p>  – the main record definition, which contains a collection of records<br>TYPE    rec_type IS RECORD (<br>                mgr             person_type,<br>                emps            direct_reports_type); </p>
<p>TYPE    recs_type IS TABLE OF rec_type INDEX BY BINARY_INTEGER;<br>recs    recs_type; </p>
<p>CURSOR  mgr_cursor IS  – finds all managers<br>SELECT  employee_id, first_name, last_name<br>FROM    employees<br>WHERE   employee_id IN<br>        (       SELECT  distinct manager_id<br>                FROM    employees)<br>ORDER BY last_name, first_name; </p>
<p>CURSOR  emp_cursor (mgr_id integer) IS  – finds all direct reports for a manager<br>SELECT  employee_id, first_name, last_name<br>FROM    employees<br>WHERE   manager_id &#x3D; mgr_id<br>ORDER BY last_name, first_name; </p>
<p>  – temporary collection of records to hold the managers.<br>TYPE            mgr_recs_type IS TABLE OF emp_cursor%ROWTYPE<br>                                INDEX BY BINARY_INTEGER;<br>mgr_recs        mgr_recs_type; </p>
<p>BEGIN </p>
<p>   OPEN mgr_cursor;<br>   FETCH mgr_cursor BULK COLLECT INTO mgr_recs;<br>   CLOSE mgr_cursor; </p>
<p>   FOR i IN 1..mgr_recs.COUNT LOOP<br>      recs(i).mgr :&#x3D; mgr_recs(i);  – move the manager record into the final structure </p>
<pre><code>    -- moves direct reports directly into the final structure 
  OPEN emp_cursor (recs(i).mgr.employee_id); 
  FETCH emp_cursor BULK COLLECT INTO recs(i).emps; 
  CLOSE emp_cursor; 
</code></pre>
<p>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>222<br>   END LOOP; </p>
<pre><code>    -- traverse the data structure to display the manager and direct reports 
    -- note the use of dot notation within the data structure 
</code></pre>
<p>   FOR i IN 1..recs.COUNT LOOP<br>      DBMS_OUTPUT.PUT_LINE (‘Manager: ‘ || recs(i).mgr.last_name);<br>      FOR j IN 1..recs(i).emps.count LOOP<br>         DBMS_OUTPUT.PUT_LINE (‘***   Employee: ‘ || recs(i).emps(j).last_name);<br>      END LOOP;<br>   END LOOP; </p>
<p>END;  </p>
<p>Executing this code block produces the following results: </p>
<p>Manager: Cambrault<br>***   Employee: Bates<br>***   Employee: Bloom<br>***   Employee: Fox<br>***   Employee: Kumar<br>***   Employee: Ozer<br>***   Employee: Smith<br>…  &lt;<snip>&gt;<br>Manager: Zlotkey<br>***   Employee: Abel<br>***   Employee: Grant<br>***   Employee: Hutton<br>***   Employee: Johnson<br>***   Employee: Livingston<br>***   Employee: Taylor<br>How It Works<br>Combining records with collections is one of the most powerful techniques for defining data structures<br>in PL&#x2F;SQL. It allows you to logically group common data, process large amounts of data efficiently, and<br>seamlessly pass data between procedures and functions.<br>The data structure contains a collection of managers; each manager contains a collection of direct<br>reports. Managers and direct reports are both person_type. Once your complex structure is defined, you<br>can use the BULK COLLECT feature to quickly fetch data from the database and load it into the structure.<br>The BULK COLLECT of the MGR_CURSOR selects all persons who are managers at once and then loads<br>them into the temporary structure MGR_RECS. Now that you have retrieved the records, it is easy to move<br>them into your final data structure. Looping through the manager records allows you to move the entire<br>data record for each manager via the RECS(I).MGR :&#x3D; MGR_RECS(I); statement. This statement moves<br>every element (field) from the MGR_RECS into the RECS structure.<br>The EMP_CURSOR uses the managers’ ID to fetch the managers’ direct reports. The cursor is opened by<br>passing the managers’ ID, and then another BULK COLLECT is used to directly store the fetched data into<br>the data structure; no temporary data structure is needed because the structure of the fetched data<br>exactly matches the target data structure.<br>Now that the data is stored in the data structure, it can be passed to another routine for processing.<br>Grouping large sets of related data is an efficient method for exchanging data between routines. This<br>  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS<br>223<br>helps separate data retrieval routines from business processing routines. It’s a very powerful feature in<br>PL&#x2F;SQL, as you’ll see in the next recipe.<br>10-7. Passing a Collection As a Parameter<br>Problem<br>You want to pass a collection as a parameter to a procedure or function. For example, you have a data<br>structure that contains employee data, and you need to pass the data to a routine that prints employee<br>paychecks.<br>Solution<br>Create a collection of employee records to hold all employee data, and then pass the data to the<br>subroutine to process the paychecks. The TYPE statement defining the data structure must be visible to<br>the called procedure; therefore, it must be defined globally, prior to defining any procedure or function<br>that uses it.<br>In this example, employee data is fetched from the database into a collection and then passed to a<br>subroutine for processing. </p>
<p>set serverout on size 1000000 </p>
<p>DECLARE </p>
<p>CURSOR  driver IS<br>SELECT  employee_id, first_name, last_name, salary<br>FROM    employees<br>ORDER BY last_name, first_name; </p>
<p>TYPE    emps_type IS TABLE OF driver%ROWTYPE;<br>recs    emps_type; </p>
<p>   PROCEDURE print_paycheck (emp_recs emps_type) IS </p>
<p>   BEGIN </p>
<pre><code>  FOR i IN 1..emp_recs.COUNT LOOP 
     DBMS_OUTPUT.PUT (&#39;Pay to the order of: &#39;); 
     DBMS_OUTPUT.PUT (emp_recs(i).first_name || &#39; &#39; || emp_recs(i).last_name); 
     DBMS_OUTPUT.PUT_LINE (&#39; $&#39; || to_char (emp_recs(i).salary, &#39;FM999,990.00&#39;)); 
  END LOOP; 
</code></pre>
<p>   END;  </p>
<p>BEGIN </p>
<p>   OPEN driver;<br>   FETCH driver BULK COLLECT INTO recs;<br>   CLOSE driver; </p>
<p>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>224<br>   print_paycheck (recs); </p>
<p>END;  </p>
<p>Results </p>
<p>Pay to the order of: Ellen Abel $11,000.00<br>Pay to the order of: Sundar Ande $6,400.00<br>Pay to the order of: Mozhe Atkinson $2,800.00<br>… &lt;<snip>&gt;<br>Pay to the order of: Alana Walsh $3,100.00<br>Pay to the order of: Matthew Weiss $8,000.00<br>Pay to the order of: Eleni Zlotkey $10,500.00<br>How It Works<br>TYPE globally defines the data structure as a collection of records for use by the PL&#x2F;SQL block and the<br>enclosed procedure. This declaration of both the type and the procedure at the same level—inside the<br>same code block—is necessary to allow the data to be passed to the function. The type and the<br>procedure are within the same scope, and thus the procedure can reference the type and accept values<br>of the type.<br>Defining the recs structure as a collection makes it much easier to pass large amounts of data<br>between routines with a single parameter. The data structure emps_type is defined as a collection of<br>employee records that can be passed to any function or procedure that requires employee data for<br>processing. This recipe is especially useful in that the logic of who receives a paycheck can be removed<br>from the routine that does the printing or the routine that archives the payroll data, for example.<br>10-8. Returning a Collection As a Parameter<br>Problem<br>Retrieving a collection of data is a common need. For example, you need a function that returns all<br>employee data and is easily called from any procedure.<br>Solution<br>Write a function that returns a complete collection of employee data. In this example, a package is used<br>to globally define a collection of employee records and return all employee data as a collection. </p>
<p>CREATE OR REPLACE PACKAGE empData AS </p>
<p>type    emps_type is table of employees%ROWTYPE INDEX BY BINARY_INTEGER; </p>
<p>FUNCTION get_emp_data RETURN emps_type; </p>
<p>END empData; </p>
<p>CREATE OR REPLACE PACKAGE BODY empData as </p>
<p>FUNCTION get_emp_data RETURN emps_type is<br>  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS<br>225 </p>
<p>cursor  driver is<br>select  *<br>from    employees<br>order by last_name, first_name; </p>
<p>recs    emps_type; </p>
<p>begin </p>
<p>   open driver;<br>   FETCH driver BULK COLLECT INTO recs;<br>   close driver; </p>
<p>   return recs; </p>
<p>end get_emp_data; </p>
<p>end empData; </p>
<p>declare </p>
<p>emp_recs empData.emps_type; </p>
<p>begin </p>
<p>   emp_recs :&#x3D; empData.get_emp_data;<br>   dbms_output.put_line (‘Employee Records: ‘ || emp_recs.COUNT); </p>
<p>END;  </p>
<p>Executing this block of code produces the following results. </p>
<p>Employee Records: 103<br>How It Works<br>By defining a PACKAGE, the data structure emps_type is available for use by any package, procedure, or<br>function that has access rights to it.1 The function get_emp_data within the common package contains all<br>the code necessary to fetch and return the employee data. This common routine can be used by multiple<br>applications that require the employee data for processing. This is a much more efficient method than<br>coding the same select statement in multiple applications.<br>It is not uncommon to include business rules in this type of function; for example, the routine may<br>fetch only active employees. If the definition of an active employee changes, you need to update only<br>one routine to fix all the applications that use it. </p>
<p>1 To grant access rights, enter the following command: grant execute on empData to SCHEMA, where SCHEMA is<br>the user name that requires access. To grant access to every user in the database, use grant execute on empData<br>to PUBLIC;.<br>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>226<br>10-9. Counting the Members in a Collection<br>Problem<br>You have a collection, and you need to determine the total number of elements in the collection.<br>Solution<br>Invoke the built-in COUNT method on the collection. For example, the following code creates two<br>collections: a varying array and an INDEX BY array. The code then invokes the COUNT method on both<br>collections, doing so before and after adding some records to each. </p>
<p>DECLARE </p>
<p>TYPE    vtype   IS VARRAY(3) OF DATE;<br>TYPE    ctype   IS TABLE OF DATE INDEX BY BINARY_INTEGER; </p>
<p>vdates  vtype :&#x3D; vtype (sysdate);<br>cdates  ctype; </p>
<p>BEGIN </p>
<p>   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);<br>   DBMS_OUTPUT.PUT_LINE (‘cdates size is: ‘ || cdates.COUNT); </p>
<p>   FOR i IN 1..3 LOOP<br>      cdates(i) :&#x3D; SYSDATE + 1;<br>   END LOOP; </p>
<p>   DBMS_OUTPUT.PUT_LINE (‘cdates size is: ‘ || cdates.COUNT); </p>
<p>END;  </p>
<p>Executing this block of code produces the following results: </p>
<p>vdates size is: 1<br>cdates size is: 0<br>cdates size is: 3<br>How It Works<br>The variable vdates is initialized with one value, so its size is reported as 1 even though it is defined to<br>hold a maximum of three values. The variable cdates is not initialized, so it is first reported with a size of </p>
<ol>
<li>The loop creates and sets three collection values, which increases its count to 3.<br>Assigning a value directly to cdates(i) is allowed because cdates is an INDEX BY collection.<br>Assigning a value to vdates in the loop would cause an error because the array has only one defined<br>value. See the EXTEND method later in this chapter for more information on assigning values to non-INDEX<br>BY collections.<br>  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS<br>227<br>The COUNT method is especially useful when used on a collection populated with a fetch from BULK<br>COLLECT statement to determine the number of records fetched or to process records in a FOR .. LOOP.<br>10-10. Deleting a Record from a Collection<br>Problem<br>You need to randomly select employees from a collection. Using a random generator may select the<br>same employee more than once, so you need to remove the record from the collection before selecting<br>the next employee.<br>Solution<br>Invoke the built-in DELETE method on the collection. For example, the following code creates a collection<br>of employees and then randomly selects one from the collection. The selected employee is removed<br>from the collection using the DELETE method. This process is repeated until three employees have been<br>selected.</li>
</ol>
<p>DECLARE </p>
<p>CURSOR  driver IS<br>SELECT  last_name<br>FROM    employees; </p>
<p>TYPE    rec_type IS TABLE OF driver%ROWTYPE INDEX BY BINARY_INTEGER;<br>recs    rec_type;<br>j       INTEGER; </p>
<p>BEGIN </p>
<p>   OPEN driver;<br>   FETCH driver BULK COLLECT INTO recs;<br>   CLOSE driver; </p>
<p>   DBMS_RANDOM.INITIALIZE(TO_NUMBER (TO_CHAR (SYSDATE, ‘SSSSS’) ) ); </p>
<p>   FOR i IN 1..3 LOOP<br>–      Randomly select an employee<br>      j :&#x3D; MOD (ABS (DBMS_RANDOM.RANDom), recs.COUNT) + 1;<br>      DBMS_OUTPUT.PUT_LINE (recs(j).last_name); </p>
<p>–      Move all employees up one postion in the collection<br>      FOR k IN j+1..recs.COUNT LOOP<br>         recs(k-1) :&#x3D; recs(k);<br>      END LOOP; </p>
<p>–      Remove the last element in the collection<br>–      so the random number generator has the correct count.<br>      recs.DELETE(recs.COUNT);<br>   END LOOP;<br>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>228 </p>
<p>   DBMS_RANDOM.TERMINATE; </p>
<p>END; </p>
<p>Executing this block of code produces the following results: </p>
<p>Olson<br>Chung<br>Seo<br>How It Works<br>The collection recs is populated with employee names via a BULK COLLECT. The FOR .. LOOP selects three<br>employees at random by generating a random number between 1 and the number of records in the<br>collection. Once an employee is selected, their name is removed from the collection, and the DELETE<br>method is used to reduce the number of elements, which changes the value returned by the COUNT<br>method for the next randomly generated number.<br>  Note: The DELETE method applies only to collections that are indexed. You can invoke DELETE only if the<br>collection’s underlying TYPE definition contains the INDEX BY clause.<br>10-11. Checking Whether an Element Exists<br>Problem<br>You are processing elements in a collection but cannot be certain that each element exists. Referencing<br>an element in a collection that does not exist will throw an exception. You want to avoid exceptions by<br>testing for existence before you access an element.<br>Solution<br>Use the EXISTS method to test whether a collection has a value for a particular index value. In the<br>following solution, a table collection is created, and then the second element is deleted. It is important<br>to note that a deleted element or an element that was never initialized is not equivalent to an element<br>with a null value. </p>
<p>DECLARE </p>
<p>TYPE ctype IS TABLE OF DATE INDEX BY BINARY_INTEGER; </p>
<p>cdates ctype; </p>
<p>BEGIN </p>
<p>   FOR i IN 1..3 LOOP<br>  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS<br>229<br>     cdates(i) :&#x3D; sysdate + i;<br>   END LOOP; </p>
<p>   cdates.DELETE(2); </p>
<p>   FOR i IN 1..3 LOOP<br>      IF cdates.EXISTS(i) then<br>         DBMS_OUTPUT.PUT_LINE (‘cdates(‘ || i || ‘)&#x3D; ‘ || cdates(i) );<br>      END IF;<br>   END LOOP; </p>
<p>END;  </p>
<p>Executing this block of code produces the following results: </p>
<p>cdates(1)&#x3D; 07-AUG-10<br>cdates(3)&#x3D; 09-AUG-10<br>How It Works<br>The first loop creates and initializes the elements in the collection; the DELETE method removes the<br>second element. Now we’re ready to loop through the data. The second loop tests for the existence of the<br>element index before attempting to use the variable. Attempting to access a value to an element in the<br>collection that does not exist throws an exception.<br>If the first loop initialized the collection elements to NULL, the remaining would execute in exactly<br>the same manner. The only difference would be in the output from running the block of code. In this<br>case, no dates would print. Referencing an element in a collection with a null value does not throw an<br>exception because the indexed element exists, whereas referencing an element that does not exist does<br>throw an exception. Here is the output in this example. Note neither solution prints an element for<br>subscript 2. </p>
<p>cdates(1)&#x3D;<br>cdates(3)&#x3D;<br>10-12. Increasing the Size of a Collection<br>Problem<br>You have a VARRAY with a defined maximum size, but not all elements are initialized, and you need to<br>add more elements to the collection.<br>Solution<br>Use the EXTEND method to create new elements within the predefined boundaries. The following<br>example adds five elements using a loop: </p>
<p>DECLARE </p>
<p>TYPE    vtype   IS VARRAY(5) OF DATE;<br>vdates  vtype :&#x3D; vtype (sysdate, sysdate+1, sysdate+2); – initialize 3 of the 5 elements<br>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>230<br>BEGIN<br>   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);<br>   FOR i IN 1..5 LOOP<br>      if NOT vdates.EXISTS(i) then<br>         vdates.EXTEND;<br>         vdates(i) :&#x3D; SYSDATE + i;<br>      END IF;<br>   END LOOP;<br>   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);<br>END;<br>Executing this block of code produces the following results:<br>vdates size is: 3<br>vdates size is: 5<br>How It Works<br>The TYPE declaration defines a maximum of five elements in the collection, which is initialized with three<br>values. The loop tests for the existence of the elements by index number. The EXTEND method allocates<br>storage space for the new elements. Without the EXTEND statement preceding the assignment, Oracle will<br>raise an error “ORA-06533: Subscript beyond count.” This occurs when the loop attempts to assign a<br>value to the fourth element in the collection.<br>The EXTEND method applies to TABLE and VARRAY collections that are not indexed. In other words, the<br>EXTEND method applies when the TABLE or VARRAY type definition does not contain the INDEX BY<br>clause. To assign a value to a collection that is indexed, simply reference the collection using the index<br>value.<br>10-13. Navigating Collections<br>Problem<br>You need a routine to display sales totaled by region, which is stored in a collection of numbers, but the<br>collection is indexed by a character string. Using a LOOP from 1 to the maximum size will not work.<br>Solution<br>Use the FIRST and LAST method to traverse the collection allowing PL&#x2F;SQL to supply the proper index<br>values. In this example, sales amounts are stored in a TABLE indexed by a string.<br>DECLARE<br>TYPE    ntype   IS TABLE OF NUMBER INDEX BY VARCHAR2(5);<br>nlist   ntype;<br>idx     VARCHAR2(5);<br>  CHAPTER 10  PL&#x2F;SQL COLLECTIONS AND RECORDS<br>231<br>total   integer :&#x3D; 0; </p>
<p>BEGIN </p>
<p>   nlist(‘North’) :&#x3D; 100;<br>   nlist(‘South’) :&#x3D; 125;<br>   nlist(‘East’)  :&#x3D; 75;<br>   nlist(‘West’)  :&#x3D; 75; </p>
<p>   idx :&#x3D; nlist.FIRST;<br>   LOOP<br>      EXIT WHEN idx is null;<br>      DBMS_OUTPUT.PUT_LINE (idx || ‘ &#x3D; ‘ || nlist(idx) );<br>      total :&#x3D; total + nlist(idx);<br>      idx   :&#x3D; nlist.NEXT(idx);<br>   END LOOP; </p>
<p>   DBMS_OUTPUT.PUT_LINE (‘Total: ‘ || total); </p>
<p>END;  </p>
<p>Executing this block of code produces the following results: </p>
<p>East &#x3D; 75<br>North &#x3D; 100<br>South &#x3D; 125<br>West &#x3D; 75<br>Total: 375<br>How It Works<br>The FIRST method returns the lowest index value in the collection. In this case, the value is East, because<br>the collection is sorted alphabetically. The loop is entered with idx initialized to the first value in the<br>collection. The NEXT method returns the next index value alphabetically in the collection. The loop<br>continues executing until the NEXT method returns a null value, which occurs after the last index value in<br>the collect is retrieved.<br>To traverse the collection in reverse alphabetical order, simply initialize the idx value to nlist.LAST.<br>Then replace the nlist.NEXT with nlist.PRIOR.<br>  Note The FIRST, NEXT, PRIOR, and LAST methods are most useful with associative arrays but also work with<br>collections indexed by an integer.<br>CHAPTER 10 PL&#x2F;SQL COLLECTIONS AND RECORDS<br>232<br>10-14. Trimming a Collection<br>Problem<br>You need to remove one or more items from the end of a non-INDEX BY collection. The DELETE method<br>will not work because it applies only to INDEX BY collections.<br>Solution<br>Use the TRIM method to remove one or more elements from the end of the collection. In this example, a<br>VARRY is initialized with five elements. The TRIM method is used to remove elements from the end of the<br>collection. </p>
<p>DECLARE </p>
<p>TYPE    vtype   IS VARRAY(5) OF DATE;<br>vdates  vtype :&#x3D; vtype (sysdate, sysdate+1, sysdate+2, sysdate+3, sysdate+4); </p>
<p>BEGIN </p>
<p>   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);<br>   vdates.TRIM;<br>   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT);<br>   vdates.TRIM(2);<br>   DBMS_OUTPUT.PUT_LINE (‘vdates size is: ‘ || vdates.COUNT); </p>
<p>END;  </p>
<p>Executing this block of code produces the following results: </p>
<p>vdates size is: 5<br>vdates size is: 4<br>vdates size is: 2<br>How It Works<br>The TRIM method deletes elements from the end of the collection including elements not initialized. It<br>accepts an optional parameter for the number of elements to delete; otherwise, it defaults to the last<br>element. The TRIM method applies to TABLE and VARRAY collections that are not indexed. If the underlying<br>TYPE definition does not contain the INDEX BY clause, then you can invoke TRIM.<br>The TRIM method is limited to removing elements from the end of a collection, whereas the DELETE<br>method can remove elements anywhere in a collection. If you DELETE an element in the middle of a<br>collection, then executing a FOR .. LOOP from one to the collection’s COUNT will not work properly. First,<br>if you attempt to access the element that was deleted without checking whether it EXISTS, an exception is<br>thrown. Second, the COUNT method will return a value that is less than the collection’s maximum index<br>value, which means the FOR .. LOOP will not process all elements in the collection.<br>C H A P T E R  11 </p>
<p>   </p>
<p>233<br>Automating Routine Tasks<br>Oracle provides methods to schedule one-time and recurring jobs within the database, which is<br>beneficial when you want to automate repetitive tasks and run them at times when a DBA may not be<br>available. This chapter provides recipes to help you get started scheduling jobs (especially PL&#x2F;SQL jobs),<br>capturing output, sending e-mail notifications, and keeping data in sync with other databases.<br>11-1. Scheduling Recurring Jobs<br>Problem<br>You want to schedule a PL&#x2F;SQL procedure to run at a fixed time or at fixed intervals.<br>Solution<br>Use the EXEC DBMS_SCHEDULER.CREATE_JOB procedure to create and schedule one-time jobs and jobs that<br>run on a recurring schedule. Suppose, for example, that you need to run a stored procedure named<br>calc_commissions every night at 2:30 a.m. to calculate commissions based on the employees’ salaries.<br>Normally, commissions would be based on sales, but the default HR schema doesn’t provide that table,<br>so we’ll use an alternate calculation for demonstration purposes: </p>
<p>EXEC DBMS_SCHEDULER.CREATE_JOB (               -<br>           JOB_NAME&#x3D;&gt;’nighly_commissions’,     -<br>           JOB_TYPE&#x3D;&gt;’STORED_PROCEDURE’,       -<br>         JOB_ACTION&#x3D;&gt;’calc_commisions’,        -<br>            ENABLED&#x3D;&gt;TRUE,                     -<br>    REPEAT_INTERVAL&#x3D;&gt;’FREQ&#x3D;DAILY;INTERVAL&#x3D;1;BYHOUR&#x3D;02;BYMINUTE&#x3D;30’);<br>How It Works<br>The DBMS_SCHEDULER.CREATE_JOB procedure sets up a nightly batch job. JOB_NAME must be unique. The<br>JOB_TYPE, in this example, is STORED_PROCEDURE. This informs the scheduler the job is a PL&#x2F;SQL procedure<br>stored in the database. In addition to scheduling a stored procedure, the scheduler can also execute a<br>PL&#x2F;SQL_BLOCK, an external EXECUTABLE program, or a job CHAIN. See Recipe 11-6 for an example on<br>scheduling job chains.<br>The JOB_ACTION identifies the stored procedure to run. If the procedure is owned by another<br>schema, then include the schema name, for example, HR.calc_commission. If the procedure is part of a<br>larger package, include that as well, for example, HR.my_package.calc_commission.<br>ENABLED is set to TRUE to tell the scheduler to run at the next scheduled time. By default, the ENABLED<br>parameter is FALSE and would require a call to the DBMS_SCHEDULER.ENABLE procedure to enable the job.<br>CHAPTER 11  AUTOMATING ROUTINE TASKS<br>234<br>The REPEAT_INTERVAL is an important part of the CREATE_JOB routine. It identifies the frequency, in<br>this case DAILY. The INTERVAL tells scheduler to run the job every day, as opposed to 2 or 3, which would<br>run every other day, or every third day. The BYHOUR and BYMINUTE sections specifies the exact time of the<br>day to run. In this example, the job will run at 2:30 a.m.<br>The scheduled job, nightly_commissions, runs the stored procedure calc_commission, which reads<br>the data, calculates the commission, and stores the commission records. Running this job nightly keeps<br>the employees’ commission data current with respect to daily sales figures.<br>11-2. E-mailing Output from a Scheduled Job<br>Problem<br>You have a scheduled job that runs a stored procedure at a regular interval. The procedure produces<br>output that ordinarily would be sent to the screen via the DBMS_OUTPUT.PUT_LINE procedure, but since it<br>runs as a nightly batch job, you want to send the output to a distribution list as an e-mail message.<br>Solution<br>Save the output in a CLOB variable and then send it to the target distribution list using the<br>UTL_MAIL.SEND procedure. For example, suppose you want to audit the employee table periodically to<br>find all employees who have not been assigned to a department within the company. Here’s a procedure<br>to do that: </p>
<p>CREATE OR REPLACE PROCEDURE employee_audit AS </p>
<p>CURSOR    driver IS    – find all employees not in a department<br>SELECT    employee_id, first_name, last_name<br>FROM      employees<br>WHERE     department_id is null<br>ORDER BY  last_name, first_name; </p>
<p>buffer        CLOB :&#x3D; null; – the e-mail message </p>
<p>BEGIN </p>
<p>   FOR rec IN driver LOOP    – generate the e-mail message<br>      buffer :&#x3D; buffer  ||<br>        rec.employee_id || ‘ ‘  ||<br>        rec.last_name   || ‘, ‘ ||<br>        rec.first_name  || chr(10);<br>   END LOOP; </p>
<p>–    Send the e-mail<br>   IF buffer is not null THEN – there are employees without a department<br>      buffer :&#x3D; ‘Employees with no Department’ || CHR(10) || CHR(10) || buffer; </p>
<pre><code>  UTL_MAIL.SEND ( 
          SENDER=&gt;&#39;someone@mycompany.com&#39;, 
      RECIPIENTS=&gt;&#39;audit_list@mycompany.com&#39;, 
         SUBJECT=&gt;&#39;Employee Audit Results&#39;, 
</code></pre>
<p>  CHAPTER 11  AUTOMATING ROUTINE TASKS<br>235<br>             MESSAGE&#x3D;&gt;buffer);<br>   END IF; </p>
<p>END;<br>How It Works<br>The procedure is very straightforward in that it finds all employees with no department. When run as a<br>scheduled job, calls to DBMS_OUTPUT.PUT_LINE won’t work because there is no “screen” to view the output.<br>Instead, the output is collected in a CLOB variable to later use in the UTL_MAIL.SEND procedure. The key to<br>remember in this recipe is there is no screen output from a stored procedure while running as a<br>scheduled job. You must store the intended output and either write it to an operating system file or, as in<br>this example, send it to users in an e-mail.<br>11-3. Using E-mail for Job Status Notification<br>Problem<br>You have a scheduled job that is running on a regular basis, and you need to know whether the job fails<br>for any reason.<br>Solution<br>Use the ADD_JOB_EMAIL_NOTIFICATION procedure to set up an e-mail notification that sends an e-mail<br>when the job fails to run successfully. Note, this solution builds on Recipe 11-1 where a nightly batch job<br>was set up to calculate commissions. </p>
<p>EXEC DBMS_SCHEDULER.ADD_JOB_EMAIL_NOTIFICATION (    -<br>      JOB_NAME&#x3D;&gt;’nightly_commissions’, -<br>    RECIPIENTS&#x3D;&gt; ‘<a href="mailto:&#x6d;&#x65;&#64;&#109;&#121;&#95;&#99;&#111;&#109;&#112;&#97;&#110;&#121;&#46;&#x63;&#x6f;&#109;">&#x6d;&#x65;&#64;&#109;&#121;&#95;&#99;&#111;&#109;&#112;&#97;&#110;&#121;&#46;&#x63;&#x6f;&#109;</a>,<a href="mailto:&#x64;&#105;&#x73;&#116;&#x5f;&#108;&#105;&#115;&#x74;&#x40;&#109;&#x79;&#x5f;&#99;&#x6f;&#x6d;&#112;&#97;&#x6e;&#121;&#x2e;&#99;&#x6f;&#109;">&#x64;&#105;&#x73;&#116;&#x5f;&#108;&#105;&#115;&#x74;&#x40;&#109;&#x79;&#x5f;&#99;&#x6f;&#x6d;&#112;&#97;&#x6e;&#121;&#x2e;&#99;&#x6f;&#109;</a>‘);<br>How It Works<br>The previous recipe is the simplest example of automating e-mail in the event a job fails. The<br>ADD_JOB_EMAIL_NOTIFICATION procedure accepts several parameters; however, the only required<br>parameters are JOB_NAME and RECIPIENTS. The JOB_NAME must already exist from a previous call to the<br>CREATE_JOB procedure (see Recipe 11-1 for an example). The RECIPIENTS is a comma-separated list of e-<br>mail addresses to receive e-mail when an event occurs; by default the events that trigger an e-mail are<br>JOB_FAILED, JOB_BROKEN, JOB_SCH_LIM_REACHED, JOB_CHAIN_STALLED, and JOB_OVER_MAX_DUR. Additional<br>event parameters are JOB_ALL_EVENTS, JOB_COMPLETED, JOB_DISABLED, JOB_RUN_COMPLETED, JOB_STARTED,<br>JOB_STOPPED, AND JOB_SUCCEEDED.<br>The full format of the ADD_JOB_EMAIL_NOTIFICATION procedure accepts additional parameters, but<br>the default for each is sufficient to keep tabs on the running jobs. The body of the e-mail will return the<br>error messages required to debug the issue that caused the job to fail.<br>To demonstrate the notification process, the commissions table was dropped after the job was set<br>up to run. The database produced an e-mail with the following subject and body: </p>
<p>SUBJECT: Oracle Scheduler Job Notification - HR.NIGHTLY_COMMISSIONS JOB_FAILED<br>BODY:<br>Job: JYTHON.NIGHTLY_COMMISSIONS<br>CHAPTER 11  AUTOMATING ROUTINE TASKS<br>236<br>Event: JOB_FAILED<br>Date: 28-AUG-10 03.15.30.102000 PM US&#x2F;CENTRAL<br>Log id: 1118<br>Job class: DEFAULT_JOB_CLASS<br>Run count: 1<br>Failure count: 1<br>Retry count: 0<br>Error code: 6575<br>Error message: ORA-06575: Package or function CALC_COMMISSIONS is in an invalid state<br>11-4. Refreshing a Materialized View on a Timed Interval<br>Problem<br>You have a materialized view that must be refreshed on a scheduled basis to reflect changes made to the<br>underlying table.<br>Solution<br>First, create the materialized view with a CREATE MATERIALIZED VIEW statement. In this example, a<br>materialized view is created consisting of the department and its total salary.: </p>
<p>CREATE MATERIALIZED VIEW dept_salaries<br>BUILD IMMEDIATE<br>AS<br>SELECT department_id, SUM(salary) total_salary<br>FROM employees<br>GROUP BY department_id; </p>
<p>Display the contents of the materialized view: </p>
<p>SELECT *<br>FROM dept_salaries<br>ORDER BY department_id; </p>
<p>DEPARTMENT_ID TOTAL_SALARY </p>
<hr>
<pre><code>       10         6500 
       20        20200 
       30        43500 
       40         6500 
       50       297100 
       60        35000 
       70        10000 
       80       305600 
       90        58000 
      100        51600 
      110        20300 
                  7000 
</code></pre>
<p>  CHAPTER 11  AUTOMATING ROUTINE TASKS<br>237<br>Use the EXEC DBMS_REFRESH.MAKE procedure to set up a refresh of the materialized view: </p>
<p>EXEC DBMS_REFRESH.MAKE (‘HR_MVs’, ‘dept_salaries’, SYSDATE, ‘TRUNC(SYSDATE)+1’); </p>
<p>Change the underlying data of the view.: </p>
<p>UPDATE employees<br>SET salary &#x3D; salary * 1.03; </p>
<p>COMMIT; </p>
<p>Note that the materialized view has not changed: </p>
<p>SELECT *<br>FROM dept_salaries<br>ORDER BY department_id; </p>
<p>DEPARTMENT_ID TOTAL_SALARY </p>
<hr>
<pre><code>       10         6500 
       20        20200 
       30        43500 
       40         6500 
       50       297100 
       60        35000 
       70        10000 
       80       305600 
       90        58000 
      100        51600 
      110        20300 
                  7000 
</code></pre>
<p>Next, manually refresh the materialized view: </p>
<p>EXEC DBMS_REFRESH.REFRESH (‘HR_MVs’); </p>
<p>The materialized view now reflects the updated salaries: </p>
<p>SELECT *<br>FROM dept_salaries<br>ORDER BY department_id; </p>
<p>DEPARTMENT_ID TOTAL_SALARY </p>
<hr>
<pre><code>       10         6695 
       20        20806 
       30        44805 
       40         6695 
       50       306013 
       60        36050 
       70        10300 
       80       314768 
</code></pre>
<p>CHAPTER 11  AUTOMATING ROUTINE TASKS<br>238<br>           90        59740<br>          100        53148<br>          110        20909<br>                      7210<br>How It Works<br>The DBMS_REFRESH.MAKE procedure creates a list of materialized views that refresh at a specified time.<br>Although you could schedule a job that calls the DBMS_REFRESH.REFRESH procedure to refresh the view, the<br>MAKE procedure simplifies this automated task. In addition, once your refresh list is created, you can later<br>add more materialized views to the schedule using the DBMS_REFRESH.ADD procedure.<br> The first argument of the DBMS_REFRESH.MAKE procedure specifies the name of this list; in this<br>example, the list name is HR_MVs. This name must be unique among lists. The next parameter is a list of<br>all materialized views to refresh. The procedure accepts either a comma-separated string of materialized<br>view names or an INDEX BY table, each containing a view name. If the list contains a view not owned by<br>the schema creating the list, then the view name must be qualified with the owner, for example,<br>HR.dept_salaries. The third parameter specifies the first time the refresh will run. In this example,<br>sysdate is used, so the refresh is immediate. The fourth parameter is the interval, which must be a<br>function that returns a date&#x2F;time for the next run time. This recipe uses ‘TRUNC(SYSDATE)+1’, which<br>causes the refresh to run at midnight every night.<br>In this example, the CREATE MATERIALIZED VIEW statement creates a simple materialized view of the<br>total salary by departments, and the data is selected from the view to verify that it is populated with<br>correct data.<br> Note After adding a 3 percent raise to each employee’s salary, we continue to see a materialized view that<br>reflects the old data. The DBMS_REFRESH routine solves that problem.<br>Although the refresh list was created, the content of the materialized view remains unchanged until<br>the automatic update, which occurs every night at midnight. After the refresh occurs, the materialized<br>view will reflect all changes made to employee salary since the last refresh occurred.<br>The manual call to DBMS_REFRESH.REFRESH demonstrates how the content of the materialized view<br>changes once the view is refreshed. Without the call to the REFRESH procedure, the content of the<br>materialized view remains unchanged until the next automated run of the REFRESH procedure.<br>11-5. Synchronizing Data with a Remote Data Source<br>Problem<br>Your database instance requires data that is readily available in another Oracle instance but cannot be<br>synchronized with a materialized view, and you do not want to duplicate data entry.<br>Solution<br>Write a procedure that creates a connection to the remote HR database and performs the steps needed<br>to synchronize the two databases. Then use the EXEC DBMS_SCHEDULER.CREATE_JOB procedure to run the<br>  CHAPTER 11  AUTOMATING ROUTINE TASKS<br>239<br>procedure on a regular basis. Suppose, for example, that your Oracle Database instance requires data<br>from the HR employee table, which is in another instance. In addition, your employee table contains<br>tables with foreign key references on the employee_id that prevents you from using a materialized view<br>to keep the HR employee table in synchronization.<br>Create a database connection to the remote HR database, and then download the data on a regular<br>basis: </p>
<p>CREATE DATABASE LINK hr_data<br>CONNECT TO hr<br>IDENTIFIED BY hr_password<br>USING<br>‘(DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;TCP)(HOST&#x3D;node_name)(PORT&#x3D;1521))(CONNECT_DATA&#x3D;(SERVICE_NAME&#x3D;h<br>r_service_name)))’; </p>
<p>CREATE OR REPLACE PROCEDURE sync_hr_data AS </p>
<p>CURSOR    driver IS<br>SELECT    *<br>FROM    employees@hr_data; </p>
<p>TYPE    recs_type IS TABLE OF driver%ROWTYPE INDEX BY BINARY_INTEGER;<br>recs    recs_type; </p>
<p>BEGIN </p>
<p>   OPEN DRIVER;<br>   FETCH DRIVER BULK COLLECT INTO recs;<br>   CLOSE DRIVER; </p>
<p>   FOR i IN 1..recs.COUNT LOOP<br>      UPDATE employees<br>      SET    first_name      &#x3D; recs(i).first_name,<br>        last_name            &#x3D; recs(i).last_name,<br>        email                &#x3D; recs(i).email,<br>        phone_number         &#x3D; recs(i).phone_number,<br>        hire_date            &#x3D; recs(i).hire_date,<br>        job_id               &#x3D; recs(i).job_id,<br>        salary               &#x3D; recs(i).salary,<br>        commission_pct       &#x3D; recs(i).commission_pct,<br>        manager_id           &#x3D; recs(i).manager_id,<br>        department_id        &#x3D; recs(i).department_id<br>      WHERE  employee_id     &#x3D; recs(i).employee_id<br>      AND    (    NVL(first_name,’<del>‘)  &lt;&gt; NVL(recs(i).first_name,’</del>‘)<br>       OR    last_name                 &lt;&gt; recs(i).last_name<br>       OR    email                     &lt;&gt; recs(i).email<br>       OR    NVL(phone_number,’<del>‘)     &lt;&gt; NVL(recs(i).phone_number,’</del>‘)<br>       OR    hire_date                 &lt;&gt; recs(i).hire_date<br>       OR    job_id                    &lt;&gt; recs(i).job_id<br>       OR    NVL(salary,-1)            &lt;&gt; NVL(recs(i).salary,-1)<br>       OR    NVL(commission_pct,-1)    &lt;&gt; NVL(recs(i).commission_pct,-1)<br>       OR    NVL(manager_id,-1)        &lt;&gt; NVL(recs(i).manager_id,-1)<br>       OR    NVL(department_id,-1)     &lt;&gt; NVL(recs(i).department_id,-1)<br>CHAPTER 11  AUTOMATING ROUTINE TASKS<br>240<br>        );<br>   END LOOP;<br>– find all new rows in the HR database since the last refresh<br>   INSERT INTO employees<br>   SELECT *<br>   FROM   employees@hr_data<br>   WHERE  employee_id NOT IN (<br>    SELECT    employee_id<br>    FROM      employees);<br>END sync_hr_data;<br>EXEC DBMS_SCHEDULER.CREATE_JOB (            -<br>          JOB_NAME&#x3D;&gt;’sync_HR_employees’,    -<br>          JOB_TYPE&#x3D;&gt;’STORED_PROCEDURE’,     -<br>        JOB_ACTION&#x3D;&gt;’sync_hr_data’,         -<br>           ENABLED&#x3D;&gt;TRUE,                   -<br>    REPEAT_INTERVAL&#x3D;&gt;’FREQ&#x3D;DAILY;INTERVAL&#x3D;1;BYHOUR&#x3D;00;BYMINUTE&#x3D;30’);<br>How It Works<br>A database link is required to access the data. This recipe focuses more on the synchronization process,<br>but the creation of the database link is demonstrated here. This link, when used, will remotely log into<br>the HR instance as the HR schema owner.<br>The procedure sync_hr_data reads all records from the HR instances. It does so in a BULK COLLECT<br>statement, because this is the most efficient method to read large chunks of data, especially over a<br>remote connection. The procedure then loops through each of the employee records updating the local<br>records, but only if the data changed, because there is no need to issue the UPDATE unless something has<br>changed. The NVL is required in the WHERE clause to accommodate values that are NULL and change to a<br>non-NULL value, or vice versa.<br>The final step is to schedule the nightly job. The CREATE_JOB procedure of the DBMS_SCHEDULER<br>package completes this recipe. The stored procedure sync_hr_data is executed nightly at 12:30 a.m. See<br>Recipe 11-1 for more information on scheduling a nightly batch job.<br>11-6. Scheduling a Job Chain<br>Problem<br>You have several PL&#x2F;SQL procedures that must run in a fixed sequence—some steps sequentially, others<br>in parallel. If one step fails, processing should stop.<br>Solution<br>Use the DBMS_SCHEDULER _CHAIN commands to create and define the order of execution of the chained<br>procedures. Figure 11-1 depicts a simple example of a chain of procedures where the successful<br>completion of step 1 kicks off parallel executions of two additional steps. When the two parallel steps<br>compete successfully, the final step runs.<br>  CHAPTER 11  AUTOMATING ROUTINE TASKS<br>241 </p>
<p>Figure 11-1. Flowchart representation of a job chain.<br>The following code shows how you can use the CREATE_CHAIN, CREATE_PROGRAM, DEFINE_CHAIN_STEP,<br>and DEFINE_CHAIN_RULE options to implement the order of execution shown in Figure 11-1. </p>
<p>– Define the Chain<br>BEGIN<br>   DBMS_SCHEDULER.CREATE_CHAIN (<br>    CHAIN_NAME    &#x3D;&gt; ‘Chain1’);<br>END; </p>
<p>– Create&#x2F;define the program to run in each step<br>BEGIN<br>   DBMS_SCHEDULER.CREATE_PROGRAM (<br>    PROGRAM_NAME    &#x3D;&gt; ‘Program1’,<br>    PROGRAM_TYPE    &#x3D;&gt; ‘STORED_PROCEDURE’,<br>    PROGRAM_ACTION  &#x3D;&gt; ‘Procedure1’,<br>    ENABLED         &#x3D;&gt; true);<br>END; </p>
<p>BEGIN<br>   DBMS_SCHEDULER.CREATE_PROGRAM (<br>    PROGRAM_NAME    &#x3D;&gt; ‘Program2’,<br>    PROGRAM_TYPE    &#x3D;&gt; ‘STORED_PROCEDURE’,<br>    PROGRAM_ACTION  &#x3D;&gt; ‘Procedure2’,<br>    ENABLED         &#x3D;&gt; true);<br>END; </p>
<p>BEGIN<br>   DBMS_SCHEDULER.CREATE_PROGRAM (<br>CHAPTER 11  AUTOMATING ROUTINE TASKS<br>242<br>    PROGRAM_NAME    &#x3D;&gt; ‘Program3’,<br>    PROGRAM_TYPE    &#x3D;&gt; ‘STORED_PROCEDURE’,<br>    PROGRAM_ACTION  &#x3D;&gt; ‘Procedure3’,<br>    ENABLED         &#x3D;&gt; true);<br>END; </p>
<p>BEGIN<br>   DBMS_SCHEDULER.CREATE_PROGRAM (<br>    PROGRAM_NAME    &#x3D;&gt; ‘Program4’,<br>    PROGRAM_TYPE    &#x3D;&gt; ‘STORED_PROCEDURE’,<br>    PROGRAM_ACTION  &#x3D;&gt; ‘Procedure4’,<br>    ENABLED         &#x3D;&gt; true);<br>END; </p>
<p>– Create each step using a unique name<br>BEGIN<br>   DBMS_SCHEDULER.DEFINE_CHAIN_STEP (<br>    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,<br>    STEP_NAME    &#x3D;&gt; ‘Step1’,<br>    PROGRAM_NAME &#x3D;&gt; ‘Program1’);<br>END; </p>
<p>BEGIN<br>   DBMS_SCHEDULER.DEFINE_CHAIN_STEP (<br>    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,<br>    STEP_NAME    &#x3D;&gt; ‘Step2_1’,<br>    PROGRAM_NAME &#x3D;&gt; ‘Program2’);<br>END; </p>
<p>BEGIN<br>   DBMS_SCHEDULER.DEFINE_CHAIN_STEP (<br>    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,<br>    STEP_NAME    &#x3D;&gt; ‘Step2_2’,<br>    PROGRAM_NAME &#x3D;&gt; ‘Program3’);<br>END; </p>
<p>BEGIN<br>   DBMS_SCHEDULER.DEFINE_CHAIN_STEP (<br>    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,<br>    STEP_NAME    &#x3D;&gt; ‘Step3’,<br>    PROGRAM_NAME &#x3D;&gt; ‘Program4’);<br>END; </p>
<p>– Define the step rules; which step runs first and their order<br>BEGIN<br>   DBMS_SCHEDULER.DEFINE_CHAIN_RULE (<br>    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,<br>    CONDITION    &#x3D;&gt; ‘TRUE’,<br>    ACTION       &#x3D;&gt; ‘START Step1’); </p>
<p>END; </p>
<p>  CHAPTER 11  AUTOMATING ROUTINE TASKS<br>243<br>BEGIN<br>   DBMS_SCHEDULER.DEFINE_CHAIN_RULE (<br>    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,<br>    CONDITION    &#x3D;&gt; ‘Step1 COMPLETED’,<br>    ACTION       &#x3D;&gt; ‘START Step2_1, Step2_2’);<br>END; </p>
<p>BEGIN<br>   DBMS_SCHEDULER.DEFINE_CHAIN_RULE (<br>    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,<br>    CONDITION    &#x3D;&gt; ‘Step2_1 COMPLETED AND Step2_2 COMPLETED’,<br>    ACTION       &#x3D;&gt; ‘START Step3’);<br>END; </p>
<p>BEGIN<br>   DBMS_SCHEDULER.DEFINE_CHAIN_RULE (<br>    CHAIN_NAME   &#x3D;&gt; ‘Chain1’,<br>    CONDITION    &#x3D;&gt; ‘Step3 COMPLETED’,<br>    ACTION       &#x3D;&gt; ‘END’);<br>END; </p>
<p>– Enable the chain<br>BEGIN<br>   DBMS_SCHEDULER.ENABLE (‘Chain1’);<br>END;<br>&#x2F; </p>
<p>– Schedule a Job to run the chain every night<br>BEGIN<br>   DBMS_SCHEDULE.CREATE_JOB (<br>    JOB_NAME        &#x3D;&gt; ‘chain1_Job’,<br>    JOB_TYPE        &#x3D;&gt; ‘CHAIN’,<br>    JOB_ACTION      &#x3D;&gt; ‘Chain1’,<br>    REPEAT_INTERVAL &#x3D;&gt; ‘freq&#x3D;daily;byhour&#x3D;3;byminute&#x3D;0;bysecond&#x3D;0’,<br>    enabled         &#x3D;&gt; TRUE);<br>END;<br>How It Works<br>Defining and scheduling a job chain may seem daunting at first but can be broken down into the<br>following steps:<br>Create the chain.<br>Define each program that will run.<br>Create each step in the chain.<br>Create the rules that link the chain together.<br>Enable the chain.<br>Schedule the chain as a job to run a specific time or interval.<br>CHAPTER 11  AUTOMATING ROUTINE TASKS<br>244 </p>
<p>The DBMS_SCHEDULER.CREATE_CHAIN procedure creates a chain named as Chain1.<br> Note The chain_name must be unique and will be used in subsequent steps.<br>The DBMS_SCHEDULER.CREATE_PROGRAM procedure defines the executable code that will run. The<br>programs defined here are run when a chain step is executed. The procedure accepts the following<br>parameters:<br>• PROGRAM_NAME: A unique name to identify the program.<br>• PROGRAM_TYPE : Valid values are plsql_block, stored_procedure, and executable.<br>• PROGRAM_ACTION : Defines what code actually runs when executed based on the<br>value for PROGRAM_TYPE. For a PROGRAM_TYPE of PLSQL_BLOCK, it is a text string of the<br>PL&#x2F;SQL code to run. For a STORED_PROCEDURE, it is the name of an internal PL&#x2F;SQL<br>procedure. For an EXECUTABLE, it is the name of an external program.<br>• ENABLE : Determines whether the program can be executed; the default is FALSE if<br>not specified.<br>The DBMS_SCHEDULER.DEFINE_CHAIN_STEP procedure defines each step in the chain. You must supply<br>the chain’s name as its first parameters, which was created in the DBMS_SCHEDULER.CREATE_CHAIN<br>procedure, along with a unique name for the step in the chained process and the name of the PL&#x2F;SQL<br>program to execute during the step. Note that the program is the name assigned in the<br>DBMS_SCHEDULER.CREATE_PROGRAM procedure; it is not the name of your PL&#x2F;SQL program.<br>The DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure defines how each step in the chain is linked<br>together. Arguably, this is the most difficult step in the process because you must define the starting and<br>ending steps in the chain properly. In addition, you must take care in defining links between sequential<br>steps and parallel steps. Sketching a flow chart like the one shown in Figure 11-1 can aid in the<br>sequencing of the chain steps.<br>The DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure accepts the following parameters:<br>• CHAIN_NAME: The name used when you created the chain.<br>• CONDITION: An expression that must evaluate to a boolean expression and must<br>evaluate to true to perform the action. Possible test conditions are NOT_STARTED,<br>SCHEDULED, RUNNING, PAUSED, STALLED, SUCCEEDED, FAILED, and STOPPED.<br>• ACTION: The action to perform when the condition evaluates to true. Possible<br>actions are start a step, stop a step, or end the chain.<br>• RULE_NAME: The name you want to give to the rule being created. If omitted, Oracle<br>will generate a unique name.<br>• COMMENTS : Optional text to describe the rule.<br>In this example, the first call to the DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure sets the condition<br>to TRUE and the action to START Step1. This causes step 1 to run immediately when the chain starts. The<br>next call to the DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure defines the action to take when step 1<br>  CHAPTER 11  AUTOMATING ROUTINE TASKS<br>245<br>completes successfully. In this example, steps 2.1 and 2.2 are started. Starting multiple steps<br>simultaneously allows you to schedule steps to run in parallel. In the third call to the<br>DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure, the condition waits for the successful completion of<br>steps 2.1 and 2.2 and then starts step 3 as its action. The final call to the<br>DBMS_SCHEDULER.DEFINE_CHAIN_RULE procedure waits for the successful completion of step 3 and then<br>ends the chain.<br>If any step in the chain fails, the entire chained process stops at its next condition test. For example,<br>if step 1 fails, steps 2.1 and 2.2 are never started. However, if steps 2.1 and 2.2 are running and step 2.1<br>fails, step 2.2 will continue to run and may complete successfully, but step 3 will never run. You can<br>account for chain failures and other conditions by testing for a condition such as NOT_STARTED,<br>SCHEDULED, RUNNING, PAUSED, STALLED, FAILED, and STOPPED.<br>The call to the procedure DBMS_SCHEDULER.ENABLE does just what you expect; it enables the chain to<br>run. It is best to keep the chain disabled while defining the steps and rules. You can run the chain<br>manually with a call to the DBMS_SCHEDULE.RUN_CHAIN procedure or, as shown in this example, with a call<br>to the DBMS_SCHEDULE.CREATE_JOB procedure. See Recipe 11-1 for more information on scheduling a job. </p>
<p>C H A P T E R  12 </p>
<p>   </p>
<p>247<br>Oracle SQL Developer<br>Tools can be useful for increasing productivity while developing code. They oftentimes allow you to take<br>shortcuts when coding by providing templates to start from or by providing autocompletion as words<br>are typed. A good development tool can also be useful by incorporating several different utilities and<br>functions into one development environment. Oracle SQL Developer is no exception, because it<br>provides functionality for database administrators and PL&#x2F;SQL developers alike. Functionalities include<br>creating database tables, importing and exporting data, managing and administering multiple<br>databases, and using robust PL&#x2F;SQL development tools.<br>Oracle SQL Developer is an enterprise-level development environment, and it would take an entire<br>book to document each of its features. Rather than attempting to cover each of the available options, this<br>chapter will focus on developing and maintaining Oracle PL&#x2F;SQL code using the tool. Along the way, you<br>will learn how to configure database connections and obtain information from database objects. In the<br>end, you should feel comfortable developing PL&#x2F;SQL applications using the Oracle SQL Developer<br>environment.<br>12-1. Creating Standard and Privileged Database Connections<br>Problem<br>You want to create a persistent connection to your database from within Oracle SQL Developer using<br>both privileged and standard accounts so that you can work with your database.<br>Solution<br>Open Oracle SQL Developer, and select New from the File menu. This will open the Create a New<br>window. Select the Database Connection option, and click OK. A New&#x2F;Select Database Connection<br>window opens, which has a list of existing database connections on the left side and an input form for<br>creating a new connection on the right side, as shown in Figure 12-1. </p>
<p>CHAPTER 12  ORACLE SQL DEVELOPER<br>248 </p>
<p>Figure 12-1. Creating a database connection<br>If you are creating a standard connection, choose the Basic connection type. If you are creating a<br>privileged connection as SYS, then choose the SYSDBA connection type. Once you have created a<br>connection, then you will be able to connect to the database via the user for which you have made a<br>connection and browse the objects belonging to that user’s schema.<br>How It Works<br>Before you can begin working with PL&#x2F;SQL code in Oracle SQL Developer, you must create a database<br>connection. Once created, this connection will remain in the database list that is located on the left side<br>of the Oracle SQL Developer environment. During the process of creating the connection, you can either<br>select the box to allow the password to be cached or keep it deselected so that you will be prompted to<br>authenticate each time you want to use the connection. From a security standpoint, it is advised that you<br>leave the box unchecked so that you are prompted to authenticate for each use.<br>Once the connection has been successfully established and you are authenticated, the world of<br>Oracle SQL Developer is opened up, and you have a plethora of options available. At this point, you have<br>the ability to browse through all the database tables, views, stored programs, and other objects that are<br>available to the user account that you used to initiate the connection to the database by simply using the<br>tree menu located within the left pane of the environment. Figure 12-2 shows a sample of what you will<br>see when your database connection has been established. </p>
<p>  CHAPTER 12  ORACLE SQL DEVELOPER<br>249 </p>
<p>Figure 12-2. Database connection in the navigator<br> Note If you plan to develop PL&#x2F;SQL code for system events such as an AFTER LOGON trigger, you should create a<br>separate connection for the privileged user using SYSDBA. This will allow you to traverse the privileged database<br>objects.<br>As mentioned in the introduction to this chapter, you will learn how to use those features provided<br>by Oracle SQL Developer that are useful for PL&#x2F;SQL application development. This does not mean the<br>other features offered by the environment are not useful, but it would take an entire book to cover each<br>feature that Oracle SQL Developer has to offer. Indeed, there are entire books on the topic. This book<br>strives to provide you with the education and concepts that you will need to know to develop complete<br>and robust PL&#x2F;SQL applications using Oracle SQL Developer.<br>12-2. Obtaining Information About Tables<br>Problem<br>You are interested in learning more about a particular database table. You also want to look at system<br>triggers and other privileged PL&#x2F;SQL objects.<br>Solution<br>Use the Oracle SQL Developer navigator to select the table that you want to view information about, as<br>demonstrated in Figure 12-3.  </p>
<p>CHAPTER 12  ORACLE SQL DEVELOPER<br>250<br>Figure 12-3. Viewing table information<br>The editor window will then populate with a tab that consists of a worksheet and several subtabs.<br>Each of these tabs provides different information about the table you are inspecting. Figure 12-4 shows<br>the Columns tab of the Table Editor.<br>Figure 12-4. Table Editor<br>How It Works<br>Oracle SQL Developer provides an excellent means for examining table metadata. When a table is<br>selected within the database connection navigator, a worksheet becomes available that includes detailed<br>information pertaining to the table characteristics and data. The first tab, which is labeled Columns,<br>includes information about the table columns and each of their datatypes. This is most likely the tab that<br>you will spend the most time in. It includes toolbar buttons that allow you to perform editing on the<br>table and to refresh the table view in the editor, and it even includes an extensive table manipulation<br>menu labeled Action that is a database administrator’s dream come true.<br>Next, the Data tab provides a live view of the data that exists within the table. It also includes toolbar<br>buttons for inserting and deleting rows. This tab resembles a spreadsheet, and it allows different<br>columns to be edited and then committed to the database. For a PL&#x2F;SQL developer, it is most useful for<br>editing data within a table that is being used for application debugging or testing purposes.<br>The Triggers tab will be useful to PL&#x2F;SQL developers because it displays a selectable list of all table<br>triggers. You can also create new triggers from the tab. Figure 12-5 shows the Triggers tab.<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>251 </p>
<p>Figure 12-5. Triggers tab of editor<br>When a trigger is selected on the Triggers tab, its DDL is displayed in a panel on the bottom half of<br>the window. The green arrow button will allow the trigger to be executed, and the refresh specifies an<br>interval of time. You will learn more about trigger development in Recipe 12-11.<br>Oracle SQL Developer provides very useful information regarding database tables for PL&#x2F;SQL<br>developers. It also provides convenient access for trigger development and manipulation.<br>12-3. Enabling Output to Be Displayed<br>Problem<br>You want to display the results of DBMS_OUTPUT within Oracle SQL Developer.<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>252<br>Solution<br>Enable DBMS_OUTPUT for your connection via the Dbms Output pane. This pane resides on the lower-right<br>side of the IDE. Do so by selecting the green plus icon within the pane and then choosing the desired<br>connection from the resulting dialog box. Figure 12-6 shows the connection dialog box. After selecting<br>the desired connection and then clicking the OK button, you will be prompted for a password for the<br>connection if you are not already connected. Once a successful password has been entered, then<br>DBMS_OUTPUT will be enabled for the specified connection. </p>
<p>Figure 12-6. Select Connection dialog box<br>After enabling the DBMS_OUTPUT option, you will be able to see the output from DBMS_OUTPUT within<br>Oracle SQL Developer. This can be very useful, especially for testing purposes.<br>How It Works<br>The easiest way to enable SERVEROUTPUT for a particular database connection is to enable DBMS_OUTPUT<br>from within the Dbms Output window. Doing so will enable output to be displayed within the pane<br>when the code is executed.<br>  Note For more information on the DBMS_OUTPUT package, please see Recipe 1-6.<br>Selecting the Dbms Output option from the View menu will open the DBMS_OUTPUT pane. This pane<br>gives you several options that include the ability to save the script output, change the buffer size, and<br>even print the output. To enable SERVEROUTPUT via the pane, you must select the green plus symbol and<br>choose a database connection. You will see the correct script output if you run the script again after<br>enabling DBMS_OUTPUT via one of the two options we have discussed. Figure 12-7 shows the Dbms Output<br>pane. </p>
<p>  CHAPTER 12  ORACLE SQL DEVELOPER<br>253 </p>
<p>Figure 12-7. Dbms Output pane<br>Once a connection has been established using the Dbms Output pane, all DBMS_OUTPUT code that is<br>executed against that connection will be displayed within the pane. It is possible to have more than one<br>connection established within the pane, and in this case different tabs can be used to select the<br>connection of your choice.<br>12-4. Writing and Executing PL&#x2F;SQL<br>Problem<br>You want to use Oracle SQL Developer to execute an anonymous block of code.<br>Solution<br>Establish a connection to the database of your choice, and the SQL worksheet will automatically open.<br>Once the worksheet has opened, you can type the code directly into it. For the purposes of this recipe,<br>type or copy&#x2F;paste the following anonymous block into a SQL worksheet: </p>
<p>DECLARE<br>  CURSOR emp_cur IS<br>  SELECT * FROM employees; </p>
<p>  emp_rec emp_cur%ROWTYPE;<br>BEGIN<br>  FOR emp_rec IN emp_cur LOOP<br>    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ‘ ‘ || emp_rec.last_name);<br>  END LOOP;<br>END; </p>
<p>Figure 12-8 shows the Oracle SQL Developer worksheet after this anonymous block has been<br>written into it. </p>
<p>CHAPTER 12  ORACLE SQL DEVELOPER<br>254 </p>
<p>Figure 12-8. Oracle SQL Developer worksheet with PL&#x2F;SQL anonymous block<br>How It Works<br>By default, when you establish a connection within Oracle SQL Developer, a SQL worksheet for that<br>connection is opened. This worksheet can be used to create anonymous code blocks, run SQL<br>statements, and create PL&#x2F;SQL code objects. The SQL worksheet is analogous to the SQL<em>Plus command<br>prompt, although it does not allow all the same commands that are available using SQL</em>Plus.<br>If you want to open more than one SQL worksheet or a new worksheet for a connection, this can be<br>done in various ways. You can right-click (Ctrl+click) the database connection of your choice and then<br>select Open SQL Worksheet from the menu. Another way to open a new worksheet is to use the SQL<br>Worksheet option within the Tools menu. This will allow you to specify the connection of your choice to<br>open a worksheet against.<br>As you type, you will notice that the worksheet will place all Oracle keywords into a different color.<br>This helps distinguish between keywords and defined variables or stored programs. By default, the<br>keywords are placed into a bold blue text, but this color can be adjusted within the user Preferences<br>window that can be accessed from the Tools drop-down menu. Similarly, any text placed within single<br>quotes will appear in a different color. By default, this is also blue, except it is not bold.<br>Besides the syntax coloring, there are some other features of the SQL worksheet that can help make<br>your programming life easier. Oracle SQL Developer will provide autocompletion for some SQL and<br>PL&#x2F;SQL statements. For instance, if you enter a package name and type a dot, all the package members<br>will be displayed in the drop-down list. You can also press Ctrl+spacebar to manually activate the<br>autocomplete drop-down list. After the drop-down list appears, you can use the arrow keys to choose<br>the option you want to use and then hit the Tab key. Oracle SQL Developer provides similar<br>autocompletion for table and column names and even SQL statement GROUP BY and ORDER BY clauses.<br>Take a look at Figure 12-9 to see the autocomplete feature in action. </p>
<p>  CHAPTER 12  ORACLE SQL DEVELOPER<br>255 </p>
<p>Figure 12-9. Autocomplete drop-down list<br>Another feature that helps productivity is to use Oracle SQL Developer snippets. To learn more<br>about snippets, please see Recipe 12-7. Within the SQL worksheet toolbar, there is a group of buttons<br>that can be used to help increase programmer productivity. The group of buttons at the far-right side of<br>the toolbar contains a button for making highlighted words uppercase, lowercase, and initial-cap. The<br>button that has an eraser on it can be used to quickly clear the SQL worksheet. There is also button that<br>can be used to display the SQL History panel. This SQL History panel opens along the bottom of the<br>Oracle SQL Developer environment, and it contains all the SQL that has been entered into the<br>worksheet. Double-clicking any line of the history will automatically add that SQL to the current<br>worksheet. Figure 12-10 shows the SQL History window. </p>
<p>Figure 12-10. SQL History window<br>To execute the SQL or PL&#x2F;SQL that is contained within the script, you can use the first two toolbar<br>icons. The first icon in the toolbar (as shown in Figure 12-8) is a green arrow will execute the code that is<br>in the worksheet and display the result in a separate pane. The second icon in the toolbar (as shown in<br>Figure 12-8) that resembles a piece of paper with a green arrow in front will execute the code within the<br>worksheet and then display the output in a pane that can be saved as script output.<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>256<br> Note It is possible to have more than one SQL statement or PL&#x2F;SQL block within the SQL worksheet at the same<br>time. In doing so, only the highlighted code will be executed when the green arrow button is selected. If all the<br>code is selected, then a separate output pane will appear for the output of each block or statement. However, if<br>the Script icon (paper with green arrow) is selected, then all the highlighted code will have its output displayed in<br>the resulting script output pane.<br>Other toolbar options within the SQL worksheet include the ability to COMMIT or ROLLBACK changes<br>that are made, run an explain plan on the current code, or set up autotrace. The SQL worksheet is like<br>SQL*Plus with many additional features. It provides the power of many tools in one easy-to-use<br>environment.<br>12-5. Creating and Executing a Script<br>Problem<br>You are interested in creating a PL&#x2F;SQL script using Oracle SQL Developer that will run against your<br>database. Once it has been created, you want to save it and then execute it.<br>Solution<br>Establish a connection to the database for which you want to create a script. By default, the SQL<br>worksheet for the selected database will open. To create a script, choose New from the File menu or<br>select the first icon on the left side of the toolbar that resembles a piece of paper with a plus sign. Next,<br>select the SQL File option from the Create a New window. When the Create SQL File window opens, type<br>in a file name for your script, and choose a directory in which to store it. For the purposes of this<br>demonstration, choose the file name select_employees, browse and choose the desired storage location,<br>and click OK. At this point, a new tab opens in the Oracle SQL Developer editor. This tab represents the<br>SQL file you have just created. Type the following script into the editor for demonstration purposes: </p>
<p>DECLARE<br>  CURSOR emp_cur IS<br>  SELECT * FROM employees; </p>
<p>  emp_rec emp_cur%ROWTYPE;<br>BEGIN<br>  FOR emp_rec IN emp_cur LOOP<br>    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ‘ ‘ || emp_rec.last_name);<br>  END LOOP;<br>END; </p>
<p>After the script has been typed into the editor, your Oracle SQL Developer editor should resemble<br>that shown in Figure 12-11. Save your script by clicking the Save icon that looks like a disk, or choose<br>Save from the File menu.<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>257 </p>
<p>Figure 12-11. Typing a script into the SQL editor<br>To execute the script, click the Run Script icon that is the second icon from the left above the editor,<br>or press the F5 function key. You will be prompted to select a database connection. At this point, you can<br>choose an existing connection, create a new connection, or edit an existing connection. Choose the<br>database connection that coincides with the schema for this book. Once you select the connection, the<br>script will execute against the database, and you will see another pane appear in the lower half of the<br>Oracle SQL Developer window. This is the Script Output pane, and you should see a message that states<br>“anonymous block completed.” The editor should now look like Figure 12-12. </p>
<p>Figure 12-12. Anonymous block completed<br>How It Works<br>In the solution to this recipe, you learned how to create and execute a script using Oracle SQL<br>Developer. As you were typing the script, you may have noticed that the text being typed is color-coded.<br>Oracle SQL Developer places PL&#x2F;SQL and SQL keywords into a different color text that can be chosen<br>from within the preferences window, which is located within the Tools menu. The default color for<br>keywords is blue.<br>When the script is executed, it prompts for a database connection to use. Once that connection has<br>been selected and established, then the script is run against the database. The script may not display any<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>258<br>useful results by default, unless the SERVEROUTPUT has been enabled via the Dbms Output pane. To learn<br>more about enabling DBMS_OUTPUT, please see Recipe 12-3.<br>When you select the Save option, the script is written to disk to a file having the name you specified<br>earlier. To execute a saved script, open the File menu, and then select the Open option. A dialog box will<br>open that allows you to browse your file system for the script that you want to open. Once you have<br>found the script and opened it, a new tab is opened, and the script is loaded into that tab along with all<br>the options of an ordinary SQL worksheet (see Figure 12-13). </p>
<p>Figure 12-13. Loaded script<br>12-6. Accepting User Input for Substitution Variables<br>Problem<br>You want to create a PL&#x2F;SQL application that accepts user input from the keyboard. To test the input,<br>you want to have Oracle SQL Developer prompt you for input.<br>Solution<br>Use an ampersand in front of a text string just like in SQL<em>Plus. Assign the resulting user variable to a<br>PL&#x2F;SQL variable, or use the value inline.<br>How It Works<br>Just as SQL</em>Plus treats the ampersand as a token to denote user input, Oracle SQL Developer does the<br>same. When an ampersand is encountered, Oracle SQL Developer will display a pop-up box to prompt<br>the user for the input. For example, type or copy and paste the following code into the SQL worksheet,<br>and then select the Run Statement toolbar button. </p>
<p>DECLARE<br>    email     VARCHAR2(25);<br>BEGIN<br>  SELECT   email<br>  INTO  email<br>  FROM employees<br>  WHERE employee_id &#x3D; &amp;emp_id; </p>
<p>  DBMS_OUTPUT.PUT_LINE(‘Email Address for ID: ‘ || email);<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>259<br>EXCEPTION<br>  WHEN OTHERS THEN<br>    DBMS_OUTPUT.PUT_LINE(‘An unknown error has occured, please try again.’);<br>END; </p>
<p>When the code is executed, you will be prompted to provide a value for the emp_id variable. A<br>separate dialog box that looks like the one shown in Figure 12-14 is displayed. </p>
<p>Figure 12-14. Entering substitution variable<br>If the value being accepted from the user is a string, then the ampersand-variable must be placed<br>within single quotes. For example, &amp;last_name would be used to prompt for user entry of a string value.<br>12-7. Saving Pieces of Code for Quick Access<br>Problem<br>You want to save a portion of code so that it can be made easily reusable by other PL&#x2F;SQL programs.<br>  Tip This recipe also works for frequently used bits of SQL.<br>Solution<br>Use the Snippets window to create the reusable piece of code and use it for access at a later time.<br>How It Works<br>The Snippets window can be accessed by selecting the View menu and then choosing the Snippets<br>option. The Snippets window will open as a pane on the far-right side of the Oracle SQL Developer<br>environment. The pane consists of a toolbar that includes a button used for creating a new snippet and a<br>button for editing an existing snippet. There is also a drop-down menu that consists of several menu<br>options that organize each of the snippets into a different category. Figure 12-15 shows the Snippets<br>pane. </p>
<p>CHAPTER 12  ORACLE SQL DEVELOPER<br>260<br>Figure 12-15. Snippets<br>The snippet is used by dragging its text onto a SQL worksheet or script. Once dragged onto the<br>worksheet, the actual code is displayed in a template fashion. In some cases, you will need to change a<br>bit of the text to make it usable, but the reusable code that is provided by the snippet can greatly reduce<br>development time.<br>You can add your own snippet by selecting the icon that resembles a piece of paper with a plus sign<br>on it from the Snippets panel. This opens the Save Snippet window (as shown in Figure 12-16) that gives<br>you the option of using one of the existing categories or typing a new one. You can also type a name and<br>tooltip for the snippet. The name of the snippet will appear in the Snippets panel after it has been saved.<br>The text of the snippet itself will be placed into the worksheet once you drag the name of your snippet to<br>a worksheet or script.<br>Figure 12-16. Save Snippet pane<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>261<br>The Edit Snippet icon (the one with the pencil through it) brings up another window that allows you<br>to choose an existing snippet to edit, create a new snippet, or delete a snippet. Only those snippets that<br>you have created are available for editing. Figure 12-17 displays the Edit Snippets window. </p>
<p>Figure 12-17. Edit Snippets window<br>The snippets are actually saved within an XML file named UserSnippets.xml. This file is located in<br>your user sqldeveloper directory. This file can be transported to another machine and placed into the<br>sqldeveloper directory so that the snippets can be made available in more than one place. This can be<br>useful if you have a group of developers who may want to share snippets. The ability to copy the<br>UserSnippets.xml file into other user sqldeveloper directories and make the snippets available to other<br>users can certainly be advantageous.<br>Snippets can be useful for saving the time of typing a SQL or PL&#x2F;SQL construct. They can also be<br>beneficial if you do not remember the exact syntax of a particular piece of code. They provide quick<br>access to template-based solutions.<br>12-8. Creating a Function<br>Problem<br>You want to create a function using Oracle SQL Developer.<br>Solution<br>You can manually create the function by typing the code into the SQL worksheet for the database<br>connection for which you want to create. You can also use the Create Function Wizard within Oracle<br>SQL Developer to provide some assistance throughout the function creation process. There are a couple<br>p<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>262<br>of different ways to invoke the Create Function Wizard. If you go to the File menu and select New, the<br>Create a New window opens, and Function is one of the available options. You can also reach the same<br>menu by selecting the New toolbar button. Both of these paths will lead you to the same window<br>because after clicking OK, the Create PL&#x2F;SQL Function window will appear (Figure 12-18).  </p>
<p>Figure 12-18. Create PL&#x2F;SQL Function window<br>A final way to invoke this same window is to establish a database connection and then expand the<br>connection navigator to list all subfolders and then right-click the Functions subfolder. One of the<br>available options after doing so will be New Function.<br>How It Works<br>If using the SQL worksheet to create a function, you will need to type the code for creating your function<br>into the editor and then click the Run button to compile and save the object. If any errors are<br>encountered while compiling, they will appear in the Messages window along with the line number that<br>they occurred on. The SQL worksheet works very well for those who are well accustomed to creating<br>functions. The Create Function Wizard may be the best choice for creating a function or those who like<br>to write less code.<br> Note Using the Connections pane, you are able to browse both valid and invalid objects. An object may become<br>invalid if it is not compilable, becomes stale, or because of issues with other dependencies.<br>Once within the Create PL&#x2F;SQL Function window, you will be able to name the function and specify<br>any parameters that will need to be used. The first parameter in the list is already defined by default, and<br>it represents the function’s return value. You can change the return type by selecting from the list of<br>datatype options within the Type column of the parameter listing.<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>263<br>To add a new parameter, click the plus symbol on the right side of the window, and a new line will<br>be added to the parameter-listing table. You can then populate the name of the parameter, select a<br>datatype and mode, and designate a default value if one should exist. After all parameters have been<br>declared, click the OK button to continue.<br>The function editor window will open, and it will contain the code that needs to be used for creation<br>of the function that you have defined. All that is left to code will be any declarations and then the actual<br>function code. The editor window contains a toolbar of options along with several tabs that can be used<br>to find out more information about a function once it has been created (Figure 12-19). </p>
<p>Figure 12-19. The Function Editor window<br>The remaining function declarations and code should be typed into the editor, and when<br>completed, the Save toolbar button or menu option can be used to compile and save the function into<br>the database. If there are compilation errors upon saving, the errors will be displayed in a Compiler – Log<br>window along with the line number on which the error occurred. By clicking the error in the window,<br>your cursor will be placed on the line of code that needs to be repaired. Figure 12-20 shows the Compiler<br>– Log window including a reference to an error in the code. </p>
<p>Figure 12-20. Compilation errors in Function Editor<br>Once you have successfully compiled and saved the function into the database, it can be executed<br>for testing purposes using the green arrow icon within the Function Editor window. When you execute<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>264<br>the function, the Run PL&#x2F;SQL window will be displayed. If you defined any parameters for the function,<br>you can supply values for them within the PL&#x2F;SQL Block portion of the window. You can then click OK to<br>execute the function using the value(s) you have defined within the window, and the results will be<br>displayed in the Run Log window. The Run PL&#x2F;SQL window can also be used to save your test case to a<br>file or restore a test case from disk. The test case incorporates all the text that is contained within the<br>PL&#x2F;SQL block portion of the Run PL&#x2F;SQL window. This window is displayed in Figure 12-21. </p>
<p>Figure 12-21. Run PL&#x2F;SQL window<br>You can use the database navigator to display the functions contained within a particular database<br>connection. If you highlight a particular trigger and right-click it, then a menu containing several options<br>will be displayed. This is shown in Figure 12-22. </p>
<p>Figure 12-22. Using the navigator with functions<br>The options provided can be used for administering or editing the selected function. The Edit<br>option will open the Function Editor, and it will contain the code for the selected function. If the selected<br>function is not compiled successfully, then you can make changes to it and choose the Compile option<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>265<br>within the right-click contextual menu to recompile the code. Similarly, the menu can be used to invoke<br>the profiler, debug, or administer privileges for the function.<br>12-9. Creating a Stored Procedure<br>Problem<br>You want to create a stored procedure using Oracle SQL Developer.<br>Solution<br>You can manually create a stored procedure by typing the code for creating your procedure into a SQL worksheet<br>and executing it. You can also use the Create Procedure Wizard. To start the wizard, go to the File menu and<br>select the New option. Once the Create a New dialog box opens (Figure 12-23), select Procedure. </p>
<p>Figure 12-23. Create a New dialog box<br>Once you click OK, you will be prompted to select a database connection. Doing so will open the<br>Create PL&#x2F;SQL Procedure Wizard. Alternatively, you can connect to the database of your choice and<br>then expand the navigator so that all the objects within the database are available. Right-click the<br>Procedures submenu, and select New Procedure, as shown in Figure 12-24. </p>
<p>Figure 12-24. Right-click the Procedures submenu within a designated database connection.<br>e<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>266<br>How It Works<br>You can use the Create a New Wizard or SQL worksheet to create a new stored procedure. The wizard is<br>best suited for those who are new to PL&#x2F;SQL or not very familiar with the overall syntax for creating a<br>stored procedure. To use the wizard, select the File menu followed by the New option. At this point, you<br>will be presented with the Create a New window that allows several options for creating new database<br>objects or code. Select the Procedure option, and click OK. Oracle SQL Developer will now prompt you<br>to select a database connection for which you will create the stored procedure. Select the connection of<br>your choice, and click OK. The Create PL&#x2F;SQL Procedure window will open, and it will resemble Figure<br>12-25. </p>
<p>Figure 12-25. Create PL&#x2F;SQL Procedure window<br>The Create PL&#x2F;SQL Procedure window provides a window that can be used to create a procedure.<br>You can select a schema and name the procedure. There is a check box that allows you to create your<br>code using all lowercase if you want. Using the green plus symbol on the right side of the window, you<br>can add a row of text to the Parameters window. By default, the parameter will be named PARAM1, and it<br>will be given a datatype of VARCHAR2 with a mode of IN. All of these options can be changed, including the<br>name. You can add zero or more parameters to the list, and you can rearrange their order by selecting a<br>parameter from the list and using the arrow buttons on the right side of the window. You can select the<br>DDL tab to see the actual code for creating the stored procedure, along with all the parameters you have<br>defined. When finished, you can optionally choose to save your code to disk using the Save button and<br>then click OK to create the procedure.<br>Once you have completed and saved the Create PL&#x2F;SQL Procedure form, the code is transferred to a<br>SQL worksheet that is a procedure editor that contains buttons and tabs for working with the stored<br>procedure, as shown in Figure 12-26. </p>
<p>  CHAPTER 12  ORACLE SQL DEVELOPER<br>267 </p>
<p>Figure 12-26. Stored Procedure Wizard<br>The worksheet contains six tabs that can be used to find out more information about the stored<br>procedure that it contains. This information includes the grants that have been made on the procedure.<br>Other information includes dependencies, references, details, and profiles. You can add code to the<br>procedure by typing into the editor. The editor will perform autocompletion where appropriate, and<br>snippets can be dragged into the editor.<br>Next, copy the following procedure into the editor for testing purposes: </p>
<p>CREATE OR REPLACE PROCEDURE INCREASE_WAGE<br>(<br>  EMPNO_IN IN NUMBER,<br> PCT_INCREASE IN NUMBER<br>) AS<br>  emp_count    NUMBER :&#x3D; 0;<br>  Results   VARCHAR2(50);<br>BEGIN </p>
<p>  SELECT count(*)<br>  INTO EMP_COUNT<br>  FROM EMPLOYEES<br>  WHERE employee_id &#x3D; empno_in; </p>
<p>  IF emp_count &gt; 0 THEN<br>    UPDATE EMP<br>    SET salary &#x3D; salary + (salary * PCT_INCREASE)<br>    WHERE employee_id &#x3D; empno_in;<br>    Results :&#x3D; ‘SUCCESSFUL INCREASE’;<br>  ELSE<br>    Results :&#x3D; ‘NO EMPLOYEE FOUND’;<br>  END IF; </p>
<p>  DBMS_OUTPUT.PUT_LINE(RESULTS);<br>END; </p>
<p>Once the procedure has been coded, select the Save option from the File menu, or click the Save<br>icon that contains an image of a disk. This will compile and store the procedure into the database. You<br>can alternatively use the Gears button to compile and save, which will produce the same results. If any<br>compilation errors are found, they will be displayed in a pane below the editor along with the line<br>number on which the error was found (Figure 12-27). </p>
<p>CHAPTER 12  ORACLE SQL DEVELOPER<br>268 </p>
<p>Figure 12-27. Compilation errors<br>If you double-click the error message, the cursor will be placed into the line of code that contains<br>the error. In this case, you can see that the EMP table does not exist. Replace it with EMPLOYEES, and then<br>click the Save button again. The procedure should now be successfully compiled and saved into the<br>database. If you select the Refresh icon above the navigator, the new procedure will appear within the<br>list of procedures for the database connection.<br>To execute the procedure, right-click it within the navigator, and choose the Run option; this will<br>cause the Run PL&#x2F;SQL window to open. This window is shown in Figure 12-28. </p>
<p>Figure 12-28. Run PL&#x2F;SQL procedure window<br>At this point, you have the option to save the file to disk or open another SQL file. If you want to test<br>the procedure, then you can assign some values to the parameters within this window. Assign the values<br>directly within the code that is listed in the PL&#x2F;SQL Block section of the Run PL&#x2F;SQL window. When you<br>click OK, then the procedure will be executed. The results of the execution will be displayed in the log<br>pane that is located below the editor pane.<br>12-10. Creating a Package Header and Body<br>Problem<br>You want to create a package and store it into the database using Oracle SQL Developer.<br>Solution<br>Use the Create Package Wizard, or type the PL&#x2F;SQL package code into a SQL worksheet. To start the<br>wizard, go to the File menu, and select the New option. Once the Create a New dialog box opens, select<br>Package, as shown in Figure 12-29.<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>269 </p>
<p>Figure 12-29. Creating a new package<br>Once you click OK, you will be prompted to select a database connection. This will open the Create<br>PL&#x2F;SQL Package Wizard. Alternatively, you can connect to the database of your choice and then expand<br>the navigator so that all the objects within the database are available. Right-click (Ctrl+click) the<br>Packages submenu and select New Package.<br>How It Works<br>Creating a new package with Oracle SQL Developer is much the same as creating other code objects<br>using this tool. You can develop using the manual technique of writing all code using the SQL worksheet,<br>or you can use the creation wizards that are provided by the tool. You can type the example code into a<br>SQL worksheet for your data connection and click the Run Statement toolbar button to compile and save<br>the package into the database. You can also issue a Save As and save the code to a file on your<br>workstation when writing code using the SQL worksheet.<br>Alternatively, the wizard is useful for quickly creating the standard code for a package, and you can<br>use the editor to add the details that are specific to your package. Once you have opened the New<br>Package Wizard, you will be prompted to enter a package name. For the purposes of this recipe, enter<br>the name PROCESS_EMPLOYEE_TIME, and click OK. If there is an existing object that has the same name,<br>then you will be alerted via a red pop-up message (Figure 12-30). </p>
<p>Figure 12-30. Naming the PL&#x2F;SQL package using creation wizard<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>270<br> Note If you want to enter all code in lowercase for readability within the tool, you can select the check box<br>before clicking OK once the package has been named.  PL&#x2F;SQL is not a case-sensitive language, so case does not<br>affect code execution.<br>After proceeding, the package editor is opened, and it contains some standard package creation<br>code using the name that you placed into the wizard. As you can see from Figure 12-31, the package<br>editor contains several tabs, along with a search bar and Run, Debug, Compile, and Profile buttons.<br>Enter the following example code into the text box on the Code tab:<br>CREATE OR REPLACE PACKAGE process_employee_time IS<br>  total_employee_salary              NUMBER;<br>  PROCEDURE grant_raises(pct_increase IN NUMBER);<br>  PROCEDURE INCREASE_WAGE (empno_in IN NUMBER,<br>                           Pct_increase IN NUMBER) ;<br>END;<br>Figure 12-31. Package editor window<br>Click the Save button to compile and store the package into the database. Once this has been<br>completed, then the package header should be successfully stored in the database. Next, a package body<br>will need to be added in order to make the package functional. This can be done by expanding the<br>Package subfolder within the navigator. Once expanded, select the package for which you want to create<br>a body. Right-click the selected package, and select the Create Body option (Figure 12-32).<br>Figure 12-32. Creating a package body<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>271<br>Next, the standard package body creation code will be added to an editor much like the SQL<br>worksheet. You can now edit this code accordingly to ensure that it performs the correct actions. Type<br>the following package body into the editor, and then click the Save button to compile and store the<br>package body: </p>
<p>CREATE OR REPLACE PACKAGE BODY process_employee_time AS<br>  PROCEDURE grant_raises (<br>    pct_increase IN NUMBER) as<br>      CURSOR emp_cur is<br>      SELECT employee_id<br>      FROM employees;<br>    BEGIN<br>      FOR emp_rec IN emp_cur LOOP<br>        increase_wage(emp_rec.employee_id, pct_increase);<br>      END LOOP;<br>      DBMS_OUTPUT.PUT_LINE(‘All employees have received the salary increase’);<br>  END grant_raises; </p>
<p> PROCEDURE increase_wage (<br>  empno_in IN NUMBER,<br>  Pct_increase IN NUMBER) as<br>  Emp_count    NUMBER :&#x3D; 0;<br>  Results   VARCHAR2(50);<br>BEGIN<br>  SELECT count(*)<br>  INTO emp_count<br>  FROM employees<br>  WHERE employee_id &#x3D; empno_in; </p>
<p>  IF emp_count &gt; 0 THEN<br>    UPDATE employees<br>    SET salary &#x3D; salary + (salary * pct_increase)<br>    WHERE employee_id &#x3D; empno_in; </p>
<pre><code>SELECT salary 
INTO total_employee_salary 
FROM employees 
WHERE employee_id = empno_in; 

Results := &#39;SUCCESSFUL INCREASE&#39;; 
</code></pre>
<p>  ELSE<br>    Results :&#x3D; ‘NO EMPLOYEE FOUND’;<br>  END IF;<br>  DBMS_OUTPUT.PUT_LINE(results); </p>
<p> END increase_wage;<br>END process_employee_time; </p>
<p>If any compilation errors are encountered, an error window will be displayed providing the line<br>number and specific error message that needs to be addressed. After any compile errors are repaired, the<br>package body will be successfully created. You can then use the navigator to expand the package name<br>and see the package body listed within it. Right-clicking the package body in the navigator offers some<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>272<br>options such as Edit, Run, Compile, Profile, and Debug. You will learn more about debugging in Recipe<br>12-12. The Edit option will open the package body editor if it is not already open. The Run option will<br>open the Run PL&#x2F;SQL window, which allows you to select a procedure or function to execute from the<br>chosen package (Figure 12-33). </p>
<p>Figure 12-33. Running the PL&#x2F;SQL package<br>Once a function or procedure is chosen from the Run PL&#x2F;SQL window, it is executed using the<br>values that are assigned to the variables within the PL&#x2F;SQL Block panel of the window (this code is<br>automatically generated by SQL*Developer). These values can be changed prior to running the package<br>by editing the code that is displayed within the panel. This window also provides the opportunity to save<br>the code to a file or load code from an existing file.<br>Oracle SQL Developer makes developing PL&#x2F;SQL packages easy. All the tools that are needed to<br>successfully create, edit, and manage packages are available within the environment. Whether you are a<br>beginner or seasoned expert, these tools will make package development and maintenance a breeze.<br>12-11. Creating a Trigger<br>Problem<br>You need to create a DML database trigger that validates data prior to inserting it into a table, and you<br>want to use Oracle SQL Developer to do so. For instance, you want to create a trigger that will validate an<br>e-mail address prior to inserting a row into the EMPLOYEES table.<br>Solution<br>Use the Create Trigger Wizard, type the PL&#x2F;SQL trigger code into a SQL worksheet, or use the trigger<br>options that are available from the database table worksheet. To start the wizard, go to the File menu<br>and select the New option. Once the Create a New dialog box opens, select Trigger. This will open the<br>Create Trigger window, as shown in Figure 12-34. </p>
<p>  CHAPTER 12  ORACLE SQL DEVELOPER<br>273 </p>
<p>Figure 12-34. Creating a new trigger<br>The Create Trigger window simplifies the process of creating a trigger because it provides all the<br>essential details that are required up front. Once the information has been completed, the trigger code<br>can be developed using the trigger editor window.<br>How It Works<br>As with all the other code creation techniques available in Oracle SQL Developer, there are various<br>different ways to create a trigger. Using the SQL worksheet for a database connection is the best way to<br>manually create a trigger. To do so, you will need to open the SQL worksheet, type the trigger creation<br>code, and click the Run toolbar button to compile and save the code. The many wizards that are<br>available for trigger creation can greatly simplify the process, especially if you are new to PL&#x2F;SQL or rusty<br>on the details of trigger creation.<br>As mentioned in the solution to the recipe, the Create Trigger window allows you to specify all the<br>details for creating a trigger. You choose the type of trigger by selecting one of the options available from<br>the drop-down menu. Different options become available in the window depending upon the type of<br>trigger you choose to create. By default, a table trigger is chosen. Using that option, you can select the<br>table from another drop-down list and choose whether the trigger should be executed on INSERT, UPDATE,<br>or DELETE from the specified table. The wizard allows you to specify your own variable names for<br>representing old and new table values. The timing for trigger execution is determined by selecting<br>Before, Statement Level, After, or Row Level and specifying an optional WHEN clause. You can even specify<br>whether the trigger is to be executed based upon a specific column.<br>If you attempt to enter a trigger name that matches an existing object in the database within the<br>specified schema, you will receive an error message, as shown in Figure 12-35. </p>
<p>CHAPTER 12  ORACLE SQL DEVELOPER<br>274 </p>
<p>Figure 12-35. Create Trigger window–—object already exists<br>After finishing with the Create Trigger Wizard and clicking the OK button, the initial trigger creation<br>code will be displayed in an editor (Figure 12-36). </p>
<p>Figure 12-36. Trigger Editor<br>Type the following code into the editor, and hit the Save button to compile the code and save it into<br>the database: </p>
<p>TRIGGER CHECK_EMAIL_ADDRESS<br>BEFORE INSERT ON employees<br>FOR EACH ROW<br>BEGIN<br>  IF NOT INSTR(:new.email,‘@’) &gt; 0 THEN<br>    RAISE_APPLICATION_ERROR(-20001, ‘INVALID EMAIL ADDRESS’);<br>  END IF;<br>END; </p>
<p>  CHAPTER 12  ORACLE SQL DEVELOPER<br>275<br>The Save button will automatically compile the code, and the output will appear in the Messages<br>pane below the editor, as shown in Figure 12-37. </p>
<p>Figure 12-37. Messages log<br>After the trigger has been successfully compiled and stored into the database, it can be highlighted<br>in the navigator, and right-clicking it will reveal several options (Figure 12-38). </p>
<p>Figure 12-38. Trigger options<br>These options help allow easy access for dropping, disabling, or enabling the trigger. Choosing the<br>Edit option from this submenu will open the trigger in the editor window to allow for code<br>modifications.<br>Using the Create Trigger Wizard in Oracle SQL Developer can greatly reduce the time it takes to<br>create a database trigger. By selecting the appropriate options within the wizard, you will be left with<br>only the trigger functionality to code.<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>276<br>12-12. Debugging Stored Code<br>Problem<br>One of your stored procedures contains logical errors, and you want to use Oracle SQL Developer to help<br>you find the cause.<br>Solution<br>A few different options are available for debugging stored code within Oracle SQL Developer. The<br>environment includes a complete debugger that provides the ability to set breakpoints within the code<br>and modify variable values at runtime to investigate a problem with your code. There are several ways to<br>invoke the debugger for a particular piece of code. When a code object is opened within the editor, the<br>toolbar will contain a red “bug” icon that can be used to invoke the debugger (Figure 12-39).  </p>
<p>Figure 12-39. Debugger icon<br>The right-click contextual menu within the navigator also contains a Debug option for procedures<br>and packages (Figure 12-40). </p>
<p>Figure 12-40. Debugger option in Navigator<br>How It Works<br>Using the debugger is a great way to find issues with your code. The debugger enables the application to<br>halt processing at the designated breakpoints so that you can inspect the current values of variables and<br>step through each line of code so that issues can be pinpointed. Debugging PL&#x2F;SQL programs is a<br>multistep process that consists of first setting breakpoints in code, followed by compiling the code for<br>debug, and lastly running the actual debugger. To use the debugger, the user who is running the<br>debugger must be granted some database permissions. The user must be granted the DEBUG ANY<br>PROCEDURE privilege to have debug capabilities on any procedure or DEBUG <procedure name> to allow<br>debugging capabilities on a single procedure. The DEBUG CONNECT SESSION privilege must also be granted<br>in order to allow access to the debugging session.<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>277<br>After a user has been granted the proper permissions for debugging, the next step is to place a<br>breakpoint (or several) into the code that will be debugged. For the purposes of this recipe, the<br>INCREASE_WAGE procedure will be loaded into the procedure editor, and a breakpoint will be set by<br>placing the mouse cursor on the left margin of the editor window next to the line of code that you want<br>the debugger to pause execution at. Once the cursor is in the desired location, click in the left margin to<br>place the breakpoint. Figure 12-41 shows a breakpoint that has been placed at the beginning of a SELECT<br>statement within the INCREASE_WAGE procedure. </p>
<p>Figure 12-41. Setting a breakpoint<br>After one or more breakpoints have been placed, the code needs to be compiled for debug. To do so,<br>use the icon in the editor toolbar for compiling, and select the Compile for Debug option. Once the code<br>has been compiled for debug, its icon in the navigator will adopt a green bug to indicate that it is ready<br>for debugging (Figure 12-42). </p>
<p>Figure 12-42. Code ready for debug<br>Next, the debugger can be started by selecting the debug icon within the editor or by right-clicking<br>the code within the navigator and selecting the Debug option. If the user who is debugging the code<br>does not have appropriate permissions to debug, then error messages such as those shown in Figure 12-<br>43 will be displayed. </p>
<p>Figure 12-43. User not granted necessary permissions<br>Assuming that the user has the correct permissions to debug, the Debug PL&#x2F;SQL window will be<br>displayed. This window provides information about the code that is being debugged including the target<br>CHAPTER 12  ORACLE SQL DEVELOPER<br>278<br>name, the parameters, and a PL&#x2F;SQL block that will be executed in order to debug the code. The code<br>that is contained within the PL&#x2F;SQL block portion of the screen can be modified so that the parameters<br>being passed into the code (if any) can be set to the values you choose (Figure 12-44). In Figure 12-44,<br>the values have been set to an EMPNO_IN value of 10 and a PCT_INCREASE value of .03. </p>
<p>Figure 12-44. Debug PL&#x2F;SQL window<br>Once the Debug PL&#x2F;SQL window has been completed with the desired values, click OK to begin the<br>debugger. This will cause Oracle SQL Developer to issue the DBMS_DEBUG_JDWP.CONNECT_TCP (hostname,<br>port) command and start the debugging session. The debugger will start, and it will provide a number of<br>different options, allowing you to step through the code one line at a time and see what the variable<br>values are at any given point in time. You will see three tabs on the debugger: Data, Smart Data, and<br>Watches. The Data tab is used for watching all the variables and their values as you walk through your<br>code using the debugger. The Smart Data tab will keep track of only those variables that are part of the<br>current piece of code that is being executed. You can set watches to determine which variables that you<br>would like to keep track of. The inspector can be used to see the values within those variables you are<br>watching. You are also given the very powerful ability to modify the values at runtime as the code is<br>executing. This provides the capability of determining how code will react to different values that are<br>passed into it.<br>The Oracle SQL Developer debugger is a useful tool and provides an intuitive user interface over the<br>DBMS_DEBUG_JDWP utility. Although this recipe covers only the basics to get you started, if you spend time<br>using each feature of the debugger, then you will learn more powerful ways to help you maintain and<br>debug issues found in your code.<br>12-13. Compiling Code Within the Navigator<br>Problem<br>You want to compile some PL&#x2F;SQL code within Oracle SQL Developer. In this solution, the navigation<br>menu of your Oracle SQL Developer environment contains code that has a red X on it. This means the<br>code needs to be compiled or that it contains an error.<br>  CHAPTER 12  ORACLE SQL DEVELOPER<br>279<br>Solution<br>Select the code that needs to be compiled, and right-click (Ctrl+click) it. A menu will be displayed that<br>lists several options. Select the Compile option from that menu (Figure 12-45). </p>
<p>Figure 12-45. Compile option<br>How It Works<br>The Oracle SQL Developer navigation menu is very handy for quickly glancing at the code that a<br>database contains. All the code that is successfully loaded into the database will contain a green check<br>mark, whereas any code that has a compilation error will contain a red X label. Sometimes code needs to<br>simply be recompiled in order to validate it and make it usable once again. This is most often the case<br>after a database has just recently been migrated or updated. This can also occur if a particular piece of<br>code depends upon another piece of code that has recently been modified, although Oracle Database<br>11gR2 includes fine-grained dependencies that help alleviate this issue. Another event that may cause<br>code to require recompilation is if an object that the code references such as a table or view has been<br>changed. Whatever the case, Oracle SQL Developer makes it easy to recompile code by right-clicking it<br>within the navigator and selecting Compile from the pop-up menu.<br> Note Oracle Database 11g introduced the idea of fine-grained dependencies. This allows PL&#x2F;SQL objects to<br>remain valid even if an object that they depend upon has changed, as long as the changes do not affect the<br>PL&#x2F;SQL object. For instance, if a column has been removed from a table and object A depends upon that table but<br>not the specific column that was removed, then object A will remain valid.<br>Once the compile task has been completed, a message will be displayed within the Messages panel to<br>note whether the compilation was successful. If there were any issues encountered, they will be listed,<br>each on a separate line, within the Messages window. The messages will contain the error code, as well<br>as the line number that caused the exception to be raised. Double-clicking each error message will take<br>you directly to the line of code that raised the exception so that you can begin working on repairs. </p>
<p>C H A P T E R  13 </p>
<p>   </p>
<p>281<br>Analyzing and Improving<br>Performance<br>This chapter introduces several methods to help you analyze your code to improve its performance in<br>terms of runtime or memory usage. Many recipes use the DBMS_PROFILE package, which is supplied by<br>Oracle, to help in the analysis. It is a useful tool for identifying which lines of code consume the most<br>execution time.<br>13-1. Installing DBMS_PROFILER<br>Problem<br>You want to analyze and diagnose your code to find bottlenecks and areas where excess execution time<br>is being spent, but the DBMS_PROFILER package is not installed.<br>Solution<br>Install the DBMS_PROFILER packages, and then create the tables and the Oracle sequence object they need<br>in order to run. Once installed, you can use the DBMS_PROFILER package to help diagnose application<br>performance issues.<br>Installing the Packages<br>To install the DBMS_PROFILER packages, follow these steps:<br>The packages are owned by the SYS account; therefore, it requires DBA login<br>access. Start by opening a SQL Plus connect with the connect sys command. If<br>the operation is successful, the system will respond with the message<br>“Connected.”<br>connect sys&#x2F;sys_pwd as sysdba<br>Connected.<br>Once connected, run the profload.sql script that can be found within the<br>RDBMS&#x2F;ADMIN directory contained in your Oracle Database home. The system<br>will respond with a series of messages like those shown next.<br>@[Oracle_Home]&#x2F;RDBMS&#x2F;ADMIN&#x2F;profload.sql </p>
<p>You should see the following output after executing the script:<br>CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>282 </p>
<p>Package created.<br>Grant succeeded.<br>Synonym created.<br>Library created.<br>Package body created.<br>Testing for correct installation<br>SYS.DBMS_PROFILER successfully loaded.<br>PL&#x2F;SQL procedure successfully completed.<br>Finally, enter the grant execute command to ensure that all schemas within the<br>database have access to the DBMS_PROFILER package.<br>grant execute on DBMS_PROFILER to PUBLIC;<br>Grant succeeded.<br>Creating the Profiler Tables and Sequence Object<br>Create the tables and Oracle sequence object you need for the profiler to run. Log into the account that<br>wants to use the profiler, and enter the following. The system will respond as follows: </p>
<p>@[Oracle_Home]&#x2F;RDBMS&#x2F;ADMIN&#x2F;proftab.sql<br>How It Works<br>The first step creates the packages and makes them available for public access. The second creates the<br>required tables in the schema that wants to use the profiler. There are alternatives to this installation<br>method based on needs and preferences.<br>The DBA may, for example, want to grant execution privileges to specific users instead of everyone.<br>Step 2 must be repeated for every user who wants to use the profiling tools. An alternative is for the DBA<br>to create public synonyms for the tables and sequence created, thereby having only one copy of the<br>profiler table, in which case the solution changes as in the following example. In the following recipe,<br>replace [Oracle_Home] with the exact path used to install the database software on your system. </p>
<p>connect sys&#x2F;sys_pwd as sysdba<br>@[Oracle_Home]&#x2F;RDBMS&#x2F;ADMIN&#x2F;profload.sql<br>grant execute on DBMS_PROFILER to USER1, USER2, USER3;<br>@[Oracle_Home]&#x2F;RDBMS&#x2F;ADMIN&#x2F;proftab.sql </p>
<p>CREATE PUBLIC SYNONYM plsql_profiler_data FOR plsql_profiler_data;<br>CREATE PUBLIC SYNONYM plsql_profiler_units FOR plsql_profiler_units;<br>CREATE PUBLIC SYNONYM plsql_profiler_runs FOR plsql_profiler_runs;<br>CREATE PUBLIC SYNONYM plsql_profiler_runnumber FOR plsql_profiler_runnumber;<br>  CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>283<br>13-2. Identifying Bottlenecks<br>Problem<br>You notice that a PL&#x2F;SQL program is running slowly, and you need to identify what sections of the code<br>are causing it to perform poorly.<br>Solution<br>Use the DBMS_PROFILER routines to analyze the code and find potential bottlenecks. In the following<br>example, the profiler is used to collect statistics on a run of a program, and then a query displays the<br>statistics.  </p>
<p>EXEC DBMS_PROFILER.START_PROFILER (‘Test1’, ‘Testing One’);<br>EXEC sync_hr_data;    – the procedure identifed has having a bottleneck<br>EXEC DBMS_PROFILER.FLUSH_DATA;<br>EXEC DBMS_PROFILER.STOP_PROFILER; </p>
<p>Now that the profile data is collected, you can query the underlying tables to see the results of the<br>analysis: </p>
<p>COL line# FORMAT 999<br>COL hundredth FORMAT a6 </p>
<p>SELECT    d.line#,<br>          to_char (d.total_time&#x2F;10000000, ‘999.00’) hundredth,<br>          s.text<br>FROM    user_source      s,<br>        plsql_profiler_data  d,<br>        plsql_profiler_units u,<br>        plsql_profiler_runs  r<br>WHERE  r.run_comment     &#x3D; ‘Test1’ – run_comment matches the text in START_PROFILER<br>AND    u.runid           &#x3D; r.runid<br>AND    u.unit_owner      &#x3D; r.run_owner<br>AND    d.runid           &#x3D; r.runid<br>AND    d.unit_number     &#x3D; u.unit_number<br>AND    s.name            &#x3D; u.unit_name<br>AND    s.line            &#x3D; d.line#<br>ORDER BY d.line#; </p>
<p>Here are the results of the previous query: </p>
<p> 1     .00 PROCEDURE sync_hr_data AS<br> 3     .00 CURSOR    driver is<br> 4   11.58 SELECT    *<br> 5     .00 FROM      employees@hr_data;<br> 9    2.25    FOR recs IN driver LOOP<br>10    1.64       UPDATE      employees<br>15     .01 END sync_hr_data; </p>
<p>CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>284<br>Here is the complete source code for the sync_hr_data procedure: </p>
<p>CREATE OR REPLACE PROCEDURE sync_hr_data AS </p>
<p>CURSOR    driver IS<br>SELECT    *<br>FROM      employees@hr_data; </p>
<p>BEGIN </p>
<p>   FOR recs IN driver LOOP<br>      UPDATE employees<br>      SET    first_name  &#x3D; recs.first_name<br>      WHERE  employee_id &#x3D; recs.employee_id;<br>   END LOOP; </p>
<p>END sync_hr_data;<br>How It Works<br>There are four steps necessary to collect statistics on a running procedure: </p>
<ol>
<li>Call the DBMS_PROFILER.START_PROFILER routine to begin the process of<br>collecting statistics. The two parameters allow you to give the run a name and<br>a comment. Unique names are not required, but that will make it easier to<br>query the results later. </li>
<li>Execute the program you suspect has bottleneck issues; in this example, we<br>run the sync_hr_data program.  </li>
<li>Execute DBMS_PROFILER.FLUSH_DATA to write the data collected to the profiler<br>tables.  </li>
<li>Call the DBMS_PROFILER.STOP_PROFILER routine to, as the name implies, stop the<br>collection of statistics.<br>The query joins the profiler data with the source code lines to display executable lines and the<br>execution time, in hundredths of a second. The raw data stores time in nanoseconds. The query results<br>show three lines of code with actual execution time.<br>The SELECT statement from the program unit in question, in which Oracle must establish a remote<br>connection via a database link, consumes the majority of the execution time. The remainder of the time<br>is consumed by the FOR statement, which fetches each record from the remote database connection, and<br>the UPDATE statement, which writes the data to the local database.<br>Selecting records in the loop and then updating them causes the program to switch context between<br>PL&#x2F;SQL and the database engine. Each iteration of the LOOP causes this switch to occur. In this example,<br>there were 107 employee records updated. The next recipe shows you how to improve the performance<br>of this procedure.<br>  CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>285<br>13-3. Speeding Up Read&#x2F;Write Loops<br>Problem<br>You have identified a loop that reads and writes large batches of data. You want to speed it up.<br>Solution<br>Use a BULK COLLECT statement to fetch the target data records, and then use a FORALL loop to update the<br>local database. For example, suppose you want to speed up the sync_hr_data procedure demonstrated<br>in Chapter 11:</li>
</ol>
<p>CREATE OR REPLACE PROCEDURE sync_hr_data AS </p>
<p>CURSOR    driver IS<br>SELECT    *<br>FROM      employees@hr_data; </p>
<p>TYPE    recs_type IS TABLE OF driver%ROWTYPE INDEX BY BINARY_INTEGER;<br>recs    recs_type; </p>
<p>BEGIN </p>
<p>   OPEN driver;<br>   FETCH driver BULK COLLECT INTO recs;<br>   CLOSE driver; </p>
<p>   FORALL i IN 1..recs.COUNT<br>      UPDATE    employees<br>      SET       first_name    &#x3D; recs(i).first_name<br>      WHERE     employee_id &#x3D; recs(i).employee_id; </p>
<p>END sync_hr_data; </p>
<p>Run the profiler procedures to collect additional statistics: </p>
<p>EXEC DBMS_PROFILER.START_PROFILER (‘Test2’, ‘Testing Two’);<br>EXEC sync_hr_data;<br>EXEC DBMS_PROFILER.FLUSH_DATA;<br>EXEC DBMS_PROFILER.STOP_PROFILER; </p>
<p>Query the underlying tables to see the results of the analysis: </p>
<p>COL line# FORMAT 999<br>COL hundreth FORMAT A6 </p>
<p>SELECT    d.line#,<br>          TO_CHAR (d.total_time&#x2F;10000000, ‘999.00’) hundreths,<br>          s.text<br>CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>286<br>FROM    user_source             s,<br>        plsql_profiler_data     d,<br>        plsql_profiler_units    u,<br>        plsql_profiler_runs     r<br>WHERE    r.run_comment     &#x3D; ‘Test2’<br>AND      u.runid           &#x3D; r.runid<br>AND      u.unit_owner      &#x3D; r.run_owner<br>AND      d.runid           &#x3D; r.runid<br>AND      d.unit_number     &#x3D; u.unit_number<br>AND      s.name            &#x3D; u.unit_name<br>AND      s.line            &#x3D; d.line#<br>ORDER BY d.line#; </p>
<p> 1     .00 PROCEDURE sync_hr_data AS<br> 3     .00 CURSOR    driver is<br> 4   11.54 SELECT    *<br> 5     .00 FROM      employees@hr_data;<br>12     .00    OPEN driver;<br>13    1.61    FETCH driver BULK COLLECT INTO recs;<br>14     .01    CLOSE driver;<br>16    1.15    FORALL i IN 1..recs.COUNT<br>21     .00 END sync_hr_data;<br>How It Works<br>The procedure is updated from the previous recipe to use a BULK COLLECT statement to gather the data<br>into a collection. The update statement uses the FORALL command to pass the entire collection of data to<br>the Oracle engine for processing rather than updating one row at a time. BULK COLLECT and FORALL loops<br>pass the entire dataset of the collections to the database engine for processing, unlike the loop in recipe<br>13-2, where each iteration passes only one record at a time from the collection to the database. The<br>constant switching back and forth between PL&#x2F;SQL and the database engine creates unnecessary<br>overhead.<br>Perform the following steps to collect statistics on the update procedure: </p>
<ol>
<li>Run the DBMS_PROFILER.START_PROFILER routine to begin the process of<br>collecting statistics. You use the two parameters of the routine to give the run a<br>name and to post a comment. Unique names are not required, but doing so<br>will make it easier to query the results later. </li>
<li>Run the sync_hr_data program to collect statistics. </li>
<li>Run the DBMS_PROFILER.FLUSH_DATA procedure to write the data collected to the<br>tables. </li>
<li>Run the DBMS_PROFILER.STOP_PROFILER routine to, as the name implies, stop<br>the collection of statistics.<br>The query joins the profiler data, using the run name of Test2, with the source code lines to display<br>executable lines and the execution time, in hundredths of a second. The raw data stores time in<br>nanoseconds. The query results show three lines of code with actual execution time.<br>Comparing these results with the previous recipe, we note a 28 percent improvement, 2.25 to 1.61,<br>in fetching the records via the BULK COLLECT statement, and a 30 percent improvement, 1.64 to 1.15, in<br>the writing of the records via the FORALL statements. This improvement is realized while processing only<br>  CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>287<br>107 records. Greater gains can be realized with larger data sets, especially when selecting records via a<br>remote database link as there are fewer context switches between PL&#x2F;SQL and the Oracle engine.<br>13-4. Passing Large or Complex Collections as OUT Parameters<br>Problem<br>You have a procedure or function that accepts one or more large or complex collections that are also OUT<br>parameters, and you need a more efficient method to pass these variables.<br>Solution<br>Pass the parameters to your procedure or function by reference using the NOCOPY option on the<br>procedure or function declaration.</li>
</ol>
<p>CREATE OR REPLACE PACKAGE no_copy_test AS </p>
<p>   TYPE rec_type IS TABLE OF all_objects%ROWTYPE INDEX BY BINARY_INTEGER;<br>   PROCEDURE test; </p>
<p>END no_copy_test;<br>&#x2F;<br>show error </p>
<p>CREATE OR REPLACE PACKAGE BODY no_copy_test AS </p>
<p>PROCEDURE proc1 (rec_list IN OUT rec_type) IS<br>BEGIN<br>   FOR i IN 1..rec_list.COUNT LOOP<br>      rec_list(i) :&#x3D; rec_list(i);<br>   END LOOP;<br>END; </p>
<p>PROCEDURE proc2 (rec_list IN OUT NOCOPY  rec_type) IS<br>BEGIN<br>   FOR i IN 1..rec_list.COUNT LOOP<br>      rec_list(i) :&#x3D; rec_list(i);<br>   END LOOP;<br>END; </p>
<p>PROCEDURE test IS </p>
<p>CURSOR  driver IS<br>SELECT  *<br>FROM    all_objects; </p>
<p>recs        rec_type;<br>rec_count   integer; </p>
<p>BEGIN<br>CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>288 </p>
<p>   OPEN driver;<br>   FETCH DRIVER BULK COLLECT INTO recs;<br>   CLOSE driver; </p>
<p>   rec_count :&#x3D; recs.COUNT; </p>
<p>   DBMS_OUTPUT.PUT_LINE (systimestamp);<br>   proc1 (recs); – parameter passed by value<br>   DBMS_OUTPUT.PUT_LINE (systimestamp);<br>   proc2 (recs); – paramter passed by reference<br>   DBMS_OUTPUT.PUT_LINE (systimestamp);<br>END test; </p>
<p>END no_copy_test; </p>
<p>set serverout on  – Enable output from DBMS_OUTPUT statements<br>EXEC no_copy_test.test; </p>
<p>Running the procedure produced the following output: </p>
<p>03-NOV-10 05.05.14.865000000 PM -05:00<br>03-NOV-10 05.05.14.880000000 PM -05:00<br>03-NOV-10 05.05.14.880000000 PM -05:00<br>How It Works<br>The recipe utilizes the NOCOPY feature within PL&#x2F;SQL. It begins by defining two procedures within the test<br>package. The first procedure, PROC1, accepts a collection of records using the default parameter-passing<br>method, which is by VALUE. The second procedure, PROC2, is an exact copy of PROC1; however, its<br>parameter is passed using the NOCOPY option. In PROC1, the parameter is passed in by VALUE, which means<br>a copy of the entire collection is created in the REC_LIST variable within PROC1. In PROC2, the parameter<br>data is passed by REFERENCE. Passing a parameter by reference does not copy the data; rather, it uses the<br>existing data structure passed to it by the calling program. This method is more efficient for very large<br>collections in both running time and in memory usage.<br>The output from the test shows the first procedure, which passed its parameter by VALUE took longer<br>to run than the second procedure, which passed its parameter by REFERENCE. In this example, the<br>USER_OBJECTS table was used as the data for the parameter, which retrieved only 6,570 records. Larger<br>performance gains can be realized with more records and more complex data structures.<br>13-5. Optimizing Computationally Intensive Code<br>Problem<br>You have computationally intensive code that you want to optimize to decrease its running time.<br>Solution<br>Recompile the package, procedure, or function in native mode using the NATIVE setting: </p>
<p>  CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>289<br>ALTER PACKAGE my_package COMPILE BODY PLSQL_CODE_TYPE&#x3D;NATIVE REUSE SETTINGS;<br>ALTER PROCEDURE my_procedure COMPILE PLSQL_CODE_TYPE&#x3D;NATIVE REUSE SETTINGS;<br>ALTER FUNCTION my_function COMPILE PLSQL_CODE_TYPE&#x3D;NATIVE REUSE SETTINGS; </p>
<p>Here is an example of a computationally intensive procedure. It uses the factorial function from<br>Recipe 17-4. </p>
<p>CREATE OR REPLACE PROCEDURE factorial_test as </p>
<p>fact    NUMBER; </p>
<p>BEGIN </p>
<p>   FOR i IN 1..100 LOOP<br>      fact :&#x3D; factorial(33);<br>   END LOOP; </p>
<p>END factorial_test; </p>
<p>  – enable display of execution time<br>SET TIMING ON </p>
<p>  – run the test<br>EXEC factorial_test </p>
<p>PL&#x2F;SQL procedure successfully completed.<br>Elapsed: 00:00:01.18 </p>
<p>Now, recompile the code using the NATIVE option and rerun the test, noting any change in running<br>time: </p>
<p>ALTER PROCEDURE factorial_test COMPILE PLSQL_CODE_TYPE&#x3D;NATIVE REUSE SETTINGS; </p>
<p>EXEC factorial_test </p>
<p>PL&#x2F;SQL procedure successfully completed.<br>Elapsed: 00:00:00.42<br>How It Works<br>The ALTER. . .COMPILE command invokes the compiler on the named object. The syntax differs slightly<br>when recompiling a PACKAGE body in that the BODY clause follows the COMPILE statement. The<br>PLSQL_CODE_TYPE&#x3D;NATIVE clause compiles the code in NATIVE format, which runs faster than interpreted<br>code. The REUSE SETTINGS clause ensures the code will be recompiled in the same mode if it later<br>becomes invalid and requires automatic recompilation.<br>Native mode realizes the most benefit from computational intensive code; it has little effect on DML<br>statements (in other words, SELECT, INSERT, UPDATE, and DELETE). In the previous example, the factorial<br>function is called repeatedly to simulate a computationally intensive procedure. When the procedure is<br>compiled in the default, interpretive method, it completes its run in 1.18 seconds. When compiled in<br>NATIVE mode, it completes in 0.42 seconds. This is a 64 percent improvement in running time!<br>CHAPTER 13  ANALYZING AND IMPROVING PERFORMANCE<br>290<br>13-6. Improving Initial Execution Running Time<br>Problem<br>You have a procedure that you run frequently, and you want to improve its overall running time by<br>minimizing its startup time.<br>Solution<br>Use the DBMS_SHAPRED_POOL.KEEP procedure to keep a permanent copy of your code in the shared<br>memory pool. For example, the following statement pins the procedure my_large_procedure in the<br>database’s shared memory pool:<br>DBMS_SHARED_POOL.KEEP (<br>   Name &#x3D;&gt; ‘my_large_procedure’,<br>   flag &#x3D;&gt; ‘P’);<br>How It Works<br>The DBMS_SHARED_POOL.KEEP procedure permanently keeps your code in the shared memory pool. By<br>default, when PL&#x2F;SQL code is executed, Oracle must first read the entire block of code into memory if it<br>isn’t already there from a previous execution. As additional procedures are executed, less recently used<br>code in the shared memory pool begins to age. If there isn’t sufficient free space in the shared memory<br>pool, older code is removed to make room.<br>If large procedures are run frequently and are aging out of the shared memory pool, then pinning<br>the procedure in the shared memory pool can improve performance by removing the overhead<br>necessary to reload the procedure again and again.<br>The first parameter of the DBMS_SHARED_POOL.KEEP procedure is the name of the object you want to<br>pin in the shared memory pool. The second parameter identifies the object type of the first parameter.<br>The most commonly used values for FLAG are as follows:<br>•P: The default, which specifies the object is a package, procedure, or function<br>•T: Specifies the object is a trigger<br>•Q: Specifies the object is a sequence<br>You must have execute privileges on the DBMS_SHARED_POOL package to pin your code. An account with<br>SYSDBA privileges must grant execute on DBMS_SHARED_POOL to your schema or to public.<br>C H A P T E R  14 </p>
<p>   </p>
<p>291<br>Using PL&#x2F;SQL on the Web<br>Oracle’s Application Server provides a powerful gateway that exposes your PL&#x2F;SQL procedures to web<br>browsers. The gateway is defined using a Data Access Descriptor (DAD) that runs PL&#x2F;SQL code as either<br>the user defined in the DAD or as the user running the web application.<br>Oracle provides a PL&#x2F;SQL Web Toolkit, which is a set of procedures and functions that generate<br>HTML tags. In addition to making your code easier to read and manage, the toolkit sends the HTML<br>code through Apache directly to the client web browser.<br>The following recipes teach you how to write PL&#x2F;SQL procedures that produce interactive web<br>pages. These recipes can be combined to create solutions for complex business applications.<br>14-1. Running a PL&#x2F;SQL Procedure on the Web<br>Problem<br>You’d like to make your PL&#x2F;SQL procedures accessible to users in a web browser via the Oracle<br>Application Server.<br>Solution<br>To run a PL&#x2F;SQL procedure on the Web, you must first configure a Data Access Descriptor (DAD) within<br>the Oracle Application Server to define the connection information required between mod_plsql within<br>the Oracle Application Server and the Oracle database that holds the PL&#x2F;SQL procedures you wish to<br>run. In this example the mod_plsql configuration file dads.conf (located in [Oracle_Home]\Apache\<br>modplsql\conf) is edited to define the DAD. </p>
<p>&lt;Location &#x2F;DAD_NAME&gt;<br>    SetHandler pls_handler<br>    Order deny,allow<br>    Deny from all<br>    Allow from localhost node1.mycompany.com node2.mycompany.com<br>    AllowOverride None </p>
<pre><code>PlsqlDatabaseUsername ORACLE_SCHEMA_NAME 
PlsqlDatabasePassword PASSWORD 
PlsqlDatabaseConnectString TNS_ENTRY 
PlsqlSessionStateManagement StatelessWithResetPackageState 
PlsqlMaxRequestsPerSession 1000 
PlsqlFetchBufferSize 128 
PlsqlCGIEnvironmentList QUERY_STRING 
PlsqlErrorStyle DebugStyle 
</code></pre>
<p>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>292<br></Location> </p>
<p>You may repeat the <Location> data for additional DADs as required; perhaps one DAD for every<br>major application. You must restart the Oracle Application Server for changes to the DAD configuration<br>file to take effect.<br>How It Works<br>To verify that your DAD is configured properly and will run your PL&#x2F;SQL code, log into the Oracle<br>database defined in your DAD. The Oracle database account is defined in the PlsqlDatabaseUsername,<br>PlsqlDatabasePassword and PlsqlDatabaseConnectString statements. Next, compile the following test<br>procedure. </p>
<p>create or replace procedure test as<br>begin<br>   htp.p (‘Hello World!’);<br>end; </p>
<p>Finally, point your web browser to <a target="_blank" rel="noopener" href="http://node_name/DAD_NAME/test">http://node_name/DAD_NAME/test</a>. Where node_name is the<br>name of the machine where the Oracle Application Server is installed and DAD_NAME is the name assigned<br>your DAD in the <Location> tag within the mod_plsql configuration file and test is the name of the<br>PL&#x2F;SQL procedure create for this test. Your browser should respond with the text “Hello World!”<br>The <Location> tag within the dads.conf file defines the equivalent of a virtual directory within<br>Apache. When a request reaches the Oracle iAS Apache web server containing the location name defined<br>in the DAD, the PL&#x2F;SQL package or procedure specified in the remaining portion of the URL is executed.<br>For example, if the URL is <a target="_blank" rel="noopener" href="http://node.my_company.com/plsqlcgi/employee.rpt">http://node.my_company.com/plsqlcgi/employee.rpt</a>, plsqlcgi is the<br>DAD_NAME, then employee is the package name and rpt is the procedure name. Calls to the PLSQL Web<br>Toolkit within the employee.rpt procedure send output directly to the client’s web browser.<br>The SetHandler directive invokes mod_plsql within Apache to handle requests for the virtual path<br>defined by the <Location> tag. This directive is required to run PL&#x2F;SQL packages and procedures<br>through the Apache web server.<br>The next three directives restrict access to the virtual path to the nodes specified on the Allow from<br>line. To allow access from any web browser in the world, replace these three directives with the following<br>two.<br>• Order allow,deny<br>• Allow from all<br>The PlsqlDatabase directives define the connection information mod_plsql needs to log into the<br>database. If the PlsqlDatabasePassword directive is supplied, Apache will automatically log into the<br>database when requests from web clients are processed. The TNS_ENTRY is used to complete the login<br>information. If the PlsqlDatabasePassword directive is omitted, the Web browser prompts the user for a<br>username and password. The username entered by the user must exist in the database specified by the<br>TNS_ENTRY name and the user must have execute privileges to the requested procedure. The procedure<br>must be accessible to the ORACLE_SCHEMA_NAME specified in PlsqlDatabaseUsername. In other words, the<br>schema must own the procedure or, if owned by another schema, it must have execute privileges to the<br>procedure.<br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>293<br>14-2. Creating a Common Set of HTML Page Generation Procedures<br>Problem<br>Every web page you generate with a PL&#x2F;SQL procedure requires a common HTML tag to start and<br>another to finish every web page, and you do not wish to repeat the code to add those tags in every<br>procedure you write for the Web.<br>Solution<br>Create a package that contains calls to the PL&#x2F;SQL Web Toolkit procedures that produce the HTML code<br>necessary to properly display a well-formed,1 HTML web page. In this example a package is created with<br>two procedures, one to generate the HTML tags required to start a page and one to generate the closing<br>HTML tags to finish a page. </p>
<p>CREATE OR REPLACE PACKAGE common AS </p>
<p>   PROCEDURE header (title VARCHAR2);<br>   PROCEDURE footer; </p>
<p>END common; </p>
<p>CREATE OR REPLACE PACKAGE BODY common AS </p>
<p>PROCEDURE header (title VARCHAR2) IS </p>
<p>BEGIN </p>
<p>   htp.p (‘<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" ' || 
          '"http://www.w3.org/TR/REC-html40/loose.dtd">‘);<br>   htp.htmlOpen;<br>   htp.headOpen;<br>   htp.meta (‘Content-Type’, null, ‘text&#x2F;html;’ ||<br>              owa_util.get_cgi_env(‘REQUEST_IANA_CHARSET’) );<br>   htp.meta (‘Pragma’, null, ‘no-cache’);<br>   htp.Title (title);<br>   htp.headClose;<br>   htp.bodyOpen;<br>   htp.header (2, title); </p>
<p>END HEADER; </p>
<p>PROCEDURE footer IS </p>
<p>BEGIN </p>
<p>1 A well-formed HTML web page conforms to the standards defined by The World Wide Web Consortium<br>(W3C). You can validate your HTML web pages at <a target="_blank" rel="noopener" href="http://validator.w3.org/">http://validator.w3.org/</a>.<br>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>294<br>– This is a great place to add legal disclaimers, about us, contact us, etc. links<br>   htp.hr;  – horizontal line<br>   htp.anchor (‘<a target="_blank" rel="noopener" href="http://www.mynode.com/legal_statement.html&#39;">http://www.mynode.com/legal_statement.html&#39;</a>, ‘Disclaimer’);<br>   htp.anchor (‘<a target="_blank" rel="noopener" href="http://www.mynode.com/About.html&#39;">http://www.mynode.com/About.html&#39;</a>, ‘About Us’);<br>   htp.bodyClose;<br>   htp.htmlClose; </p>
<p>END footer; </p>
<p>END common;<br>How It Works<br>Recipe 14-1 includes a test procedure to verify the DAD is setup correctly; however the test procedure<br>does not produce a well-formed HTML page. Here is the updated example from Recipe 14-1, this time<br>with calls to the common header and footer procedures. </p>
<p>create or replace procedure test as<br>begin<br>   common.header (‘Test Page’);<br>   htp.p (‘Hello World!’);<br>   common.footer;<br>end; </p>
<p>This procedure, when called from a web browser, produces the following HTML code. </p>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/ 
TR/REC-html40/loose.dtd"><HTML> 
<HEAD> 
<META HTTP-EQUIV="Content-Type" NAME="" CONTENT="text/html;WINDOWS-1252"> 
<META HTTP-EQUIV="Pragma" NAME="" CONTENT="no-cache"> 
<TITLE>Test Page</TITLE> 
<BODY> 
<H2>Test Page</H2> 
Hello World! 
</BODY> 
</HTML> 
 
<p>The header routine generates the necessary opening HTML code to properly display a web page. It<br>begins by setting the document type, then sending the opening <HTML> and <HEAD> tags. It sets the<br>content-type to the character set defined in the Apache environment variable, which is retrieved using a<br>call to the PL&#x2F;SQL Web Toolkit’s owa_util.get_cgi_env routine. The Pragma <META> tag tells the browser<br>not to store the page’s content in its internal cache. This is useful when the PL&#x2F;SQL routine returns time-<br>sensitive data because the users need to see real-time data. The remaining code sets the title in the user’s<br>browser, opens the <BODY> tag and displays the title on the user’s web browser.<br>The footer routine closes the <BODY> and <HTML> tags. As stated in the code’s comments, this is a<br>good place to include any legal disclaimers or other useful text or links required for every web page<br>generated.<br>Oftentimes when creating an application, you will create several procedures that will make use of<br>the same code. You could copy the code throughout your procedures, but it is more efficient and safer to<br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>295<br>write once and use in many different places. The creation of a common codebase that is accessible to<br>each PL&#x2F;SQL object within a schema can be quite an effective solution for storing such code.<br>14-3 Creating an Input Form<br>Problem<br>You require a web page that accepts and processes data entered by users. The data should be collected<br>on the opening page and processed (stored in a table, used to update rows in a table, etc.) when the user<br>clicks the Submit button.<br>Solution<br>Create a package using the Oracle PL&#x2F;SQL Web Toolkit to display a data entry form and process the<br>results. In this example a simple data entry form is created to collect employee information and send the<br>user’s input to a second procedure for processing.<br>■ Note See Recipe 14-2 for more information on the common package, which is used in this recipe.<br>CREATE OR REPLACE PACKAGE input_form AS </p>
<p>   null_array OWA_UTIL.IDENT_ARR; </p>
<p>   PROCEDURE html;<br>   PROCEDURE submit (emp_id     VARCHAR2,<br>                     gender     VARCHAR2 DEFAULT NULL,<br>                     options    OWA_UTIL.IDENT_ARR DEFAULT null_array,<br>                     comments   varchar2); </p>
<p>END input_form; </p>
<p>CREATE OR REPLACE PACKAGE BODY input_form AS </p>
<p>PROCEDURE html IS </p>
<p>type    options_type is varray(3) of varchar2(50);<br>options options_type :&#x3D; options_type (‘I will attend the Team Meeting’,<br>                        ‘I will attend the social event’,<br>                        ‘I will attend the company tour’); </p>
<p>BEGIN </p>
<p>   common.header (‘Input Form’);<br>   htp.formOpen (‘input_form.submit’, ‘POST’); </p>
<p>   htp.p (‘Employee ID: ‘);<br>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>296<br>   htp.formText (‘emp_id’, 9, 9);<br>   htp.br; </p>
<p>   htp.p (‘Gender: ‘);<br>   htp.formRadio (‘gender’, ‘M’);<br>   htp.p (‘Male’);<br>   htp.formRadio (‘gender’, ‘F’);<br>   htp.p (‘Female’);<br>   htp.br; </p>
<p>   FOR i IN 1..10 LOOP<br>      htp.formCheckBox (‘options’, i);<br>      htp.p (options(i));<br>      htp.br;<br>   END LOOP;<br>   htp.br; </p>
<p>   htp.p (‘COMMENTS: ‘);<br>   htp.formTextArea (‘comments’, 5, 50);<br>   htp.br; </p>
<p>   htp.formSubmit;<br>   htp.formClose;<br>   common.footer; </p>
<p>END html; </p>
<p>PROCEDURE submit (emp_id     VARCHAR2,<br>                  gender     VARCHAR2 DEFAULT NULL,<br>                  options    OWA_UTIL.IDENT_ARR DEFAULT null_array,<br>                  comments   varchar2) is </p>
<p>BEGIN </p>
<p>   common.header (‘Input Results’);<br>   htp.bold (‘You entered the following…’);<br>   htp.br; </p>
<p>   htp.p (‘Employee ID: ‘ || emp_id);<br>   htp.br;<br>   htp.p (‘Gender: ‘ || gender);<br>   htp.br;<br>   htp.p (‘Comments: ‘ || comments);<br>   htp.br; </p>
<p>   htp.bold (‘Options Selected…’);<br>   htp.br;<br>   FOR i IN 1..options.COUNT LOOP<br>      htp.p (options(i));<br>      htp.br;<br>   END LOOP; </p>
<p>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>297<br>   common.footer; </p>
<p>END submit; </p>
<p>END input_form;<br>How It Works<br>Access the web page using a link with an HTML anchor URL of <a target="_blank" rel="noopener" href="http://node.mycompany.com/DAD_NAME/">http://node.mycompany.com/DAD_NAME/</a><br>input_form.html.<br>■ Note See Recipe 14-1 to define the DAD_NAME.<br>The input_form package specification defines an empty collection named null_array as the type<br>OWA_UTIL.IDENT_ARR. It is used as the default value in the event the web form is submitted without<br>checking at least one of the check boxes. Without the default value for the input parameter options, the<br>call to input_form.submit will not work and returns an error to the user if no boxes are checked.<br>■ Note See Recipe 14-9 for more information on viewing errors.<br>The two procedures, html and submit, exposed in the package specification, are required to make<br>them visible to the PL&#x2F;SQL module within the Apache web server. It is important to note that it is not<br>possible to call procedures via a URL if they are not defined in the package specification.<br>The html procedure generates the data entry form shown in Figure 14-1. It begins with a call to<br>header common procedure, which generates the opening HTML tags. The htp.formOpen call generates<br>the <FORM> tag with the destination of the submit button to the submit procedure within the input_form<br>package.<br>The htp.p procedure call sends the data passed to it directly to the client’s web browser, this<br>procedure should not be confused with the htp.para, which produces the <P> tag. The htp.br call sends<br>the <BR> tag to the client’s web browser.<br>The remainder of the procedure generates several form elements that accept user input. The<br>htp.formText call generates a simple text box that accepts nine bytes. The htp.formRadio routine is called<br>twice with the same variable name in the first parameter. This defines the variable gender with one of<br>two possible values, M or F. The call to htp.formCheckBox within the FOR…LOOP generates the checkboxes,<br>each having a unique value returned if checked by the user. Only the values checked are sent in a<br>collection to the submit routine. The call to htp.formTextArea creates a multi-line, text box 50 characters<br>wide and 5 lines deep. See Table 14-1 for a list of common PL&#x2F;SQL Web Toolkit procedures that generate<br>HTML form tags.<br>The procedure ends with a calls to htp.formSubmit and htp.formClose, which generate the form’s<br>submit button and the closing </FORM> tag. When the user clicks the submit button, the client’s web<br>browser sends the data entered into the form to the submit routine within the input_form package. </p>
<p>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>298 </p>
<p>Figure 14-1. Form generated by the input_form.html procedure<br>Table 14-1. Common form procedures in the PL&#x2F;SQL Web Toolkit<br>Toolkit Procedure HTML Tag<br>htp.formCheckbox <INPUT TYPE="CHECKBOX"><br>htp.formClose </FORM><br>htp.formHidden <INPUT TYPE="HIDDEN"><br>htp.formImage <IPUT TYPE="IMAGE"><br>htp.formOpen <FORM><br>htp.formPassword <INPUT TYPE="PASSWORD"><br>htp.formRadio <INPUT TYPE="RADIO"><br>htp.formReset <INPUT TYPE="RESET"><br>htp.formSelectClose </SELECT><br>htp.formSelectOpen <SELECT><br>htp.formSelectOption <OPTION><br>htp.formSubmit <INPUT TYPE="SUBMIT"><br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>299<br>Toolkit Procedure  HTML Tag<br>htp.formText <INPUT TYPE="TEXT"><br>htp.formTextarea <TEXTAREA></TEXTAREA><br>htp.formTextareaClose </TEXTAREA><br>htp.formTextareaOpen <TEXTAREA><br>14-4. Creating a Web–based Report Using PL&#x2F;SQL Procedures<br>Problem<br>You need to generate a web page report that displays the results of a database query.<br>Solution<br>Create a package with two procedures, one to accept a user’s input, and another to query the database<br>and display the results. Suppose, for example, that you need a report that displays information for an<br>employee whose employee ID has been entered by an authorized user. This recipe uses the employee<br>table in the HR schema.<br>■ Note When defining packages that contain procedures you wish to access via web browsers, you must include<br>each procedure you wish to access in the package specification.  </p>
<p>■ Note See Recipe 14-2 for more information on the common package, which is used in this recipe.<br>CREATE OR REPLACE PACKAGE emp_rpt AS </p>
<p>   PROCEDURE html;<br>   PROCEDURE rpt (emp_id VARCHAR2); </p>
<p>END emp_rpt; </p>
<p>CREATE OR REPLACE PACKAGE BODY emp_rpt AS </p>
<p>PROCEDURE html IS </p>
<p>BEGIN </p>
<p>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>300<br>   common.header (‘Employee Report’);<br>   htp.formOpen (‘emp_rpt.rpt’, ‘POST’);<br>   htp.p (‘Employee ID:’);<br>   htp.formText (‘emp_id’, 6, 6);<br>   htp.formSubmit;<br>   htp.formClose;<br>   common.footer;  – See recipe 14-2 for the common package.<br>END html;<br>PROCEDURE show_row (label VARCHAR2, value VARCHAR2) IS<br>BEGIN<br>   htp.tableRowOpen (‘LEFT’, ‘TOP’);<br>   htp.tableHeader (label, ‘RIGHT’);<br>   htp.tableData (value);<br>   htp.tableRowClose;<br>END show_row;<br>PROCEDURE rpt (emp_id VARCHAR2) IS<br>CURSOR  driver IS<br>SELECT  *<br>FROM    employees<br>WHERE   employee_id &#x3D; emp_id;<br>rec             driver%ROWTYPE;<br>rec_found       BOOLEAN;<br>BEGIN<br>   common.header (‘Employee Report’); </p>
<p>   OPEN driver;<br>   FETCH driver INTO rec;<br>   rec_found :&#x3D; driver%FOUND;<br>   CLOSE driver;<br>   IF rec_found THEN<br>      htp.tableOpen;<br>      show_row (‘Employee ID’, rec.employee_id);<br>      show_row (‘First Name’, rec.first_name);<br>      show_row (‘Last Name’, rec.last_name);<br>      show_row (‘Email’, rec.email);<br>      show_row (‘Phone’, rec.phone_number);<br>      show_row (‘Hire Date’, rec.hire_date);<br>      show_row (‘Salary’, rec.salary);<br>      show_row (‘Commission %’, rec.commission_pct);<br>      htp.tableClose;<br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>301<br>   ELSE<br>      htp.header (3, ‘No such employee ID ‘ || emp_id);<br>   END IF; </p>
<p>   common.footer; – See recipe 14-2 for the common package. </p>
<p>EXCEPTION<br>   WHEN OTHERS THEN<br>   htp.header (3, ‘Invalid employee ID. Click your browser’’s back button and try again.’);<br>   common.footer; </p>
<p>END rpt; </p>
<p>END emp_rpt;<br>How It Works<br>Users access the web page using the URL <a target="_blank" rel="noopener" href="http://node.mycompany.com/DAD_NAME/emp_rpt.html">http://node.mycompany.com/DAD_NAME/emp_rpt.html</a>.<br>■ Note See Recipe 14-1 for more on how to define the DAD_NAME.<br>The package specification is defined with two procedures, html and rpt. Exposing these procedures<br>in the specification is required to make the PL&#x2F;SQL procedures available within Apache.<br>Next, the package body is defined. The html procedure generates the data entry form. It generates<br>the opening HTML code by calling the common.header routine defined in recipe 14-2. Next, it calls the<br>htp.formOpen to set the form’s action, which is to run the PL&#x2F;SQL procedure emp_rpt.rpt, when the user<br>clicks the submit button and to send the form data in a POST method, as opposed to GET. A simple<br>prompt and a text box follows to allow the user to enter an employee ID. A call to form.submit,<br>form.close and common.footer complete the HTML code.<br>The show_row procedure is a handy subroutine to output one table row with two data cells. It<br>displays data on the client’s browser in a formatted table, making it more visually appealing.<br>The rpt procedure accepts the user’s input in the emp_id parameter and uses it to query the<br>employee record. The common.header routine generates the opening HTML code. The cursor is opened<br>and the data is fetched into the rec data structure. The rec_found variable stores the flag that identifies if<br>a record was fetched. It needs to be referenced after the fetch and before the close. If a record is found,<br>the employee data is displayed in a two-column table, shown in Figure 14-2, otherwise a message is sent<br>to the user that the employee ID is not valid.<br>The exception is necessary to trap the error generated if the user enters a non-numeric employee<br>ID. Another option is to validate the user’s input prior to using it in the cursor query.<br>■ Note See recipe 14-10 for an example of validating user input.<br>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>302 </p>
<p>Figure 14-2. Results from entering employee ID 200 on the previous data entry screen<br>14-5. Displaying Data from Tables<br>Problem<br>You wish to provide the results from an SQL SELECT statement to the users via a web browser.<br>Solution<br>Use the Oracle PL&#x2F;SQL Web Toolkit to SELECT and display data. The owa_util.tablePrint procedure<br>accepts any table name for the ctable parameter. When this procedure is compiled in a schema with a<br>DAD it can be accessed via the Web. This example displays information similar to the describe feature<br>within SQL*Plus.<br>■ Note See Recipe 14-1 to define a DAD and direct your browser to run your procedure.  </p>
<p>■ Note See Recipe 14-2 for more information on the common package, which is used in this recipe.<br>CREATE OR REPLACE PROCEDURE descr_emp IS </p>
<p>BEGIN </p>
<p>   common.header (‘The Employees Table’); </p>
<p>   IF owa_util.tablePrint (<br>             ctable&#x3D;&gt;’user_tab_columns’,<br>        cattributes&#x3D;&gt;’BORDER’,<br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>303<br>           ccolumns&#x3D;&gt;’column_name, data_type, data_length, data_precision, nullable’,<br>           cclauses&#x3D;&gt;’WHERE table_name&#x3D;’’EMPLOYEES’’ ORDER BY column_id’) then<br>      NULL;<br>   END IF; </p>
<p>   common.footer; </p>
<p>END descr_emp;<br>How It Works<br>Users access the web page using the URL <a target="_blank" rel="noopener" href="http://node.mycompany.com/DAD_NAME/emp_rpt.html">http://node.mycompany.com/DAD_NAME/emp_rpt.html</a>. The<br>descr_emp procedure calls the owa_util.tablePrint procedure, which is included in the PL&#x2F;SQL Web<br>Toolkit. The ctable parameter defines the table the owa_util.tablePrint procedure accesses to read the<br>data. The cattribributes parameter accepts options for the HTML <TABLE> tag. The ccolumns parameter<br>allows you to specify which columns to select from the named table. If no columns are specified, then<br>the procedure shows all columns. The cclauses parameter allows you to add a where clause and&#x2F;or an<br>order by statement. If no where clause is specified, all rows are returned. The output is shown in Figure<br>14-3. </p>
<p>Figure 14-3. Results of the descr_emp procedure<br>14-6. Creating a Web Form Dropdown List from a Database Query<br>Problem<br>Your web form requires a dropdown list whose elements are drawn from a database table.<br>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>304<br>Solution<br>Use the htp.formSelectOpen, htp.formSelectOption and htp.formSelectClose procedures in the PL&#x2F;SQL<br>Web Toolkit to generate the required HTML tags. For example, suppose you need to use the HR schema<br>to create a dropdown list of job titles from the JOBS table. Here’s how you’d do it. </p>
<p>create or replace procedure job_list as </p>
<p>cursor  driver is<br>select  job_id, job_title<br>from    jobs<br>order by job_title; </p>
<p>begin </p>
<p>   common.header (‘Job Title’);<br>   htp.formSelectOpen (‘id’, ‘Job Title: ‘);<br>   htp.formSelectOption (‘’, ‘SELECTED’); </p>
<p>   for rec in driver LOOP<br>      htp.formSelectOption (rec.job_title, cattributes&#x3D;&gt;’VALUE&#x3D;”‘ || rec.job_id || ‘“‘);<br>   end LOOP; </p>
<p>   htp.formSelectClose;<br>   common.footer; </p>
<p>end job_list; </p>
<p>This procedure produces the following web page. </p>
<p>Figure 14-4. Dropdown list created by job_list procedure<br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>305<br>How It Works<br>The htp.formSelectOpen procedure generates the HTML <SELECT NAME="id">, which defines the<br>dropdown list in the web browser. In addition the procedure uses the second parameter as the prompt<br>for the dropdown list. In this example the prompt is Job Title:.<br>The call to htp.formSelectOption procedure defines the elements of the dropdown list. The first<br>parameter is the text displayed in the list and the second parameter preselects the element in the list<br>when it is first displayed. In this example the first call to the htp.formSelectOption procedure defines the<br>default selected element in the list to an empty value.<br>The subsequent calls to htp.formSelectOption that appear in the cursor for loop define the<br>remaining elements in the dropdown list using the data selected from the JOBS table. The cattributes<br>parameter is used to change the default value returned by the web browser when the element is selected<br>from the list.<br>The call to htp.formSelectClose generates the </SELECT> HTML tag to close the dropdown list.<br>Dropdown lists usually appear within the <FORM> tags to accept user input and process that input on a<br>subsequent page.<br>■ Note See Recipe 14-3 for more information on creating an input form.<br>14-7. Creating a Sortable Web Report<br>Problem<br>You need a report that displays data that is sorted by a field the user selects.<br>Solution<br>Create a package that prompts the user for a sort field, then generates the sorted output using the sort<br>field parameter in the ORDER BY section of the SELECT statement. In this example the user is prompted to<br>select a sort option on the EMPLOYEEs table. The options are to sort by last name, hire date, salary, or<br>employee ID.<br>■ Note See Recipe 14-1 to define a DAD and direct your browser to run your procedure.  </p>
<p>■ Note See Recipe 14-2 for more information on the common package, which is used in this recipe.<br>CREATE OR REPLACE PACKAGE sorted AS </p>
<p>   PROCEDURE html;<br>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>306<br>   PROCEDURE rpt (sort_order VARCHAR2); </p>
<p>END sorted; </p>
<p>CREATE OR REPLACE PACKAGE BODY sorted AS </p>
<p>PROCEDURE html IS </p>
<p>BEGIN </p>
<p>   common.header (‘Sorted Report’);<br>   htp.formOpen (‘sorted.rpt’, ‘POST’);<br>   htp.formSelectOpen (‘sort_order’, ‘Select a Sort Order: ‘);<br>   htp.formSelectOption (‘Last Name’);<br>   htp.formSelectOption (‘Hire Date’);<br>   htp.formSelectOption (‘Salary’);<br>   htp.formSelectOption (‘Employee ID’);<br>   htp.formSelectClose;<br>   htp.formSubmit;<br>   htp.formClose;<br>   common.footer;<br>END html; </p>
<p>PROCEDURE rpt (sort_order VARCHAR2) IS </p>
<p>CURSOR  driver IS<br>SELECT  *<br>FROM    employees<br>ORDER BY DECODE (sort_order,<br>                ‘Last Name’,   last_name,<br>                ‘Hire Date’,   TO_CHAR (hire_date, ‘YYYYMMDD’),<br>                ‘Salary’,      TO_CHAR (salary, ‘00000’),<br>                ‘Employee ID’, TO_CHAR (employee_id, ‘00000’) ); </p>
<p>BEGIN </p>
<p>   common.header (‘Sorted Report by ‘||sort_order); – See recipe 14-2.<br>   htp.tableOpen (‘BORDER’);<br>   htp.tableRowOpen (‘LEFT’, ‘BOTTOM’);<br>   htp.tableHeader (‘Name’);<br>   htp.tableHeader (‘Hired’);<br>   htp.tableHeader (‘Salary’);<br>   htp.tableHeader (‘ID’);<br>   htp.tableRowClose; </p>
<p>   FOR rec IN driver LOOP<br>      htp.tableRowOpen (‘LEFT’, ‘TOP’);<br>      htp.tableData (rec.last_name);<br>      htp.tableData (rec.hire_date);<br>      htp.tableData (rec.salary);<br>      htp.tableData (rec.employee_id);<br>      htp.tableRowClose;<br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>307<br>   END LOOP; </p>
<p>   htp.tableClose;<br>   common.footer; </p>
<p>END rpt; </p>
<p>END sorted;<br>How It Works<br>Users access the web page using the URL <a target="_blank" rel="noopener" href="http://node.mycompany.com/DAD_NAME/sorted.html">http://node.mycompany.com/DAD_NAME/sorted.html</a>.<br>■ Note See Recipe 14-1 for more on how to to define the DAD_NAME.<br>The package specification is defined by exposing two procedures, html and rpt. You must define<br>these procedures in the specification to make the PL&#x2F;SQL procedures available within Apache.<br>Next, the package body is defined. The html procedure generates the data entry form. It generates<br>the opening HTML code by calling the common.header routine defined in Recipe 14-2. Next, it calls the<br>htp.formOpen to set the form’s action when the user clicks the Submit button. The calls to<br>htp.formSelectOpen, htp.formSelectOption and htp.formSelectClose procedures create the dropdown<br>list for the user to select a sort order.<br>■ Note See Recipe 14-6 for more information on how to create dropdown lists.<br>A call to form.submit, form.close and common.footer complete the necessary HTML code. The form<br>generated is shown in Figure 14-5.<br>The rpt procedure accepts the sort_order parameter, which is used in the cursor to dynamically<br>determine the sort order on the EMPLOYEES table. The order by option in the select statement uses the<br>decode function to return the proper string needed for ordering based on the user’s input.<br>The first set of parameters sent to the decode function, namely the first_name field, defines the data<br>type returned by the decode function. This is important to note as the remaining data types returned<br>from the decode function will be converted to strings to match the first_name. It is necessary to convert<br>the numeric and date fields to strings that sort properly. For example, if the default date string format is<br>dd-Mon-yy, then the hire dates will sort by the day of the month first, then by the month’s abbreviation<br>and year. The desired sort order is year, month, then day. </p>
<p>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>308 </p>
<p>Figure 14-5. Initial data entry screen showing the sort options<br>14-8. Passing Data Between Web Pages<br>Problem<br>You have a multi-page data entry form in which the final page requires data entered on pages that<br>precede it. You need to pass the data gathered on previous pages to the current page.<br>Solution<br>Pass the name&#x2F;value pairs from previous pages using the htp.formHidden procedure in the PL&#x2F;SQL Web<br>Toolkit. In this recipe each parameter is passed to the next form using hidden HTML elements. </p>
<p>CREATE OR REPLACE PACKAGE multi AS </p>
<p>   PROCEDURE page1;<br>   PROCEDURE page2 (var1 varchar2);<br>   PROCEDURE page3 (var1 varchar2, var2 varchar2);<br>   PROCEDURE process (var1 varchar2, var2 varchar2, var3 varchar2); </p>
<p>END multi; </p>
<p>CREATE OR REPLACE PACKAGE BODY multi AS </p>
<p>PROCEDURE page1 IS </p>
<p>begin </p>
<p>   htp.formOpen (‘multi.page2’, ‘POST’);<br>   htp.p (‘Enter First Value:’);<br>   htp.formText (‘var1’, 10, 10);<br>   htp.formSubmit;<br>   htp.formClose; </p>
<p>END page1; </p>
<p>PROCEDURE page2 (var1 VARCHAR2) IS </p>
<p>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>309<br>begin </p>
<p>   htp.formOpen (‘multi.page3’, ‘POST’);<br>   htp.formHidden (‘var1’, var1);<br>   htp.p (‘Enter Second Value:’);<br>   htp.formText (‘var2’, 10, 10);<br>   htp.formSubmit;<br>   htp.formClose; </p>
<p>END page2; </p>
<p>PROCEDURE page3 (var1 VARCHAR2, var2 VARCHAR2) IS </p>
<p>begin </p>
<p>   htp.formOpen (‘multi.process’, ‘POST’);<br>   htp.formHidden (‘var1’, var1);<br>   htp.formHidden (‘var2’, var2);<br>   htp.p (‘Enter Third Value:’);<br>   htp.formText (‘var3’, 10, 10);<br>   htp.formSubmit;<br>   htp.formClose; </p>
<p>END page3; </p>
<p>PROCEDURE process (var1 varchar2, var2 varchar2, var3 varchar2) is </p>
<p>BEGIN </p>
<p>  htp.p (‘The three variables entered are…’);<br>  htp.br; </p>
<p>  htp.p (‘1&#x3D;’ || var1);<br>  htp.br;<br>  htp.p (‘2&#x3D;’ || var2);<br>  htp.br;<br>  htp.p (‘3&#x3D;’ || var3); </p>
<p>END process; </p>
<p>END multi;<br>How It Works<br>Users access the web page using the URL <a target="_blank" rel="noopener" href="http://node.mycompany.com/DAD_NAME/multi.page1">http://node.mycompany.com/DAD_NAME/multi.page1</a>.<br>■ Note See Recipe 14.1 to define the DAD_NAME.<br>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>310<br>The page1 procedure within the mulit package prompts the user for an input value, which is passed<br>to procedure page2 as its parameter, var1. The htp.formHidden call in the page2 procedure produces an<br>HTML <INPUT> tag of type HIDDEN. In this recipe it produces the following HTML code in the client’s web<br>browser: <INPUT TYPE="hidden" NAME="var1" VALUE="xxx">, where xxx is the text the user entered on the<br>first page of this multi-part form.<br>The page2 procedure then accepts more user input into the form variable var2, which is passed to<br>page3 along with var1 collected on the first input page. The third page accepts the final user input and<br>passes it to the process procedure, where final processing occurs.<br>14-9. Viewing Errors for Debugging Web Apps<br>Problem<br>You have a PL&#x2F;SQL package or procedure called from a web client that generates errors and you need to<br>view the error message.<br>Solution<br>Choose one of the following two solutions, depending on your circumstances.<br>Solution #1<br>If the package is in use in a production environment, then check the output of the Apache error log file.<br>The log file location is defined in the httpd.conf configuration file. The default log file location is<br>[oracle_home]\Apache\Apache\logs directory. Open the log file and search for the errors generated with<br>a timestamp that corresponds to the approximate time the error was generated.<br>Solution #2<br>If the application is in development or running in a non-production environment, change the default<br>error style within the DAD used to produce the web page that failed. The error style is defined in the<br>DADS.CONF file located in [oracle_homme]\Apache\modplsql\conf. Set the PlsqlErrorStyle to DebugStyle.<br>■ Note See recipe 14-1 for more information on defining DADs.<br>How It Works<br>Solution #1<br>The PL&#x2F;SQL module within Apache logs all errors, complete with timestamps. New errors are written to<br>the end of the error log. This solution is recommended for production environments where the display<br>of Apache environment variables may pose security issues.<br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>311<br>Here’s an example of an error message written to the error log. In this example, a procedure was<br>called from the Web but was missing required parameters. </p>
<p>[error] [client 127.0.0.1] mod_plsql: &#x2F;DAD_NAME&#x2F;class_sched.list HTTP-404 </p>
<p>class_sched.list: SIGNATURE (parameter names) MISMATCH<br>VARIABLES IN FORM NOT IN PROCEDURE:<br>NON-DEFAULT VARIABLES IN PROCEDURE NOT IN FORM: THIS_ID, THIS_ID_TYPE<br>Solution #2<br>Setting the PlsqlErrorStyle to DebugStyle causes Apache to display all PL&#x2F;SQL error messages on the<br>client’s web browser when the PL&#x2F;SQL routine fails. It displays the same error messages normally found<br>in the Apache log file plus a list of all Apache environment variables and their values. This solution is<br>recommended for non-production environments where errors are more likely to occur during<br>development and testing. It has the advantage of immediate, onscreen feedback for developers and<br>testers. </p>
<p>The following is an example of an error message written to the web browser. </p>
<p>class_sched.list: SIGNATURE (parameter names) MISMATCH<br>VARIABLES IN FORM NOT IN PROCEDURE:<br>NON-DEFAULT VARIABLES IN PROCEDURE NOT IN FORM: THIS_ID, THIS_ID_TYPE </p>
<p>  DAD name: default<br>  PROCEDURE  : class_sched.list<br>  URL        : <a target="_blank" rel="noopener" href="http://node.mycomp.com/DAD_NAME/class_sched.list">http://node.mycomp.com/DAD_NAME/class_sched.list</a><br>  PARAMETERS :<br>  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </p>
<h1 id="ENVIRONMENT"><a href="#ENVIRONMENT" class="headerlink" title="  ENVIRONMENT: "></a>  ENVIRONMENT: </h1><pre><code>PLSQL_GATEWAY=WebDb 
GATEWAY_IVERSION=3 
    &lt;&lt; snip &gt;&gt; 
</code></pre>
<p>14-10. Generating JavaScript via PL&#x2F;SQL<br>Problem<br>Your procedure requires JavaScript but you do not have access to the Oracle application server to store<br>the script file to make it accessible from Apache.<br>Solution<br>Use the Oracle PL&#x2F;SQLWeb Toolkit to output JavaScript within your PL&#x2F;SQL procedure. There are two<br>steps to define and enable a JavaScript within your PL&#x2F;SQL procedure.<br>CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>312<br>First, define the JavaScript source on the web page that requires access to your<br>JavaScript routine using the HTML tag <SCRIPT>.<br>Define a PL/SQL procedure to match the name of the <SCRIPT> tag’s source (SRC)<br>property.<br>In the following example the html procedure defines the <SCRIPT> tag with the source set to<br>empID.js and the js procedure generates the JavaScript code. </p>
<p>CREATE OR REPLACE PACKAGE empID IS </p>
<p>   PROCEDURE html;<br>   PROCEdURE js; </p>
<p>END empID; </p>
<p>CREATE OR REPLACE PACKAGE BODY empID IS </p>
<p>PROCEDURE html is </p>
<p>BEGIN </p>
<p>   common.header ('Employee Report'); -- See recipe 14-2 for the common package.<br>   htp.p ('<SCRIPT LANGUAGE="JavaScript" SRC="'                 || 
                owa_util.get_cgi_env ('REQUEST_PROTOCOL')       || '://'        || 
                owa_util.get_cgi_env ('HTTP_HOST')              || 
                owa_util.get_cgi_env ('SCRIPT_NAME')            || '/empID.js"></SCRIPT>‘); </p>
<p>   htp.formOpen (‘emp_rpt.rpt’, ‘POST’); – See recipe 14-4 for the emp_rpt pacakge.<br>   htp.p (‘Employee ID:’);<br>   htp.formText (‘emp_id’, 6, 6, cattributes&#x3D;&gt;’onChange&#x3D;”validateNumber(this.value);”‘); </p>
<p>   htp.formSubmit;<br>   htp.formClose;<br>   common.footer; – See recipe 14-2 for the common package. </p>
<p>END html; </p>
<p>PROCEDURE js is </p>
<p>BEGIN </p>
<p>   htp.p (‘ </p>
<p>function validateNumber (theNumber) { </p>
<p>   if ( isNaN (theNumber) ) {<br>      alert (“You must enter a number for the Employee ID”);<br>      return false; } </p>
<p>   return true; </p>
<p>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>313<br>}’); </p>
<p>END js; </p>
<p>END empID;<br>How It Works<br>Begin by creating the package specification for empID, which exposes the html and js procedures. Next<br>create the package body with two procedures, html and js.<br>The html procedure generates the opening HTML code with a call to common.header. Next, the<br>procedure generates a <SCRIPT> tag that identifies the location of the JavaScript to include in the user’s<br>browser. The <SCRIPT> tag of this form is one of the few HTML tags not predefined in the PL/SQL Web<br>Toolkit.<br>The <SCRIPT> tag takes advantage of the owa_util package, which is also part of the PL/SQL Web<br>Toolkit, to dynamically generate the web address of the JavaScript using the settings of the Apache<br>environment values. This method avoids your having to hard-code the URL of the script into the<br>procedure and allows it to run in any environment—development, integration, production, etc. The URL<br>generated references the JavaScript package defined later in the package body.<br>Next, the html procedure generates the <FORM> tag with emp_rpt.rpt as its target. When the user<br>clicks the Submit button the form will call the PL/SQL procedure emp_rpt.rpt defined in Recipe 14-4. It<br>will not call a procedure within the empID package.<br>The htp.formText routine contains an extra parameter to include the JavaScript necessary to run<br>when the user changes the value in the emp_id field. Nearly every procedure in the htp package includes<br>the cattributes parameter, which provides for any additional option needed within the tag that is not<br>already defined in the existing parameters. Figure 14-6 shows the data entry form with a non-numeric<br>employee ID; in this example the letter “o” was used instead of a zero. JavaScript pops up the error<br>message shown.<br>The js procedure consists of a simple print statement that contains the entire contents of the<br>JavaScript code. JavaScript allows either single or double quotes for character strings. Using double<br>quotes in the JavaScript code avoids conflicts with the single quote requirements of PL/SQL. </p>
<p>Figure 14-6. Error message generated by JavaScript when a non-numeric employee ID is entered<br>CHAPTER 14  USING PL/SQL ON THE WEB<br>314<br>14-11. Generating XML Output<br>Problem<br>You need to provide XML data for PL/SQL or other consumers of data from your Oracle database.<br>Solution<br>Use Oracle’s built-in DBMS_XMLGEN package to extract data from the database in standard XML format and<br>then output the data through the Apache web server. In this example a generic procedure builds and<br>outputs XML formatted data based on the SQL query statement passed to it. This procedure can be used<br>in any application that requires XML output extracted from database tables. </p>
<p>CREATE OR REPLACE PROCEDURE gen_xml (sql_stmt VARCHAR2) IS </p>
<p>string          VARCHAR2(4000);<br>ipos            INTEGER;<br>offset          INTEGER;<br>n               INTEGER := 1; </p>
<p>qryctx          dbms_xmlgen.ctxhandle;<br>result          CLOB; </p>
<p>BEGIN </p>
<p>   qryctx := dbms_xmlgen.newcontext (sql_stmt);<br>   result := dbms_xmlgen.getxml (qryctx);<br>   dbms_xmlgen.closecontext (qryctx); </p>
<p>   owa_util.mime_header ('text/xml', true);<br>   LOOP<br>      EXIT WHEN result IS NULL;<br>      ipos := dbms_lob.instr (result, CHR(10), 1, n);<br>      EXIT WHEN ipos = 0; </p>
<pre><code>  string := dbms_lob.substr (result, ipos-offset, offset); 
  htp.p (string); 

  offset    := ipos + 1; 
  n         := n + 1; 
</code></pre>
<p>   END LOOP; </p>
<p>   IF result IS NULL THEN<br>      htp.p ('<ROWSET>');<br>      htp.p ('</ROWSET>');<br>   END IF; </p>
<p>END gen_xml;<br>  CHAPTER 14  USING PL/SQL ON THE WEB<br>315<br>How It Works<br>The newcontext procedure in the dbms_xmlgen package executes the query passed to it in the first<br>parameter. The getxml procedure returns the data in XML format. Each row of data from the select<br>statement is enclosed in the XML tags <ROW>. Each field in the row is enclosed by its attribute (field)<br>name in the database. For example, the employee ID is enclosed in the XML tag <EMPLOYEE_ID>.<br>The owa_util.mime_header is called to output the proper string to the client’s browser, indicating the<br>content of the web page is in standard XML format. At this point it is sufficient to simply output the XML<br>data returned by the call to xmlgen with an htp.p statement. However, this approach works only if the<br>length in bytes of the XML data does not exceed the maximum allowed by the htp.p procedure, which is<br>32k. The LOOP breaks apart the XML data into smaller segments at each line break, CHR(10), insuring no<br>call to htp.p exceeds the maximum length.<br>The final IF statement returns an empty XML tag set if the result of the query returns no rows.<br>Without the empty tag set your Ajax call will fail because the Ajax call to parse the data from the XML<br>structure requires the <ROWSET> tags.<br>Here is an example of the XML output produced from Recipe 14-12. Only the first two data rows<br>retrieved are displayed. </p>
<ROWSET> 
 <ROW> 
  <EMPLOYEE_ID>101</EMPLOYEE_ID> 
  <LAST_NAME>Kochhar</LAST_NAME> 
 </ROW> 
 <ROW> 
  <EMPLOYEE_ID>102</EMPLOYEE_ID> 
  <LAST_NAME>De Haan</LAST_NAME> 
 </ROW> 
</ROWSET> 
14-12. Creating an Input Form with AJAX 
Problem 
You need a web application that can interactively retrieve data based on partial data entered by the user. 
The data must be retrieved before the user clicks the Submit button to process the page. 
Solution 
Use JavaScript and Ajax to dynamically retrieve data as the user enters data into the web form. This 
recipe uses the EMPLOYEES table in the HR schema. 
The data entry screen is built with all managers in a single dropdown list, which includes a call to a 
JavaScript procedure that invokes Ajax to retrieve subordinate data. Once the user selects a manager, the 
employee dropdown list populates with the manager’s subordinates. The subordinates’ dropdown list is 
defined with an ID, which is required by JavaScript to access the list and load the manager’s 
subordinates. 
The package contains the procedure xml, which is required to produce the XML data required by the 
Ajax call. The PL/SQL procedure ajax.xml is called by the web browser within the AjaxMgr.js procedure. 
 
<p>CREATE OR REPLACE PACKAGE ajax IS<br>CHAPTER 14  USING PL/SQL ON THE WEB<br>316 </p>
<p>   PROCEDURE html;<br>   PROCEDURE xml (ID INTEGER); </p>
<p>END ajax; </p>
<p>CREATE OR REPLACE PACKAGE BODY ajax IS </p>
<p>PROCEDURE html is </p>
<p>CURSOR  driver IS<br>SELECT  employee_id, last_name<br>FROM    employees<br>WHERE   employee_id in<br>(       SELECT  DISTINCT manager_id<br>        FROM    employees)<br>ORDER BY last_name; </p>
<p>BEGIN </p>
<p>   common.header ('Manager/Employee Example'); -- See recipe 14-2 for the common package.<br>   htp.p ('<SCRIPT LANGUAGE="JavaScript" SRC="'         || 
                owa_util.get_cgi_env ('REQUEST_PROTOCOL')       || '://'        || 
                owa_util.get_cgi_env ('HTTP_HOST')              || 
                                '/js/AjaxMgr.js"></SCRIPT>‘); </p>
<p>   htp.formOpen (‘#’, ‘POST’);<br>   htp.p (‘Select a Manager:’);<br>   htp.formSelectOpen (‘mgr’, cattributes&#x3D;&gt;’onChange&#x3D;”loadEmployees(this.value);”‘);<br>   htp.formSelectOption (‘’, ‘SELECTED’); </p>
<p>   FOR rec IN driver LOOP<br>      htp.formSelectOption (rec.last_name, cattributes&#x3D;&gt;’VALUE&#x3D;”‘||rec.employee_id||’”‘);<br>   END LOOP; </p>
<p>   htp.formSelectClose;<br>   htp.br; </p>
<p>   htp.p (‘Select a Subordinate:’);<br>   htp.formSelectOpen (‘emp’, cattributes&#x3D;&gt;’ID&#x3D;”emp_list”‘);<br>   htp.formSelectClose;<br>   htp.br; </p>
<p>   htp.formSubmit;<br>   htp.formClose;<br>   common.footer; </p>
<p>END html; </p>
<p>PROCEDURE xml (ID INTEGER) IS </p>
<p>BEGIN<br>  CHAPTER 14  USING PL&#x2F;SQL ON THE WEB<br>317 </p>
<p>– see recipe 14-11 for more information on the gen_xml procedure.<br>   gen_xml (‘SELECT employee_id, last_name ‘    ||<br>           ‘FROM employees ‘                    ||<br>           ‘WHERE manager_id &#x3D; ‘ || ID          ||<br>           ‘ ORDER by 1’); </p>
<p>END xml; </p>
<p>END ajax;<br>How It Works<br>The recipe begins by defining the package specification with two packages, html and xml. The html<br>package generates the HTML data entry form and the xml procedure generates the XML data required by<br>the call to Ajax.<br>The html procedure generates the opening HTML code with a call to common.header. Next, the<br>procedure generates a <SCRIPT> tag that identifies the location of the JavaScript to include in the user’s<br>browser. The <SCRIPT> tag of this form is one of the few HTML tags not pre-defined in the PL/SQL Web<br>Toolkit.<br>The <SCRIPT> tag takes advantage of the owa_util package, which is also part of the PL/SQL Web<br>Toolkit. It dynamically generates the web address of the JavaScript based on Apache environment<br>values. This method avoids hard-coding the URL into the procedure and allows it to run in any<br>environment—development, integration, production, etc.<br>■ Note The JavaScript, AjaxMgr.js, is included in the media but not reproduced here.<br>An HTML form is opened with two dropdown lists defined. The first list is populated with the names<br>of all managers from the employees table. The second dropdown list is intentionally left empty. It will be<br>populated at runtime when the user selects a manager from the first dropdown list. Figure 14-7 shows<br>the initial data entry screen generated by the html procedure, prior to the user selecting a manager from<br>the manager’s dropdown list.<br>The manager’s dropdown list, mgr, is created using the htp.formSelectOpen procedure with an<br>additional parameter to define the JavaScript to execute when the selected item in the list changes. A<br>change to the manager’s dropdown list invokes the JavaScript procedure loadEmployees, which was<br>defined earlier in the <SCRIPT> tag.<br>The employee’s dropdown list, emp, is also created using the htp.formSelectOpen procedure with an<br>additional parameter to define the ID name of the object in the Web browser’s DOM2. This ID is required<br>by the JavaScript to dynamically rebuild the employee dropdown list if the value in the manager<br>dropdown list changes. Figure 14-8 shows the data entry form after a Manager is selected by the user.<br>Note the Subordinate list is now populated. </p>
<p>2 A DOM (Document Object Model) “is a cross-platform and language-independent convention for<br>representing and interacting with objects in HTML, XHTML and XML documents.” – Wikipedia.<br>CHAPTER 14  USING PL/SQL ON THE WEB<br>318<br>The xml procedure calls the gen_xml procedure, created in Recipe 14-11, to generate the data<br>required to populate the employee dropdown list via the Ajax call. The gen_xml procedure is generic in<br>that it only requires the select statement need to produce the XML output. </p>
<p>Figure 14-7. Manager dropdown list with empty subordinate dropdown list </p>
<p>Figure 14-8. Subordinate list after being populated by Ajax<br>C H A P T E R  15 </p>
<p>   </p>
<p>319<br>Java in the Database </p>
<p>Java plays an important role in the application development space today. It has become increasingly<br>popular over the years, because it is cross-platform, powerful, and easy to learn. Although Java<br>development is not directly related to PL/SQL, it is important for a PL/SQL developer to learn a bit about<br>Java since there are some major benefits to using it to perform database tasks. Integrating the two<br>languages when you’re building Oracle Database applications is a seamless effort. Oracle Database 11g<br>contains JVM compatibility with Java 1.5, which includes substantial changes to the Java language,<br>making it an even more complementary development platform. Also starting with Oracle 11g, the<br>database includes a just-in-time compiler, which compiles Java bytecode into machine language<br>instructions, making Java in the database run much faster. In 2010, Oracle acquired Sun Microsystems,<br>so it now owns Java. This may help the database JVM compatibility remain in concert with the latest<br>releases.<br>In this chapter, you will learn how to combine the power of PL/SQL development with Java code<br>that is stored within the database. You will learn how to create stored procedures, functions, and triggers<br>using the Java language. Running Java in the database is a substantial topic that has filled entire books,<br>but in this chapter, we will focus only on using the Java types in conjunction with PL/SQL applications—<br>which, after all, is the subject of this book. For complete documentation on using Java inside Oracle<br>Database, please see the Oracle Java developers guide at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/E11882_01/java.112/e10588/toc.htm">http://download.oracle.com/docs/cd/E11882_01/java.112/e10588/toc.htm</a>.<br>15-1. Creating a Java Database Class<br>Problem<br>You want to write a Java class that will query the database and return a result.<br>Solution<br>Create a Java class that uses the Java Database Connectivity (JDBC) API to query the Oracle Database.<br>For example, the Java class in the following example will query the EMPLOYEES table for all employees who<br>belong to the IT department. The example entails a complete Java class that is named Employees. This<br>class contains a method named getItEmps() that will become a Java stored procedure. The Employees<br>class shown here will be stored into a file named Employees.java. </p>
<p>import java.sql.<em>;<br>import oracle.jdbc.</em>; </p>
<p>public class Employees {<br>  public static void getItEmps(){<br>CHAPTER 15  JAVA IN THE DATABASE<br>320<br>      String firstName = null;<br>      String lastName = null;<br>      String email = null;<br>      try {<br>           Connection conn = DriverManager.<br>                        getConnection("jdbc:default:connection:");<br>           String sql = "SELECT FIRST_NAME, LAST_NAME, EMAIL " +<br>                        "FROM EMPLOYEES " +<br>                        "WHERE DEPARTMENT_ID = 60";<br>           PreparedStatement pstmt = conn.prepareStatement(sql);<br>           ResultSet rset = pstmt.executeQuery();<br>           while(rset.next()) {<br>             firstName = rset.getString(1);<br>             lastName = rset.getString(2);<br>             email = rset.getString(3);<br>             System.out.println(firstName + " " + lastName + " " +<br>                                email);<br>           }<br>           pstmt.close();<br>           rset.close();<br>      } catch (SQLException ex){<br>          System.err.println("ERROR: " + ex);<br>      }<br>  };<br>The following lines from SQL*Plus show how to execute this Java in the database, followed by the<br>output from the program. Prior to executing the code, you must load it into the database and compile it.<br>You will learn more about doing this in the next recipe. To learn more about executing Java in the<br>database, please see Recipe 15-5. For now, it is important to see the output that will result from a<br>successful call to this Java program.<br>SQL> exec get_it_emps;<br>Alexander Hunold AHUNOLD<br>Bruce Ernst BERNST<br>David Austin DAUSTIN<br>Valli Pataballa VPATABAL<br>Diana Lorentz DLORENTZ<br>PL/SQL procedure successfully completed.<br>The Java class in this example performs a simple query and then prints the result. Although this<br>class does not demonstrate the full potential of using Java, it is a good segue into Java database<br>development.<br>How It Works<br>Java is a mature language that can be used in conjunction with PL/SQL. Sometimes it makes sense to<br>code portions of your application in Java, while in other instances it may make sense to code the entire<br>  CHAPTER 15  JAVA IN THE DATABASE<br>321<br>application in Java. Both PL/SQL and Java can coexist in the same application, and you must use PL/SQL<br>to access Java via the database.<br>This recipe demonstrates how to create a simple Java class that queries the database for EMPLOYEE<br>records. The JDBC APIs provide a way for Java programs to methodically perform the tasks you will<br>typically want to complete whenever you access a database, whether it’s querying data, updating<br>records, or deleting rows.<br>A Java class that you will use to access an Oracle Database as a stored procedure must adhere to a<br>few standards. The class must be public, and each of its methods must be public and static. Failure to<br>follow these standards will render the class methods inaccessible for use as stored procedures.<br>The first step taken in the solution to this recipe is to obtain a connection to the database. In a Java<br>class that lives outside the database, obtaining a connection is a performance-intensive operation, and<br>you must pass a user name and password along with the database host name. However, obtaining a<br>connection using stored procedures is a bit different since they reside within the database itself. The<br>only requirement is that you pass jdbc:default:connection to the getConnection() method. </p>
<p>Next, the SQL query (sql) is formed as a String, and a PreparedStatement object (pstmt) is then<br>created from it using the prepareStatement method. The prepared statement is what actually queries the<br>database. The next line of code in the solution issues the query by calling the executeQuery() method on<br>the prepared statement object, which returns a result set. The result set is what you need to use in order<br>to access the rows that have been returned via the query. Use a simple while loop to traverse the rows,<br>and obtain each of the values from the result set within each iteration of the loop by indicating the<br>position of the column you want to retrieve. For instance, to obtain the FIRST_NAME, you will call<br>rset.getString(1) because FIRST_NAME is the first column that is listed within the query.<br>Lastly, the class in the solution closes the prepared statement and result set objects. Not doing so<br>may cause issues such as memory leaks, although Java has a very efficient garbage collection system, so<br>it should take care of this for you. Again, closing the objects is a form of good practice to ensure that<br>resources can be reallocated.<br>The Oracle Java virtual machine (JVM) also supports the use of SQLJ for database access. Use of<br>SQLJ is beyond the scope of this book, but if you are interested in learning about it JVM, then please refer<br>to the Oracle Java Developer Guide, which can be found at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/E11882_01/java.112/e10588/toc.htm">http://download.oracle.com/docs/cd/E11882_01/java.112/e10588/toc.htm</a>.<br>15-2. Loading a Java Database Class into a Database<br>Problem<br>You want to load a Java class into a schema within your Oracle Database.<br>Solution #1<br>You can use the CREATE JAVA command to load the Java source into the database by copying and pasting<br>the Java source into a SQL file. This is the easiest way to create a Java class and then load it into the<br>database if you are not working directly on the database server but rather remotely using an editor or<br>SQL*Plus. The following lines of SQL code will load the Java class that was created in Recipe 15-1 into the<br>database using the CREATE JAVA command: </p>
<p>CREATE OR REPLACE JAVA SOURCE NAMED "Employees" AS<br>import java.sql.<em>;<br>import oracle.jdbc.</em>;<br>CHAPTER 15  JAVA IN THE DATABASE<br>322 </p>
<p>public class Employees {<br>  public static void getItEmps(){<br>      String firstName = null;<br>      String lastName = null;<br>      String email = null;<br>      try {<br>           Connection conn = DriverManager.<br>                        getConnection("jdbc:default:connection:");<br>           String sql = "SELECT FIRST_NAME, LAST_NAME, EMAIL " +<br>                        "FROM EMPLOYEES " +<br>                        "WHERE DEPARTMENT_ID = 60"; </p>
<pre><code>       PreparedStatement pstmt = conn.prepareStatement(sql); 
       ResultSet rset = pstmt.executeQuery(); 
       while(rset.next()) &#123; 
         firstName = rset.getString(1); 
         lastName = rset.getString(2); 
         email = rset.getString(3); 
         System.out.println(firstName + &quot; &quot; + lastName + &quot; &quot; + 
                            email); 
       &#125; 
       pstmt.close(); 
       rset.close(); 
  &#125; catch (SQLException ex)&#123; 
      System.err.println(&quot;ERROR: &quot; + ex); 
      &#125; 
  &#125;           
</code></pre>
<p>  };<br>Next, you need to compile the code. To do so, use the ALTER JAVA CLASS <name> RESOLVE command.<br>The following line of code compiles the Employees Java source: </p>
<p>ALTER JAVA CLASS "Employees" RESOLVE;<br>Solution #2<br>You can use the loadjava utility that is provided by Oracle in order to load Java code into the database.<br>This situation works best if you are working directly on the database server and have access to the<br>loadjava utility that is installed in the Oracle Database home. This utility is also nice to use if you already<br>have the Java code stored in a file and do not want to copy and paste code into an editor or SQL*Plus.<br>The following code demonstrates loading a Java source file named Employees.java using the loadjava<br>utility: </p>
<p>loadjava –user dbuser Employees.java </p>
<p>After the command is issued, you will be prompted for the password to the user who you named<br>using the –user option. By issuing the –resolve option, you will be loading the Java into the database and<br>compiling at the same time. This saves you the step of issuing the ALTER JAVA CLASS <name> RESOLVE<br>command.<br>  CHAPTER 15  JAVA IN THE DATABASE<br>323<br>How It Works<br>You can load Java source code into the database directly using the CREATE JAVA SOURCE command. This<br>will load the source and make it accessible to the schema in which it was loaded. Once loaded, you can<br>create a call specification for any of the class methods that you want to make into a stored procedure or<br>function. The call specification maps the Java method names, parameter types, and return types to their<br>SQL counterparts. You will learn more about creating call specifications in Recipe 15-4. We recommend<br>compiling the source using the RESOLVE command before attempting to invoke any of its methods.<br>However, if you do not issue the RESOLVE command, then Oracle Database will attempt to compile the<br>Java source dynamically at runtime.<br> Note A class name can be a maximum of 30 characters in length. If the specified name is more than 30<br>characters in length, then Oracle will automatically shorten it for you and create and use a map to correlate the<br>long name with the shortened name. You can still specify the long name in most cases, and Oracle will<br>automatically convert that name to the shortened name for you. However, in some cases you will need to use the<br>DBMS_JAVA.SHORTNAME('long_classname') function to map the name for you. Conversely, if you want to retrieve<br>the long name by using its corresponding short name, you can use the<br>DBMS_JAVA.LONGNAME('short_classname') function.<br>The loadjava utility, which is the tool you use to implement the second solution, uses the CREATE<br>JAVA command to load the Java into the database. It also allows you to specify the –resolve option,<br>which will compile the code once it has been loaded. The advantage to using loadjava is that you can<br>load Java source files directly into the database without the need to create a separate SQL file containing<br>the CREATE JAVA command or copy and paste the Java class into SQL*Plus. The downside is that you<br>must have access to the loadjava binary executable that resides on the Oracle Database server. This<br>utility can also be used to load files of type .class, .sqlj. ,  .properties,  and .ser.<br>If your code is unable to compile because of errors, then it will not execute if you attempt to invoke<br>one of its methods. You must repair the error(s) and ensure that the code compiles successfully before it<br>can be used. If your code does not compile, then you can check the USER_ERRORS table to see what<br>issue(s) are preventing the code from compiling successfully. The USER_ERRORS table describes the<br>current errors on all the objects that are contained within the user’s schema. To learn more about<br>querying the USER_ERRORS table, please refer to Recipe 15-15.<br>15-3. Loading a Compiled Java Class Into the Database<br>Problem<br>You want to load a compiled Java class into the database so that you can use one or more of its methods<br>as stored procedures.<br>CHAPTER 15  JAVA IN THE DATABASE<br>324<br>Solution<br>Use the loadjava command-line utility to load the compiled Java class into the database. The following<br>line of code demonstrates how to use the loadjava utility to load a compiled Java class file named<br>Employees.class into the database. </p>
<p>loadjava -user dbuser -resolve Employees.class<br>You will be prompted to enter the password for the database user who you designated when issuing<br>the command.<br>How It Works<br>The loadjava utility can be used to load compiled Java class files into the database. To do so, you have<br>access to the binary loadjava utility executable. Usually this means you are located directly on the<br>Oracle Database server hosting the database that you want to load the Java into. Before you can invoke<br>the loadjava utility, you should be sure that the ORACLE_SID for the target database has been set. If the<br>server on which you are located contains more than one Oracle home, then it is a good idea to also set<br>the ORACLE_HOME environment variable to be sure you will be invoking the correct version of the loadjava<br>utility for your database. The loadjava utility is located within the bin directory of the Oracle Database<br>home. The following statements show how to set these two environment variables on a Windows<br>machine: </p>
<p>SET ORACLE_SID=MYDATABASE<br>SET ORACLE_HOME=<PATH_TO_ORACLE_HOME><br>If you happen to be working on a Unix or Linux machine, the equivalent commands would be as<br>follows: </p>
<p>setenv ORACLE_SID = MYDATABASE<br>setenv ORACLE_HOME= <PATH_TO_ORACLE_HOME> </p>
<p>You must have the following permissions in order to use the loadjava utility:<br>• CREATE PROCEDURE<br>• CREATE TABLE<br>• Oracle.aurora.security.JServerPermission.loadLibraryInClass.classname </p>
<p>Several options are at your disposal when using loadjava to load source or compiled class files into<br>the database. The –resolve option can be used to compile Java source and mark it as VALID within the<br>Oracle Database. The –resolver option can be used for locating other Java class files that your code is<br>dependant upon. For a complete listing of loadjava options, please see the online Oracle<br>documentation, which can be found at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/E11882_01/java.112/e10588/cheleven.htm#CACFHDJE">http://download.oracle.com/docs/cd/E11882_01/java.112/e10588/cheleven.htm#CACFHDJE</a>. </p>
<p>The loadjava utility is a member of the DBMS_JAVA package, and it can be invoked directly from<br>within your PL/SQL code as well. To do this, issue a call to DBMS_JAVA.loadjava, and pass the options<br>separated by spaces. This is demonstrated by the following lines of text in SQL*Plus: </p>
<p>call dbms_java.loadjava(‘Employees.class’);<br>  CHAPTER 15  JAVA IN THE DATABASE<br>325<br>15-4. Exposing a Java Class As a Stored Procedure<br>Problem<br>You have created a Java stored procedure and loaded it into the database, and now you want to access it<br>via PL/SQL.<br>Solution<br>Create a PL/SQL call specification for the Java class. The PL/SQL call specification will essentially wrap<br>the call to the Java class, enabling you to have access to the class from PL/SQL. The following code<br>demonstrates the creation of a call specification for the Java class that was created in Recipe 15-1 and<br>loaded into the database in Recipe 15-2. </p>
<p>CREATE OR REPLACE PROCEDURE get_it_emps AS LANGUAGE JAVA<br>NAME 'Employees.getItEmps()';<br>How It Works<br>To make the Java class accessible from the database, you must create a PL/SQL call specification<br>(sometimes known as PL/SQL wrapper) for the stored Java code. A call specification maps a Java method<br>call to a PL/SQL procedure so that the Java code can be called from the database directly. A call<br>specification also maps any parameters and return type to the Java code. To learn more about mapping<br>parameters and return types, please see Recipe 15-7.<br>The call specification for a Java stored procedure is a PL/SQL procedure itself that specifies AS<br>LANGUAGE JAVA, followed by the name of the Java class and method that will be mapped to the procedure<br>name. The name of the Java method to be invoked must be preceded by the Java class name that<br>contains it. This is because the method has been defined as static, meaning it is a class method rather<br>than an instance method. When a call to the specification is made, Oracle will automatically call the<br>underlying Java class method.<br> Note Two types of methods can be created in a Java class: class methods and instance methods. Class<br>methods belong to the class, rather than to an instance of the class. This means the methods are instantiated once<br>for each class. Instance methods belong to an instance of the class. This means that if a new instance of the class<br>is created, a new method will be created with that instance. Class methods have access to class variables<br>(otherwise known as static), whereas instance methods have access only to instance variables.<br>15-5. Executing a Java Stored Procedure<br>Problem<br>You want to execute a Java stored procedure that you have created from within SQL<em>Plus.<br>CHAPTER 15  JAVA IN THE DATABASE<br>326<br>Solution<br>Call the PL/SQL call specification that maps to the Java stored procedure. The following SQL</em>Plus code<br>demonstrates how to execute the Java class for which you created a call specification in Recipe 15-3. </p>
<p>SQL> set serveroutput on<br>SQL> call dbms_java.set_output(2000); </p>
<p>Call completed. </p>
<p>SQL> exec get_it_emps;<br>Alexander Hunold AHUNOLD<br>Bruce Ernst BERNST<br>David Austin DAUSTIN<br>Valli Pataballa VPATABAL<br>Diana Lorentz DLORENTZ </p>
<p>PL/SQL procedure successfully completed.<br>As you can see, when the code is executed, the results are returned to SQL<em>Plus and displayed as if it<br>were the output of a PL/SQL procedure or function.<br>How It Works<br>Java can be executed directly from within the database once a call specification has been made for the<br>corresponding Java method. Since the call specification is a PL/SQL procedure itself, you can invoke the<br>underlying Java just as if it were PL/SQL using the EXEC command from SQL</em>Plus or call it from any other<br>PL/SQL block as if it were PL/SQL as illustrated in Recipe 15-6. To see any output from the Java, you<br>must set the buffer size appropriately to display it. If the buffer size is not set, then no output will be<br>displayed. Similarly, if the buffer size is set too small, then only a portion of the output will be displayed.<br>Personally, we recommend setting the output size to 2000 and moving up from there if needed. To set<br>the buffer size, issue this command: </p>
<p>CALL DBMS_JAVA.SET_OUTPUT(buffer_size);<br>The Java will be executed seamlessly and display the result, if any, just as if it were a PL/SQL<br>response. In the solution to this recipe, the get_it_emps PL/SQL procedure is called. Since get_it_emps is<br>a call specification, it will invoke the underlying Java class method getItEmps() that actually performs the<br>query and displays the content.<br>15-6. Calling a Java Stored Procedure from PL/SQL<br>Problem<br>You want to access a Java stored procedure from within one of your PL/SQL applications. For instance,<br>you are creating a PL/SQL procedure, and you want to make a call to a Java stored procedure from<br>within it.<br>  CHAPTER 15  JAVA IN THE DATABASE<br>327<br>Solution<br>Make a call to the Java stored procedure using the call specification that you created for it. The following<br>code demonstrates a PL/SQL package that makes a call to a Java stored procedure and then resumes<br>PL/SQL execution once the call has been made. </p>
<p>CREATE OR REPLACE PROCEDURE employee_reports AS<br>  CURSOR emp_cur IS<br>  SELECT first_name, last_name, email<br>  FROM employees<br>  WHERE department_id = 50; </p>
<p>  emp_rec    emp_cur%ROWTYPE;<br>BEGIN<br>  DBMS_OUTPUT.PUT_LINE('Employees from Shipping Department');<br>  DBMS_OUTPUT.PUT_LINE('----------------------------------');<br>  FOR emp_rec IN emp_cur LOOP<br>    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ' ' ||<br>                         emp_rec.last_name || ' ' ||<br>                         emp_rec.email);<br>  END LOOP; </p>
<p>  DBMS_OUTPUT.PUT_LINE('==========================================');<br>  DBMS_OUTPUT.PUT_LINE('Employees from IT Department');<br>  DBMS_OUTPUT.PUT_LINE('----------------------------');<br>  get_it_emps;<br>END;<br>This results in the following output: </p>
<p>SQL> EXEC EMPLOYEE_REPORTS<br>Employees from Shipping Department </p>
<hr>
<p>Matthew Weiss MWEISS<br>Adam Fripp AFRIPP<br>…<br>Alana Walsh AWALSH<br>Kevin Feeney KFEENEY<br>Donald OConnell DOCONNEL<br>Douglas Grant DGRANT<br>==========================================<br>Employees from IT Department </p>
<hr>
<p>Alexander Hunold AHUNOLD<br>Bruce Ernst BERNST<br>David Austin DAUSTIN<br>Valli Pataballa VPATABAL<br>Diana Lorentz DLORENTZ </p>
<p>PL/SQL procedure successfully completed.<br>CHAPTER 15  JAVA IN THE DATABASE<br>328<br>The call to the Java stored procedure from within the PL/SQL procedure is seamless. It is integrated<br>into the PL/SQL procedure body and invoked as if it were PL/SQL.<br>How It Works<br>The call specification publishes the Java stored procedure as if it were a PL/SQL procedure. This allows<br>for seamless integration of Java stored procedures and PL/SQL. In the solution to this recipe, the<br>EMPLOYEES table is queried via a PL/SQL cursor for all employees who belong to department 50. That<br>cursor is then parsed, and the results are displayed. After the cursor results have been processed, a call is<br>made to the Java stored procedure getItEmps() using the call specification get_it_emps. The Java stored<br>procedure is executed, and its results are displayed along with those from the PL/SQL cursor processing.<br>As you can see, Java can be executed from PL/SQL just as if it were native PL/SQL code. It can be<br>very useful to create database jobs utilizing Java stored procedures by developing a PL/SQL stored<br>procedure or anonymous block that makes a series of calls to different Java stored procedures or<br>functions that perform the actual processing. PL/SQL and Java in the database can be very<br>complementary to each other.<br>15-7. Passing Parameters Between PL/SQL and Java<br>Problem<br>You want to pass parameters from PL/SQL to a Java stored procedure that expects them.<br>Solution<br>Create a call specification that accepts the same number of parameters as the number the Java stored<br>procedure expects. For this example, an additional method will be added to the Employee Java class that<br>was created in Recipe 15-1. This method will be an enhanced version of the original method that will<br>accept a department ID as an input argument. It will then query the database for the employees who<br>belong to that department and display them.<br>The following code is the enhanced Java method that will be added the Employees class contained<br>within the Employees.java file: </p>
<p>public static void getItEmpsByDept(int departmentId){<br>      String firstName = null;<br>      String lastName = null;<br>      String email = null;<br>      try {<br>           Connection conn = DriverManager.<br>                        getConnection("jdbc:default:connection:");<br>           String sql = "SELECT FIRST_NAME, LAST_NAME, EMAIL " +<br>                        "FROM EMPLOYEES " +<br>                        "WHERE DEPARTMENT_ID = ?"; </p>
<pre><code>       PreparedStatement pstmt = conn.prepareStatement(sql); 
       pstmt.setInt(1, departmentId); 
       ResultSet rset = pstmt.executeQuery(); 
       while(rset.next()) &#123; 
         firstName = rset.getString(1); 
         lastName = rset.getString(2); 
</code></pre>
<p>  CHAPTER 15  JAVA IN THE DATABASE<br>329<br>             email = rset.getString(3);<br>             System.out.println(firstName + " " + lastName + " " +<br>                                email);<br>           }<br>           pstmt.close();<br>           rset.close();<br>      } catch (SQLException ex){<br>          System.err.println("ERROR: " + ex);<br>          }<br>  }<br>Once this method has been added to the Employees class, then the Java source should be loaded into<br>the database using the technique demonstrated in Recipe 15-2.<br> Note You must include the OR REPLACE clause of the CREATE JAVA statement if the Employees source is<br>already contained in the database. If you do not include this clause, then you will receive an Oracle error.<br>Once the Java has been loaded into the database and compiled, you will need to create the call<br>specification that will be used by PL/SQL for accessing the Java stored procedure. The following code<br>demonstrates a call specification that will accept a parameter when invoked and pass it to the Java<br>stored procedure: </p>
<p>CREATE OR REPLACE PROCEDURE get_it_emps_by_dept(dept_id IN NUMBER)<br> AS LANGUAGE JAVA<br>NAME 'Employees.getItEmpsByDept(int)';<br>The procedure can now be called by passing a department ID value as such: </p>
<p>SQL> exec get_it_emps_by_dept(60);<br>Alexander Hunold AHUNOLD<br>Bruce Ernst BERNST<br>David Austin DAUSTIN<br>Valli Pataballa VPATABAL<br>Diana Lorentz DLORENTZ </p>
<p>PL/SQL procedure successfully completed.<br>How It Works<br>The call specification is what determines how a Java stored procedure or function’s arguments are<br>mapped to PL/SQL arguments. To implement parameters, the call specification must match each<br>parameter in the stored procedure or function to an argument in the specification. As mentioned in<br>previous recipes, the call specification is a PL/SQL procedure itself, and each argument that is coded in<br>the specification matches an argument that is coded within the Java stored procedure.<br>The datatypes that Java uses do not match those used in PL/SQL. In fact, a translation must take<br>place when passing parameters listed as a PL/SQL datatype to a Java stored procedure that accepts<br>parameters as a Java datatype. If you are familiar enough with each of the two languages, the translation<br>CHAPTER 15  JAVA IN THE DATABASE<br>330<br>is fairly straightforward. However, there are always those cases where one is not sure what datatype to<br>match against. Table 15-1 lists some of the most common datatypes and how they map between Java<br>and PL/SQL. For a complete datatype map, please refer to the Oracle documentation at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/B28359_01/java.111/b31225/chsix.htm#CHDFACEE">http://download.oracle.com/docs/cd/B28359_01/java.111/b31225/chsix.htm#CHDFACEE</a>.<br>Table 15-1. Datatype Map<br>SQL Datatype Java Type<br>CHAR oracle.sql.CHAR<br>VARCHAR java.lang.String<br>LONG java.lang.String<br>NUMBER java.lang.Integer,Java.lang.Float,Java.lang.Double,Java.<br>math.BigDecimal,Java.lang.Byte,Oracle.sql.NUMBER,Java.la<br>ng.Short,<br>DATE    oracle.sql.DATE<br>TIMESTAMP oracle.sql.TIMESTAMP<br>TIMESTAMP WITH TIME ZONE oracle.sql.TIMESTAMPTZ<br>TIMESTAMP WITH LOCAL TIME ZONE  oracle.sql.TIMESTAMPLTZ<br>BLOB oracle.sql.BLOB<br>CLOB oracle.sql.CLOB<br>Creating a PL/SQL call specification that includes parameters must use the fully qualified Java class<br>name when specifying the parameter datatypes in the Java class method signature. If an incorrect<br>datatype is specified, then an exception will be thrown. For instance, if you want to pass a VARCHAR2 from<br>PL/SQL to a Java stored procedure, the signature for the Java class method must accept an argument of<br>type java.lang.String. The following pseudocode demonstrates this type of call specification:<br>CREATE OR REPLACE PROCEDURE procedure_name(value   VARCHAR2)<br>AS LANGUAGE JAVA<br>NAME ‘JavaClass.javaMethod(java.lang.String)’;<br>15-8. Creating and Calling a Java Database Function<br>Problem<br>You want to create a database function using the Java language.<br>  CHAPTER 15  JAVA IN THE DATABASE<br>331<br>Solution<br>Create a function written in Java, and then create a call specification for the function. Ensure that the call<br>specification allows for the same number of parameters to pair up with the Java function and allows for a<br>returning result. For this recipe, you will add a function to the Employees Java class that will accept an<br>employee ID and return that employee’s job title. The following code is the Java source for the function<br>named getEmpJobTitle: </p>
<p>public static String getEmpJobTitle(int empId){<br>      String jobTitle = null;<br>      try {<br>           Connection conn = DriverManager.<br>                        getConnection("jdbc:default:connection:");<br>           String sql = "SELECT JOB_TITLE " +<br>                        "FROM EMPLOYEES EMP, " +<br>            "JOBS JOBS " +<br>                        "WHERE EMP.EMPLOYEE_ID = ? " +<br>                         "AND JOBS.JOB_ID = EMP.JOB_ID"; </p>
<pre><code>       PreparedStatement pstmt = conn.prepareStatement(sql); 
       pstmt.setInt(1, empId); 
       ResultSet rset = pstmt.executeQuery(); 
       while(rset.next()) &#123; 
         jobTitle = rset.getString(1); 
       &#125; 
       pstmt.close(); 
       rset.close(); 
                      &#125; catch (SQLException ex)&#123; 
                                 System.err.println(&quot;ERROR: &quot; + ex); 
                                 jobTitle = &quot;N/A&quot;; 
      &#125; 
              if (jobTitle == null)&#123; 
                   jobTitle = &quot;N/A&quot;; 
             &#125; 
                                return jobTitle; 
</code></pre>
<p>  }<br>Next is the call specification for the function: </p>
<p>CREATE OR REPLACE FUNCTION get_emp_job_title(emp_id IN NUMBER)<br>RETURN VARCHAR2 AS LANGUAGE JAVA<br>NAME 'Employees.getEmpJobTitle(int) return java.lang.String';<br>The function can now be called just like a PL/SQL function would. The following lines of code show<br>a SQL SELECT statement that calls the function passing an employee ID number of 200. </p>
<p>SQL> select get_emp_job_title(200) from dual; </p>
<h2 id="GET-EMP-JOB-TITLE-200"><a href="#GET-EMP-JOB-TITLE-200" class="headerlink" title="GET_EMP_JOB_TITLE(200) "></a>GET_EMP_JOB_TITLE(200) </h2><p>Administration Assistant<br>CHAPTER 15  JAVA IN THE DATABASE<br>332<br>How It Works<br>The difference between a stored procedure and a stored function is that a function always returns a<br>value. In the Java language, a method may or may not return a value. The difference between a PL/SQL<br>call specification for a Java stored procedure and a PL/SQL call specifcation for a Java function is that the<br>PL/SQL call specification will specify a return value if it is being used to invoke an underlying function.<br>In the solution to this recipe, the example PL/SQL call specification returns a VARCHAR2 data type because<br>the Java function that is being called will return a Java String.<br>15-9. Creating a Java Database Trigger<br>Problem<br>You want to create a database trigger that uses a Java stored procedure to do its work.<br>Solution<br>Create a Java stored procedure that does the work you require, and publish it as a Java stored procedure,<br>making it accessible to PL/SQL. Once it’s published, write a standard PL/SQL trigger that calls the Java<br>stored procedure.<br>For example, suppose you need a trigger to audit INSERT events on the EMPLOYEES table and record<br>them in another table. First, you must create the table that will be used to record each of the logged<br>events. The following DDL creates one: </p>
<p>CREATE TABLE EMPLOYEE_AUDIT_LOG (<br>employee_id     NUMBER,<br>enter_date      DATE);<br>Next, you will need to code the Java stored procedure that you want to have executed each time an<br>INSERT occurs on the EMPLOYEES table. Add the following Java method to the Employees class of previous<br>recipes in this chapter:<br>public static void employeeAudit(int empId){<br>      try {<br>           Connection conn = DriverManager.<br>                        getConnection("jdbc:default:connection:");<br>           String sql = "INSERT INTO EMPLOYEE_AUDIT_LOG VALUES(" +<br>                    "?, sysdate)";<br>           PreparedStatement pstmt = conn.prepareStatement(sql);<br>           pstmt.setInt(1, empId);<br>           pstmt.executeUpdate();<br>       pstmt.close();<br>       conn.commit(); </p>
<pre><code>  &#125; catch (SQLException ex)&#123; 
      System.err.println(&quot;ERROR: &quot; + ex); 
      &#125; 
   
</code></pre>
<p>  }<br>  CHAPTER 15  JAVA IN THE DATABASE<br>333<br>Next, the PL/SQL call specification for the Java stored procedure must be created. The following is<br>the code to implement the call specification: </p>
<p>CREATE OR REPLACE PROCEDURE emp_audit(emp_id NUMBER)<br>AS LANGUAGE JAVA<br>NAME 'Employees.employeeAudit(int)'; </p>
<p>Finally, a trigger to call the EMP_AUDIT procedure must be created. The trigger will be executed on<br>INSERT to the EMPLOYEES table. The following code will generate the trigger to call EMP_AUDIT: </p>
<p>CREATE OR REPLACE TRIGGER emp_audit_ins<br>AFTER INSERT ON EMPLOYEES<br>FOR EACH ROW<br>CALL emp_audit(:new.employee_id);<br>Once all these pieces have been successfully created within the database, the EMP_AUDIT_INS trigger<br>will be executed each time there is an INSERT made to the EMPLOYEES table. In turn, the trigger will call the<br>EMP_AUDIT PL/SQL procedure, which calls the Java method contained within the Employees class. The<br>SQL*Plus output shown here demonstrates an INSERT into the EMPLOYEES table, followed by a query on<br>the EMPLOYEE_AUDIT_LOG table to show that the trigger has been invoked: </p>
<p>SQL> insert into employees values(<br>   employees_seq.nextval,<br>   'Jane',<br>   'Doe',<br>   '<a href="mailto:&#x6a;&#97;&#x6e;&#x65;&#x2e;&#100;&#111;&#x65;&#x40;&#109;&#121;&#x63;&#111;&#109;&#x70;&#x61;&#110;&#121;&#46;&#x63;&#111;&#109;">&#x6a;&#97;&#x6e;&#x65;&#x2e;&#100;&#111;&#x65;&#x40;&#109;&#121;&#x63;&#111;&#109;&#x70;&#x61;&#110;&#121;&#46;&#x63;&#111;&#109;</a>',<br>   null,<br>   sysdate,<br>   'FI_MGR',<br>   null,<br>   null,<br>   null,<br>   null); </p>
<p>1 row created. </p>
<p>SQL> select * from employee_audit_log; </p>
<p>EMPLOYEE_ID ENTER_DAT </p>
<hr>
<pre><code>265 02-NOV-10 
</code></pre>
<p>How It Works<br>A Java-based trigger combines the power of Java code with the native ease of performing data<br>manipulation using PL/SQL triggers. Although creating a Java trigger requires more steps than using<br>native PL/SQL, the Java code is portable. If your application is supported on more than one database<br>platform, this lets you write code once and deploy it in many environments. It also makes sense to code<br>a trigger using Java if you require the use of Java libraries or technologies that are unavailable to PL/SQL.<br>CHAPTER 15  JAVA IN THE DATABASE<br>334<br>In the solution to this recipe, a trigger was created that will insert a row into an audit table each time<br>an INSERT is made on the EMPLOYEES table. The actual work is performed within a Java method that is<br>added to a Java class and loaded into the database. For more information on loading Java into the<br>database, please see Recipe 15-2. To invoke the stored Java method, you must create a PL/SQL call<br>specification, which maps the Java method to a PL/SQL stored procedure. The call specification can<br>accept zero, one, or many parameters, and it will seamlessly pass the parameters to the underlying Java<br>method. The final step to creating a Java trigger is to code a PL/SQL trigger that invokes the PL/SQL<br>stored procedure that was created.<br>Creating a Java-based trigger entails a series of steps. Each piece of code depends upon the others,<br>and like a domino effect, the trigger will call the procedure that in turn executes the Java method. This<br>solution opens the world of Java libraries and thousands of possibilities to the standard PL/SQL trigger.<br>15-10. Passing Data Objects from PL/SQL to Java<br>Problem<br>You have retrieved a row of data from the database using PL/SQL, and you want to populate a PL/SQL<br>object type with that data and then pass the populated data object to a Java procedure.<br>Solution<br>Create a PL/SQL object type, along with a call specification for the Java stored procedure that you want<br>to pass the object to. Ensure that the Java stored procedure accepts an object of type oracle.sql.STRUCT<br>and that the call specification accepts the PL/SQL object type you have created. For this recipe, the<br>example will demonstrate the creation of a Java method that will accept an Employee object and return<br>that employee’s corresponding department name. The Java code will be invoked from within a PL/SQL<br>anonymous block that queries each employee, loads an Employee object with the data, passes the object<br>to the Java method, and returns the result.<br>First, add the following Java method to the Employees class you’ve used with previous recipes in this<br>chapter: </p>
<p>public static String getEmpDepartment(oracle.sql.STRUCT emp) { </p>
<pre><code>String deptName = null; 
BigDecimal employeeId = null; 
try &#123; 
      Object[] attribs = emp.getAttributes(); 
   // Use indexes to grab individual attributes. 
   Object empId = attribs[0]; 
   try&#123; 
       employeeId = (BigDecimal) empId; 
   &#125; catch (ClassCastException cce) &#123; 
       System.out.println(cce); 
   &#125; 
   Connection conn = DriverManager. 
                    getConnection(&quot;jdbc:default:connection:&quot;); 
       String sql = &quot;SELECT DEPARTMENT_NAME &quot; +  
                    &quot;FROM DEPARTMENTS DEPT, &quot; + 
        &quot;EMPLOYEES EMP &quot; + 
                    &quot;WHERE EMP.EMPLOYEE_ID = ? &quot; + 
</code></pre>
<p>  CHAPTER 15  JAVA IN THE DATABASE<br>335<br>            "AND DEPT.DEPARTMENT_ID = EMP.DEPARTMENT_ID"; </p>
<pre><code>       PreparedStatement pstmt = conn.prepareStatement(sql); 
       pstmt.setInt(1, employeeId.intValue()); 
       ResultSet rset = pstmt.executeQuery(); 
       while(rset.next()) &#123; 
         deptName = rset.getString(1); 
       &#125; 
       pstmt.close(); 
       rset.close(); 
  &#125; catch (java.sql.SQLException ex)&#123; 
      System.err.println(&quot;ERROR: &quot; + ex); 
      deptName = &quot;N/A&quot;; 
      &#125; 
  if (deptName == null)&#123; 
    deptName = &quot;N/A&quot;; 
  &#125; 
  return deptName; 
</code></pre>
<p>  }<br>Next, create the PL/SQL object that will contain employee information. The following SQL<br>statement will create this object: </p>
<p>CREATE TYPE Employee AS OBJECT (<br>emp_id NUMBER(6),<br>first VARCHAR2(20),<br>last  VARCHAR2(25),<br>email VARCHAR2(25),<br>job VARCHAR2(10),<br>dept NUMBER(4)<br>);<br>Now you need to create the call specification for the Java method. Since the method is returning a<br>value, the call specification needs to be a PL/SQL function that accepts an Employee object and returns a<br>String value. The following code demonstrates such a call specification for the getEmpDepartment Java<br>method: </p>
<p>CREATE OR REPLACE FUNCTION get_emp_department (emp Employee) RETURN VARCHAR2 AS<br>LANGUAGE JAVA<br>NAME 'Employees.getEmpDepartment(oracle.sql.STRUCT) return java.lang.String';<br>Finally, call the new Java function from within an anonymous block. The following PL/SQL block<br>uses a cursor to traverse the EMPLOYEES table and populates an Employee object with each iteration. In<br>turn, the object is passed to the Java stored procedure via the PL/SQL function GET_EMP_DEPARTMENT, and<br>the corresponding DEPARTMENT_NAME is returned. </p>
<p>DECLARE<br>  CURSOR emp_cur IS<br>  SELECT * FROM EMPLOYEES; </p>
<p>  emp_rec    emp_cur%ROWTYPE;<br>CHAPTER 15  JAVA IN THE DATABASE<br>336<br>  emp        Employee;<br>BEGIN<br>  FOR emp_rec IN emp_cur LOOP<br>    emp := Employee(emp_rec.employee_id,<br>                    emp_rec.first_name,<br>                    emp_rec.last_name,<br>                    emp_rec.email,<br>                    emp_rec.job_id,<br>                    emp_rec.department_id);<br>    DBMS_OUTPUT.PUT_LINE(emp.first || ' ' || emp.last || ' - ' ||<br>            get_emp_department(emp));<br>  END LOOP;<br>END;<br>How It Works<br>Passing objects to Java code should be second nature to you since Java is an object-oriented language.<br>You can create PL/SQL objects as well and use them within your PL/SQL and Java mashup applications.<br>The solution to this recipe demonstrated the creation of an Employee object in PL/SQL that was passed to<br>Java.<br>To accept a PL/SQL object type, Java code must use a parameter of type oracle.sql.STRUCT in place<br>of the object. The STRUCT object is basically a container that allows the contents to be accessed by calling<br>the getAttributes method. In the solution to this recipe, the oracle.sql.STRUCT object is accepted in the<br>Java class as a parameter, and then the getAttributes method is called on it. This creates an array of<br>objects that contains the data. The Java stored procedure accesses the object using the 0 index position,<br>which is the first placeholder from the PL/SQL object. This position maps to the emp_id field in the<br>PL/SQL object. The Java class then uses that emp_id to query the database and retrieve a corresponding<br>DEPARTMENT_ID if it exists.<br>The call specification must accept the PL/SQL object type as a parameter but use the<br>oracle.sql.STRUCT object as the parameter in the Java source signature. When the object is passed to the<br>PL/SQL call specification procedure, it will be converted into an oracle.sql.STRUCT object, which is a<br>datatype that a Java class can accept.<br>Organizing your data into objects can be useful, especially when the object you are creating does<br>not match a table definition exactly. For instance, you could create an object that contains employee<br>information along with region information. There are no tables that contain both of these fields, so in<br>order to retrieve the information together, you are forced into either using a SQL query that contains<br>table joins or creating a database view. In such a case, it may be easier to populate the object using<br>PL/SQL and then hand it off to the Java program for processing.<br>15-11. Embedding a Java Class Into a PL/SQL Package<br>Problem<br>You are interested in creating a Java class and making each of its methods and attributes available to<br>PL/SQL in an organized unit of code.<br>Solution<br>Use a PL/SQL package to declare each of the attributes and methods that reside within the Java class,<br>and then create separate call specifications for each of the Java methods within the PL/SQL package<br>  CHAPTER 15  JAVA IN THE DATABASE<br>337<br>body. The following code demonstrates the creation of a PL/SQL package named EMP_PKG, which<br>declares each of the methods that reside within the Employee Java class and makes them available to<br>PL/SQL via call specifications that are implemented within the package body.<br>First, create the package header as follows: </p>
<p>CREATE OR REPLACE PACKAGE EMP_PKG AS </p>
<pre><code>PROCEDURE get_it_emps; 
PROCEDURE get_it_emps_by_dept(dept_id IN NUMBER); 
PROCEDURE emp_audit(emp_id NUMBER); 
 
FUNCTION get_emp_job_title(emp_id IN NUMBER) RETURN VARCHAR2; 
FUNCTION get_emp_department (emp Employee) RETURN VARCHAR2; 
</code></pre>
<p>END;<br>Next, create the package body as follows, adding a call specification for each Java method or<br>attribute you plan to use: </p>
<p>CREATE PACKAGE BODY EMP_PKG AS </p>
<pre><code>PROCEDURE get_it_emps 
AS LANGUAGE JAVA 
NAME &#39;Employees.getItEmps()&#39;; 
 
PROCEDURE get_it_emps_by_dept(dept_id IN NUMBER) 
AS LANGUAGE JAVA 
NAME &#39;Employees.getItEmpsByDept(int)&#39;; 
 
PROCEDURE emp_audit(emp_id NUMBER) 
AS LANGUAGE JAVA 
NAME &#39;Employees.employeeAudit(int)&#39;; 
 
FUNCTION get_emp_job_title(emp_id IN NUMBER) RETURN VARCHAR2 
AS LANGUAGE JAVA 
NAME &#39;Employees.getEmpJobTitle(int) return String&#39;; 
 
FUNCTION get_emp_department (emp Employee) RETURN VARCHAR2 
AS LANGUAGE JAVA 
NAME &#39;Employees.getEmpDepartment(oracle.sql.STRUCT) return java.lang.String&#39;; 
</code></pre>
<p>END;<br>Now the package can be used to call each of the underlying Java stored procedures instead of having<br>separate PL/SQL procedures and functions for each. The following anonymous block has been modified<br>to make use of the PL/SQL package for calling GET_EMP_DEPARTMENT rather than a stand-alone function. </p>
<p>DECLARE<br>  CURSOR emp_cur IS<br>  SELECT * FROM EMPLOYEES; </p>
<p>CHAPTER 15  JAVA IN THE DATABASE<br>338<br>  emp_rec    emp_cur%ROWTYPE;<br>  emp        Employee;<br>BEGIN<br>  FOR emp_rec IN emp_cur LOOP<br>    emp := Employee(emp_rec.employee_id,<br>                    emp_rec.first_name,<br>                    emp_rec.last_name,<br>                    emp_rec.email,<br>                    emp_rec.job_id,<br>                    emp_rec.department_id);<br>    DBMS_OUTPUT.PUT_LINE(emp.first || ' ' || emp.last || ' - ' ||<br>            emp_pkg.get_emp_department(emp));<br>  END LOOP;<br>END;<br>How It Works<br>In programming, it is a best practice to organize code in a way that makes it easy to maintain.  Placing<br>related procedures and functions inside a single PL/SQL package is one such application of that<br>approach. The same can be said for working with Java code in the database. A few Java stored<br>procedures or functions will not cause much trouble to maintain. However, once you start to<br>accumulate more than a handful within the same underlying Java class, then it is a good idea to<br>consolidate the call specifications into a single PL/SQL package.<br>In the solution to this recipe, all the Java stored procedures that are contained within the Employees<br>Java class have call specifications that are grouped into a single PL/SQL package. If you create one<br>PL/SQL package containing call specifications per each Java class that is loaded into the database, you<br>will have a nicely organized environment. In some cases, you may have more than one Java class that<br>contains the implementations that are to be used within a single PL/SQL application. In those cases, it<br>may make more sense to combine all call specifications into a single PL/SQL package.<br>Using PL/SQL package to group call specifications is a good idea. Not only will this technique make<br>for easier maintenance, but it also makes for more uniform applications with consistent interfaces.<br>15-12. Loading Java Libraries Into the Database<br>Problem<br>You want to create a Java class that utilizes some external Java libraries. To do so, you must load those<br>external libraries into the database.<br>Solution<br>Use the loadjava utility to store the external libraries into the database. In this example, a Java utility<br>class containing a method that uses the JavaMail API to send e-mail will be loaded into the database. The<br>method relies on some external Java libraries to use the JavaMail API. The following loadjava commands<br>demonstrate the loading of three essential JAR files for using the JavaMail API: </p>
<p>loadjava –u <username> mail.jar<br>loadjava –u <username> standard.jar<br>loadjava –u <username> activation.jar </p>
<p>  CHAPTER 15  JAVA IN THE DATABASE<br>339<br>Next, load the Java source for the JavaUtils class into the database: </p>
<p>CREATE OR REPLACE JAVA SOURCE NAMED "JavaUtils" AS<br>import java.util.<em>;<br>import java.util.logging.Level;<br>import java.util.logging.Logger;<br>import javax.activation.</em>;<br>import javax.mail.<em>;<br>import javax.mail.internet.</em>;<br>import javax.naming.*; </p>
<p>public class JavaUtils { </p>
<p> public static void sendMail(String subject,<br>            String recipient,<br>            String message) {<br>        try { </p>
<pre><code>        Properties props = System.getProperties(); 
        props.put(&quot;mail.from&quot;, &quot;me@mycompany.com&quot;); 
        props.put(&quot;mail.smtp.host&quot;,&quot;company.smtp.server&quot;); 
        Session session = Session.getDefaultInstance(props,null); 
        Message msg = new MimeMessage(session); 
        msg = new MimeMessage(session); 
        msg.setSubject(subject); 
        msg.setSentDate(new java.util.Date()); 
        msg.setFrom(); 
         
        msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipient, 
</code></pre>
<p>false)); </p>
<pre><code>        MimeBodyPart body = new MimeBodyPart(); 
        body.setText(message); 
        Multipart mp = new MimeMultipart(); 
        mp.addBodyPart(body); 
        msg.setContent(mp); 

        Transport.send(msg); 
    &#125; catch (MessagingException ex) &#123; 
        Logger.getLogger(JavaUtils.class.getName()).log(Level.SEVERE, null, ex); 
    &#125;  
&#125;; 
</code></pre>
<p>Compile the Java sources using the ALTER JAVA SOURCE command. The sources should compile<br>without issues since the JAR files containing the required library references have been loaded into the<br>database. If the JAR files had not been loaded, then the class would not compile successfully. </p>
<p>ALTER JAVA SOURCE "JavaUtils" RESOLVE;<br>Lastly, create the call specification for the sendMail Java stored procedure. In this case, a PL/SQL<br>package will be created that contains the call specification for sendMail. </p>
<p>CHAPTER 15  JAVA IN THE DATABASE<br>340<br>CREATE OR REPLACE PACKAGE JAVA_UTILS AS<br>    PROCEDURE send_mail(subject VARCHAR2,<br>                        recipient VARCHAR2,<br>                        message VARCHAR2); </p>
<p>END;<br>CREATE OR REPLACE PACKAGE BODY JAVA_UTILS AS<br>    PROCEDURE send_mail(subject VARCHAR2,<br>                        recipient VARCHAR2,<br>                        message VARCHAR2)<br>    AS LANGUAGE JAVA<br>    NAME 'JavaUtils.sendMail(java.lang.String, java.lang.String, java.lang.String)'; </p>
<p>END;<br>The stored procedure can now be executed using the following command:<br>EXEC java_utils.send_mail('Test','<a href="mailto:&#109;&#x79;&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#109;&#121;&#x63;&#111;&#109;&#x70;&#x61;&#110;&#x79;&#46;&#99;&#111;&#x6d;">&#109;&#x79;&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#109;&#121;&#x63;&#111;&#109;&#x70;&#x61;&#110;&#x79;&#46;&#99;&#111;&#x6d;</a>','Test Message');<br>If the message is sucessfully sent, you will see the following output:<br>PL/SQL procedure successfully completed.<br>How It Works<br>Java libraries are packaged into JAR files so that they can be easily distributed. The loadjava utility can<br>be used to load Java libraries into the database. To use the utility, download the JAR files that you want to<br>load into the database, and place them into a directory that can be accessed by the database server.<br>Open the command prompt or terminal, traverse into that directory, and execute the loadjava utility,<br>using the –u flag to specify the database user and passing the name of the JAR file to load. If successful,<br>the JAR file will be loaded into the schema that you indicated with the –u flag, and you may begin to use<br>the libraries contained in the JAR file within your stored Java code.<br>The loadjava utility contains a number of options. For a complete listing of loadjava options, please<br>see the online Oracle documentation at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/B28359_01/java.111/b31225/cheleven.htm">http://download.oracle.com/docs/cd/B28359_01/java.111/b31225/cheleven.htm</a>.<br>Additional options are not necessary to load a JAR file into the schema that you indicate with the -u<br>flag. Since the JAR file consists of compiled Java libraries, there is no need to resolve the library once<br>loaded. As indicated in the solution to this recipe, you can begin to import classes from the libraries as<br>soon as they have been loaded.<br>15-13. Removing a Java Class<br>Problem<br>You want to drop a Java class from your database.<br>  CHAPTER 15  JAVA IN THE DATABASE<br>341<br>Solution<br>Issue the SQL DROP JAVA command along with the schema and object name you want to drop. For<br>instance, you want to drop the Java source for the Employees class. In this case, you would issue the<br>following command: </p>
<p>DROP JAVA SOURCE “Employees”;<br>How It Works<br>There may come a time when you need to drop a Java class or sources from the database. For instance, if<br>you no longer want to maintain or allow access to a particular Java class, it may make sense to drop it.<br>The DROP JAVA SOURCE command does this by passing the name of the class or source as demonstrated<br>within the solution to this recipe.<br> Note Be careful not to drop a Java class if other Java procedures or PL/SQL call specifications depend upon it.<br>Doing so will invalidate any dependent code, and you will receive an error if you try to execute. The data dictionary<br>provides views, such as DBA_DEPENDENCIES, that can be queried in order to find dependent objects. </p>
<p>Alternately, if you are on the database server, there is a dropjava utility that works in the same<br>fashion as the loadjava utility that was demonstrated in Recipe 15-3. To use the dropjava utility, issue<br>the dropjava command at the command line, and pass the database connect string using the –u flag<br>along with the name of the Java class or source you want to drop. The following example demonstrates<br>the command to drop the Employees Java class using the dropjava utility. </p>
<p>dropjava –u username/password@database_host:port:database_name Employees.class<br>The dropjava utility actually invokes the DROP JAVA SOURCE command. The downside to using the<br>utility is that you must be located on the database server to use it. I recommend using the DROP JAVA<br>SOURCE command from SQL<em>Plus if possible because it tends to make life easier if you are working within<br>SQL</em>Plus on a machine that is remote from the server.<br>15-14. Retrieving Database Metadata with Java<br>Problem<br>You are interested in retrieving some metadata regarding the database from within your Java stored<br>procedure. In this recipe, you want to list all the schemas within the database.<br>Solution<br>Create a Java stored procedure that utilizes the OracleDatabaseMetaData object to pull information from<br>the connection. In the following example, a Java stored procedure is created that utilizes the<br>CHAPTER 15  JAVA IN THE DATABASE<br>342<br>OracleDatabaseMetaData object to retrieve schema names from the Oracle connection. This Java method<br>will be added to the JavaUtils class. </p>
<p>public static void listDatabaseSchemas() {<br>        Connection conn = null;<br>        try {<br>            conn = DriverManager.getConnection("jdbc:default:connection:");<br>            OracleDatabaseMetaData meta = (OracleDatabaseMetaData) conn.getMetaData(); </p>
<pre><code>        if (meta == null) &#123; 
            System.out.println(&quot;Database metadata is unavailable&quot;); 
        &#125; else &#123; 
            ResultSet rs = meta.getSchemas(); 
            while (rs.next()) &#123; 
                System.out.println(rs.getString(1)); 
            &#125; 
        &#125; 
    &#125; catch (SQLException ex) &#123; 
        System.out.println(ex); 
    &#125;  
&#125; 
</code></pre>
<p>The output from the execution of this Java method will be a list of all database schemas.<br>How It Works<br>Sometimes it may be useful to use Java code for obtaining database metadata. One such instance might<br>arise when you are developing a Java class that needs to access database metadata. Your code will be<br>easier to maintain and read if you use Java to obtain the metadata rather than a PL/SQL procedure. The<br>OracleDatabaseMetaData object was created for that purpose. In the solution to this recipe, the metadata<br>object is used to retrieve a listing of all database schemas. However, several other methods can be called<br>on the OracleDatabaseMetaData object to obtain other useful database metadata. For instance,<br>information about the underlying database tables or columns can also be obtained using this resource.<br>For a complete listing of the different options available via the OracleDatabaseMetaData object, please<br>refer to the online documentation at<br><a target="_blank" rel="noopener" href="http://www.oracle.com/technology/docs/tech/java/sqlj_jdbc/doc_library/javadoc/oracle.jdbc.driver.Orac">www.oracle.com/technology/docs/tech/java/sqlj_jdbc/doc_library/javadoc/oracle.jdbc.driver.Orac</a><br>leDatabaseMetaData.html. </p>
<p>In the solution to this recipe, a Java Connection object is obtained using jdbc:default:connection.<br>The getMetaData method can be called on a Connection object and casted to an OracleDatabaseMetaData<br>object type. This solution demonstrates this technique and then uses the object to retrieve information<br>about the database.<br>  CHAPTER 15  JAVA IN THE DATABASE<br>343<br>15-15. Querying the Database to Help Resolve Java<br>Compilation Issues<br>Problem<br>You are attempting to compile Java source within the database, and you are receiving an unsuccessful<br>result. You need to determine the underlying issue to the problem that is preventing the Java source<br>from compiling correctly.<br>Solution<br>Query the USER_ERRORS table to determine the cause of the compilation issue. For example, suppose the<br>JavaUtils class source is loaded into the database with an incorrect variable name. This will cause a<br>compiler error that will be displayed within the USER_ERRORS table. The following is an excerpt from a<br>SQL*Plus session where an attempt has been made to compile the code: </p>
<p>SQL> ALTER JAVA SOURCE "JavaUtils" RESOLVE; </p>
<p>Warning: Java altered with compilation errors. </p>
<p>Since compilation errors have occurred, query the USER_ERRORS table to determine the exact cause of<br>the error so that it can be repaired. The following query demonstrates this technique: </p>
<p>SQL> COL TEXT FOR A25<br>SQL> SELECT NAME, TYPE, LINE, TEXT<br>  2  FROM USER_ERRORS<br>  3  WHERE TYPE LIKE 'JAVA%'; </p>
<p>NAME                   TYPE          LINE TEXT </p>
<hr>
<p>JavaUtils               JAVA CLASS         0 ORA-29535: source require<br>                               s recompilation </p>
<p>JavaUtils               JAVA SOURCE         0 JavaUtils:51: cannot find<br>                            symbol </p>
<p>JavaUtils               JAVA SOURCE         0 symbol  : variable me<br>JavaUtils               JAVA SOURCE         0 location: class JavaUtils<br>JavaUtils               JAVA SOURCE         0               ResultSet<br>                            rs = me.getSchemas(); </p>
<p>NAME                   TYPE          LINE TEXT </p>
<hr>
<p>JavaUtils               JAVA SOURCE         0<br>                                 ^ </p>
<p>JavaUtils               JAVA SOURCE         0 1 error </p>
<p>CHAPTER 15  JAVA IN THE DATABASE<br>344<br>7 rows selected.<br>How It Works<br>The USER_ERRORS table contains the most recent errors generated by PL/SQL or Java code. It is the most<br>useful way to determine the issues that are causing compilation errors when attempting to resolve Java<br>source errors. Unlike PL/SQL, you are unable to issue the SHOW ERRORS command to display the most<br>recent compiler errors. The Java compiler, as well as the PL/SQL compiler, writes output to the<br>USER_ERRORS table, making it a beneficial tool when writing Java code for the database.<br>C H A P T E R  16 </p>
<p>   </p>
<p>345<br>Accessing PL/SQL from JDBC,<br>HTTP, Groovy, and Jython<br>Java programs run on a virtual machine known as the Java virtual machine (JVM). A version of the JVM is<br>available for most operating systems and is deployed on millions of servers, desktops, phones, and even<br>Blu-ray players throughout the world. Because of the widespread availability of the JVM, Java is<br>considered a portable language: you can essentially write Java code once and run it just about anywhere,<br>whether it’s on a Linux box, a Mac, Android phone, or a Windows desktop.<br>The JVM has evolved over time, and Java is no longer the only language that can run on it. There<br>have been many languages implemented in Java that provide different features for those who enjoy<br>developing applications for the JVM. Each of these languages has its own syntax and constructs, and<br>many of them can be viable alternatives for developing scripts, desktop applications, or enterprise-level<br>web applications. As such, this chapter not only covers the ins and outs of accessing PL/SQL from Java<br>application code but also includes recipes for working with two popular dynamic languages that run on<br>the JVM: Jython and Groovy.<br>This chapter is not intended to be an overall instruction set for using Java or any other language on<br>the JVM. It is meant for the purpose of demonstrating how to access PL/SQL code from within these<br>languages. The Java online community is outstanding, and a plethora of resources are available on the<br>Web for learning about Java or other languages on the JVM. For more detailed information, please<br>consult those resources, because this chapter will only provide solutions targeting PL/SQL integration.<br>16-1. Accessing a PL/SQL Stored Procedure via JDBC<br>Problem<br>You are writing a Java application that uses JDBC to access data, but you also want to call some PL/SQL<br>stored procedures from within your Java application.<br>Solution<br>Use the JDBC API to connect to the database, and then execute prepareCall(), passing a string to it that<br>consists of a PL/SQL code block that calls the stored procedure. For example, consider a stand-alone<br>Java class that contains a method named increaseWage(). This method uses JDBC to obtain a database<br>connection, create a CallableStatement, and then invoke the PL/SQL stored procedure that passes in the<br>required variables. </p>
<p>import java.sql.<em>;<br>import oracle.jdbc.</em>;<br>CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>346 </p>
<p>public class EmployeeFacade { </p>
<p> public void increaseWage()<br> throws SQLException {<br>  int ret_code;<br>  Connection conn = null;<br>  try {<br>    //Load Oracle driver<br>    DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());<br>    //Obtain a connection </p>
<pre><code>conn = DriverManager.getConnection(&quot;jdbc:oracle:thin:@hostname:port_number:mydb&quot;, 
                                                                          &quot;user&quot;, 
</code></pre>
<p>"password");<br>    int emp_id = 199;<br>    double increase_pct = .02;<br>    int upper_bound = 10000;<br>    CallableStatement pstmt =<br>    conn.prepareCall("begin increase_wage(?,?,?); end;");<br>    pstmt.setInt(1, emp_id);<br>    pstmt.setDouble(2, increase_pct);<br>    pstmt.setInt(3, upper_bound);<br>    pstmt.executeUpdate(); </p>
<pre><code>pstmt.close(); 
conn.commit(); 
conn.close(); 
System.out.println(&quot;Increase successful&quot;); 
</code></pre>
<p>  } catch (SQLException e) {ret_code = e.getErrorCode();<br>    System.err.println(ret_code + e.getMessage()); conn.close();}<br>  } </p>
<p>  public static void main(String[] args){<br>      EmployeeFacade facade = new EmployeeFacade();<br>      try {<br>          facade.increaseWage();<br>      } catch (SQLException e){<br>          System.err.println("A database exception has occurred.");<br>      }<br>  }<br>}<br>Running this code within an integrated development environment such as NetBeans would result in<br>the following output: </p>
<p>run:<br>Increase successful<br>BUILD SUCCESSFUL (total time: 4 seconds)<br>The EmployeeFacade class contains a main() method that is used to initiate the execution of the<br>increaseWage() method. The increaseWage() method initializes three variables that are passed to the<br>increase_wage PL/SQL stored procedure using a CallableStatement.<br> CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>347<br>How It Works<br>It is possible to invoke a PL/SQL stored procedure from a JDBC call just as if you were issuing a call from<br>PL/SQL. You can do so by passing a PL/SQL code block that contains the procedure call as a string to the<br>JDBC connection. In the solution to the example we’ve chosen for this recipe, a Java class named<br>EmployeeFacade contains a method that makes a JDBC call to invoke a stored procedure. If you are<br>unfamiliar with Java and database connectivity, you can see that using JDBC is very methodical. There<br>are several steps that need to be taken in order to obtain a connection to the database, followed by the<br>steps to perform the database transaction and lastly to commit the changes and close all of the JDBC<br>constructs.<br>Any Java work that is done using the JDBC API must include an exception handler for the<br>java.sql.SQLException. As the increaseWage() method demonstrates, the SQLException is handled using<br>a Java try-catch block. Prior to the try-catch block, a couple of variables are created that the rest of the<br>method will use. One of the variables is the java.sql.Connection, which is to be used to make a<br>connection to the database, execute the call, and then finally close the connection. In the next couple of<br>lines, a try-catch block is started, and a connection is obtained to the Oracle Database using the<br>DriverManager class. The getConnection() method accepts a JDBC URL pertaining to a database as well<br>as a user name and password.<br> Note It is important to maintain a close watch on JDBC connections. They can be costly for performance, and<br>only a limited number of connections is usually available for use. For this reason, a connection should always be<br>obtained, used, and then closed.<br>If a connection is successfully made to the database, then a CallableStatement is created that<br>performs all the work against the database. If you wanted to issue a query, then you would use a<br>PreparedStatement instead because CallableStatements are most useful for making PL/SQL calls. A<br>string containing a PL/SQL code block is used to invoke the call to the PL/SQL stored procedure. The call<br>is a bit different from native PL/SQL because it includes Java bind variables that represent the<br>parameters that need to be passed into the procedure. A bind variable is represented by a question mark<br>(?) character, and subsequent setter methods will be used to set values for each bind variable. After the<br>CallableStatement’s prepareCall() method is invoked, variables are passed to the procedure using a<br>series of setXXX() methods on the CallableStatement. The set methods correlate with the type of data<br>that is being passed to the stored procedure, and they provide a positional parameter that maps the<br>variable to the bind variable position in the call. For instance, the first setInt(1, emp_id) method<br>contains an integer variable, emp_id, and it will be passed to the bind variable in the first position within<br>the call.<br>After all the variables have been set, the executeUpdate() method is called in order to execute the<br>call to the procedure. If successful, program execution will continue. However, if unsuccessful for some<br>reason, then a java.sql.SQLException will be thrown that will cause the execution of the Java program to<br>be passed to the catch block. Finally, if the transaction was a success, then the connection commits the<br>transaction, and the CallableStatement is closed, followed by the closing of the connection. You will<br>notice that the throws SQLException clause has been placed within the method declaration. When any<br>Java method contains a throws clause within the declaration, then you must code an exception handler<br>for any Java code that calls the method. In this solution, the throws clause has been put into place to<br>handle any exceptions that may be raised when closing the connection within the exception-handling<br>CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>348<br>catch block. For more information on Java exception handling, please see the online documentation<br>available at <a target="_blank" rel="noopener" href="http://download.oracle.com/javase/tutorial/essential/exceptions/handling.html">http://download.oracle.com/javase/tutorial/essential/exceptions/handling.html</a>.<br>The JDBC API can be used to call PL/SQL stored procedures by passing a PL/SQL code block in the<br>form of a Java String to a CallableStatement object. The majority of the code using JDBC is spent<br>creating and closing the database connections as well as the CallableStatements. If you are unfamiliar<br>with JDBC, then you can learn more about it at <a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/overview-">www.oracle.com/technetwork/java/overview-</a><br>141217.html. It can be used for creating small Java programs or enterprise-level Java applications. The<br>JDBC API has been around since the early days of Java, so it is quite mature and allows you to access the<br>database and your PL/SQL programs directly.<br>16-2. Accessing a PL/SQL Stored Function from JDBC<br>Problem<br>You want to utilize a PL/SQL function from a Java application that uses the JDBC API to connect to an<br>Oracle Database and returns a value to the Java application.<br>Solution<br>Use the JDBC API and a CallableStatement to invoke the PL/SQL function by passing a Java String<br>containing the function call to the CallableStatement. The following example demonstrates a Java<br>method that accepts a parameter of type double and then makes a JDBC call to the PL/SQL function<br>calc_quarter_hour using the parameter. It is assumed that this Java method is to be added into the class<br>that was created in Recipe 16-1. </p>
<p>public void calcQuarterHour(double hours)<br>            throws SQLException {<br>        float returnValue;<br>        int ret_code;<br>        Connection conn = null;<br>        try {<br>            //Load Oracle driver<br>            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());<br>            //Obtain a connection </p>
<pre><code>        conn = DriverManager.getConnection(&quot;jdbc:oracle:thin:@hostname:1521:mydb&quot;, 
                &quot;user&quot;, &quot;password&quot;); 

        CallableStatement pstmt = 
                conn.prepareCall(&quot;&#123;? = call calc_quarter_hour(?)&#125;&quot;); 
        
        pstmt.registerOutParameter(1, java.sql.Types.FLOAT); 
        pstmt.setDouble(2, hours); 
        pstmt.execute(); 
        returnValue = pstmt.getFloat(1); 
        pstmt.close(); 
        conn.commit(); 
        conn.close(); 
        System.out.println(&quot;The calculated value: &quot; + returnValue); 
    &#125; catch (SQLException e) &#123; 
</code></pre>
<p> CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>349<br>            ret_code = e.getErrorCode();<br>            System.err.println(ret_code + e.getMessage());<br>            conn.close();<br>        }<br>    }<br>Update the main method from the class that was created in Recipe 16-1 to the following code in<br>order to make a call to the new calcQuarterHour method. </p>
<p>public static void main(String[] args) {<br>        EmployeeFacade facade = new EmployeeFacade();<br>        try {<br>            facade.calcQuarterHour(7.667);<br>        } catch (SQLException e) {<br>            System.err.println("A database exception has occurred.");<br>        }<br>    } </p>
<p>Running this code within an integrated development environment such as NetBeans would result in<br>the following output: </p>
<p>run:<br>The calculated value: 7.75<br>BUILD SUCCESSFUL (total time: 1 second) </p>
<p>Values can be passed as parameters from Java to PL/SQL, and in turn, PL/SQL can pass return<br>values back to Java. This helps form a seamless integration between the two languages.<br>How It Works<br>Calling a PL/SQL function from a JDBC application is not very much different from using native PL/SQL.<br>The biggest difference is that you need to use the JDBC API to make the database call and to set and<br>retrieve values from the database. The solution to this recipe contains a Java method that accepts a<br>double value representing a number of hours. The method connects to the Oracle Database using the<br>JDBC, calls the PL/SQL function using a CallableStatement, and then returns the results.<br>To make the connection, the database driver is first registered using the<br>DriverManager.registerDriver() method and passing the appropriate driver for Oracle Database. Next,<br>a connection is obtained using the DriverManager.getConnection() method by passing the URL for the<br>Oracle Database that will be used, along with the appropriate user name and password. In Recipe 16-1,<br>obtaining JDBC connections is discussed in more detail. If you haven’t yet read Recipe 16-1 and are<br>unfamiliar with JDBC, we recommend you read it for more information on this important aspect of<br>using the JDBC API.<br>Once a connection has been obtained, a CallableStatement is created by calling the<br>java.sql.Connection prepareCall() method and passing a Java String that contains the call to the<br>PL/SQL function. The function call is in the following format: </p>
<p>{? = call calc_quarter_hour(?)} </p>
<p>The String is surrounded by curly braces ({}), and the call to the PL/SQL function is preceded by<br>the ? = characters. The question mark (?) character represents a bind variable in a Java prepared<br>statement.  Bind variables are used to represent the returning value as well as the parameter value that<br>CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>350<br>will be passed into the function. The first ? character represents the returning value, whereas the ?<br>character within the parentheses correlates to the parameter being passed to the function. The PL/SQL<br>function is invoked using the call keyword followed by the function name.<br>The next line of code registers the return value using the CallableStatement<br>registerOutParameter() method. This method accepts the bind variable position as its first argument<br>and accepts the datatype of the value as the second argument. In this example, the datatype is<br>java.sql.Types.FLOAT, which correlates to a PL/SQL float type. Many different types are available within<br>java.sql.Types, and if you are using a Java integrated development environment (IDE) that contains<br>code completion, then you should see a list of all available types after you type the trailing dot when<br>declaring java.sql.Type. Next, the parameter that will be passed into the PL/SQL function is set by<br>calling the setDouble() method and passing the bind variable position along with the value. Lastly, the<br>CallableStatement is executed by invoking the execute() method.<br>If the function call is successful, then the return value of the function can be obtained by calling the<br>getFloat() method on the CallableStatement and passing the bind variable position. If you were calling<br>a PL/SQL function that had a different return type, then you would use the getter method that correlates<br>to the return type. This method will return the value of the call, so it should be assigned to a Java<br>variable. In the solution, returnValue is the variable that is used to hold the value returned from the<br>function call. Finally, the CallableStatement is closed, and the transaction is committed by calling the<br>commit() method on the java.sql.Connection.<br>The entire method is enclosed within a Java exception-handling try-catch block. Code that is<br>contained within the try block may or may not throw an exception. If an exception is thrown, then it can<br>be caught by a subsequent catch block. For more information on Java exception handling, please see the<br>documentation at <a target="_blank" rel="noopener" href="http://download.oracle.com/javase/tutorial/essential/exceptions/handling.html">http://download.oracle.com/javase/tutorial/essential/exceptions/handling.html</a>.<br>Interacting with PL/SQL functions from within a Java application can be quite powerful. You will<br>gain the most benefit if the function that you are calling is working with the data. Any application that is<br>not stored in the database will incur at least a minor performance hit when working with the database<br>because of connections and round-trips to and from the database server. If you have a PL/SQL function<br>that works with the database, then it can be more efficient to call the PL/SQL function from your Java<br>application rather than reproducing that function in Java code.<br>16-3.  Accessing PL/SQL Web Procedures with HTTP<br>Problem<br>You are developing a Java web application that uses an Oracle Database. You have already created a<br>PL/SQL web application that displays some particular data from your database that is generated from an<br>input identifier. You want to use the PL/SQL web application to display that data by passing the<br>necessary input from the Java web application.<br>Solution<br>Write your PL/SQL web program to accept parameter values within a URL. Pass the values from your<br>Java web application to the PL/SQL application by embedding them within the URL that calls it. When<br>the URL is clicked, then it will redirect control to the PL/SQL application, passing the parameters that<br>are required to display the correct data. Suppose, for example, that you are writing a Java web<br>application that generates a list of employees on a web page. Suppose further that you have already<br>written PL/SQL web application that, given an employee_id, displays employee record details in a<br>browser. You want to combine that functionality with your Java program so that when you click one of<br>the employees in the list generated by the Java web program, it passes the selected employee’s ID to the<br> CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>351<br>PL/SQL web program. In turn, the PL/SQL program will display the detail for that ticket. In the following<br>example, the EMP_RPT package that was introduced in Recipe 14-4 is accessed via a Java Server Faces<br>page.<br> Note JSF is the Java standard for creation of server-side user interfaces. To learn more about this technology,<br>please see the online documentation at <a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javaee/javaserverfaces-">www.oracle.com/technetwork/java/javaee/javaserverfaces-</a><br>139869.html. </p>
<?xml version='1.0' encoding='UTF-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:ui="http://java.sun.com/jsf/facelets" 
      xmlns:f="http://java.sun.com/jsf/core" 
      xmlns:h="http://java.sun.com/jsf/html"> 
 
<pre><code>&lt;body&gt; 

    &lt;ui:composition template=&quot;layout/my_layout.xhtml&quot;&gt; 

        &lt;ui:define name=&quot;body&quot;&gt; 
            &lt;f:view id=&quot;employeeView&quot;&gt; 
                &lt;h:form id=&quot;employeeResults&quot;&gt; 
                    &lt;center&gt; 

                        &lt;br/&gt; 
                        &lt;h:messages id=&quot;messages&quot; 
                                    errorClass=&quot;error&quot; 
                                    infoClass=&quot;info&quot; /&gt; 
                        &lt;br/&gt; 
                        &lt;span class=&quot;sub_head_sub&quot;&gt; 
                            Employee Listing 
                        &lt;/span&gt; 
                        &lt;br/&gt; 
                        &lt;br/&gt; 

                        &lt;h:dataTable id=&quot;employeeList&quot; 
                                     rows=&quot;20&quot; 
                                     value=&quot;#&#123;employeeList&#125;&quot; 
                                     var=&quot;emp&quot;&gt; 
                            &lt;f:facet name=&quot;header&quot;&gt; 
                                &lt;h:column &gt; 
                                    &lt;h:outputText value=&quot;First Name&quot;/&gt; 
                                &lt;/h:column&gt; 
                                &lt;h:column &gt; 
                                    &lt;h:outputText value=&quot;Last Name&quot;/&gt; 
</code></pre>
<p>CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>352<br>                                    </h:column><br>                                    <h:column ><br>                                        <h:outputText value="Email"/><br>                                    </h:column><br>                                </f:facet> </p>
<pre><code>                            &lt;h:column id=&quot;firstNameCol&quot;&gt; 
                                &lt;h:outputText id=&quot;firstName&quot; value=&quot;#&#123;emp.firstName&#125;&quot;/&gt; 
                            &lt;/h:column&gt; 
                            &lt;h:column id=&quot;lastNameCol&quot;&gt; 
                                &lt;h:outputText id=&quot;lastName&quot; value=&quot;#&#123;emp.lastName&#125;&quot;/&gt; 
                            &lt;/h:column&gt; 

                            &lt;h:column id=&quot;emailCol&quot;&gt; 
                                &lt;h:outputLink value=&quot;http://my-oracle-application-
</code></pre>
<p>server:7778/DAD/emp_rpt.rpt"<br>                                            target="_blank"><br>                                        <f:param name="emp_id" value="#{emp.employeeId}"/><br>                                        <h:outputText id="email" value="#{emp.email}"/><br>                                    </h:outputLink><br>                                </h:column> </p>
<pre><code>                        &lt;/h:dataTable&gt; 



                    &lt;/center&gt; 
                &lt;/h:form&gt; 

            &lt;/f:view&gt; 

        &lt;/ui:define&gt; 

    &lt;/ui:composition&gt; 

&lt;/body&gt; 
</code></pre>
</html> 
 
<p>The JSF tags in this example would generate a web page that looks similar to Figure 16-1. However,<br>it is important to note that JSF contains template functionality, so the look and feel of the user interface<br>can be changed significantly if a different template were applied.<br> CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>353 </p>
<p>Figure 16-1.  Employee listing JSF web page </p>
<p>For the sake of brevity, the Java code will not be displayed, because it is not essential for this<br>solution. However, if you want to learn more about writing Java web applications utilizing the Java<br>Server Faces web framework, please see the online documentation available at<br><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html">www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html</a>.<br>When you look at the JSF page output on your monitor, you’ll see that the EMAIL column values are<br>blue. This signifies that they are links that will take you to another page when selected with the mouse.<br>In this case, the link will redirect users to a PL/SQL application that accepts the employee ID as input<br>and in turn displays a result. Figure 16-2 shows the output from the PL/SQL web application when the e-<br>mail user name SKING is selected from the JSF page. </p>
<p>CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>354 </p>
<p>Figure 16-2.  PL/SQL web application output </p>
<p>How It Works<br>Developing Java web applications and PL/SQL web applications can be quite different. However,<br>accessing one from the other can be quite easy and can create powerful solutions. In this recipe, a<br>mashup consisting of a standard web URL passes data from a Java application to a PL/SQL stored<br>procedure, and then the PL/SQL stored procedure displays content via a web page.<br>The PL/SQL stored procedure in this recipe utilizes the built-in UTL_HTTP package to display content in<br>HTML format via the Web. The procedure accepts one argument, an EMPLOYEE_ID. The given EMPLOYEE_ID<br>field is used to query the database, and the content that is retrieved is displayed. The procedure is<br>accessible from the Web because a Data Access Descriptor (DAD) has been created on the web server,<br>which allows access to a particular schema’s web-accessible content. Using the DAD, a URL<br>incorporating the host name, the DAD, and the procedure to be used can access the stored procedure.<br>Please see Recipe 14-1 to learn more about creating DADs. For more details regarding the creation of<br>web content using PL/SQL, please refer to Chapter 14.<br>The Java application Extensible Hypertext Markup Language (XHTML) page that is displayed in the<br>solution to this recipe creates a listing of employee names by querying the database using EJB<br>technology. Enterprise Java Beans (EJB) is part of the Java Enterprise Edition stack that is used for object<br>relational mapping of Java code and database entities. For more information regarding EJB technology,<br>please refer to the documentation at <a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/index-jsp-140203.html">www.oracle.com/technetwork/java/index-jsp-140203.html</a>.<br> The important code for this particular recipe is the web page code that resides within the Java<br>Server Faces XHTML page. The generated list of employee names is a list of URLs that contain the host<br>name of the Oracle Application Server, the DAD for the schema containing the PL/SQL you want to<br>access, and the name of the PL/SQL stored procedure, which is EMP_RPT.RPT in this case. The URL also<br>contains an embedded parameter that is passed to the stored procedure upon invocation. The following<br>code shows an example of a URL that is generated by the Java application: </p>
<a href="http://my-web-server:port/hr/EMP_RPT.RPT?emp_id=200"> 
The code that generates this URL is written in Java Server Faces using Facelets markup, as shown 
here: 
 
<p><h:outputLink value="<a href="http://my-oracle-application-server:port/DAD/emp_rpt.rpt&quot;">http://my-oracle-application-server:port/DAD/emp_rpt.rpt&quot;</a><br>                                            target="_blank"><br> CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>355<br>               <f:param name="emp_id" value="#{emp.employeeId}"/><br>               <h:outputText id="email" value="#{emp.email}"/><br></h:outputLink> </p>
<p>The &emp_id=200 portion of the URL is the parameter name and value that is passed to the<br>EMP_RPT.RPT procedure when called. In the case of the JSF markup, #{emp.employeeId} will pass this<br>value as a parameter to the URL. In turn, the EMP_RPT.RPT procedure queries the EMPLOYEES table for the<br>given EMPLOYEE_ID and displays the record data. In a sense, the Java application performs a redirect to<br>the PL/SQL stored procedure, as illustrated by Figure 16-3.  </p>
<p>Figure 16-3. JSF to PL/SQL web redirect<br> Note Facelets is an open source web framework that is the default view handler technology for JSF.<br>Any two languages that can be used to develop web applications can be used to create mashups in a<br>similar fashion. A regular HTML page can include links to any PL/SQL stored procedure that has been<br>deployed and made available using a DAD. This is a simple technique that can be used to allow<br>applications to use data that resides in a remote database. </p>
<p>16-4. Accessing PL/SQL from Jython<br>Problem<br>You are working with a Jython program and want to call some PL/SQL stored procedures or functions<br>from it.<br>Solution #1<br>Use Jython’s zxJDBC API to obtain a connection to the Oracle Database, and then call the PL/SQL stored<br>procedure passing parameters as required.  The following code is an example of a Jython script that<br>performs these tasks: </p>
<p>CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>356<br>from <strong>future</strong> import with_statement<br>from com.ziclix.python.sql import zxJDBC </p>
<h1 id="Set-up-connection-variables"><a href="#Set-up-connection-variables" class="headerlink" title="Set up connection variables"></a>Set up connection variables</h1><p>jdbc_url = "jdbc:oracle:thin:@host:1521:dbname"<br>username = "user"<br>password = "password"<br>driver = "oracle.jdbc.driver.OracleDriver" </p>
<h1 id="obtain-a-connection-using-the-with-statment"><a href="#obtain-a-connection-using-the-with-statment" class="headerlink" title="obtain a connection using the with-statment"></a>obtain a connection using the with-statment</h1><p>with zxJDBC.connect(jdbc_url, username, password, driver) as conn:<br>    with conn:<br>        with conn.cursor() as c:<br>            c.callproc('increase_wage',[199,.03,10000])<br>            print ‘Procedure call complete’<br>            conn.commit()<br>This example does not display any real output; it only calls the INCREASE_WAGE procedure and<br>performs a commit. After the procedure is called, a line of text is printed to alert the user that the<br>procedure call is complete.<br>Solution #2<br>Use a Python web framework, such as Django, along with Jython to create a web application for<br>deployment to a Java application server. Use the selected web framework’s built-in syntax to invoke the<br>stored procedure or function call.  </p>
<p>DJANGO<br>Django is a popular web framework that is used with the Python programming language. Django has<br>worked with Jython since the release of Jython 2.5. Django takes a model-view-controller approach to<br>web design, whereas all code is separated from web pages. The web pages use templating that makes it<br>easy to create dynamic and expressive web pages. Django uses an object-oriented approach to working<br>with the database that is known as object relational mapping. For more information on the Django<br>framework, please visit the Django web site at <a target="_blank" rel="noopener" href="http://www.djangoproject.com/">www.djangoproject.com/</a> and the Django-Jython project<br>that is located at <a target="_blank" rel="noopener" href="http://code.google.com/p/django-jython/">http://code.google.com/p/django-jython/</a>. </p>
<p>For example, here’s how you might use the Django web framework to create a call to the PL/SQL<br>stored procedure CALC_QUARTER_HOUR that was demonstrated in Recipe 4-1. The following code<br>demonstrates an excerpt taken from a Django view to make a call to an Oracle PL/SQL function: </p>
<h1 id="Views-py"><a href="#Views-py" class="headerlink" title="Views.py"></a>Views.py</h1><p>from django.db import connection </p>
<p>def calc_hours(self, hours_in):<br> CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>357<br>        cursor = connection.cursor()<br>        ret = cursor.callproc("CALC_QUARTER_HOUR", (hours_in))# calls PROCEDURE OR FUNCTION<br>        cursor.close()<br>        return ret<br>This view code only demonstrates a function written in Python or Jython that will perform the call to<br>the database and return a result.<br>How It Works<br>The Jython language is an incarnation of the Python language that has been implemented on the JVM.<br>Using Jython provides a developer with all the corresponding syntax and language constructs that the<br>Python language has to offer and allows them to be used to write applications running on the JVM.<br>Furthermore, Jython applications have access to all the underlying libraries that the Java platform has to<br>offer, which is a tremendous asset to any developer. Jython is one of the first additional languages<br>developed to run on the JVM. It has matured over the years, although it remains a bit behind its sister<br>language Python in release number. Jython can be used for developing scripts, desktop applications, and<br>enterprise-level web applications.<br>Using the zxJDBC API to Solve the Problem<br>In the first solution to this recipe, Jython’s zxJDBC API is used to perform tasks against an Oracle<br>Database. zxJDBC is an extension of the Java JDBC API that allows Jython developers to program JDBC<br>calls in a Python-like syntax. Working with zxJDBC can be very efficient. It is similar to working with<br>regular Java JDBC code, except the syntax makes development a bit easier since there are fewer lines of<br>code to maintain. zxJDBC contains the function callproc() that can be used to make calls to PL/SQL<br>procedures or functions. Once you have obtained a database connection, you allocate a cursor from the<br>connection and invoke that cursor's callproc() function. The callproc() function accepts one<br>argument, which is the name of the PL/SQL procedure to be called. The called procedure or function will<br>return the results to the caller in a seamless manner. </p>
<p>The zxJDBC API is useful for writing stand-alone Jython applications or scripts. Many developers<br>and database administrators use Jython to script their nightly jobs, allowing zxJDBC to invoke PL/SQL<br>functions and stored procedures. This is one alternative to using Oracle Scheduler for executing<br>database tasks, and it can allow for much more flexibility because all the libraries available for use on the<br>JVM are at your disposal.<br>Using Django to Solve the Problem<br>Although zxJDBC is a great way to work with the database, there are other techniques that can be used<br>for creation of web content that accesses PL/SQL. Many Jython users create web applications using<br>different Python web frameworks. One such Python web framework is Django, and it can be used along<br>with Jython to productively create web applications that run on the Java platform. The Django<br>framework uses an object-oriented approach to work with the database. In other terms, Django provides<br>an object-relational mapping solution that allows developers to work with Python objects representing<br>database tables rather than working directly with SQL. </p>
<p>Django uses a model.py file to map a database table to a Python object. A views.py file is used to<br>implement separate views for the web site, and a urls.py file is used to contain the valid URL mappings<br>CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>358<br>for a Django application. In the solution to this recipe, a Python function that would go into the views.py<br>file is displayed. The purpose of this function is to make a connection to the database and invoke a<br>PL/SQL function call. The Django framework handles database connections for you by declaring some<br>parameters for the database connection within a settings.py file for the project. As you can see from the<br>example, obtaining a connection is trivial because you merely import it from the django.db package. The<br>code is similar to using zxJDBC for calling a PL/SQL stored procedure or function. The cursor’s<br>callProc() function is used to make the function call, and the syntax for performing that task is as<br>follows: </p>
<p>cursor.callProc(function_or_procedure_name,(parameter_one, parameter_two, etc)) </p>
<p>The function or procedure name should be a string value, and the parameters can passed as a tuple<br>or listed one by one, separated by commas. If calling a PL/SQL function, the callProc() function should<br>be assigned to a variable because there will be a return result. Lastly, the cursor should be closed in order<br>to release resources. Again, when using the Django framework connections to the database will be<br>handled for you, so there is no need to worry about closing connections after a database call has been<br>made. </p>
<p>For more information on using the Django web framework, please visit the project home page at<br><a target="_blank" rel="noopener" href="http://www.djangoproject.com/">www.djangoproject.com</a>. To use the Django web framework with Jython, you will also need to include the<br>django-jython site package at <a target="_blank" rel="noopener" href="http://code.google.com/p/django-jython/">http://code.google.com/p/django-jython/</a>.<br>16-5. Accessing PL/SQL from Groovy<br>Problem<br>You are writing a Groovy program and want to call some PL/SQL stored procedures or functions from it.<br>Solution<br>Use GroovySQL to establish a database connection, and make the call to the PL/SQL stored program. For<br>example, here’s how you would use of GroovySQL to connect to an Oracle Database and call a PL/SQL<br>function: </p>
<p>import groovy.sql.Sql<br>import oracle.jdbc.driver.OracleTypes </p>
<p>Sql sql = Sql.newInstance("jdbc:oracle:thin:@hostname:1521:dbname", </p>
<p>"username","password","oracle.jdbc.driver.OracleDriver")<br>dept_id = 50 </p>
<p>sql.call('{? = call calc_quarter_hour(?)}', [Sql.DOUBLE, 6.35]) { qtr_hour-><br>  println qtr_hour<br>}<br>Short and to the point, the Groovy script in this example connects to an Oracle Database, executes a<br>PL/SQL function call, returns a value, and prints the result.<br> CHAPTER 16  ACCESSING PL/SQL FROM JDBC, HTTP, GROOVY, AND JYTHON<br>359<br>How It Works<br>Groovy is a unique JVM language that is useful for developing productive and efficient applications. It<br>can be used for developing a wide variety of applications, from scripts to enterprise-level web<br>applications. The syntax of the Groovy language is unlike that of other languages on the JVM because the<br>Groovy compiler allows you to write Java code and it will be deemed as valid Groovy. However, Groovy<br>also has its own syntax that can be combined with Java syntax if you want to do so. Its flexibility allows<br>for beginners to pick up the language as they go and allows advanced Groovy coders to write code in<br>Groovy syntax that is magnitudes smaller than the amount of lines taken to write the same code in Java. </p>
<p>In the solution to this example, the Groovy SQL API is used to connect to an Oracle Database and<br>issue a PL/SQL function call. The top of the script contains import statements. The imports in Groovy<br>work in the same manner as Java imports. The groovy.sql.Sql import pulls all the Groovy SQL<br>functionality into the script. The second import is used to pull in the Oracle driver.  </p>
<p>The database connection is made by using the Sql.newInstance method and passing the JDBC URL<br>for the database along with the user name, password, and database driver class. The actual PL/SQL<br>function call occurs with the Sql instance’s call() method, and the syntax is very similar to that of Java’s<br>JDBC API, whereas you pass a string that is enclosed in curly braces in the following format. The<br>following example demonstrates a call to the CALC_QUARTER_HOUR PL/SQL function that was written in<br>Recipe 4-1: </p>
<p>{? = call calc_quarter_hour(?)} </p>
<p>The question mark characters (?) correlate to bind variables. The second argument that is passed to<br>the call() method is a list of parameters including the return type and value of the parameter that will<br>be passed to the PL/SQL function. In this case, the PL/SQL function’s return type is<br>groovy.sql.Sql.DOUBLE, and the value that will be passed to the function is 6.35. The code that follows<br>the call is some Groovy syntactic sugar and is otherwise known as a closure. By specifying curly braces<br>({}) after the function call, you are telling Groovy to pass any return values to the variable contained<br>within the braces. In this case, qtr_hour will contain the result from the PL/SQL function call, and it<br>prints the result upon return via use of the closure -> notation and then specifying a print statement<br>afterward. </p>
<p>If you have never seen Groovy code before, this syntax will seem a bit awkward. However, once you<br>become used to the syntax, it will become a powerful asset to your tool box. It is easy to see that taking<br>standard Java JDBC implementations for accessing PL/SQL and translating them into a different<br>language will allow for the same PL/SQL connectivity across most languages that run on the JVM. For<br>more information regarding the use of Groovy, Groovy SQL, or closures in Groovy, please see the online<br>documentation at <a target="_blank" rel="noopener" href="http://groovy.codehaus.org/Beginners+Tutorial">http://groovy.codehaus.org/Beginners+Tutorial</a>. </p>
<p>C H A P T E R  17 </p>
<p>   </p>
<p>361<br>Unit Testing With utPLSQL<br>Testing is a necessary evil of the application development process. Sadly, testing is oftentimes<br>overlooked or bypassed when time is short. Distribution of untested or undertested code can lead to<br>code that is riddled with bugs and to disappointed users. Unit testing with a well-constructed framework<br>can help to alleviate some of the time that it takes to conform to a well-tested development process.<br>There are a few different options available to you for testing your PL/SQL code. SQL Developer<br>provides some good debugging options that you can read about in Recipe 12-12. You can also use<br>DBMS_OUTPUT statements within your code to display the results of variables as your code executes. This is<br>a good technique for helping to pinpoint issues in your code and one you can read about in Recipe 17-1.<br>There are also unit-testing frameworks available that will help you to write unit tests for your PL/SQL<br>code objects. Although not covered in this book, the PLUTO (PL/SQL Unit Testing for Oracle) framework<br>(<a target="_blank" rel="noopener" href="http://code.google.com/p/pluto-test-framework/">http://code.google.com/p/pluto-test-framework/</a>) is one such framework. Another is the utPLSQL unit-<br>testing framework, and this chapter will focus on utPLSQL since it is more widely adopted than the<br>others.<br>The utPLSQL unit-testing framework can alleviate some of the pain of unit testing. The framework is<br>easy to use and performs nicely for testing code under every circumstance that can be imagined. There<br>are also many options in utPLSQL that can be used to enhance your unit testing process. This chapter<br>includes recipes that show how to use the framework for testing PL/SQL objects, how to create test<br>suites, and how to automate your unit tests. In the end, you will learn to make the unit testing process a<br>functional part of your development process. As a result of using unit testing, your applications will be<br>successful, and you will spend much less time maintaining the code base.<br>17-1. Testing Stored PL/SQL Code Without Unit Tests<br>Problem<br>You want to ensure that a block of PL/SQL code is working properly, but don’t want to take the time to<br>write a unit test.<br>Solution<br> Wrap the code in DBMS_OUTPUT statements that display or print the results of intermediate and final<br>computations and the results of complex conditional steps and branches. This will enable you to see the<br>path that the code is taking when the function is called with specified parameters. The following<br>example demonstrates this tactic for placing comments into strategic locations within a PL/SQL code<br>block in order to help determine if code is functioning as expected. For example, suppose you wish to<br>quickly test the function we introduced in the example for Recipe 4-1. Here’s how you’d modify it to<br>quickly test the correctness of its results.  </p>
<p>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>362<br>CREATE OR REPLACE<br>FUNCTION CALC_QUARTER_HOUR(HOURS IN NUMBER) RETURN NUMBER AS<br>  CALCULATED_HOURS NUMBER := 0;<br>BEGIN </p>
<p>   -- if HOURS is greater than one, then calculate the decimal portion<br>  -- based upon quarterly hours<br> IF HOURS > 1 THEN<br>  -- calculate the modulus of the HOURS variable and compare it to<br>  DBMS_OUTPUT.Put_LINE('The value passed in was greater than one hour...');<br>  -- fractional values<br>    IF MOD(HOURS, 1) <=.125 THEN<br>       DBMS_OUTPUT.Put_LINE('The decimal portion < .125');<br>       CALCULATED_HOURS := substr(to_char(HOURS),0,1);<br>    ELSIF MOD(HOURS, 1) > .125 AND MOD(HOURS,1) <= .375 THEN<br>       DBMS_OUTPUT.Put_LINE('The decimal portion <= .375');<br>       CALCULATED_HOURS := substr(to_char(HOURS),0,1) + MOD(.25,1);<br>    ELSIF MOD(HOURS, 1) > .375 AND MOD(HOURS,1) <= .625 THEN<br>       DBMS_OUTPUT.Put_LINE('The decimal portion <= .625');<br>       CALCULATED_HOURS := substr(to_char(HOURS),0,1) + MOD(.50,1);<br>    ELSIF MOD(HOURS, 1) > .63 AND MOD(HOURS,1) <= .825 THEN<br>       DBMS_OUTPUT.Put_LINE('The decimal portion <= .825');<br>       CALCULATED_HOURS := SUBSTR(TO_CHAR(HOURS),0,1) + MOD(.75,1);<br>    ELSIF MOD(HOURS, 1) > .825 AND MOD(HOURS,1) <= .999 THEN<br>       DBMS_OUTPUT.Put_LINE('The decimal portion <= .999');<br>       CALCULATED_HOURS := (substr(to_char(HOURS),0,1) + 1) + MOD(.00,1);<br>    ELSE<br>       DBMS_OUTPUT.Put_LINE('The hours passed in will use standard rounding');<br>       CALCULATED_HOURS := ROUND(HOURS,1); </p>
<pre><code>END IF; 
</code></pre>
<p>  ELSE<br>    -- if HOURS is less than one, then calculate the entire value<br>    DBMS_OUTPUT.Put_LINE('Less than 1 hour was passed in...');<br>    -- based upon quarterly hours<br>    IF HOURS > 0 AND HOURS <=.375 THEN<br>        DBMS_OUTPUT.Put_LINE('The decimal portion < .125');<br>        CALCULATED_HOURS := .25;<br>    ELSIF HOURS > .375 AND HOURS <= .625 THEN<br>        DBMS_OUTPUT.Put_LINE('The decimal portion <= .625');<br>        CALCULATED_HOURS := .5;<br>    ELSIF HOURS > .625 AND HOURS <= .825 THEN<br>        DBMS_OUTPUT.Put_LINE('The decimal portion <= .825');<br>        CALCULATED_HOURS := .75;<br>    ELSIF HOURS > .825 AND HOURS <= .999 THEN<br>        DBMS_OUTPUT.Put_LINE('The decimal portion <= .999');<br>        CALCULATED_HOURS := 1;<br>    ELSE<br>        DBMS_OUTPUT.Put_LINE('The hours passed in will use standard rounding');<br>        CALCULATED_HOURS := ROUND(HOURS,1);<br>    END IF;<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>363 </p>
<p>  END IF; </p>
<p>  RETURN CALCULATED_HOURS; </p>
<p>END CALC_QUARTER_HOUR; </p>
<p>When the CALC_QUARTER_HOUR function is executed with a value of 7.34, the comments will be<br>displayed as seen in the next snippet from a SQL*Plus session. </p>
<p>SQL> set serveroutput on<br>SQL> select calc_quarter_hour(7.34) from dual; </p>
<h2 id="CALC-QUARTER-HOUR-7-34"><a href="#CALC-QUARTER-HOUR-7-34" class="headerlink" title="CALC_QUARTER_HOUR(7.34) "></a>CALC_QUARTER_HOUR(7.34) </h2><pre><code>              7.25 
</code></pre>
<p>The value passed in was greater than one hour...<br>The decimal portion <= .375<br>How It Works<br>The use of DBMS_OUTPUT statements within PL/SQL code for displaying data or information pertaining to<br>the functionality of the code has been a great tactic for testing code in any language. As a matter of fact,<br>it is probably one of the most widely used techniques for debugging code. The ability to see values as<br>they are calculated or to determine how a condition is being handled can be very useful for determining<br>whether your code is executing as it should.<br>In order to use DBMS_OUTPUT statements for testing your code, you must place them in strategic<br>locations. In the example for this recipe, comments have been placed within each of the IF-ELSE blocks<br>to display a bit of text that will tell the developer how the values are being processed within the function.<br>This can be very useful when testing the code because a series of numbers can be passed into the<br>function in order to determine whether the correct result is being returned. If not, then you will be able<br>to see exactly where the code is being evaluated incorrectly.<br>Although using DBMS_OUTPUT statements in code can be very useful for determining where code is<br>functioning properly, it can cause clutter, and can also create its own issues. For example, if you forget to<br>place a quote after one of the DBMS_OUTPUT statements that you place into your code, then the code will<br>not compile correctly, causing you to hunt for the cause of yet another issue. Also, it is a good idea to<br>remove the output statements before code is released into production. This can take some time, which<br>could be better spent on development. As a means for testing small units of code, using DBMS_OUTPUT<br>statements works quite well. However, if you wish to develop entire test suites and automated unit<br>testing then you should go on to read Recipe 17-2 regarding utPLSQL.<br>17-2. Installing the utPLSQL Unit Testing Framework<br>Problem<br>You’ve chosen the utPLSQL unit-testing framework for PL/SQL for your work, and you want to install it.<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>364<br>Solution<br>First, download the utPLSQL sources from <a target="_blank" rel="noopener" href="http://utplsql.sourceforge.net/">http://utplsql.sourceforge.net/</a>. Once you have obtained<br>the sources, use the following steps to install the utPLSQL package into the database for which you wish<br>to write unit tests, and make it available for all schemas.<br>Create a user to host the utPLSQL tables, packages, and other objects. In this<br>example, the user will be named UTP, and the default permanent and<br>temporary tablespaces will be used.<br>SQL> create user utp identified by abc123;<br>Grant privileges to the newly created UTP user using the GRANT privilege_name TO<br>user_name statement, replacing values with the appropriate privilege and<br>username. The user will require the following privileges:<br> Create session<br> Create procedure<br> Create table<br> Create view<br> Create sequence<br> Create public synonym<br> Drop public synonym<br>Install the objects by running the ut_i_do.sql script.<br>SQL> @ut_i_do install </p>
<p>Once these steps have been completed then you will have the ability to run unit tests on packages<br>that are loaded into different schemas within the database.<br>How It Works<br>Before you can begin to write and run unit tests within the utPLSQL framework for the PL/SQL contained<br>within your database, you must install the utPLSQL package into a database schema. While the utPLSQL<br>framework can be loaded into the SYSTEM schema, it is better to separate the framework into its own<br>schema by creating a separate user and installing the packages, tables, and other objects into it. The<br>solution to this recipe steps through the recommended approach taken to install the utPLSQL framework<br>into the database of your choice.<br>Once you have created a user schema in which to install the utPLSQL framework objects, you must<br>grant it the appropriate privileges. The majority of the privileges are used to create the objects that are<br>required to make the framework functional. Public synonyms are created for many of the framework<br>objects, and this allows them to be accessible to other database user accounts. After all privileges have<br>been granted, running the ut_i_do.sql script and passing the install parameter will complete the<br>installation of the framework. After completion, you can begin to build unit test packages and install<br>them into different schemas within the database, depending on which PL/SQL objects that you wish to<br>test.<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>365<br>■ Note Unit tests will be executed from the same schema in which the PL/SQL object that is being tested resides,<br>not from the schema that contains the utPLSQL framework objects.<br>17-3. Building a utPLSQL Test Package<br>Problem<br>You would like to build a unit test package for one or more of the PL/SQL objects in your database<br>schema.<br>Solution<br>You want to build a utPLSQL test package to test an object in your database. A test package consists of two<br>separate files, a package header and a package body.<br>Create a header for the test package and save it in a file with the same name you<br>have given the header and with a .pks suffix. A header file contains three<br>procedures: ut_setup, ut_teardown, and the procedure that performs the unit<br>tests of the target object in your database. For example, suppose you want to<br>create a unit test package to test the code for the CALC_QUARTERLY_HOURS<br>function of Recipe 17-1. This package header should be stored into a file<br>named ut_calc_quarter_hour.pks and loaded into the database whose objects<br>you are testing.<br>CREATE OR REPLACE PACKAGE ut_calc_quarter_hour<br>IS<br>  PROCEDURE ut_setup;<br>  PROCEDURE ut_teardown; </p>
<p>  PROCEDURE ut_calc_quarter_hour;<br>END ut_calc_quarter_hour;<br>Create the package body that implements the procedures specified by the unit test<br>package header and save it as a file with the same name as the header, but this<br>time with a .pkb suffix. The following package body should be stored into a file<br>named ut_calc_quarter_hour.pkb and loaded into the database.<br>CREATE OR REPLACE PACKAGE BODY ut_calc_quarter_hour<br>IS </p>
<p>PROCEDURE ut_setup IS<br>BEGIN<br>  NULL;<br>END; </p>
<p>PROCEDURE ut_teardown IS<br>BEGIN<br>  NULL;<br>END;<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>366 </p>
<p>PROCEDURE ut_calc_quarter_hour IS<br>BEGIN </p>
<p>  -- Perform unit tests here<br>  NULL; </p>
<p>END ut_calc_quarter_hour; </p>
<p>END ut_calc_quarter_hour;<br>The package body in this example conforms to the format that must be used for testing packages<br>using the utPLSQL framework.<br>■ Note The .pks and .pkb suffixes could be changed to something different, like .sql, if you wish. You could<br>also store both the package header and body in the same file. However, utPLSQL framework will look for the .pks<br>and .pkb suffixes in order to automatically recompile your test packages before each test. It is best to follow the<br>utPLSQL convention to ensure that your test packages are always valid.<br>How It Works<br>A unit test package for the utPLSQL framework consists of a package header and a body. The package<br>header declares a setup procedure, a teardown procedure, and a unit testing procedure. The package<br>body consists of the PL/SQL code that implements the unit test. When you create a ut_PLSQL package, its<br>name must be prefixed with ut_, followed by the procedure or function name for which you are writing<br>the unit test. The unit test prefix can be changed, but ut_ is the default. For more information on<br>changing the unit test prefix, please see Recipe 12-8.<br>The test package body must contain both a setup and teardown procedure. These procedures must<br>also be given names that use the same prefix you have chosen for your unit testing. Therefore, as you can<br>see in the solution to this recipe, the package header declares ut_setup and ut_teardown procedures. The<br>ut_setup procedure is to initialize the variables or data structures the unit test procedure uses. When a<br>unit test is executed, ut_setup is always the first procedure to execute. The ut_teardown procedure is<br>used to clean up after all of the tests have been run. You should use this procedure to destroy all of the<br>data structures and variables created to support your unit tests. The ut_teardown procedure is always<br>executed last, after all unit tests have been run.<br>■ Note If you are choosing to use manual registration for your tests, you will be required to register each test<br>procedure in the ut_setup procedure as well. By default, registration of unit test procedures occurs automatically,<br>so you do not need to register them within ut_setup. If you are interested in learning more about manual unit test<br>registration, please see the online documentation that can be found at: <a target="_blank" rel="noopener" href="http://utplsql.oracledeveloper.nl/">http://utplsql.oracledeveloper.nl/</a><br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>367<br>The package must also contain an implementation for your unit test procedures. The unit test<br>procedure names should begin with the ut_ prefix followed by the name of the PL/SQL object that you<br>are testing. In the case of the solution for this recipe, the procedure name is ut_calc_quarter_hour. The<br>solution to this recipe does not contain any unit tests per se, but in order to perform a valid unit test of<br>the PL/SQL object, you must define a test case for each possible scenario using the assertion routines<br>that are made available by utAssert. To learn more about the different assertion routines, please see<br>Recipe 17-4.<br>17-4. Writing a utPLSQL Unit Test Procedure<br>Problem<br>You have a PL/SQL object that you’d like to test to verify it returns the expected values.<br>Solution<br>Create a utPLSQL test package to test every code branch and computation within your function. Use<br>utPLSQL assertion statements to test every foreseeable use case for the function. For example, suppose<br>you wish to test a simple factorial function that contains four code branches, each of which returns a<br>value. Here’s the target function: </p>
<p>CREATE OR REPLACE FUNCTION factorial (fact INTEGER) RETURN INTEGER is </p>
<p>BEGIN </p>
<p>   IF fact < 0 THEN RETURN NULL;<br>   ELSIF fact = 0 THEN RETURN 1;<br>   ELSIF fact = 1 THEN RETURN fact;<br>   ELSE RETURN fact * factorial (fact-1);<br>   END IF; </p>
<p>END factorial; </p>
<p>Next, create the unit test package to test the factorial function. Name the package using the same<br>name as the function to be tested and adding the prefix ut_ to it In this example, you’ll name the<br>package ut_factorial. Create the three required procedures within the package for setup, teardown,<br>and testing. Remember to save the file as a PKS file (i.e., one with a .pks file extension).  </p>
<p>CREATE OR REPLACE PACKAGE ut_factorial IS </p>
<p>   PROCEDURE ut_setup;<br>   PROCEDURE ut_teardown;<br>   PROCEDURE ut_factorial; </p>
<p>END ut_factorial; </p>
<p>Now create the unit testing package body. No code is required for the ut_setup or the ut_teardown<br>procedures as these are usually reserved for code that updates the database prior to or after running the<br>tests. For example, the setup procedure may insert records that are required only by the unit test, which<br>means that the teardown routine must clean up any data the test leaves behind. The ut_factorial<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>368<br>procedure is built with a series of assert statements that test each code branch in the factorial<br>function. Remember to save the file as a PKB file (i.e., one with a .pkb file extension). </p>
<p>CREATE OR REPLACE PACKAGE BODY ut_factorial IS </p>
<p>PROCEDURE ut_setup IS<br>BEGIN<br>   NULL;<br>END ut_setup; </p>
<p>PROCEDURE ut_teardown IS<br>BEGIN<br>   NULL;<br>END ut_teardown; </p>
<p>PROCEDURE ut_factorial IS<br>BEGIN<br>   utAssert.isnull ('is NULL test', factorial(-1));<br>   utAssert.eqQuery ('0! Test', 'select factorial(0) from dual', 'select 1 from dual');<br>   utAssert.eqQuery ('1! Test', 'select factorial(1) from dual', 'select 1 from dual');<br>   utAssert.eqQuery ('N! Test', 'select FACTORIAL(5) from dual', 'select 120 from dual');<br>END ut_factorial; </p>
<p>END ut_factorial;<br>How It Works<br>The utPLSQL package contains a number of tests that can be used to ensure that your code is working<br>properly. Each of these tests is an assertion, which is a statement that evaluates to either true or false<br>depending on whether its conditions are met. The solution to this recipe uses four tests to determine<br>whether the function returns an appropriate result for each scenario. The utAssert.isnull procedure<br>verifies the second parameter returns a null value when executed. The utAssert.eqQuery procedure uses<br>the select statements in parameter positions two and three to determine if the unit test succeeds or<br>fails. Each select statement must return the same value when executed to succeed. The three calls to<br>utAssert.eqQuery procedure in the ut_factorial procedure tests one branch (if statement) within the<br>factorial function. The expected return value from the factorial is used in the select statement of the<br>third parameter to retrieve the value from dual. If the factorial is updated in such a way that any code<br>branch no longer returns the expected value, the unit test will fail. This test should be performed after<br>modifying the factorial function to test for bugs introduced by the update. Table 17-1 lists the different<br>assertion tests that are part of the utAssert package.<br>Table 17-1. utPLSQL Assertion Tests<br>Assertion Name Description<br>utAssert.eq Checks equality of scalar values<br>utAssert.eq_refc_query Checks equality of RefCursor and Query<br>utAssert.eq_refc_table Checks equality of RefCursor and Database Tables<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>369<br>Assertion Name  Description<br>utAssert.eqcoll Checks equality of collections<br>utAssert.eqcollapi Checks equality of collections<br>utAssert.eqfile Checks equality of files<br>utAssert.eqoutput Checks equality of DBMS_OUTPUT values<br>utAssert.eqpipe Checks equality of database pipes<br>utAssert.eqquery Checks equality of different queries<br>utAssert.eqqueryvalue Checks equality of query against a value<br>utAssert.eqtabcount Checks equality of table counts<br>utAssert.eqtable Checks equality of different database tables<br>UTASSERT.isnotnull Checks for NOT NULL values<br>utAssert.isnull  Checks for NULL values<br>utAssert.objexists Checks for the existence of database objects<br>utAssert.objnotexists Checks for the existence of database objects<br>utAssert.previous_failed Checks if the previous assertion failed<br>utAssert.previous_passed Checks if the previous assertion passed<br>utAssert.this Generic “this” procedure<br>utAssert.throws Checks if a procedure or function throws an exception </p>
<p>There are many other tests that can also be used to help build your unit test packages. For an entire<br>list of the tests that are available, please see the documentation that can be found online at:<br><a target="_blank" rel="noopener" href="http://utplsql.oracledeveloper.nl/">http://utplsql.oracledeveloper.nl/</a>.<br>17-5. Running a utPLSQL Test<br>Problem<br>With a unit test package defined, you want to run it to verify that a function returns the values you expect<br>under a variety of scenarios.<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>370<br>Solution<br>Use the utPLSQL.test procedure to run your test package. For example, suppose you want to run the unit<br>test you built in 17-4. To do so, enter the following commands.<br>set serverout on<br>exec utPLSQL.test('factorial', recompile_in => FALSE)<br>Executing the commands above produces the following output.<br>. </p>
<blockquote>
<p>   SSSS   U     U   CCC     CCC   EEEEEEE   SSSS     SSSS<br>  S    S  U     U  C   C   C   C  E        S    S   S    S<br> S        U     U C     C C     C E       S        S<br>  S       U     U C       C       E        S        S<br>   SSSS   U     U C       C       EEEE      SSSS     SSSS<br>       S  U     U C       C       E             S        S<br>        S U     U C     C C     C E              S        S<br>  S    S   U   U   C   C   C   C  E        S    S   S    S<br>   SSSS     UUU     CCC     CCC   EEEEEEE   SSSS     SSSS<br>.<br>SUCCESS: "factorial"<br>.<br>Individual Test Case Results: </p>
</blockquote>
<p>SUCCESS - factorial.UT_FACTORIAL: ISNULL "is NULL test" Expected "" and got "" </p>
<blockquote>
</blockquote>
<p>SUCCESS - factorial.UT_FACTORIAL: EQQUERY "0! Test" Result: Result set for "select<br>factorial(0) from dual does match that of "select 1 from dual"<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>371 </p>
<blockquote>
</blockquote>
<p>SUCCESS - factorial.UT_FACTORIAL: EQQUERY "1! Test" Result: Result set for "select<br>factorial(1) from dual does match that of "select 1 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - factorial.UT_FACTORIAL: EQQUERY "N! Test" Result: Result set for "select<br>FACTORIAL(5) from dual does match that of "select 120 from dual" </p>
<blockquote>
<p>Errors recorded in utPLSQL Error Log: </p>
<p>NONE FOUND </p>
</blockquote>
<p>PL/SQL procedure successfully completed. </p>
<p>SQL> spool off<br>What if one of your test cases fails? Suppose that one of the test cases for the FACTORIAL test has<br>been modified so that a failure will result. Following is the resulting output from a failed unit test.<br>SQL> exec utPLSQL.test('factorial', recompile_in => FALSE)<br>. </p>
<blockquote>
<p> FFFFFFF   AA     III  L      U     U RRRRR   EEEEEEE<br> F        A  A     I   L      U     U R    R  E<br> F       A    A    I   L      U     U R     R E<br> F      A      A   I   L      U     U R     R E<br> FFFF   A      A   I   L      U     U RRRRRR  EEEE<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>372<br> F      AAAAAAAA   I   L      U     U R   R   E<br> F      A      A   I   L      U     U R    R  E<br> F      A      A   I   L       U   U  R     R E<br> F      A      A  III  LLLLLLL  UUU   R     R EEEEEEE<br>.<br>FAILURE: "factorial"<br>.<br>Individual Test Case Results: </p>
</blockquote>
<p>SUCCESS - factorial.UT_FACTORIAL: ISNULL "is NULL test" Expected "" and got "" </p>
<blockquote>
</blockquote>
<p>SUCCESS - factorial.UT_FACTORIAL: EQQUERY "0! Test" Result: Result set for<br>"select factorial(0) from dual does match that of "select 1 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - factorial.UT_FACTORIAL: EQQUERY "1! Test" Result: Result set for<br>"select factorial(1) from dual does match that of "select 1 from dual" </p>
<blockquote>
</blockquote>
<p>FAILURE - factorial.UT_FACTORIAL: EQQUERY "N! Test" Result: Result set for<br>"select FACTORIAL(5) from dual does  not match that of "select 121 from dual" </p>
<blockquote>
<p>Errors recorded in utPLSQL Error Log: </p>
</blockquote>
<p> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>373 </p>
<blockquote>
<p>NONE FOUND </p>
</blockquote>
<p>PL/SQL procedure successfully completed.<br>How It Works<br>The utPLSQL framework makes it easy to execute all of the tests that you have setup within a unit test<br>package; you need only to enter a utPLSQL.test command. In the solution to this recipe, the SET<br>SERVEROUT ON command enables output from the DBMS_OUTPUT statements within the utPLSQL.test<br>procedure. Without this command you cannot view the results of the unit test. The call to the<br>utPLSQL.test procedure passes two parameters, the first is the name of the unit test to run. Notice that<br>you do not specify the name of the package built for the unit test. Instead, you pass the name of the<br>function being tested. The second parameter tells the utPLSQL.test procedure not to recompile any of<br>the code before running the test.<br>17-6. Building a utPLSQL Test Suite<br>Problem<br>You have created numerous unit test procedures that you must run every time you modify your code.<br>Running each test individually is both time-consuming and error-prone, as you may forget to run a test<br>or two. You need a simple method to run all of your tests at once.<br>Solution<br>Use the utsuite.add command of utPLSQL to build a test suite, use the utPackage.add command to add<br>individual unit tests to it, and then run the result. For example, here’s how to build a suite to run the unit<br>tests you developed in Recipes 17-3 and 17-4.<br>Create the test suite.<br>exec utSuite.add ('My Test Suite', 'Test all my functions');<br>Add individual unit tests to the suite.<br>exec utPackage.add ('My Test Suite', 'calc_quarter_hour');<br>exec utPackage.add ('My Test Suite', 'factorial');<br>Run the test suite. See recipe 17-7.<br>How It Works<br>The utSuite.add routine creates a new test suite using the text in the first parameter as its unique name.<br>Note that the utPLSQL utility uppercases the suite name before saving, so take that into consideration, as<br>suite names must be unique. The second parameter is descriptive text for your test suite.<br>Once the suite is created, use the utPackage.add procedure to add existing unit tests to the suite. The<br>first parameter must match the name of an existing test suite. The second parameter is the name of the<br>unit test to run. As more unit tests are developed, they can be added to the suite to provide an easy<br>method to run all tests at once.<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>374<br>17-7. Running a utPLSQL Test Suite<br>Problem<br>You have defined a test suite and now wish to run the tests.<br>Solution<br>Use the utPLSQL.testSuite routine to run your tests. For example, here’s how run the test suite defined<br>in Recipe 17-6. </p>
<p>exec utPLSQL.testSuite ('My Test Suite', recompile_in=>false); </p>
<p>Executing the above test suite produces the following results.<br>SQL> exec utPLSQL.testSuite ('My Test Suite', recompile_in=>false);<br>. </p>
<blockquote>
<p>   SSSS   U     U   CCC     CCC   EEEEEEE   SSSS     SSSS<br>  S    S  U     U  C   C   C   C  E        S    S   S    S<br> S        U     U C     C C     C E       S        S<br>  S       U     U C       C       E        S        S<br>   SSSS   U     U C       C       EEEE      SSSS     SSSS<br>       S  U     U C       C       E             S        S<br>        S U     U C     C C     C E              S        S<br>  S    S   U   U   C   C   C   C  E        S    S   S    S<br>   SSSS     UUU     CCC     CCC   EEEEEEE   SSSS     SSSS<br>.<br>SUCCESS: "FACTORIAL"<br>.<br>Individual Test Case Results: </p>
</blockquote>
<p> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>375<br>SUCCESS - FACTORIAL.UT_FACTORIAL: ISNULL "is NULL test" Expected "" and got "" </p>
<blockquote>
</blockquote>
<p>SUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY "0! Test" Result: Result set for "select<br>factorial(0) from dual does match that of "select 1 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY "1! Test" Result: Result set for "select<br>factorial(1) from dual does match that of "select 1 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY "N! Test" Result: Result set for "select<br>FACTORIAL(5) from dual does match that of "select 120 from dual" </p>
<blockquote>
<p>Errors recorded in utPLSQL Error Log: </p>
<p>NONE FOUND<br>.<br>   SSSS   U     U   CCC     CCC   EEEEEEE   SSSS     SSSS<br>  S    S  U     U  C   C   C   C  E        S    S   S    S<br> S        U     U C     C C     C E       S        S<br>  S       U     U C       C       E        S        S<br>   SSSS   U     U C       C       EEEE      SSSS     SSSS<br>       S  U     U C       C       E             S        S<br>        S U     U C     C C     C E              S        S<br>  S    S   U   U   C   C   C   C  E        S    S   S    S<br>   SSSS     UUU     CCC     CCC   EEEEEEE   SSSS     SSSS<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>376<br>.<br>SUCCESS: "CALC_QUARTER_HOUR"<br>.<br>Individual Test Case Results: </p>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: ISNULL "NULL value" Expected "" and got "" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .10 rounds down"<br>Result: Result set for "select calc_quarter_hour(6.10) from dual does match that of "select<br>6 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .15 rounds up" Result:<br>Result set for "select calc_quarter_hour(6.15) from dual does match that of "select 6.25<br>from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .35 rounds down"<br>Result: Result set for "select calc_quarter_hour(6.35) from dual does match that of "select<br>6.25 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .40 rounds up" Result:<br>Result set for "select calc_quarter_hour(6.40) from dual does match that of "select 6.5 from<br>dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .65 rounds up" Result:<br>Result set for "select calc_quarter_hour(6.65) from dual does match that of "select 6.75<br>from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .83 rounds down"<br>Result: Result set for "select calc_quarter_hour(6.83) from dual does match that of "select<br>7 from dual"<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>377 </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .92 rounds up" Result:<br>Result set for "select calc_quarter_hour(6.92) from dual does match that of "select 7 from<br>dual" </p>
<blockquote>
<p>Errors recorded in utPLSQL Error Log: </p>
<p>NONE FOUND<br>If you happen to have a test fail, then the output of the test suite will display a failure message for<br>the unit test that failed. In the following output, one of the test cases for the FACTORIAL unit test fails.<br> FFFFFFF   AA     III  L      U     U RRRRR   EEEEEEE<br> F        A  A     I   L      U     U R    R  E<br> F       A    A    I   L      U     U R     R E<br> F      A      A   I   L      U     U R     R E<br> FFFF   A      A   I   L      U     U RRRRRR  EEEE<br> F      AAAAAAAA   I   L      U     U R   R   E<br> F      A      A   I   L      U     U R    R  E<br> F      A      A   I   L       U   U  R     R E<br> F      A      A  III  LLLLLLL  UUU   R     R EEEEEEE<br>.<br>FAILURE: "FACTORIAL"<br>.<br>Individual Test Case Results:<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>378 </p>
</blockquote>
<p>SUCCESS - FACTORIAL.UT_FACTORIAL: ISNULL "is NULL test" Expected "" and got "" </p>
<blockquote>
</blockquote>
<p>SUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY "0! Test" Result: Result set for<br>"select factorial(0) from dual does match that of "select 1 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - FACTORIAL.UT_FACTORIAL: EQQUERY "1! Test" Result: Result set for<br>"select factorial(1) from dual does match that of "select 1 from dual" </p>
<blockquote>
</blockquote>
<p>FAILURE - FACTORIAL.UT_FACTORIAL: EQQUERY "N! Test" Result: Result set for<br>"select FACTORIAL(5) from dual does  not match that of "select 121 from dual" </p>
<blockquote>
<p>Errors recorded in utPLSQL Error Log: </p>
<p>NONE FOUND<br>.<br>   SSSS   U     U   CCC     CCC   EEEEEEE   SSSS     SSSS<br>  S    S  U     U  C   C   C   C  E        S    S   S    S<br> S        U     U C     C C     C E       S        S<br>  S       U     U C       C       E        S        S<br>   SSSS   U     U C       C       EEEE      SSSS     SSSS<br>       S  U     U C       C       E             S       S<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>379<br>        S U     U C     C C     C E              S        S<br>  S    S   U   U   C   C   C   C  E        S    S   S    S<br>   SSSS     UUU     CCC     CCC   EEEEEEE   SSSS     SSSS<br>.<br>SUCCESS: "CALC_QUARTER_HOUR"<br>.<br>Individual Test Case Results: </p>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: ISNULL "NULL value" Expected<br>"" and got "" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .10 rounds<br>down" Result: Result set for "select calc_quarter_hour(6.10) from dual does<br>match that of "select 6 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .15 rounds<br>up" Result: Result set for "select calc_quarter_hour(6.15) from dual does match<br>that of "select 6.25 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .35 rounds<br>down" Result: Result set for "select calc_quarter_hour(6.35) from dual does<br>match that of "select 6.25 from dual" </p>
<blockquote>
</blockquote>
<p>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>380<br>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .40 rounds<br>up" Result: Result set for "select calc_quarter_hour(6.40) from dual does match<br>that of "select 6.5 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .65 rounds<br>up" Result: Result set for "select calc_quarter_hour(6.65) from dual does match<br>that of "select 6.75 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .83 rounds<br>down" Result: Result set for "select calc_quarter_hour(6.83) from dual does<br>match that of "select 7 from dual" </p>
<blockquote>
</blockquote>
<p>SUCCESS - CALC_QUARTER_HOUR.UT_CALC_QUARTER_HOUR: EQQUERY "Check that .92 rounds<br>up" Result: Result set for "select calc_quarter_hour(6.92) from dual does match<br>that of "select 7 from dual" </p>
<blockquote>
<p>Errors recorded in utPLSQL Error Log: </p>
<p>NONE FOUND<br>PL/SQL procedure successfully completed.<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>381<br>How It Works<br>The utPLSQL.testSuite procedure steps though each unit test added using the utPackage.add procedure<br>and executes each test. In turn, each test executes and sends its results to the screen. This is a quick<br>method to run all tests and see the output on one screen capture. If one of the test cases within a unit<br>test fails, all of the remaining tests in the suite will continue to execute, and the test that failed will be<br>noted in the output. This is very useful as it will allow tests of many PL/SQL objects at once, and you will<br>be able to see which tests had issues and which did not.<br>■ Hint Spool the output to a file if the number of tests exceeds the screen buffer’s capacity.<br>17-8. Reconfiguring utPLSQL Parameters<br>Problem<br>You would like to change some of the configurations for your utPLSQL install. For instance, you would<br>like to change the prefix for all of your unit test packages so that, instead of beginning with ut_, they all<br>start with test_.<br>Solution<br>Use the utConfig package to alter the configurations for utPLSQL. For this solution, you will see how<br>utConfig can be used to change the prefix that is used for all of your test packages. For example, here’s<br>how to change the prefix for your test packages from ut_ to test_ using the utConfig package for the<br>current schema. </p>
</blockquote>
<p>SQL> exec utConfig.setPrefix('test_'); </p>
<p>PL/SQL procedure successfully completed. </p>
<p>After executing the statement in the example, the utPLSQL unit test framework will look for test<br>packages beginning with the test_ prefix rather than ut_ within the current schema, until the prefix is<br>changed again using the utConfig package.<br>How It Works<br>The utPLSQL test framework can be configured to operate differently from its default manner by<br>changing options using the utConfig package. Changes can be made for the current schema only, or for<br>all schemas within the database. In the solution to this recipe, you have seen that the prefix for test<br>packages is configurable. To change the prefix, pass the desired prefix in string format to<br>utConfig.setPrefix(). The setPrefix() procedure also accepts an additional schema name that will<br>specify the schema to which the configuration option will be applied. If you do not pass a schema name,<br>the changes will occur within the current schema. The actual format for executing the<br>utConfig.setPrefix procedure is as follows: </p>
<p>exec utConfig.setPrefix(desired_prefix, [schema]);<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>382<br>There are many configurable options that can be changed using the utConfig package. Table 17-2<br>shows the complete list of options.<br>Table 17-2. utConfig Configuration Options<br>Option Description<br>utConfig.autocompile Configure autocompile feature<br>utConfig.registertest Configure the registration mode (manual or automatic)<br>utConfig.setdateformat Configure the date format for the date portion of output file names<br>utConfig.setdelimiter Configure the V2 delimiter<br>utConfig.setdir Configure the directory containing the test package code<br>utConfig.setfiledir Configure the directory for file output<br>utConfig.setfileextension Configure the file extension for output file names<br>utConfig.setfileinfo Configure all of the above file output related items<br>utConfig.setincludeprogname Configure whether to include the name of the program being tested<br>within output file names<br>utConfig.setprefix Configure the default unit test prefix<br>utConfig.setreporter Configure the default Output Reporter<br>utConfig.settester Configure whose configuration is used<br>utConfig.setuserprefix Configure the user prefix for output file names<br>utConfig.showfailuresonly Switch off the display for successful tests </p>
<p>You can set of the options shown here using a syntax similar to that shown for the setPrefix()<br>procedure that was demonstrated in the solution to this recipe. For more information on using the<br>configurations listed in Table 17-2, please see the online documentation that can be found at:<br><a target="_blank" rel="noopener" href="http://utplsql.oracledeveloper.nl/">http://utplsql.oracledeveloper.nl/</a>. Along with configurable options, the utConfig package includes<br>some functions that can be called to retrieve information regarding the unit test configuration for the<br>database or for a particular schema. Table 17-3 contains a listing of the options that utConfig makes<br>available for obtaining information.<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>383<br>Table 17-3. utConfig Informational Options<br>Option Name Description<br>utConfig.autocompiling Returns autocompile flag value<br>utConfig.dateformat Returns date format used to construct output file names<br>utConfig.delimiter Returns V2 delimiter<br>utConfig.dir Returns directory containing the test package code<br>utConfig.filedir Returns file output directory<br>utConfig.fileextension Returns output file name extension<br>utConfig.fileinfo Returns all file output—related items<br>utConfig.getreporter Obtains name of the default Output Reporter to use<br>utConfig.includeprogname Returns whether to include the name of the program being tested<br>within file names<br>utConfig.prefix Returns default unit test prefix for your code<br>utConfig.registering Returns registration mode<br>utConfig.showconfig Displays a schema configuration<br>utConfig.showingfailuresonly Returns whether successful test results are displayed<br>utConfig.tester Returns the schema whose configuration is used<br>utConfig.userprefix Returns the user prefix for output files </p>
<p>The functions can be called just as if they were standard functions within your schema. Some, such<br>as the utConfig.showconfig procedure, require you to set serveroutput on in order to display the output.<br>The following excerpt from a SQL*Plus session shows a call to utConfig.showconfig. </p>
<p>SQL> set serveroutput on<br>SQL> exec utconfig.showconfig<br>=============================================================<br>utPLSQL Configuration for USERNAME<br>Directory:<br>Autcompile?<br>Manual test registration?<br>Prefix =<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>384<br>Default reporter     =<br>----- File Output settings:<br>Output directory:<br>User prefix     =<br>Include progname?<br>Date format     =<br>File extension  =<br>----- End File Output settings<br>============================================================= </p>
<p>PL/SQL procedure successfully completed. </p>
<p>The utConfig package contains a variety of configurable options that will allow you to adjust unit<br>testing according to your specific needs. Out of the box, the utPLSQL testing framework contains default<br>values for each of these options, so you may never need to touch utConfig, but the option is available if<br>you need it. Another nice feature is that you can set configurable options for a specific schema. Doing so<br>will allow different schemas in the database to act differently when performing unit testing.<br>17-9. Redirecting utPLSQL Test Results to a File<br>Problem<br>You are interested in writing the results of a unit test to a file.<br>Solution<br>Change the setting of the setreporter option of utPLSQL so that output is redirected to a file instead of<br>DBMS_OUTPUT. Once the configuration has been altered, execute the unit tests for which you would like to<br>have the output captured to the file. After you’ve run your tests, close the file and change the<br>configuration back to its default. In the following lines of code, all of the steps that are necessary for<br>redirecting test results to a file are exhibited. For example, suppose that the database has a directory that<br>has already been enabled for use with the database named FILE_SYSTEM. </p>
<p>SQL>  BEGIN<br>  utconfig.setfiledir('FILE_SYSTEM');<br>  -- Causes output to be redirected to file system<br>  utconfig.setreporter('File');<br>  utPLSQL.test('calc_quarter_hour');<br>  -- Closes the fle<br>  utfilereporter.close();<br>  -- Returns output redirection to DBMS_OUTPUT<br>  utconfig.setreporter('Output');<br>END; </p>
<p>PL/SQL procedure successfully completed. </p>
<p>When the code block in this example is executed, a file will be created within the directory<br>represented by FILE_SYSTEM. The unit test for CALC_QUARTER_HOUR will then be executed and the results<br>will be redirected to the newly created file. Lastly, the file will be closed and the output will be redirected<br>back to DBMS_OUTPUT.<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>385<br>How It Works<br>One of the configurable options of utPLSQL allows for the output of your unit tests to be redirected. The<br>choices for displaying unit test results include Output, File, and HTML. The standard Output option is<br>Output , which causes output to be displayed within the SQL<em>Plus environment using DBMS_OUTPUT. The<br>File option allows for a file to be created and unit test results to be written to that file. Lastly, the HTML<br>option allows for unit test results to be formatted into file in the format of an HTML table. In the solution<br>to this recipe, the use of the File output reporter is demonstrated.<br>Prior to redirecting unit test output to a file, you must create a database directory using the CREATE<br>DIRECTORY statement with a privileged account. For more information about creating directories, please<br>see the Oracle documentation that can be found at:<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/statements_5007.htm#SQLRF01207">http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/statements_5007.htm#SQLRF01207</a>.<br>Once you have created a database directory, you can use it to write the results of unit tests by setting the<br>file directory using the utConfig.setfiledir() procedure. This procedure accepts the name of the<br>database directory as a parameter. In the solution to this recipe, the directory is named FILE_SYSTEM. To<br>redirect the unit test output from utPLSQL, you must use the utConfig.setreporter() procedure. This<br>procedure accepts the name of the reporter that you would like to use for displaying output. As you can<br>see from the solution to this recipe, the File reporter is chosen to redirect the output to a file on the file<br>system. It is also possible to create a custom reporter configuration that you can pass to the<br>utConfig.setreporter() procedure. For more information about creating customized reporters, please<br>see the utPLSQL documentation that can be found at:<br><a target="_blank" rel="noopener" href="http://utplsql.sourceforge.net/Doc/reporter.html">http://utplsql.sourceforge.net/Doc/reporter.html</a>.<br>After the output has been redirected using utConfig.setreporter(), you can run as many tests as<br>you wish and all of the output will be directed to a file instead of to the SQL</em>Plus command prompt. In<br>the solution to this recipe, the CALC_QUARTER_HOUR function is tested. Once you have finished running<br>your tests, you must close the output file in order to make it available for you to use. If you fail to close<br>the file, you will be unable to open it or use it because the database will maintain a lock on the file. To<br>close the file, use issue utfilereporter.close(). Lastly, I recommend redirecting unit test output to the<br>default Ouput option, which will cause it to be sent to DBMS_OUTPUT. By doing so, the next person who runs<br>a unit test will receive the functionality that he or she expects by default, as the output will be directed to<br>the screen. It is a good idea to set the default output at the beginning of all test suites just to ensure that<br>you know where the output will be directed. However, if you are the only person running unit tests, or if<br>you prefer to maintain the File reporter as your default, then omit the final call to<br>utConfig.setreporter() that is shown in this solution.<br>Many times it can be useful to have unit test results redirected to an output file rather than<br>displayed within the SQL<em>Plus environment. For instance, if you are running unit tests during off hours<br>and would like to see the output, then it would be helpful to have it recorded to a file that can be viewed<br>at a later time. Similarly, if you are running several unit tests, it may be easier to read through a file rather<br>than scrolling through SQL</em>Plus output. Whatever the requirement may be, utPLSQL makes it easy to<br>redirect unit test output to a file or another device by creating a custom reporter.<br>17-10. Automating Unit Tests for PL/SQL and Java Stored Procedures<br>Using Ant<br>Problem<br>You wish to automatically run your unit tests for PL/SQL code and Java stored procedures each day and<br>to write the results of the unit test to a file.<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>386<br>Solution<br>Use Apache’s Ant build system to perform unit testing on your PL/SQL code. At the same time, Ant can<br>build and compile any Java code that you will be using for your stored procedures. To do so, develop an<br>Ant build script that will execute some SQL statements, automate your unit tests, and compile Java<br>source into a directory. For example, the following build.xml file is an example of such a build that can<br>be used to compile Java sources and execute unit tests on PL/SQL within a single Ant run. </p>
<project name="MyPLSQLProject" default="unitTest" basedir="."> 
    <description> 
        PLSQL Unit Test and Application Builder 
    </description> 
  <!-- set global properties for this build --> 
  <property name="src" location="src"/> 
  <property name="build" location="build" value=”build”/> 
  <property name="user" value="myuser"/> 
  <property name="db_password" value="mypassword"/> 
  <property name="database.jdbc.url" value="jdbc:oracle:thin:@hostname:1521:database"/> 
 
  <target name="init"> 
    <!-- Create the time stamp --> 
    <tstamp/> 
    <mkdir dir="${build}"/> 
  </target> 
 
<p>  <target name="compile" depends="init" 
        description="compile the source " ><br>    <!-- Compile the java code from ${src} into ${build} --><br>    <!-- This is where you place the code for your java stored procedures --><br>    <javac srcdir="${src}" destdir="${build}"/><br>  </target> </p>
<p>  <target name="unitTest" depends="compile" 
        description="Execute PLSQL Unit Tests" ><br>    <sql 
     driver = "oracle.jdbc.driver.OracleDriver" 
     url = "${database.jdbc.url}" 
     userid = "${user}" 
     password = "${db_password}" 
     print="true" 
    ><br>      call utconfig.setfiledir('FILE_SYSTEM');<br>      call utconfig.setreporter('File');<br>      call utPLSQL.test('calc_quarter_hour');<br>      -- Closes the fle<br>      call utfilereporter.close();<br>      -- Returns output redirection to DBMS_OUTPUT<br>      call utconfig.setreporter('Output'); </p>
<pre><code>&lt;/sql&gt; 
</code></pre>
  </target> 
 CHAPTER 17  UNIT TESTING WITH UTPLSQL 
387 
</project> 
 
<p>This build script can be executed by issuing the ant command from within the terminal or<br>command prompt. The results will resemble the following output.<br>juneau$ ant<br>Buildfile: /Users/juneau/Documents/PLSQL_Recipes/sources/17/build.xml </p>
<p>init: </p>
<p>compile:<br>    [javac] /Users/juneau/Documents/PLSQL_Recipes/sources/17/build.xml:22: warning:<br>'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for<br>repeatable builds </p>
<p>unitTest:<br>      [sql] Executing commands<br>      [sql] 0 rows affected<br>      [sql] 0 rows affected<br>      [sql] 0 rows affected<br>      [sql] 0 rows affected<br>      [sql] 0 rows affected<br>      [sql] 5 of 5 SQL statements executed successfully </p>
<p>BUILD SUCCESSFUL<br>Total time: 4 seconds<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>388<br>How It Works<br>Automating unit tests can be very helpful, especially if you are working on a project where there may be<br>more than one developer contributing code. The Apache Ant build system is useful for automating<br>builds and unit tests for Java projects. However, it can also be used to perform a myriad of other tasks,<br>including issuing SQL statements, as seen in the solution to this recipe. Ant provides an entire build and<br>unit test solution that is easy to use. To set up a build, all you need to do is install Ant on your machine<br>and then create a build.xml file that consists of targets that Ant will use to build the project. Once you<br>have created a build file, then simply open a command prompt or terminal and traverse into the<br>directory containing your build file. Once in the directory, issue the ant command and it will<br>automatically look for a file named build.xml that will provide Ant the sequence used for the build.<br>Ant uses simple logic to determine the order of sequence that will be used to execute the targets that<br>are listed within the build.xml file. In the solution to this recipe, the build file contains three targets,<br>init, compile, and unitTest. Ant will start the build by executing the target listed within the <project><br>tag as the default. In this case, the default target is unitTest.  </p>
<project name="MyPLSQLProject" default="unitTest" basedir="."> 
 
<p>The unitTest target contains a depends attribute, which lists the compile target. This tells Ant that<br>the compile target should be executed first because unitTest depends upon its outcome.  </p>
<p><target name="unitTest" depends="compile" 
        description="Execute PLSQL Unit Tests" > </p>
<p>Consequently, the compile target depends upon the init target, so init will be executed before<br>compile.  </p>
<p><target name="compile" depends="init" 
        description="compile the source " > </p>
<p>The order of target execution for the solution to this recipe will be the init target first, followed by<br>the compile target, and lastly the unitTest target. The project tag also contains an attribute named<br>basedir. This attribute tells Ant where the build files should be located. In the solution to this recipe,<br>basedir contains a period “.” that tells Ant to use the current directory.<br>At the top of the build file, you can see that there is a <description> tag. This is used to provide a<br>brief description of the tasks completed by the build file. There are also several <property> tags. These<br>tags are used to define the variables that will be used within the build file. Each <property> tag contains a<br>name attribute and either a value or location attribute.  </p>
  <property name="src" location="src"/> 
  <property name="build" location="build" value=”build”/> 
  <property name="user" value="myuser"/> 
  <property name="db_password" value="mypassword"/> 
  <property name="database.jdbc.url" value="jdbc:oracle:thin:@hostname:1521:database"/> 
 
<p>The properties that use a value attribute are used to assign values to the property name, whereas the<br>properties that contain location attributes are used to assign a location to the property name. Properties<br>can be referenced within the build file by using the following syntax: “${property_name}”. As you can see<br>from the solution to this recipe, each target within the build file consists of a number of tasks in the form<br>of XML tags. The init target creates a timestamp by using the <tstamp/> tag, and it creates a directory<br> CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>389<br>using the <mkdir/> tag and passing the name of a directory to be created. In this case, the directory name<br>will be named the same as the value that is assigned to the <property> tag that is named build.  </p>
<target name="init"> 
    <!-- Create the time stamp --> 
    <tstamp/> 
    <mkdir dir="${build}"/> 
  </target> 
 
<p>The compile target is used to compile all of the Java sources contained in the project. All of the<br>sources should reside within a named directory that is located in the base directory of the Ant project.<br>The compile target contains a single task using the <javac> tag. This tag contains a src attribute that<br>defines the location of the sources to be compiled, and a destdir attribute that tells Ant where to place<br>the resulting Java class files. An Ant project that builds a Java project may contain only this task, but can<br>build several hundred Java class files. In the solution to this recipe, and for most Ant uses with PL/SQL<br>projects, however, the project will probably contain no Java source files or only a few at most. If a project<br>contains no Java source files, then the target will be executed, but the <javac> task will do nothing since<br>there are not any sources to be compiled. </p>
<p><target name="compile" depends="init" 
        description="compile the source " ><br>    <!-- Compile the java code from ${src} into ${build} --><br>    <!-- This is where you place the code for your java stored procedures --><br>    <javac srcdir="${src}" destdir="${build}"/><br>  </target> </p>
<p>The most important target in the solution to this recipe is the unitTest target. It consists of a single<br>task using the <sql> tag. The sole purpose of the <sql> task is to execute SQL within a designated<br>database. The <sql> tag contains a driver attribute that is used to list the JDBC driver for the target<br>database, a url attribute used to define the JDBC URL for the target database, a userid and password<br>attribute for defining the database username and password, and a print attribute that tells Ant whether<br>to print the result sets from the SQL statements. In the solution to this recipe, the SQL that is required to<br>execute the unit tests is contained within the <sql> opening and closing tags. This causes the unit tests to<br>be executed as if you were issuing these statements at the SQL*Plus command prompt. </p>
<p><target name="unitTest" depends="compile" 
        description="Execute PLSQL Unit Tests" ><br>    <sql 
     driver = "oracle.jdbc.driver.OracleDriver" 
     url = "${database.jdbc.url}" 
     userid = "${user}" 
     password = "${db_password}" 
     print="true" 
    ><br>      call utconfig.setfiledir('FILE_SYSTEM');<br>      call utconfig.setreporter('File');<br>      call utPLSQL.test('calc_quarter_hour');<br>      -- Closes the fle<br>      call utfilereporter.close();<br>      -- Returns output redirection to DBMS_OUTPUT<br>      call utconfig.setreporter('Output');<br>CHAPTER 17  UNIT TESTING WITH UTPLSQL<br>390<br>    </sql> </p>
  </target> 
To automate your Ant build, you will need to set up an operating system task that starts the Ant
build. The task is very simple and needs to contain only very few lines. The following lines of code
contain batch script for the Windows operating system that can be used to invoke the Ant build. This
assumes that the java.exe executable is contained within the PATH environment variable. 
cd C:/path_to_project_directory
ant 
You will also need to ensure that the JDBC driver for the Oracle database is contained within your
CLASSPATH. If you do not include the JDBC driver in the CLASSPATH, then you will receive an error when
you try to execute the build. When the Ant build is executed, a file will be placed onto the database server
in the location designated by the FILE_SYSTEM database directory. The file will contain the results of the
unit test execution. 
Ant is a complex build system that can be used for configuration and preparation of your builds and unit
tests. It is a widely used build system, especially for organizations that do lots of Java development. As
you can see, it is easy to use, but does contain complexity in that there are a number of different tasks
and attributes that can be used. This recipe does not even scratch the surface of everything that Ant can
do. However, there are lots of sources for documentation on Ant that can be found online as well as in
book format. To learn more about Ant, you can start by reading the online documentation that can be
found at: http://ant.apache.org/manual/. 
            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/04/oracle/oracle_sql_%E5%BF%85%E5%A4%87%E5%8F%82%E8%80%83/"
                    data-tooltip="Oracle Sql必备手册"
                    aria-label="PREVIOUS: Oracle Sql必备手册"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/01/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E5%9C%A3%E7%BB%8F/"
                    data-tooltip="圣经-旧约全书"
                    aria-label="NEXT: 圣经-旧约全书"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/03/oracle/OraclePL_SQL_Recipes/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/04/oracle/oracle_sql_%E5%BF%85%E5%A4%87%E5%8F%82%E8%80%83/"
                    data-tooltip="Oracle Sql必备手册"
                    aria-label="PREVIOUS: Oracle Sql必备手册"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/01/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E5%9C%A3%E7%BB%8F/"
                    data-tooltip="圣经-旧约全书"
                    aria-label="NEXT: 圣经-旧约全书"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/03/oracle/OraclePL_SQL_Recipes/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href=""
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/03/oracle/OraclePL_SQL_Recipes/"
                        aria-label="global.share_on_wechat"
                    >
                        <i class="fa-foo_bar" aria-hidden="true"></i><span>global.share_on_wechat</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Canton
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-4u8r0fo0pgap8c0kebqie2krcfxcv3h259cjxizeggkmknhnwzjt04ztqpi1.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'ca29b9a1203b5920918d',
              clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
              repo: 'SimonTeo58.github.io',
              owner: 'SimonTeo58',
              admin: ['SimonTeo58'],
              id: '2022/11/03/oracle/OraclePL_SQL_Recipes/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
