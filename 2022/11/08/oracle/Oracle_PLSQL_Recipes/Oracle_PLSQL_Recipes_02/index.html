
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CoffeeMan">
    <title>Oracle PLSQL Recipes 02-基础sql - CoffeeMan</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://simonteo58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg"},"articleBody":"摘要: 其实这个讲PLSQL有点基础\n\n\n\n\n\n\n2.基础sql\n2.1 Retrieving a Single Row from the DatabaseProblem\nYou are interested in returning one row from a database table via a query that searches for an exactmatch.\nSolution 1你可以使用select ... into ...语法\nDECLARE\n    first VARCHAR2(20);  -- varchar2(20)一定是要兼容的数据库表字段的\n    last VARCHAR2(25); \n    email VARCHAR2(25); \nBEGIN \n    SELECT first_name, last_name, email \n    INTO first, last, email \n    FROM employees \n    WHERE employee_id &#x3D; 100; \n    DBMS_OUTPUT.PUT_LINE( \n    &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); \nEXCEPTION \nWHEN NO_DATA_FOUND THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given ID&#39;); \nWHEN TOO_MANY_ROWS THEN\n    DBMS_OUTPUT.PUT_LINE(&#39;More than one employee matches the given ID&#39;); \nEND; \n\nSolution 2\nDECLARE\n CURSOR emp_cursor IS \n SELECT first_name, last_name, email \n FROM employees \n WHERE employee_id &#x3D; &amp;emp_id; \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n OPEN emp_cursor; \n FETCH emp_cursor INTO first, last, email; \n IF emp_cursor%NOTFOUND THEN \n      RAISE NO_DATA_FOUND; \n ELSE \n -- Perform second fetch to see if more than one row is returned \n    FETCH emp_cursor INTO first, last, email; \n    IF emp_cursor%FOUND THEN \n      RAISE TOO_MANY_ROWS; \n    ELSE \n      DBMS_OUTPUT.PUT_LINE( \n      &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); \n      END IF;\n END IF; \nCLOSE emp_cursor; \n\n\nHow It Works\nSolution 1: One is to issue a SELECT…INTO statement,which is a statement designed to return just one row.The other approach is to open a cursor, fetch the  one row, and close the cursorSolution 2: We keep an open mind on that point. Consider that if youare expecting exactly one row to bereturned, getting multiple rows back represents an exception case that you must somehow deal with.The cursor-based Solution makes it easy to simply ignore that exception case, but ignoring a conditionthat you do not expect to occur does not change the fact that it has occurred. Although a cursor is used,the cases where no data is returned or where too many rows are returnedgiven the user-supplied EMPLOYEE_IDstill remain a reality. However, since cursors are specifically designed to deal with zero rows or morethan one row coming back from a query, no exceptions will be raised if these situations occur. For this reason,Solution #2 contains some conditional logic that is used to manually raise the desired exceptions.In the event that the user supplies the block with an invalid EMPLOYEE_ID, the cursor will not fetch any data. The %NOTFOUND attribute of the cursor will be checked to see whether the cursor successfully fetched data. If not, then the NO_DATA_FOUND exception is raised. If the cursor is successful in retrieving data, then a second FETCH statement is issued to see whether more thanone row will be returned. If more than one row is returned, then the TOO_MANY_ROWS exception is raised;otherwise, the expected output is displayed. In any event, the output that is displayed using either of theSolutions will be the same whether successful or not.\n2.2. Qualifying Column and Variable Names（变量和表列名相同)ProblemYou have a variable and a column sharing the same name. You want to refer to both in the same SQLstatement.For example, you decide that you’d like to search for records where LAST_NAME is not equal to a lastname that is provided by a user via an argument to a procedure call. Suppose you have declared avariable LAST_NAME, and you want to alter the query to read as follows: \nSELECT first_name, last_name, email\n INTO first, last, email \n FROM employees \nWHERE last_name &#x3D; last_name; \nHow does PL&#x2F;SQL know which LAST_NAME you are referring to since both the table column name andthe variable name are the same? You need a way to differentiate your references. \nSolutionYou can use the dot notation to fully qualify the local variable name with the procedure name so thatPL&#x2F;SQL can differentiate between the two. The altered query, including the fully qualifiedprocedure_name.variable Solution, would read as follows: \nCREATE OR REPLACE PROCEDURE retrieve_emp_info(last_name IN VARCHAR2) AS \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n SELECT first_name, last_name, email \n INTO first, last, email \n FROM employees \n WHERE last_name &#x3D; retrieve_emp_info.last_name; \n DBMS_OUTPUT.PUT_LINE( \n &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last_name || &#39; - &#39; || email); \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name &#39; || last_name); \nEND; \n\nHow It Works\nPL&#x2F;SQL name reSolution(方法) becomes very important in circumstances such as these, and by fully qualifyingthe names, you can be sure that your code will work as expected. The Solution used dot notation to fullyqualify the variable name. \nThe column name could have been qualified with the table name, as in EMPLOYEES.LAST_NAME.However, there’s no need to qualify the column name in this case. Because the reference occurs within aSELECT, the closest reSolution for LAST_NAME becomes the table column of that name. So, in this particularcase, it is necessary only to qualify references to variable names in the enclosing PL&#x2F;SQL block. \nIf you are executing a simple BEGIN…END block, then you also have the option of fully qualifying thevariable using the dot notation along with the block label. For the purposes of this demonstration, let’ssay that the code block shown in the Solution was labeled &lt;&gt;. You could then fully qualify avariable named description as follows: \nside note:\n\n\n&lt;&lt;emp_info&gt;&gt;\nDECLARE \n last_name VARCHAR2(25) :&#x3D; &#39;Fay&#39;; \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n SELECT first_name, last_name, email \n INTO first, last, email \n FROM employees \n WHERE last_name &#x3D; emp_info.last_name; \nEND; \n\nIn this example, the LAST_NAME that is declared in the code block is used within the SELECT..INTOquery, and it is fully qualified with the code block label.\n\n\nsummary: \n\nwhile code block contain same variable name as parameter, we could use “procedure”(including package name i though) name qualify parameter name at where clause statement.\nactualy you could use table name qualify parameter name in code block, but no more works on it,due to in your select statement,it had been qualified by table name.\nand so on , if you use label on your code block, as case shown above\n\n\n\n2.3. Declaring Variable Types That Match Column TypesProblemYou want to declare some variables in your code block that match the same datatypes as some columnsin a particular table. If the datatype on one of those columns changes, you’d like the code block toautomatically update the variable type to match that of the updated column\nNoteSharp-eyed readers will notice that we cover this Problem redundantly in Chapter 1. We cover thisProblem here as well, because the Solution is fundamental to working in PL&#x2F;SQL, especially to working with SQL inPL&#x2F;SQL. We don’t want you to miss what we discuss in this recipe. It is that important.\nSolutionUse the %TYPE attribute(n.属性) on table columns to identify(v.确定) the types of data that will be returned into your local variables. Instead of providing a hard-coded datatype for a variable, append %TYPE to the database column name. Doing so will apply the datatype from the specified column to the variable you are declaring.\nIn the following example, the same SELECT INTO query is issued, as in the previous Problem, to retrieve an employee record from the database. However, in this case, the variables are declared using the %TYPE attribute rather than designating a specified datatype for each.\nDECLARE \n  first   employees.first_name%TYPE;\n  last    employees.last_name%TYPE;\n  email   employees.email%TYPE;\nBEGIN \nSELECT \n  first_name, \n  last_name, \n  email INTO first, last, email \nFROM \n  employees \nWHERE \n  employee_id &#x3D; &amp; emp_id;\n  DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email);\nEXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;No matching employee was found, please try again.&#39;);\nWHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&#39;An unknown error has occured, please try again.&#39;);\nEND;\n\nAs you can see from the Solution, the code block looks essentially the same as the one in the previous recipe. The only difference is that here the %TYPE attribute of each database column is being used in order to declare your local variable types.\nHow It WorksThe %TYPE attribute can become a significant time-saver and savior for declaring variable types, especially if the underlying database column types are subject(会发生变化) to change. This attribute enables the local variable to assume the same datatype of its corresponding database column type at runtime. Retrieving several columns into local application variables can become tedious(沉闷的) if you need to continually verify that the datatypes of each variable are the same as those of the columns whose data they will consume.The%TYPE attribute can be used when defining variables, constants, fields, and parameters. Using %TYPE assures(保证) that the variables you declare will always remain synchronized with the datatypes of their corresponding columns.\n\nsummary: \nat all above explained that we could use `%TYPE` attribute to define variable which the same as table datatype\n\n\n2.4. Returning Queried Data into a PL&#x2F;SQL RecordProblemInstead of retrieving only a select few columns via a database query, you’d rather return the entirematching row. It can be a time-consuming task to replicate each of the table’s columns in yourapplication by creating a local variable for each along with selecting the correct datatypes. Although youcan certainly make use of the %TYPE attribute while declaring the variables, you’d rather retrieve theentire row into a single object. Furthermore, you’d like the object that the data is going to be stored intoto have the ability to assume the same datatypes for each of the columns being returned just as youwould by using the %TYPE attribute.SolutionMake use of the %ROWTYPE attribute for the particular database table that you are querying. The %ROWTYPEattribute returns a record type that represents a database row from the specified table. For instance, thefollowing example demonstrates how the %ROWTYPE attribute can store an entire employee table row for acursor: \nDECLARE \n CURSOR emp_cur IS \n SELECT * \n FROM employees \n WHERE employee_id &#x3D; &amp;emp_id; \n -- Declaring a local variable using the ROWTYPE attribute \n -- of the employees table \n emp_rec employees%ROWTYPE; \nBEGIN \n OPEN emp_cur; \n FETCH emp_cur INTO emp_rec; \n IF emp_cur%FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || emp_rec.first_name || &#39; &#39; || \n emp_rec.last_name || &#39; - &#39; || emp_rec.email); \n ELSE \n  DBMS_OUTPUT.PUT_LINE(&#39;No matching employee for the given ID&#39;);\n END IF; \n CLOSE emp_cur; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given emp ID’); \nEND; \n\n\nHow It WorksThe %ROWTYPE attribute represents an entire database table row as a record type. Each of thecorresponding table columns is represented within the record as a variable, and each variable in therecord inherits its type from the respective table column.Using the %ROWTYPE attribute offers several advantages to declaring each variable individually. Forstarters, declaring a single record type is much more productive than declaring several local variables tocorrespond to each of the columns of a table. Also, if any of the table columns’ datatypes is everadjusted, then your code will not break because the %ROWTYPE attribute works in much the same manneras the %TYPE attribute of a column in that it will automatically maintain the same datatypes as thecorresponding table columns. Therefore, if a column with a type of VARCHAR2(10) is changed toVARCHAR2(100), that change will ripple(vt.在…上形成波痕) through into your record definition.Using %ROWTYPE also makes your code much easier to read because you are not littering(n.乱丢废物) localvariables throughout. Instead, you can use the dot notation to reference each of the different columnsthat the record type returned by %ROWTYPE consists of. For instance, in the Solution, the first_name,last_name, and email columns are referenced from the emp_rec record type. \n2.5. Creating Your Own Records to Receive Query ResultsProblemYou want to query the database, return several columns from one or more tables, and store them intolocal variables of a code block for processing. Rather than placing the values of the columns intoseparate variables, you want to create a single variable that contains all the values.summary: return several columns from one or more tables.\nSolutionCreate a database RECORD containing variables to hold the data you want to retrieve from the database.Since a RECORD can hold multiple variables of different datatypes, they work nicely for grouping data thathas been retrieved as a result of a query.In the following example, the database is queried for the name and position of a player. The datathat is returned is used to populate(vt.居住于；构成人口) a PL&#x2F;SQL RECORD containing three separate variables: first name, lastname, and position. \nDECLARE\n  TYPE emp_info IS RECORD(first employees.first_name%TYPE, \n                         last employees.last_name%TYPE, \n                         email employees.email%TYPE); \n  emp_info_rec emp_info;  -- 用emp_info 类型定义了emp_info_rec变量\n\nBEGIN \n SELECT first_name, last_name, email \n INTO emp_info_rec \n FROM employees \n WHERE last_name &#x3D; &#39;Vargas&#39;; \n DBMS_OUTPUT.PUT_LINE(&#39;The queried employee&#39;&#39;s email address is &#39; || emp_info_rec.email); \n EXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); \nEND; \n\nHow It WorksRecords are useful for passing similar data around within an application, but they are also quite usefulfor simply retrieving data and organizing it nicely as is the case with the Solution to this recipe. To createa record, you first declare a record TYPE. This declaration can consist of one or more different datatypesthat represent columns of one or more database tables. Once the record type is declared, you create avariable and define it as an instance of the record type. This variable is then used to populate and work with the data stored in the record. \nCursor work very well with records of data. When declaring a cursor, you can select particularcolumns of data to return into your record. The record variable then takes on the type of cursor%ROWTYPE.In the following example, a cursor is used to determine which fields you want to return from EMPLOYEES.That cursor’s %ROWTYPE attribute is then used to define a record variable that is used for holding thequeried data. \nDECLARE\n CURSOR emp_cur IS \n SELECT first_name, last_name, email \n FROM employees \n WHERE employee_id &#x3D; 100; \n emp_rec emp_cur%ROWTYPE; \nBEGIN \n OPEN emp_cur; \n FETCH emp_cur INTO emp_rec; \n IF emp_cur %FOUND THEN \nCLOSE emp_cur; \n DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || \n &#39;&#39;&#39;s email is &#39; || emp_rec.email); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the provided ID number&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); \nEND; \nAs you can see in this example, the cursor %ROWTYPE attribute creates a record type using thecolumns that are queried by the cursor. The result is easy-to-read code that gains all the positive effectsof declaring record types via the %ROWTYPE attribute. \n2.6. Looping Through Rows from a QueryProblemA query that you are issuing to the database will return many rows. You want to loop through those rowsand process them accordingly. \nSolution #1There are a couple of different Solutions for looping through rows from a query. One is to work directlywith a SELECT statement and use a FOR loop along with it. In the following example, you will see thistechnique in action:\nSET SERVEROUTPUT ON; \nBEGIN \n FOR emp IN \n ( \n SELECT first_name, last_name, email \n FROM employees \n WHERE commission_pct is not NULL \n ) \n LOOP \n DBMS_OUTPUT.PUT_LINE(emp.first_name || &#39; &#39; || emp.last_name || &#39; - &#39; || emp.email); \n END LOOP; \nEND; \n\nSolution #2Similarly, you can choose to use a FOR loop along with a cursor. Here’s an example: \nSET SERVEROUTPUT ON; \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, email \n FROM employees \nWHERE commission_pct is not NULL; \n      emp_rec emp_cur%ROWTYPE;\nBEGIN \n FOR emp_rec IN emp_cur LOOP \n DBMS_OUTPUT.PUT_LINE( \n emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_rec.email); \n END LOOP; \nEND; \n\nHow It WorksThe loop that is used in the first Solution is also known as an implicit(adj.含蓄的,暗示的) cursor FOR loop. No variables need to be explicitly defined in that Solution, because the FOR loop will automatically create a record using the results of the query. That record will take the name provided in the FOR variable_name IN clause. Thatrecord variable can then be used to reference the different columns that are returned by the query. As demonstrated in the second Solution to this recipe, a cursor is also a very useful way to loop through the results of a query. This technique is also known as an explicit cursor FOR loop. This technique is very similar to looping through the results of an explicitly listed query. Neither Solution requires you to explicitly open and close a cursor. In both cases, the opening andclosing is done on your behalf by the FOR loop processing. As you can see, the FOR loop with the SELECT query in the first example is a bit more concise(adj.简明的,简洁的), and there are fewer lines of code. The first example also contains no declarations. In the second example, with the cursor, there are two declarations that account for more lines of code. However, using the cursor is a standard technique that provides for more reusable code. For instance, you can elect to use the cursor any number of times, and you’ll need to write the query only once when declaring the cursor. On the contrary, if you wanted to reuse the query in the first example, then you would have to rewrite it,and having to write the same query multiple times opens the door to errors and inconsistencies. We recommend Solution #2. \n2.7. Obtaining Environment and Session InformationProblemYou want to obtain environment and session information such as the name and IP address of thecurrent user so that the values can be stored into local variables for logging purposes.SolutionMake use of the SYS_CONTEXT() built-in function to query the database for the user’s information. Once youhave obtained the information, then store it into a local variable. At that point, you can do whateveryou’d like with it, such as save it in a logging table. The following code block demonstrates thistechnique: \n&lt;&lt;obtain_user_info&gt;&gt;\nDECLARE \n  username varchar2(100); \n  ip_address varchar2(100); \nBEGIN\n  SELECT SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), SYS_CONTEXT(&#39;USERENV&#39;,&#39;IP_ADDRESS&#39;) \n  INTO username, ip_address \n  FROM DUAL; \n  DBMS_OUTPUT.PUT_LINE(&#39;The connected user is: &#39; || username || &#39;, and the IP address\n  is &#39; || \n  ip_address); \nEND; \nOnce this code block has been run, then the user’s information should be stored into the localvariables that have been declared within it. \nHow It WorksYou can use the SYS_CONTEXT function to obtain important information regarding the current user’senvironment, among other things. It is often times used for auditing(n.审计;查帐) purposes so that a particular codeblock can grab(vi.攫取;夺取) important information about the connected user such as you’ve seen in the Solution tothis recipe. The SYS_CONTEXT function allows you to define a namespace and then place parameterswithin it so that they can be retrieved for use at a later time. The general syntax for the use ofSYS_CONTEXT is as follows: \nSYS_CONTEXT(&#39;namespace&#39;,&#39;parameter&#39;[,length]) \nA namespace can be any valid SQL identifier, and it must be created using the CREATE_CONTEXTstatement. The parameter must be a string or evaluate to a string, and it must be set using theDBMS_SESSION.SET_CONTEXT procedure. The call to SYS_CONTEXT with a valid namespace and parameterwill result in the return of a value that has a VARCHAR2 datatype. The default maximum length of thereturned value is 256 bytes. However, this default maximum length can be overridden by specifying thelength when calling SYS_CONTEXT. The length is an optional parameter. The range of values for the lengthis 1 to 4000, and if you specify an invalid value, then the default of 256 will be used.The USERENV namespace is automatically available for use because it is a built-in namespaceprovided by Oracle. The USERENV namespace contains session information for the current user. Table 2-1lists the parameters that are available to use with the USERENV namespace.Table 2-1. USERENV Parameter Listing \n-- Parameter          Description \nACTION                Identifies the position in the application name.\nAUDITED_CURSORID      Returns the cursor ID of the SQL that triggered the audit. \nAUTHENTICATED_DATA    Returns the data being used to authenticate the user. \nAUTHENTICATION_TYPE   Identifies how the user was authenticated. \nBG_JOB_ID             If an Oracle Database background process was used to establish the connection, then this returns the job ID of the current session. If no \n                      background process was established, then NULL is returned. \nCLIENT_IDENTIFIER     Returns identifier that is set by the application. \nCLIENT_INFO           Returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. \nCURRENT_SCHEMA        Returns the current session’s default schema.\nCURRENT_SCHEMAID      Returns the current schema’s identifier.\nCURRENT_SQL           Returns the first 4KB of the triggering SQL.\nDB_DOMAIN             Returns the value specified in the DB_DOMAIN parameter. \nDB_NAME               Returns the value specified in the DB_NAME parameter. \nDB_UNIQUE_NAME        Returns the value specified in the DB_UNIQUE_NAME parameter. \nENTRYID               Returns the current audit entry number. \nEXTERNAL_NAME         Returns the external name of the database user. \nFG_JOB_ID             If an Oracle Database foreground process was used to establish the connection, then this returns the job ID of the current session. If no \n                      foreground process was established, then NULL is returned. \nGLOBAL_CONTEXT_MEMORY Returns the number being used by the globally accessed context in the \n                      System Global Area.   \nHOST                  Returns the host name of the machine from which the client has connected. \nINSTANCE              Returns the instance ID number of the current instance. \nIP_ADDRESS            Returns the IP address of the machine from which the client has connected. \nISDBA                 Returns TRUE if the user was authenticated as a DBA. \nLANG                  Returns the ISO abbreviation of the language name. \nLANGUAGE              Returns the language and territory used by the session, along with the \n                      character set. \nMODULE                Returns the application name. This name has to be set via the\n                      DBMS_APPLICATION_INFO package. \nNETWORK_PROTOCOL      Returns the network protocol being used for communication. \nNLS_CALENDAR          Returns the current calendar of the current session. \nNLS_CURRENCY          Returns the currency of the current session. \nNLS_DATE_FORMAT       Returns the date format for the session. \nNLS_DATE_LANGUAGE     Returns the language being used for expressing dates. \nNLS_SORT              Returns the BINARY or linguistic sort basis. \nNLS_TERRITORY         Returns the territory of the current session. \nOS_USER               Returns the operating system user name of the client that initiated the \n                      session. \nPROXY_USER            Returns the name of the database that opened the current session on behalf \n                      of SESSION_USER. \nPROXY_USERID          Returns the identifier of the database user who opened the current session on behalf of the SESSION_USER. \nSERVICE_NAME          Returns the name of the service to which a given session is connected. \nSESSION_USER          Returns the database user name through which the current user is authenticated. \nSESSION_USERID        Returns the identifier of the database user name by which the current user is authenticated. \nSESSIONID             Returns the auditing session identifier. \nSTATEMENTID           Returns the auditing statement identifier. \nTERMINAL              Returns the operating system identifier for the client of the current session. \nWhen SYS_CONTEXT is used within any query, it is most commonly issued against the DUAL table. TheDUAL table is installed along with the data dictionary when the Oracle Database is created. This table isreally a dummy(adj.虚拟的,假的) table that contains one column that is appropriately named DUMMY. This column containsthe value X.\nSQL&gt; desc dual;\n Name Null? Type \n ----------------------------------------- -------- ---------------------------- \nDUMMY VARCHAR2(1) \nAmong other things, DUAL is useful for obtaining values from the database when no actual table isneeded. Our Solution case is such a situation.\n2.8. Formatting Query ResultsProblemYour boss asks you to print the results from a couple of queries in a nicely formatted manner.SolutionUse a combination of different built-in formatting functions along with the concatenation operator (||)to create a nice-looking basic report. The RPAD and LPAD functions along with the concatenation operatorare used together in the following example that displays a list of employees from a company: \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, phone_number \n FROM employees; \n emp_rec employees%ROWTYPE; \nBEGIN \n FOR emp_rec IN emp_cur LOOP \n IF emp_rec.phone_number IS NOT NULL THEN \n DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 35,&#39;.&#39;) || \n emp_rec.phone_number); \n ELSE \n DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || \n &#39; does not have a phone number.&#39;); \n END IF; \n END LOOP; \nEND; \nThe following is another variant of the same report, but this time dashes are used instead of using \ndots to space out the report: \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, phone_number \n FROM employees; \n emp_rec employees%ROWTYPE; \nBEGIN \n FOR emp_rec IN emp_cur LOOP \n  IF emp_rec.phone_number IS NOT NULL THEN\n  --CHECK FOR INTERNATIONAL PHONE NUMBERS\n        IF length(emp_rec.phone_number) &gt; 12 THEN\n          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,18));\n        ELSE\n          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,12));\n        END IF;\n      ELSE\n        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;does not have a phone number.&#39;);\n    END IF;\n  END LOOP;\nEND;\n\nHow It WorksThe RPAD and LPAD functions are used to return the data in a formatted manner. The RPAD function takes astring of text and pads it on the right by the number of spaces provided by the second parameter. Thesyntax for the RPAD function is as follows:\nRPAD(input_text, n, character) -- append n piece characters on the right\n\nIn this syntax, n is the number of spaces used to pad. Similarly, the LPAD function pads on the left ofthe provided string. The syntax is exactly the same as RPAD; the only difference is the direction of thepadding. The combination of these two functions, along with the concatenation operator (||), providesfor some excellent formatting options.  \nIt is important to look at the data being returned before you try to format it, especially to considerwhat formatting options will look best when generating output for presentation. In the case of theexamples in this recipe, the latter example would be the most reasonable choice of formatting for thedata being returned, since the phone number includes dots in it. The first example uses dots to space outthe report, so too many dots may make the output difficult to read. Know your data, and then choose theappropriate PL&#x2F;SQL built-ins to format accordingly.  \nNote When using DBMS_OUTPUT to display data, please be sure to pay attention to the size of the buffer. You canset the buffer size from 2,000 to 1,000,000 bytes by passing the size you desire to the DBMS_OUTPUT.ENABLE procedure.If you attempt to display content over this size limit, then Oracle will raise an exception.\nOracle provides a number of built-in functions to use when formatting strings. Two others that areespecially useful are LTRIM(&lt;string&gt;) and RTRIM(&lt;string&gt;). These remove leading and trailing spaces,respectively. See your Oracle SQL Reference manual for a complete list of available string functions.\n2.9. Updating Rows Returned by a QueryProblem  You’ve queried the database and retrieved a row into a variable. You want to update some valuescontained in the row and commit them to the database.Solution  First, retrieve the database row that you want to update. Second, update the values in the row that needto be changed, and then issue an UPDATE statement to modify the database with the updated values. Inthe following example, a procedure is created that queries a table of employees for a particularemployee. The resulting employee’s department ID is then updated with the new one unless theemployee is already a member of the given department.\nCREATE OR REPLACE PROCEDURE change_emp_dept(emp_id IN NUMBER, \n dept_id IN NUMBER) AS \n emp_row employees%ROWTYPE; \n dept departments.department_name%TYPE; \n rec_count number :&#x3D; 0; \nBEGIN \n SELECT count(*) \n INTO rec_count \n FROM employees \n WHERE employee_id &#x3D; emp_id; \n IF rec_count &#x3D; 1 THEN \n SELECT * \n INTO emp_row \n FROM employees \n WHERE employee_id &#x3D; emp_id; \n IF emp_row.department_id !&#x3D; dept_id THEN \n emp_row.department_id :&#x3D; dept_id; \n UPDATE employees SET ROW &#x3D; emp_row \n WHERE employee_id &#x3D; emp_id; \n SELECT department_name \n INTO dept \n from departments \n WHERE department_id &#x3D; dept_id; \n DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || emp_row.first_name || &#39; &#39; || \n emp_row.last_name || &#39; is now in department: &#39; || dept); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;The employee is already in that department...no change&#39;); \n END IF; \nELSIF rec_count &gt; 1 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The employee ID you entered is not unique&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;No employee records match the given employee ID&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Invalid employee or department ID, try again&#39;); \n WHEN OTHERS THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Unsuccessful change, please check ID numbers and try again&#39;); \nEND; \nAs you can see, the example queries the database into a record declared using the %ROWTYPEattribute. The value that needs to be updated is then modified using the data contained in the record.Lastly, using the SET ROW clause updates the table with the modified record.How It WorksAs you’ve seen in the Solution to the recipe, it is possible to update the values of a row returned by aquery using the UPDATE...SET ROW syntax. In many cases, using a single UPDATE statement can solve thistype of transaction. However, in some scenarios where you need to evaluate the current value of aparticular column, then this Solution is the correct choice.\nUsing the UPDATE ROW statement, you can update entire database rows with a single variable of eitherthe %ROWTYPE or RECORD type. The UPDATE statement also allows you to return values after the update byadding the RETURNING clause to the end of the statement followed(v.跟着,听从) by the column names to return and thevariables that will receive their values. Take a look at this next example:\nDECLARE\n first        employees.first_name%TYPE; \n last         employees.last_name%TYPE; \n new_salary   employees.salary%TYPE; \nBEGIN \n UPDATE employees \n SET salary &#x3D; salary + (salary * .03) \n WHERE employee_id &#x3D; 100  RETURNING first_name, last_name,salary INTO first, last, new_salary; \n DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || first || &#39; &#39; || last || &#39; now has a salary of: &#39; || new_salary); \nEND; \nAs you can see, the example outputs the new values that are the result of the update statement.Using the RETURNING clause saves a step in that you are not required to requery the table after the updatein order to display the updated results.\n2.10. Updating Rows Returned by a CursorProblemYou’ve created a cursor to use for querying your data. You want to loop through the results using a cursor for loop and update the data as needed.SolutionUse the WHERE_CURRENT_OF clause within your loop to update the current data row in the iteration. In thefollowing example, the EMPLOYEES table is queried for all employees in a particular department. Theresults of the query are then iterated using a FOR loop, and the salary is increased for each employeerecord that is returned.\n\nDECLARE \n CURSOR emp_sal_cur IS \n SELECT * \n FROM employees \n WHERE department_id &#x3D; 60 \n FOR UPDATE;        --cursor should use &#96;FOR UPDATE&#96; clause statement\n\n emp_sal_rec emp_sal_cur%ROWTYPE; -- cursor also would define varable using ROWTYPE keyword\n\n BEGIN \n FOR emp_sal_rec IN emp_sal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;Old Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); \n    UPDATE employees \n    SET salary &#x3D; salary + (salary * .025) \n    WHERE CURRENT OF emp_sal_cur;  -- current of your_cursor\n END LOOP; \n\n -- Display the updated salaries \n FOR emp_sal_rec IN emp_sal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;New Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); \n END LOOP; \nEND;\n\nAn update on the EMPLOYEES table occurs with each iteration of the loop. The second loop in thisexample simply displays the new salary result for each employee that was returned by the cursor query.How It WorksUpdating values when iterating a cursor can be handy(adj.便利的,手边的), especially when working with a number of(大量) rows.There is one main difference between a cursor that allows updating and one(cursor) that does not. Thatdifference is the addition of the FOR UPDATE clause in the cursor declaration. By using the FOR UPDATEclause of the SELECT statement, you are causing the database to lock the rows that have been read by thequery. This lock is to ensure that nobody else can modify the rows while you are working with them. Thelock creates a read-only block on the table rows so that if someone else attempts to modify them whileyou have them locked, then they will have to wait until you have performed either a COMMIT or a ROLLBACK.The FOR UPDATE clause has an optional NOWAIT keyword. By including this keyword, you will ensurethat your query does not block your transaction if someone else already has the rows that you arequerying blocked. The NOWAIT keyword tells Oracle not to wait if the requested rows are already locked,and control is immediately passed back to your program so that it can continue to run. If the NOWAITkeyword is omitted and the rows are already locked, then your program will stop and wait until the lockhas been released.\nYou can use the cursor with any style of loop, as you’ve seen in previous recipes. No matter whichtype of loop you choose, the UPDATE must be coded using the WHERE CURRENT OF your_cursor clause to update thecurrent row in the cursor iteration. You will need to be sure to commit the changes after this block hasbeen run, and in many circumstances the COMMIT statement can be coded into this block once it has beentested and verified to work correctly. As with any UPDATE statement, if you fail to COMMIT your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to yourschema only until you disconnect. Issuing a COMMIT after your UPDATE statements have been issued is alsoa good practice in this case because it will release the lock on the rows you had queried via the cursor sothat someone else can update them if needed. If you determine the data that was updated by the codeblock is incorrect, then a ROLLBACK will also release the lock.\n\n\nsummary:\n\nif you wanna update data of cursor that returned by select, you can use WHERE CURRENT OF emp_sal_cur and for update\nBy using the FOR UPDATE clause of the SELECT statement,data lock is data level\nwether FOR UPDATE clause update table data or cursor only?(it should be commit changes for table)\nif you fail to COMMIT your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to yourschema only until you disconnec\nCOMMIT and ROLLBACK either release lock\n\n \n\n2.11. Deleting Rows Returned by a CursorProblemThere are a series of database rows that you’d like to delete. You’ve created a cursor FOR LOOP, and you want to delete some or all rows that have been queried with the cursor.SolutionUse a DELETE statement within a FOR LOOP to delete the rows that are retrieved by the cursor. If you create a cursor using the FOR UPDATE clause, then you will be able to use the WHERE CURRENT OF clause along with the DELETE statement to eliminate the current row within each iteration of the cursor. The following example shows how this can be done to remove all job history for a given department ID:\nCREATE OR REPLACE PROCEDURE remove_job_history(dept_id IN NUMBER) AS \n\n CURSOR job_history_cur IS \n SELECT * \n FROM job_history \n WHERE department_id &#x3D; dept_id \n FOR UPDATE; \n    job_history_rec job_history_cur%ROWTYPE; \n BEGIN \n  FOR job_history_rec IN job_history_cur LOOP \n    DELETE FROM job_history WHERE CURRENT OF job_history_cur; \n    DBMS_OUTPUT.PUT_LINE(&#39;Job history removed for department &#39; || dept_id); \n  END LOOP; \nEND; \nUsing this technique, the job history for the department with the given ID will be removed from the JOB_HISTORY table.\nHow It WorksMuch like updating rows using a cursor, the deletion of rows uses the WHERE CURRENT OF clause within the DELETE statement to remove each row. The cursor query must contain the FOR UPDATE clause in order to lock the rows that you are reading until a COMMIT or ROLLBACK has been issued. As mentioned in the previous recipe, the NOWAIT keyword is optional, and it can be used to allow control to be immediately returned to your program if someone else already has locks on the rows that you are interested in updating. In each iteration of the loop, the DELETE statement is used along with the WHERE CURRENT OF clause to remove the current cursor record from the database. Once the loop has been completed, then all the rows that had been queried via the cursor should have been deleted. This technique is especially useful if you are going to be performing some further processing on each of the records and then deleting them. One such case would be if you wanted to write each of the records to a history table prior to deleting them. In any case, the cursor FOR loop deletion technique is a great way to remove rows from the database and work with the data along the way.\n2.12. Performing a TransactionProblemYou need to complete a series of INSERT or UPDATE statements in order to process a complete transaction. In doing so, you need to ensure that if one of the statements fails, that all of the statements are canceled so that the transaction is not partially processed.SolutionUse the transaction control mechanisms that are part of PL&#x2F;SQL, as well as SQL itself, in order to control your transactions. When all your statements have been completed successfully, issue a COMMIT to make them final. On the other hand, if one of the statements does not complete successfully, then perform a ROLLBACK to undo all the other changes that have been made and bring the database back to the state that it was in prior(美[‘praɪɚ],adj.优先的,在先的,在前的) to the transaction occurring.In the following example, the code block entails the body of a script that is to be executed in order to create a new department and add some employees to it. The department change involves an INSERT and UPDATE statement to complete.\nDECLARE\n -- Query all programmers who make more than 4000 \n -- as they will be moved to the new &#39;Web Development&#39; department \n CURSOR new_dept_cur IS \n    SELECT * \n    FROM employees \n    WHERE job_id &#x3D; &#39;IT_PROG&#39;\n    AND salary &gt; 4000 \n    FOR UPDATE; \n new_dept_rec         new_dept_cur%ROWTYPE; \n current_department   departments.department_id%TYPE; \nBEGIN \n -- Create a new department \n INSERT INTO departments values( \n                                DEPARTMENTS_SEQ.nextval, -- Department ID (sequence value) \n                                &#39;Web Development&#39;, -- Department Title \n                                103 -- Manager ID \n                                1700); -- Location ID \n -- Obtain the current department ID…the new department ID \n SELECT DEPARTMENTS_SEQ.currval \n INTO current_department \n FROM DUAL; \n\n -- Assign all employees to the new department \n FOR new_dept_rec IN new_dept_cur LOOP \n      UPDATE employees \n      SET department_id &#x3D; current_department \n      WHERE CURRENT OF new_dept_cur; \n END LOOP;\n\n COMMIT;\n      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); \nEND;\nAs you can see, a transaction was performed in this block of code. It is important to roll back changes if errors occur along the way so that the transaction is not partially completed.\nHow It WorksTransaction control is built into the Oracle Database. Any database changes that are made within a code block are visible to the current session only until a COMMIT has been made. The changes that have been made by the statements can be rolled back via the ROLLBACK command up until the point that a COMMIT is issued. Oracle uses table and row locks to ensure that data that has been updated in one session cannot be seen in another session until a COMMIT occurs. A transaction is started when the first statement after the last COMMIT or ROLLBACK is processed or when a session is created. It ends when a COMMIT or ROLLBACK occurs. A transaction is not bound to a single code block, and any code block may contain one or more transactions. Oracle provides a SAVEPOINT command, which places a marker at the current database state so as to allow you to roll back to that point in time in a transaction. Oracle Database automatically issues a SAVEPOINT prior to processing the first statement in any transaction.\nAs a rule of thumb, it is always a good idea to have exception handling in place in case an exceptionoccurs. However, if an unhandled exception occurs, then the database will roll back the statement that caused the exception, not the entire transaction. Therefore, it is up to the program to handle exceptions and issue the ROLLBACK command if the entire transaction should be undone. If a database crashes and goes down during a transaction, then when the database is restarted, all uncommitted statements are rolled back. All transactions are completed when a COMMIT or ROLLBACK is issued.\n2.13. Ensuring That Multiple Queries “See” the Same DataProblemYou are issuing a set of queries against the database, and you need to ensure that none of the table rows change throughout the course of the queries being made.SolutionSet up a read-only transaction in which the current transaction will see the data only as an unchanged snapshot in time. To do so, use the SET TRANSACTION statement to begin a read-only transaction and establish a snapshot of the data so it will be consistent and unchanged from all other updates being made. For instance, the following example displays a block that sets up read-only queries against the database for dollar values from a bank account:\nDECLARE \n daily_atm_total NUMBER(12,2); \n weekly_atm_total NUMBER(12,2); \nBEGIN \n COMMIT; -- ends previous transaction \n SET TRANSACTION READ ONLY NAME &#39;ATM Weekly Summary&#39;; \n SELECT SUM (wd_amt) INTO daily_atm_total FROM atm_withdrawals \n WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE, &#39;MM-DD-YYYY&#39;); \n SELECT SUM (weekly_total) INTO weekly_atm_total FROM atm_withdrawals \n WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE - 7, &#39;MM-DD-YYYY&#39;); \n DBMS_OUTPUT.PUT_LINE(daily_atm_total || &#39; - &#39; || weekly_atm_total); \n COMMIT; -- ends read-only transaction \nEND; \nQuerying the database using read-only transactions will ensure that someone will see the correct values in a situation such as the one depicted(vt.描述,描画) in this example.\nHow It Worksoften times there are situations when you need to ensure that the data being queried throughout a transaction’s life cycle is unchanged by other users’ updates. The classic case is when someone goes to withdraw money from the bank and their spouse(n.配偶) is at an ATM machine depositing into the account at the same time. If read consistency were not in place, the individual may view their account balance and see that there was plenty of money to withdraw, and then they’d go to take the money out and receive an error because the spouse had canceled the deposit(美 [dɪ’pɑzɪt]n.存款,押金) instead. A read-only transaction allows for read consistency until a COMMIT has been issued. If the spouse had confirmed the deposit, then the next query on the account would reflect the additional funds (assuming that the bank were to release them to the account in real time).Situations such as these require that you provide an environment that is essentially isolated from the outside world. You can use the SET TRANSACTION command to start a read-only transaction, set an isolation level, and assign the current transaction to a rollback segment. The SET TRANSACTION statement must be the first statement in a read-only transaction, and it can appear only once in the transaction. Note that there are some statement restrictions when using a read-only transaction. Only SELECT INTO, OPEN, FETCH, CLOSE, LOCK TABLE, COMMIT, and ROLLBACK statements can be used; other statements are not allowed.\n2.14. Executing One Transaction from Within Another(nested tracsaction)ProblemYou are executing a transaction, and you are faced with the need to suspend your current work, issue a completely separate transaction, and then pick up your current work. For example, say you want to log entries into a log table. The log entries should be persisted separately from the current transaction such that if the transaction fails or is rolled back, the log entries will still be completed.SolutionStart an autonomous transaction to make the log entry. This will ensure that the log entry is performed separately from the current transaction. In the following example, an employee is deleted from the EMPLOYEES table. Hence, a job is ended, and the job history must be recorded into the JOB_HISTORY table. In the case that something fails within the transaction, the log entry into the JOB_HISTORY table must be intact(adj.完整的,原封不动的). This log entry cannot be rolled back because it is performed using an autonomous transaction.The code to encapsulate(美 [ɪn’kæpsjə’let],vt.压缩,将…装入胶囊) the autonomous transaction needs to be placed into a named block that can be called when the logging needs to be performed. The following piece of code creates a PL&#x2F;SQL procedure that performs the log entry using an autonomous transaction. (You will learn more about procedures in Chapter 4.) Specifically notice(n.通知,布告) the declaration of PRAGMA AUTONOMOUS_TRANSACTION. That pragma specifies that the procedure executes as a separate transaction, independent of any calling transaction.\nCREATE OR REPLACE PROCEDURE log_job_history ( emp_id IN \n                                              employees.employee_id%TYPE, \n                                              Job_id IN jobs.job_id%TYPE, \n                                              Department_id IN employees.department_id%TYPE, \n                                              employee_start IN DATE) AS \n  PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN \n INSERT INTO job_history \n VALUES (emp_id, \n employee_start, \n sysdate, \n job_id, \n department_id); \n COMMIT; \nEND;\n\nThe LOG_JOB_HISTORY procedure inserts an entry into the log table separately from the transaction that is taking place in the calling code block. The following code performs the job termination, and it calls the log_substitution procedure to record the history:\nDECLARE\n CURSOR dept_removal_cur IS \n    SELECT * \n    FROM employees \n    WHERE department_id &#x3D; 10 \n    FOR UPDATE; \n dept_removal_rec dept_removal_cur%ROWTYPE; \nBEGIN \n -- Delete all employees from the database who reside in department 10 \n FOR dept_removal_rec IN dept_removal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;DELETING RECORD NOW&#39;); \n    DELETE FROM employees WHERE CURRENT OF dept_removal_cur; \n    -- Log the termination \n    log_job_history(dept_removal_rec.employee_id, \n                      dept_removal_rec.job_id, \n                      dept_removal_rec.department_id, \n                      dept_removal_rec.hire_date);\n END LOOP; \n    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); \nEXCEPTION \n -- Handles all errors \n WHEN NO_DATA_FOUND THEN\n    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been rolled back due to errors, please try again.&#39;); \n    ROLLBACK; \nEND;\nIf this code block is executed and then rolled back, the entry into the job history table remains,because it is performed as a separate, autonomous transaction.How It WorksAn autonomous transaction is a transaction that is called by another transaction and that runs separately from the calling transaction. Autonomous transactions commit or roll back without affecting the calling transaction. They also have the full functionality of regular transactions; they merely(adv.仅仅,只不过,只是) run separately from the main transaction. They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.\nAn autonomous transaction must be created with a top-level code block, trigger, procedure,function, or stand-alone named piece of code. In the Solution, you saw that a procedure was created to run as an autonomous transaction. That is because it is not possible to create an autonomous transaction within a nested code block. To name a transaction as autonomous, you must place the statement PRAGMA AUTONOMOUS_TRANSACTION within the declaration section of a block encompassing(adj.包含的,包容的,环绕) the transaction. To end the transaction, perform a COMMIT or ROLLBACK.\n\n\nsummary: \n\nThey allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.\n\n\n\n2.15. Finding and Removing Duplicate Table RowsProblemYou have found that for some reason your database contains a table that has duplicate records. You areworking with a database that unfortunately does not use primary key values, so you must manually enforce data integrity. You need a way to remove the duplicate records. However, any query you write to remove one record will also remove its duplicate.SolutionThe Solution to this issue involves two steps. First you need to query the database to find all duplicaterows, and then you need to run a statement to delete one of each duplicate record that is found.The following code block queries the EMPLOYEES table for duplicate rows. When a duplicate is found,it is returned along with a count of duplicates found.\n&lt;&lt;duplicate_emp_qry&gt;&gt;\nDECLARE\nCURSOR emp_cur IS\n  SELECT *\n  FROM employees\n  ORDER BY employee_id;\n  emp_count\n  number :&#x3D; 0;\n  total_count\n  number :&#x3D; 0;\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(&#39;You will see each duplicated employee listed more &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;than once in the list below. This will allow you to &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;review the list and ensure that indeed...there are more &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;than one of these employee records in the table.&#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;Duplicated Employees: &#39;);\n-- Loop through each player in the table\nFOR emp_rec IN emp_cur LOOP\n-- Select the number of records in the table that have the same ID as the current record\nSELECT count(*)\nINTO emp_count\nFROM employees\nWHERE employee_id &#x3D; emp_rec.employee_id;\n-- If the count is greater than one then a duplicate has been found, so print it out.\nIF emp_count &gt; 1 THEN \n DBMS_OUTPUT.PUT_LINE(emp_rec.employee_id || &#39; - &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_count); \n total_count :&#x3D; total_count + 1; \n END IF; \n END LOOP; \nEND;\nIf the table includes a duplicate, then it is printed out as follows:You will see each duplicated employee listed more than once in the list below. This will allow you to review the list and ensure that indeed…there are morethan one of these employees in the table.Duplicated Employees:100 - Steven King - 2100 – Steven King - 2PL&#x2F;SQL procedure successfully completed.  \nNext, you need to delete the duplicated rows that have been found. The following DELETE statementwill ensure that one of the duplicates is removed:DELETE FROM employees A WHERE ROWID &gt; (SELECT min(rowid) FROM employees BWHERE A.employee_id &#x3D; B.employee_id);\nHow It WorksUsually using primary keys prohibits the entry of duplicate rows into a database table. However, many legacy databases still in use today do not include such constraints. In rare situations, a duplicate key and values are entered into the database that can cause issues when querying data or assigning values. The method shown in the Solution for finding duplicate rows is very basic. The Solution loops through each record in the table, and during each pass, it queries the table for the number of records found that match the current record’s EMPLOYEE_ID. If the number found is greater than one, then you know that you have found a duplicate. The Solution presented here for finding duplicates will work on any table provided that you have a column of data that should contain logically unique values. In the example, each record should contain a different EMPLOYEE_ID, so if there is more than one record with the same EMPLOYEE_ID value, then a duplicate is found. If the table you are working with does not contain any unique columns, then you can concatenate a number of columns in order to obtain a unique combination. For instance, if EMPLOYEES did not contain an EMPLOYEE_ID column, then you could concatenate the FIRST_NAME, LAST_NAME, and EMAIL columns to obtain a unique combination. More likely than not, there will not be two employees in the table with the same name and e-mail address. The second part of the Solution involves removing one or more duplicate records from the set. To do so, you have to look at a pseudocolumn known as the ROWID. The ROWID is a pseudocolumn (invisible column) that is found in each table in an Oracle Database that uniquely identifies each row. By comparing these unique ROWID values, you can delete just one of the records, not both. The DELETE statement actually finds the rows that contain the same uniquely identified column(s) and then removes the row with the larger ROWID value.\n","dateCreated":"2022-11-08T23:12:45+08:00","dateModified":"2022-11-08T23:38:30+08:00","datePublished":"2022-11-08T23:12:45+08:00","description":"摘要: 其实这个讲PLSQL有点基础","headline":"Oracle PLSQL Recipes 02-基础sql","image":[null,"https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_02/"},"publisher":{"@type":"Organization","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_02/","thumbnailUrl":"https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"}</script>
    <meta name="description" content="摘要: 其实这个讲PLSQL有点基础">
<meta property="og:type" content="blog">
<meta property="og:title" content="Oracle PLSQL Recipes 02-基础sql">
<meta property="og:url" content="https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_02/index.html">
<meta property="og:site_name" content="CoffeeMan">
<meta property="og:description" content="摘要: 其实这个讲PLSQL有点基础">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png">
<meta property="article:published_time" content="2022-11-08T15:12:45.815Z">
<meta property="article:modified_time" content="2022-11-08T15:38:30.375Z">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/avatar.jpg"/>
    
    
    
        <meta property="og:image" content="https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-y9io9e1ok9lpsmk4fyk7quzstdgr6eztu8x2xr6n9iikjgfjbcqqpobdlqy8.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CoffeeMan
        </a>
    </div>
    
        
            <a
                class="header-right-picture open-algolia-search"
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/SimonTeo58"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/11289672/simon-teo"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/shiming_kirk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/kirk-zhang-424935235/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/zxc741208584@qq.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    "
             style="background-image:url('https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg');"
             data-behavior="2">
            
        </div>

            <div id="main" data-behavior="2"
                 class="hasCover
                        hasCoverMetaOut
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Oracle PLSQL Recipes 02-基础sql
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-11-08T23:12:45+08:00">
	
		    Nov 08, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/oracle/">oracle</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>摘要: 其实这个讲PLSQL有点基础</p>
<span id="more"></span>

<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E7%A1%80sql"><span class="toc-text">2.基础sql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Retrieving-a-Single-Row-from-the-Database"><span class="toc-text">2.1 Retrieving a Single Row from the Database</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Qualifying-Column-and-Variable-Names%EF%BC%88%E5%8F%98%E9%87%8F%E5%92%8C%E8%A1%A8%E5%88%97%E5%90%8D%E7%9B%B8%E5%90%8C"><span class="toc-text">2.2. Qualifying Column and Variable Names（变量和表列名相同)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Declaring-Variable-Types-That-Match-Column-Types"><span class="toc-text">2.3. Declaring Variable Types That Match Column Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record"><span class="toc-text">2.4. Returning Queried Data into a PL&#x2F;SQL Record</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Creating-Your-Own-Records-to-Receive-Query-Results"><span class="toc-text">2.5. Creating Your Own Records to Receive Query Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Looping-Through-Rows-from-a-Query"><span class="toc-text">2.6. Looping Through Rows from a Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Obtaining-Environment-and-Session-Information"><span class="toc-text">2.7. Obtaining Environment and Session Information</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Formatting-Query-Results"><span class="toc-text">2.8. Formatting Query Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-Updating-Rows-Returned-by-a-Query"><span class="toc-text">2.9. Updating Rows Returned by a Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-Updating-Rows-Returned-by-a-Cursor"><span class="toc-text">2.10. Updating Rows Returned by a Cursor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-Deleting-Rows-Returned-by-a-Cursor"><span class="toc-text">2.11. Deleting Rows Returned by a Cursor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-Performing-a-Transaction"><span class="toc-text">2.12. Performing a Transaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-Ensuring-That-Multiple-Queries-%E2%80%9CSee%E2%80%9D-the-Same-Data"><span class="toc-text">2.13. Ensuring That Multiple Queries “See” the Same Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-Executing-One-Transaction-from-Within-Another"><span class="toc-text">2.14. Executing One Transaction from Within Another</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-Finding-and-Removing-Duplicate-Table-Rows"><span class="toc-text">2.15. Finding and Removing Duplicate Table Rows</span></a></li></ol></li></ol>



<h1 id="2-基础sql"><a href="#2-基础sql" class="headerlink" title="2.基础sql"></a>2.基础sql</h1><p><img src="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png" alt="图文无关,在写文章时听张学友的歌"></p>
<h2 id="2-1-Retrieving-a-Single-Row-from-the-Database"><a href="#2-1-Retrieving-a-Single-Row-from-the-Database" class="headerlink" title="2.1 Retrieving a Single Row from the Database"></a>2.1 Retrieving a Single Row from the Database</h2><p><strong><strong>Problem</strong></strong></p>
<p>You are interested in returning one row from a database table via a query that searches for an exact<br>match.</p>
<p><strong><strong>Solution</strong> 1</strong><br>你可以使用<code>select ... into ...</code>语法</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
    first VARCHAR2(20);  -- varchar2(20)一定是要兼容的数据库表字段的
    last VARCHAR2(25); 
    email VARCHAR2(25); 
BEGIN 
    SELECT first_name, last_name, email 
    INTO first, last, email 
    FROM employees 
    WHERE employee_id &#x3D; 100; 
    DBMS_OUTPUT.PUT_LINE( 
    &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); 
EXCEPTION 
WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given ID&#39;); 
WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE(&#39;More than one employee matches the given ID&#39;); 
END; </code></pre>

<p><strong><strong>Solution</strong> 2</strong></p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR emp_cursor IS 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE employee_id &#x3D; &amp;emp_id; 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 OPEN emp_cursor; 
 FETCH emp_cursor INTO first, last, email; 
 IF emp_cursor%NOTFOUND THEN 
      RAISE NO_DATA_FOUND; 
 ELSE 
 -- Perform second fetch to see if more than one row is returned 
    FETCH emp_cursor INTO first, last, email; 
    IF emp_cursor%FOUND THEN 
      RAISE TOO_MANY_ROWS; 
    ELSE 
      DBMS_OUTPUT.PUT_LINE( 
      &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); 
      END IF;
 END IF; 
CLOSE emp_cursor; 
</code></pre>

<p><strong><strong>How It Works</strong></strong></p>
<p><strong>Solution</strong> 1: One is to issue a SELECT…INTO statement,which is a statement designed to return just one row.<br>The other approach is to open a cursor, fetch the  one row, and close the cursor<br><strong>Solution</strong> 2: We keep an open mind on that point. Consider that if youare expecting exactly one row to be<br>returned, getting multiple rows back represents an exception case that you must somehow deal with.<br>The cursor-based <strong>Solution</strong> makes it easy to simply ignore that exception case, but ignoring a condition<br>that you do not expect to occur does not change the fact that it has occurred. Although a cursor is used,<br>the cases where no data is returned or where too many rows are returnedgiven the user-supplied EMPLOYEE_ID<br>still remain a reality. However, since cursors are specifically designed to deal with zero rows or more<br>than one row coming back from a query, no exceptions will be raised if these situations occur. For this reason,<br><strong>Solution</strong> #2 contains some conditional logic that is used to manually raise the desired exceptions.In the event that the user supplies the block with an invalid EMPLOYEE_ID, the cursor will not fetch any data. The %NOTFOUND attribute of the cursor will be checked to see whether the cursor successfully fetched data. If not, then the NO_DATA_FOUND exception is raised. If the cursor is successful in retrieving data, then a second FETCH statement is issued to see whether more than<br>one row will be returned. If more than one row is returned, then the TOO_MANY_ROWS exception is raised;<br>otherwise, the expected output is displayed. In any event, the output that is displayed using either of the<br><strong>Solution</strong>s will be the same whether successful or not.</p>
<h2 id="2-2-Qualifying-Column-and-Variable-Names（变量和表列名相同"><a href="#2-2-Qualifying-Column-and-Variable-Names（变量和表列名相同" class="headerlink" title="2.2. Qualifying Column and Variable Names（变量和表列名相同)"></a>2.2. Qualifying Column and Variable Names（变量和表列名相同)</h2><p><strong><strong>Problem</strong></strong><br>You have a variable and a column sharing the same name. You want to refer to both in the same SQL<br>statement.<br>For example, you decide that you’d like to search for records where LAST_NAME is not equal to a last<br>name that is provided by a user via an argument to a procedure call. Suppose you have declared a<br>variable LAST_NAME, and you want to alter the query to read as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SELECT first_name, last_name, email
 INTO first, last, email 
 FROM employees 
WHERE last_name &#x3D; last_name; </code></pre>
<p>How does PL&#x2F;SQL know which LAST_NAME you are referring to since both the table column name and<br>the variable name are the same? You need a way to differentiate your references. </p>
<p><strong><strong>Solution</strong></strong><br>You can use the dot notation to fully qualify the local variable name with the procedure name so that<br>PL&#x2F;SQL can differentiate between the two. The altered query, including the fully qualified<br>procedure_name.variable <strong>Solution</strong>, would read as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE retrieve_emp_info(last_name IN VARCHAR2) AS 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 SELECT first_name, last_name, email 
 INTO first, last, email 
 FROM employees 
 WHERE last_name &#x3D; retrieve_emp_info.last_name; 
 DBMS_OUTPUT.PUT_LINE( 
 &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last_name || &#39; - &#39; || email); 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name &#39; || last_name); 
END; </code></pre>

<p><strong><strong>How It Works</strong></strong></p>
<p>PL&#x2F;SQL name re<strong>Solution</strong>(方法) becomes very important in circumstances such as these, and by fully qualifying<br>the names, you can be sure that your code will work as expected. The <strong>Solution</strong> used dot notation to fully<br>qualify the variable name. </p>
<p>The column name could have been qualified with the table name, as in EMPLOYEES.LAST_NAME.<br>However, there’s no need to qualify the column name in this case. Because the reference occurs within a<br>SELECT, the closest re<strong>Solution</strong> for LAST_NAME becomes the table column of that name. So, in this particular<br>case, it is necessary only to qualify references to variable names in the enclosing PL&#x2F;SQL block. </p>
<p>If you are executing a simple BEGIN…END block, then you also have the option of fully qualifying the<br>variable using the dot notation along with the block label. For the purposes of this demonstration, let’s<br>say that the code block shown in the <strong>Solution</strong> was labeled &lt;<emp_info>&gt;. You could then fully qualify a<br>variable named description as follows: </p>
<pre class="language-text" data-language="text"><code class="language-text">side note:
</code></pre>

<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;emp_info&gt;&gt;
DECLARE 
 last_name VARCHAR2(25) :&#x3D; &#39;Fay&#39;; 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 SELECT first_name, last_name, email 
 INTO first, last, email 
 FROM employees 
 WHERE last_name &#x3D; emp_info.last_name; 
END; </code></pre>

<p>In this example, the LAST_NAME that is declared in the code block is used within the SELECT..INTO<br>query, and it is fully qualified with the code block label.</p>
<text style="font-family:Courier New;color:red">

<p>summary: </br></p>
<ol>
<li>while code block contain same variable name as parameter, we could use “procedure”(including package name i though) name qualify parameter name at where clause statement.</li>
<li>actualy you could use table name qualify parameter name in code block, but no more works on it,due to in your select statement,<br>it had been qualified by table name.</li>
<li>and so on , if you use label on your code block, as case shown above</li>
</ol>
</text>

<h2 id="2-3-Declaring-Variable-Types-That-Match-Column-Types"><a href="#2-3-Declaring-Variable-Types-That-Match-Column-Types" class="headerlink" title="2.3. Declaring Variable Types That Match Column Types"></a>2.3. Declaring Variable Types That Match Column Types</h2><p><strong><strong>Problem</strong></strong><br>You want to declare some variables in your code block that match the same datatypes as some columns<br>in a particular table. If the datatype on one of those columns changes, you’d like the code block to<br>automatically update the variable type to match that of the updated column</p>
<p><strong>Note</strong><br>Sharp-eyed readers will notice that we cover this <strong>Problem</strong> redundantly in Chapter 1. We cover this<br><strong>Problem</strong> here as well, because the <strong>Solution</strong> is fundamental to working in PL&#x2F;SQL, especially to working with SQL in<br>PL&#x2F;SQL. We don’t want you to miss what we discuss in this recipe. It is that important.</p>
<p><strong><strong>Solution</strong></strong><br>Use the <code>%TYPE</code> attribute(n.属性) on table columns to identify(v.确定) the types of data that will be returned into your local variables. Instead of providing a hard-coded datatype for a variable, append %TYPE to the database column name. Doing so will apply the datatype from the specified column to the variable you are declaring.</p>
<p>In the following example, the same <code>SELECT INTO</code> query is issued, as in the previous <strong>Problem</strong>, to retrieve an employee record from the database. However, in this case, the variables are declared using the <code>%TYPE</code> attribute rather than designating a specified datatype for each.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  first   employees.first_name%TYPE;
  last    employees.last_name%TYPE;
  email   employees.email%TYPE;
BEGIN 
SELECT 
  first_name, 
  last_name, 
  email INTO first, last, email 
FROM 
  employees 
WHERE 
  employee_id &#x3D; &amp; emp_id;
  DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email);
EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;No matching employee was found, please try again.&#39;);
WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&#39;An unknown error has occured, please try again.&#39;);
END;</code></pre>

<p>As you can see from the <strong>Solution</strong>, the code block looks essentially the same as the one in the previous recipe. The only difference is that here the <code>%TYPE</code> attribute of each database column is being used in order to declare your local variable types.</p>
<p><strong><strong>How It Works</strong></strong><br>The <code>%TYPE</code> attribute can become a significant time-saver and savior for declaring variable types, especially if the underlying database column types are subject(会发生变化) to change. This attribute enables the local variable to assume the same datatype of its corresponding database column type at runtime. Retrieving several columns into local application variables can become tedious(<code>沉闷的</code>) if you need to continually verify that the datatypes of each variable are the same as those of the columns whose data they will consume.The<code>%TYPE</code> attribute can be used when defining variables, constants, fields, and parameters. Using <code>%TYPE</code> assures(<code>保证</code>) that the variables you declare will always remain synchronized with the datatypes of their corresponding columns.</p>
<text style="font-family:Courier New;color:red">
summary: </br>
at all above explained that we could use `%TYPE` attribute to define variable which the same as table datatype
</text>

<h2 id="2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record"><a href="#2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record" class="headerlink" title="2.4. Returning Queried Data into a PL&#x2F;SQL Record"></a>2.4. Returning Queried Data into a PL&#x2F;SQL Record</h2><p><strong><strong>Problem</strong></strong><br>Instead of retrieving only a select few columns via a database query, you’d rather return the entire<br>matching row. It can be a time-consuming task to replicate each of the table’s columns in your<br>application by creating a local variable for each along with selecting the correct datatypes. Although you<br>can certainly make use of the <code>%TYPE</code> attribute while declaring the variables, you’d rather retrieve the<br>entire row into a single object. Furthermore, you’d like the object that the data is going to be stored into<br>to have the ability to assume the same datatypes for each of the columns being returned just as you<br>would by using the <code>%TYPE</code> attribute.<br><strong><strong>Solution</strong></strong><br>Make use of the <code>%ROWTYPE</code> attribute for the particular database table that you are querying. The <code>%ROWTYPE</code><br>attribute returns a record type that represents a database row from the specified table. For instance, the<br>following example demonstrates how the %ROWTYPE attribute can store an entire employee table row for a<br>cursor: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 CURSOR emp_cur IS 
 SELECT * 
 FROM employees 
 WHERE employee_id &#x3D; &amp;emp_id; 
 -- Declaring a local variable using the ROWTYPE attribute 
 -- of the employees table 
 emp_rec employees%ROWTYPE; 
BEGIN 
 OPEN emp_cur; 
 FETCH emp_cur INTO emp_rec; 
 IF emp_cur%FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || emp_rec.first_name || &#39; &#39; || 
 emp_rec.last_name || &#39; - &#39; || emp_rec.email); 
 ELSE 
  DBMS_OUTPUT.PUT_LINE(&#39;No matching employee for the given ID&#39;);
 END IF; 
 CLOSE emp_cur; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given emp ID’); 
END; 
</code></pre>

<p><strong><strong>How It Works</strong></strong><br>The <code>%ROWTYPE</code> attribute represents an entire database table row as a record type. Each of the<br>corresponding table columns is represented within the record as a variable, and each variable in the<br>record inherits its type from the respective table column.<br>Using the <code>%ROWTYPE</code> attribute offers several advantages to declaring each variable individually. For<br>starters, declaring a single record type is much more productive than declaring several local variables to<br>correspond to each of the columns of a table. Also, if any of the table columns’ datatypes is ever<br>adjusted, then your code will not break because the <code>%ROWTYPE</code> attribute works in much the same manner<br>as the <code>%TYPE</code> attribute of a column in that it will automatically maintain the same datatypes as the<br>corresponding table columns. Therefore, if a column with a type of <code>VARCHAR2(10)</code> is changed to<br><code>VARCHAR2(100)</code>, that change will ripple(vt.在…上形成波痕) through into your record definition.<br>Using <code>%ROWTYPE</code> also makes your code much easier to read because you are not littering(n.乱丢废物) local<br>variables throughout. Instead, you can use the dot notation to reference each of the different columns<br>that the record type returned by <code>%ROWTYPE</code> consists of. For instance, in the <strong>Solution</strong>, the <code>first_name</code>,<br><code>last_name</code>, and <code>email</code> columns are referenced from the <code>emp_rec</code> record type. </p>
<h2 id="2-5-Creating-Your-Own-Records-to-Receive-Query-Results"><a href="#2-5-Creating-Your-Own-Records-to-Receive-Query-Results" class="headerlink" title="2.5. Creating Your Own Records to Receive Query Results"></a>2.5. Creating Your Own Records to Receive Query Results</h2><p><strong><strong>Problem</strong></strong><br>You want to query the database, return several columns from one or more tables, and store them into<br>local variables of a code block for processing. Rather than placing the values of the columns into<br>separate variables, you want to create a single variable that contains all the values.<br><text style="font-family:Courier New;color:red"><br>summary: </br><br>return several columns from one or more tables.<br></text></p>
<p><strong><strong>Solution</strong></strong><br>Create a database RECORD containing variables to hold the data you want to retrieve from the database.<br>Since a RECORD can hold multiple variables of different datatypes, they work nicely for grouping data that<br>has been retrieved as a result of a query.<br>In the following example, the database is queried for the name and position of a player. The data<br>that is returned is used to populate(vt.居住于；构成人口) a PL&#x2F;SQL RECORD containing three separate variables: first name, last<br>name, and position. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
  TYPE emp_info IS RECORD(first employees.first_name%TYPE, 
                         last employees.last_name%TYPE, 
                         email employees.email%TYPE); 
  emp_info_rec emp_info;  -- 用emp_info 类型定义了emp_info_rec变量

BEGIN 
 SELECT first_name, last_name, email 
 INTO emp_info_rec 
 FROM employees 
 WHERE last_name &#x3D; &#39;Vargas&#39;; 
 DBMS_OUTPUT.PUT_LINE(&#39;The queried employee&#39;&#39;s email address is &#39; || emp_info_rec.email); 
 EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); 
END; </code></pre>

<p><strong><strong>How It Works</strong></strong><br>Records are useful for passing similar data around within an application, but they are also quite useful<br>for simply retrieving data and organizing it nicely as is the case with the <strong>Solution</strong> to this recipe. To create<br>a record, you first declare a record TYPE. This declaration can consist of one or more different datatypes<br>that represent columns of one or more database tables. Once the record type is declared, you create a<br>variable and define it as an instance of the record type. This variable is then used to populate and work with the data stored in the record. </p>
<p><code>Cursor</code> work very well with records of data. When declaring a cursor, you can select particular<br>columns of data to return into your record. The record variable then takes on the type of cursor%ROWTYPE.<br>In the following example, a cursor is used to determine which fields you want to return from EMPLOYEES.<br>That cursor’s %ROWTYPE attribute is then used to define a record variable that is used for holding the<br>queried data. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR emp_cur IS 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE employee_id &#x3D; 100; 
 emp_rec emp_cur%ROWTYPE; 
BEGIN 
 OPEN emp_cur; 
 FETCH emp_cur INTO emp_rec; 
 IF emp_cur %FOUND THEN 
CLOSE emp_cur; 
 DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || 
 &#39;&#39;&#39;s email is &#39; || emp_rec.email); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the provided ID number&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); 
END; </code></pre>
<p>As you can see in this example, the cursor <code>%ROWTYPE</code> attribute creates a record type using the<br>columns that are queried by the cursor. The result is easy-to-read code that gains all the positive effects<br>of declaring record types via the <code>%ROWTYPE</code> attribute. </p>
<h2 id="2-6-Looping-Through-Rows-from-a-Query"><a href="#2-6-Looping-Through-Rows-from-a-Query" class="headerlink" title="2.6. Looping Through Rows from a Query"></a>2.6. Looping Through Rows from a Query</h2><p><strong><strong>Problem</strong></strong><br>A query that you are issuing to the database will return many rows. You want to loop through those rows<br>and process them accordingly. </p>
<p><strong><strong>Solution</strong> #1</strong><br>There are a couple of different <strong>Solution</strong>s for looping through rows from a query. One is to work directly<br>with a SELECT statement and use a FOR loop along with it. In the following example, you will see this<br>technique in action:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SET SERVEROUTPUT ON; 
BEGIN 
 FOR emp IN 
 ( 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE commission_pct is not NULL 
 ) 
 LOOP 
 DBMS_OUTPUT.PUT_LINE(emp.first_name || &#39; &#39; || emp.last_name || &#39; - &#39; || emp.email); 
 END LOOP; 
END; </code></pre>

<p><strong><strong>Solution</strong> #2</strong><br>Similarly, you can choose to use a FOR loop along with a cursor. Here’s an example: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SET SERVEROUTPUT ON; 
DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, email 
 FROM employees 
WHERE commission_pct is not NULL; 
      emp_rec emp_cur%ROWTYPE;
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
 DBMS_OUTPUT.PUT_LINE( 
 emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_rec.email); 
 END LOOP; 
END; </code></pre>

<p><strong><strong>How It Works</strong></strong><br>The <code>loop</code> that is used in the first <strong>Solution</strong> is also known as an implicit(adj.含蓄的,暗示的) cursor FOR loop. No variables need to be explicitly defined in that <strong>Solution</strong>, because the FOR loop will automatically create a record using the results of the query. That record will take the name provided in the FOR variable_name IN clause. That<br>record variable can then be used to reference the different columns that are returned by the query. As demonstrated in the second <strong>Solution</strong> to this recipe, a cursor is also a very useful way to loop through the results of a query. This technique is also known as an explicit cursor FOR loop. This technique is very similar to looping through the results of an explicitly listed query. Neither <strong>Solution</strong> requires you to explicitly open and close a cursor. In both cases, the opening and<br>closing is done on your behalf by the FOR loop processing. As you can see, the <code>FOR loop</code> with the <code>SELECT query</code> in the first example is a bit more concise(adj.简明的,简洁的), and there are fewer lines of code. The first example also contains no declarations. In the second example, with the cursor, there are two declarations that account for more lines of code. However, using the cursor is a standard technique that provides for more reusable code. For instance, you can elect to use the cursor any number of times, and you’ll need to write the query only once when declaring the cursor. On the contrary, if you wanted to reuse the query in the first example, then you would have to rewrite it,<br>and having to write the same query multiple times opens the door to errors and inconsistencies. We recommend <strong>Solution</strong> #2. </p>
<h2 id="2-7-Obtaining-Environment-and-Session-Information"><a href="#2-7-Obtaining-Environment-and-Session-Information" class="headerlink" title="2.7. Obtaining Environment and Session Information"></a>2.7. Obtaining Environment and Session Information</h2><p><strong><strong>Problem</strong></strong><br>You want to obtain environment and session information such as the name and IP address of the<br>current user so that the values can be stored into local variables for logging purposes.<br><strong><strong>Solution</strong></strong><br>Make use of the <code>SYS_CONTEXT()</code> built-in function to query the database for the user’s information. Once you<br>have obtained the information, then store it into a local variable. At that point, you can do whatever<br>you’d like with it, such as save it in a logging table. The following code block demonstrates this<br>technique: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;obtain_user_info&gt;&gt;
DECLARE 
  username varchar2(100); 
  ip_address varchar2(100); 
BEGIN
  SELECT SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), SYS_CONTEXT(&#39;USERENV&#39;,&#39;IP_ADDRESS&#39;) 
  INTO username, ip_address 
  FROM DUAL; 
  DBMS_OUTPUT.PUT_LINE(&#39;The connected user is: &#39; || username || &#39;, and the IP address
  is &#39; || 
  ip_address); 
END; </code></pre>
<p>Once this code block has been run, then the user’s information should be stored into the local<br>variables that have been declared within it. </p>
<p><strong><strong>How It Works</strong></strong><br>You can use the <code>SYS_CONTEXT</code> function to obtain important information regarding the current user’s<br>environment, among other things. It is often times used for auditing(n.审计;查帐) purposes so that a particular code<br>block can grab(vi.攫取;夺取) important information about the connected user such as you’ve seen in the <strong>Solution</strong> to<br>this recipe. The SYS_CONTEXT function allows you to define a namespace and then place parameters<br>within it so that they can be retrieved for use at a later time. The general syntax for the use of<br><code>SYS_CONTEXT</code> is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SYS_CONTEXT(&#39;namespace&#39;,&#39;parameter&#39;[,length]) </code></pre>
<p>A namespace can be any valid SQL identifier, and it must be created using the CREATE_CONTEXT<br>statement. The parameter must be a string or evaluate to a string, and it must be set using the<br>DBMS_SESSION.SET_CONTEXT procedure. The call to SYS_CONTEXT with a valid namespace and parameter<br>will result in the return of a value that has a VARCHAR2 datatype. The default maximum length of the<br>returned value is 256 bytes. However, this default maximum length can be overridden by specifying the<br>length when calling SYS_CONTEXT. The length is an optional parameter. The range of values for the length<br>is 1 to 4000, and if you specify an invalid value, then the default of 256 will be used.<br>The USERENV namespace is automatically available for use because it is a built-in namespace<br>provided by Oracle. The USERENV namespace contains session information for the current user. Table 2-1<br>lists the parameters that are available to use with the USERENV namespace.<br>Table 2-1. USERENV Parameter Listing </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- Parameter          Description 
ACTION                Identifies the position in the application name.
AUDITED_CURSORID      Returns the cursor ID of the SQL that triggered the audit. 
AUTHENTICATED_DATA    Returns the data being used to authenticate the user. 
AUTHENTICATION_TYPE   Identifies how the user was authenticated. 
BG_JOB_ID             If an Oracle Database background process was used to establish the connection, then this returns the job ID of the current session. If no 
                      background process was established, then NULL is returned. 
CLIENT_IDENTIFIER     Returns identifier that is set by the application. 
CLIENT_INFO           Returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. 
CURRENT_SCHEMA        Returns the current session’s default schema.
CURRENT_SCHEMAID      Returns the current schema’s identifier.
CURRENT_SQL           Returns the first 4KB of the triggering SQL.
DB_DOMAIN             Returns the value specified in the DB_DOMAIN parameter. 
DB_NAME               Returns the value specified in the DB_NAME parameter. 
DB_UNIQUE_NAME        Returns the value specified in the DB_UNIQUE_NAME parameter. 
ENTRYID               Returns the current audit entry number. 
EXTERNAL_NAME         Returns the external name of the database user. 
FG_JOB_ID             If an Oracle Database foreground process was used to establish the connection, then this returns the job ID of the current session. If no 
                      foreground process was established, then NULL is returned. 
GLOBAL_CONTEXT_MEMORY Returns the number being used by the globally accessed context in the 
                      System Global Area.   
HOST                  Returns the host name of the machine from which the client has connected. 
INSTANCE              Returns the instance ID number of the current instance. 
IP_ADDRESS            Returns the IP address of the machine from which the client has connected. 
ISDBA                 Returns TRUE if the user was authenticated as a DBA. 
LANG                  Returns the ISO abbreviation of the language name. 
LANGUAGE              Returns the language and territory used by the session, along with the 
                      character set. 
MODULE                Returns the application name. This name has to be set via the
                      DBMS_APPLICATION_INFO package. 
NETWORK_PROTOCOL      Returns the network protocol being used for communication. 
NLS_CALENDAR          Returns the current calendar of the current session. 
NLS_CURRENCY          Returns the currency of the current session. 
NLS_DATE_FORMAT       Returns the date format for the session. 
NLS_DATE_LANGUAGE     Returns the language being used for expressing dates. 
NLS_SORT              Returns the BINARY or linguistic sort basis. 
NLS_TERRITORY         Returns the territory of the current session. 
OS_USER               Returns the operating system user name of the client that initiated the 
                      session. 
PROXY_USER            Returns the name of the database that opened the current session on behalf 
                      of SESSION_USER. 
PROXY_USERID          Returns the identifier of the database user who opened the current session on behalf of the SESSION_USER. 
SERVICE_NAME          Returns the name of the service to which a given session is connected. 
SESSION_USER          Returns the database user name through which the current user is authenticated. 
SESSION_USERID        Returns the identifier of the database user name by which the current user is authenticated. 
SESSIONID             Returns the auditing session identifier. 
STATEMENTID           Returns the auditing statement identifier. 
TERMINAL              Returns the operating system identifier for the client of the current session. </code></pre>
<p>When <code>SYS_CONTEXT</code> is used within any query, it is most commonly issued against the <code>DUAL</code> table. The<br><code>DUAL</code> table is installed along with the data dictionary when the Oracle Database is created. This table is<br>really a dummy(adj.虚拟的,假的) table that contains one column that is appropriately named <code>DUMMY</code>. This column contains<br>the value <code>X</code>.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; desc dual;
 Name Null? Type 
 ----------------------------------------- -------- ---------------------------- 
DUMMY VARCHAR2(1) </code></pre>
<p>Among other things, <code>DUAL</code> is useful for obtaining values from the database when no actual table is<br>needed. Our <strong>Solution</strong> case is such a situation.</p>
<h2 id="2-8-Formatting-Query-Results"><a href="#2-8-Formatting-Query-Results" class="headerlink" title="2.8. Formatting Query Results"></a>2.8. Formatting Query Results</h2><p><strong><strong>Problem</strong></strong><br>Your boss asks you to print the results from a couple of queries in a nicely formatted manner.<br><strong><strong>Solution</strong></strong><br>Use a combination of different built-in formatting functions along with the concatenation operator (||)<br>to create a nice-looking basic report. The RPAD and LPAD functions along with the concatenation operator<br>are used together in the following example that displays a list of employees from a company: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, phone_number 
 FROM employees; 
 emp_rec employees%ROWTYPE; 
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
 IF emp_rec.phone_number IS NOT NULL THEN 
 DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 35,&#39;.&#39;) || 
 emp_rec.phone_number); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || 
 &#39; does not have a phone number.&#39;); 
 END IF; 
 END LOOP; 
END; 
The following is another variant of the same report, but this time dashes are used instead of using 
dots to space out the report: 
DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, phone_number 
 FROM employees; 
 emp_rec employees%ROWTYPE; 
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
  IF emp_rec.phone_number IS NOT NULL THEN
  --CHECK FOR INTERNATIONAL PHONE NUMBERS
        IF length(emp_rec.phone_number) &gt; 12 THEN
          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,18));
        ELSE
          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,12));
        END IF;
      ELSE
        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;does not have a phone number.&#39;);
    END IF;
  END LOOP;
END;</code></pre>

<p><strong><strong>How It Works</strong></strong><br>The <code>RPAD</code> and <code>LPAD</code> functions are used to return the data in a formatted manner. The <code>RPAD</code> function takes a<br>string of text and pads it on the right by the number of spaces provided by the second parameter. The<br>syntax for the <code>RPAD</code> function is as follows:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">RPAD(input_text, n, character) -- append n piece characters on the right</code></pre>

<p>In this syntax, <code>n</code> is the number of spaces used to pad. Similarly, the <code>LPAD</code> function pads on the left of<br>the provided string. The syntax is exactly the same as <code>RPAD</code>; the only difference is the direction of the<br>padding. The combination of these two functions, along with the concatenation operator (<code>||</code>), provides<br>for some excellent formatting options.  </p>
<p>It is important to look at the data being returned before you try to format it, especially to consider<br>what formatting options will look best when generating output for presentation. In the case of the<br>examples in this recipe, the latter example would be the most reasonable choice of formatting for the<br>data being returned, since the phone number includes dots in it. The first example uses dots to space out<br>the report, so too many dots may make the output difficult to read. Know your data, and then choose the<br>appropriate PL&#x2F;SQL built-ins to format accordingly.  </p>
<p>Note When using <code>DBMS_OUTPUT</code> to display data, please be sure to pay attention to the size of the buffer. You can<br>set the buffer size from 2,000 to 1,000,000 bytes by passing the size you desire to the <code>DBMS_OUTPUT.ENABLE</code> procedure.<br>If you attempt to display content over this size limit, then Oracle will raise an exception.</p>
<p>Oracle provides a number of built-in functions to use when formatting strings. Two others that are<br>especially useful are <code>LTRIM(&lt;string&gt;)</code> and <code>RTRIM(&lt;string&gt;)</code>. These remove leading and trailing spaces,<br>respectively. See your Oracle SQL Reference manual for a complete list of available string functions.</p>
<h2 id="2-9-Updating-Rows-Returned-by-a-Query"><a href="#2-9-Updating-Rows-Returned-by-a-Query" class="headerlink" title="2.9. Updating Rows Returned by a Query"></a>2.9. Updating Rows Returned by a Query</h2><p><strong><strong>Problem</strong></strong><br>  You’ve queried the database and retrieved a row into a variable. You want to update some values<br>contained in the row and commit them to the database.<br><strong><strong>Solution</strong></strong><br>  First, retrieve the database row that you want to update. Second, update the values in the row that need<br>to be changed, and then issue an UPDATE statement to modify the database with the updated values. In<br>the following example, a procedure is created that queries a table of employees for a particular<br>employee. The resulting employee’s department ID is then updated with the new one unless the<br>employee is already a member of the given department.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE change_emp_dept(emp_id IN NUMBER, 
 dept_id IN NUMBER) AS 
 emp_row employees%ROWTYPE; 
 dept departments.department_name%TYPE; 
 rec_count number :&#x3D; 0; 
BEGIN 
 SELECT count(*) 
 INTO rec_count 
 FROM employees 
 WHERE employee_id &#x3D; emp_id; 
 IF rec_count &#x3D; 1 THEN 
 SELECT * 
 INTO emp_row 
 FROM employees 
 WHERE employee_id &#x3D; emp_id; 
 IF emp_row.department_id !&#x3D; dept_id THEN 
 emp_row.department_id :&#x3D; dept_id; 
 UPDATE employees SET ROW &#x3D; emp_row 
 WHERE employee_id &#x3D; emp_id; 
 SELECT department_name 
 INTO dept 
 from departments 
 WHERE department_id &#x3D; dept_id; 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || emp_row.first_name || &#39; &#39; || 
 emp_row.last_name || &#39; is now in department: &#39; || dept); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee is already in that department...no change&#39;); 
 END IF; 
ELSIF rec_count &gt; 1 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee ID you entered is not unique&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee records match the given employee ID&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Invalid employee or department ID, try again&#39;); 
 WHEN OTHERS THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Unsuccessful change, please check ID numbers and try again&#39;); 
END; </code></pre>
<p>As you can see, the example queries the database into a record declared using the <code>%ROWTYPE</code><br>attribute. The value that needs to be updated is then modified using the data contained in the record.<br>Lastly, using the SET ROW clause updates the table with the modified record.<br><strong><strong>How It Works</strong></strong><br>As you’ve seen in the <strong>Solution</strong> to the recipe, it is possible to update the values of a row returned by a<br>query using the <code>UPDATE...SET</code> ROW syntax. In many cases, using a single <code>UPDATE</code> statement can solve this<br>type of transaction. However, in some scenarios where you need to evaluate the current value of a<br>particular column, then this <strong>Solution</strong> is the correct choice.</p>
<p>Using the <code>UPDATE</code> ROW statement, you can update entire database rows with a single variable of either<br>the <code>%ROWTYPE</code> or <code>RECORD</code> type. The <code>UPDATE</code> statement also allows you to return values after the update by<br>adding the <code>RETURNING</code> clause to the end of the statement followed(v.跟着,听从) by the column names to return and the<br>variables that will receive their values. Take a look at this next example:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 first        employees.first_name%TYPE; 
 last         employees.last_name%TYPE; 
 new_salary   employees.salary%TYPE; 
BEGIN 
 UPDATE employees 
 SET salary &#x3D; salary + (salary * .03) 
 WHERE employee_id &#x3D; 100  RETURNING first_name, last_name,salary INTO first, last, new_salary; 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || first || &#39; &#39; || last || &#39; now has a salary of: &#39; || new_salary); 
END; </code></pre>
<p>As you can see, the example outputs the new values that are the result of the update statement.<br>Using the RETURNING clause saves a step in that you are not required to requery the table after the update<br>in order to display the updated results.</p>
<h2 id="2-10-Updating-Rows-Returned-by-a-Cursor"><a href="#2-10-Updating-Rows-Returned-by-a-Cursor" class="headerlink" title="2.10. Updating Rows Returned by a Cursor"></a>2.10. Updating Rows Returned by a Cursor</h2><p><strong><strong>Problem</strong></strong><br>You’ve created a cursor to use for querying your data. You want to loop through the results using a cursor for loop and update the data as needed.<br><strong><strong>Solution</strong></strong><br>Use the <code>WHERE_CURRENT_OF</code> clause within your loop to update the current data row in the iteration. In the<br>following example, the EMPLOYEES table is queried for all employees in a particular department. The<br>results of the query are then iterated using a FOR loop, and the salary is increased for each employee<br>record that is returned.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
DECLARE 
 CURSOR emp_sal_cur IS 
 SELECT * 
 FROM employees 
 WHERE department_id &#x3D; 60 
 FOR UPDATE;        --cursor should use &#96;FOR UPDATE&#96; clause statement

 emp_sal_rec emp_sal_cur%ROWTYPE; -- cursor also would define varable using ROWTYPE keyword

 BEGIN 
 FOR emp_sal_rec IN emp_sal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;Old Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); 
    UPDATE employees 
    SET salary &#x3D; salary + (salary * .025) 
    WHERE CURRENT OF emp_sal_cur;  -- current of your_cursor
 END LOOP; 

 -- Display the updated salaries 
 FOR emp_sal_rec IN emp_sal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;New Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); 
 END LOOP; 
END;
</code></pre>
<p>An update on the <code>EMPLOYEES</code> table occurs with each iteration of the loop. The second loop in this<br>example simply displays the new salary result for each employee that was returned by the cursor query.<br><strong><strong>How It Works</strong></strong><br>Updating values when iterating a cursor can be handy(adj.便利的,手边的), especially when working with a number of(大量) rows.<br>There is one main difference between a cursor that allows updating and one(cursor) that does not. That<br>difference is the addition of the <code>FOR UPDATE</code> clause in the cursor declaration. By using the <code>FOR UPDATE</code><br>clause of the <code>SELECT</code> statement, you are causing the database to lock the rows that have been read by the<br>query. This lock is to ensure that nobody else can modify the rows while you are working with them. The<br>lock creates a read-only block on the table rows so that if someone else attempts to modify them while<br>you have them locked, then they will have to wait until you have performed either a <code>COMMIT</code> or a <code>ROLLBACK</code>.<br>The <code>FOR UPDATE</code> clause has an optional <code>NOWAIT</code> keyword. By including this keyword, you will ensure<br>that your query does not block your transaction if someone else already has the rows that you are<br>querying blocked. The <code>NOWAIT</code> keyword tells Oracle not to wait if the requested rows are already locked,<br>and control is immediately passed back to your program so that it can continue to run. If the <code>NOWAIT</code><br>keyword is omitted and the rows are already locked, then your program will stop and wait until the lock<br>has been released.</p>
<p>You can use the cursor with any style of loop, as you’ve seen in previous recipes. No matter which<br>type of loop you choose, the <code>UPDATE</code> must be coded using the <code>WHERE CURRENT OF your_cursor</code> clause to update the<br>current row in the cursor iteration. You will need to be sure to commit the changes after this block has<br>been run, and in many circumstances the <code>COMMIT</code> statement can be coded into this block once it has been<br>tested and verified to work correctly. As with any <code>UPDATE</code> statement, if you fail to <code>COMMIT</code> your changes,<br>then the UPDATE will not save any changes to the database, and the updated data will be visible to your<br>schema only until you disconnect. Issuing a <code>COMMIT</code> after your <code>UPDATE</code> statements have been issued is also<br>a good practice in this case because it will release the lock on the rows you had queried via the cursor so<br>that someone else can update them if needed. If you determine the data that was updated by the code<br>block is incorrect, then a <code>ROLLBACK</code> will also release the lock.</p>
<text style="font-family:Courier New;color:red">

<p>summary:</br></p>
<ol>
<li>if you wanna update data of cursor that returned by select, you can use <code>WHERE CURRENT OF emp_sal_cur</code> and <code>for update</code></li>
<li>By using the <code>FOR UPDATE</code> clause of the <code>SELECT</code> statement,data lock is data level</li>
<li>wether <code>FOR UPDATE</code> clause update table data or cursor only?(it should be commit changes for table)</li>
<li>if you fail to <code>COMMIT</code> your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to your<br>schema only until you disconnec</li>
<li><code>COMMIT</code> and <code>ROLLBACK</code> either release lock</li>
</ol>
</text> 

<h2 id="2-11-Deleting-Rows-Returned-by-a-Cursor"><a href="#2-11-Deleting-Rows-Returned-by-a-Cursor" class="headerlink" title="2.11. Deleting Rows Returned by a Cursor"></a>2.11. Deleting Rows Returned by a Cursor</h2><p><strong><strong>Problem</strong></strong><br>There are a series of database rows that you’d like to delete. You’ve created a cursor <code>FOR LOOP</code>, and you want to delete some or all rows that have been queried with the cursor.<br><strong><strong>Solution</strong></strong><br>Use a <code>DELETE</code> statement within a <code>FOR LOOP</code> to delete the rows that are retrieved by the <code>cursor</code>. If you create a cursor using the <code>FOR UPDATE</code> clause, then you will be able to use the <code>WHERE CURRENT OF</code> clause along with the <code>DELETE</code> statement to eliminate the current row within each iteration of the cursor. The following example shows how this can be done to remove all job history for a given department ID:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE remove_job_history(dept_id IN NUMBER) AS 

 CURSOR job_history_cur IS 
 SELECT * 
 FROM job_history 
 WHERE department_id &#x3D; dept_id 
 FOR UPDATE; 
    job_history_rec job_history_cur%ROWTYPE; 
 BEGIN 
  FOR job_history_rec IN job_history_cur LOOP 
    DELETE FROM job_history WHERE CURRENT OF job_history_cur; 
    DBMS_OUTPUT.PUT_LINE(&#39;Job history removed for department &#39; || dept_id); 
  END LOOP; 
END; </code></pre>
<p>Using this technique, the job history for the department with the given ID will be removed from the <code>JOB_HISTORY</code> table.</p>
<p><strong><strong>How It Works</strong></strong><br>Much like updating rows using a cursor, the deletion of rows uses the <code>WHERE CURRENT OF</code> clause within the <code>DELETE</code> statement to remove each row. The cursor query must contain the <code>FOR UPDATE</code> clause in order to lock the rows that you are reading until a <code>COMMIT</code> or <code>ROLLBACK</code> has been issued. As mentioned in the previous recipe, the <code>NOWAIT</code> keyword is optional, and it can be used to allow control to be immediately returned to your program if someone else already has locks on the rows that you are interested in updating. In each iteration of the loop, the DELETE statement is used along with the <code>WHERE CURRENT OF</code> clause to remove the current cursor record from the database. Once the loop has been completed, then all the rows that had been queried via the cursor should have been deleted. This technique is especially useful if you are going to be performing some further processing on each of the records and then deleting them. One such case would be if you wanted to write each of the records to a history table prior to deleting them. In any case, the cursor <code>FOR loop</code> deletion technique is a great way to remove rows from the database and work with the data along the way.</p>
<h2 id="2-12-Performing-a-Transaction"><a href="#2-12-Performing-a-Transaction" class="headerlink" title="2.12. Performing a Transaction"></a>2.12. Performing a Transaction</h2><p><strong><strong>Problem</strong></strong><br>You need to complete a series of <code>INSERT</code> or <code>UPDATE</code> statements in order to process a complete transaction. In doing so, you need to ensure that if one of the statements fails, that all of the statements are canceled so that the transaction is not partially processed.<br><strong><strong>Solution</strong></strong><br>Use the transaction control mechanisms that are part of PL&#x2F;SQL, as well as SQL itself, in order to control your transactions. When all your statements have been completed successfully, issue a <code>COMMIT</code> to make them final. On the other hand, if one of the statements does not complete successfully, then perform a <code>ROLLBACK</code> to undo all the other changes that have been made and bring the database back to the state that it was in prior(美[‘praɪɚ],adj.优先的,在先的,在前的) to the transaction occurring.In the following example, the code block entails the body of a script that is to be executed in order to create a new department and add some employees to it. The department change involves an INSERT and UPDATE statement to complete.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 -- Query all programmers who make more than 4000 
 -- as they will be moved to the new &#39;Web Development&#39; department 
 CURSOR new_dept_cur IS 
    SELECT * 
    FROM employees 
    WHERE job_id &#x3D; &#39;IT_PROG&#39;
    AND salary &gt; 4000 
    FOR UPDATE; 
 new_dept_rec         new_dept_cur%ROWTYPE; 
 current_department   departments.department_id%TYPE; 
BEGIN 
 -- Create a new department 
 INSERT INTO departments values( 
                                DEPARTMENTS_SEQ.nextval, -- Department ID (sequence value) 
                                &#39;Web Development&#39;, -- Department Title 
                                103 -- Manager ID 
                                1700); -- Location ID 
 -- Obtain the current department ID…the new department ID 
 SELECT DEPARTMENTS_SEQ.currval 
 INTO current_department 
 FROM DUAL; 

 -- Assign all employees to the new department 
 FOR new_dept_rec IN new_dept_cur LOOP 
      UPDATE employees 
      SET department_id &#x3D; current_department 
      WHERE CURRENT OF new_dept_cur; 
 END LOOP;

 COMMIT;
      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); 
END;</code></pre>
<p>As you can see, a transaction was performed in this block of code. It is important to roll back changes if errors occur along the way so that the transaction is not partially completed.</p>
<p><strong><strong>How It Works</strong></strong><br>Transaction control is built into the Oracle Database. Any database changes that are made within a code block are visible to the current session only until a COMMIT has been made. The changes that have been made by the statements can be rolled back via the ROLLBACK command up until the point that a COMMIT is issued. Oracle uses table and row locks to ensure that data that has been updated in one session cannot be seen in another session until a COMMIT occurs. A transaction is started when the first statement after the last COMMIT or ROLLBACK is processed or when a session is created. It ends when a COMMIT or ROLLBACK occurs. A transaction is not bound to a single code block, and any code block may contain one or more transactions. Oracle provides a SAVEPOINT command, which places a marker at the current database state so as to allow you to roll back to that point in time in a transaction. Oracle Database automatically issues a SAVEPOINT prior to processing the first statement in any transaction.</p>
<p>As a rule of thumb, it is always a good idea to have exception handling in place in case an exceptionoccurs. However, if an unhandled exception occurs, then the database will roll back the statement that caused the exception, not the entire transaction. Therefore, it is up to the program to handle exceptions and issue the ROLLBACK command if the entire transaction should be undone. If a database crashes and goes down during a transaction, then when the database is restarted, all uncommitted statements are rolled back. All transactions are completed when a COMMIT or ROLLBACK is issued.</p>
<h2 id="2-13-Ensuring-That-Multiple-Queries-“See”-the-Same-Data"><a href="#2-13-Ensuring-That-Multiple-Queries-“See”-the-Same-Data" class="headerlink" title="2.13. Ensuring That Multiple Queries “See” the Same Data"></a>2.13. Ensuring That Multiple Queries “See” the Same Data</h2><p><strong><strong>Problem</strong></strong><br>You are issuing a set of queries against the database, and you need to ensure that none of the table rows change throughout the course of the queries being made.<br><strong><strong>Solution</strong></strong><br>Set up a read-only transaction in which the current transaction will see the data only as an unchanged snapshot in time. To do so, use the SET TRANSACTION statement to begin a read-only transaction and establish a snapshot of the data so it will be consistent and unchanged from all other updates being made. For instance, the following example displays a block that sets up read-only queries against the database for dollar values from a bank account:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 daily_atm_total NUMBER(12,2); 
 weekly_atm_total NUMBER(12,2); 
BEGIN 
 COMMIT; -- ends previous transaction 
 SET TRANSACTION READ ONLY NAME &#39;ATM Weekly Summary&#39;; 
 SELECT SUM (wd_amt) INTO daily_atm_total FROM atm_withdrawals 
 WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE, &#39;MM-DD-YYYY&#39;); 
 SELECT SUM (weekly_total) INTO weekly_atm_total FROM atm_withdrawals 
 WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE - 7, &#39;MM-DD-YYYY&#39;); 
 DBMS_OUTPUT.PUT_LINE(daily_atm_total || &#39; - &#39; || weekly_atm_total); 
 COMMIT; -- ends read-only transaction 
END; </code></pre>
<p>Querying the database using read-only transactions will ensure that someone will see the correct values in a situation such as the one depicted(vt.描述,描画) in this example.</p>
<p><strong><strong>How It Works</strong></strong><br>often times there are situations when you need to ensure that the data being queried throughout a transaction’s life cycle is unchanged by other users’ updates. The classic case is when someone goes to withdraw money from the bank and their spouse(n.配偶) is at an ATM machine depositing into the account at the same time. If read consistency were not in place, the individual may view their account balance and see that there was plenty of money to withdraw, and then they’d go to take the money out and receive an error because the spouse had canceled the deposit(美 [dɪ’pɑzɪt]n.存款,押金) instead. A read-only transaction allows for read consistency until a <code>COMMIT</code> has been issued. If the spouse had confirmed the deposit, then the next query on the account would reflect the additional funds (assuming that the bank were to release them to the account in real time).<br>Situations such as these require that you provide an environment that is essentially isolated from the outside world. You can use the SET TRANSACTION command to start a read-only transaction, set an isolation level, and assign the current transaction to a <code>rollback</code> segment. The SET TRANSACTION statement must be the first statement in a read-only transaction, and it can appear only once in the transaction. Note that there are some statement restrictions when using a read-only transaction. Only <code>SELECT INTO</code>, <code>OPEN</code>, <code>FETCH</code>, <code>CLOSE</code>, <code>LOCK TABLE</code>, <code>COMMIT</code>, and <code>ROLLBACK</code> statements can be used; other statements are not allowed.</p>
<h2 id="2-14-Executing-One-Transaction-from-Within-Another"><a href="#2-14-Executing-One-Transaction-from-Within-Another" class="headerlink" title="2.14. Executing One Transaction from Within Another"></a>2.14. Executing One Transaction from Within Another</h2><p>(nested tracsaction)<br><strong><strong>Problem</strong></strong><br>You are executing a transaction, and you are faced with the need to suspend your current work, issue a completely separate transaction, and then pick up your current work. For example, say you want to log entries into a log table. The log entries should be persisted separately from the current transaction such that if the transaction fails or is rolled back, the log entries will still be completed.<br><strong><strong>Solution</strong></strong><br>Start an autonomous transaction to make the log entry. This will ensure that the log entry is performed separately from the current transaction. In the following example, an employee is deleted from the EMPLOYEES table. Hence, a job is ended, and the job history must be recorded into the <code>JOB_HISTORY</code> table. In the case that something fails within the transaction, the log entry into the <code>JOB_HISTORY</code> table must be intact(adj.完整的,原封不动的). This log entry cannot be rolled back because it is performed using an autonomous transaction.The code to encapsulate(美 [ɪn’kæpsjə’let],vt.压缩,将…装入胶囊) the autonomous transaction needs to be placed into a named block that can be called when the logging needs to be performed. The following piece of code creates a PL&#x2F;SQL procedure that performs the log entry using an autonomous transaction. (You will learn more about procedures in Chapter 4.) Specifically notice(n.通知,布告) the declaration of <code>PRAGMA AUTONOMOUS_TRANSACTION</code>. That pragma specifies that the procedure executes as a separate transaction, independent of any calling transaction.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE log_job_history ( emp_id IN 
                                              employees.employee_id%TYPE, 
                                              Job_id IN jobs.job_id%TYPE, 
                                              Department_id IN employees.department_id%TYPE, 
                                              employee_start IN DATE) AS 
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN 
 INSERT INTO job_history 
 VALUES (emp_id, 
 employee_start, 
 sysdate, 
 job_id, 
 department_id); 
 COMMIT; 
END;
</code></pre>
<p>The <code>LOG_JOB_HISTORY</code> procedure inserts an entry into the log table separately from the transaction that is taking place in the calling code block. The following code performs the job termination, and it calls the <code>log_substitution</code> procedure to record the history:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR dept_removal_cur IS 
    SELECT * 
    FROM employees 
    WHERE department_id &#x3D; 10 
    FOR UPDATE; 
 dept_removal_rec dept_removal_cur%ROWTYPE; 
BEGIN 
 -- Delete all employees from the database who reside in department 10 
 FOR dept_removal_rec IN dept_removal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;DELETING RECORD NOW&#39;); 
    DELETE FROM employees WHERE CURRENT OF dept_removal_cur; 
    -- Log the termination 
    log_job_history(dept_removal_rec.employee_id, 
                      dept_removal_rec.job_id, 
                      dept_removal_rec.department_id, 
                      dept_removal_rec.hire_date);
 END LOOP; 
    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); 
EXCEPTION 
 -- Handles all errors 
 WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been rolled back due to errors, please try again.&#39;); 
    ROLLBACK; 
END;</code></pre>
<p>If this code block is executed and then rolled back, the entry into the job history table remains,because it is performed as a separate, autonomous transaction.<br><strong><strong>How It Works</strong></strong><br>An autonomous transaction is a transaction that is called by another transaction and that runs separately from the calling transaction. Autonomous transactions commit or roll back without affecting the calling transaction. They also have the full functionality of regular transactions; they merely(adv.仅仅,只不过,只是) run separately from the main transaction. They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.</p>
<p>An autonomous transaction must be created with a top-level code block, trigger, procedure,function, or stand-alone named piece of code. In the <strong>Solution</strong>, you saw that a procedure was created to run as an autonomous transaction. That is because it is not possible to create an autonomous transaction within a nested code block. To name a transaction as autonomous, you must place the statement PRAGMA AUTONOMOUS_TRANSACTION within the declaration section of a block encompassing(adj.包含的,包容的,环绕) the transaction. To end the transaction, perform a COMMIT or ROLLBACK.</p>
<text style="font-family:Courier New;color:red">

<p>summary: </br></p>
<ol>
<li>They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.</li>
</ol>
</text>

<h2 id="2-15-Finding-and-Removing-Duplicate-Table-Rows"><a href="#2-15-Finding-and-Removing-Duplicate-Table-Rows" class="headerlink" title="2.15. Finding and Removing Duplicate Table Rows"></a>2.15. Finding and Removing Duplicate Table Rows</h2><p><strong><strong>Problem</strong></strong><br>You have found that for some reason your database contains a table that has duplicate records. You areworking with a database that unfortunately does not use primary key values, so you must manually enforce data integrity. You need a way to remove the duplicate records. However, any query you write to remove one record will also remove its duplicate.<br><strong><strong>Solution</strong></strong><br>The <strong>Solution</strong> to this issue involves two steps. First you need to query the database to find all duplicaterows, and then you need to run a statement to delete one of each duplicate record that is found.The following code block queries the EMPLOYEES table for duplicate rows. When a duplicate is found,it is returned along with a count of duplicates found.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;duplicate_emp_qry&gt;&gt;
DECLARE
CURSOR emp_cur IS
  SELECT *
  FROM employees
  ORDER BY employee_id;
  emp_count
  number :&#x3D; 0;
  total_count
  number :&#x3D; 0;
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;You will see each duplicated employee listed more &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;than once in the list below. This will allow you to &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;review the list and ensure that indeed...there are more &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;than one of these employee records in the table.&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;Duplicated Employees: &#39;);
-- Loop through each player in the table
FOR emp_rec IN emp_cur LOOP
-- Select the number of records in the table that have the same ID as the current record
SELECT count(*)
INTO emp_count
FROM employees
WHERE employee_id &#x3D; emp_rec.employee_id;
-- If the count is greater than one then a duplicate has been found, so print it out.
IF emp_count &gt; 1 THEN 
 DBMS_OUTPUT.PUT_LINE(emp_rec.employee_id || &#39; - &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_count); 
 total_count :&#x3D; total_count + 1; 
 END IF; 
 END LOOP; 
END;</code></pre>
<p>If the table includes a duplicate, then it is printed out as follows:<br>You will see each duplicated employee listed more than once in the list below. This will allow you to review the list and ensure that indeed…there are more<br>than one of these employees in the table.<br>Duplicated Employees:<br>100 - Steven King - 2<br>100 – Steven King - 2<br>PL&#x2F;SQL procedure successfully completed.  </p>
<p>Next, you need to delete the duplicated rows that have been found. The following DELETE statement<br>will ensure that one of the duplicates is removed:<br>DELETE FROM employees A WHERE ROWID &gt; (<br>SELECT min(rowid) FROM employees B<br>WHERE A.employee_id &#x3D; B.employee_id);</p>
<p><strong><strong>How It Works</strong></strong><br>Usually using primary keys prohibits the entry of duplicate rows into a database table. However, many legacy databases still in use today do not include such constraints. In rare situations, a duplicate key and values are entered into the database that can cause issues when querying data or assigning values. The method shown in the <strong>Solution</strong> for finding duplicate rows is very basic. The <strong>Solution</strong> loops through each record in the table, and during each pass, it queries the table for the number of records found that match the current record’s EMPLOYEE_ID. If the number found is greater than one, then you know that you have found a duplicate. The <strong>Solution</strong> presented here for finding duplicates will work on any table provided that you have a column of data that should contain logically unique values. In the example, each record should contain a different EMPLOYEE_ID, so if there is more than one record with the same EMPLOYEE_ID value, then a duplicate is found. If the table you are working with does not contain any unique columns, then you can concatenate a number of columns in order to obtain a unique combination. For instance, if EMPLOYEES did not contain an EMPLOYEE_ID column, then you could concatenate the FIRST_NAME, LAST_NAME, and EMAIL columns to obtain a unique combination. More likely than not, there will not be two employees in the table with the same name and e-mail address. The second part of the <strong>Solution</strong> involves removing one or more duplicate records from the set. To do so, you have to look at a pseudocolumn known as the ROWID. The ROWID is a pseudocolumn (invisible column) that is found in each table in an Oracle Database that uniquely identifies each row. By comparing these unique ROWID values, you can delete just one of the records, not both. The DELETE statement actually finds the rows that contain the same uniquely identified column(s) and then removes the row with the larger ROWID value.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_03/"
                    data-tooltip="Oracle PLSQL Recipes 03-Looping and Logic"
                    aria-label="PREVIOUS: Oracle PLSQL Recipes 03-Looping and Logic"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_01/"
                    data-tooltip="Oracle PLSQL Recipes-01 PL/SQL Fundamentals"
                    aria-label="NEXT: Oracle PLSQL Recipes-01 PL/SQL Fundamentals"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_02/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_03/"
                    data-tooltip="Oracle PLSQL Recipes 03-Looping and Logic"
                    aria-label="PREVIOUS: Oracle PLSQL Recipes 03-Looping and Logic"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_01/"
                    data-tooltip="Oracle PLSQL Recipes-01 PL/SQL Fundamentals"
                    aria-label="NEXT: Oracle PLSQL Recipes-01 PL/SQL Fundamentals"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_02/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href=""
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_02/"
                        aria-label="global.share_on_wechat"
                    >
                        <i class="fa-foo_bar" aria-hidden="true"></i><span>global.share_on_wechat</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Canton
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-4u8r0fo0pgap8c0kebqie2krcfxcv3h259cjxizeggkmknhnwzjt04ztqpi1.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'ca29b9a1203b5920918d',
              clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
              repo: 'SimonTeo58.github.io',
              owner: 'SimonTeo58',
              admin: ['SimonTeo58'],
              id: '2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_02/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
