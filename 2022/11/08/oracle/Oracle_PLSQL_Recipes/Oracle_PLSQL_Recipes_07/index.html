
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CoffeeMan">
    <title>Oracle PLSQL Recipes 07-Numbers, Strings, and Dates - CoffeeMan</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://simonteo58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg"},"articleBody":"摘要: 其实这个讲PLSQL有点基础\n\n\n\n\n\n7. Numbers, Strings, and DatesEvery PL&#x2F;SQL program uses one or more datatypes. This chapter focuses on some details that youshould know when working with data in the form of numbers, strings, and dates. Each recipe in thischapter provides a basic tip for working with these datatypes. From basic string concatenation to moreadvanced regular expression processing, you’ll learn some techniques for getting things done in aneffective manner. You’ll learn about date calculations as well. When you’re done with this chapter, you’llbe ready to move on to the more advanced recipes later in the chapters to follow. \n7-1. Concatenating StringsProblemYou have two or more text strings, or variables containing strings, that you want to combine. \nSolutionUse the concatenation operator to append the strings. In the following example, you can see that twovariables are concatenated to a string of text to form a single string of text: \nDECLARE \n  CURSOR emp_cur IS \n  SELECT employee_id, first_name, last_name \n  FROM EMPLOYEES \n  WHERE HIRE_DATE &gt; TO_DATE(&#39;01&#x2F;01&#x2F;2000&#39;,&#39;MM&#x2F;DD&#x2F;YYYY&#39;); \n   \n  emp_rec       emp_cur%ROWTYPE; \n  emp_string    VARCHAR2(150); \nBEGIN \n  DBMS_OUTPUT.PUT_LINE(&#39;EMPLOYEES HIRED AFTER 01&#x2F;01&#x2F;2000&#39;); \n  DBMS_OUTPUT.PUT_LINE(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;); \n  FOR emp_rec IN emp_cur LOOP \n        emp_string :&#x3D; emp_rec.first_name || &#39; &#39; || \n                      emp_rec.last_name || &#39; - &#39; || \n                      &#39;ID #: &#39; || emp_rec.employee_id; \n \n        DBMS_OUTPUT.PUT_LINE(emp_string); \n  END LOOP; \nEND; \nYou can see that the example uses the concatenation operator || to formulate a string of text thatcontains each employee’s first name, last name, and employee ID number.How It WorksAs you have seen in the Solution to this recipe, the concatenation operator is used for concatenatingstrings within your PL&#x2F;SQL applications. When the concatenation operator is used to concatenatenumbers with strings, the numbers are automatically converted into strings and then concatenated.Similarly, an automatic conversion occurs with dates before being concatenated. \n7-2. Adding Some Number of Days to a DateProblemYou want to add a number of days to a given date. For example, you are developing an application thatcalculates shipping dates for a company’s products. In this case, your application is processingshipments, and you need to calculate a date that is 14 days from the current date.SolutionTreat the number of days as an integer, and add that integer to your DATE value. The following lines ofcode show how this can be done: \nDECLARE \n  ship_date    DATE :&#x3D; SYSDATE + 14; \nBEGIN \n  DBMS_OUTPUT.PUT_LINE(&#39;The shipping date for any products &#39;|| \n                       &#39;that are ordered today is &#39; || ship_date); \nEND; \n \nThe result that is displayed for this example will be 14 days past your current date.  \nIf you wanted to encapsulate this logic within a function, then it would be easy to do. The following \nfunction takes a date and a number as arguments. The function will perform simple mathematics and \nreturn the result. \n \nCREATE OR REPLACE FUNCTION calculate_days(date_to_change  IN DATE, \n                                          number_of_days  IN NUMBER) \nRETURN DATE IS \nBEGIN \n  RETURN date_to_change + number_of_days; \nEND; \nNotice that the name of the function does not include the word add, such as ADD_DAYS. That wasdone on purpose because this function not only allows addition of days to a date, but if a negativenumber is passed in as an argument, then it will also subtract the number of days from the given date. \nHow It WorksSince calculations such as these are the most common date calculations performed, Oracle makes themeasy to do. If a number is added to or subtracted from a DATE value, Oracle Database will add or subtractthat number of days from the date value. DATE types can have numbers added to them, and they can alsohave numbers subtracted from them. Multiplication and division do not work because it is not possibleto perform such a calculation on a date. For example, it doesn’t mean anything to speak of multiplying adate by some value.If you are developing an application that always performs an addition or subtraction using the samenumber of days, it may be helpful to create a function such as the one demonstrated in the Solution tothis recipe. For instance, if you were developing a billing application and always required a date that was30 days into the future of the current date, then you could create a function named BILLING_DATE andhard-code the 30 days into it. This is not necessary, but if your business or application depended upon it,then it may be a good idea to encapsulate logic to alleviate possible data entry errors. \n7-3. Adding a Number of Months to a DateProblemYou want to add some number of months to a date. For example, you are developing a paymentapplication for a company, and it requires payments every six months. You need to enable theapplication to calculate the date six months in the future of the current date.■ Note This recipe’s Solution also works for subtracting months. Simply “add” a negative number of months.  \nSolutionUse the ADD_MONTHS function to add six months onto the given date.  Doing so will enable yourapplication to create bills for future payments.  This technique is demonstrated in the followingexample: \nDECLARE \n  new_date    DATE; \nBEGIN \n  new_date :&#x3D; ADD_MONTHS(sysdate,6); \n  DBMS_OUTPUT.PUT_LINE(&#39;The newly calculated date is: &#39; || new_date); \nEND; \n\nThis simple technique will enable you to add a number of months to any given date. As with anyother logic, this could easily be encapsulated into a function for the specific purpose of producing abilling date that was six months into the future of the current date. Such a function may look somethinglike the next example: \nCREATE OR REPLACE FUNCTION calc_billing_date IS \nBEGIN \n  RETURN ADD_MONTHS(sysdate, 6); \nEND;\n\nAlthough this function does not do much besides encapsulate logic, it is a good idea to code suchfunctions when developing a larger application where this type of calculation may be performed severaltimes. It will help to maintain consistency and alleviate maintenance issues if the date calculation everneeds to change. You could simply make the change within the function rather than visiting all thelocations in the code that use the function. \nHow It WorksOracle provides the ADD_MONTHS function to assist with date calculations. This function has twopurposes—to add or subtract a specified number of months from the given date. The syntax for use ofthe ADD_MONTHS function is as follows: \nADD_MONTHS(date, integer) \n\nYou can also use the function to subtract months from the given date. If the function is passed anegative integer in place of the month’s argument, then that number of months will be subtracted fromthe date. The following example demonstrates this functionality: \nDECLARE \n  new_date    DATE; \nBEGIN \n  new_date :&#x3D; ADD_MONTHS(sysdate,-2); \n  DBMS_OUTPUT.PUT_LINE(&#39;The newly calculated date is: &#39; || new_date); \nEND; \n\nAs you can see from the example in Figure 7-3, the negative integer is the only change made to thecode in order to achieve a subtraction of months rather than an addition. As a result, the example in thisfigure will return the current date minus two months.In the case that you are attempting to add months to a date that represents the last day of themonth, the ADD_MONTHS function works a bit differently than you might expect. For instance, if it is August31 and you want to add one month, then you would expect the calculation to resolve to September 31,which is not possible. However, ADD_MONTHS is smart enough to return the last day of September in thiscase. The following code provides a demonstration: \nDECLARE \n  new_date    DATE; \nBEGIN \n  new_date :&#x3D; ADD_MONTHS(to_date(&#39;08&#x2F;31&#x2F;2010&#39;,&#39;MM&#x2F;DD&#x2F;YYYY&#39;),1); \n  DBMS_OUTPUT.PUT_LINE(&#39;The last day of next month is: &#39; || new_date); \nEND; \n\nThe following is the resulting output: \nThe last day of next month is: 30-SEP-10 \nPL&#x2F;SQL procedure successfully completed.In general, if your source date is the late day of its month, then your result date will be forced to thelast day of its respective month. Adding one month to September 30, for example, will yield October 31. \n7-4. Adding Years to a DateProblemYou are developing an application that requires date calculations to be performed. You need todetermine how to add to a specified date. You may also want to subtract years.  \nSolutionCreate a function that will calculate a new date based upon the number of years that you have specified.If you want to subtract a number of years from a date, then pass a negative value for the number of years.The following code implements this functionality: \nCREATE OR REPLACE FUNCTION calculate_date_years (in_date DATE, \n                                    in_years NUMBER) \nRETURN DATE AS \n  new_date    DATE; \nBEGIN \n  IF in_date is NULL OR in_years is NULL THEN \n    RAISE NO_DATA_FOUND; \n  END IF; \n  new_date :&#x3D; ADD_MONTHS(in_date, 12 * in_years); \n  RETURN new_date; \nEND; \nThe example function expects to receive a date and a number of years to add or subtract asarguments. If one of those arguments is left out, then PL&#x2F;SQL will raise an ORA-06553 error, and theexample also raises a special NO_DATA_FOUND error if one or both of the arguments are NULL. The returnvalue will be the input date but in the newly calculated year. \nHow It WorksOracle provides a couple of different ways to calculate dates based upon the addition or subtraction ofyears. One such technique is to use the ADD_MONTHS function that was discussed in Recipe 7-3, as theSolution to this recipe demonstrates. Simple mathematics allow you to multiply the number of yearspassed into the ADD_MONTHS function by 12 since there are 12 months in the year. Essentially thistechnique exploits the ADD_MONTHS function to return a date a specified number of dates into the future.■ Note See Recipe 7-3 for discussion of a corner case involving the use of ADD_MONTHS on a date that representsthe final day of that date’s month.You can use this same technique to subtract a number of years from the specified date by passing anegative integer value that represents the number of years you want to subtract. For instance, if youwanted to subtract five years from the date 06&#x2F;01&#x2F;2000, then pass a -5 to the function that was created inthe Solution to this recipe. The following query demonstrates this strategy. \nselect calculate_date_years(to_date(&#39;06&#x2F;01&#x2F;2000&#39;,&#39;MM&#x2F;DD&#x2F;YYYY&#39;),-5) from dual; \nHere’s the result: \n06/01/1995 \nUsing the ADD_MONTHS function works well for adding or subtracting a rounded number of years.However, if you wanted to add one year and six months, then it would take another line of code to addthe number of months to the calculated date. The function in the next example is a modified version ofthe CALCULATE_DATE_YEARS function that allows you to specify a number of months to add or subtract aswell: \nCREATE OR REPLACE FUNCTION calculate_date_years (in_date DATE, \n                                              in_years IN NUMBER, \n                                              in_months IN NUMBER DEFAULT 0) \nRETURN DATE AS \n  new_date    DATE; \nBEGIN \n  IF in_date is NULL OR in_years is NULL THEN \n    RAISE NO_DATA_FOUND; \n  END IF; \n  new_date :&#x3D; ADD_MONTHS(in_date, 12 * in_years); \n  -- Additional code to add the number of months to the calculated date \n  IF in_months !&#x3D; 0 THEN \n    new_date :&#x3D; ADD_MONTHS(new_date, in_months); \n  END IF; \n  RETURN new_date; \nEND; \n\nUsing the new function, you can pass positive integer values for the number of years and thenumber of months to add years or months to the date, or you can pass negative values for each tosubtract years or months from the date. You can also use a combination of positive and negative integersfor each to obtain the desired date. Since the modified function contains a DEFAULT value of 0 for thenumber of months, it is possible to not specify a number of months, and you will achieve the same resultas the function in the Solution to the recipe.As you can see, this function is a bit easier to follow, but it does not allow for one to enter a negativevalue to subtract from the date. All the techniques described within this section have their own merit.However, it is always a good rule of thumb to write software so that it is easy to maintain in the future.Using this rule of thumb, the most favored technique of the three would be to use the ADD_MONTHSfunction as demonstrated in the Solution. Not only is this function easy to understand but also widelyused by others within the Oracle community. \n7-5. Determining the Interval Between Two DatesProblemYou want to determine the number of days between two dates. For example, working on an applicationto calculate credit card late fees, you are required to determine the number of days between any twogiven dates. The difference in days between the two dates will produce the number of days that thepayment is overdue. \nSolutionSubtract the two dates using simple math to find the interval in days. In this Solution, the example codesubtracts the current date from the due date to obtain the number of days that the payment is past due: \nCREATE OR REPLACE FUNCTION find_interval(from_date IN DATE, \n                                         to_date IN DATE) \nRETURN NUMBER AS \nBEGIN \n  RETURN abs(trunc(to_date) – trunc(from_date)); \nEND; \nThis function will return the difference between the two dates passed as arguments. Note that thenumber of days will be a decimal value. Although it is just as easy to subtract one date from anotherwithout the use of a helper function, sometimes it is useful to encapsulate the logic. This is especiallytrue if the same calculation will be performed multiple times throughout the application. \nHow It WorksOracle includes the ability to subtract dates in order to find the difference between the two. You can usethis functionality within PL&#x2F;SQL code or SQL queries. The result of the calculation is the number offractional days between the two dates. That number can be rounded in order to find the number of days,or it can be formatted to determine the number of days, hours, minutes, and seconds.As it stands, the result from the subtraction of two will return the number of days between the givendates. If you were interested in returning the number of hours, minutes, or seconds between the twodates, then you could do so by applying some simple mathematics to the result of the subtraction. Forinstance, to find an interval in minutes, multiply the result by 24 * 60. The following functions show howthis technique can be used to create separate functions for returning each time interval: \nCREATE OR REPLACE FUNCTION find_interval_hours(from_date IN DATE, \n                     to_date IN DATE) \nRETURN NUMBER AS \nBEGIN \n RETURN abs(trunc(from_date) - trunc(to_date) )* 24; \nEND; \n \n \nCREATE OR REPLACE FUNCTION find_interval_minutes(from_date IN DATE, \n                                         to_date IN DATE) \nRETURN NUMBER AS \nBEGIN \n  RETURN (from_date - to_date) * 24 * 60; \nEND; \n \n \nCREATE OR REPLACE FUNCTION find_interval_seconds(from_date IN DATE, \n                                         to_date IN DATE) \nRETURN NUMBER AS \nBEGIN \n  RETURN (from_date - to_date) * 24 * 60 * 60; \nEND;\nEach of these functions will return a decimal number that can be rounded. Now you can mix andmatch these functions as needed to return the desired time interval between two dates. \n7-6. Adding Hours, Minutes, Seconds, or Days to a Given DateProblemOne of your applications requires that you have the ability to add any number of days, hours, minutes, orseconds to a given date and time to produce a new date and time.SolutionCreate functions that add each of these time values to TIMESTAMP dataypes that are passed as anargument. Each of these functions will return the given time plus the amount of time that is passed in asargument. The following three functions will provide the ability to add hours, minutes, seconds, or daysto a given time. Each of these functions returns the calculated date and time using the TIMESTAMPdatatype.\nCREATE OR REPLACE FUNCTION calc_hours(time_to_change IN TIMESTAMP, \n                     timeval IN NUMBER)\nRETURN TIMESTAMP AS \n  new_time    TIMESTAMP;\nBEGIN \n  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,&#39;HOUR&#39;); \n  RETURN new_time;\nEND; \nCREATE OR REPLACE FUNCTION calc_minutes(time_to_change IN TIMESTAMP, \n                     timeval IN NUMBER)\nRETURN TIMESTAMP AS \n  new_time    TIMESTAMP;\nBEGIN \n  \n  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,&#39;MINUTE&#39;); \n  RETURN new_time;\nEND; \nCREATE OR REPLACE FUNCTION calc_seconds(time_to_change IN TIMESTAMP, \n                     timeval IN NUMBER)\nRETURN TIMESTAMP AS \n  new_time    TIMESTAMP;\nBEGIN \n  \n  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,&#39;SECOND&#39;); \n  RETURN new_time;\nEND; \n\nCREATE OR REPLACE FUNCTION calc_days(time_to_change IN TIMESTAMP, \n                     timeval IN NUMBER) \nRETURN TIMESTAMP as \n  new_time  TIMESTAMP; \nBEGIN \n  new_time :&#x3D; time_to_change + timeval; \n  RETURN new_time; \nEND; \nAll of these functions operate in a similar fashion. You must input a date in the form of a TIMESTAMP,and the calculated TIMESTAMP will be returned.How It WorksWhen performing the calculation of times and dates in Oracle, you have plenty of options. Over theyears, Oracle Database has introduced newer functions to help alleviate some of the difficulties thatwere encountered when attempting date and time calculations in earlier versions of the database. Dateand time calculations can be as simple as adding an integer to the DATE or TIMESTAMP. They can also bedifficult when many multiplications and divisions occur within the same calculation. The Solution to thisrecipe provides you with an easy way to add time to a given date using the NUMTODSINTERVAL function.The syntax for this function is as follows: \nNUMTODSINTERVAL(number, expression) \nThe expression that is passed to the function must be one of the following: HOUR, MINUTE, SECOND, orDAY. Technically, the functions created in the Solution are capable of subtracting the time or day valuesfrom the given date as well. If you were to pass a negative number to the functions, then theNUMTODSINTERVAL would subtract that many units from the given date and time and return the result. Thefunctions in the Solution also do not lock you into using a TIMESTAMP; if you were to pass a DATE type in asan argument, then it would work just as well.In the past, you used to only have the ability to use fractions to add or subtract hours, minutes, andseconds to a date. Over the next few examples, I will show you the sort of fractional mathematics thatyou may see in legacy code. You can add a fraction to a date or TIMESTAMP as both will return a result. Toadd hours to a date, use the fraction x&#x2F;24, where x is the number of hours (1–24) you want to add. Youcan subtract hours by using a negative value for x. This works because there are of course 24 hours inone day. The following example shows how you may see some legacy code using fractions to add hours. \n-- Add 1 hour to the current date \nresult :&#x3D; SYSDATE + 1&#x2F;24; \n \n-- Add 5 hours to the current date \nresult :&#x3D; CURRENT_TIMESTAMP + 5&#x2F;24; \nIt is possible to add minutes to a date using a similar technique with fractions. To add minutes, usethe fraction x&#x2F;24&#x2F;60, where x is the number of minutes (1–60) that you would like to add. Again, use anegative value in place of x in order to subtract that number of minutes from a date. This fraction worksbecause it divides the number assigned to x by the hours in the day and then divides that result by thenumber of minutes in an hour. The next figure shows an example of this technique. \n-- Add 10 mintes to the current date \nresult :&#x3D; SYSDATE + 10&#x2F;24&#x2F;60; \n-- Add 30 minutes to the current date \nresult :&#x3D; CURRENT_TIMESTAMP + 30&#x2F;24&#x2F;60; \nSimilarly, you can add seconds to a date by using the fraction x&#x2F;24&#x2F;3600. In this fraction, x is thenumber of seconds (1–60) that you want to add. Subtraction of seconds is possible by using a negativenumber for the x value. Just as with the other fractional calculations, this works because there are 3,600seconds in one hour. Therefore, the number assigned to x is divided by the number of hours in the day,and then that result is divided by the number of seconds in one hour. The next figure demonstratesadding seconds to the date using this technique: \n-- Add 10 seconds to the current date \nresult :&#x3D; SYSDATE + 10&#x2F;24&#x2F;3600; \n \n-- Add 45 seconds to the current date \nresult :&#x3D; CURRENT_TIMESTAMP + 45&#x2F;24&#x2F;3600; \n \nUsing the fractional mathematics, you can add each of the different fractions to the given date and \nachieve the same result. It is not uncommon for legacy code using fractional mathematics for date \ncalculation to look like the following: \n \n-- Add 2 hours, 5 minutes, and 30 seconds to the current date \nresult :&#x3D; SYSDATE + 2&#x2F;24 + 5&#x2F;24&#x2F;60 + 30&#x2F;24&#x2F;3600; \nThere are a number of ways to add time intervals to a given date. I recommend usingNUMTODSINTERVAL for performing mathematics on time values. In the past, this function was not available,so using fractional mathematics was the only way to add or subtract time from a given date. As shown inthe Solution to this recipe, it is possible to encapsulate the logic inside of a PL&#x2F;SQL function. If this isdone, then you could change the implementation inside the function and someone using it would neverknow the difference. Date and time calculations can be made even easier to use by writing functions toencapsulate the logic. \n7-7. Returning the First Day of a Given MonthProblemYou want to have the ability to obtain the name of the first day for a given month. \nSolutionWrite a PL&#x2F;SQL function that accepts a date and applies the necessary functions to return the first day ofmonth for the given date. \nCREATE OR REPLACE FUNCTION first_day_of_month(in_date DATE) \nRETURN VARCHAR2 IS \nBEGIN \n  RETURN to_char(trunc(in_date,&#39;MM&#39;), &#39;DD-MON-YYYY&#39;); \nEND; \nThe function created in this Solution will return the first day of the month that is passed into itbecause it is passed into the TRUNC function. \nHow It WorksThe TRUNC function can be useful for returning information from a DATE type. In this case, it is used toreturn the first day of the month from the given date. The Solution then converts the truncated datevalue to a character format and returns the result.The TRUNC function accepts two arguments, the first being the date that is to be truncated and thesecond being the format model. The format model is a series of characters that specifies how you wantto truncate the given date. Table 7-1 lists the format models along with a description of each.Table 7-1. Format Models for TRUNC \nFormat              Model Description \nMI                              Returns the nearest minute \nHH, HH12, HH24                  Returns the nearest hour \nD, DY, DAY                      Returns the first day of the week \nW                               Returns the same day of the week as the first day of the month \nIW                              Returns the same day of the week as the first day of ISO year \nWW                              Returns the same day of the week as the first day of the year \nRM, MM, MON, MONTH              Returns to the nearest first day of the month \nQ                               Returns to the nearest quarter \nI, IY, IYYY                     Returns the ISO year \nY, YY, YYY, SYEAR, YEAR, YYYY   Rounds to the nearest first day of the year \nCC, SCC                         Returns one greater than the first two digits of a given four-digit year\nThe Solution to this recipe returns the first day of the given month using the format model MM. \n7-8. Returning the Last Day of a Given MonthProblemYou want to have the ability to obtain the last day for a given month. \nSolutionUse the Oracle built-in LAST_DAY function to return the last day of the month for the date that you passinto it. The following example demonstrates a code block in which the LAST_DAY function is used toreturn the last day of the current month: \nDECLARE \n  last_day  VARCHAR2(20); \nBEGIN \n  select LAST_DAY(sysdate) \n  INTO last_day \n  FROM DUAL; \n  DBMS_OUTPUT.PUT_LINE(last_day); \nEND;\n\nHow It WorksThe LAST_DAY function is an easy way to retrieve the date for the last day of a given date. To use thefunction, pass in any date, and the last day of the month for the given date will be returned. The functioncan be useful in combination with other functions, especially for converting strings into dates and thendetermining the last day of the given month for the date given in string format. For example, thefollowing combination is used quite often: \nLAST_DAY(to_date(string_based_date,&#39;MM&#x2F;DD&#x2F;YYYY&#39;)) \n7-9. Rounding a NumberProblemYou are interested in rounding a given number. For example, let’s say you are working on employeetimecards, and you want to round to the nearest tenth of an hour for every given hour amount. \nSolutionUse the Oracle built-in ROUND function to return the result that you desire. For this Solution, you areworking with hours on employee timecards. To round to the nearest tenth, you would write a smallPL&#x2F;SQL function that uses the ROUND function and returns the result. The following exampledemonstrates this technique: \nCREATE OR REPLACE FUNCTION emp_labor_hours(time IN NUMBER) \nRETURN NUMBER IS \nBEGIN \n  RETURN ROUND(time, 1); \nEND; \nThe time will be rounded to the nearest tenth in this example because a 1 is passed as the secondargument to the ROUND function.How It WorksThe Oracle built-in ROUND function can be used for rounding numbers based upon a specified precisionlevel. To use the ROUND function, pass a number that you would like to round as the first argument, andpass the optional precision level as the second argument. If you do not specify a precision level, then thenumber will be rounded to the nearest integer. If the precision is specified, then the number will berounded to the number of decimal places specified by the precision argument.In the case of this Solution, a 1 was specified for the precision argument, so the number will berounded to one decimal place. The precision can be up to eight decimal places. If you specify a precisionlarger than eight decimal places, then the precision will default to eight. \n7-10. Rounding a Datetime ValueProblemGiven a particular date and time, you want the ability to round the date.SolutionUse the ROUND function passing the date you want to round along with the format model for the unit youwant to round. For example, suppose that given a date and time, you want to the nearest day. To do this,you would pass in the date along with the DD format model. The following code block demonstrates thistechnique: \nBEGIN \n  DBMS_OUTPUT.PUT_LINE(to_char(ROUND (SYSDATE, &#39;DD&#39;),&#39;MM&#x2F;DD&#x2F;YYYY - HH12:MI:SS&#39;)); \n END; \nThe previous code block will return the current date and time rounded to the nearest day. Forexample, if it is before 12 p.m., then it will round the given date back to 12 a.m. on that date; otherwise, itwill round forward to 12 a.m. on the next date.How It WorksYou can also use the ROUND function for working with DATE types. To round a date using this function, youmust specify the date you want to have rounded as the first argument along with the format parameterfor the type of rounding you want to perform. Table 7-2 lists the different format parameters forperforming DATE rounding. \nTable 7-2. Format Parameters for DATE Rounding \nFormat                            Parameter Description \nY, YYY, YYYY, YEAR, SYEAR, SYYYY  Rounds to the nearest year \nI, IY, IYYY                       Rounds to the nearest ISO year \nQ                                 Rounds to the nearest quarter \nRM, MM, MON, MONTH                Rounds to the nearest month \nWW                                Rounds to the same day of the week as the first day of the year \nIW                                Rounds to the same day of the week as the first day of the ISO year\nW                                 Rounds to the same day of the week as the first day of the month \nJ, DD, DDD                        Rounds to the nearest day \nD, DY, DAY                        Rounds to the start day of the week \nHH, HH12, HH24                    Rounds to the nearest hour \nMI                                Rounds to the nearest minute \nIf you find that you are using the same date conversion in many places throughout your application,then it may make sense to create a function to encapsulate the call to the ROUND function. Doing so wouldenable a simple function call that can be used to return the date value you require rather thanremembering to use the correct format parameter each time. \n7-11. Tracking Time to a MillisecondProblemYou are interested in tracking time in a finely grained manner to the millisecond. For example, you wantto determine the exact time in which a particular change is made to the database. \nSolutionPerform simple mathematics with the current date time in order to determine the exact time down themillisecond. The following function accepts a timestamp and returns the |milliseconds: \nCREATE OR REPLACE FUNCTION capture_milliseconds(in_time TIMESTAMP)  \nRETURN NUMBER IS \n  milliseconds    NUMBER; \n  CHAPTER 7  NUMBERS, STRINGS, AND DATES \n147 \nBEGIN \nselect sum( \n   (extract(hour from in_time))*3600+ \n   (extract(minute from in_time))*60+ \n   (extract(second from in_time)))*1000 \ninto MILLISECONDS from dual; \nRETURN milliseconds; \n \nEND;\n\nHow It WorksIf your application requires a fine-grained accuracy for time, then you may want to track time inmilliseconds. Performing a calculation such as the one demonstrated in the Solution to this recipe on agiven DATE or TIMESTAMP can do this. By combining the EXTRACT function with some calculations, thedesired milliseconds result can be achieved.The EXTRACT function is used to extract YEAR, MONTH, or DATE units from a DATE type. It can extractHOUR, MINUTE, or SECOND from a TIMESTAMP. Milliseconds can be calculated by obtaining the sum of thehours multiplied by 3600, the minutes multiplied by 60, and the seconds multiplied by 1000 from a givenTIMESTAMP. If you need to use milliseconds in your program, then I recommend creating a function suchas the one demonstrated in the Solution to this recipe to encapsulate this logic. \n7-12. Associating a Time Zone with a Date and TimeProblemYou want to associate a time zone with a given date and time in order to be more precise. \nSolutionCreate a code block that declares a field as type TIMESTAMP WITH TIME ZONE. Assign a TIMESTAMP to thenewly declared field within the body of the code block. After doing so, the field that you declared willcontain the date and time of the TIMESTAMP that you assigned along with the associated time zone. Thefollowing example demonstrates a code block that performs this technique using the SYSTIMESTAMP: \nDECLARE \n  time   TIMESTAMP WITH TIME ZONE; \n BEGIN \n  time :&#x3D; SYSTIMESTAMP; \n  DBMS_OUTPUT.PUT_LINE(time); \n END; \nThe results that will be displayed via the call to DBMS_OUTPUT should resemble something similar tothe following: \n29-AUG-10 10.27.58.639000 AM -05:00 \nPL&#x2F;SQL procedure successfully completed. \nHow It WorksPrior to the TIMESTAMP datatype being introduced in Oracle 9i, the DATE type was the only way to workwith dates. There were limited capabilities provided, and later the TIMESTAMP was created to fill thosegaps. For those needing to make use of time zones, Oracle created the TIMESTAMP WITH TIME ZONE andTIMESTAMP WITH LOCAL TIME ZONE datatypes. Both of these datatypes provide a time zone to beassociated with a given date, but they work a bit differently. When you specify the WITH TIME ZONEoption, the time zone information is stored within the database along with the hours, minutes, and soon. However, if you specify the WITH LOCAL TIME ZONE option, the time zone information is not storedwithin the database, but rather it is calculated each time against a baseline time zone, which determinesthe time zone of your current session.In the Solution to this recipe, the time zone information is stored within the database along with therest of the date and time associated with the TIMESTAMP. \n7-13. Finding a Pattern Within a StringProblemYou want to find the number of occurrences of a particular pattern within a given string. For instance,you want to search for email addresses within a body of text. \nSolutionUse a regular expression to match a given string against the body of text and return the resulting count ofmatching occurrences. The following example searches through a given body of text and counts thenumber of email addresses it encounters. Any email address will be added to the tally because a regularexpression is used to compare the strings. \nCREATE OR REPLACE PROCEDURE COUNT_EMAIL_IN_TEXT(text_var     IN VARCHAR2) AS \n  counter    NUMBER :&#x3D; 0; \n  mail_pattern    VARCHAR2(15) :&#x3D; &#39;\\w+@\\w+(\\.\\w+)+&#39;; \nBEGIN \n  counter :&#x3D; REGEXP_COUNT(text_var, mail_pattern); \n \n  IF COUNTER &#x3D; 1 THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;This passage provided contains 1 email address’); \n  ELSIF counter &gt; 1 THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;This passage provided contains &#39;|| \n                     counter || &#39; email addresses&#39;); \n  ELSE \n    DBMS_OUTPUT.PUT_LINE(&#39;This passage provided contains &#39; || \n            &#39;no email addresses&#39;); \n  END IF; \nEND; \nThe function in this example provides a single service because it counts the number of occurrencesof an email address in a given body of text and returns the result. \nHow It WorksYou can use regular expressions to help match strings of numbers, text, or alphanumeric values. Theyare sequences of characters and symbols that assimilate a pattern that can be used to match againststrings of text. A regular expression is similar to using the % symbol as a wildcard within a query, exceptthat a regular expression provides a pattern that text must match against. Please refer to online Oracledocumentation for a listing of the different options that can be used for creating regular expressionpatterns.  \nOracle introduced the REGEXP_COUNT function in Oracle 11g, which provides the functionality of countingthe number of occurrences of a given string within a given body of text. The syntax for the REGEXP_COUNTfunction is as follows: \nREGEXP_COUNT(source_text, pattern, position, options) \nThe source text for the function can be any string literal, variable, or column that has a datatype ofVARCHAR2, NVARCHAR2, CHAR, NCHAR, CLOB, or NCLOB. The pattern is a regular expression or a string of text thatwill be used to match against. The position specifies the placement within the source text where thesearch should begin. By default, the position is 1. The options include different useful matchingmodifiers; please refer to the Oracle regular expression support documentation athttp://download.oracle.com/docs/cd/E14072_01/server.112/e10592/ap_posix.htm#g693775 for a listingof the pattern matching modifiers that can be used as options.The REGEXP_COUNT function can be used within any Oracle SQL statement or PL&#x2F;SQL program. Thefollowing are a few more examples of using this function: \n-- Count all occurrences of the letter &#39;l&#39; in the word Hello \nresult :&#x3D; REGEXP_COUNT(&#39;hello&#39;,&#39;l&#39;); \n \nReturns:  2 \n \n-- Count the number of occurrences of the pattern &#39;ells&#39; beginning at \n-- the fifth character. \nresult :&#x3D; REGEXP_COUNT(&#39;she sells sea shells by the sea shore&#39;, \n                      &#39;ells&#39;,7,&#39;c&#39;); \n \nReturns: 1 \n \n-- Count the number of words in the line \nresult :&#x3D; REGEXP_COUNT(&#39;she sells sea shells by the sea shore&#39;, \n                      &#39;\\w+&#39;); \n \nReturns: 8 \nAs you can see from these examples, the REGEXP_COUNT function is a great addition to the Oracleregular expression function family \n7-14. Determining the Position of a Pattern Within a StringProblemYou want to return the position of a matching string within a body of text. Furthermore, you are want topattern match and therefore must invoke a regular expression function. For example, you need to find away to determine the position of a string that matches the pattern of a phone number. \nSolutioUse the REGEXP_INSTR function to use a regular expression to search a body of text to find the position ofa phone number. The following code block demonstrates this technique by looping through each of therows in the EMPLOYEES table and determining whether the employee phone number is USA orinternational:\nDECLARE \n  CURSOR emp_cur IS \n  SELECT * \n  FROM employees; \n  emp_rec       emp_cur%ROWTYPE; \n  position     NUMBER :&#x3D; 0; \n  counter        NUMBER :&#x3D; 0; \n  intl_count     NUMBER :&#x3D; 0;\nBEGIN \n  FOR emp_rec IN emp_cur LOOP \n  position :&#x3D; REGEXP_INSTR(emp_rec.phone_number, \n  &#39;([[:digit:]]&#123;3&#125;)\\.([[:digit:]]&#123;3&#125;)\\.([[:digit:]]&#123;4&#125;)&#39;); \n   \n  IF position &gt; 0 THEN \n    counter :&#x3D; counter + 1; \n  ELSE \n    intl_count :&#x3D; intl_count + 1; \n  END IF; \n  END LOOP; \n  DBMS_OUTPUT.PUT_LINE(&#39;Numbers within USA: &#39; || counter); \n  DBMS_OUTPUT.PUT_LINE(&#39;International Numbers: &#39; || intl_count); \nEND; \nResult:Numbers within USA: 72International Numbers: 35PL&#x2F;SQL procedure successfully completed. \nHow It WorksIn the Solution to this recipe, the function uses REGEXP_INSTR to find all telephone numbers that matchthe U.S. telephone number format. The field passed into REGEXP_INSTR is always going to return atelephone number, but that number may be in an international format or a U.S. format. If the pattern ofthe telephone number matches that of a U.S. format, then the counter for U.S. numbers is increased byone. Otherwise, the counter for the international numbers is increased by one. The reasonableassumption is that if a number is not a U.S. number, that it is an “international” number. UsingREGEXP_INSTR makes this a very easy function to implement.REGEXP_INSTR will return the position of the first or last character of the matching string dependingupon the value of the return option argument. This function provides the same functionality of INSTRexcept that it also allows the ability to use regular expression patterns. The syntax for this function is asfollows: \nREGEXP_INSTR(source_text, pattern, position, occurrence, \n                               return_option, match parameter, subexpression) \nAll but the source_text and pattern parameters are optional. The source_text is the string of text tobe searched. The pattern is a regular expression or string that will be matched against the source_text.The optional position argument is an integer that specifies on which character Oracle should start thesearch. The optional occurrence parameter specifies which occurrence of the pattern will have itsposition returned. The default occurrence argument is 1, which means that the position of the firstmatching string will be returnedThe optional return_option is used to specify special options that are outlined within the Oracleregular expression documentation that can be found athttp://download.oracle.com/docs/cd/E11882_01/server.112/e10592/ap_posix.htm#g693775. Theoptional match_parameter allows you to change the default matching behavior. The subexpressionparameter is optional, and it is an integer from 0 to 9 that indicates which subexpression in thesource_text will be the target of the function. \n7-15. Finding and Replacing Text Within a StringProblemYou want to replace each occurrence of a given string within a body of text.SolutionUse the REGEXP_REPLACE function to match a pattern of text against a given body of text, and replace allmatching occurrences with a new string. In the following function, the REGEXP_REPLACE function is usedto replace all occurrences of the JOB_TITLE ‘Programmer’ with the new title of ‘Developer.’ \nDECLARE \n  CURSOR job_cur IS \n  SELECT * \n  FROM jobs; \n \n  job_rec       job_cur%ROWTYPE; \n  new_job_title jobs.job_title%TYPE; \nBEGIN \n  FOR job_rec IN job_cur LOOP \n    IF REGEXP_INSTR(job_rec.job_title,&#39;Programmer&#39;) &gt; 0 THEN \n      new_job_title :&#x3D; REGEXP_REPLACE(job_rec.job_title, &#39;Programmer&#39;, \n                                    &#39;Developer&#39;); \n \n      UPDATE jobs \n      SET job_title &#x3D; new_job_title \n      WHERE job_id &#x3D; job_rec.job_id; \n     \n      DBMS_OUTPUT.PUT_LINE(job_rec.job_title || &#39; replaced with &#39; || \n         new_job_title); \n    END IF; \n END LOOP; \n \nEND; \nAlthough this particular example does not use any regular expression patterns, it could be adjustedto do so. To find more information and tables specifying the options that are available for creatingpatterns, please refer to the online Oracle documentation.The Solution to this recipe prints out the revised text. Each occurrence of the ‘Programmer’ text isreplaced with ‘Developer’, and the newly generated string is returned into the NEW_REVIEW variable. \nHow It WorksThe REGEXP_REPLACE function is a great way to find and replace strings within a body of text. The functioncan be used within any Oracle SQL statement or PL&#x2F;SQL code. The syntax for the function is as follows: \nREGEXP_REPLACE(source_text, pattern, replacement_string, position, occurrence, options) \nThe source text for the function can be any string literal, variable, or column that has a datatype ofVARCHAR2, NVARCHAR2, CHAR, NCHAR, CLOB, or NCLOB. The pattern is a regular expression or a string of text thatwill be used to match against. The replacement string is will replace each occurrence of the stringidentified by the source text. The optional position specifies the placement within the source text wherethe search should begin. By default, the position is 1. The optional occurrence argument is anonnegative integer that indicates the occurrence of the replace operation. If a 0 is specified, then allmatching occurrences will be replaced. If a positive integer is specified, then Oracle will replace thematch for that occurrence with the replacement string. The optional options argument includesdifferent useful matching modifiers; please refer to the online Oracle documentation for a listing of thepattern matching modifiers that can be used as options.■ Note Do not use REGEXP_REPLACE if the replacement can be performed with a regular UPDATE statement. SinceREGEXP_REPLACE uses regular expressions, it can be slower than a regular UPDATE.The following examples demonstrate how this function can be used within a PL&#x2F;SQL application ora simple query. This next bit of code demonstrates how to replace numbers that match those within thegiven set. \nselect REGEXP_REPLACE(&#39;abcdefghi&#39;,&#39;[acegi]&#39;,&#39;x&#39;) from dual; \nReturns: xbxdxfxhx \nNext, we replace a Social Security Number with Xs. \nnew_ssn :&#x3D; REGEXP_REPLACE(‘123-45-6789’,’[[:digit:]]{3}-[[:digit:]]{2}-[[:digit:]]{4}’,’xxx-xxx-xxxx’); \nReturns: xxx-xxx-xxxx \nThe REGEXP_REPLACE function can be most useful when attempting to replace patterns of strings within agiven body of text such as the two previous examples have shown. As noted previously, if a standardUPDATE statement can be used to replace a value, then that should be the first choice, because regularexpressions perform slightly slower. \n","dateCreated":"2022-11-08T23:17:08+08:00","dateModified":"2022-11-08T23:39:33+08:00","datePublished":"2022-11-08T23:17:08+08:00","description":"摘要: 其实这个讲PLSQL有点基础","headline":"Oracle PLSQL Recipes 07-Numbers, Strings, and Dates","image":[null,"https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_07/"},"publisher":{"@type":"Organization","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_07/","thumbnailUrl":"https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"}</script>
    <meta name="description" content="摘要: 其实这个讲PLSQL有点基础">
<meta property="og:type" content="blog">
<meta property="og:title" content="Oracle PLSQL Recipes 07-Numbers, Strings, and Dates">
<meta property="og:url" content="https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_07/index.html">
<meta property="og:site_name" content="CoffeeMan">
<meta property="og:description" content="摘要: 其实这个讲PLSQL有点基础">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-08T15:17:08.515Z">
<meta property="article:modified_time" content="2022-11-08T15:39:33.855Z">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/avatar.jpg"/>
    
    
    
        <meta property="og:image" content="https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-y9io9e1ok9lpsmk4fyk7quzstdgr6eztu8x2xr6n9iikjgfjbcqqpobdlqy8.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CoffeeMan
        </a>
    </div>
    
        
            <a
                class="header-right-picture open-algolia-search"
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/SimonTeo58"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/11289672/simon-teo"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/shiming_kirk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/kirk-zhang-424935235/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/zxc741208584@qq.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    "
             style="background-image:url('https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg');"
             data-behavior="2">
            
        </div>

            <div id="main" data-behavior="2"
                 class="hasCover
                        hasCoverMetaOut
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Oracle PLSQL Recipes 07-Numbers, Strings, and Dates
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-11-08T23:17:08+08:00">
	
		    Nov 08, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/oracle/">oracle</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>摘要: 其实这个讲PLSQL有点基础</p>
<span id="more"></span>

<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Numbers-Strings-and-Dates"><span class="toc-text">7. Numbers, Strings, and Dates</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Concatenating-Strings"><span class="toc-text">7-1. Concatenating Strings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Adding-Some-Number-of-Days-to-a-Date"><span class="toc-text">7-2. Adding Some Number of Days to a Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Adding-a-Number-of-Months-to-a-Date"><span class="toc-text">7-3. Adding a Number of Months to a Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Adding-Years-to-a-Date"><span class="toc-text">7-4. Adding Years to a Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-Determining-the-Interval-Between-Two-Dates"><span class="toc-text">7-5. Determining the Interval Between Two Dates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-Adding-Hours-Minutes-Seconds-or-Days-to-a-Given-Date"><span class="toc-text">7-6. Adding Hours, Minutes, Seconds, or Days to a Given Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-Returning-the-First-Day-of-a-Given-Month"><span class="toc-text">7-7. Returning the First Day of a Given Month</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-Returning-the-Last-Day-of-a-Given-Month"><span class="toc-text">7-8. Returning the Last Day of a Given Month</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-Rounding-a-Number"><span class="toc-text">7-9. Rounding a Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-10-Rounding-a-Datetime-Value"><span class="toc-text">7-10. Rounding a Datetime Value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-Tracking-Time-to-a-Millisecond"><span class="toc-text">7-11. Tracking Time to a Millisecond</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-12-Associating-a-Time-Zone-with-a-Date-and-Time"><span class="toc-text">7-12. Associating a Time Zone with a Date and Time</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-13-Finding-a-Pattern-Within-a-String"><span class="toc-text">7-13. Finding a Pattern Within a String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-14-Determining-the-Position-of-a-Pattern-Within-a-String"><span class="toc-text">7-14. Determining the Position of a Pattern Within a String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-15-Finding-and-Replacing-Text-Within-a-String"><span class="toc-text">7-15. Finding and Replacing Text Within a String</span></a></li></ol></li></ol>


<h1 id="7-Numbers-Strings-and-Dates"><a href="#7-Numbers-Strings-and-Dates" class="headerlink" title="7. Numbers, Strings, and Dates"></a>7. Numbers, Strings, and Dates</h1><p>Every PL&#x2F;SQL program uses one or more datatypes. This chapter focuses on some details that you<br>should know when working with data in the form of numbers, strings, and dates. Each recipe in this<br>chapter provides a basic tip for working with these datatypes. From basic string concatenation to more<br>advanced regular expression processing, you’ll learn some techniques for getting things done in an<br>effective manner. You’ll learn about date calculations as well. When you’re done with this chapter, you’ll<br>be ready to move on to the more advanced recipes later in the chapters to follow. </p>
<h2 id="7-1-Concatenating-Strings"><a href="#7-1-Concatenating-Strings" class="headerlink" title="7-1. Concatenating Strings"></a>7-1. Concatenating Strings</h2><p><strong><strong>Problem</strong></strong><br>You have two or more text strings, or variables containing strings, that you want to combine. </p>
<p><strong><strong>Solution</strong></strong><br>Use the concatenation operator to append the strings. In the following example, you can see that two<br>variables are concatenated to a string of text to form a single string of text: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  CURSOR emp_cur IS 
  SELECT employee_id, first_name, last_name 
  FROM EMPLOYEES 
  WHERE HIRE_DATE &gt; TO_DATE(&#39;01&#x2F;01&#x2F;2000&#39;,&#39;MM&#x2F;DD&#x2F;YYYY&#39;); 
   
  emp_rec       emp_cur%ROWTYPE; 
  emp_string    VARCHAR2(150); 
BEGIN 
  DBMS_OUTPUT.PUT_LINE(&#39;EMPLOYEES HIRED AFTER 01&#x2F;01&#x2F;2000&#39;); 
  DBMS_OUTPUT.PUT_LINE(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;); 
  FOR emp_rec IN emp_cur LOOP 
        emp_string :&#x3D; emp_rec.first_name || &#39; &#39; || 
                      emp_rec.last_name || &#39; - &#39; || 
                      &#39;ID #: &#39; || emp_rec.employee_id; 
 
        DBMS_OUTPUT.PUT_LINE(emp_string); 
  END LOOP; 
END; </code></pre>
<p>You can see that the example uses the concatenation operator || to formulate a string of text that<br>contains each employee’s first name, last name, and employee ID number.<br><strong><strong>How It Works</strong></strong><br>As you have seen in the <strong>Solution</strong> to this recipe, the concatenation operator is used for concatenating<br>strings within your PL&#x2F;SQL applications. When the concatenation operator is used to concatenate<br>numbers with strings, the numbers are automatically converted into strings and then concatenated.<br>Similarly, an automatic conversion occurs with dates before being concatenated. </p>
<h2 id="7-2-Adding-Some-Number-of-Days-to-a-Date"><a href="#7-2-Adding-Some-Number-of-Days-to-a-Date" class="headerlink" title="7-2. Adding Some Number of Days to a Date"></a>7-2. Adding Some Number of Days to a Date</h2><p><strong><strong>Problem</strong></strong><br>You want to add a number of days to a given date. For example, you are developing an application that<br>calculates shipping dates for a company’s products. In this case, your application is processing<br>shipments, and you need to calculate a date that is 14 days from the current date.<br><strong><strong>Solution</strong></strong><br>Treat the number of days as an integer, and add that integer to your DATE value. The following lines of<br>code show how this can be done: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  ship_date    DATE :&#x3D; SYSDATE + 14; 
BEGIN 
  DBMS_OUTPUT.PUT_LINE(&#39;The shipping date for any products &#39;|| 
                       &#39;that are ordered today is &#39; || ship_date); 
END; 
 
The result that is displayed for this example will be 14 days past your current date.  
If you wanted to encapsulate this logic within a function, then it would be easy to do. The following 
function takes a date and a number as arguments. The function will perform simple mathematics and 
return the result. 
 
CREATE OR REPLACE FUNCTION calculate_days(date_to_change  IN DATE, 
                                          number_of_days  IN NUMBER) 
RETURN DATE IS 
BEGIN 
  RETURN date_to_change + number_of_days; 
END; </code></pre>
<p>Notice that the name of the function does not include the word add, such as ADD_DAYS. That was<br>done on purpose because this function not only allows addition of days to a date, but if a negative<br>number is passed in as an argument, then it will also subtract the number of days from the given date. </p>
<p><strong><strong>How It Works</strong></strong><br>Since calculations such as these are the most common date calculations performed, Oracle makes them<br>easy to do. If a number is added to or subtracted from a DATE value, Oracle Database will add or subtract<br>that number of days from the date value. DATE types can have numbers added to them, and they can also<br>have numbers subtracted from them. Multiplication and division do not work because it is not possible<br>to perform such a calculation on a date. For example, it doesn’t mean anything to speak of multiplying a<br>date by some value.<br>If you are developing an application that always performs an addition or subtraction using the same<br>number of days, it may be helpful to create a function such as the one demonstrated in the <strong>Solution</strong> to<br>this recipe. For instance, if you were developing a billing application and always required a date that was<br>30 days into the future of the current date, then you could create a function named BILLING_DATE and<br>hard-code the 30 days into it. This is not necessary, but if your business or application depended upon it,<br>then it may be a good idea to encapsulate logic to alleviate possible data entry errors. </p>
<h2 id="7-3-Adding-a-Number-of-Months-to-a-Date"><a href="#7-3-Adding-a-Number-of-Months-to-a-Date" class="headerlink" title="7-3. Adding a Number of Months to a Date"></a>7-3. Adding a Number of Months to a Date</h2><p><strong><strong>Problem</strong></strong><br>You want to add some number of months to a date. For example, you are developing a payment<br>application for a company, and it requires payments every six months. You need to enable the<br>application to calculate the date six months in the future of the current date.<br>■ Note This recipe’s <strong>Solution</strong> also works for subtracting months. Simply “add” a negative number of months.  </p>
<p><strong><strong>Solution</strong></strong><br>Use the ADD_MONTHS function to add six months onto the given date.  Doing so will enable your<br>application to create bills for future payments.  This technique is demonstrated in the following<br>example: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  new_date    DATE; 
BEGIN 
  new_date :&#x3D; ADD_MONTHS(sysdate,6); 
  DBMS_OUTPUT.PUT_LINE(&#39;The newly calculated date is: &#39; || new_date); 
END; </code></pre>

<p>This simple technique will enable you to add a number of months to any given date. As with any<br>other logic, this could easily be encapsulated into a function for the specific purpose of producing a<br>billing date that was six months into the future of the current date. Such a function may look something<br>like the next example: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION calc_billing_date IS 
BEGIN 
  RETURN ADD_MONTHS(sysdate, 6); 
END;</code></pre>

<p>Although this function does not do much besides encapsulate logic, it is a good idea to code such<br>functions when developing a larger application where this type of calculation may be performed several<br>times. It will help to maintain consistency and alleviate maintenance issues if the date calculation ever<br>needs to change. You could simply make the change within the function rather than visiting all the<br>locations in the code that use the function. </p>
<p><strong><strong>How It Works</strong></strong><br>Oracle provides the ADD_MONTHS function to assist with date calculations. This function has two<br>purposes—to add or subtract a specified number of months from the given date. The syntax for use of<br>the ADD_MONTHS function is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">ADD_MONTHS(date, integer) </code></pre>

<p>You can also use the function to subtract months from the given date. If the function is passed a<br>negative integer in place of the month’s argument, then that number of months will be subtracted from<br>the date. The following example demonstrates this functionality: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  new_date    DATE; 
BEGIN 
  new_date :&#x3D; ADD_MONTHS(sysdate,-2); 
  DBMS_OUTPUT.PUT_LINE(&#39;The newly calculated date is: &#39; || new_date); 
END; </code></pre>

<p>As you can see from the example in Figure 7-3, the negative integer is the only change made to the<br>code in order to achieve a subtraction of months rather than an addition. As a result, the example in this<br>figure will return the current date minus two months.<br>In the case that you are attempting to add months to a date that represents the last day of the<br>month, the ADD_MONTHS function works a bit differently than you might expect. For instance, if it is August<br>31 and you want to add one month, then you would expect the calculation to resolve to September 31,<br>which is not possible. However, ADD_MONTHS is smart enough to return the last day of September in this<br>case. The following code provides a demonstration: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  new_date    DATE; 
BEGIN 
  new_date :&#x3D; ADD_MONTHS(to_date(&#39;08&#x2F;31&#x2F;2010&#39;,&#39;MM&#x2F;DD&#x2F;YYYY&#39;),1); 
  DBMS_OUTPUT.PUT_LINE(&#39;The last day of next month is: &#39; || new_date); 
END; </code></pre>

<p>The following is the resulting output: </p>
<p>The last day of next month is: 30-SEP-10 </p>
<p>PL&#x2F;SQL procedure successfully completed.<br>In general, if your source date is the late day of its month, then your result date will be forced to the<br>last day of its respective month. Adding one month to September 30, for example, will yield October 31. </p>
<h2 id="7-4-Adding-Years-to-a-Date"><a href="#7-4-Adding-Years-to-a-Date" class="headerlink" title="7-4. Adding Years to a Date"></a>7-4. Adding Years to a Date</h2><p><strong><strong>Problem</strong></strong><br>You are developing an application that requires date calculations to be performed. You need to<br>determine how to add to a specified date. You may also want to subtract years.  </p>
<p><strong><strong>Solution</strong></strong><br>Create a function that will calculate a new date based upon the number of years that you have specified.<br>If you want to subtract a number of years from a date, then pass a negative value for the number of years.<br>The following code implements this functionality: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION calculate_date_years (in_date DATE, 
                                    in_years NUMBER) 
RETURN DATE AS 
  new_date    DATE; 
BEGIN 
  IF in_date is NULL OR in_years is NULL THEN 
    RAISE NO_DATA_FOUND; 
  END IF; 
  new_date :&#x3D; ADD_MONTHS(in_date, 12 * in_years); 
  RETURN new_date; 
END; </code></pre>
<p>The example function expects to receive a date and a number of years to add or subtract as<br>arguments. If one of those arguments is left out, then PL&#x2F;SQL will raise an ORA-06553 error, and the<br>example also raises a special NO_DATA_FOUND error if one or both of the arguments are NULL. The return<br>value will be the input date but in the newly calculated year. </p>
<p><strong><strong>How It Works</strong></strong><br>Oracle provides a couple of different ways to calculate dates based upon the addition or subtraction of<br>years. One such technique is to use the ADD_MONTHS function that was discussed in Recipe 7-3, as the<br><strong>Solution</strong> to this recipe demonstrates. Simple mathematics allow you to multiply the number of years<br>passed into the ADD_MONTHS function by 12 since there are 12 months in the year. Essentially this<br>technique exploits the ADD_MONTHS function to return a date a specified number of dates into the future.<br>■ Note See Recipe 7-3 for discussion of a corner case involving the use of ADD_MONTHS on a date that represents<br>the final day of that date’s month.<br>You can use this same technique to subtract a number of years from the specified date by passing a<br>negative integer value that represents the number of years you want to subtract. For instance, if you<br>wanted to subtract five years from the date 06&#x2F;01&#x2F;2000, then pass a -5 to the function that was created in<br>the <strong>Solution</strong> to this recipe. The following query demonstrates this strategy. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">select calculate_date_years(to_date(&#39;06&#x2F;01&#x2F;2000&#39;,&#39;MM&#x2F;DD&#x2F;YYYY&#39;),-5) from dual; </code></pre>
<p>Here’s the result: </p>
<pre class="language-text" data-language="text"><code class="language-text">06/01/1995 </code></pre>
<p>Using the ADD_MONTHS function works well for adding or subtracting a rounded number of years.<br>However, if you wanted to add one year and six months, then it would take another line of code to add<br>the number of months to the calculated date. The function in the next example is a modified version of<br>the CALCULATE_DATE_YEARS function that allows you to specify a number of months to add or subtract as<br>well: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION calculate_date_years (in_date DATE, 
                                              in_years IN NUMBER, 
                                              in_months IN NUMBER DEFAULT 0) 
RETURN DATE AS 
  new_date    DATE; 
BEGIN 
  IF in_date is NULL OR in_years is NULL THEN 
    RAISE NO_DATA_FOUND; 
  END IF; 
  new_date :&#x3D; ADD_MONTHS(in_date, 12 * in_years); 
  -- Additional code to add the number of months to the calculated date 
  IF in_months !&#x3D; 0 THEN 
    new_date :&#x3D; ADD_MONTHS(new_date, in_months); 
  END IF; 
  RETURN new_date; 
END; </code></pre>

<p>Using the new function, you can pass positive integer values for the number of years and the<br>number of months to add years or months to the date, or you can pass negative values for each to<br>subtract years or months from the date. You can also use a combination of positive and negative integers<br>for each to obtain the desired date. Since the modified function contains a DEFAULT value of 0 for the<br>number of months, it is possible to not specify a number of months, and you will achieve the same result<br>as the function in the <strong>Solution</strong> to the recipe.<br>As you can see, this function is a bit easier to follow, but it does not allow for one to enter a negative<br>value to subtract from the date. All the techniques described within this section have their own merit.<br>However, it is always a good rule of thumb to write software so that it is easy to maintain in the future.<br>Using this rule of thumb, the most favored technique of the three would be to use the ADD_MONTHS<br>function as demonstrated in the <strong>Solution</strong>. Not only is this function easy to understand but also widely<br>used by others within the Oracle community. </p>
<h2 id="7-5-Determining-the-Interval-Between-Two-Dates"><a href="#7-5-Determining-the-Interval-Between-Two-Dates" class="headerlink" title="7-5. Determining the Interval Between Two Dates"></a>7-5. Determining the Interval Between Two Dates</h2><p><strong><strong>Problem</strong></strong><br>You want to determine the number of days between two dates. For example, working on an application<br>to calculate credit card late fees, you are required to determine the number of days between any two<br>given dates. The difference in days between the two dates will produce the number of days that the<br>payment is overdue. </p>
<p><strong><strong>Solution</strong></strong><br>Subtract the two dates using simple math to find the interval in days. In this <strong>Solution</strong>, the example code<br>subtracts the current date from the due date to obtain the number of days that the payment is past due: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION find_interval(from_date IN DATE, 
                                         to_date IN DATE) 
RETURN NUMBER AS 
BEGIN 
  RETURN abs(trunc(to_date) – trunc(from_date)); 
END; </code></pre>
<p>This function will return the difference between the two dates passed as arguments. Note that the<br>number of days will be a decimal value. Although it is just as easy to subtract one date from another<br>without the use of a helper function, sometimes it is useful to encapsulate the logic. This is especially<br>true if the same calculation will be performed multiple times throughout the application. </p>
<p><strong><strong>How It Works</strong></strong><br>Oracle includes the ability to subtract dates in order to find the difference between the two. You can use<br>this functionality within PL&#x2F;SQL code or SQL queries. The result of the calculation is the number of<br>fractional days between the two dates. That number can be rounded in order to find the number of days,<br>or it can be formatted to determine the number of days, hours, minutes, and seconds.<br>As it stands, the result from the subtraction of two will return the number of days between the given<br>dates. If you were interested in returning the number of hours, minutes, or seconds between the two<br>dates, then you could do so by applying some simple mathematics to the result of the subtraction. For<br>instance, to find an interval in minutes, multiply the result by 24 * 60. The following functions show how<br>this technique can be used to create separate functions for returning each time interval: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION find_interval_hours(from_date IN DATE, 
                     to_date IN DATE) 
RETURN NUMBER AS 
BEGIN 
 RETURN abs(trunc(from_date) - trunc(to_date) )* 24; 
END; 
 
 
CREATE OR REPLACE FUNCTION find_interval_minutes(from_date IN DATE, 
                                         to_date IN DATE) 
RETURN NUMBER AS 
BEGIN 
  RETURN (from_date - to_date) * 24 * 60; 
END; 
 
 
CREATE OR REPLACE FUNCTION find_interval_seconds(from_date IN DATE, 
                                         to_date IN DATE) 
RETURN NUMBER AS 
BEGIN 
  RETURN (from_date - to_date) * 24 * 60 * 60; 
END;</code></pre>
<p>Each of these functions will return a decimal number that can be rounded. Now you can mix and<br>match these functions as needed to return the desired time interval between two dates. </p>
<h2 id="7-6-Adding-Hours-Minutes-Seconds-or-Days-to-a-Given-Date"><a href="#7-6-Adding-Hours-Minutes-Seconds-or-Days-to-a-Given-Date" class="headerlink" title="7-6. Adding Hours, Minutes, Seconds, or Days to a Given Date"></a>7-6. Adding Hours, Minutes, Seconds, or Days to a Given Date</h2><p><strong><strong>Problem</strong></strong><br>One of your applications requires that you have the ability to add any number of days, hours, minutes, or<br>seconds to a given date and time to produce a new date and time.<br><strong><strong>Solution</strong></strong><br>Create functions that add each of these time values to TIMESTAMP dataypes that are passed as an<br>argument. Each of these functions will return the given time plus the amount of time that is passed in as<br>argument. The following three functions will provide the ability to add hours, minutes, seconds, or days<br>to a given time. Each of these functions returns the calculated date and time using the TIMESTAMP<br>datatype.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION calc_hours(time_to_change IN TIMESTAMP, 
                     timeval IN NUMBER)
RETURN TIMESTAMP AS 
  new_time    TIMESTAMP;
BEGIN 
  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,&#39;HOUR&#39;); 
  RETURN new_time;
END; 
CREATE OR REPLACE FUNCTION calc_minutes(time_to_change IN TIMESTAMP, 
                     timeval IN NUMBER)
RETURN TIMESTAMP AS 
  new_time    TIMESTAMP;
BEGIN 
  
  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,&#39;MINUTE&#39;); 
  RETURN new_time;
END; 
CREATE OR REPLACE FUNCTION calc_seconds(time_to_change IN TIMESTAMP, 
                     timeval IN NUMBER)
RETURN TIMESTAMP AS 
  new_time    TIMESTAMP;
BEGIN 
  
  new_time :&#x3D; time_to_change + NUMTODSINTERVAL(timeval,&#39;SECOND&#39;); 
  RETURN new_time;
END; 

CREATE OR REPLACE FUNCTION calc_days(time_to_change IN TIMESTAMP, 
                     timeval IN NUMBER) 
RETURN TIMESTAMP as 
  new_time  TIMESTAMP; 
BEGIN 
  new_time :&#x3D; time_to_change + timeval; 
  RETURN new_time; 
END; </code></pre>
<p>All of these functions operate in a similar fashion. You must input a date in the form of a TIMESTAMP,<br>and the calculated TIMESTAMP will be returned.<br><strong><strong>How It Works</strong></strong><br>When performing the calculation of times and dates in Oracle, you have plenty of options. Over the<br>years, Oracle Database has introduced newer functions to help alleviate some of the difficulties that<br>were encountered when attempting date and time calculations in earlier versions of the database. Date<br>and time calculations can be as simple as adding an integer to the DATE or TIMESTAMP. They can also be<br>difficult when many multiplications and divisions occur within the same calculation. The <strong>Solution</strong> to this<br>recipe provides you with an easy way to add time to a given date using the NUMTODSINTERVAL function.<br>The syntax for this function is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">NUMTODSINTERVAL(number, expression) </code></pre>
<p>The expression that is passed to the function must be one of the following: HOUR, MINUTE, SECOND, or<br>DAY. Technically, the functions created in the <strong>Solution</strong> are capable of subtracting the time or day values<br>from the given date as well. If you were to pass a negative number to the functions, then the<br>NUMTODSINTERVAL would subtract that many units from the given date and time and return the result. The<br>functions in the <strong>Solution</strong> also do not lock you into using a TIMESTAMP; if you were to pass a DATE type in as<br>an argument, then it would work just as well.<br>In the past, you used to only have the ability to use fractions to add or subtract hours, minutes, and<br>seconds to a date. Over the next few examples, I will show you the sort of fractional mathematics that<br>you may see in legacy code. You can add a fraction to a date or TIMESTAMP as both will return a result. To<br>add hours to a date, use the fraction x&#x2F;24, where x is the number of hours (1–24) you want to add. You<br>can subtract hours by using a negative value for x. This works because there are of course 24 hours in<br>one day. The following example shows how you may see some legacy code using fractions to add hours. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- Add 1 hour to the current date 
result :&#x3D; SYSDATE + 1&#x2F;24; 
 
-- Add 5 hours to the current date 
result :&#x3D; CURRENT_TIMESTAMP + 5&#x2F;24; </code></pre>
<p>It is possible to add minutes to a date using a similar technique with fractions. To add minutes, use<br>the fraction x&#x2F;24&#x2F;60, where x is the number of minutes (1–60) that you would like to add. Again, use a<br>negative value in place of x in order to subtract that number of minutes from a date. This fraction works<br>because it divides the number assigned to x by the hours in the day and then divides that result by the<br>number of minutes in an hour. The next figure shows an example of this technique. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- Add 10 mintes to the current date 
result :&#x3D; SYSDATE + 10&#x2F;24&#x2F;60; 
-- Add 30 minutes to the current date 
result :&#x3D; CURRENT_TIMESTAMP + 30&#x2F;24&#x2F;60; </code></pre>
<p>Similarly, you can add seconds to a date by using the fraction x&#x2F;24&#x2F;3600. In this fraction, x is the<br>number of seconds (1–60) that you want to add. Subtraction of seconds is possible by using a negative<br>number for the x value. Just as with the other fractional calculations, this works because there are 3,600<br>seconds in one hour. Therefore, the number assigned to x is divided by the number of hours in the day,<br>and then that result is divided by the number of seconds in one hour. The next figure demonstrates<br>adding seconds to the date using this technique: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- Add 10 seconds to the current date 
result :&#x3D; SYSDATE + 10&#x2F;24&#x2F;3600; 
 
-- Add 45 seconds to the current date 
result :&#x3D; CURRENT_TIMESTAMP + 45&#x2F;24&#x2F;3600; 
 
Using the fractional mathematics, you can add each of the different fractions to the given date and 
achieve the same result. It is not uncommon for legacy code using fractional mathematics for date 
calculation to look like the following: 
 
-- Add 2 hours, 5 minutes, and 30 seconds to the current date 
result :&#x3D; SYSDATE + 2&#x2F;24 + 5&#x2F;24&#x2F;60 + 30&#x2F;24&#x2F;3600; </code></pre>
<p>There are a number of ways to add time intervals to a given date. I recommend using<br>NUMTODSINTERVAL for performing mathematics on time values. In the past, this function was not available,<br>so using fractional mathematics was the only way to add or subtract time from a given date. As shown in<br>the <strong>Solution</strong> to this recipe, it is possible to encapsulate the logic inside of a PL&#x2F;SQL function. If this is<br>done, then you could change the implementation inside the function and someone using it would never<br>know the difference. Date and time calculations can be made even easier to use by writing functions to<br>encapsulate the logic. </p>
<h2 id="7-7-Returning-the-First-Day-of-a-Given-Month"><a href="#7-7-Returning-the-First-Day-of-a-Given-Month" class="headerlink" title="7-7. Returning the First Day of a Given Month"></a>7-7. Returning the First Day of a Given Month</h2><p><strong><strong>Problem</strong></strong><br>You want to have the ability to obtain the name of the first day for a given month. </p>
<p><strong><strong>Solution</strong></strong><br>Write a PL&#x2F;SQL function that accepts a date and applies the necessary functions to return the first day of<br>month for the given date. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION first_day_of_month(in_date DATE) 
RETURN VARCHAR2 IS 
BEGIN 
  RETURN to_char(trunc(in_date,&#39;MM&#39;), &#39;DD-MON-YYYY&#39;); 
END; </code></pre>
<p>The function created in this <strong>Solution</strong> will return the first day of the month that is passed into it<br>because it is passed into the TRUNC function. </p>
<p><strong><strong>How It Works</strong></strong><br>The TRUNC function can be useful for returning information from a DATE type. In this case, it is used to<br>return the first day of the month from the given date. The <strong>Solution</strong> then converts the truncated date<br>value to a character format and returns the result.<br>The TRUNC function accepts two arguments, the first being the date that is to be truncated and the<br>second being the format model. The format model is a series of characters that specifies how you want<br>to truncate the given date. Table 7-1 lists the format models along with a description of each.<br>Table 7-1. Format Models for TRUNC </p>
<pre class="language-text" data-language="text"><code class="language-text">Format              Model Description 
MI                              Returns the nearest minute 
HH, HH12, HH24                  Returns the nearest hour 
D, DY, DAY                      Returns the first day of the week 
W                               Returns the same day of the week as the first day of the month 
IW                              Returns the same day of the week as the first day of ISO year 
WW                              Returns the same day of the week as the first day of the year 
RM, MM, MON, MONTH              Returns to the nearest first day of the month 
Q                               Returns to the nearest quarter 
I, IY, IYYY                     Returns the ISO year 
Y, YY, YYY, SYEAR, YEAR, YYYY   Rounds to the nearest first day of the year 
CC, SCC                         Returns one greater than the first two digits of a given four-digit year</code></pre>
<p>The <strong>Solution</strong> to this recipe returns the first day of the given month using the format model MM. </p>
<h2 id="7-8-Returning-the-Last-Day-of-a-Given-Month"><a href="#7-8-Returning-the-Last-Day-of-a-Given-Month" class="headerlink" title="7-8. Returning the Last Day of a Given Month"></a>7-8. Returning the Last Day of a Given Month</h2><p><strong><strong>Problem</strong></strong><br>You want to have the ability to obtain the last day for a given month. </p>
<p><strong><strong>Solution</strong></strong><br>Use the Oracle built-in LAST_DAY function to return the last day of the month for the date that you pass<br>into it. The following example demonstrates a code block in which the LAST_DAY function is used to<br>return the last day of the current month: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  last_day  VARCHAR2(20); 
BEGIN 
  select LAST_DAY(sysdate) 
  INTO last_day 
  FROM DUAL; 
  DBMS_OUTPUT.PUT_LINE(last_day); 
END;</code></pre>

<p><strong><strong>How It Works</strong></strong><br>The LAST_DAY function is an easy way to retrieve the date for the last day of a given date. To use the<br>function, pass in any date, and the last day of the month for the given date will be returned. The function<br>can be useful in combination with other functions, especially for converting strings into dates and then<br>determining the last day of the given month for the date given in string format. For example, the<br>following combination is used quite often: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">LAST_DAY(to_date(string_based_date,&#39;MM&#x2F;DD&#x2F;YYYY&#39;)) </code></pre>
<h2 id="7-9-Rounding-a-Number"><a href="#7-9-Rounding-a-Number" class="headerlink" title="7-9. Rounding a Number"></a>7-9. Rounding a Number</h2><p><strong><strong>Problem</strong></strong><br>You are interested in rounding a given number. For example, let’s say you are working on employee<br>timecards, and you want to round to the nearest tenth of an hour for every given hour amount. </p>
<p><strong><strong>Solution</strong></strong><br>Use the Oracle built-in ROUND function to return the result that you desire. For this <strong>Solution</strong>, you are<br>working with hours on employee timecards. To round to the nearest tenth, you would write a small<br>PL&#x2F;SQL function that uses the ROUND function and returns the result. The following example<br>demonstrates this technique: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION emp_labor_hours(time IN NUMBER) 
RETURN NUMBER IS 
BEGIN 
  RETURN ROUND(time, 1); 
END; </code></pre>
<p>The time will be rounded to the nearest tenth in this example because a 1 is passed as the second<br>argument to the ROUND function.<br><strong><strong>How It Works</strong></strong><br>The Oracle built-in ROUND function can be used for rounding numbers based upon a specified precision<br>level. To use the ROUND function, pass a number that you would like to round as the first argument, and<br>pass the optional precision level as the second argument. If you do not specify a precision level, then the<br>number will be rounded to the nearest integer. If the precision is specified, then the number will be<br>rounded to the number of decimal places specified by the precision argument.<br>In the case of this <strong>Solution</strong>, a 1 was specified for the precision argument, so the number will be<br>rounded to one decimal place. The precision can be up to eight decimal places. If you specify a precision<br>larger than eight decimal places, then the precision will default to eight. </p>
<h2 id="7-10-Rounding-a-Datetime-Value"><a href="#7-10-Rounding-a-Datetime-Value" class="headerlink" title="7-10. Rounding a Datetime Value"></a>7-10. Rounding a Datetime Value</h2><p><strong><strong>Problem</strong></strong><br>Given a particular date and time, you want the ability to round the date.<br><strong><strong>Solution</strong></strong><br>Use the ROUND function passing the date you want to round along with the format model for the unit you<br>want to round. For example, suppose that given a date and time, you want to the nearest day. To do this,<br>you would pass in the date along with the DD format model. The following code block demonstrates this<br>technique: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
  DBMS_OUTPUT.PUT_LINE(to_char(ROUND (SYSDATE, &#39;DD&#39;),&#39;MM&#x2F;DD&#x2F;YYYY - HH12:MI:SS&#39;)); 
 END; </code></pre>
<p>The previous code block will return the current date and time rounded to the nearest day. For<br>example, if it is before 12 p.m., then it will round the given date back to 12 a.m. on that date; otherwise, it<br>will round forward to 12 a.m. on the next date.<br><strong>How It Works</strong><br>You can also use the ROUND function for working with DATE types. To round a date using this function, you<br>must specify the date you want to have rounded as the first argument along with the format parameter<br>for the type of rounding you want to perform. Table 7-2 lists the different format parameters for<br>performing DATE rounding. </p>
<pre class="language-text" data-language="text"><code class="language-text">Table 7-2. Format Parameters for DATE Rounding 
Format                            Parameter Description 
Y, YYY, YYYY, YEAR, SYEAR, SYYYY  Rounds to the nearest year 
I, IY, IYYY                       Rounds to the nearest ISO year 
Q                                 Rounds to the nearest quarter 
RM, MM, MON, MONTH                Rounds to the nearest month 
WW                                Rounds to the same day of the week as the first day of the year 
IW                                Rounds to the same day of the week as the first day of the ISO year
W                                 Rounds to the same day of the week as the first day of the month 
J, DD, DDD                        Rounds to the nearest day 
D, DY, DAY                        Rounds to the start day of the week 
HH, HH12, HH24                    Rounds to the nearest hour 
MI                                Rounds to the nearest minute </code></pre>
<p>If you find that you are using the same date conversion in many places throughout your application,<br>then it may make sense to create a function to encapsulate the call to the ROUND function. Doing so would<br>enable a simple function call that can be used to return the date value you require rather than<br>remembering to use the correct format parameter each time. </p>
<h2 id="7-11-Tracking-Time-to-a-Millisecond"><a href="#7-11-Tracking-Time-to-a-Millisecond" class="headerlink" title="7-11. Tracking Time to a Millisecond"></a>7-11. Tracking Time to a Millisecond</h2><p><strong><strong>Problem</strong></strong><br>You are interested in tracking time in a finely grained manner to the millisecond. For example, you want<br>to determine the exact time in which a particular change is made to the database. </p>
<p><strong><strong>Solution</strong></strong><br>Perform simple mathematics with the current date time in order to determine the exact time down the<br>millisecond. The following function accepts a timestamp and returns the |milliseconds: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE FUNCTION capture_milliseconds(in_time TIMESTAMP)  
RETURN NUMBER IS 
  milliseconds    NUMBER; 
  CHAPTER 7  NUMBERS, STRINGS, AND DATES 
147 
BEGIN 
select sum( 
   (extract(hour from in_time))*3600+ 
   (extract(minute from in_time))*60+ 
   (extract(second from in_time)))*1000 
into MILLISECONDS from dual; 
RETURN milliseconds; 
 
END;</code></pre>

<p><strong><strong>How It Works</strong></strong><br>If your application requires a fine-grained accuracy for time, then you may want to track time in<br>milliseconds. Performing a calculation such as the one demonstrated in the <strong>Solution</strong> to this recipe on a<br>given DATE or TIMESTAMP can do this. By combining the EXTRACT function with some calculations, the<br>desired milliseconds result can be achieved.<br>The EXTRACT function is used to extract YEAR, MONTH, or DATE units from a DATE type. It can extract<br>HOUR, MINUTE, or SECOND from a TIMESTAMP. Milliseconds can be calculated by obtaining the sum of the<br>hours multiplied by 3600, the minutes multiplied by 60, and the seconds multiplied by 1000 from a given<br>TIMESTAMP. If you need to use milliseconds in your program, then I recommend creating a function such<br>as the one demonstrated in the <strong>Solution</strong> to this recipe to encapsulate this logic. </p>
<h2 id="7-12-Associating-a-Time-Zone-with-a-Date-and-Time"><a href="#7-12-Associating-a-Time-Zone-with-a-Date-and-Time" class="headerlink" title="7-12. Associating a Time Zone with a Date and Time"></a>7-12. Associating a Time Zone with a Date and Time</h2><p><strong><strong>Problem</strong></strong><br>You want to associate a time zone with a given date and time in order to be more precise. </p>
<p><strong><strong>Solution</strong></strong><br>Create a code block that declares a field as type TIMESTAMP WITH TIME ZONE. Assign a TIMESTAMP to the<br>newly declared field within the body of the code block. After doing so, the field that you declared will<br>contain the date and time of the TIMESTAMP that you assigned along with the associated time zone. The<br>following example demonstrates a code block that performs this technique using the SYSTIMESTAMP: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  time   TIMESTAMP WITH TIME ZONE; 
 BEGIN 
  time :&#x3D; SYSTIMESTAMP; 
  DBMS_OUTPUT.PUT_LINE(time); 
 END; </code></pre>
<p>The results that will be displayed via the call to DBMS_OUTPUT should resemble something similar to<br>the following: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">29-AUG-10 10.27.58.639000 AM -05:00 </code></pre>
<p>PL&#x2F;SQL procedure successfully completed. </p>
<p><strong><strong>How It Works</strong></strong><br>Prior to the TIMESTAMP datatype being introduced in Oracle 9i, the DATE type was the only way to work<br>with dates. There were limited capabilities provided, and later the TIMESTAMP was created to fill those<br>gaps. For those needing to make use of time zones, Oracle created the TIMESTAMP WITH TIME ZONE and<br>TIMESTAMP WITH LOCAL TIME ZONE datatypes. Both of these datatypes provide a time zone to be<br>associated with a given date, but they work a bit differently. When you specify the WITH TIME ZONE<br>option, the time zone information is stored within the database along with the hours, minutes, and so<br>on. However, if you specify the WITH LOCAL TIME ZONE option, the time zone information is not stored<br>within the database, but rather it is calculated each time against a baseline time zone, which determines<br>the time zone of your current session.<br>In the <strong>Solution</strong> to this recipe, the time zone information is stored within the database along with the<br>rest of the date and time associated with the TIMESTAMP. </p>
<h2 id="7-13-Finding-a-Pattern-Within-a-String"><a href="#7-13-Finding-a-Pattern-Within-a-String" class="headerlink" title="7-13. Finding a Pattern Within a String"></a>7-13. Finding a Pattern Within a String</h2><p><strong><strong>Problem</strong></strong><br>You want to find the number of occurrences of a particular pattern within a given string. For instance,<br>you want to search for email addresses within a body of text. </p>
<p><strong><strong>Solution</strong></strong><br>Use a regular expression to match a given string against the body of text and return the resulting count of<br>matching occurrences. The following example searches through a given body of text and counts the<br>number of email addresses it encounters. Any email address will be added to the tally because a regular<br>expression is used to compare the strings. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE COUNT_EMAIL_IN_TEXT(text_var     IN VARCHAR2) AS 
  counter    NUMBER :&#x3D; 0; 
  mail_pattern    VARCHAR2(15) :&#x3D; &#39;\w+@\w+(\.\w+)+&#39;; 
BEGIN 
  counter :&#x3D; REGEXP_COUNT(text_var, mail_pattern); 
 
  IF COUNTER &#x3D; 1 THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;This passage provided contains 1 email address’); 
  ELSIF counter &gt; 1 THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;This passage provided contains &#39;|| 
                     counter || &#39; email addresses&#39;); 
  ELSE 
    DBMS_OUTPUT.PUT_LINE(&#39;This passage provided contains &#39; || 
            &#39;no email addresses&#39;); 
  END IF; 
END; </code></pre>
<p>The function in this example provides a single service because it counts the number of occurrences<br>of an email address in a given body of text and returns the result. </p>
<p><strong><strong>How It Works</strong></strong><br>You can use regular expressions to help match strings of numbers, text, or alphanumeric values. They<br>are sequences of characters and symbols that assimilate a pattern that can be used to match against<br>strings of text. A regular expression is similar to using the % symbol as a wildcard within a query, except<br>that a regular expression provides a pattern that text must match against. Please refer to online Oracle<br>documentation for a listing of the different options that can be used for creating regular expression<br>patterns.  </p>
<p>Oracle introduced the REGEXP_COUNT function in Oracle 11g, which provides the functionality of counting<br>the number of occurrences of a given string within a given body of text. The syntax for the REGEXP_COUNT<br>function is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">REGEXP_COUNT(source_text, pattern, position, options) </code></pre>
<p>The source text for the function can be any string literal, variable, or column that has a datatype of<br>VARCHAR2, NVARCHAR2, CHAR, NCHAR, CLOB, or NCLOB. The pattern is a regular expression or a string of text that<br>will be used to match against. The position specifies the placement within the source text where the<br>search should begin. By default, the position is 1. The options include different useful matching<br>modifiers; please refer to the Oracle regular expression support documentation at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/E14072_01/server.112/e10592/ap_posix.htm#g693775">http://download.oracle.com/docs/cd/E14072_01/server.112/e10592/ap_posix.htm#g693775</a> for a listing<br>of the pattern matching modifiers that can be used as options.<br>The REGEXP_COUNT function can be used within any Oracle SQL statement or PL&#x2F;SQL program. The<br>following are a few more examples of using this function: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- Count all occurrences of the letter &#39;l&#39; in the word Hello 
result :&#x3D; REGEXP_COUNT(&#39;hello&#39;,&#39;l&#39;); 
 
Returns:  2 
 
-- Count the number of occurrences of the pattern &#39;ells&#39; beginning at 
-- the fifth character. 
result :&#x3D; REGEXP_COUNT(&#39;she sells sea shells by the sea shore&#39;, 
                      &#39;ells&#39;,7,&#39;c&#39;); 
 
Returns: 1 
 
-- Count the number of words in the line 
result :&#x3D; REGEXP_COUNT(&#39;she sells sea shells by the sea shore&#39;, 
                      &#39;\w+&#39;); 
 
Returns: 8 </code></pre>
<p>As you can see from these examples, the REGEXP_COUNT function is a great addition to the Oracle<br>regular expression function family </p>
<h2 id="7-14-Determining-the-Position-of-a-Pattern-Within-a-String"><a href="#7-14-Determining-the-Position-of-a-Pattern-Within-a-String" class="headerlink" title="7-14. Determining the Position of a Pattern Within a String"></a>7-14. Determining the Position of a Pattern Within a String</h2><p><strong><strong>Problem</strong></strong><br>You want to return the position of a matching string within a body of text. Furthermore, you are want to<br>pattern match and therefore must invoke a regular expression function. For example, you need to find a<br>way to determine the position of a string that matches the pattern of a phone number. </p>
<p><strong>Solutio</strong><br>Use the REGEXP_INSTR function to use a regular expression to search a body of text to find the position of<br>a phone number. The following code block demonstrates this technique by looping through each of the<br>rows in the EMPLOYEES table and determining whether the employee phone number is USA or<br>international:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  CURSOR emp_cur IS 
  SELECT * 
  FROM employees; 
  emp_rec       emp_cur%ROWTYPE; 
  position     NUMBER :&#x3D; 0; 
  counter        NUMBER :&#x3D; 0; 
  intl_count     NUMBER :&#x3D; 0;
BEGIN 
  FOR emp_rec IN emp_cur LOOP 
  position :&#x3D; REGEXP_INSTR(emp_rec.phone_number, 
  &#39;([[:digit:]]&#123;3&#125;)\.([[:digit:]]&#123;3&#125;)\.([[:digit:]]&#123;4&#125;)&#39;); 
   
  IF position &gt; 0 THEN 
    counter :&#x3D; counter + 1; 
  ELSE 
    intl_count :&#x3D; intl_count + 1; 
  END IF; 
  END LOOP; 
  DBMS_OUTPUT.PUT_LINE(&#39;Numbers within USA: &#39; || counter); 
  DBMS_OUTPUT.PUT_LINE(&#39;International Numbers: &#39; || intl_count); 
END; </code></pre>
<p>Result:<br>Numbers within USA: 72<br>International Numbers: 35<br>PL&#x2F;SQL procedure successfully completed. </p>
<p><strong><strong>How It Works</strong></strong><br>In the <strong>Solution</strong> to this recipe, the function uses REGEXP_INSTR to find all telephone numbers that match<br>the U.S. telephone number format. The field passed into REGEXP_INSTR is always going to return a<br>telephone number, but that number may be in an international format or a U.S. format. If the pattern of<br>the telephone number matches that of a U.S. format, then the counter for U.S. numbers is increased by<br>one. Otherwise, the counter for the international numbers is increased by one. The reasonable<br>assumption is that if a number is not a U.S. number, that it is an “international” number. Using<br>REGEXP_INSTR makes this a very easy function to implement.<br>REGEXP_INSTR will return the position of the first or last character of the matching string depending<br>upon the value of the return option argument. This function provides the same functionality of INSTR<br>except that it also allows the ability to use regular expression patterns. The syntax for this function is as<br>follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">REGEXP_INSTR(source_text, pattern, position, occurrence, 
                               return_option, match parameter, subexpression) </code></pre>
<p>All but the source_text and pattern parameters are optional. The source_text is the string of text to<br>be searched. The pattern is a regular expression or string that will be matched against the source_text.<br>The optional position argument is an integer that specifies on which character Oracle should start the<br>search. The optional occurrence parameter specifies which occurrence of the pattern will have its<br>position returned. The default occurrence argument is 1, which means that the position of the first<br>matching string will be returned<br>The optional return_option is used to specify special options that are outlined within the Oracle<br>regular expression documentation that can be found at<br><a target="_blank" rel="noopener" href="http://download.oracle.com/docs/cd/E11882_01/server.112/e10592/ap_posix.htm#g693775">http://download.oracle.com/docs/cd/E11882_01/server.112/e10592/ap_posix.htm#g693775</a>. The<br>optional match_parameter allows you to change the default matching behavior. The subexpression<br>parameter is optional, and it is an integer from 0 to 9 that indicates which subexpression in the<br>source_text will be the target of the function. </p>
<h2 id="7-15-Finding-and-Replacing-Text-Within-a-String"><a href="#7-15-Finding-and-Replacing-Text-Within-a-String" class="headerlink" title="7-15. Finding and Replacing Text Within a String"></a>7-15. Finding and Replacing Text Within a String</h2><p><strong><strong>Problem</strong></strong><br>You want to replace each occurrence of a given string within a body of text.<br><strong><strong>Solution</strong></strong><br>Use the REGEXP_REPLACE function to match a pattern of text against a given body of text, and replace all<br>matching occurrences with a new string. In the following function, the REGEXP_REPLACE function is used<br>to replace all occurrences of the JOB_TITLE ‘Programmer’ with the new title of ‘Developer.’ </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  CURSOR job_cur IS 
  SELECT * 
  FROM jobs; 
 
  job_rec       job_cur%ROWTYPE; 
  new_job_title jobs.job_title%TYPE; 
BEGIN 
  FOR job_rec IN job_cur LOOP 
    IF REGEXP_INSTR(job_rec.job_title,&#39;Programmer&#39;) &gt; 0 THEN 
      new_job_title :&#x3D; REGEXP_REPLACE(job_rec.job_title, &#39;Programmer&#39;, 
                                    &#39;Developer&#39;); 
 
      UPDATE jobs 
      SET job_title &#x3D; new_job_title 
      WHERE job_id &#x3D; job_rec.job_id; 
     
      DBMS_OUTPUT.PUT_LINE(job_rec.job_title || &#39; replaced with &#39; || 
         new_job_title); 
    END IF; 
 END LOOP; 
 
END; </code></pre>
<p>Although this particular example does not use any regular expression patterns, it could be adjusted<br>to do so. To find more information and tables specifying the options that are available for creating<br>patterns, please refer to the online Oracle documentation.<br>The <strong>Solution</strong> to this recipe prints out the revised text. Each occurrence of the ‘Programmer’ text is<br>replaced with ‘Developer’, and the newly generated string is returned into the NEW_REVIEW variable. </p>
<p><strong><strong>How It Works</strong></strong><br>The REGEXP_REPLACE function is a great way to find and replace strings within a body of text. The function<br>can be used within any Oracle SQL statement or PL&#x2F;SQL code. The syntax for the function is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">REGEXP_REPLACE(source_text, pattern, replacement_string, position, occurrence, options) </code></pre>
<p>The source text for the function can be any string literal, variable, or column that has a datatype of<br>VARCHAR2, NVARCHAR2, CHAR, NCHAR, CLOB, or NCLOB. The pattern is a regular expression or a string of text that<br>will be used to match against. The replacement string is will replace each occurrence of the string<br>identified by the source text. The optional position specifies the placement within the source text where<br>the search should begin. By default, the position is 1. The optional occurrence argument is a<br>nonnegative integer that indicates the occurrence of the replace operation. If a 0 is specified, then all<br>matching occurrences will be replaced. If a positive integer is specified, then Oracle will replace the<br>match for that occurrence with the replacement string. The optional options argument includes<br>different useful matching modifiers; please refer to the online Oracle documentation for a listing of the<br>pattern matching modifiers that can be used as options.<br>■ Note Do not use REGEXP_REPLACE if the replacement can be performed with a regular UPDATE statement. Since<br>REGEXP_REPLACE uses regular expressions, it can be slower than a regular UPDATE.<br>The following examples demonstrate how this function can be used within a PL&#x2F;SQL application or<br>a simple query. This next bit of code demonstrates how to replace numbers that match those within the<br>given set. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">select REGEXP_REPLACE(&#39;abcdefghi&#39;,&#39;[acegi]&#39;,&#39;x&#39;) from dual; </code></pre>
<p>Returns: xbxdxfxhx </p>
<p>Next, we replace a Social Security Number with Xs. </p>
<p>new_ssn :&#x3D; REGEXP_REPLACE(‘123-45-6789’,’[[:digit:]]{3}-[[:digit:]]{2}-[[:digit:]]{4}’,’xxx-<br>xxx-xxxx’); </p>
<p>Returns: xxx-xxx-xxxx </p>
<p>The REGEXP_REPLACE function can be most useful when attempting to replace patterns of strings within a<br>given body of text such as the two previous examples have shown. As noted previously, if a standard<br>UPDATE statement can be used to replace a value, then that should be the first choice, because regular<br>expressions perform slightly slower. </p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_08/"
                    data-tooltip="Oracle PLSQL Recipes 08-Dynamic SQL"
                    aria-label="PREVIOUS: Oracle PLSQL Recipes 08-Dynamic SQL"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_06/"
                    data-tooltip="Oracle PLSQL Recipes 06-Type Conversion"
                    aria-label="NEXT: Oracle PLSQL Recipes 06-Type Conversion"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_07/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_08/"
                    data-tooltip="Oracle PLSQL Recipes 08-Dynamic SQL"
                    aria-label="PREVIOUS: Oracle PLSQL Recipes 08-Dynamic SQL"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_06/"
                    data-tooltip="Oracle PLSQL Recipes 06-Type Conversion"
                    aria-label="NEXT: Oracle PLSQL Recipes 06-Type Conversion"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_07/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href=""
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_07/"
                        aria-label="global.share_on_wechat"
                    >
                        <i class="fa-foo_bar" aria-hidden="true"></i><span>global.share_on_wechat</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Canton
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-4u8r0fo0pgap8c0kebqie2krcfxcv3h259cjxizeggkmknhnwzjt04ztqpi1.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'ca29b9a1203b5920918d',
              clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
              repo: 'SimonTeo58.github.io',
              owner: 'SimonTeo58',
              admin: ['SimonTeo58'],
              id: '2022/11/08/oracle/Oracle_PLSQL_Recipes/Oracle_PLSQL_Recipes_07/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
