
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CoffeeMan">
    <title>go标准库阅读与解析 - CoffeeMan</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://simonteo58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg"},"articleBody":"\nsource link: https://pkg.go.dev/stdabstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.\n\n\n\n\n1. archive1.1 tar  Package tar implements access to tar archives.\n  Tape(封装,胶带) archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.\nConstants\n  const (\n  &#x2F;&#x2F; Type &#39;0&#39; indicates a regular file.\n  TypeReg  &#x3D; &#39;0&#39;\n  TypeRegA &#x3D; &#39;\\x00&#39; &#x2F;&#x2F; Deprecated: Use TypeReg instead.\n\n  &#x2F;&#x2F; Type &#39;1&#39; to &#39;6&#39; are header-only flags and may not have a data body.\n  TypeLink    &#x3D; &#39;1&#39; &#x2F;&#x2F; Hard link\n  TypeSymlink &#x3D; &#39;2&#39; &#x2F;&#x2F; Symbolic link\n  TypeChar    &#x3D; &#39;3&#39; &#x2F;&#x2F; Character device node\n  TypeBlock   &#x3D; &#39;4&#39; &#x2F;&#x2F; Block device node\n  TypeDir     &#x3D; &#39;5&#39; &#x2F;&#x2F; Directory\n  TypeFifo    &#x3D; &#39;6&#39; &#x2F;&#x2F; FIFO node\n\n  &#x2F;&#x2F; Type &#39;7&#39; is reserved.\n  TypeCont &#x3D; &#39;7&#39;\n\n  &#x2F;&#x2F; Type &#39;x&#39; is used by the PAX format to store key-value records that\n  &#x2F;&#x2F; are only relevant to the next file.\n  &#x2F;&#x2F; This package transparently handles these types.\n  TypeXHeader &#x3D; &#39;x&#39;\n\n  &#x2F;&#x2F; Type &#39;g&#39; is used by the PAX format to store key-value records that\n  &#x2F;&#x2F; are relevant to all subsequent files.\n  &#x2F;&#x2F; This package only supports parsing and composing such headers,\n  &#x2F;&#x2F; but does not currently support persisting the global state across files.\n  TypeXGlobalHeader &#x3D; &#39;g&#39;\n\n  &#x2F;&#x2F; Type &#39;S&#39; indicates a sparse file in the GNU format.\n  TypeGNUSparse &#x3D; &#39;S&#39;\n\n  &#x2F;&#x2F; Types &#39;L&#39; and &#39;K&#39; are used by the GNU format for a meta file\n  &#x2F;&#x2F; used to store the path or link name for the next file.\n  &#x2F;&#x2F; This package transparently handles these types.\n  TypeGNULongName &#x3D; &#39;L&#39;\n  TypeGNULongLink &#x3D; &#39;K&#39;\n)\n\nVariables\n  var (\n  ErrHeader          &#x3D; errors.New(&quot;archive&#x2F;tar: invalid tar header&quot;)\n  ErrWriteTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: write too long&quot;)\n  ErrFieldTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: header field too long&quot;)\n  ErrWriteAfterClose &#x3D; errors.New(&quot;archive&#x2F;tar: write after close&quot;)\n)\n\ntype Format\n  type Format int\n\n  Format represents the tar archive format.The original tar format was introduced in Unix V7. Since then, there have been multiple competing(相互竞争) formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.\n  The following table captures the capabilities of each format:\n                    |  USTAR |       PAX |       GNU\n------------------+--------+-----------+----------\nName              |   256B | unlimited | unlimited\nLinkname          |   100B | unlimited | unlimited\nSize              | uint33 | unlimited |    uint89\nMode              | uint21 |    uint21 |    uint57\nUid&#x2F;Gid           | uint21 | unlimited |    uint57\nUname&#x2F;Gname       |    32B | unlimited |       32B\nModTime           | uint33 | unlimited |     int89\nAccessTime        |    n&#x2F;a | unlimited |     int89\nChangeTime        |    n&#x2F;a | unlimited |     int89\nDevmajor&#x2F;Devminor | uint21 |    uint21 |    uint57\n------------------+--------+-----------+----------\nstring encoding   |  ASCII |     UTF-8 |    binary\nsub-second times  |     no |       yes |        no\nsparse files      |     no |       yes |       yes\n\n  The table’s upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).\n  The table’s lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.\n  The Writer currently provides no support for sparse files.\n  const (\n\n&#x2F;&#x2F; FormatUnknown indicates that the format is unknown.\nFormatUnknown Format\n&#x2F;&#x2F; FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.\n&#x2F;&#x2F;\n&#x2F;&#x2F; While this format is compatible with most tar readers,\n&#x2F;&#x2F; the format has several limitations making it unsuitable for some usages.\n&#x2F;&#x2F; Most notably, it cannot support sparse files, files larger than 8GiB,\n&#x2F;&#x2F; filenames larger than 256 characters, and non-ASCII filenames.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Reference:\n&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;pax.html#tag_20_92_13_06\nFormatUSTAR\n&#x2F;&#x2F; FormatPAX represents the PAX header format defined in POSIX.1-2001.\n&#x2F;&#x2F;\n&#x2F;&#x2F; PAX extends USTAR by writing a special file with Typeflag TypeXHeader\n&#x2F;&#x2F; preceding the original header. This file contains a set of key-value\n&#x2F;&#x2F; records, which are used to overcome USTAR\\&#39;s shortcomings, in addition to\n&#x2F;&#x2F; providing the ability to have sub-second resolution for timestamps.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Some newer formats add their own extensions to PAX by defining their\n&#x2F;&#x2F; own keys and assigning certain semantic meaning to the associated values.\n&#x2F;&#x2F; For example, sparse file support in PAX is implemented using keys\n&#x2F;&#x2F; defined by the GNU manual (e.g., &quot;GNU.sparse.map&quot;).\n&#x2F;&#x2F;\n&#x2F;&#x2F; Reference:\n&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;utilities&#x2F;pax.html\nFormatPAX\n&#x2F;&#x2F; FormatGNU represents the GNU header format.\n&#x2F;&#x2F;\n&#x2F;&#x2F; The GNU header format is older than the USTAR and PAX standards and\n&#x2F;&#x2F; is not compatible with them. The GNU format supports\n&#x2F;&#x2F; arbitrary file sizes, filenames of arbitrary encoding and length,\n&#x2F;&#x2F; sparse files, and other features.\n&#x2F;&#x2F;\n&#x2F;&#x2F; It is recommended that PAX be chosen over GNU unless the target\n&#x2F;&#x2F; application can only parse GNU formatted archives.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Reference:\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;tar&#x2F;manual&#x2F;html_node&#x2F;Standard.html\nFormatGNU\n)\n\n\nfunc (f Format) String() string\n  打印tar的格式\ntype Header\n    type Header struct &#123;\n  &#x2F;&#x2F; Typeflag is the type of header entry.\n  &#x2F;&#x2F; The zero value is automatically promoted to either TypeReg or TypeDir\n  &#x2F;&#x2F; depending on the presence of a trailing slash in Name.\n  Typeflag byte\n\n  Name     string &#x2F;&#x2F; Name of file entry\n  Linkname string &#x2F;&#x2F; Target name of link (valid for TypeLink or TypeSymlink)\n\n  Size  int64  &#x2F;&#x2F; Logical file size in bytes\n  Mode  int64  &#x2F;&#x2F; Permission and mode bits\n  Uid   int    &#x2F;&#x2F; User ID of owner\n  Gid   int    &#x2F;&#x2F; Group ID of owner\n  Uname string &#x2F;&#x2F; User name of owner\n  Gname string &#x2F;&#x2F; Group name of owner\n\n  &#x2F;&#x2F; If the Format is unspecified, then Writer.WriteHeader rounds ModTime\n  &#x2F;&#x2F; to the nearest second and ignores the AccessTime and ChangeTime fields.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; To use AccessTime or ChangeTime, specify the Format as PAX or GNU.\n  &#x2F;&#x2F; To use sub-second resolution, specify the Format as PAX.\n  ModTime    time.Time &#x2F;&#x2F; Modification time\n  AccessTime time.Time &#x2F;&#x2F; Access time (requires either PAX or GNU support)\n  ChangeTime time.Time &#x2F;&#x2F; Change time (requires either PAX or GNU support)\n\n  Devmajor int64 &#x2F;&#x2F; Major device number (valid for TypeChar or TypeBlock)\n  Devminor int64 &#x2F;&#x2F; Minor device number (valid for TypeChar or TypeBlock)\n\n  &#x2F;&#x2F; Xattrs stores extended attributes as PAX records under the\n  &#x2F;&#x2F; &quot;SCHILY.xattr.&quot; namespace.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; The following are semantically equivalent:\n  &#x2F;&#x2F;  h.Xattrs[key] &#x3D; value\n  &#x2F;&#x2F;  h.PAXRecords[&quot;SCHILY.xattr.&quot;+key] &#x3D; value\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; When Writer.WriteHeader is called, the contents of Xattrs will take\n  &#x2F;&#x2F; precedence over those in PAXRecords.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; Deprecated: Use PAXRecords instead.\n  Xattrs map[string]string\n\n  &#x2F;&#x2F; PAXRecords is a map of PAX extended header records.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; User-defined records should have keys of the following form:\n  &#x2F;&#x2F;\tVENDOR.keyword\n  &#x2F;&#x2F; Where VENDOR is some namespace in all uppercase, and keyword may\n  &#x2F;&#x2F; not contain the &#39;&#x3D;&#39; character (e.g., &quot;GOLANG.pkg.version&quot;).\n  &#x2F;&#x2F; The key and value should be non-empty UTF-8 strings.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; When Writer.WriteHeader is called, PAX records derived from the\n  &#x2F;&#x2F; other fields in Header take precedence over PAXRecords.\n  PAXRecords map[string]string\n\n  &#x2F;&#x2F; Format specifies the format of the tar header.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; This is set by Reader.Next as a best-effort guess at the format.\n  &#x2F;&#x2F; Since the Reader liberally reads some non-compliant files,\n  &#x2F;&#x2F; it is possible for this to be FormatUnknown.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; If the format is unspecified when Writer.WriteHeader is called,\n  &#x2F;&#x2F; then it uses the first format (in the order of USTAR, PAX, GNU)\n  &#x2F;&#x2F; capable of encoding this Header (see Format).\n  Format Format\n&#125;\n\n\nfunc FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)\nfunc (h*Header) FileInfo() fs.FileInfo\ntype Reader\nfunc NewReader(r io.Reader) *Reader\nfunc (tr*Reader) Next() (*Header, error)\nfunc (tr*Reader) Read(b []byte) (int, error)\ntype Writer\nfunc NewWriter(w io.Writer) *Writer\nfunc (tw*Writer) Close() error\nfunc (tw *Writer) Flush() error\nfunc (tw*Writer) Write(b []byte) (int, error)\nfunc (tw Writer) WriteHeader(hdrHeader) error\n1.2 zipPackage zip provides support for reading and writing ZIP archives.\nConstants\n  const (\n  Store   uint16 &#x3D; 0 &#x2F;&#x2F; no compression\n  Deflate uint16 &#x3D; 8 &#x2F;&#x2F; DEFLATE compressed\n)\n\nVariables\n  var (\n  ErrFormat    &#x3D; errors.New(&quot;zip: not a valid zip file&quot;)\n  ErrAlgorithm &#x3D; errors.New(&quot;zip: unsupported compression algorithm&quot;)\n  ErrChecksum  &#x3D; errors.New(&quot;zip: checksum error&quot;)\n)\n\n\nfunc RegisterCompressor(method uint16, comp Compressor)\nfunc RegisterDecompressor(method uint16, dcomp Decompressor)\ntype Compressor\ntype Decompressor\ntype File\nfunc (f *File) DataOffset() (offset int64, err error)\nfunc (f*File) Open() (io.ReadCloser, error)\nfunc (f *File) OpenRaw() (io.Reader, error)\ntype FileHeader\nfunc FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)\nfunc (h *FileHeader) FileInfo() fs.FileInfo\nfunc (h*FileHeader) ModTime() time.TimeDEPRECATED\nfunc (h *FileHeader) Mode() (mode fs.FileMode)\nfunc (h*FileHeader) SetModTime(t time.Time)DEPRECATED\nfunc (h *FileHeader) SetMode(mode fs.FileMode)\ntype ReadCloser\nfunc OpenReader(name string) (*ReadCloser, error)\nfunc (rc *ReadCloser) Close() error\ntype Reader\nfunc NewReader(r io.ReaderAt, size int64) (*Reader, error)\nfunc (r *Reader) Open(name string) (fs.File, error)\nfunc (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)\ntype Writer\nfunc NewWriter(w io.Writer) *Writer\nfunc (w*Writer) Close() error\nfunc (w *Writer) Copy(f*File) error\nfunc (w *Writer) Create(name string) (io.Writer, error)\nfunc (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)\nfunc (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)\nfunc (w*Writer) Flush() error\nfunc (w *Writer) RegisterCompressor(method uint16, comp Compressor)\nfunc (w*Writer) SetComment(comment string) error\nfunc (w *Writer) SetOffset(n int64)\n2. bufioPackage bufio implements buffered I&#x2F;O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual(adj.本文的,按原文的) I&#x2F;O.\nConstants\nconst (\n\t&#x2F;&#x2F; MaxScanTokenSize is the maximum size used to buffer a token\n\t&#x2F;&#x2F; unless the user provides an explicit buffer with Scanner.Buffer.\n\t&#x2F;&#x2F; The actual maximum token size may be smaller as the buffer\n\t&#x2F;&#x2F; may need to include, for instance, a newline.\n\tMaxScanTokenSize &#x3D; 64 * 1024\n)\nVariables\nvar (\n\tErrInvalidUnreadByte &#x3D; errors.New(&quot;bufio: invalid use of UnreadByte&quot;)\n\tErrInvalidUnreadRune &#x3D; errors.New(&quot;bufio: invalid use of UnreadRune&quot;)\n\tErrBufferFull        &#x3D; errors.New(&quot;bufio: buffer full&quot;)\n\tErrNegativeCount     &#x3D; errors.New(&quot;bufio: negative count&quot;)\n)\nvar (\n\tErrTooLong         &#x3D; errors.New(&quot;bufio.Scanner: token too long&quot;)\n\tErrNegativeAdvance &#x3D; errors.New(&quot;bufio.Scanner: SplitFunc returns negative advance count&quot;)\n\tErrAdvanceTooFar   &#x3D; errors.New(&quot;bufio.Scanner: SplitFunc returns advance count beyond input&quot;)\n\tErrBadReadCount    &#x3D; errors.New(&quot;bufio.Scanner: Read returned impossible count&quot;)\n)\nErrors returned by Scanner.\nvar ErrFinalToken &#x3D; errors.New(&quot;final token&quot;)\n\nErrFinalToken is a special sentinel error value. It is intended to be returned by a Split(vt.分离) function to indicate that the token being delivered with the error is the last token and scanning should stop after this one. After ErrFinalToken is received by Scan, scanning stops with no error. The value is useful to stop processing early or when it is necessary to deliver a final empty token. One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value.\nfunc ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)ScanBytes is a split function for a Scanner that returns each byte as a token.\nfunc ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)\ntype ReadWriter\ntype ReadWriter struct &#123;\n\t*Reader\n\t*Writer\n&#125;\n\nfunc NewReadWriter(r *Reader, w *Writer) *ReadWritertype Reader\ntype Reader struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc NewReader(rd io.Reader) *Readerfunc NewReaderSize(rd io.Reader, size int) *Readerfunc (b *Reader) Buffered() intfunc (b *Reader) Discard(n int) (discarded int, err error)func (b *Reader) Peek(n int) ([]byte, error)func (b *Reader) Read(p []byte) (n int, err error)func (b *Reader) ReadByte() (byte, error)func (b *Reader) ReadBytes(delim byte) ([]byte, error)func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)func (b *Reader) ReadRune() (r rune, size int, err error)func (b *Reader) ReadSlice(delim byte) (line []byte, err error)func (b *Reader) ReadString(delim byte) (string, error)func (b *Reader) Reset(r io.Reader)func (b *Reader) Size() intfunc (b *Reader) UnreadByte() errorfunc (b *Reader) UnreadRune() errorfunc (b *Reader) WriteTo(w io.Writer) (n int64, err error)type Scanner\ntype Scanner struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc NewScanner(r io.Reader) *Scannerfunc (s *Scanner) Buffer(buf []byte, max int)func (s *Scanner) Bytes() []bytefunc (s *Scanner) Err() errorfunc (s *Scanner) Scan() boolfunc (s *Scanner) Split(split SplitFunc)func (s *Scanner) Text() stringtype SplitFunc\ntype SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)\n\ntype Writer\ntype Writer struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n\nfunc NewWriter(w io.Writer) *Writerfunc NewWriterSize(w io.Writer, size int) *Writerfunc (b *Writer) Available() intfunc (b *Writer) AvailableBuffer() []bytefunc (b *Writer) Buffered() intfunc (b *Writer) Flush() errorfunc (b *Writer) ReadFrom(r io.Reader) (n int64, err error)func (b *Writer) Reset(w io.Writer)func (b *Writer) Size() intfunc (b *Writer) Write(p []byte) (nn int, err error)func (b *Writer) WriteByte(c byte) errorfunc (b *Writer) WriteRune(r rune) (size int, err error)func (b *Writer) WriteString(s string) (int, error)\n3. builtinPackage builtin provides documentation for Go’s predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language’s special identifiers.\nConstants\nconst (\n\ttrue  &#x3D; 0 &#x3D;&#x3D; 0 &#x2F;&#x2F; Untyped bool.\n\tfalse &#x3D; 0 !&#x3D; 0 &#x2F;&#x2F; Untyped bool.\n)\nconst iota &#x3D; 0 &#x2F;&#x2F; Untyped int.\n\nvariables\nvar nil Type &#x2F;&#x2F; Type must be a pointer, channel, func, interface, map, or slice type\n\nfunc append(slice []Type, elems …Type) []Typefunc cap(v Type) intfunc close(c chan&lt;- Type)func complex(r, i FloatType) ComplexTypefunc copy(dst, src []Type) intfunc delete(m map[Type]Type1, key Type)func imag(c ComplexType) FloatTypefunc len(v Type) intfunc make(t Type, size …IntegerType) Typefunc new(Type) *Typefunc panic(v any)func print(args …Type)func println(args …Type)func real(c ComplexType) FloatTypefunc recover() any\ntype ComplexTypetype FloatTypetype IntegerTypetype Typetype Type1type anytype booltype bytetype comparabletype complex128type complex64type errortype float32type float64type inttype int16type int32type int64type int8type runetype stringtype uinttype uint16type uint32type uint64type uint8type uintptr\n4. bytesPackage bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.\nconstants\nconst MinRead &#x3D; 512\n\nvariables\nvar ErrTooLarge &#x3D; errors.New(&quot;bytes.Buffer: too large&quot;)\n\nfunc Compare(a, b []byte) intfunc Contains(b, subslice []byte) boolfunc ContainsAny(b []byte, chars string) boolfunc ContainsRune(b []byte, r rune) boolfunc Count(s, sep []byte) intfunc Cut(s, sep []byte) (before, after []byte, found bool)func Equal(a, b []byte) boolfunc EqualFold(s, t []byte) boolfunc Fields(s []byte) [][]bytefunc FieldsFunc(s []byte, f func(rune) bool) [][]bytefunc HasPrefix(s, prefix []byte) boolfunc HasSuffix(s, suffix []byte) boolfunc Index(s, sep []byte) intfunc IndexAny(s []byte, chars string) intfunc IndexByte(b []byte, c byte) intfunc IndexFunc(s []byte, f func(r rune) bool) intfunc IndexRune(s []byte, r rune) intfunc Join(s [][]byte, sep []byte) []bytefunc LastIndex(s, sep []byte) intfunc LastIndexAny(s []byte, chars string) intfunc LastIndexByte(s []byte, c byte) intfunc LastIndexFunc(s []byte, f func(r rune) bool) intfunc Map(mapping func(r rune) rune, s []byte) []bytefunc Repeat(b []byte, count int) []bytefunc Replace(s, old, new []byte, n int) []bytefunc ReplaceAll(s, old, new []byte) []bytefunc Runes(s []byte) []runefunc Split(s, sep []byte) [][]bytefunc SplitAfter(s, sep []byte) [][]bytefunc SplitAfterN(s, sep []byte, n int) [][]bytefunc SplitN(s, sep []byte, n int) [][]bytefunc Title(s []byte) []byteDEPRECATEDfunc ToLower(s []byte) []bytefunc ToLowerSpecial(c unicode.SpecialCase, s []byte) []bytefunc ToTitle(s []byte) []bytefunc ToTitleSpecial(c unicode.SpecialCase, s []byte) []bytefunc ToUpper(s []byte) []bytefunc ToUpperSpecial(c unicode.SpecialCase, s []byte) []bytefunc ToValidUTF8(s, replacement []byte) []bytefunc Trim(s []byte, cutset string) []bytefunc TrimFunc(s []byte, f func(r rune) bool) []bytefunc TrimLeft(s []byte, cutset string) []bytefunc TrimLeftFunc(s []byte, f func(r rune) bool) []bytefunc TrimPrefix(s, prefix []byte) []bytefunc TrimRight(s []byte, cutset string) []bytefunc TrimRightFunc(s []byte, f func(r rune) bool) []bytefunc TrimSpace(s []byte) []bytefunc TrimSuffix(s, suffix []byte) []byte\ntype Buffer\nfunc NewBuffer(buf []byte) *Bufferfunc NewBufferString(s string) *Bufferfunc (b *Buffer) Bytes() []bytefunc (b *Buffer) Cap() intfunc (b *Buffer) Grow(n int)func (b *Buffer) Len() intfunc (b *Buffer) Next(n int) []bytefunc (b *Buffer) Read(p []byte) (n int, err error)func (b *Buffer) ReadByte() (byte, error)func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)func (b *Buffer) ReadRune() (r rune, size int, err error)func (b *Buffer) ReadString(delim byte) (line string, err error)func (b *Buffer) Reset()func (b *Buffer) String() stringfunc (b *Buffer) Truncate(n int)func (b *Buffer) UnreadByte() errorfunc (b *Buffer) UnreadRune() errorfunc (b *Buffer) Write(p []byte) (n int, err error)func (b *Buffer) WriteByte(c byte) errorfunc (b *Buffer) WriteRune(r rune) (n int, err error)func (b *Buffer) WriteString(s string) (n int, err error)func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)type Readerfunc NewReader(b []byte) *Readerfunc (r *Reader) Len() intfunc (r *Reader) Read(b []byte) (n int, err error)func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)func (r *Reader) ReadByte() (byte, error)func (r *Reader) ReadRune() (ch rune, size int, err error)func (r *Reader) Reset(b []byte)func (r *Reader) Seek(offset int64, whence int) (int64, error)func (r *Reader) Size() int64func (r *Reader) UnreadByte() errorfunc (r *Reader) UnreadRune() errorfunc (r *Reader) WriteTo(w io.Writer) (n int64, err error)\n5. compress5.1 bzip2Package bzip2 implements bzip2 decompression.\nfunc NewReader(r io.Reader) io.Readertype StructuralErrorfunc (s StructuralError) Error() string\nflatePackage flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats.\nConstants\nconst (\n\tNoCompression      &#x3D; 0\n\tBestSpeed          &#x3D; 1\n\tBestCompression    &#x3D; 9\n\tDefaultCompression &#x3D; -1\n\n\t&#x2F;&#x2F; HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman\n\t&#x2F;&#x2F; entropy encoding. This mode is useful in compressing data that has\n\t&#x2F;&#x2F; already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)\n\t&#x2F;&#x2F; that lacks an entropy encoder. Compression gains are achieved when\n\t&#x2F;&#x2F; certain bytes in the input stream occur more frequently than others.\n\t&#x2F;&#x2F;\n\t&#x2F;&#x2F; Note that HuffmanOnly produces a compressed output that is\n\t&#x2F;&#x2F; RFC 1951 compliant. That is, any valid DEFLATE decompressor will\n\t&#x2F;&#x2F; continue to be able to decompress this output.\n\tHuffmanOnly &#x3D; -2\n)\nfunc NewReader(r io.Reader) io.ReadCloserfunc NewReaderDict(r io.Reader, dict []byte) io.ReadClosertype CorruptInputError#func (e CorruptInputError) Error() stringtype InternalError#func (e InternalError) Error() stringtype ReadErrorDEPRECATED#func (e *ReadError) Error() stringtype Readertype Resettertype WriteErrorDEPRECATED#func (e *WriteError) Error() stringtype Writerfunc NewWriter(w io.Writer, level int) (*Writer, error)func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)#func (w *Writer) Close() error#func (w *Writer) Flush() error#func (w *Writer) Reset(dst io.Writer)#func (w *Writer) Write(data []byte) (n int, err error)\n5.2 gzipPackage gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.\nConstants\nconst (\n\tNoCompression      &#x3D; flate.NoCompression\n\tBestSpeed          &#x3D; flate.BestSpeed\n\tBestCompression    &#x3D; flate.BestCompression\n\tDefaultCompression &#x3D; flate.DefaultCompression\n\tHuffmanOnly        &#x3D; flate.HuffmanOnly\n)\nThese constants are copied from the flate package, so that code that imports “compress&#x2F;gzip” does not also have to import “compress&#x2F;flate”.\nVariables\nvar (\n\t&#x2F;&#x2F; ErrChecksum is returned when reading GZIP data that has an invalid checksum.\n\tErrChecksum &#x3D; errors.New(&quot;gzip: invalid checksum&quot;)\n\t&#x2F;&#x2F; ErrHeader is returned when reading GZIP data that has an invalid header.\n\tErrHeader &#x3D; errors.New(&quot;gzip: invalid header&quot;)\n)\ntype Header\ntype Header struct &#123;\n\tComment string    &#x2F;&#x2F; comment\n\tExtra   []byte    &#x2F;&#x2F; &quot;extra data&quot;\n\tModTime time.Time &#x2F;&#x2F; modification time\n\tName    string    &#x2F;&#x2F; file name\n\tOS      byte      &#x2F;&#x2F; operating system type\n&#125;\ntype Reader\ntype Reader struct &#123;\n\tHeader &#x2F;&#x2F; valid after NewReader or Reader.Reset\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc NewReader(r io.Reader) (*Reader, error)#func (z *Reader) Close() error#func (z *Reader) Multistream(ok bool)#func (z *Reader) Read(p []byte) (n int, err error)#func (z *Reader) Reset(r io.Reader) errortype Writer\ntype Writer struct &#123;\n\tHeader &#x2F;&#x2F; written at first call to Write, Flush, or Close\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n\nfunc NewWriter(w io.Writer) *Writerfunc NewWriterLevel(w io.Writer, level int) (*Writer, error)#func (z *Writer) Close() error#func (z *Writer) Flush() error#func (z *Writer) Reset(w io.Writer)#func (z *Writer) Write(p []byte) (int, error)\n5.3 lzwPackage lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19.\nIn particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.\nThe TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org&#x2F;x&#x2F;image&#x2F;tiff&#x2F;lzw package for an implementation.\nfunc NewReader(r io.Reader, order Order, litWidth int) io.ReadCloserfunc NewWriter(w io.Writer, order Order, litWidth int) io.WriteClosertype Order\ntype Order int\ntype Reader\ntype Reader struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n#func (r *Reader) Close() error#func (r *Reader) Read(b []byte) (int, error)#func (r *Reader) Reset(src io.Reader, order Order, litWidth int)type Writer\ntype Writer struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n\n\n#func (w *Writer) Close() error#func (w *Writer) Reset(dst io.Writer, order Order, litWidth int)#func (w *Writer) Write(p []byte) (n int, err error)\n5.4 compress&#x2F;zlibOverviewPackage zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.\nThe implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:\nvar b bytes.Buffer\nw :&#x3D; zlib.NewWriter(&amp;b)\nw.Write([]byte(&quot;hello, world\\n&quot;))\nw.Close()\nand to read that data back:\nr, err :&#x3D; zlib.NewReader(&amp;b)\nio.Copy(os.Stdout, r)\nr.Close()\nConstantsVariablesfunc NewReader(r io.Reader) (io.ReadCloser, error)func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)type Resetter\ntype Resetter interface &#123;\n\t&#x2F;&#x2F; Reset discards any buffered data and resets the Resetter as if it was\n\t&#x2F;&#x2F; newly initialized with the given reader.\n\tReset(r io.Reader, dict []byte) error\n&#125;\ntype Writer\ntype Writer struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc NewWriter(w io.Writer) *Writerfunc NewWriterLevel(w io.Writer, level int) (*Writer, error)func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)#func (z *Writer) Close() error#func (z *Writer) Flush() error#func (z *Writer) Reset(w io.Writer)#func (z *Writer) Write(p []byte) (n int, err error)\n6. container6.1 container&#x2F;heapOverviewPackage heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.\nThe minimum element in the tree is the root, at index 0.\nA heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source.\nfunc Fix(h Interface, i int)func Init(h Interface)func Pop(h Interface) anyfunc Push(h Interface, x any)func Remove(h Interface, i int) anytype Interface\n6.2 container&#x2F;listOverviewPackage list implements a doubly linked list.\nTo iterate over a list (where l is a *List):\nfor e :&#x3D; l.Front(); e !&#x3D; nil; e &#x3D; e.Next() &#123;\n\t&#x2F;&#x2F; do something with e.Value\n&#125;\n\n\ntype Elementfunc (e *Element) Next() *Elementfunc (e *Element) Prev() *Elementtype Listfunc New() *Listfunc (l *List) Back() *Elementfunc (l *List) Front() *Elementfunc (l *List) Init() *Listfunc (l *List) InsertAfter(v any, mark *Element) *Elementfunc (l *List) InsertBefore(v any, mark *Element) *Elementfunc (l *List) Len() intfunc (l *List) MoveAfter(e, mark *Element)func (l *List) MoveBefore(e, mark *Element)func (l *List) MoveToBack(e *Element)func (l *List) MoveToFront(e *Element)func (l *List) PushBack(v any) *Elementfunc (l *List) PushBackList(other *List)func (l *List) PushFront(v any) *Elementfunc (l *List) PushFrontList(other *List)func (l *List) Remove(e *Element) any\n7. osoverviewPackage os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information.\nThe os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.\nHere is a simple example, opening a file and reading some of it.\nfile, err :&#x3D; os.Open(&quot;file.go&quot;) &#x2F;&#x2F; For read access.\nif err !&#x3D; nil &#123;\n\tlog.Fatal(err)\n&#125;\nIf the open fails, the error string will be self-explanatory, like\nopen file.go: no such file or directory\nThe file’s data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.\ndata :&#x3D; make([]byte, 100)\ncount, err :&#x3D; file.Read(data)\nif err !&#x3D; nil &#123;\n\tlog.Fatal(err)\n&#125;\nfmt.Printf(&quot;read %d bytes: %q\\n&quot;, count, data[:count])\nNote: The maximum number of concurrent operations on a File may be limited by the OS or the system. The number should be high, but exceeding(adj.超越的) it may degrade(vt.贬低) performance or cause other issues.\nsummary:  \n\nfailing calls return values of type error rather than error numbers.like above open file failed. and emit “open file.go: no such file or directory”\nThe maximum number of concurrent operations on a File may be limited by the OS or the system(not know the root cause and knowledge)\n\nConstants\nconst (\n\t&#x2F;&#x2F; Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.\n\tO_RDONLY int &#x3D; syscall.O_RDONLY &#x2F;&#x2F; open the file read-only.\n\tO_WRONLY int &#x3D; syscall.O_WRONLY &#x2F;&#x2F; open the file write-only.\n\tO_RDWR   int &#x3D; syscall.O_RDWR   &#x2F;&#x2F; open the file read-write.\n\t&#x2F;&#x2F; The remaining values may be or&#39;ed in to control behavior.\n\tO_APPEND int &#x3D; syscall.O_APPEND &#x2F;&#x2F; append data to the file when writing.\n\tO_CREATE int &#x3D; syscall.O_CREAT  &#x2F;&#x2F; create a new file if none exists.\n\tO_EXCL   int &#x3D; syscall.O_EXCL   &#x2F;&#x2F; used with O_CREATE, file must not exist.\n\tO_SYNC   int &#x3D; syscall.O_SYNC   &#x2F;&#x2F; open for synchronous I&#x2F;O.\n\tO_TRUNC  int &#x3D; syscall.O_TRUNC  &#x2F;&#x2F; truncate regular(adj. 定期的) writable file when opened.\n)\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system.\nconst (\n\tSEEK_SET int &#x3D; 0 &#x2F;&#x2F; seek relative to the origin of the file\n\tSEEK_CUR int &#x3D; 1 &#x2F;&#x2F; seek relative to the current offset\n\tSEEK_END int &#x3D; 2 &#x2F;&#x2F; seek relative to the end\n)\nDeprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.\nconst (\n\tPathSeparator     &#x3D; &#39;&#x2F;&#39; &#x2F;&#x2F; OS-specific path separator\n\tPathListSeparator &#x3D; &#39;:&#39; &#x2F;&#x2F; OS-specific path list separator\n)\nconst (\n\t&#x2F;&#x2F; The single letters are the abbreviations\n\t&#x2F;&#x2F; used by the String method&#39;s formatting.\n\tModeDir        &#x3D; fs.ModeDir        &#x2F;&#x2F; d: is a directory\n\tModeAppend     &#x3D; fs.ModeAppend     &#x2F;&#x2F; a: append-only\n\tModeExclusive  &#x3D; fs.ModeExclusive  &#x2F;&#x2F; l: exclusive use\n\tModeTemporary  &#x3D; fs.ModeTemporary  &#x2F;&#x2F; T: temporary file; Plan 9 only\n\tModeSymlink    &#x3D; fs.ModeSymlink    &#x2F;&#x2F; L: symbolic link\n\tModeDevice     &#x3D; fs.ModeDevice     &#x2F;&#x2F; D: device file\n\tModeNamedPipe  &#x3D; fs.ModeNamedPipe  &#x2F;&#x2F; p: named pipe (FIFO)\n\tModeSocket     &#x3D; fs.ModeSocket     &#x2F;&#x2F; S: Unix domain socket\n\tModeSetuid     &#x3D; fs.ModeSetuid     &#x2F;&#x2F; u: setuid\n\tModeSetgid     &#x3D; fs.ModeSetgid     &#x2F;&#x2F; g: setgid\n\tModeCharDevice &#x3D; fs.ModeCharDevice &#x2F;&#x2F; c: Unix character device, when ModeDevice is set\n\tModeSticky     &#x3D; fs.ModeSticky     &#x2F;&#x2F; t: sticky\n\tModeIrregular  &#x3D; fs.ModeIrregular  &#x2F;&#x2F; ?: non-regular file; nothing else is known about this file\n\n\t&#x2F;&#x2F; Mask for the type bits. For regular files, none will be set.\n\tModeType &#x3D; fs.ModeType\n\n\tModePerm &#x3D; fs.ModePerm &#x2F;&#x2F; Unix permission bits, 0o777\n)\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.\nconst DevNull &#x3D; &quot;&#x2F;dev&#x2F;null&quot;\nDevNull is the name of the operating system’s “null device.” On Unix-like systems, it is “&#x2F;dev&#x2F;null”; on Windows, “NUL”.\nvariables\nvar (\n\t&#x2F;&#x2F; ErrInvalid indicates an invalid argument.\n\t&#x2F;&#x2F; Methods on File will return this error when the receiver is nil.\n\tErrInvalid &#x3D; fs.ErrInvalid &#x2F;&#x2F; &quot;invalid argument&quot;\n\n\tErrPermission &#x3D; fs.ErrPermission &#x2F;&#x2F; &quot;permission denied&quot;\n\tErrExist      &#x3D; fs.ErrExist      &#x2F;&#x2F; &quot;file already exists&quot;\n\tErrNotExist   &#x3D; fs.ErrNotExist   &#x2F;&#x2F; &quot;file does not exist&quot;\n\tErrClosed     &#x3D; fs.ErrClosed     &#x2F;&#x2F; &quot;file already closed&quot;\n\n\tErrNoDeadline       &#x3D; errNoDeadline()       &#x2F;&#x2F; &quot;file type does not support deadline&quot;\n\tErrDeadlineExceeded &#x3D; errDeadlineExceeded() &#x2F;&#x2F; &quot;i&#x2F;o timeout&quot;\n)\nPortable analogs of some common system call errors.\nErrors returned from this package may be tested against these errors with errors.Is.\nStdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors.\nNote that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later.\nvar Args []string\n\nArgs hold the command-line arguments, starting with the program name.\nvar ErrProcessDone &#x3D; errors.New(&quot;os: process already finished&quot;)\nErrProcessDone indicates a Process has finished.\nfucntionfunc Chdir(dir string) errorChdir changes the current working directory to the named directory. If there is an error, it will be of type *PathError.\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;log&quot;\n\t&quot;os&quot;\n)\n\nfunc main() &#123;\n\tif err :&#x3D; os.Chdir(&quot;&#x2F;home&#x2F;kirkzhang&#x2F;go-workspace&quot;); err !&#x3D; nil &#123;\n\t\tlog.Fatal(err)\n\t&#125;\n\tCurDir, err :&#x3D; os.Getwd()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125; else &#123;\n\t\tfmt.Println(&quot;Current working directory: &quot;, CurDir)\n\t&#125;\n&#125;\n\n$ Current working directory:  &#x2F;home&#x2F;kirkzhang&#x2F;go-workspace\n\nsummary:more like cd command in linux\nfunc Chmod(name string, mode FileMode) errorChmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link’s target. If there is an error, it will be of type *PathError.\nA different subset of the mode bits are used, depending on the operating system.\nOn Unix, the mode’s permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used.\nOn Windows, only the 0200 bit (owner writable) of mode is used; it controls whether the file’s read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0400 for a read-only file and 0600 for a readable+writable file.\nOn Plan 9, the mode’s permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used.\nfunc main() &#123;\n\tif err :&#x3D; os.Chmod(&quot;.&#x2F;hello_world.go&quot;, os.ModePerm); err !&#x3D; nil &#123;\n  &#x2F;&#x2F; if err :&#x3D; os.Chmod(&quot;.&#x2F;hello_world.go&quot;, os.FileMode.Perm(777));\n\t\tlog.Fatal(err)\n\t&#125;\n\tCurDir, err :&#x3D; os.Getwd()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125; else &#123;\n\t\tfmt.Println(&quot;Current working directory: &quot;, CurDir)\n\t&#125;\n\n&#125;\n\n\n\nfunc Chown(name string, uid, gid int) errorChown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link’s target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type *PathError.\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9 error, wrapped in *PathError.\nfunc Chtimes(name string, atime time.Time, mtime time.Time) errorChtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions.\nThe underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.\nfunc Clearenv()Clearenv deletes all environment variables.func DirFS(dir string) fs.FSDirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.\nNote that DirFS(“&#x2F;prefix”) only guarantees that the Open calls it makes to the operating system will begin with “&#x2F;prefix”: DirFS(“&#x2F;prefix”).Open(“file”) is the same as os.Open(“&#x2F;prefix&#x2F;file”). So if &#x2F;prefix&#x2F;file is a symbolic link pointing outside the &#x2F;prefix tree, then using DirFS does not stop the access any more than using os.Open does. Additionally, the root of the fs.FS returned for a relative path, DirFS(“prefix”), will be affected by later calls to Chdir. DirFS is therefore not a general substitute for a chroot-style security mechanism when the directory tree contains arbitrary content.\nfunc Environ() []stringEnviron returns a copy of strings representing the environment, in the form “key&#x3D;value”.\nfunc Executable() (string, error)Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path&#x2F;filepath.EvalSymlinks might help.\nExecutable returns an absolute path unless an error occurred.\nThe main use case is finding resources located relative to an executable.\nfunc Exit(code int)Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run.\nFor portability, the status code should be in the range [0, 125].func Expand(s string, mapping func(string) string) stringExpand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).func ExpandEnv(s string) stringExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string.func Getegid() intGetegid returns the numeric effective group id of the caller.\nOn Windows, it returns -1.func Getenv(key string) stringGetenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv.func Geteuid() int\nfunc Getgid() intGeteuid returns the numeric effective user id of the caller.\nOn Windows, it returns -1.func Getgroups() ([]int, error)Getgid returns the numeric group id of the caller.\nOn Windows, it returns -1.func Getpagesize() intGetgroups returns a list of the numeric ids of groups that the caller belongs to.\nOn Windows, it returns syscall.EWINDOWS. See the os&#x2F;user package for a possible alternative.func Getpid() intGetpagesize returns the underlying system’s memory page size.func Getppid() intGetpid returns the process id of the caller.func Getuid() intGeteuid returns the numeric effective user id of the caller.\nOn Windows, it returns -1.func Getwd() (dir string, err error)Getgid returns the numeric group id of the caller.\nOn Windows, it returns -1.func Hostname() (name string, err error)func IsExist(err error) boolfunc IsNotExist(err error) boolfunc IsPathSeparator(c uint8) boolfunc IsPermission(err error) boolfunc IsTimeout(err error) boolfunc Lchown(name string, uid, gid int) errorfunc Link(oldname, newname string) errorfunc LookupEnv(key string) (string, bool)func Mkdir(name string, perm FileMode) errorfunc MkdirAll(path string, perm FileMode) errorfunc MkdirTemp(dir, pattern string) (string, error)func NewSyscallError(syscall string, err error) errorfunc Pipe() (r *File, w *File, err error)func ReadFile(name string) ([]byte, error)func Readlink(name string) (string, error)func Remove(name string) errorfunc RemoveAll(path string) errorfunc Rename(oldpath, newpath string) errorfunc SameFile(fi1, fi2 FileInfo) boolfunc Setenv(key, value string) errorfunc Symlink(oldname, newname string) errorfunc TempDir() stringfunc Truncate(name string, size int64) errorfunc Unsetenv(key string) errorfunc UserCacheDir() (string, error)func UserConfigDir() (string, error)func UserHomeDir() (string, error)func WriteFile(name string, data []byte, perm FileMode) errortype DirEntryfunc ReadDir(name string) ([]DirEntry, error)type Filefunc Create(name string) (*File, error)func CreateTemp(dir, pattern string) (*File, error)func NewFile(fd uintptr, name string) *Filefunc Open(name string) (*File, error)func OpenFile(name string, flag int, perm FileMode) (*File, error)func (f *File) Chdir() errorfunc (f *File) Chmod(mode FileMode) errorfunc (f *File) Chown(uid, gid int) errorfunc (f *File) Close() errorfunc (f *File) Fd() uintptrfunc (f *File) Name() stringfunc (f *File) Read(b []byte) (n int, err error)func (f *File) ReadAt(b []byte, off int64) (n int, err error)func (f *File) ReadDir(n int) ([]DirEntry, error)func (f *File) ReadFrom(r io.Reader) (n int64, err error)func (f *File) Readdir(n int) ([]FileInfo, error)func (f *File) Readdirnames(n int) (names []string, err error)func (f *File) Seek(offset int64, whence int) (ret int64, err error)func (f *File) SetDeadline(t time.Time) errorfunc (f *File) SetReadDeadline(t time.Time) errorfunc (f *File) SetWriteDeadline(t time.Time) errorfunc (f *File) Stat() (FileInfo, error)func (f *File) Sync() errorfunc (f *File) SyscallConn() (syscall.RawConn, error)func (f *File) Truncate(size int64) errorfunc (f *File) Write(b []byte) (n int, err error)func (f *File) WriteAt(b []byte, off int64) (n int, err error)func (f *File) WriteString(s string) (n int, err error)type FileInfofunc Lstat(name string) (FileInfo, error)func Stat(name string) (FileInfo, error)type FileModetype LinkErrorfunc (e *LinkError) Error() stringfunc (e *LinkError) Unwrap() errortype PathErrortype ProcAttrtype Processfunc FindProcess(pid int) (*Process, error)func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)func (p *Process) Kill() errorfunc (p *Process) Release() errorfunc (p *Process) Signal(sig Signal) errorfunc (p *Process) Wait() (*ProcessState, error)type ProcessStatefunc (p *ProcessState) ExitCode() intfunc (p *ProcessState) Exited() boolfunc (p *ProcessState) Pid() intfunc (p *ProcessState) String() stringfunc (p *ProcessState) Success() boolfunc (p *ProcessState) Sys() anyfunc (p *ProcessState) SysUsage() anyfunc (p *ProcessState) SystemTime() time.Durationfunc (p *ProcessState) UserTime() time.Durationtype Signaltype SyscallErrorfunc (e *SyscallError) Error() stringfunc (e *SyscallError) Timeout() boolfunc (e *SyscallError) Unwrap() error\n8. timeConstants  const (\n  Layout      &#x3D; &quot;01&#x2F;02 03:04:05PM &#39;06 -0700&quot; &#x2F;&#x2F; The reference time, in numerical order.\n  ANSIC       &#x3D; &quot;Mon Jan _2 15:04:05 2006&quot;\n  UnixDate    &#x3D; &quot;Mon Jan _2 15:04:05 MST 2006&quot;\n  RubyDate    &#x3D; &quot;Mon Jan 02 15:04:05 -0700 2006&quot;\n  RFC822      &#x3D; &quot;02 Jan 06 15:04 MST&quot;\n  RFC822Z     &#x3D; &quot;02 Jan 06 15:04 -0700&quot; &#x2F;&#x2F; RFC822 with numeric zone\n  RFC850      &#x3D; &quot;Monday, 02-Jan-06 15:04:05 MST&quot;\n  RFC1123     &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 MST&quot;\n  RFC1123Z    &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 -0700&quot; &#x2F;&#x2F; RFC1123 with numeric zone\n  RFC3339     &#x3D; &quot;2006-01-02T15:04:05Z07:00&quot;\n  RFC3339Nano &#x3D; &quot;2006-01-02T15:04:05.999999999Z07:00&quot;\n  Kitchen     &#x3D; &quot;3:04PM&quot;\n  &#x2F;&#x2F; Handy time stamps.\n  Stamp      &#x3D; &quot;Jan _2 15:04:05&quot;\n  StampMilli &#x3D; &quot;Jan _2 15:04:05.000&quot;\n  StampMicro &#x3D; &quot;Jan _2 15:04:05.000000&quot;\n  StampNano  &#x3D; &quot;Jan _2 15:04:05.000000000&quot;\n)\nfunc After(d Duration) &lt;-chan Time\n  After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.这里需要注意，这个After(d Duration)是指返回一次的时间戳，想要使用还要再次初始化\nfunc Sleep(d Duration)\nfunc Tick(d Duration) &lt;-chan Time\ntype Duration\nfunc ParseDuration(s string) (Duration, error)\nfunc Since(t Time) Duration\nfunc Until(t Time) Duration\nfunc (d Duration) Abs() Duration\nfunc (d Duration) Hours() float64\nfunc (d Duration) Microseconds() int64\nfunc (d Duration) Milliseconds() int64\nfunc (d Duration) Minutes() float64\nfunc (d Duration) Nanoseconds() int64\nfunc (d Duration) Round(m Duration) Duration\nfunc (d Duration) Seconds() float64\nfunc (d Duration) String() string\nfunc (d Duration) Truncate(m Duration) Duration\ntype Location\nfunc FixedZone(name string, offset int) *Location\nfunc LoadLocation(name string) (*Location, error)\nfunc LoadLocationFromTZData(name string, data []byte) (*Location, error)\nfunc (l*Location) String() string\ntype Month\nfunc (m Month) String() string\ntype ParseError\nfunc (e *ParseError) Error() string\ntype Ticker\n  A Ticker holds a channel that delivers “ticks” of a clock at intervals.\nfunc NewTicker(d Duration) *Ticker\n  NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.\nfunc (t *Ticker) Reset(d Duration)\n  Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic.\nfunc (t *Ticker) Stop()\n  Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous “tick”.\ntype Time\nfunc Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time\nfunc Now() Time\nfunc Parse(layout, value string) (Time, error)\nfunc ParseInLocation(layout, value string, loc *Location) (Time, error)\nfunc Unix(sec int64, nsec int64) Time\nfunc UnixMicro(usec int64) Time\nfunc UnixMilli(msec int64) Time\nfunc (t Time) Add(d Duration) Time\nfunc (t Time) AddDate(years int, months int, days int) Time\nfunc (t Time) After(u Time) bool\nfunc (t Time) AppendFormat(b []byte, layout string) []byte\nfunc (t Time) Before(u Time) bool\nfunc (t Time) Clock() (hour, min, sec int)\nfunc (t Time) Date() (year int, month Month, day int)\nfunc (t Time) Day() int\nfunc (t Time) Equal(u Time) bool\nfunc (t Time) Format(layout string) string\nfunc (t Time) GoString() string\nfunc (t *Time) GobDecode(data []byte) error\nfunc (t Time) GobEncode() ([]byte, error)\nfunc (t Time) Hour() int\nfunc (t Time) ISOWeek() (year, week int)\nfunc (t Time) In(loc*Location) Time\nfunc (t Time) IsDST() bool\nfunc (t Time) IsZero() bool\nfunc (t Time) Local() Time\nfunc (t Time) Location() *Location\nfunc (t Time) MarshalBinary() ([]byte, error)\nfunc (t Time) MarshalJSON() ([]byte, error)\nfunc (t Time) MarshalText() ([]byte, error)\nfunc (t Time) Minute() int\nfunc (t Time) Month() Month\nfunc (t Time) Nanosecond() int\nfunc (t Time) Round(d Duration) Time\nfunc (t Time) Second() int\nfunc (t Time) String() string\nfunc (t Time) Sub(u Time) Duration\nfunc (t Time) Truncate(d Duration) Time\nfunc (t Time) UTC() Time\nfunc (t Time) Unix() int64\nfunc (t Time) UnixMicro() int64\nfunc (t Time) UnixMilli() int64\nfunc (t Time) UnixNano() int64\nfunc (t*Time) UnmarshalBinary(data []byte) error\nfunc (t *Time) UnmarshalJSON(data []byte) error\nfunc (t*Time) UnmarshalText(data []byte) error\nfunc (t Time) Weekday() Weekday\nfunc (t Time) Year() int\nfunc (t Time) YearDay() int\nfunc (t Time) Zone() (name string, offset int)\nfunc (t Time) ZoneBounds() (start, end Time)\ntype Timer\n  type Timer struct &#123;\n  C &lt;-chan Time\n  &#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n\n  这里的C用于接收\nfunc AfterFunc(d Duration, f func()) *Timer\nfunc NewTimer(d Duration)*Timer\nfunc (t *Timer) Reset(d Duration) bool\nfunc (t*Timer) Stop() bool\ntype Weekday\nfunc (d Weekday) String() string\n9. mathindexfunc Abs(x float64) float64func Acos(x float64) float64func Acosh(x float64) float64func Asin(x float64) float64func Asinh(x float64) float64func Atan(x float64) float64func Atan2(y, x float64) float64func Atanh(x float64) float64func Cbrt(x float64) float64func Ceil(x float64) float64func Copysign(f, sign float64) float64func Cos(x float64) float64func Cosh(x float64) float64func Dim(x, y float64) float64func Erf(x float64) float64func Erfc(x float64) float64func Erfcinv(x float64) float64func Erfinv(x float64) float64func Exp(x float64) float64func Exp2(x float64) float64func Expm1(x float64) float64func FMA(x, y, z float64) float64func Float32bits(f float32) uint32func Float32frombits(b uint32) float32func Float64bits(f float64) uint64func Float64frombits(b uint64) float64func Floor(x float64) float64func Frexp(f float64) (frac float64, exp int)func Gamma(x float64) float64func Hypot(p, q float64) float64func Ilogb(x float64) intfunc Inf(sign int) float64func IsInf(f float64, sign int) boolfunc IsNaN(f float64) (is bool)func J0(x float64) float64func J1(x float64) float64func Jn(n int, x float64) float64func Ldexp(frac float64, exp int) float64func Lgamma(x float64) (lgamma float64, sign int)func Log(x float64) float64func Log10(x float64) float64func Log1p(x float64) float64func Log2(x float64) float64func Logb(x float64) float64func Max(x, y float64) float64func Min(x, y float64) float64func Mod(x, y float64) float64func Modf(f float64) (int float64, frac float64)func NaN() float64func Nextafter(x, y float64) (r float64)func Nextafter32(x, y float32) (r float32)func Pow(x, y float64) float64func Pow10(n int) float64func Remainder(x, y float64) float64func Round(x float64) float64func RoundToEven(x float64) float64func Signbit(x float64) boolfunc Sin(x float64) float64func Sincos(x float64) (sin, cos float64)func Sinh(x float64) float64func Sqrt(x float64) float64func Tan(x float64) float64func Tanh(x float64) float64func Trunc(x float64) float64func Y0(x float64) float64func Y1(x float64) float64func Yn(n int, x float64) float64\nOverview\nPackage math provides basic constants and mathematical functions.\nThis package does not guarantee bit-identical results across architectures.\nConstants\nconst (\n\tE   &#x3D; 2.71828182845904523536028747135266249775724709369995957496696763 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A001113\n\tPi  &#x3D; 3.14159265358979323846264338327950288419716939937510582097494459 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A000796\n\tPhi &#x3D; 1.61803398874989484820458683436563811772030917980576286213544862 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A001622\n\tSqrt2   &#x3D; 1.41421356237309504880168872420969807856967187537694807317667974 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A002193\n\tSqrtE   &#x3D; 1.64872127070012814684865078781416357165377610071014801157507931 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A019774\n\tSqrtPi  &#x3D; 1.77245385090551602729816748334114518279754945612238712821380779 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A002161\n\tSqrtPhi &#x3D; 1.27201964951406896425242246173749149171560804184009624861664038 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A139339\n\tLn2    &#x3D; 0.693147180559945309417232121458176568075500134360255254120680009 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A002162\n\tLog2E  &#x3D; 1 &#x2F; Ln2\n\tLn10   &#x3D; 2.30258509299404568401799145468436420760110148862877297603332790 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A002392\n\tLog10E &#x3D; 1 &#x2F; Ln10\n)\n\nMathematical constants.\nconst (\n\tMaxFloat32             &#x3D; 0x1p127 * (1 + (1 - 0x1p-23)) &#x2F;&#x2F; 3.40282346638528859811704183484516925440e+38\n\tSmallestNonzeroFloat32 &#x3D; 0x1p-126 * 0x1p-23            &#x2F;&#x2F; 1.401298464324817070923729583289916131280e-45\n\n\tMaxFloat64             &#x3D; 0x1p1023 * (1 + (1 - 0x1p-52)) &#x2F;&#x2F; 1.79769313486231570814527423731704356798070e+308\n\tSmallestNonzeroFloat64 &#x3D; 0x1p-1022 * 0x1p-52            &#x2F;&#x2F; 4.9406564584124654417656879286822137236505980e-324\n)\nFloating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type.\nconst (\n\tMaxInt    &#x3D; 1&lt;&lt;(intSize-1) - 1\n\tMinInt    &#x3D; -1 &lt;&lt; (intSize - 1)\n\tMaxInt8   &#x3D; 1&lt;&lt;7 - 1\n\tMinInt8   &#x3D; -1 &lt;&lt; 7\n\tMaxInt16  &#x3D; 1&lt;&lt;15 - 1\n\tMinInt16  &#x3D; -1 &lt;&lt; 15\n\tMaxInt32  &#x3D; 1&lt;&lt;31 - 1\n\tMinInt32  &#x3D; -1 &lt;&lt; 31\n\tMaxInt64  &#x3D; 1&lt;&lt;63 - 1\n\tMinInt64  &#x3D; -1 &lt;&lt; 63\n\tMaxUint   &#x3D; 1&lt;&lt;intSize - 1\n\tMaxUint8  &#x3D; 1&lt;&lt;8 - 1\n\tMaxUint16 &#x3D; 1&lt;&lt;16 - 1\n\tMaxUint32 &#x3D; 1&lt;&lt;32 - 1\n\tMaxUint64 &#x3D; 1&lt;&lt;64 - 1\n)\nInteger limit values.\nFunctions\nfunc Absfunc Abs(x float64) float64Abs returns the absolute value of xSpecial cases are:Abs(±Inf) &#x3D; +InfAbs(NaN) &#x3D; NaN\nfunc Absfunc Acos(x float64) float64Acos returns the arccosine, in radians, of xSpecial case is:\nAcos(x) &#x3D; NaN if x &lt; -1 or x &gt; 1\n\nfunc Absfunc Acosh(x float64) float64Acosh returns the inverse hyperbolic cosine of x.\nSpecial cases are:\nAcosh(+Inf) &#x3D; +Inf\nAcosh(x) &#x3D; NaN if x &lt; 1\nAcosh(NaN) &#x3D; NaN\nfunc Asin ¶func Asin(x float64) float64Asin returns the arcsine, in radians, of x.\nSpecial cases are:\nAsin(±0) &#x3D; ±0\nAsin(x) &#x3D; NaN if x &lt; -1 or x &gt; 1\nfunc Asinh\nfunc Asinh(x float64) float64Asinh returns the inverse hyperbolic sine of x.\nSpecial cases are:\nAsinh(±0) &#x3D; ±0\nAsinh(±Inf) &#x3D; ±Inf\nAsinh(NaN) &#x3D; NaN\nfunc Atan\nfunc Atan(x float64) float64Atan returns the arctangent, in radians, of x.\nSpecial cases are:\nAtan(±0) &#x3D; ±0\nAtan(±Inf) &#x3D; ±Pi&#x2F;2\nfunc Atan2\nfunc Atan2(y, x float64) float64Atan2 returns the arc tangent of y&#x2F;x, using the signs of the two to determine the quadrant of the return value.\nSpecial cases are (in order):\nAtan2(y, NaN) &#x3D; NaNAtan2(NaN, x) &#x3D; NaNAtan2(+0, x&gt;&#x3D;0) &#x3D; +0Atan2(-0, x&gt;&#x3D;0) &#x3D; -0Atan2(+0, x&lt;&#x3D;-0) &#x3D; +PiAtan2(-0, x&lt;&#x3D;-0) &#x3D; -PiAtan2(y&gt;0, 0) &#x3D; +Pi&#x2F;2Atan2(y&lt;0, 0) &#x3D; -Pi&#x2F;2Atan2(+Inf, +Inf) &#x3D; +Pi&#x2F;4Atan2(-Inf, +Inf) &#x3D; -Pi&#x2F;4Atan2(+Inf, -Inf) &#x3D; 3Pi&#x2F;4Atan2(-Inf, -Inf) &#x3D; -3Pi&#x2F;4Atan2(y, +Inf) &#x3D; 0Atan2(y&gt;0, -Inf) &#x3D; +PiAtan2(y&lt;0, -Inf) &#x3D; -PiAtan2(+Inf, x) &#x3D; +Pi&#x2F;2Atan2(-Inf, x) &#x3D; -Pi&#x2F;2Example ¶func Atanh ¶func Atanh(x float64) float64Atanh returns the inverse hyperbolic tangent of x.\nSpecial cases are:\nAtanh(1) &#x3D; +InfAtanh(±0) &#x3D; ±0Atanh(-1) &#x3D; -InfAtanh(x) &#x3D; NaN if x &lt; -1 or x &gt; 1Atanh(NaN) &#x3D; NaNExample ¶func Cbrt ¶func Cbrt(x float64) float64Cbrt returns the cube root of x.\nSpecial cases are:\nCbrt(±0) &#x3D; ±0Cbrt(±Inf) &#x3D; ±InfCbrt(NaN) &#x3D; NaNExample ¶func Ceil ¶func Ceil(x float64) float64Ceil returns the least integer value greater than or equal to x.\nSpecial cases are:\nCeil(±0) &#x3D; ±0Ceil(±Inf) &#x3D; ±InfCeil(NaN) &#x3D; NaNExample ¶func Copysign ¶func Copysign(f, sign float64) float64Copysign returns a value with the magnitude of f and the sign of sign.\nExample ¶func Cos ¶func Cos(x float64) float64Cos returns the cosine of the radian argument x.\nSpecial cases are:\nCos(±Inf) &#x3D; NaNCos(NaN) &#x3D; NaNExample ¶func Cosh ¶func Cosh(x float64) float64Cosh returns the hyperbolic cosine of x.\nSpecial cases are:\nCosh(±0) &#x3D; 1Cosh(±Inf) &#x3D; +InfCosh(NaN) &#x3D; NaNExample ¶func Dim ¶func Dim(x, y float64) float64Dim returns the maximum of x-y or 0.\nSpecial cases are:\nDim(+Inf, +Inf) &#x3D; NaNDim(-Inf, -Inf) &#x3D; NaNDim(x, NaN) &#x3D; Dim(NaN, x) &#x3D; NaNExample ¶func Erf ¶func Erf(x float64) float64Erf returns the error function of x.\nSpecial cases are:\nErf(+Inf) &#x3D; 1Erf(-Inf) &#x3D; -1Erf(NaN) &#x3D; NaNfunc Erfc ¶func Erfc(x float64) float64Erfc returns the complementary error function of x.\nSpecial cases are:\nErfc(+Inf) &#x3D; 0Erfc(-Inf) &#x3D; 2Erfc(NaN) &#x3D; NaNfunc Erfcinv ¶added in go1.10func Erfcinv(x float64) float64Erfcinv returns the inverse of Erfc(x).\nSpecial cases are:\nErfcinv(0) &#x3D; +InfErfcinv(2) &#x3D; -InfErfcinv(x) &#x3D; NaN if x &lt; 0 or x &gt; 2Erfcinv(NaN) &#x3D; NaNfunc Erfinv ¶added in go1.10func Erfinv(x float64) float64Erfinv returns the inverse error function of x.\nSpecial cases are:\nErfinv(1) &#x3D; +InfErfinv(-1) &#x3D; -InfErfinv(x) &#x3D; NaN if x &lt; -1 or x &gt; 1Erfinv(NaN) &#x3D; NaNfunc Exp ¶func Exp(x float64) float64Exp returns e**x, the base-e exponential of x.\nSpecial cases are:\nExp(+Inf) &#x3D; +InfExp(NaN) &#x3D; NaNVery large values overflow to 0 or +Inf. Very small values underflow to 1.\nExample ¶func Exp2 ¶func Exp2(x float64) float64Exp2 returns 2**x, the base-2 exponential of x.\nSpecial cases are the same as Exp.\nExample ¶func Expm1 ¶func Expm1(x float64) float64Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than Exp(x) - 1 when x is near zero.\nSpecial cases are:\nExpm1(+Inf) &#x3D; +InfExpm1(-Inf) &#x3D; -1Expm1(NaN) &#x3D; NaNVery large values overflow to -1 or +Inf.\nExample ¶func FMA ¶added in go1.14func FMA(x, y, z float64) float64FMA returns x * y + z, computed with only one rounding. (That is, FMA returns the fused multiply-add of x, y, and z.)\nfunc Float32bits ¶func Float32bits(f float32) uint32Float32bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position. Float32bits(Float32frombits(x)) &#x3D;&#x3D; x.\nfunc Float32frombits ¶func Float32frombits(b uint32) float32Float32frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float32frombits(Float32bits(x)) &#x3D;&#x3D; x.\nfunc Float64bits ¶func Float64bits(f float64) uint64Float64bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position, and Float64bits(Float64frombits(x)) &#x3D;&#x3D; x.\nfunc Float64frombits ¶func Float64frombits(b uint64) float64Float64frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float64frombits(Float64bits(x)) &#x3D;&#x3D; x.\nfunc Floor ¶func Floor(x float64) float64Floor returns the greatest integer value less than or equal to x.\nSpecial cases are:\nFloor(±0) &#x3D; ±0Floor(±Inf) &#x3D; ±InfFloor(NaN) &#x3D; NaNExample ¶func Frexp ¶func Frexp(f float64) (frac float64, exp int)Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f &#x3D;&#x3D; frac × 2**exp, with the absolute value of frac in the interval [½, 1).\nSpecial cases are:\nFrexp(±0) &#x3D; ±0, 0Frexp(±Inf) &#x3D; ±Inf, 0Frexp(NaN) &#x3D; NaN, 0func Gamma ¶func Gamma(x float64) float64Gamma returns the Gamma function of x.\nSpecial cases are:\nGamma(+Inf) &#x3D; +InfGamma(+0) &#x3D; +InfGamma(-0) &#x3D; -InfGamma(x) &#x3D; NaN for integer x &lt; 0Gamma(-Inf) &#x3D; NaNGamma(NaN) &#x3D; NaNfunc Hypot ¶func Hypot(p, q float64) float64Hypot returns Sqrt(pp + qq), taking care to avoid unnecessary overflow and underflow.\nSpecial cases are:\nHypot(±Inf, q) &#x3D; +InfHypot(p, ±Inf) &#x3D; +InfHypot(NaN, q) &#x3D; NaNHypot(p, NaN) &#x3D; NaNfunc Ilogb ¶func Ilogb(x float64) intIlogb returns the binary exponent of x as an integer.\nSpecial cases are:\nIlogb(±Inf) &#x3D; MaxInt32Ilogb(0) &#x3D; MinInt32Ilogb(NaN) &#x3D; MaxInt32func Inf ¶func Inf(sign int) float64Inf returns positive infinity if sign &gt;&#x3D; 0, negative infinity if sign &lt; 0.\nfunc IsInf ¶func IsInf(f float64, sign int) boolIsInf reports whether f is an infinity, according to sign. If sign &gt; 0, IsInf reports whether f is positive infinity. If sign &lt; 0, IsInf reports whether f is negative infinity. If sign &#x3D;&#x3D; 0, IsInf reports whether f is either infinity.\nfunc IsNaN ¶func IsNaN(f float64) (is bool)IsNaN reports whether f is an IEEE 754 “not-a-number” value.\nfunc J0 ¶func J0(x float64) float64J0 returns the order-zero Bessel function of the first kind.\nSpecial cases are:\nJ0(±Inf) &#x3D; 0J0(0) &#x3D; 1J0(NaN) &#x3D; NaNfunc J1 ¶func J1(x float64) float64J1 returns the order-one Bessel function of the first kind.\nSpecial cases are:\nJ1(±Inf) &#x3D; 0J1(NaN) &#x3D; NaNfunc Jn ¶func Jn(n int, x float64) float64Jn returns the order-n Bessel function of the first kind.\nSpecial cases are:\nJn(n, ±Inf) &#x3D; 0Jn(n, NaN) &#x3D; NaNfunc Ldexp ¶func Ldexp(frac float64, exp int) float64Ldexp is the inverse of Frexp. It returns frac × 2**exp.\nSpecial cases are:\nLdexp(±0, exp) &#x3D; ±0Ldexp(±Inf, exp) &#x3D; ±InfLdexp(NaN, exp) &#x3D; NaNfunc Lgamma ¶func Lgamma(x float64) (lgamma float64, sign int)Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\nSpecial cases are:\nLgamma(+Inf) &#x3D; +InfLgamma(0) &#x3D; +InfLgamma(-integer) &#x3D; +InfLgamma(-Inf) &#x3D; -InfLgamma(NaN) &#x3D; NaNfunc Log ¶func Log(x float64) float64Log returns the natural logarithm of x.\nSpecial cases are:\nLog(+Inf) &#x3D; +InfLog(0) &#x3D; -InfLog(x &lt; 0) &#x3D; NaNLog(NaN) &#x3D; NaNExample ¶func Log10 ¶func Log10(x float64) float64Log10 returns the decimal logarithm of x. The special cases are the same as for Log.\nExample ¶func Log1p ¶func Log1p(x float64) float64Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.\nSpecial cases are:\nLog1p(+Inf) &#x3D; +InfLog1p(±0) &#x3D; ±0Log1p(-1) &#x3D; -InfLog1p(x &lt; -1) &#x3D; NaNLog1p(NaN) &#x3D; NaNfunc Log2 ¶func Log2(x float64) float64Log2 returns the binary logarithm of x. The special cases are the same as for Log.\nExample ¶func Logb ¶func Logb(x float64) float64Logb returns the binary exponent of x.\nSpecial cases are:\nLogb(±Inf) &#x3D; +InfLogb(0) &#x3D; -InfLogb(NaN) &#x3D; NaNfunc Max ¶func Max(x, y float64) float64Max returns the larger of x or y.\nSpecial cases are:\nMax(x, +Inf) &#x3D; Max(+Inf, x) &#x3D; +InfMax(x, NaN) &#x3D; Max(NaN, x) &#x3D; NaNMax(+0, ±0) &#x3D; Max(±0, +0) &#x3D; +0Max(-0, -0) &#x3D; -0func Min ¶func Min(x, y float64) float64Min returns the smaller of x or y.\nSpecial cases are:\nMin(x, -Inf) &#x3D; Min(-Inf, x) &#x3D; -InfMin(x, NaN) &#x3D; Min(NaN, x) &#x3D; NaNMin(-0, ±0) &#x3D; Min(±0, -0) &#x3D; -0func Mod ¶func Mod(x, y float64) float64Mod returns the floating-point remainder of x&#x2F;y. The magnitude of the result is less than y and its sign agrees with that of x.\nSpecial cases are:\nMod(±Inf, y) &#x3D; NaNMod(NaN, y) &#x3D; NaNMod(x, 0) &#x3D; NaNMod(x, ±Inf) &#x3D; xMod(x, NaN) &#x3D; NaNExample ¶func Modf ¶func Modf(f float64) (int float64, frac float64)Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.\nSpecial cases are:\nModf(±Inf) &#x3D; ±Inf, NaNModf(NaN) &#x3D; NaN, NaNExample ¶func NaN ¶func NaN() float64NaN returns an IEEE 754 “not-a-number” value.\nfunc Nextafter ¶func Nextafter(x, y float64) (r float64)Nextafter returns the next representable float64 value after x towards y.\nSpecial cases are:\nNextafter(x, x)   &#x3D; xNextafter(NaN, y) &#x3D; NaNNextafter(x, NaN) &#x3D; NaNfunc Nextafter32 ¶added in go1.4func Nextafter32(x, y float32) (r float32)Nextafter32 returns the next representable float32 value after x towards y.\nSpecial cases are:\nNextafter32(x, x)   &#x3D; xNextafter32(NaN, y) &#x3D; NaNNextafter32(x, NaN) &#x3D; NaNfunc Pow ¶func Pow(x, y float64) float64Pow returns x**y, the base-x exponential of y.\nSpecial cases are (in order):\nPow(x, ±0) &#x3D; 1 for any xPow(1, y) &#x3D; 1 for any yPow(x, 1) &#x3D; x for any xPow(NaN, y) &#x3D; NaNPow(x, NaN) &#x3D; NaNPow(±0, y) &#x3D; ±Inf for y an odd integer &lt; 0Pow(±0, -Inf) &#x3D; +InfPow(±0, +Inf) &#x3D; +0Pow(±0, y) &#x3D; +Inf for finite y &lt; 0 and not an odd integerPow(±0, y) &#x3D; ±0 for y an odd integer &gt; 0Pow(±0, y) &#x3D; +0 for finite y &gt; 0 and not an odd integerPow(-1, ±Inf) &#x3D; 1Pow(x, +Inf) &#x3D; +Inf for |x| &gt; 1Pow(x, -Inf) &#x3D; +0 for |x| &gt; 1Pow(x, +Inf) &#x3D; +0 for |x| &lt; 1Pow(x, -Inf) &#x3D; +Inf for |x| &lt; 1Pow(+Inf, y) &#x3D; +Inf for y &gt; 0Pow(+Inf, y) &#x3D; +0 for y &lt; 0Pow(-Inf, y) &#x3D; Pow(-0, -y)Pow(x, y) &#x3D; NaN for finite x &lt; 0 and finite non-integer yExample ¶func Pow10 ¶func Pow10(n int) float64Pow10 returns 10**n, the base-10 exponential of n.\nSpecial cases are:\nPow10(n) &#x3D;    0 for n &lt; -323Pow10(n) &#x3D; +Inf for n &gt; 308Example ¶func Remainder ¶func Remainder(x, y float64) float64Remainder returns the IEEE 754 floating-point remainder of x&#x2F;y.\nSpecial cases are:\nRemainder(±Inf, y) &#x3D; NaNRemainder(NaN, y) &#x3D; NaNRemainder(x, 0) &#x3D; NaNRemainder(x, ±Inf) &#x3D; xRemainder(x, NaN) &#x3D; NaNExample ¶func Round ¶added in go1.10func Round(x float64) float64Round returns the nearest integer, rounding half away from zero.\nSpecial cases are:\nRound(±0) &#x3D; ±0Round(±Inf) &#x3D; ±InfRound(NaN) &#x3D; NaNExample ¶func RoundToEven ¶added in go1.10func RoundToEven(x float64) float64RoundToEven returns the nearest integer, rounding ties to even.\nSpecial cases are:\nRoundToEven(±0) &#x3D; ±0RoundToEven(±Inf) &#x3D; ±InfRoundToEven(NaN) &#x3D; NaNExample ¶func Signbit ¶func Signbit(x float64) boolSignbit reports whether x is negative or negative zero.\nfunc Sin ¶func Sin(x float64) float64Sin returns the sine of the radian argument x.\nSpecial cases are:\nSin(±0) &#x3D; ±0Sin(±Inf) &#x3D; NaNSin(NaN) &#x3D; NaNExample ¶func Sincos ¶func Sincos(x float64) (sin, cos float64)Sincos returns Sin(x), Cos(x).\nSpecial cases are:\nSincos(±0) &#x3D; ±0, 1Sincos(±Inf) &#x3D; NaN, NaNSincos(NaN) &#x3D; NaN, NaNExample ¶func Sinh ¶func Sinh(x float64) float64Sinh returns the hyperbolic sine of x.\nSpecial cases are:\nSinh(±0) &#x3D; ±0Sinh(±Inf) &#x3D; ±InfSinh(NaN) &#x3D; NaNExample ¶func Sqrt ¶func Sqrt(x float64) float64Sqrt returns the square root of x.\nSpecial cases are:\nSqrt(+Inf) &#x3D; +InfSqrt(±0) &#x3D; ±0Sqrt(x &lt; 0) &#x3D; NaNSqrt(NaN) &#x3D; NaNExample ¶func Tan ¶func Tan(x float64) float64Tan returns the tangent of the radian argument x.\nSpecial cases are:\nTan(±0) &#x3D; ±0Tan(±Inf) &#x3D; NaNTan(NaN) &#x3D; NaNExample ¶func Tanh ¶func Tanh(x float64) float64Tanh returns the hyperbolic tangent of x.\nSpecial cases are:\nTanh(±0) &#x3D; ±0Tanh(±Inf) &#x3D; ±1Tanh(NaN) &#x3D; NaNExample ¶func Trunc ¶func Trunc(x float64) float64Trunc returns the integer value of x.\nSpecial cases are:\nTrunc(±0) &#x3D; ±0Trunc(±Inf) &#x3D; ±InfTrunc(NaN) &#x3D; NaNExample ¶func Y0 ¶func Y0(x float64) float64Y0 returns the order-zero Bessel function of the second kind.\nSpecial cases are:\nY0(+Inf) &#x3D; 0Y0(0) &#x3D; -InfY0(x &lt; 0) &#x3D; NaNY0(NaN) &#x3D; NaNfunc Y1 ¶func Y1(x float64) float64Y1 returns the order-one Bessel function of the second kind.\nSpecial cases are:\nY1(+Inf) &#x3D; 0Y1(0) &#x3D; -InfY1(x &lt; 0) &#x3D; NaNY1(NaN) &#x3D; NaNfunc Yn ¶func Yn(n int, x float64) float64Yn returns the order-n Bessel function of the second kind.\nSpecial cases are:\nYn(n, +Inf) &#x3D; 0Yn(n ≥ 0, 0) &#x3D; -InfYn(n &lt; 0, 0) &#x3D; +Inf if n is odd, -Inf if n is evenYn(n, x &lt; 0) &#x3D; NaNYn(n, NaN) &#x3D; NaN\n9.1 big9.2 bits9.3 cmplx9.4 randOverview\nFunction\nfunc ExpFloat64() float64\nfunc Float32() float32\nfunc Float64() float64\nfunc Int() int\nfunc Int31() int32\nfunc Int31n(n int32) int32\nfunc Int63() int64\nfunc Int63n(n int64) int64\nfunc Intn(n int) int\nfunc NormFloat64() float64\nfunc Perm(n int) []int\nfunc Read(p []byte) (n int, err error)\nfunc Seed(seed int64)\nfunc Shuffle(n int, swap func(i, j int))\nfunc Uint32() uint32\nfunc Uint64() uint64\ntype Rand\nfunc New(src Source) *Rand\nfunc (r*Rand) ExpFloat64() float64\nfunc (r *Rand) Float32() float32\nfunc (r*Rand) Float64() float64\nfunc (r *Rand) Int() int\nfunc (r*Rand) Int31() int32\nfunc (r *Rand) Int31n(n int32) int32\nfunc (r*Rand) Int63() int64\nfunc (r *Rand) Int63n(n int64) int64\nfunc (r*Rand) Intn(n int) int\nfunc (r *Rand) NormFloat64() float64\nfunc (r*Rand) Perm(n int) []int\nfunc (r *Rand) Read(p []byte) (n int, err error)\nfunc (r*Rand) Seed(seed int64)\n  Seed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。\nfunc (r *Rand) Shuffle(n int, swap func(i, j int))\nfunc (r*Rand) Uint32() uint32\nfunc (r *Rand) Uint64() uint64\ntype Source\nfunc NewSource(seed int64) Source\n  NewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。\n  randomSource :&#x3D; NewSource(time.Now().UnixNano())\nrandSeed :&#x3D; New(randomSource) &#x2F;&#x2F;这时候就可以使用rand的method\nrandomInt :&#x3D; randSeed.Intn(300)&#x2F;&#x2F;[0,300)的整数\n\n\ntype Source64\n  Source64是一个也可以直接生成[0, 1&lt;&lt;64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。  Source64的结构\n  type Source64 interface &#123;\n    Source\n    Uint64() uint64\n&#125;\n\ntype Zipf\nfunc NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipf\nfunc (z *Zipf) Uint64() uint64\n","dateCreated":"2022-10-08T07:48:06+08:00","dateModified":"2022-11-06T21:55:29+08:00","datePublished":"2022-10-08T07:48:06+08:00","description":"\nsource link: https://pkg.go.dev/stdabstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.\n","headline":"go标准库阅读与解析","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://simonteo58.github.io/2022/10/08/golang/go_documentation/"},"publisher":{"@type":"Organization","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://simonteo58.github.io/2022/10/08/golang/go_documentation/","keywords":"golang"}</script>
    <meta name="description" content="source link: https:&#x2F;&#x2F;pkg.go.dev&#x2F;stdabstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.">
<meta property="og:type" content="blog">
<meta property="og:title" content="go标准库阅读与解析">
<meta property="og:url" content="https://simonteo58.github.io/2022/10/08/golang/go_documentation/index.html">
<meta property="og:site_name" content="CoffeeMan">
<meta property="og:description" content="source link: https:&#x2F;&#x2F;pkg.go.dev&#x2F;stdabstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-07T23:48:06.892Z">
<meta property="article:modified_time" content="2022-11-06T13:55:29.727Z">
<meta property="article:author" content="kirkzhang">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-y9io9e1ok9lpsmk4fyk7quzstdgr6eztu8x2xr6n9iikjgfjbcqqpobdlqy8.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CoffeeMan
        </a>
    </div>
    
        
            <a
                class="header-right-picture open-algolia-search"
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/SimonTeo58"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/11289672/simon-teo"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/shiming_kirk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/kirk-zhang-424935235/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/zxc741208584@qq.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            go标准库阅读与解析
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-10-08T07:48:06+08:00">
	
		    Oct 08, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>source link: <a target="_blank" rel="noopener" href="https://pkg.go.dev/std">https://pkg.go.dev/std</a><br>abstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</p>
</blockquote>
<span id="more"></span>
<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-archive"><span class="toc-text">1. archive</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-tar"><span class="toc-text">1.1 tar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-zip"><span class="toc-text">1.2 zip</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-bufio"><span class="toc-text">2. bufio</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-builtin"><span class="toc-text">3. builtin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-bytes"><span class="toc-text">4. bytes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-compress"><span class="toc-text">5. compress</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-bzip2"><span class="toc-text">5.1 bzip2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-gzip"><span class="toc-text">5.2 gzip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-lzw"><span class="toc-text">5.3 lzw</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-compress-x2F-zlib"><span class="toc-text">5.4 compress&#x2F;zlib</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-container"><span class="toc-text">6. container</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-container-x2F-heap"><span class="toc-text">6.1 container&#x2F;heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-container-x2F-list"><span class="toc-text">6.2 container&#x2F;list</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-os"><span class="toc-text">7. os</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-time"><span class="toc-text">8. time</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-math"><span class="toc-text">9. math</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-big"><span class="toc-text">9.1 big</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-bits"><span class="toc-text">9.2 bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-cmplx"><span class="toc-text">9.3 cmplx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-rand"><span class="toc-text">9.4 rand</span></a></li></ol></li></ol>

<h1 id="1-archive"><a href="#1-archive" class="headerlink" title="1. archive"></a>1. archive</h1><h2 id="1-1-tar"><a href="#1-1-tar" class="headerlink" title="1.1 tar"></a>1.1 tar</h2><p>  Package tar implements access to tar archives.</p>
<p>  Tape(封装,胶带) archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.</p>
<p><strong>Constants</strong></p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  &#x2F;&#x2F; Type &#39;0&#39; indicates a regular file.
  TypeReg  &#x3D; &#39;0&#39;
  TypeRegA &#x3D; &#39;\x00&#39; &#x2F;&#x2F; Deprecated: Use TypeReg instead.

  &#x2F;&#x2F; Type &#39;1&#39; to &#39;6&#39; are header-only flags and may not have a data body.
  TypeLink    &#x3D; &#39;1&#39; &#x2F;&#x2F; Hard link
  TypeSymlink &#x3D; &#39;2&#39; &#x2F;&#x2F; Symbolic link
  TypeChar    &#x3D; &#39;3&#39; &#x2F;&#x2F; Character device node
  TypeBlock   &#x3D; &#39;4&#39; &#x2F;&#x2F; Block device node
  TypeDir     &#x3D; &#39;5&#39; &#x2F;&#x2F; Directory
  TypeFifo    &#x3D; &#39;6&#39; &#x2F;&#x2F; FIFO node

  &#x2F;&#x2F; Type &#39;7&#39; is reserved.
  TypeCont &#x3D; &#39;7&#39;

  &#x2F;&#x2F; Type &#39;x&#39; is used by the PAX format to store key-value records that
  &#x2F;&#x2F; are only relevant to the next file.
  &#x2F;&#x2F; This package transparently handles these types.
  TypeXHeader &#x3D; &#39;x&#39;

  &#x2F;&#x2F; Type &#39;g&#39; is used by the PAX format to store key-value records that
  &#x2F;&#x2F; are relevant to all subsequent files.
  &#x2F;&#x2F; This package only supports parsing and composing such headers,
  &#x2F;&#x2F; but does not currently support persisting the global state across files.
  TypeXGlobalHeader &#x3D; &#39;g&#39;

  &#x2F;&#x2F; Type &#39;S&#39; indicates a sparse file in the GNU format.
  TypeGNUSparse &#x3D; &#39;S&#39;

  &#x2F;&#x2F; Types &#39;L&#39; and &#39;K&#39; are used by the GNU format for a meta file
  &#x2F;&#x2F; used to store the path or link name for the next file.
  &#x2F;&#x2F; This package transparently handles these types.
  TypeGNULongName &#x3D; &#39;L&#39;
  TypeGNULongLink &#x3D; &#39;K&#39;
)</code></pre>

<p><strong>Variables</strong></p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var (
  ErrHeader          &#x3D; errors.New(&quot;archive&#x2F;tar: invalid tar header&quot;)
  ErrWriteTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: write too long&quot;)
  ErrFieldTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: header field too long&quot;)
  ErrWriteAfterClose &#x3D; errors.New(&quot;archive&#x2F;tar: write after close&quot;)
)</code></pre>

<p>type Format</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">type Format int</code></pre>

<p>  Format represents the tar archive format.The original tar format was introduced in Unix V7. Since then, there have been multiple competing(相互竞争) formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the <strong>USTAR</strong>, <strong>PAX</strong>, and <strong>GNU</strong> formats, each with their own advantages and limitations.</p>
<p>  The following table captures the capabilities of each format:</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">                  |  USTAR |       PAX |       GNU
------------------+--------+-----------+----------
Name              |   256B | unlimited | unlimited
Linkname          |   100B | unlimited | unlimited
Size              | uint33 | unlimited |    uint89
Mode              | uint21 |    uint21 |    uint57
Uid&#x2F;Gid           | uint21 | unlimited |    uint57
Uname&#x2F;Gname       |    32B | unlimited |       32B
ModTime           | uint33 | unlimited |     int89
AccessTime        |    n&#x2F;a | unlimited |     int89
ChangeTime        |    n&#x2F;a | unlimited |     int89
Devmajor&#x2F;Devminor | uint21 |    uint21 |    uint57
------------------+--------+-----------+----------
string encoding   |  ASCII |     UTF-8 |    binary
sub-second times  |     no |       yes |        no
sparse files      |     no |       yes |       yes</code></pre>

<p>  The table’s upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</p>
<p>  The table’s lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</p>
<p>  The Writer currently provides no support for sparse files.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">const (

&#x2F;&#x2F; FormatUnknown indicates that the format is unknown.
FormatUnknown Format
&#x2F;&#x2F; FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.
&#x2F;&#x2F;
&#x2F;&#x2F; While this format is compatible with most tar readers,
&#x2F;&#x2F; the format has several limitations making it unsuitable for some usages.
&#x2F;&#x2F; Most notably, it cannot support sparse files, files larger than 8GiB,
&#x2F;&#x2F; filenames larger than 256 characters, and non-ASCII filenames.
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;pax.html#tag_20_92_13_06
FormatUSTAR
&#x2F;&#x2F; FormatPAX represents the PAX header format defined in POSIX.1-2001.
&#x2F;&#x2F;
&#x2F;&#x2F; PAX extends USTAR by writing a special file with Typeflag TypeXHeader
&#x2F;&#x2F; preceding the original header. This file contains a set of key-value
&#x2F;&#x2F; records, which are used to overcome USTAR\&#39;s shortcomings, in addition to
&#x2F;&#x2F; providing the ability to have sub-second resolution for timestamps.
&#x2F;&#x2F;
&#x2F;&#x2F; Some newer formats add their own extensions to PAX by defining their
&#x2F;&#x2F; own keys and assigning certain semantic meaning to the associated values.
&#x2F;&#x2F; For example, sparse file support in PAX is implemented using keys
&#x2F;&#x2F; defined by the GNU manual (e.g., &quot;GNU.sparse.map&quot;).
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;utilities&#x2F;pax.html
FormatPAX
&#x2F;&#x2F; FormatGNU represents the GNU header format.
&#x2F;&#x2F;
&#x2F;&#x2F; The GNU header format is older than the USTAR and PAX standards and
&#x2F;&#x2F; is not compatible with them. The GNU format supports
&#x2F;&#x2F; arbitrary file sizes, filenames of arbitrary encoding and length,
&#x2F;&#x2F; sparse files, and other features.
&#x2F;&#x2F;
&#x2F;&#x2F; It is recommended that PAX be chosen over GNU unless the target
&#x2F;&#x2F; application can only parse GNU formatted archives.
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;tar&#x2F;manual&#x2F;html_node&#x2F;Standard.html
FormatGNU
)
</code></pre>

<p>func (f Format) String() string</p>
<p>  打印tar的格式</p>
<p>type Header</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">  type Header struct &#123;
  &#x2F;&#x2F; Typeflag is the type of header entry.
  &#x2F;&#x2F; The zero value is automatically promoted to either TypeReg or TypeDir
  &#x2F;&#x2F; depending on the presence of a trailing slash in Name.
  Typeflag byte

  Name     string &#x2F;&#x2F; Name of file entry
  Linkname string &#x2F;&#x2F; Target name of link (valid for TypeLink or TypeSymlink)

  Size  int64  &#x2F;&#x2F; Logical file size in bytes
  Mode  int64  &#x2F;&#x2F; Permission and mode bits
  Uid   int    &#x2F;&#x2F; User ID of owner
  Gid   int    &#x2F;&#x2F; Group ID of owner
  Uname string &#x2F;&#x2F; User name of owner
  Gname string &#x2F;&#x2F; Group name of owner

  &#x2F;&#x2F; If the Format is unspecified, then Writer.WriteHeader rounds ModTime
  &#x2F;&#x2F; to the nearest second and ignores the AccessTime and ChangeTime fields.
  &#x2F;&#x2F;
  &#x2F;&#x2F; To use AccessTime or ChangeTime, specify the Format as PAX or GNU.
  &#x2F;&#x2F; To use sub-second resolution, specify the Format as PAX.
  ModTime    time.Time &#x2F;&#x2F; Modification time
  AccessTime time.Time &#x2F;&#x2F; Access time (requires either PAX or GNU support)
  ChangeTime time.Time &#x2F;&#x2F; Change time (requires either PAX or GNU support)

  Devmajor int64 &#x2F;&#x2F; Major device number (valid for TypeChar or TypeBlock)
  Devminor int64 &#x2F;&#x2F; Minor device number (valid for TypeChar or TypeBlock)

  &#x2F;&#x2F; Xattrs stores extended attributes as PAX records under the
  &#x2F;&#x2F; &quot;SCHILY.xattr.&quot; namespace.
  &#x2F;&#x2F;
  &#x2F;&#x2F; The following are semantically equivalent:
  &#x2F;&#x2F;  h.Xattrs[key] &#x3D; value
  &#x2F;&#x2F;  h.PAXRecords[&quot;SCHILY.xattr.&quot;+key] &#x3D; value
  &#x2F;&#x2F;
  &#x2F;&#x2F; When Writer.WriteHeader is called, the contents of Xattrs will take
  &#x2F;&#x2F; precedence over those in PAXRecords.
  &#x2F;&#x2F;
  &#x2F;&#x2F; Deprecated: Use PAXRecords instead.
  Xattrs map[string]string

  &#x2F;&#x2F; PAXRecords is a map of PAX extended header records.
  &#x2F;&#x2F;
  &#x2F;&#x2F; User-defined records should have keys of the following form:
  &#x2F;&#x2F;	VENDOR.keyword
  &#x2F;&#x2F; Where VENDOR is some namespace in all uppercase, and keyword may
  &#x2F;&#x2F; not contain the &#39;&#x3D;&#39; character (e.g., &quot;GOLANG.pkg.version&quot;).
  &#x2F;&#x2F; The key and value should be non-empty UTF-8 strings.
  &#x2F;&#x2F;
  &#x2F;&#x2F; When Writer.WriteHeader is called, PAX records derived from the
  &#x2F;&#x2F; other fields in Header take precedence over PAXRecords.
  PAXRecords map[string]string

  &#x2F;&#x2F; Format specifies the format of the tar header.
  &#x2F;&#x2F;
  &#x2F;&#x2F; This is set by Reader.Next as a best-effort guess at the format.
  &#x2F;&#x2F; Since the Reader liberally reads some non-compliant files,
  &#x2F;&#x2F; it is possible for this to be FormatUnknown.
  &#x2F;&#x2F;
  &#x2F;&#x2F; If the format is unspecified when Writer.WriteHeader is called,
  &#x2F;&#x2F; then it uses the first format (in the order of USTAR, PAX, GNU)
  &#x2F;&#x2F; capable of encoding this Header (see Format).
  Format Format
&#125;
</code></pre>

<p>func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)</p>
<p>func (h*Header) FileInfo() fs.FileInfo</p>
<p>type Reader</p>
<p>func NewReader(r io.Reader) *Reader</p>
<p>func (tr*Reader) Next() (*Header, error)</p>
<p>func (tr*Reader) Read(b []byte) (int, error)</p>
<p>type Writer</p>
<p>func NewWriter(w io.Writer) *Writer</p>
<p>func (tw*Writer) Close() error</p>
<p>func (tw *Writer) Flush() error</p>
<p>func (tw*Writer) Write(b []byte) (int, error)</p>
<p>func (tw <em>Writer) WriteHeader(hdr</em>Header) error</p>
<h2 id="1-2-zip"><a href="#1-2-zip" class="headerlink" title="1.2 zip"></a>1.2 zip</h2><p>Package zip provides support for reading and writing ZIP archives.</p>
<p><strong>Constants</strong></p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  Store   uint16 &#x3D; 0 &#x2F;&#x2F; no compression
  Deflate uint16 &#x3D; 8 &#x2F;&#x2F; DEFLATE compressed
)</code></pre>

<p><strong>Variables</strong></p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var (
  ErrFormat    &#x3D; errors.New(&quot;zip: not a valid zip file&quot;)
  ErrAlgorithm &#x3D; errors.New(&quot;zip: unsupported compression algorithm&quot;)
  ErrChecksum  &#x3D; errors.New(&quot;zip: checksum error&quot;)
)
</code></pre>

<p>func RegisterCompressor(method uint16, comp Compressor)</p>
<p>func RegisterDecompressor(method uint16, dcomp Decompressor)</p>
<p>type Compressor</p>
<p>type Decompressor</p>
<p>type File</p>
<p>func (f *File) DataOffset() (offset int64, err error)</p>
<p>func (f*File) Open() (io.ReadCloser, error)</p>
<p>func (f *File) OpenRaw() (io.Reader, error)</p>
<p>type FileHeader</p>
<p>func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</p>
<p>func (h *FileHeader) FileInfo() fs.FileInfo</p>
<p>func (h*FileHeader) ModTime() time.TimeDEPRECATED</p>
<p>func (h *FileHeader) Mode() (mode fs.FileMode)</p>
<p>func (h*FileHeader) SetModTime(t time.Time)DEPRECATED</p>
<p>func (h *FileHeader) SetMode(mode fs.FileMode)</p>
<p>type ReadCloser</p>
<p>func OpenReader(name string) (*ReadCloser, error)</p>
<p>func (rc *ReadCloser) Close() error</p>
<p>type Reader</p>
<p>func NewReader(r io.ReaderAt, size int64) (*Reader, error)</p>
<p>func (r *Reader) Open(name string) (fs.File, error)</p>
<p>func (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</p>
<p>type Writer</p>
<p>func NewWriter(w io.Writer) *Writer</p>
<p>func (w*Writer) Close() error</p>
<p>func (w *Writer) Copy(f*File) error</p>
<p>func (w *Writer) Create(name string) (io.Writer, error)</p>
<p>func (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)</p>
<p>func (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)</p>
<p>func (w*Writer) Flush() error</p>
<p>func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</p>
<p>func (w*Writer) SetComment(comment string) error</p>
<p>func (w *Writer) SetOffset(n int64)</p>
<h1 id="2-bufio"><a href="#2-bufio" class="headerlink" title="2. bufio"></a>2. bufio</h1><p>Package bufio implements buffered I&#x2F;O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual(adj.本文的,按原文的) I&#x2F;O.</p>
<p><strong>Constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	&#x2F;&#x2F; MaxScanTokenSize is the maximum size used to buffer a token
	&#x2F;&#x2F; unless the user provides an explicit buffer with Scanner.Buffer.
	&#x2F;&#x2F; The actual maximum token size may be smaller as the buffer
	&#x2F;&#x2F; may need to include, for instance, a newline.
	MaxScanTokenSize &#x3D; 64 * 1024
)</code></pre>
<p><strong>Variables</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var (
	ErrInvalidUnreadByte &#x3D; errors.New(&quot;bufio: invalid use of UnreadByte&quot;)
	ErrInvalidUnreadRune &#x3D; errors.New(&quot;bufio: invalid use of UnreadRune&quot;)
	ErrBufferFull        &#x3D; errors.New(&quot;bufio: buffer full&quot;)
	ErrNegativeCount     &#x3D; errors.New(&quot;bufio: negative count&quot;)
)
var (
	ErrTooLong         &#x3D; errors.New(&quot;bufio.Scanner: token too long&quot;)
	ErrNegativeAdvance &#x3D; errors.New(&quot;bufio.Scanner: SplitFunc returns negative advance count&quot;)
	ErrAdvanceTooFar   &#x3D; errors.New(&quot;bufio.Scanner: SplitFunc returns advance count beyond input&quot;)
	ErrBadReadCount    &#x3D; errors.New(&quot;bufio.Scanner: Read returned impossible count&quot;)
)
Errors returned by Scanner.
var ErrFinalToken &#x3D; errors.New(&quot;final token&quot;)
</code></pre>
<p><code>ErrFinalToken</code> is a special sentinel error value. It is intended to be returned by a Split(vt.分离) function to indicate that the token being delivered with the error is the last token and scanning should stop after this one. After ErrFinalToken is received by Scan, scanning stops with no error. The value is useful to stop processing early or when it is necessary to deliver a final empty token. One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value.</p>
<p>func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)<br>ScanBytes is a split function for a Scanner that returns each byte as a token.</p>
<p>func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)<br>func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)<br>func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</p>
<p>type ReadWriter</p>
<pre class="language-goalng" data-language="goalng"><code class="language-goalng">type ReadWriter struct &#123;
	*Reader
	*Writer
&#125;</code></pre>

<p>func NewReadWriter(r *Reader, w *Writer) *ReadWriter<br>type Reader</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Reader struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<p>func NewReader(rd io.Reader) *Reader<br>func NewReaderSize(rd io.Reader, size int) *Reader<br>func (b *Reader) Buffered() int<br>func (b *Reader) Discard(n int) (discarded int, err error)<br>func (b *Reader) Peek(n int) ([]byte, error)<br>func (b *Reader) Read(p []byte) (n int, err error)<br>func (b *Reader) ReadByte() (byte, error)<br>func (b *Reader) ReadBytes(delim byte) ([]byte, error)<br>func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)<br>func (b *Reader) ReadRune() (r rune, size int, err error)<br>func (b *Reader) ReadSlice(delim byte) (line []byte, err error)<br>func (b *Reader) ReadString(delim byte) (string, error)<br>func (b *Reader) Reset(r io.Reader)<br>func (b *Reader) Size() int<br>func (b *Reader) UnreadByte() error<br>func (b *Reader) UnreadRune() error<br>func (b *Reader) WriteTo(w io.Writer) (n int64, err error)<br>type Scanner</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Scanner struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<p>func NewScanner(r io.Reader) *Scanner<br>func (s *Scanner) Buffer(buf []byte, max int)<br>func (s *Scanner) Bytes() []byte<br>func (s *Scanner) Err() error<br>func (s *Scanner) Scan() bool<br>func (s *Scanner) Split(split SplitFunc)<br>func (s *Scanner) Text() string<br>type SplitFunc</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
</code></pre>
<p>type Writer</p>
<pre class="language-golng" data-language="golng"><code class="language-golng">type Writer struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>

<p>func NewWriter(w io.Writer) *Writer<br>func NewWriterSize(w io.Writer, size int) *Writer<br>func (b *Writer) Available() int<br>func (b *Writer) AvailableBuffer() []byte<br>func (b *Writer) Buffered() int<br>func (b *Writer) Flush() error<br>func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)<br>func (b *Writer) Reset(w io.Writer)<br>func (b *Writer) Size() int<br>func (b *Writer) Write(p []byte) (nn int, err error)<br>func (b *Writer) WriteByte(c byte) error<br>func (b *Writer) WriteRune(r rune) (size int, err error)<br>func (b *Writer) WriteString(s string) (int, error)</p>
<h1 id="3-builtin"><a href="#3-builtin" class="headerlink" title="3. builtin"></a>3. builtin</h1><p>Package builtin provides documentation for Go’s predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language’s special identifiers.</p>
<p><strong>Constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	true  &#x3D; 0 &#x3D;&#x3D; 0 &#x2F;&#x2F; Untyped bool.
	false &#x3D; 0 !&#x3D; 0 &#x2F;&#x2F; Untyped bool.
)
const iota &#x3D; 0 &#x2F;&#x2F; Untyped int.</code></pre>

<p><strong>variables</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var nil Type &#x2F;&#x2F; Type must be a pointer, channel, func, interface, map, or slice type</code></pre>

<p>func append(slice []Type, elems …Type) []Type<br>func cap(v Type) int<br>func close(c chan&lt;- Type)<br>func complex(r, i FloatType) ComplexType<br>func copy(dst, src []Type) int<br>func delete(m map[Type]Type1, key Type)<br>func imag(c ComplexType) FloatType<br>func len(v Type) int<br>func make(t Type, size …IntegerType) Type<br>func new(Type) *Type<br>func panic(v any)<br>func print(args …Type)<br>func println(args …Type)<br>func real(c ComplexType) FloatType<br>func recover() any</p>
<p>type ComplexType<br>type FloatType<br>type IntegerType<br>type Type<br>type Type1<br>type any<br>type bool<br>type byte<br>type comparable<br>type complex128<br>type complex64<br>type error<br>type float32<br>type float64<br>type int<br>type int16<br>type int32<br>type int64<br>type int8<br>type rune<br>type string<br>type uint<br>type uint16<br>type uint32<br>type uint64<br>type uint8<br>type uintptr</p>
<h1 id="4-bytes"><a href="#4-bytes" class="headerlink" title="4. bytes"></a>4. bytes</h1><p>Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.</p>
<p><strong>constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const MinRead &#x3D; 512</code></pre>

<p><strong>variables</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var ErrTooLarge &#x3D; errors.New(&quot;bytes.Buffer: too large&quot;)
</code></pre>
<p>func Compare(a, b []byte) int<br>func Contains(b, subslice []byte) bool<br>func ContainsAny(b []byte, chars string) bool<br>func ContainsRune(b []byte, r rune) bool<br>func Count(s, sep []byte) int<br>func Cut(s, sep []byte) (before, after []byte, found bool)<br>func Equal(a, b []byte) bool<br>func EqualFold(s, t []byte) bool<br>func Fields(s []byte) [][]byte<br>func FieldsFunc(s []byte, f func(rune) bool) [][]byte<br>func HasPrefix(s, prefix []byte) bool<br>func HasSuffix(s, suffix []byte) bool<br>func Index(s, sep []byte) int<br>func IndexAny(s []byte, chars string) int<br>func IndexByte(b []byte, c byte) int<br>func IndexFunc(s []byte, f func(r rune) bool) int<br>func IndexRune(s []byte, r rune) int<br>func Join(s [][]byte, sep []byte) []byte<br>func LastIndex(s, sep []byte) int<br>func LastIndexAny(s []byte, chars string) int<br>func LastIndexByte(s []byte, c byte) int<br>func LastIndexFunc(s []byte, f func(r rune) bool) int<br>func Map(mapping func(r rune) rune, s []byte) []byte<br>func Repeat(b []byte, count int) []byte<br>func Replace(s, old, new []byte, n int) []byte<br>func ReplaceAll(s, old, new []byte) []byte<br>func Runes(s []byte) []rune<br>func Split(s, sep []byte) [][]byte<br>func SplitAfter(s, sep []byte) [][]byte<br>func SplitAfterN(s, sep []byte, n int) [][]byte<br>func SplitN(s, sep []byte, n int) [][]byte<br>func Title(s []byte) []byteDEPRECATED<br>func ToLower(s []byte) []byte<br>func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte<br>func ToTitle(s []byte) []byte<br>func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte<br>func ToUpper(s []byte) []byte<br>func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte<br>func ToValidUTF8(s, replacement []byte) []byte<br>func Trim(s []byte, cutset string) []byte<br>func TrimFunc(s []byte, f func(r rune) bool) []byte<br>func TrimLeft(s []byte, cutset string) []byte<br>func TrimLeftFunc(s []byte, f func(r rune) bool) []byte<br>func TrimPrefix(s, prefix []byte) []byte<br>func TrimRight(s []byte, cutset string) []byte<br>func TrimRightFunc(s []byte, f func(r rune) bool) []byte<br>func TrimSpace(s []byte) []byte<br>func TrimSuffix(s, suffix []byte) []byte</p>
<p>type Buffer</p>
<p>func NewBuffer(buf []byte) *Buffer<br>func NewBufferString(s string) *Buffer<br>func (b *Buffer) Bytes() []byte<br>func (b *Buffer) Cap() int<br>func (b *Buffer) Grow(n int)<br>func (b *Buffer) Len() int<br>func (b *Buffer) Next(n int) []byte<br>func (b *Buffer) Read(p []byte) (n int, err error)<br>func (b *Buffer) ReadByte() (byte, error)<br>func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)<br>func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)<br>func (b *Buffer) ReadRune() (r rune, size int, err error)<br>func (b *Buffer) ReadString(delim byte) (line string, err error)<br>func (b *Buffer) Reset()<br>func (b *Buffer) String() string<br>func (b *Buffer) Truncate(n int)<br>func (b *Buffer) UnreadByte() error<br>func (b *Buffer) UnreadRune() error<br>func (b *Buffer) Write(p []byte) (n int, err error)<br>func (b *Buffer) WriteByte(c byte) error<br>func (b *Buffer) WriteRune(r rune) (n int, err error)<br>func (b *Buffer) WriteString(s string) (n int, err error)<br>func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)<br>type Reader<br>func NewReader(b []byte) *Reader<br>func (r *Reader) Len() int<br>func (r *Reader) Read(b []byte) (n int, err error)<br>func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)<br>func (r *Reader) ReadByte() (byte, error)<br>func (r *Reader) ReadRune() (ch rune, size int, err error)<br>func (r *Reader) Reset(b []byte)<br>func (r *Reader) Seek(offset int64, whence int) (int64, error)<br>func (r *Reader) Size() int64<br>func (r *Reader) UnreadByte() error<br>func (r *Reader) UnreadRune() error<br>func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</p>
<h1 id="5-compress"><a href="#5-compress" class="headerlink" title="5. compress"></a>5. compress</h1><h2 id="5-1-bzip2"><a href="#5-1-bzip2" class="headerlink" title="5.1 bzip2"></a>5.1 bzip2</h2><p>Package bzip2 implements bzip2 decompression.</p>
<p>func NewReader(r io.Reader) io.Reader<br>type StructuralError<br>func (s StructuralError) Error() string</p>
<p>flate<br>Package flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats.</p>
<p><strong>Constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	NoCompression      &#x3D; 0
	BestSpeed          &#x3D; 1
	BestCompression    &#x3D; 9
	DefaultCompression &#x3D; -1

	&#x2F;&#x2F; HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman
	&#x2F;&#x2F; entropy encoding. This mode is useful in compressing data that has
	&#x2F;&#x2F; already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)
	&#x2F;&#x2F; that lacks an entropy encoder. Compression gains are achieved when
	&#x2F;&#x2F; certain bytes in the input stream occur more frequently than others.
	&#x2F;&#x2F;
	&#x2F;&#x2F; Note that HuffmanOnly produces a compressed output that is
	&#x2F;&#x2F; RFC 1951 compliant. That is, any valid DEFLATE decompressor will
	&#x2F;&#x2F; continue to be able to decompress this output.
	HuffmanOnly &#x3D; -2
)</code></pre>
<p>func NewReader(r io.Reader) io.ReadCloser<br>func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser<br>type CorruptInputError<br>#func (e CorruptInputError) Error() string<br>type InternalError<br>#func (e InternalError) Error() string<br>type ReadErrorDEPRECATED<br>#func (e *ReadError) Error() string<br>type Reader<br>type Resetter<br>type WriteErrorDEPRECATED<br>#func (e *WriteError) Error() string<br>type Writer<br>func NewWriter(w io.Writer, level int) (*Writer, error)<br>func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)<br>#func (w *Writer) Close() error<br>#func (w *Writer) Flush() error<br>#func (w *Writer) Reset(dst io.Writer)<br>#func (w *Writer) Write(data []byte) (n int, err error)</p>
<h2 id="5-2-gzip"><a href="#5-2-gzip" class="headerlink" title="5.2 gzip"></a>5.2 gzip</h2><p>Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.</p>
<p><strong>Constants</strong></p>
<pre class="language-none"><code class="language-none">const (
	NoCompression      &#x3D; flate.NoCompression
	BestSpeed          &#x3D; flate.BestSpeed
	BestCompression    &#x3D; flate.BestCompression
	DefaultCompression &#x3D; flate.DefaultCompression
	HuffmanOnly        &#x3D; flate.HuffmanOnly
)</code></pre>
<p>These constants are copied from the flate package, so that code that imports “compress&#x2F;gzip” does not also have to import “compress&#x2F;flate”.</p>
<p><strong>Variables</strong></p>
<pre class="language-none"><code class="language-none">var (
	&#x2F;&#x2F; ErrChecksum is returned when reading GZIP data that has an invalid checksum.
	ErrChecksum &#x3D; errors.New(&quot;gzip: invalid checksum&quot;)
	&#x2F;&#x2F; ErrHeader is returned when reading GZIP data that has an invalid header.
	ErrHeader &#x3D; errors.New(&quot;gzip: invalid header&quot;)
)</code></pre>
<p>type Header</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Header struct &#123;
	Comment string    &#x2F;&#x2F; comment
	Extra   []byte    &#x2F;&#x2F; &quot;extra data&quot;
	ModTime time.Time &#x2F;&#x2F; modification time
	Name    string    &#x2F;&#x2F; file name
	OS      byte      &#x2F;&#x2F; operating system type
&#125;</code></pre>
<p>type Reader</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Reader struct &#123;
	Header &#x2F;&#x2F; valid after NewReader or Reader.Reset
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<p>func NewReader(r io.Reader) (*Reader, error)<br>#func (z *Reader) Close() error<br>#func (z *Reader) Multistream(ok bool)<br>#func (z *Reader) Read(p []byte) (n int, err error)<br>#func (z *Reader) Reset(r io.Reader) error<br>type Writer</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Writer struct &#123;
	Header &#x2F;&#x2F; written at first call to Write, Flush, or Close
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;
</code></pre>
<p>func NewWriter(w io.Writer) *Writer<br>func NewWriterLevel(w io.Writer, level int) (*Writer, error)<br>#func (z *Writer) Close() error<br>#func (z *Writer) Flush() error<br>#func (z *Writer) Reset(w io.Writer)<br>#func (z *Writer) Write(p []byte) (int, error)</p>
<h2 id="5-3-lzw"><a href="#5-3-lzw" class="headerlink" title="5.3 lzw"></a>5.3 lzw</h2><p>Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19.</p>
<p>In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.</p>
<p>The TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org&#x2F;x&#x2F;image&#x2F;tiff&#x2F;lzw package for an implementation.</p>
<p>func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser<br>func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser<br>type Order</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Order int</code></pre>
<p>type Reader</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Reader struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<p>#func (r *Reader) Close() error<br>#func (r *Reader) Read(b []byte) (int, error)<br>#func (r *Reader) Reset(src io.Reader, order Order, litWidth int)<br>type Writer</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Writer struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>


<p>#func (w *Writer) Close() error<br>#func (w *Writer) Reset(dst io.Writer, order Order, litWidth int)<br>#func (w *Writer) Write(p []byte) (n int, err error)</p>
<h2 id="5-4-compress-x2F-zlib"><a href="#5-4-compress-x2F-zlib" class="headerlink" title="5.4 compress&#x2F;zlib"></a>5.4 compress&#x2F;zlib</h2><p><strong>Overview</strong><br>Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.</p>
<p>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var b bytes.Buffer
w :&#x3D; zlib.NewWriter(&amp;b)
w.Write([]byte(&quot;hello, world\n&quot;))
w.Close()</code></pre>
<p>and to read that data back:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">r, err :&#x3D; zlib.NewReader(&amp;b)
io.Copy(os.Stdout, r)
r.Close()</code></pre>
<p><strong>Constants</strong><br><strong>Variables</strong><br>func NewReader(r io.Reader) (io.ReadCloser, error)<br>func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)<br>type Resetter</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Resetter interface &#123;
	&#x2F;&#x2F; Reset discards any buffered data and resets the Resetter as if it was
	&#x2F;&#x2F; newly initialized with the given reader.
	Reset(r io.Reader, dict []byte) error
&#125;</code></pre>
<p>type Writer</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Writer struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<p>func NewWriter(w io.Writer) *Writer<br>func NewWriterLevel(w io.Writer, level int) (*Writer, error)<br>func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)<br>#func (z *Writer) Close() error<br>#func (z *Writer) Flush() error<br>#func (z *Writer) Reset(w io.Writer)<br>#func (z *Writer) Write(p []byte) (n int, err error)</p>
<h1 id="6-container"><a href="#6-container" class="headerlink" title="6. container"></a>6. container</h1><h2 id="6-1-container-x2F-heap"><a href="#6-1-container-x2F-heap" class="headerlink" title="6.1 container&#x2F;heap"></a>6.1 container&#x2F;heap</h2><p><strong>Overview</strong><br>Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.</p>
<p>The minimum element in the tree is the root, at index 0.</p>
<p>A heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source.</p>
<p>func Fix(h Interface, i int)<br>func Init(h Interface)<br>func Pop(h Interface) any<br>func Push(h Interface, x any)<br>func Remove(h Interface, i int) any<br>type Interface</p>
<h2 id="6-2-container-x2F-list"><a href="#6-2-container-x2F-list" class="headerlink" title="6.2 container&#x2F;list"></a>6.2 container&#x2F;list</h2><p><strong>Overview</strong><br>Package list implements a doubly linked list.</p>
<p>To iterate over a list (where l is a *List):</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">for e :&#x3D; l.Front(); e !&#x3D; nil; e &#x3D; e.Next() &#123;
	&#x2F;&#x2F; do something with e.Value
&#125;
</code></pre>

<p>type Element<br>func (e *Element) Next() *Element<br>func (e *Element) Prev() *Element<br>type List<br>func New() *List<br>func (l *List) Back() *Element<br>func (l *List) Front() *Element<br>func (l *List) Init() *List<br>func (l *List) InsertAfter(v any, mark *Element) *Element<br>func (l *List) InsertBefore(v any, mark *Element) *Element<br>func (l *List) Len() int<br>func (l *List) MoveAfter(e, mark *Element)<br>func (l *List) MoveBefore(e, mark *Element)<br>func (l *List) MoveToBack(e *Element)<br>func (l *List) MoveToFront(e *Element)<br>func (l *List) PushBack(v any) *Element<br>func (l *List) PushBackList(other *List)<br>func (l *List) PushFront(v any) *Element<br>func (l *List) PushFrontList(other *List)<br>func (l *List) Remove(e *Element) any</p>
<h1 id="7-os"><a href="#7-os" class="headerlink" title="7. os"></a>7. os</h1><p><strong>overview</strong><br>Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information.</p>
<p>The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.</p>
<p>Here is a simple example, opening a file and reading some of it.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">file, err :&#x3D; os.Open(&quot;file.go&quot;) &#x2F;&#x2F; For read access.
if err !&#x3D; nil &#123;
	log.Fatal(err)
&#125;</code></pre>
<p>If the open fails, the error string will be self-explanatory, like</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">open file.go: no such file or directory</code></pre>
<p>The file’s data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">data :&#x3D; make([]byte, 100)
count, err :&#x3D; file.Read(data)
if err !&#x3D; nil &#123;
	log.Fatal(err)
&#125;
fmt.Printf(&quot;read %d bytes: %q\n&quot;, count, data[:count])</code></pre>
<p>Note: The maximum number of concurrent operations on a File may be limited by the OS or the system. The number should be high, but exceeding(adj.超越的) it may degrade(vt.贬低) performance or cause other issues.</p>
<p>summary:  </p>
<ol>
<li>failing calls return values of type error rather than error numbers.like above open file failed. and emit “open file.go: no such file or directory”</li>
<li>The maximum number of concurrent operations on a File may be limited by the OS or the system(not know the root cause and knowledge)</li>
</ol>
<p><strong>Constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	&#x2F;&#x2F; Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
	O_RDONLY int &#x3D; syscall.O_RDONLY &#x2F;&#x2F; open the file read-only.
	O_WRONLY int &#x3D; syscall.O_WRONLY &#x2F;&#x2F; open the file write-only.
	O_RDWR   int &#x3D; syscall.O_RDWR   &#x2F;&#x2F; open the file read-write.
	&#x2F;&#x2F; The remaining values may be or&#39;ed in to control behavior.
	O_APPEND int &#x3D; syscall.O_APPEND &#x2F;&#x2F; append data to the file when writing.
	O_CREATE int &#x3D; syscall.O_CREAT  &#x2F;&#x2F; create a new file if none exists.
	O_EXCL   int &#x3D; syscall.O_EXCL   &#x2F;&#x2F; used with O_CREATE, file must not exist.
	O_SYNC   int &#x3D; syscall.O_SYNC   &#x2F;&#x2F; open for synchronous I&#x2F;O.
	O_TRUNC  int &#x3D; syscall.O_TRUNC  &#x2F;&#x2F; truncate regular(adj. 定期的) writable file when opened.
)</code></pre>
<p>Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	SEEK_SET int &#x3D; 0 &#x2F;&#x2F; seek relative to the origin of the file
	SEEK_CUR int &#x3D; 1 &#x2F;&#x2F; seek relative to the current offset
	SEEK_END int &#x3D; 2 &#x2F;&#x2F; seek relative to the end
)</code></pre>
<p>Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	PathSeparator     &#x3D; &#39;&#x2F;&#39; &#x2F;&#x2F; OS-specific path separator
	PathListSeparator &#x3D; &#39;:&#39; &#x2F;&#x2F; OS-specific path list separator
)</code></pre>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	&#x2F;&#x2F; The single letters are the abbreviations
	&#x2F;&#x2F; used by the String method&#39;s formatting.
	ModeDir        &#x3D; fs.ModeDir        &#x2F;&#x2F; d: is a directory
	ModeAppend     &#x3D; fs.ModeAppend     &#x2F;&#x2F; a: append-only
	ModeExclusive  &#x3D; fs.ModeExclusive  &#x2F;&#x2F; l: exclusive use
	ModeTemporary  &#x3D; fs.ModeTemporary  &#x2F;&#x2F; T: temporary file; Plan 9 only
	ModeSymlink    &#x3D; fs.ModeSymlink    &#x2F;&#x2F; L: symbolic link
	ModeDevice     &#x3D; fs.ModeDevice     &#x2F;&#x2F; D: device file
	ModeNamedPipe  &#x3D; fs.ModeNamedPipe  &#x2F;&#x2F; p: named pipe (FIFO)
	ModeSocket     &#x3D; fs.ModeSocket     &#x2F;&#x2F; S: Unix domain socket
	ModeSetuid     &#x3D; fs.ModeSetuid     &#x2F;&#x2F; u: setuid
	ModeSetgid     &#x3D; fs.ModeSetgid     &#x2F;&#x2F; g: setgid
	ModeCharDevice &#x3D; fs.ModeCharDevice &#x2F;&#x2F; c: Unix character device, when ModeDevice is set
	ModeSticky     &#x3D; fs.ModeSticky     &#x2F;&#x2F; t: sticky
	ModeIrregular  &#x3D; fs.ModeIrregular  &#x2F;&#x2F; ?: non-regular file; nothing else is known about this file

	&#x2F;&#x2F; Mask for the type bits. For regular files, none will be set.
	ModeType &#x3D; fs.ModeType

	ModePerm &#x3D; fs.ModePerm &#x2F;&#x2F; Unix permission bits, 0o777
)</code></pre>
<p>The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix <code>rwxrwxrwx</code> permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const DevNull &#x3D; &quot;&#x2F;dev&#x2F;null&quot;</code></pre>
<p>DevNull is the name of the operating system’s “null device.” On Unix-like systems, it is “&#x2F;dev&#x2F;null”; on Windows, “NUL”.</p>
<p><strong>variables</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var (
	&#x2F;&#x2F; ErrInvalid indicates an invalid argument.
	&#x2F;&#x2F; Methods on File will return this error when the receiver is nil.
	ErrInvalid &#x3D; fs.ErrInvalid &#x2F;&#x2F; &quot;invalid argument&quot;

	ErrPermission &#x3D; fs.ErrPermission &#x2F;&#x2F; &quot;permission denied&quot;
	ErrExist      &#x3D; fs.ErrExist      &#x2F;&#x2F; &quot;file already exists&quot;
	ErrNotExist   &#x3D; fs.ErrNotExist   &#x2F;&#x2F; &quot;file does not exist&quot;
	ErrClosed     &#x3D; fs.ErrClosed     &#x2F;&#x2F; &quot;file already closed&quot;

	ErrNoDeadline       &#x3D; errNoDeadline()       &#x2F;&#x2F; &quot;file type does not support deadline&quot;
	ErrDeadlineExceeded &#x3D; errDeadlineExceeded() &#x2F;&#x2F; &quot;i&#x2F;o timeout&quot;
)</code></pre>
<p>Portable analogs of some common system call errors.</p>
<p>Errors returned from this package may be tested against these errors with errors.Is.</p>
<p><code>Stdin</code>, <code>Stdout</code>, and <code>Stderr</code> are open Files pointing to the standard input, standard output, and standard error file descriptors.</p>
<p>Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var Args []string</code></pre>

<p>Args hold the command-line arguments, starting with the program name.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var ErrProcessDone &#x3D; errors.New(&quot;os: process already finished&quot;)</code></pre>
<p>ErrProcessDone indicates a Process has finished.</p>
<p>fucntion<br>func Chdir(dir string) error<br>Chdir changes the current working directory to the named directory. If there is an error, it will be of type *PathError.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() &#123;
	if err :&#x3D; os.Chdir(&quot;&#x2F;home&#x2F;kirkzhang&#x2F;go-workspace&quot;); err !&#x3D; nil &#123;
		log.Fatal(err)
	&#125;
	CurDir, err :&#x3D; os.Getwd()
	if err !&#x3D; nil &#123;
		panic(err)
	&#125; else &#123;
		fmt.Println(&quot;Current working directory: &quot;, CurDir)
	&#125;
&#125;

$ Current working directory:  &#x2F;home&#x2F;kirkzhang&#x2F;go-workspace
</code></pre>
<p>summary:<br>more like <code>cd</code> command in linux</p>
<p>func Chmod(name string, mode FileMode) error<br>Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link’s target. If there is an error, it will be of type *PathError.</p>
<p>A different subset of the mode bits are used, depending on the operating system.</p>
<p>On Unix, the mode’s permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used.</p>
<p>On Windows, only the 0200 bit (owner writable) of mode is used; it controls whether the file’s read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0400 for a read-only file and 0600 for a readable+writable file.</p>
<p>On Plan 9, the mode’s permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
	if err :&#x3D; os.Chmod(&quot;.&#x2F;hello_world.go&quot;, os.ModePerm); err !&#x3D; nil &#123;
  &#x2F;&#x2F; if err :&#x3D; os.Chmod(&quot;.&#x2F;hello_world.go&quot;, os.FileMode.Perm(777));
		log.Fatal(err)
	&#125;
	CurDir, err :&#x3D; os.Getwd()
	if err !&#x3D; nil &#123;
		panic(err)
	&#125; else &#123;
		fmt.Println(&quot;Current working directory: &quot;, CurDir)
	&#125;

&#125;

</code></pre>

<p>func Chown(name string, uid, gid int) error<br>Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link’s target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type *PathError.</p>
<p>On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9 error, wrapped in *PathError.</p>
<p>func Chtimes(name string, atime time.Time, mtime time.Time) error<br>Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions.</p>
<p>The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.</p>
<p>func Clearenv()<br>Clearenv deletes all environment variables.<br>func DirFS(dir string) fs.FS<br>DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.</p>
<p>Note that DirFS(“&#x2F;prefix”) only guarantees that the Open calls it makes to the operating system will begin with “&#x2F;prefix”: DirFS(“&#x2F;prefix”).Open(“file”) is the same as os.Open(“&#x2F;prefix&#x2F;file”). So if &#x2F;prefix&#x2F;file is a symbolic link pointing outside the &#x2F;prefix tree, then using DirFS does not stop the access any more than using os.Open does. Additionally, the root of the fs.FS returned for a relative path, DirFS(“prefix”), will be affected by later calls to Chdir. DirFS is therefore not a general substitute for a chroot-style security mechanism when the directory tree contains arbitrary content.</p>
<p>func Environ() []string<br>Environ returns a copy of strings representing the environment, in the form “key&#x3D;value”.</p>
<p>func Executable() (string, error)<br>Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path&#x2F;filepath.EvalSymlinks might help.</p>
<p>Executable returns an absolute path unless an error occurred.</p>
<p>The main use case is finding resources located relative to an executable.</p>
<p>func Exit(code int)<br>Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run.</p>
<p>For portability, the status code should be in the range [0, 125].<br>func Expand(s string, mapping func(string) string) string<br>Expand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).<br>func ExpandEnv(s string) string<br>ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string.<br>func Getegid() int<br>Getegid returns the numeric effective group id of the caller.</p>
<p>On Windows, it returns -1.<br>func Getenv(key string) string<br>Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv.<br>func Geteuid() int</p>
<p>func Getgid() int<br>Geteuid returns the numeric effective user id of the caller.</p>
<p>On Windows, it returns -1.<br>func Getgroups() ([]int, error)<br>Getgid returns the numeric group id of the caller.</p>
<p>On Windows, it returns -1.<br>func Getpagesize() int<br>Getgroups returns a list of the numeric ids of groups that the caller belongs to.</p>
<p>On Windows, it returns syscall.EWINDOWS. See the os&#x2F;user package for a possible alternative.<br>func Getpid() int<br>Getpagesize returns the underlying system’s memory page size.<br>func Getppid() int<br>Getpid returns the process id of the caller.<br>func Getuid() int<br>Geteuid returns the numeric effective user id of the caller.</p>
<p>On Windows, it returns -1.<br>func Getwd() (dir string, err error)<br>Getgid returns the numeric group id of the caller.</p>
<p>On Windows, it returns -1.<br>func Hostname() (name string, err error)<br>func IsExist(err error) bool<br>func IsNotExist(err error) bool<br>func IsPathSeparator(c uint8) bool<br>func IsPermission(err error) bool<br>func IsTimeout(err error) bool<br>func Lchown(name string, uid, gid int) error<br>func Link(oldname, newname string) error<br>func LookupEnv(key string) (string, bool)<br>func Mkdir(name string, perm FileMode) error<br>func MkdirAll(path string, perm FileMode) error<br>func MkdirTemp(dir, pattern string) (string, error)<br>func NewSyscallError(syscall string, err error) error<br>func Pipe() (r *File, w *File, err error)<br>func ReadFile(name string) ([]byte, error)<br>func Readlink(name string) (string, error)<br>func Remove(name string) error<br>func RemoveAll(path string) error<br>func Rename(oldpath, newpath string) error<br>func SameFile(fi1, fi2 FileInfo) bool<br>func Setenv(key, value string) error<br>func Symlink(oldname, newname string) error<br>func TempDir() string<br>func Truncate(name string, size int64) error<br>func Unsetenv(key string) error<br>func UserCacheDir() (string, error)<br>func UserConfigDir() (string, error)<br>func UserHomeDir() (string, error)<br>func WriteFile(name string, data []byte, perm FileMode) error<br>type DirEntry<br>func ReadDir(name string) ([]DirEntry, error)<br>type File<br>func Create(name string) (*File, error)<br>func CreateTemp(dir, pattern string) (*File, error)<br>func NewFile(fd uintptr, name string) *File<br>func Open(name string) (*File, error)<br>func OpenFile(name string, flag int, perm FileMode) (*File, error)<br>func (f *File) Chdir() error<br>func (f *File) Chmod(mode FileMode) error<br>func (f *File) Chown(uid, gid int) error<br>func (f *File) Close() error<br>func (f *File) Fd() uintptr<br>func (f *File) Name() string<br>func (f *File) Read(b []byte) (n int, err error)<br>func (f *File) ReadAt(b []byte, off int64) (n int, err error)<br>func (f *File) ReadDir(n int) ([]DirEntry, error)<br>func (f *File) ReadFrom(r io.Reader) (n int64, err error)<br>func (f *File) Readdir(n int) ([]FileInfo, error)<br>func (f *File) Readdirnames(n int) (names []string, err error)<br>func (f *File) Seek(offset int64, whence int) (ret int64, err error)<br>func (f *File) SetDeadline(t time.Time) error<br>func (f *File) SetReadDeadline(t time.Time) error<br>func (f *File) SetWriteDeadline(t time.Time) error<br>func (f *File) Stat() (FileInfo, error)<br>func (f *File) Sync() error<br>func (f *File) SyscallConn() (syscall.RawConn, error)<br>func (f *File) Truncate(size int64) error<br>func (f *File) Write(b []byte) (n int, err error)<br>func (f *File) WriteAt(b []byte, off int64) (n int, err error)<br>func (f *File) WriteString(s string) (n int, err error)<br>type FileInfo<br>func Lstat(name string) (FileInfo, error)<br>func Stat(name string) (FileInfo, error)<br>type FileMode<br>type LinkError<br>func (e *LinkError) Error() string<br>func (e *LinkError) Unwrap() error<br>type PathError<br>type ProcAttr<br>type Process<br>func FindProcess(pid int) (*Process, error)<br>func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)<br>func (p *Process) Kill() error<br>func (p *Process) Release() error<br>func (p *Process) Signal(sig Signal) error<br>func (p *Process) Wait() (*ProcessState, error)<br>type ProcessState<br>func (p *ProcessState) ExitCode() int<br>func (p *ProcessState) Exited() bool<br>func (p *ProcessState) Pid() int<br>func (p *ProcessState) String() string<br>func (p *ProcessState) Success() bool<br>func (p *ProcessState) Sys() any<br>func (p *ProcessState) SysUsage() any<br>func (p *ProcessState) SystemTime() time.Duration<br>func (p *ProcessState) UserTime() time.Duration<br>type Signal<br>type SyscallError<br>func (e *SyscallError) Error() string<br>func (e *SyscallError) Timeout() bool<br>func (e *SyscallError) Unwrap() error</p>
<h1 id="8-time"><a href="#8-time" class="headerlink" title="8. time"></a>8. time</h1><p><strong>Constants</strong><br>  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  Layout      &#x3D; &quot;01&#x2F;02 03:04:05PM &#39;06 -0700&quot; &#x2F;&#x2F; The reference time, in numerical order.
  ANSIC       &#x3D; &quot;Mon Jan _2 15:04:05 2006&quot;
  UnixDate    &#x3D; &quot;Mon Jan _2 15:04:05 MST 2006&quot;
  RubyDate    &#x3D; &quot;Mon Jan 02 15:04:05 -0700 2006&quot;
  RFC822      &#x3D; &quot;02 Jan 06 15:04 MST&quot;
  RFC822Z     &#x3D; &quot;02 Jan 06 15:04 -0700&quot; &#x2F;&#x2F; RFC822 with numeric zone
  RFC850      &#x3D; &quot;Monday, 02-Jan-06 15:04:05 MST&quot;
  RFC1123     &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 MST&quot;
  RFC1123Z    &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 -0700&quot; &#x2F;&#x2F; RFC1123 with numeric zone
  RFC3339     &#x3D; &quot;2006-01-02T15:04:05Z07:00&quot;
  RFC3339Nano &#x3D; &quot;2006-01-02T15:04:05.999999999Z07:00&quot;
  Kitchen     &#x3D; &quot;3:04PM&quot;
  &#x2F;&#x2F; Handy time stamps.
  Stamp      &#x3D; &quot;Jan _2 15:04:05&quot;
  StampMilli &#x3D; &quot;Jan _2 15:04:05.000&quot;
  StampMicro &#x3D; &quot;Jan _2 15:04:05.000000&quot;
  StampNano  &#x3D; &quot;Jan _2 15:04:05.000000000&quot;
)</code></pre></p>
<p>func After(d Duration) &lt;-chan Time</p>
<p>  After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.这里需要注意，这个After(d Duration)是指返回一次的时间戳，想要使用还要再次初始化</p>
<p>func Sleep(d Duration)</p>
<p>func Tick(d Duration) &lt;-chan Time</p>
<p>type Duration</p>
<p>func ParseDuration(s string) (Duration, error)</p>
<p>func Since(t Time) Duration</p>
<p>func Until(t Time) Duration</p>
<p>func (d Duration) Abs() Duration</p>
<p>func (d Duration) Hours() float64</p>
<p>func (d Duration) Microseconds() int64</p>
<p>func (d Duration) Milliseconds() int64</p>
<p>func (d Duration) Minutes() float64</p>
<p>func (d Duration) Nanoseconds() int64</p>
<p>func (d Duration) Round(m Duration) Duration</p>
<p>func (d Duration) Seconds() float64</p>
<p>func (d Duration) String() string</p>
<p>func (d Duration) Truncate(m Duration) Duration</p>
<p>type Location</p>
<p>func FixedZone(name string, offset int) *Location</p>
<p>func LoadLocation(name string) (*Location, error)</p>
<p>func LoadLocationFromTZData(name string, data []byte) (*Location, error)</p>
<p>func (l*Location) String() string</p>
<p>type Month</p>
<p>func (m Month) String() string</p>
<p>type ParseError</p>
<p>func (e *ParseError) Error() string</p>
<p>type Ticker</p>
<p>  A Ticker holds a channel that delivers “ticks” of a clock at <strong>intervals</strong>.</p>
<p>func NewTicker(d Duration) *Ticker</p>
<p>  NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. <strong>The ticker will adjust the time interval or drop ticks to make up for slow receivers</strong>. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</p>
<p>func (t *Ticker) Reset(d Duration)</p>
<p>  Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic.</p>
<p>func (t *Ticker) Stop()</p>
<p>  Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous “tick”.</p>
<p>type Time</p>
<p>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</p>
<p>func Now() Time</p>
<p>func Parse(layout, value string) (Time, error)</p>
<p>func ParseInLocation(layout, value string, loc *Location) (Time, error)</p>
<p>func Unix(sec int64, nsec int64) Time</p>
<p>func UnixMicro(usec int64) Time</p>
<p>func UnixMilli(msec int64) Time</p>
<p>func (t Time) Add(d Duration) Time</p>
<p>func (t Time) AddDate(years int, months int, days int) Time</p>
<p>func (t Time) After(u Time) bool</p>
<p>func (t Time) AppendFormat(b []byte, layout string) []byte</p>
<p>func (t Time) Before(u Time) bool</p>
<p>func (t Time) Clock() (hour, min, sec int)</p>
<p>func (t Time) Date() (year int, month Month, day int)</p>
<p>func (t Time) Day() int</p>
<p>func (t Time) Equal(u Time) bool</p>
<p>func (t Time) Format(layout string) string</p>
<p>func (t Time) GoString() string</p>
<p>func (t *Time) GobDecode(data []byte) error</p>
<p>func (t Time) GobEncode() ([]byte, error)</p>
<p>func (t Time) Hour() int</p>
<p>func (t Time) ISOWeek() (year, week int)</p>
<p>func (t Time) In(loc*Location) Time</p>
<p>func (t Time) IsDST() bool</p>
<p>func (t Time) IsZero() bool</p>
<p>func (t Time) Local() Time</p>
<p>func (t Time) Location() *Location</p>
<p>func (t Time) MarshalBinary() ([]byte, error)</p>
<p>func (t Time) MarshalJSON() ([]byte, error)</p>
<p>func (t Time) MarshalText() ([]byte, error)</p>
<p>func (t Time) Minute() int</p>
<p>func (t Time) Month() Month</p>
<p>func (t Time) Nanosecond() int</p>
<p>func (t Time) Round(d Duration) Time</p>
<p>func (t Time) Second() int</p>
<p>func (t Time) String() string</p>
<p>func (t Time) Sub(u Time) Duration</p>
<p>func (t Time) Truncate(d Duration) Time</p>
<p>func (t Time) UTC() Time</p>
<p>func (t Time) Unix() int64</p>
<p>func (t Time) UnixMicro() int64</p>
<p>func (t Time) UnixMilli() int64</p>
<p>func (t Time) UnixNano() int64</p>
<p>func (t*Time) UnmarshalBinary(data []byte) error</p>
<p>func (t *Time) UnmarshalJSON(data []byte) error</p>
<p>func (t*Time) UnmarshalText(data []byte) error</p>
<p>func (t Time) Weekday() Weekday</p>
<p>func (t Time) Year() int</p>
<p>func (t Time) YearDay() int</p>
<p>func (t Time) Zone() (name string, offset int)</p>
<p>func (t Time) ZoneBounds() (start, end Time)</p>
<p>type Timer</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">type Timer struct &#123;
  C &lt;-chan Time
  &#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>

<p>  这里的C用于接收</p>
<p>func AfterFunc(d Duration, f func()) *Timer</p>
<p>func NewTimer(d Duration)*Timer</p>
<p>func (t *Timer) Reset(d Duration) bool</p>
<p>func (t*Timer) Stop() bool</p>
<p>type Weekday</p>
<p>func (d Weekday) String() string</p>
<h1 id="9-math"><a href="#9-math" class="headerlink" title="9. math"></a>9. math</h1><p><strong>index</strong><br><a href="#Abs">func Abs(x float64) float64</a><br><a href="#Acos">func Acos(x float64) float64</a><br><a href="#Acosh" >func Acosh(x float64) float64</a><br><a href="#Asin" >func Asin(x float64) float64</a><br><a href="#Asinh" >func Asinh(x float64) float64</a><br><a href="#Atan" >func Atan(x float64) float64</a><br><a href="#Atan2" >func Atan2(y, x float64) float64</a><br><a href="#Atanh" >func Atanh(x float64) float64</a><br><a href="#Cbrt" >func Cbrt(x float64) float64</a><br><a href="#Ceil" >func Ceil(x float64) float64</a><br><a href="#Copysign" >func Copysign(f, sign float64) float64</a><br><a href="#Cos" >func Cos(x float64) float64</a><br><a href="#Cosh" >func Cosh(x float64) float64</a><br><a href="#Dim" >func Dim(x, y float64) float64</a><br><a href="#Erf" >func Erf(x float64) float64</a><br><a href="#Erfc" >func Erfc(x float64) float64</a><br><a href="#Erfcinv" >func Erfcinv(x float64) float64</a><br><a href="#Erfinv" >func Erfinv(x float64) float64</a><br><a href="#Exp" >func Exp(x float64) float64</a><br><a href="#Exp2" >func Exp2(x float64) float64</a><br><a href="#Expm1" >func Expm1(x float64) float64</a><br><a href="#FMA" >func FMA(x, y, z float64) float64</a><br><a href="#Float32bits" >func Float32bits(f float32) uint32</a><br><a href="#Float32frombits" >func Float32frombits(b uint32) float32</a><br><a href="#Float64bits" >func Float64bits(f float64) uint64</a><br><a href="#Float64frombits" >func Float64frombits(b uint64) float64</a><br><a href="#Floor" >func Floor(x float64) float64</a><br><a href="#Frexp" >func Frexp(f float64) (frac float64, exp int)</a><br><a href="#Gamma" >func Gamma(x float64) float64</a><br><a href="#Hypot" >func Hypot(p, q float64) float64</a><br><a href="#Ilogb" >func Ilogb(x float64) int</a><br><a href="#Inf" >func Inf(sign int) float64</a><br><a href="#IsInf" >func IsInf(f float64, sign int) bool</a><br><a href="#IsNaN" >func IsNaN(f float64) (is bool)</a><br><a href="#J0" >func J0(x float64) float64</a><br><a href="#J1" >func J1(x float64) float64</a><br><a href="#Jn" >func Jn(n int, x float64) float64</a><br><a href="#Ldexp" >func Ldexp(frac float64, exp int) float64</a><br><a href="#Lgamma" >func Lgamma(x float64) (lgamma float64, sign int)</a><br><a href="#Log" >func Log(x float64) float64</a><br><a href="#Log10" >func Log10(x float64) float64</a><br><a href="#Log1p" >func Log1p(x float64) float64</a><br><a href="#Log2" >func Log2(x float64) float64</a><br><a href="#Logb" >func Logb(x float64) float64</a><br><a href="#Max" >func Max(x, y float64) float64</a><br><a href="#Min" >func Min(x, y float64) float64</a><br><a href="#Mod" >func Mod(x, y float64) float64</a><br><a href="#Modf" >func Modf(f float64) (int float64, frac float64)</a><br><a href="#NaN" >func NaN() float64</a><br><a href="#Nextafter" >func Nextafter(x, y float64) (r float64)</a><br><a href="#Nextafter32" >func Nextafter32(x, y float32) (r float32)</a><br><a href="#Pow" >func Pow(x, y float64) float64</a><br><a href="#Pow10" >func Pow10(n int) float64</a><br><a href="#Remainder" >func Remainder(x, y float64) float64</a><br><a href="#Round" >func Round(x float64) float64</a><br><a href="#RoundToEven" >func RoundToEven(x float64) float64</a><br><a href="#Signbit" >func Signbit(x float64) bool</a><br><a href="#Sin" >func Sin(x float64) float64</a><br><a href="#Sincos" >func Sincos(x float64) (sin, cos float64)</a><br><a href="#Sinh" >func Sinh(x float64) float64</a><br><a href="#Sqrt" >func Sqrt(x float64) float64</a><br><a href="#Tan" >func Tan(x float64) float64</a><br><a href="#Tanh" >func Tanh(x float64) float64</a><br><a href="#Trunc" >func Trunc(x float64) float64</a><br><a href="#Y0" >func Y0(x float64) float64</a><br><a href="#Y1" >func Y1(x float64) float64</a><br><a href="#Yn" >func Yn(n int, x float64) float64</a></p>
<p><strong>Overview</strong></p>
<p>Package math provides basic constants and mathematical functions.</p>
<p>This package does not guarantee bit-identical results across architectures.</p>
<p><strong>Constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	E   &#x3D; 2.71828182845904523536028747135266249775724709369995957496696763 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A001113
	Pi  &#x3D; 3.14159265358979323846264338327950288419716939937510582097494459 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A000796
	Phi &#x3D; 1.61803398874989484820458683436563811772030917980576286213544862 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A001622
	Sqrt2   &#x3D; 1.41421356237309504880168872420969807856967187537694807317667974 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A002193
	SqrtE   &#x3D; 1.64872127070012814684865078781416357165377610071014801157507931 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A019774
	SqrtPi  &#x3D; 1.77245385090551602729816748334114518279754945612238712821380779 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A002161
	SqrtPhi &#x3D; 1.27201964951406896425242246173749149171560804184009624861664038 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A139339
	Ln2    &#x3D; 0.693147180559945309417232121458176568075500134360255254120680009 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A002162
	Log2E  &#x3D; 1 &#x2F; Ln2
	Ln10   &#x3D; 2.30258509299404568401799145468436420760110148862877297603332790 &#x2F;&#x2F; https:&#x2F;&#x2F;oeis.org&#x2F;A002392
	Log10E &#x3D; 1 &#x2F; Ln10
)</code></pre>

<p>Mathematical constants.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	MaxFloat32             &#x3D; 0x1p127 * (1 + (1 - 0x1p-23)) &#x2F;&#x2F; 3.40282346638528859811704183484516925440e+38
	SmallestNonzeroFloat32 &#x3D; 0x1p-126 * 0x1p-23            &#x2F;&#x2F; 1.401298464324817070923729583289916131280e-45

	MaxFloat64             &#x3D; 0x1p1023 * (1 + (1 - 0x1p-52)) &#x2F;&#x2F; 1.79769313486231570814527423731704356798070e+308
	SmallestNonzeroFloat64 &#x3D; 0x1p-1022 * 0x1p-52            &#x2F;&#x2F; 4.9406564584124654417656879286822137236505980e-324
)</code></pre>
<p>Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	MaxInt    &#x3D; 1&lt;&lt;(intSize-1) - 1
	MinInt    &#x3D; -1 &lt;&lt; (intSize - 1)
	MaxInt8   &#x3D; 1&lt;&lt;7 - 1
	MinInt8   &#x3D; -1 &lt;&lt; 7
	MaxInt16  &#x3D; 1&lt;&lt;15 - 1
	MinInt16  &#x3D; -1 &lt;&lt; 15
	MaxInt32  &#x3D; 1&lt;&lt;31 - 1
	MinInt32  &#x3D; -1 &lt;&lt; 31
	MaxInt64  &#x3D; 1&lt;&lt;63 - 1
	MinInt64  &#x3D; -1 &lt;&lt; 63
	MaxUint   &#x3D; 1&lt;&lt;intSize - 1
	MaxUint8  &#x3D; 1&lt;&lt;8 - 1
	MaxUint16 &#x3D; 1&lt;&lt;16 - 1
	MaxUint32 &#x3D; 1&lt;&lt;32 - 1
	MaxUint64 &#x3D; 1&lt;&lt;64 - 1
)</code></pre>
<p>Integer limit values.</p>
<p><strong>Functions</strong></p>
<p><a  id="Abs" >func Abs</a><br>func Abs(x float64) float64<br>Abs returns the absolute value of x<br>Special cases are:<br>Abs(±Inf) &#x3D; +Inf<br>Abs(NaN) &#x3D; NaN</p>
<p><a  id="Acos" >func Abs</a><br>func Acos(x float64) float64<br>Acos returns the arccosine, in radians, of x<br>Special case is:</p>
<pre class="language-none"><code class="language-none">Acos(x) &#x3D; NaN if x &lt; -1 or x &gt; 1</code></pre>

<p><a  id="Acosh" >func Abs</a><br>func Acosh(x float64) float64<br>Acosh returns the inverse hyperbolic cosine of x.</p>
<p>Special cases are:</p>
<pre class="language-none"><code class="language-none">Acosh(+Inf) &#x3D; +Inf
Acosh(x) &#x3D; NaN if x &lt; 1
Acosh(NaN) &#x3D; NaN</code></pre>
<p><a  id="Asin" >func Asin ¶</a><br>func Asin(x float64) float64<br>Asin returns the arcsine, in radians, of x.</p>
<p>Special cases are:</p>
<pre class="language-none"><code class="language-none">Asin(±0) &#x3D; ±0
Asin(x) &#x3D; NaN if x &lt; -1 or x &gt; 1</code></pre>
<p><a  id="Asinh" >func Asinh</a></p>
<p>func Asinh(x float64) float64<br>Asinh returns the inverse hyperbolic sine of x.</p>
<p>Special cases are:</p>
<pre class="language-none"><code class="language-none">Asinh(±0) &#x3D; ±0
Asinh(±Inf) &#x3D; ±Inf
Asinh(NaN) &#x3D; NaN</code></pre>
<p><a  id="Atan" >func Atan</a></p>
<p>func Atan(x float64) float64<br>Atan returns the arctangent, in radians, of x.</p>
<p>Special cases are:</p>
<pre class="language-none"><code class="language-none">Atan(±0) &#x3D; ±0
Atan(±Inf) &#x3D; ±Pi&#x2F;2</code></pre>
<p><a  id="Atan2" >func Atan2</a></p>
<p>func Atan2(y, x float64) float64<br>Atan2 returns the arc tangent of y&#x2F;x, using the signs of the two to determine the quadrant of the return value.</p>
<p>Special cases are (in order):</p>
<p>Atan2(y, NaN) &#x3D; NaN<br>Atan2(NaN, x) &#x3D; NaN<br>Atan2(+0, x&gt;&#x3D;0) &#x3D; +0<br>Atan2(-0, x&gt;&#x3D;0) &#x3D; -0<br>Atan2(+0, x&lt;&#x3D;-0) &#x3D; +Pi<br>Atan2(-0, x&lt;&#x3D;-0) &#x3D; -Pi<br>Atan2(y&gt;0, 0) &#x3D; +Pi&#x2F;2<br>Atan2(y&lt;0, 0) &#x3D; -Pi&#x2F;2<br>Atan2(+Inf, +Inf) &#x3D; +Pi&#x2F;4<br>Atan2(-Inf, +Inf) &#x3D; -Pi&#x2F;4<br>Atan2(+Inf, -Inf) &#x3D; 3Pi&#x2F;4<br>Atan2(-Inf, -Inf) &#x3D; -3Pi&#x2F;4<br>Atan2(y, +Inf) &#x3D; 0<br>Atan2(y&gt;0, -Inf) &#x3D; +Pi<br>Atan2(y&lt;0, -Inf) &#x3D; -Pi<br>Atan2(+Inf, x) &#x3D; +Pi&#x2F;2<br>Atan2(-Inf, x) &#x3D; -Pi&#x2F;2<br>Example ¶<br>func Atanh ¶<br>func Atanh(x float64) float64<br>Atanh returns the inverse hyperbolic tangent of x.</p>
<p>Special cases are:</p>
<p>Atanh(1) &#x3D; +Inf<br>Atanh(±0) &#x3D; ±0<br>Atanh(-1) &#x3D; -Inf<br>Atanh(x) &#x3D; NaN if x &lt; -1 or x &gt; 1<br>Atanh(NaN) &#x3D; NaN<br>Example ¶<br>func Cbrt ¶<br>func Cbrt(x float64) float64<br>Cbrt returns the cube root of x.</p>
<p>Special cases are:</p>
<p>Cbrt(±0) &#x3D; ±0<br>Cbrt(±Inf) &#x3D; ±Inf<br>Cbrt(NaN) &#x3D; NaN<br>Example ¶<br>func Ceil ¶<br>func Ceil(x float64) float64<br>Ceil returns the least integer value greater than or equal to x.</p>
<p>Special cases are:</p>
<p>Ceil(±0) &#x3D; ±0<br>Ceil(±Inf) &#x3D; ±Inf<br>Ceil(NaN) &#x3D; NaN<br>Example ¶<br>func Copysign ¶<br>func Copysign(f, sign float64) float64<br>Copysign returns a value with the magnitude of f and the sign of sign.</p>
<p>Example ¶<br>func Cos ¶<br>func Cos(x float64) float64<br>Cos returns the cosine of the radian argument x.</p>
<p>Special cases are:</p>
<p>Cos(±Inf) &#x3D; NaN<br>Cos(NaN) &#x3D; NaN<br>Example ¶<br>func Cosh ¶<br>func Cosh(x float64) float64<br>Cosh returns the hyperbolic cosine of x.</p>
<p>Special cases are:</p>
<p>Cosh(±0) &#x3D; 1<br>Cosh(±Inf) &#x3D; +Inf<br>Cosh(NaN) &#x3D; NaN<br>Example ¶<br>func Dim ¶<br>func Dim(x, y float64) float64<br>Dim returns the maximum of x-y or 0.</p>
<p>Special cases are:</p>
<p>Dim(+Inf, +Inf) &#x3D; NaN<br>Dim(-Inf, -Inf) &#x3D; NaN<br>Dim(x, NaN) &#x3D; Dim(NaN, x) &#x3D; NaN<br>Example ¶<br>func Erf ¶<br>func Erf(x float64) float64<br>Erf returns the error function of x.</p>
<p>Special cases are:</p>
<p>Erf(+Inf) &#x3D; 1<br>Erf(-Inf) &#x3D; -1<br>Erf(NaN) &#x3D; NaN<br>func Erfc ¶<br>func Erfc(x float64) float64<br>Erfc returns the complementary error function of x.</p>
<p>Special cases are:</p>
<p>Erfc(+Inf) &#x3D; 0<br>Erfc(-Inf) &#x3D; 2<br>Erfc(NaN) &#x3D; NaN<br>func Erfcinv ¶<br>added in go1.10<br>func Erfcinv(x float64) float64<br>Erfcinv returns the inverse of Erfc(x).</p>
<p>Special cases are:</p>
<p>Erfcinv(0) &#x3D; +Inf<br>Erfcinv(2) &#x3D; -Inf<br>Erfcinv(x) &#x3D; NaN if x &lt; 0 or x &gt; 2<br>Erfcinv(NaN) &#x3D; NaN<br>func Erfinv ¶<br>added in go1.10<br>func Erfinv(x float64) float64<br>Erfinv returns the inverse error function of x.</p>
<p>Special cases are:</p>
<p>Erfinv(1) &#x3D; +Inf<br>Erfinv(-1) &#x3D; -Inf<br>Erfinv(x) &#x3D; NaN if x &lt; -1 or x &gt; 1<br>Erfinv(NaN) &#x3D; NaN<br>func Exp ¶<br>func Exp(x float64) float64<br>Exp returns e**x, the base-e exponential of x.</p>
<p>Special cases are:</p>
<p>Exp(+Inf) &#x3D; +Inf<br>Exp(NaN) &#x3D; NaN<br>Very large values overflow to 0 or +Inf. Very small values underflow to 1.</p>
<p>Example ¶<br>func Exp2 ¶<br>func Exp2(x float64) float64<br>Exp2 returns 2**x, the base-2 exponential of x.</p>
<p>Special cases are the same as Exp.</p>
<p>Example ¶<br>func Expm1 ¶<br>func Expm1(x float64) float64<br>Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than Exp(x) - 1 when x is near zero.</p>
<p>Special cases are:</p>
<p>Expm1(+Inf) &#x3D; +Inf<br>Expm1(-Inf) &#x3D; -1<br>Expm1(NaN) &#x3D; NaN<br>Very large values overflow to -1 or +Inf.</p>
<p>Example ¶<br>func FMA ¶<br>added in go1.14<br>func FMA(x, y, z float64) float64<br>FMA returns x * y + z, computed with only one rounding. (That is, FMA returns the fused multiply-add of x, y, and z.)</p>
<p>func Float32bits ¶<br>func Float32bits(f float32) uint32<br>Float32bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position. Float32bits(Float32frombits(x)) &#x3D;&#x3D; x.</p>
<p>func Float32frombits ¶<br>func Float32frombits(b uint32) float32<br>Float32frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float32frombits(Float32bits(x)) &#x3D;&#x3D; x.</p>
<p>func Float64bits ¶<br>func Float64bits(f float64) uint64<br>Float64bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position, and Float64bits(Float64frombits(x)) &#x3D;&#x3D; x.</p>
<p>func Float64frombits ¶<br>func Float64frombits(b uint64) float64<br>Float64frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float64frombits(Float64bits(x)) &#x3D;&#x3D; x.</p>
<p>func Floor ¶<br>func Floor(x float64) float64<br>Floor returns the greatest integer value less than or equal to x.</p>
<p>Special cases are:</p>
<p>Floor(±0) &#x3D; ±0<br>Floor(±Inf) &#x3D; ±Inf<br>Floor(NaN) &#x3D; NaN<br>Example ¶<br>func Frexp ¶<br>func Frexp(f float64) (frac float64, exp int)<br>Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f &#x3D;&#x3D; frac × 2**exp, with the absolute value of frac in the interval [½, 1).</p>
<p>Special cases are:</p>
<p>Frexp(±0) &#x3D; ±0, 0<br>Frexp(±Inf) &#x3D; ±Inf, 0<br>Frexp(NaN) &#x3D; NaN, 0<br>func Gamma ¶<br>func Gamma(x float64) float64<br>Gamma returns the Gamma function of x.</p>
<p>Special cases are:</p>
<p>Gamma(+Inf) &#x3D; +Inf<br>Gamma(+0) &#x3D; +Inf<br>Gamma(-0) &#x3D; -Inf<br>Gamma(x) &#x3D; NaN for integer x &lt; 0<br>Gamma(-Inf) &#x3D; NaN<br>Gamma(NaN) &#x3D; NaN<br>func Hypot ¶<br>func Hypot(p, q float64) float64<br>Hypot returns Sqrt(p<em>p + q</em>q), taking care to avoid unnecessary overflow and underflow.</p>
<p>Special cases are:</p>
<p>Hypot(±Inf, q) &#x3D; +Inf<br>Hypot(p, ±Inf) &#x3D; +Inf<br>Hypot(NaN, q) &#x3D; NaN<br>Hypot(p, NaN) &#x3D; NaN<br>func Ilogb ¶<br>func Ilogb(x float64) int<br>Ilogb returns the binary exponent of x as an integer.</p>
<p>Special cases are:</p>
<p>Ilogb(±Inf) &#x3D; MaxInt32<br>Ilogb(0) &#x3D; MinInt32<br>Ilogb(NaN) &#x3D; MaxInt32<br>func Inf ¶<br>func Inf(sign int) float64<br>Inf returns positive infinity if sign &gt;&#x3D; 0, negative infinity if sign &lt; 0.</p>
<p>func IsInf ¶<br>func IsInf(f float64, sign int) bool<br>IsInf reports whether f is an infinity, according to sign. If sign &gt; 0, IsInf reports whether f is positive infinity. If sign &lt; 0, IsInf reports whether f is negative infinity. If sign &#x3D;&#x3D; 0, IsInf reports whether f is either infinity.</p>
<p>func IsNaN ¶<br>func IsNaN(f float64) (is bool)<br>IsNaN reports whether f is an IEEE 754 “not-a-number” value.</p>
<p>func J0 ¶<br>func J0(x float64) float64<br>J0 returns the order-zero Bessel function of the first kind.</p>
<p>Special cases are:</p>
<p>J0(±Inf) &#x3D; 0<br>J0(0) &#x3D; 1<br>J0(NaN) &#x3D; NaN<br>func J1 ¶<br>func J1(x float64) float64<br>J1 returns the order-one Bessel function of the first kind.</p>
<p>Special cases are:</p>
<p>J1(±Inf) &#x3D; 0<br>J1(NaN) &#x3D; NaN<br>func Jn ¶<br>func Jn(n int, x float64) float64<br>Jn returns the order-n Bessel function of the first kind.</p>
<p>Special cases are:</p>
<p>Jn(n, ±Inf) &#x3D; 0<br>Jn(n, NaN) &#x3D; NaN<br>func Ldexp ¶<br>func Ldexp(frac float64, exp int) float64<br>Ldexp is the inverse of Frexp. It returns frac × 2**exp.</p>
<p>Special cases are:</p>
<p>Ldexp(±0, exp) &#x3D; ±0<br>Ldexp(±Inf, exp) &#x3D; ±Inf<br>Ldexp(NaN, exp) &#x3D; NaN<br>func Lgamma ¶<br>func Lgamma(x float64) (lgamma float64, sign int)<br>Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).</p>
<p>Special cases are:</p>
<p>Lgamma(+Inf) &#x3D; +Inf<br>Lgamma(0) &#x3D; +Inf<br>Lgamma(-integer) &#x3D; +Inf<br>Lgamma(-Inf) &#x3D; -Inf<br>Lgamma(NaN) &#x3D; NaN<br>func Log ¶<br>func Log(x float64) float64<br>Log returns the natural logarithm of x.</p>
<p>Special cases are:</p>
<p>Log(+Inf) &#x3D; +Inf<br>Log(0) &#x3D; -Inf<br>Log(x &lt; 0) &#x3D; NaN<br>Log(NaN) &#x3D; NaN<br>Example ¶<br>func Log10 ¶<br>func Log10(x float64) float64<br>Log10 returns the decimal logarithm of x. The special cases are the same as for Log.</p>
<p>Example ¶<br>func Log1p ¶<br>func Log1p(x float64) float64<br>Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.</p>
<p>Special cases are:</p>
<p>Log1p(+Inf) &#x3D; +Inf<br>Log1p(±0) &#x3D; ±0<br>Log1p(-1) &#x3D; -Inf<br>Log1p(x &lt; -1) &#x3D; NaN<br>Log1p(NaN) &#x3D; NaN<br>func Log2 ¶<br>func Log2(x float64) float64<br>Log2 returns the binary logarithm of x. The special cases are the same as for Log.</p>
<p>Example ¶<br>func Logb ¶<br>func Logb(x float64) float64<br>Logb returns the binary exponent of x.</p>
<p>Special cases are:</p>
<p>Logb(±Inf) &#x3D; +Inf<br>Logb(0) &#x3D; -Inf<br>Logb(NaN) &#x3D; NaN<br>func Max ¶<br>func Max(x, y float64) float64<br>Max returns the larger of x or y.</p>
<p>Special cases are:</p>
<p>Max(x, +Inf) &#x3D; Max(+Inf, x) &#x3D; +Inf<br>Max(x, NaN) &#x3D; Max(NaN, x) &#x3D; NaN<br>Max(+0, ±0) &#x3D; Max(±0, +0) &#x3D; +0<br>Max(-0, -0) &#x3D; -0<br>func Min ¶<br>func Min(x, y float64) float64<br>Min returns the smaller of x or y.</p>
<p>Special cases are:</p>
<p>Min(x, -Inf) &#x3D; Min(-Inf, x) &#x3D; -Inf<br>Min(x, NaN) &#x3D; Min(NaN, x) &#x3D; NaN<br>Min(-0, ±0) &#x3D; Min(±0, -0) &#x3D; -0<br>func Mod ¶<br>func Mod(x, y float64) float64<br>Mod returns the floating-point remainder of x&#x2F;y. The magnitude of the result is less than y and its sign agrees with that of x.</p>
<p>Special cases are:</p>
<p>Mod(±Inf, y) &#x3D; NaN<br>Mod(NaN, y) &#x3D; NaN<br>Mod(x, 0) &#x3D; NaN<br>Mod(x, ±Inf) &#x3D; x<br>Mod(x, NaN) &#x3D; NaN<br>Example ¶<br>func Modf ¶<br>func Modf(f float64) (int float64, frac float64)<br>Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.</p>
<p>Special cases are:</p>
<p>Modf(±Inf) &#x3D; ±Inf, NaN<br>Modf(NaN) &#x3D; NaN, NaN<br>Example ¶<br>func NaN ¶<br>func NaN() float64<br>NaN returns an IEEE 754 “not-a-number” value.</p>
<p>func Nextafter ¶<br>func Nextafter(x, y float64) (r float64)<br>Nextafter returns the next representable float64 value after x towards y.</p>
<p>Special cases are:</p>
<p>Nextafter(x, x)   &#x3D; x<br>Nextafter(NaN, y) &#x3D; NaN<br>Nextafter(x, NaN) &#x3D; NaN<br>func Nextafter32 ¶<br>added in go1.4<br>func Nextafter32(x, y float32) (r float32)<br>Nextafter32 returns the next representable float32 value after x towards y.</p>
<p>Special cases are:</p>
<p>Nextafter32(x, x)   &#x3D; x<br>Nextafter32(NaN, y) &#x3D; NaN<br>Nextafter32(x, NaN) &#x3D; NaN<br>func Pow ¶<br>func Pow(x, y float64) float64<br>Pow returns x**y, the base-x exponential of y.</p>
<p>Special cases are (in order):</p>
<p>Pow(x, ±0) &#x3D; 1 for any x<br>Pow(1, y) &#x3D; 1 for any y<br>Pow(x, 1) &#x3D; x for any x<br>Pow(NaN, y) &#x3D; NaN<br>Pow(x, NaN) &#x3D; NaN<br>Pow(±0, y) &#x3D; ±Inf for y an odd integer &lt; 0<br>Pow(±0, -Inf) &#x3D; +Inf<br>Pow(±0, +Inf) &#x3D; +0<br>Pow(±0, y) &#x3D; +Inf for finite y &lt; 0 and not an odd integer<br>Pow(±0, y) &#x3D; ±0 for y an odd integer &gt; 0<br>Pow(±0, y) &#x3D; +0 for finite y &gt; 0 and not an odd integer<br>Pow(-1, ±Inf) &#x3D; 1<br>Pow(x, +Inf) &#x3D; +Inf for |x| &gt; 1<br>Pow(x, -Inf) &#x3D; +0 for |x| &gt; 1<br>Pow(x, +Inf) &#x3D; +0 for |x| &lt; 1<br>Pow(x, -Inf) &#x3D; +Inf for |x| &lt; 1<br>Pow(+Inf, y) &#x3D; +Inf for y &gt; 0<br>Pow(+Inf, y) &#x3D; +0 for y &lt; 0<br>Pow(-Inf, y) &#x3D; Pow(-0, -y)<br>Pow(x, y) &#x3D; NaN for finite x &lt; 0 and finite non-integer y<br>Example ¶<br>func Pow10 ¶<br>func Pow10(n int) float64<br>Pow10 returns 10**n, the base-10 exponential of n.</p>
<p>Special cases are:</p>
<p>Pow10(n) &#x3D;    0 for n &lt; -323<br>Pow10(n) &#x3D; +Inf for n &gt; 308<br>Example ¶<br>func Remainder ¶<br>func Remainder(x, y float64) float64<br>Remainder returns the IEEE 754 floating-point remainder of x&#x2F;y.</p>
<p>Special cases are:</p>
<p>Remainder(±Inf, y) &#x3D; NaN<br>Remainder(NaN, y) &#x3D; NaN<br>Remainder(x, 0) &#x3D; NaN<br>Remainder(x, ±Inf) &#x3D; x<br>Remainder(x, NaN) &#x3D; NaN<br>Example ¶<br>func Round ¶<br>added in go1.10<br>func Round(x float64) float64<br>Round returns the nearest integer, rounding half away from zero.</p>
<p>Special cases are:</p>
<p>Round(±0) &#x3D; ±0<br>Round(±Inf) &#x3D; ±Inf<br>Round(NaN) &#x3D; NaN<br>Example ¶<br>func RoundToEven ¶<br>added in go1.10<br>func RoundToEven(x float64) float64<br>RoundToEven returns the nearest integer, rounding ties to even.</p>
<p>Special cases are:</p>
<p>RoundToEven(±0) &#x3D; ±0<br>RoundToEven(±Inf) &#x3D; ±Inf<br>RoundToEven(NaN) &#x3D; NaN<br>Example ¶<br>func Signbit ¶<br>func Signbit(x float64) bool<br>Signbit reports whether x is negative or negative zero.</p>
<p>func Sin ¶<br>func Sin(x float64) float64<br>Sin returns the sine of the radian argument x.</p>
<p>Special cases are:</p>
<p>Sin(±0) &#x3D; ±0<br>Sin(±Inf) &#x3D; NaN<br>Sin(NaN) &#x3D; NaN<br>Example ¶<br>func Sincos ¶<br>func Sincos(x float64) (sin, cos float64)<br>Sincos returns Sin(x), Cos(x).</p>
<p>Special cases are:</p>
<p>Sincos(±0) &#x3D; ±0, 1<br>Sincos(±Inf) &#x3D; NaN, NaN<br>Sincos(NaN) &#x3D; NaN, NaN<br>Example ¶<br>func Sinh ¶<br>func Sinh(x float64) float64<br>Sinh returns the hyperbolic sine of x.</p>
<p>Special cases are:</p>
<p>Sinh(±0) &#x3D; ±0<br>Sinh(±Inf) &#x3D; ±Inf<br>Sinh(NaN) &#x3D; NaN<br>Example ¶<br>func Sqrt ¶<br>func Sqrt(x float64) float64<br>Sqrt returns the square root of x.</p>
<p>Special cases are:</p>
<p>Sqrt(+Inf) &#x3D; +Inf<br>Sqrt(±0) &#x3D; ±0<br>Sqrt(x &lt; 0) &#x3D; NaN<br>Sqrt(NaN) &#x3D; NaN<br>Example ¶<br>func Tan ¶<br>func Tan(x float64) float64<br>Tan returns the tangent of the radian argument x.</p>
<p>Special cases are:</p>
<p>Tan(±0) &#x3D; ±0<br>Tan(±Inf) &#x3D; NaN<br>Tan(NaN) &#x3D; NaN<br>Example ¶<br>func Tanh ¶<br>func Tanh(x float64) float64<br>Tanh returns the hyperbolic tangent of x.</p>
<p>Special cases are:</p>
<p>Tanh(±0) &#x3D; ±0<br>Tanh(±Inf) &#x3D; ±1<br>Tanh(NaN) &#x3D; NaN<br>Example ¶<br>func Trunc ¶<br>func Trunc(x float64) float64<br>Trunc returns the integer value of x.</p>
<p>Special cases are:</p>
<p>Trunc(±0) &#x3D; ±0<br>Trunc(±Inf) &#x3D; ±Inf<br>Trunc(NaN) &#x3D; NaN<br>Example ¶<br>func Y0 ¶<br>func Y0(x float64) float64<br>Y0 returns the order-zero Bessel function of the second kind.</p>
<p>Special cases are:</p>
<p>Y0(+Inf) &#x3D; 0<br>Y0(0) &#x3D; -Inf<br>Y0(x &lt; 0) &#x3D; NaN<br>Y0(NaN) &#x3D; NaN<br>func Y1 ¶<br>func Y1(x float64) float64<br>Y1 returns the order-one Bessel function of the second kind.</p>
<p>Special cases are:</p>
<p>Y1(+Inf) &#x3D; 0<br>Y1(0) &#x3D; -Inf<br>Y1(x &lt; 0) &#x3D; NaN<br>Y1(NaN) &#x3D; NaN<br>func Yn ¶<br>func Yn(n int, x float64) float64<br>Yn returns the order-n Bessel function of the second kind.</p>
<p>Special cases are:</p>
<p>Yn(n, +Inf) &#x3D; 0<br>Yn(n ≥ 0, 0) &#x3D; -Inf<br>Yn(n &lt; 0, 0) &#x3D; +Inf if n is odd, -Inf if n is even<br>Yn(n, x &lt; 0) &#x3D; NaN<br>Yn(n, NaN) &#x3D; NaN</p>
<h2 id="9-1-big"><a href="#9-1-big" class="headerlink" title="9.1 big"></a>9.1 big</h2><h2 id="9-2-bits"><a href="#9-2-bits" class="headerlink" title="9.2 bits"></a>9.2 bits</h2><h2 id="9-3-cmplx"><a href="#9-3-cmplx" class="headerlink" title="9.3 cmplx"></a>9.3 cmplx</h2><h2 id="9-4-rand"><a href="#9-4-rand" class="headerlink" title="9.4 rand"></a>9.4 rand</h2><p><strong>Overview</strong></p>
<p><strong>Function</strong></p>
<p>func ExpFloat64() float64</p>
<p>func Float32() float32</p>
<p>func Float64() float64</p>
<p>func Int() int</p>
<p>func Int31() int32</p>
<p>func Int31n(n int32) int32</p>
<p>func Int63() int64</p>
<p>func Int63n(n int64) int64</p>
<p>func Intn(n int) int</p>
<p>func NormFloat64() float64</p>
<p>func Perm(n int) []int</p>
<p>func Read(p []byte) (n int, err error)</p>
<p>func Seed(seed int64)</p>
<p>func Shuffle(n int, swap func(i, j int))</p>
<p>func Uint32() uint32</p>
<p>func Uint64() uint64</p>
<p>type Rand</p>
<p>func New(src Source) *Rand</p>
<p>func (r*Rand) ExpFloat64() float64</p>
<p>func (r *Rand) Float32() float32</p>
<p>func (r*Rand) Float64() float64</p>
<p>func (r *Rand) Int() int</p>
<p>func (r*Rand) Int31() int32</p>
<p>func (r *Rand) Int31n(n int32) int32</p>
<p>func (r*Rand) Int63() int64</p>
<p>func (r *Rand) Int63n(n int64) int64</p>
<p>func (r*Rand) Intn(n int) int</p>
<p>func (r *Rand) NormFloat64() float64</p>
<p>func (r*Rand) Perm(n int) []int</p>
<p>func (r *Rand) Read(p []byte) (n int, err error)</p>
<p>func (r*Rand) Seed(seed int64)</p>
<p>  Seed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。</p>
<p>func (r *Rand) Shuffle(n int, swap func(i, j int))</p>
<p>func (r*Rand) Uint32() uint32</p>
<p>func (r *Rand) Uint64() uint64</p>
<p>type Source</p>
<p>func NewSource(seed int64) Source</p>
<p>  NewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">randomSource :&#x3D; NewSource(time.Now().UnixNano())
randSeed :&#x3D; New(randomSource) &#x2F;&#x2F;这时候就可以使用rand的method
randomInt :&#x3D; randSeed.Intn(300)&#x2F;&#x2F;[0,300)的整数
</code></pre>

<p>type Source64</p>
<p>  Source64是一个也可以直接生成[0, 1&lt;&lt;64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。<br>  Source64的结构</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">type Source64 interface &#123;
    Source
    Uint64() uint64
&#125;</code></pre>

<p>type Zipf</p>
<p>func NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipf</p>
<p>func (z *Zipf) Uint64() uint64</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/golang/" rel="tag">golang</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"
                    data-tooltip="go语言圣经"
                    aria-label="PREVIOUS: go语言圣经"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/07/archive/compact_wsl2/"
                    data-tooltip="压缩wsl2的磁盘"
                    aria-label="NEXT: 压缩wsl2的磁盘"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go_documentation/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"
                    data-tooltip="go语言圣经"
                    aria-label="PREVIOUS: go语言圣经"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/07/archive/compact_wsl2/"
                    data-tooltip="压缩wsl2的磁盘"
                    aria-label="NEXT: 压缩wsl2的磁盘"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go_documentation/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href=""
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go_documentation/"
                        aria-label="global.share_on_wechat"
                    >
                        <i class="fa-foo_bar" aria-hidden="true"></i><span>global.share_on_wechat</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Canton
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-4u8r0fo0pgap8c0kebqie2krcfxcv3h259cjxizeggkmknhnwzjt04ztqpi1.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'ca29b9a1203b5920918d',
              clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
              repo: 'SimonTeo58.github.io',
              owner: 'SimonTeo58',
              admin: ['SimonTeo58'],
              id: '2022/10/08/golang/go_documentation/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
