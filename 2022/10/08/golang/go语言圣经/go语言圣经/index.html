
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CoffeeMan">
    <title>go语言圣经 - CoffeeMan</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://simonteo58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg"},"articleBody":"摘要: Go语言有时候被描述为”C类似语言”,或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。\n\n\n\n\ngo语言项目所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）。\n正如Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。\n简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。\nGo项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。\nGo语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。\nGo语言鼓励当代计算机系统设计的原则，特别是局部的重要性。它的内置数据类型和大多数的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因为很少的内存分配和内存初始化代码被隐藏在库代码中了。Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存写操作，而且指针操作比其他间接操作的语言也更有效率。由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。\nGo语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I&#x2F;O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且，每个Go程序结构都是如此的相似，因此，Go程序也很容易学习。使用Go语言自带工具构建Go语言项目只需要使用文件名和标识符名称，一个偶尔的特殊注释来确定所有的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范。\n1. 入门1.1. hello_world我们以现已成为传统的“hello world”案例来开始吧，这个例子首次出现于 1978 年出版的 C 语言圣经 《The C Programming Language》（译注：本书作者之一 Brian W. Kernighan 也是《The C Programming Language》一书的作者）。C 语言是直接影响 Go 语言设计的语言之一。这个例子体现了 Go 语言一些核心理念。\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    fmt.Println(&quot;Hello, 世界&quot;)\n&#125;\n\nGo 是一门编译型语言，Go 语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。Go 语言提供的工具都通过一个单独的命令 go 调用，go 命令有一系列子命令。最简单的一个子命令就是 run。这个命令编译一个或多个以。.go 结尾的源文件，链接库文件，并运行最终生成的可执行文件。（本书使用$表示命令行提示符。）\ngo run helloworld.go\n\n毫无意外，这个命令会输出Hello, 世界Go 语言原生支持 Unicode，它可以处理全世界任何语言的文本。如果不只是一次实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以用 build 子命令：\ngo build helloworld.go\n\n这个命令生成一个名为 helloworld 的可执行的二进制文件(译注:Windows系统下生成的可执行文件是 helloworld.exe,增加了.exe后缀名)，之后你可以随时运行它(译注：在 Windows 系统下在命令行直接输入 helloworld.exe 命令运行),不需任何处理(译注：因为静态编译，所以不用担心在系统库更新的时候冲突，幸福感满满)\nhelloworld\n\nHello, 世界\n本书中所有示例代码上都有一行标记，利用这些标记可以从 gopl.io 网站上本书源码仓库里获取代码;gopl.io/ch1/helloworld执行 go get gopl.io/ch1/helloworld命令，就会从网上获取代码，并放到对应目录中（需要先安装 Git 或 Hg 之类的版本管理工具，并将对应的命令添加到 PATH 环境变量中。序言已经提及，需要先设置好 GOPATH 环境变量，下载的代码会放在 $GOPATH/src/gopl.io/ch1/helloworld 目录）。2.6 和 10.7 节有这方面更详细的介绍。\n来讨论下程序本身。Go 语言的代码通过包(package)组织，包类似于其它语言里的库(libraries)或者模块(modules)。一个包由位于单个目录下的一个或多个 .go 源代码文件组成，目录定义包的作用。每个源文件都以一条 package 声明语句开始，这个例子里就是 package main，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。\nGo 的标准库提供了 100 多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如 fmt 包，就含有格式化输出、接收输入的函数。Println 是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。\nmain包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main函数也很特殊，它是整个程序执行时的入口（译注：C 系语言差不多都这样）。main 函数所做的事情就是程序做的。当然了，main 函数一般调用其它包里的函数完成很多工作（如：fmt.Println）。\n必须告诉编译器源文件需要哪些包，这就是跟随在 package 声明后面的import声明扮演的角色。hello world 例子只用到了一个包，大多数程序需要导入多个包。\n必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包（译注：Go 语言编译过程没有警告信息，争议特性之一）。\nimport 声明必须跟在文件的 package 声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字 func、var、const、type 定义）。这些内容的声明顺序并不重要（译注：最好还是定一下规范）。这个例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。为了节省篇幅，有些时候示例程序会省略 package 和 import 声明，但是，这些声明在源代码里有，并且必须得有才能编译。\n一个函数的声明由 func 关键字、函数名、参数列表、返回值列表（这个例子里的 main 函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。\nGo 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响 Go 代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字 break、continue、fallthrough或 return 中的一个、运算符和分隔符 ++、–、)、] 或 } 中的一个）。举个例子，函数的左括号 { 必须和 func 函数声明在同一行上，且位于末尾，不能独占一行，而在表达式 x+y 中，可在 + 后换行，不能在 + 前换行（译注：以+结尾的话不会被插入分号分隔符，但是以 x 结尾的话则会被分号分隔符，从而导致编译错误）。\nGo 语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式（译注：这个格式化工具没有任何可以调整代码格式的参数，Go 语言就是这么任性），并且 go 工具中的 fmt 子命令会对指定包，否则默认为当前目录中所有。go 源文件应用 gofmt 命令。本书中的所有代码都被 gofmt 过。你也应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执（译注：也导致了 Go 语言的 TIOBE 排名较低，因为缺少撕逼的话题）。更重要的是，这样可以做多种自动源码转换，如果放任 Go 语言代码格式，这些转换就不大可能了。\n很多文本编辑器都可以配置为保存文件时自动执行 gofmt，这样你的源代码总会被恰当地格式化。还有个相关的工具：goimports，可以根据代码需要，自动地添加或删除 import 声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装：\n$ go get golang.org/x/tools/cmd/goimports对于大多数用户来说，下载、编译包、运行测试用例、察看 Go 语言的文档等等常用功能都可以用 go 的工具完成节详细介绍这些知识。\nsummary:  \n\ngo拥有完整的工具链，通常是go的子命令，在命令输入go关键字就可以查看子命令\nGo 语言原生支持 Unicode，它可以处理全世界任何语言的文本。\n编写完程序就可以编译成二进制可执行程序使用go build\ngo help build 查看build文档\ngo build 选项列表及说明,语法为usage: go build [-o output] [build flags] [packages]  -o      指定编译输出的软件名称\n-i      安装作为目标的依赖关系的包(用于增量编译提速)\n-a      强制重建已经是最新版本的软件包 \n-n      (只是输出一些运行过程)\n-p n    the number of programs, such as build commands or (指定内核数量编译程序，包括test binary)\n-race   (同时检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64)\n-msan   (启用与内存消毒器的互操作。仅支持linux / amd64，并且只用Clang / LLVM作为主机C编译器（少用))\n-asan\n-v      (打印名称)\n-work   (打印临时工作目录名称)\n-x      打印输出 执行命令名\n-asmflags '[pattern=]arg list'   (传递每个go工具asm调用的参数)\n-buildmode mode             (编译模式 go help buildmode)\n-buildvcs   \n-compiler name  (指定编译器)\n-gccgoflags '[pattern=]arg list'  gccgo编译/连接器参数\n-gcflags '[pattern=]arg list'   垃圾回收参数\n-installsuffix suffix           (压缩编译后体积)\n-ldflags '[pattern=]arg list'\n-linkshared             (链接到以前共享库)\n-mod mode\n-modcacherw\n-modfile file\n-overlay file\n-pkgdir dir     (从指定位置，而不是通常的位置安装和加载所有软件包。例如，当使用非标准配置构建时，使用-pkgdir将生成的包保留在单独的位置。)\n-tags tag,list  (构建出带tag的版本.)\n-trimpath\n-toolexec 'cmd args'\n\n\ngo拥有丰富的库函数\nfunc 接收器、函数名、参数列表、返回值列表\n函数的左括号 { 必须和 func 函数声明在同一行上，且位于末尾，不能独占一行(第一节对格式有说明)\ngofmt工具把代码格式化为标准格式,只能服从\n\n1.2 命令行参数(os package)大多数的程序都是处理输入，产生输出；这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？一些程序生成自己的数据，但通常情况下，输入来自于程序外部：文件、网络连接、其它程序的输出、敲键盘的用户、命令行参数或其它类似输入源。下面几个例子会讨论其中几个输入源，首先是命令行参数。\nos 包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的 Args变量获取；os 包外部使用 os.Args 访问该变量。\nos.Args 变量是一个字符串（string）的 切片（slice）（译注：slice 和 Python 语言中的切片类似，是一个简版的动态数组），切片是 Go 语言的基础概念，稍后详细介绍。现在先把切片 s 当作数组元素序列，序列的长度动态变化，用 s[i] 访问单个元素，用 s[m:n] 获取子序列（译注：和 Python 里的语法差不多）。序列的元素数目为 len(s)。和大多数编程语言类似，区间索引时，Go 语言里也采用左闭右开形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。（译注：比如 a&#x3D;[1,2,3,4,5], a[0:3]&#x3D;[1,2,3]，不包含最后一个元素）。比如 s[m:n] 这个切片，0≤m≤n≤len(s)，包含 n-m 个元素。os.Args 的第一个元素：os.Args[0]，是命令本身的名字；其它的元素则是程序启动时传给它的参数。s[m:n] 形式的切片表达式，产生从第 m 个元素到第 n-1 个元素的切片，下个例子用到的元素包含在 os.Args[1:len(os.Args)] 切片中。如果省略切片表达式的 m 或 n，会默认传入 0 或 len(s)，因此前面的切片可以简写成 os.Args[1:]。\n下面是 Unix 里 echo 命令的一份实现，echo 把它的命令行参数打印成一行。程序导入了两个包，用括号把它们括起来写成列表形式，而没有分开写成独立的 import 声明。两种形式都合法，列表形式习惯上用得多。包导入顺序并不重要；gofmt 工具格式化时按照字母顺序对包名排序。（示例有多个版本时，我们会对示例编号，这样可以明确当前正在讨论的是哪个。）\ngopl.io&#x2F;ch1&#x2F;echo1\n&#x2F;&#x2F; Echo1 prints its command-line arguments.\npackage main\nimport (\n    &quot;fmt&quot;\n    &quot;os&quot;\n)\nfunc main() &#123;\n    var s, sep string\n    for i :&#x3D; 1; i &lt; len(os.Args); i++ &#123;\n        s +&#x3D; sep + os.Args[i]\n        sep &#x3D; &quot; &quot;\n    &#125;\n    fmt.Println(s)\n&#125;\n注释语句以 &#x2F;&#x2F; 开头。对于程序员来说，&#x2F;&#x2F; 之后到行末之间所有的内容都是注释，被编译器忽略。按照惯例，我们在每个包的包声明前添加注释；对于 main package，注释包含一句或几句话，从整体角度对程序做个描述。var 声明定义了两个 string 类型的变量 s 和 sep。变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的 零值（zero value），数值类型是 0，字符串类型是空字符串 “”。这个例子里，声明把 s 和 sep 隐式地初始化成空字符串。第 2 章再来详细地讲解变量和声明。对数值类型，Go 语言提供了常规的数值和逻辑运算符。而对 string 类型，+ 运算符连接字符串（译注：和 C++ 或者 JavaScript 是一样的）。所以表达式：sep + os.Args[i] 表示连接字符串 sep 和 os.Args。程序中使用的语句：s+&#x3D;sep+os.Args[i] 是一条 赋值语句，将 s 的旧值跟 sep 与 os.Args[i] 连接后赋值回 s，等价于：s&#x3D;s+sep+os.Args[i]。运算符 +&#x3D; 是赋值运算符（assignment operator），每种数值运算符或逻辑运算符，如 + 或 *，都有对应的赋值运算符。echo 程序可以每循环一次输出一个参数，这个版本却是不断地把新文本追加到末尾来构造字符串。字符串 s 开始为空，即值为 “”，每次循环会添加一些文本；第一次迭代之后，还会再插入一个空格，因此循环结束时每个参数中间都有一个空格。这是一种二次加工（quadratic process），当参数数量庞大时，开销很大，但是对于 echo，这种情形不大可能出现。本章会介绍 echo 的若干改进版，下一章解决低效问题。循环索引变量 i 在 for 循环的第一部分中定义。符号 :&#x3D; 是 短变量声明（short variable declaration）的一部分，这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句。下一章有这方面更多说明。自增语句 i++ 给 i 加 1；这和 i+&#x3D;1 以及 i&#x3D;i+1 都是等价的。对应的还有 i– 给 i 减 1。它们是语句，而不像 C 系的其它语言那样是表达式。所以 j&#x3D;i++ 非法，而且 ++ 和 – 都只能放在变量名后面，因此 –i 也非法。Go 语言只有 for 循环这一种循环语句。for 循环有多种形式，其中一种如下所示：\nfor initialization; condition; post &#123;\n    &#x2F;&#x2F; zero or more statements\n&#125;\nfor 循环三个部分不需括号包围。大括号强制要求，左大括号必须和 post 语句在同一行。\ninitialization 语句是可选的，在循环开始前执行。initalization 如果存在，必须是一条 简单语句（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。condition 是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为 true 则执行循环体语句。post 语句在循环体执行结束后执行，之后再次对 condition 求值。condition 值为 false 时，循环结束。\nfor 循环的这三个部分每个都可以省略，如果省略 initialization 和 post，分号也可以省略：\n&#x2F;&#x2F; a traditional &quot;while&quot; loop\nfor condition &#123;\n    &#x2F;&#x2F; ...\n&#125;\n如果连 condition 也省略了，像下面这样：\n\n&#x2F;&#x2F; a traditional infinite loop\nfor &#123;\n    &#x2F;&#x2F; ...\n&#125;\n这就变成一个无限循环，尽管如此，还可以用其他方式终止循环，如一条 break 或 return 语句。for 循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片。echo 的第二版本展示了这种形式：\ngopl.io&#x2F;ch1&#x2F;echo2\n&#x2F;&#x2F; Echo2 prints its command-line arguments.\npackage main\nimport (\n    &quot;fmt&quot;\n    &quot;os&quot;\n)\n\nfunc main() &#123;\n    s, sep :&#x3D; &quot;&quot;, &quot;&quot;\n    for _, arg :&#x3D; range os.Args[1:] &#123;\n        s +&#x3D; sep + arg\n        sep &#x3D; &quot; &quot;\n    &#125;\n    fmt.Println(s)\n&#125;\n每次循环迭代，range 产生一对值；索引以及在该索引处的元素值。这个例子不需要索引，但 range 的语法要求，要处理元素，必须处理索引。一种思路是把索引赋值给一个临时变量（如 temp）然后忽略它的值，但 Go 语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。\nGo 语言中这种情况的解决方法是用 空标识符（blank identifier），即 _（也就是下划线）。空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。大多数的 Go 程序员都会像上面这样使用 range 和 _ 写 echo 程序，因为隐式地而非显式地索引 os.Args，容易写对。\necho 的这个版本使用一条短变量声明来声明并初始化 s 和 seps，也可以将这两个变量分开声明，声明一个变量有好几种方式，下面这些都等价：\ns :&#x3D; &quot;&quot;\nvar s string\nvar s &#x3D; &quot;&quot;\nvar s string &#x3D; &quot;&quot;\n用哪种不用哪种，为什么呢？第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为 “”。第三种形式用得很少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。\n如前文所述，每次循环迭代字符串 s 的内容都会更新。+&#x3D; 连接原字符串、空格和下个参数，产生新字符串，并把它赋值给 s。s 原来的内容已经不再使用，将在适当时机对它进行垃圾回收。如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用 strings 包的 Join 函数：\ngopl.io&#x2F;ch1&#x2F;echo3\nfunc main() &#123;\n    fmt.Println(strings.Join(os.Args[1:], &quot; &quot;))\n&#125;\n最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用 Println 为我们格式化输出。fmt.Println(os.Args[1:])这条语句的输出结果跟 strings.Join 得到的结果很像，只是被放到了一对方括号里。切片都会被打印成这种格式。\n练习 1.1： 修改 echo 程序，使其能够打印 os.Args[0]，即被执行命令本身的名字。练习 1.2： 修改 echo 程序，使其打印每个参数的索引和值，每个一行。练习 1.3： 做实验测量潜在低效的版本和使用了 strings.Join 的版本的运行时间差异。（1.6 节讲解了部分 time 包，11.4 节展示了如何写标准测试程序，以得到系统性的性能评测。）summary:  \n\nos包提供跨平台的方式。具体怎么用要参考文档,文档主要提供了type DirEntry,type File,type FileInfo\ngolang定义参数的方式var a,b,c int=0,0,0,还有海马运算符   s := &quot;&quot;   var s , v string   var s = &quot;&quot;   var s string = &quot;&quot;   golang字符串类型也可以使用简单的A+B方式进行拼接   string.Join()方法第一位参数是slice，然后seperator\nfor statement commonly\nfor k,v := range os.Args[1:]&#123;&#125;\nfor condition &#123;&#125;\nfor &#123;&#125;\nfor i:=0;i&lt;m;i++&#123;&#125;\n\n\n切片的使用 切片的基本使用，slice[m:n]可以截取切片区间，包头不包尾巴,其中包含n-m个元素\nslice[1:]是从位置1直到末尾\n所以j&#x3D;i++非法，而且 ++ 和 – 都只能放在变量名后面，因此 –i 也非法。\n\n1.3 查找重复的行%d          十进制整数\n%x, %o, %b  十六进制，八进制，二进制整数。\n%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00\n%t          布尔：true或false\n%c          字符(rune)(Unicode码点)\n%s          字符串\n%q          带双引号的字符串&quot;abc&quot;或带单引号的字符&#39;c&#39;\n%v          变量的自然形式（natural format）\n%T          变量的类型\n%%          字面上的百分号标志（无操作数）\n\n\na := make(map[string]int)\nvar fileMap map[string][]string 定义map\nfileMap:= map[string][]string&#123;&quot;kirk&quot;:[1,2,3],&quot;zhang&quot;:[4,5,6]&#125;定义map并初始化\nfileMap:= make(map[string][]string ,5) make创建map并初始化存储能力\n增-fileMap[&quot;kirk&quot;]=[1,2,3]\n删-delete(fileMap,&quot;kirk&quot;)\n改-fileMap[&quot;kirk&quot;]=[4,5,6],简介修改fileMap := newFileMap这时候地址就改了\n查-value, ok := myMap[&quot;1234&quot;]; !ok&#123;//处理找到的value&#125;else&#123;&#125;\n\n\ngolang的传递都是值传递\n\n1.4 GIF动画没啥意思，都是介绍功能\n1.5 获取URL这一节主要还是io的例子\n1.6. 并发获取多个URL开始介绍go关键字进行并发还有channel\n1.7. Web服务主要还是介绍net包\n2. 程序结构2.1 命名\n\n\n功能性关键字\n描述\n\n\n\nbreak\n退出循环\n\n\ncase\nswitch case, select case\n\n\nchan\nvar ch chan int, ch :&#x3D; make(chan int),ch :&#x3D; make(chan int,1)\n\n\nconst\nconst (a int    &#x3D; 1  b int    &#x3D; 2 c string &#x3D; “3”)\n\n\ncontinue\n退出循环\n\n\ndefault\n常见于select {}一起使用\n\n\ndefer\n函数退出前执行\n\n\nelse\nif else\n\n\nfallthrough\nN&#x2F;A\n\n\nfor\nfor {}, for i:&#x3D;0;i &lt; length ;i++{}, for k,v :&#x3D; range Slice{}\n\n\nfunc\nfunc (){}\n\n\ngo\n携程\n\n\nif\n\n\n\nimport\n\n\n\ninterface\ninterface{} 是噩梦\n\n\nmap\na :&#x3D; make(map[int]string) ,var a map[int]string\n\n\npackage\n\n\n\nrange\nfor , :&#x3D; range _ {}\n\n\nreturn\nyou know\n\n\nselect\nselect {case a: }\n\n\nstruct\n相当于java的类,跟c的struct很像\n\n\nswitch\nswitch conditional {}\n\n\ntype\ntype A struct {}\n\n\nvar\nvar a , b, int &#x3D; 0,1 . var ( linkFile int &#x3D;1  dFile int &#x3D;2 )\n\n\n\n\n\n内建常量\n关键字\n\n\n\ntrue\nshit\n\n\nfalse\nshit\n\n\niota\n1,2,3,4….\n\n\nnil\nshit\n\n\n\n\n\ngolang的基本数据类型\n关键字\n\n\n\nint\n\n\n\nint8\n\n\n\nint16\n\n\n\nint32\n\n\n\nint64\n\n\n\nuint\n\n\n\nuint8\n\n\n\nuint16\n\n\n\nuint32\n\n\n\nuint64\n\n\n\nuintptr\n\n\n\nfloat32\n\n\n\nfloat64\n\n\n\ncomplex128\n\n\n\ncomplex64\n\n\n\nbool\n\n\n\nbyte\n\n\n\nrune\n\n\n\nstring\n\n\n\nerror\n\n\n\n\n\n\n常用内建函数\n关键字\n\n\n\nmake\n\n\n\nlen\n\n\n\ncap\n\n\n\nnew\n\n\n\nappend\n\n\n\ncopy\n\n\n\nclose\n\n\n\ndelete\n\n\n\ncomplex\n\n\n\nreal\n\n\n\nimag\n\n\n\npanic\n\n\n\nrecover\n\n\n\nGo推荐使用驼峰式命名:\n\n一个名字必须以一个字母（Unicode字母）或下划线开头,下划线开头可能表示私有的\n后面可以跟任意数量的字母、数字或下划线。\n名字的开头字母的大小写决定了名字在包外的可见性.如果一个名字是大写字母开头的(译注必须是 在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将是导出的,也就是说可以被外部的包访问,例如fmt.Printf,就可以在包外访问\n\n2.2 声明Go语言主要有四种类型的声明语句:\n\nvar\nconst\ntype\nfunc\n\npackage main\n\nimport &quot;fmt&quot;\n\nconst boilingF &#x3D; 212.0\nconst var a &#x3D; 0\n\nfunc main() &#123;\n    var f &#x3D; boilingF\n    var c &#x3D; (f - 32) * 5 &#x2F; 9\n    fmt.Printf(&quot;boiling point &#x3D; %g°F or %g°C\\n&quot;, f, c)\n    &#x2F;&#x2F; Output:\n    &#x2F;&#x2F; boiling point &#x3D; 212°F or 100°C\n&#125;\n\nboilingF是包一级的变量在包内可以访问。如果函数没有返回值，那么返回值列表是省略的。函数顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者\n2.3 变量常规声明变量\nvar 变量名字 类型 &#x3D; 表达式\n\nvar i ,j , k int &#x2F;&#x2F; 都是int类型\nvar b,f,s &#x3D;true , 2.3 ,&quot;four&quot; &#x2F;&#x2F;bool , float 64,string\nvar f, err &#x3D; os.Open(name) &#x2F;&#x2F; os.Open returns a file and an error\n\n\n在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。\n类型和表达式都可以缺省,如果是类型缺省那么就可以通过表达式进行推断,如果是表达式缺省那么就会赋类型的零值,如果是自定义类型或者是引用类型就是内部各个字段都是零值.Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态\n\n2.3.1 简短变量声明  anim :&#x3D; gif.GIF&#123;LoopCount: nframes&#125; &#x2F;&#x2F;聚合类型,引用类型\nfreq :&#x3D; rand.Float64() * 3.0 &#x2F;&#x2F; float\nt :&#x3D; 0.0  &#x2F;&#x2F;float\nf, err :&#x3D; os.Open(name) &#x2F;&#x2F;通过函数进行声明，并初始化\nif err !&#x3D; nil &#123;\n    return err\n&#125;\n\n\n例子1中声明的err是重复,第二个简短声明符的err就是赋值操作，注意该操作是在变量相同作用例子2中这种情况编译不通过,至少有一个是新声明的.[ 实际工程中尽量不要出现例子2 ]\n&#x2F;&#x2F;例子1\nin, err :&#x3D; os.Open(infile)\n&#x2F;&#x2F; ...\nout, err :&#x3D; os.Create(outfile)\n&#x2F;&#x2F;例子2\nf, err :&#x3D; os.Open(infile)\n&#x2F;&#x2F; ...\nf, err :&#x3D; os.Create(outfile) &#x2F;&#x2F; compile error: no new variables\n\n2.3.2 指针\n任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。\n\n返回局部变量地址也是安全的。\n  func incr(p *int) int &#123;\n    *p++ &#x2F;&#x2F; 非常重要：只是增加p指向的变量的值，并不改变p指针！！！\n    return *p\n&#125;\nv :&#x3D; 1\nincr(&amp;v)              &#x2F;&#x2F; side effect: v is now 2\nfmt.Println(incr(&amp;v)) &#x2F;&#x2F; &quot;3&quot; (and v is 3)\n\n在flag包中,应用到了指针技术\n  package main\nimport (\n    &quot;flag&quot;\n    &quot;fmt&quot;\n    &quot;strings&quot;\n)\nvar n &#x3D; flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)\nvar sep &#x3D; flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)\n\nfunc main() &#123;\n    flag.Parse() &#x2F;&#x2F;解析标志性参数位\n    fmt.Print(strings.Join(flag.Args(), *sep)) &#x2F;&#x2F;flag.Args() 解析非标志参数位\n    if !*n &#123;\n        fmt.Println()\n    &#125;\n&#125;\n\n在此代码例子中使用flag.Args()解析非标志参数位,flag.Parse()解析标志性参数位,to be continue\n\n\n\n2.3.3 new函数  表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T(返回的是指针)\n\n每次new()返回新的变量地址,比如new(int)\n\n2.3.4. 变量的生命周期\n包一级的声明会伴随程序整个声明周期,但是函数内部则是动态,会被GC回收\n\n函数的参数变量(参数列表)和返回值变量都是局部变量。它们在函数每次被调用的时候创建,下面循环的变量t就是动态创建,用完就扔\nfor t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;\n  x :&#x3D; math.Sin(t)\n  y :&#x3D; math.Sin(t*freq + phase)\n  img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),\n      blackIndex)\n&#125;\n\n下面也是合法的\nfor t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;\n  x :&#x3D; math.Sin(t)\n  y :&#x3D; math.Sin(t*freq + phase)\n  img.SetColorIndex(\n      size+int(x*size+0.5), size+int(y*size+0.5),\n      blackIndex, &#x2F;&#x2F; 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性\n  )               &#x2F;&#x2F; 小括弧另起一行缩进，和大括弧的风格保存一致\n&#125;\n\n局部变量逃逸.因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。编译器会自动选择在栈上还是在堆上分配局部变量的存储空间,代码如下,f函数里的x变量必须在堆上分配,因为它在函数退出后依然可以通过包一级的global变量找到,g函数在栈上分配*y内存空间\nvar global *int\n\nfunc f() &#123;\n    var x int\n    x &#x3D; 1\n    global &#x3D; &amp;x\n&#125;\n\nfunc g() &#123;\n    y :&#x3D; new(int)\n    *y &#x3D; 1\n&#125;\n\n\nGo语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期,比如,如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。\n\n\n2.4 赋值  x &#x3D; 1                       &#x2F;&#x2F; 命名变量的赋值\n*p &#x3D; true                   &#x2F;&#x2F; 通过指针间接赋值\nperson.name &#x3D; &quot;bob&quot;         &#x2F;&#x2F; 结构体字段赋值\ncount[x] &#x3D; count[x] * scale &#x2F;&#x2F; 数组、slice或map的元素赋值\n\n\n2.4.1 元组赋值  x,y &#x3D; y,x; &#x2F;&#x2F;不限制数量\na[i], a[j] &#x3D; a[j], a[i];\n&#x2F;&#x2F;额外的布尔类型表达某种错误类型\nv, ok &#x3D; m[key]             &#x2F;&#x2F; map lookup\nv, ok &#x3D; x.(T)              &#x2F;&#x2F; type assertion\nv, ok &#x3D; &lt;-ch               &#x2F;&#x2F; channel receive\n&#x2F;&#x2F;只做检查\nv &#x3D; m[key]                &#x2F;&#x2F; map查找，失败时返回零值\nv &#x3D; x.(T)                 &#x2F;&#x2F; type断言，失败时panic异常\nv &#x3D; &lt;-ch                  &#x2F;&#x2F; 管道接收，失败时返回零值（阻塞不算是失败）\n\n_, ok &#x3D; m[key]            &#x2F;&#x2F; map返回2个值\n_, ok &#x3D; mm[&quot;&quot;], false     &#x2F;&#x2F; map返回1个值\n_ &#x3D; mm[&quot;&quot;]                &#x2F;&#x2F; map返回1个值\n&#x2F;&#x2F;复合类型隐式赋值\nmedals :&#x3D; []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125;\n&#x2F;&#x2F;等价写法\nmedals[0] &#x3D; &quot;gold&quot;\nmedals[1] &#x3D; &quot;silver&quot;\nmedals[2] &#x3D; &quot;bronze&quot;\n\n\n对于两个值是否可以用&#x3D;&#x3D;或!&#x3D;进行相等比较的能力也和可赋值能力有关系\n\n2.5 类型  package tempconv\n\nimport &quot;fmt&quot;\n\ntype Celsius float64    &#x2F;&#x2F; 摄氏温度\ntype Fahrenheit float64 &#x2F;&#x2F; 华氏温度\n\nconst (\n    AbsoluteZeroC Celsius &#x3D; -273.15 &#x2F;&#x2F; 绝对零度\n    FreezingC     Celsius &#x3D; 0       &#x2F;&#x2F; 结冰点温度\n    BoilingC      Celsius &#x3D; 100     &#x2F;&#x2F; 沸水温度\n)\n\nfunc CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9&#x2F;5 + 32) &#125;\n\nfunc FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 &#x2F; 9) &#125;\n\n\n\n类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用\nCelsius和Fahrenheit是两种不同类型,Celsius(t)或Fahrenheit(t)形式的显式转型,整数-&gt;小数回省略小数部分(CPP在这部分有很详细的讨论)\n如果两个值有着不同的类型，则不能直接进行比较\n命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集后面详细讨论\n\n2.6 包和文件\n名字空间每个包都对应一个独立的名字空间,例如，在image包中的Decode函数和在unicode&#x2F;utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问\n\n包的导入Go语言的规范并没有定义这些源代码的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。\n\n包的初始化。包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的。例如func init() &#123; /* ... */ &#125;,init不能被调用，也不能被声明。包会按照声明的顺序初始化。\n\n包的初始化顺序。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了\n  复杂初始化可以用以下方式\n  &#x2F;&#x2F;可以使用匿名函数处理\nvar pc [256]byte &#x3D; func() (pc [256]byte) &#123;\n  for i :&#x3D; range pc &#123;\n      pc[i] &#x3D; pc[i&#x2F;2] + byte(i&amp;1)\n  &#125;\n  return\n&#125;()\n\n\n2.7. 作用域\n不要将作用域和生命周期混为一谈，作用域是指文本域，而生命周期是指运行有效时段\n任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的\n对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包\n控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是  函数级的作用域\n\n几种常见作用域例子\n\n正常情况下作用域例子\n  func f() &#123;&#125;\n\nvar g &#x3D; &quot;g&quot;\n\nfunc main() &#123;\n    f :&#x3D; &quot;f&quot;\n    fmt.Println(f) &#x2F;&#x2F; &quot;f&quot;; local var f shadows package-level func f\n    fmt.Println(g) &#x2F;&#x2F; &quot;g&quot;; package-level var\n    fmt.Println(h) &#x2F;&#x2F; compile error: undefined: h\n&#125;\n\n作用域嵌套,函数中可以进行词法域嵌套\n  func main() &#123;\n  x :&#x3D; &quot;hello!&quot;\n  for i :&#x3D; 0; i &lt; len(x); i++ &#123;\n      x :&#x3D; x[i]\n      if x !&#x3D; &#39;!&#39; &#123;\n          x :&#x3D; x + &#39;A&#39; - &#39;a&#39;\n          fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;上述代码&#96;x[]&#96;和&#96;x + &#39;A&#39; - &#39;a&#39;&#96;都是引用了外部作用域声明的x变量。\n&#x2F;&#x2F;再比如下面的例子,有三个不同的x变量，\n\n  &#x2F;&#x2F;每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化\n&#x2F;&#x2F;词法域，一个在for循环体词法域；只有两个块是显式创建的：\nfunc main() &#123;\n  x :&#x3D; &quot;hello&quot;\n  for _, x :&#x3D; range x &#123;\n      x :&#x3D; x + &#39;A&#39; - &#39;a&#39;\n      fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)\n  &#125;\n&#125;\n\n建隐式词法域,隐式作用域if和switch语句也会在条件部分创建隐式词法域，代码例子如下.第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问\n  if x :&#x3D; f(); x &#x3D;&#x3D; 0 &#123;\n  fmt.Println(x)\n&#125; else if y :&#x3D; g(x); x &#x3D;&#x3D; y &#123;\n    fmt.Println(x, y)\n&#125; else &#123;\n    fmt.Println(x, y)\n&#125;\nfmt.Println(x, y) &#x2F;&#x2F; compile error: x and y are not visible here\n\n  如果不想提前声明变量还可以选择如下方式，但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回\n  if f, err :&#x3D; os.Open(fname); err !&#x3D; nil &#123;\n  return err\n&#125; else &#123;\n    &#x2F;&#x2F; f and err are visible here too\n    f.ReadByte()\n    f.Close()\n&#125;\n\n屏蔽其他作用域变暗亮  cwd在外部已经声明的包级变量，但是:&#x3D;语句还是将cwd和err重新声明为新的局部变量\n  var cwd string\n\nfunc init() &#123;\n    cwd, err :&#x3D; os.Getwd() &#x2F;&#x2F; compile error: unused: cwd\n    if err !&#x3D; nil &#123;\n        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)\n    &#125;\n&#125;\n\n  可以用赋值运算符，就不会屏蔽cwd变量\n  var cwd string\n\nfunc init() &#123;\n    var err error &#x2F;&#x2F;因为是赋值运算符所以需要定义error变量\n    cwd, err &#x3D; os.Getwd()\n    if err !&#x3D; nil &#123;\n        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)\n    &#125;\n&#125;\n\n3.基础数据类型\n整型格式控制符\n\n\n\n格 式\n描 述\n\n\n\n%b\n整型以二进制方式显示\n\n\n%o\n整型以八进制方式显示\n\n\n%d\n整型以十进制方式显示,以锁为例子mutex&#x3D;&amp;((1 0) 0 0 -1073741824 0)\n\n\n%x\n整型以十六进制方式显示\n\n\n%X\n整型以十六进制、字母大写方式显示\n\n\n%c\n相应Unicode码点所表示的字符\n\n\n%U\nUnicode 字符, Unicode格式：123，等同于 “U+007B”\n\n\n\n浮点数格式控制\n\n\n\n格 式\n描 述\n\n\n\n%e\n科学计数法,例如 -1234.456e+78\n\n\n%E\n科学计数法,例如 -1234.456E+78\n\n\n%f\n有小数点而无指数,例如 123.456\n\n\n%g\n根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出\n\n\n%G\n根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出\n\n\n\n字符串格式化\n\n\n\n格 式\n描 述\n\n\n\n%s\n字符串或切片的无解译字节\n\n\n%q\n双引号围绕的字符串，由Go语法安全地转义\n\n\n%x\n十六进制，小写字母，每字节两个字符\n\n\n%X\n十六进制，大写字母，每字节两个字符\n\n\n\n指针格式化\n\n\n\n格 式\n描 述\n\n\n\n%p\n十六进制表示，前缀 0x\n\n\n\n通用的占位符\n\n\n\n格 式\n描 述\n\n\n\n%v\n值的默认格式。只输出字段的值，没有字段名字,eg: requestVote RPC&#x3D;{1,1,0,0}\n\n\n%+v\n类似%v，但输出结构体时会添加字段名,以RWMutex为例子, &amp;{w:{state:1 sema:0} writerSem:0 readerSem:0 readerCount:-1073741824 readerWait:0}\n\n\n%#v\n相应值的Go语法表示,比如地址用十六进制表示,以RWMutex为例子, &amp;sync.RWMutex{w:sync.Mutex{state:1, sema:0x0}, writerSem:0x0, readerSem:0x0, readerCount:-1073741824, readerWait:0}\n\n\n%T\n相应值的类型的Go语法表示,比如以RWMutex为例子,rf.mu&#x3D;*sync.RWMutex\n\n\n%%\n百分号,字面上的%,非占位符含义\n\n\n\n控制宽度  宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐\n\n字符串控制\nfmt.Printf(&quot;|%s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 不设置宽度\nfmt.Printf(&quot;|%5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度,  默认+， 右对齐\nfmt.Printf(&quot;|%-5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度, 左对齐\nfmt.Printf(&quot;|%05s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; |000aa|\n\n\n浮点控制\na :&#x3D; 54.123456\nfmt.Printf(&quot;|%f|&quot;, a)  &#x2F;&#x2F; |54.123456|\nfmt.Printf(&quot;|%5.1f|&quot;, a)  &#x2F;&#x2F; | 54.1|\nfmt.Printf(&quot;|%-5.1f|&quot;, a) &#x2F;&#x2F; |54.1 |\nfmt.Printf(&quot;|%05.1f|&quot;, a) &#x2F;&#x2F; |054.1|\n\n\n\n\n\n3.1 整型\n因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节\nUnicode和rune类型是个int32等价的类型,通常用于表示一个Unicode码点\n同样byte也是uint8类型的等价类型\n还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方\nint、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然\n位元素符号\nint32和int64无法直接四则运算\nfmt.Printf(&quot;%d %[1]o %#[1]o\\n&quot;, o) // &quot;438 666 0666&quot;中的fmt两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀\n\n3.2 浮点数\n一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大\n浮点数字面量可以直接书写\n很大或者很小的数都可以用科学计数法来书写\nfmt.Printf(&quot;x = %d e^x = %8.3f\\n&quot;, x, math.Exp(float64(x)))8.3是指三个小数精度，8个字符宽度,%g %e %f.\n\n3.3 复数复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:\nvar x complex128 &#x3D; complex(1, 2) &#x2F;&#x2F; 1+2i\nvar y complex128 &#x3D; complex(3, 4) &#x2F;&#x2F; 3+4i\nfmt.Println(x*y)                 &#x2F;&#x2F; &quot;(-5+10i)&quot;\nfmt.Println(real(x*y))           &#x2F;&#x2F; &quot;-5&quot;\nfmt.Println(imag(x*y))           &#x2F;&#x2F; &quot;10&quot;\n\n\n3.4 布尔类型布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:\ni :&#x3D; 0\nif b &#123;\n    i &#x3D; 1\n&#125;\n\n3.5 字符串\n字符串可以用&#x3D;&#x3D;和&lt;进行比较；比较通过逐个字节比较完成的\n\n字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故s[0] = &#39;L&#39; // compile error: cannot assign to s[0]\n\n因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中\n可在字符串面值中写十六进制和八进制数字进行码点转义\n原生字面值用反引号(&#96;)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.\n通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思\nUTF-8 [to be continue]\nbytes、strings、strconv和unicode包,四个包对字符串处理尤为重要,strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能\n字符串和数字的转换,strconv包提供这类转换功能\n\n\n\n4. 复合数据类型4.1 数组数组代码示例\nvar a [3]int             &#x2F;&#x2F; array of 3 integers\nfmt.Println(a[0])        &#x2F;&#x2F; print the first element\nfmt.Println(a[len(a)-1]) &#x2F;&#x2F; print the last element, a[2]\n\n&#x2F;&#x2F; Print the indices and elements.\nfor i, v :&#x3D; range a &#123;\n    fmt.Printf(&quot;%d %d\\n&quot;, i, v)\n&#125;\n\n&#x2F;&#x2F; Print the elements only.\nfor _, v :&#x3D; range a &#123;\n    fmt.Printf(&quot;%d\\n&quot;, v)\n&#125;\n\n如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算\nq :&#x3D; [...]int&#123;1, 2, 3&#125;\nfmt.Printf(&quot;%T\\n&quot;, q) &#x2F;&#x2F; &quot;[3]int&quot;\n\n上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化\ntype Currency int\n\nconst (\n    USD Currency &#x3D; iota &#x2F;&#x2F; 美元\n    EUR                 &#x2F;&#x2F; 欧元\n    GBP                 &#x2F;&#x2F; 英镑\n    RMB                 &#x2F;&#x2F; 人民币\n)\n\nsymbol :&#x3D; [...]string&#123;USD: &quot;$&quot;, EUR: &quot;€&quot;, GBP: &quot;￡&quot;, RMB: &quot;￥&quot;&#125;\n\nfmt.Println(RMB, symbol[RMB]) &#x2F;&#x2F; &quot;3 ￥&quot;\n\n定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。\nr :&#x3D; [...]int&#123;99: -1&#125;\n\n数组进行比较是比较所有元素是否相等\n4.2 slice创建slice变量\nv_len :&#x3D; make([]T, len)\nv_len_cap :&#x3D; make([]T, len, cap) &#x2F;&#x2F; same as make([]T, cap)[:len]\ns :&#x3D; []int&#123;0, 1, 2, 3, 4, 5&#125;\n\nslice和数组典型的不同就是slice不指定长度bytes.Equal函数来判断两个字节型slice是否相等（[]byte)\nfunc equal(x, y []string) bool &#123;\n    if len(x) !&#x3D; len(y) &#123;\n        return false\n    &#125;\n    for i :&#x3D; range x &#123;\n        if x[i] !&#x3D; y[i] &#123;\n            return false\n        &#125;\n    &#125;\n    return true\n&#125;\n\nslice的nil值\nvar s []int    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; nil        &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; []int(nil) &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil\ns &#x3D; []int&#123;&#125;    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s !&#x3D; nil\n\n4.2.1 append函数(留着放些API东西)\n4.3 Map其中K对应的key必须是支持&#x3D;&#x3D;比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在创建map\nages :&#x3D; make(map[string]int) &#x2F;&#x2F; mapping from strings to ints\nages :&#x3D; map[string]int&#123;\n    &quot;alice&quot;:   31,\n    &quot;charlie&quot;: 34,\n&#125;\n&#x2F;&#x2F;访问map数据，也是put操作\nages[&quot;alice&quot;] &#x3D; 32\n&#x2F;&#x2F;删除元素\ndelete(ages, &quot;alice&quot;) &#x2F;&#x2F; remove element ages[&quot;alice&quot;]\n&#x2F;&#x2F;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：\n_ &#x3D; &amp;ages[&quot;bob&quot;] &#x2F;&#x2F; compile error: cannot take address of map element\n\n\nMap的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序\nimport &quot;sort&quot;\n\nvar names []string\nfor name :&#x3D; range ages &#123;\n    names &#x3D; append(names, name)\n&#125;\nsort.Strings(names)\nfor _, name :&#x3D; range names &#123;\n    fmt.Printf(&quot;%s\\t%d\\n&quot;, name, ages[name])\n&#125;\n\nmap返回两个值，第一个值是bool类型,false则说明不存在这个key。map的key要求必须是可比较类型，那么如果想用slice作为key就需要写小改动\nvar m &#x3D; make(map[string]int)\n\nfunc k(list []string) string &#123; return fmt.Sprintf(&quot;%q&quot;, list) &#125;\n\nfunc Add(list []string)       &#123; m[k(list)]++ &#125;\nfunc Count(list []string) int &#123; return m[k(list)] &#125;\n\n4.4 结构体seen :&#x3D; make(map[string]struct&#123;&#125;) &#x2F;&#x2F; set of strings\n&#x2F;&#x2F; ...\nif _, ok :&#x3D; seen[s]; !ok &#123;\n    seen[s] &#x3D; struct&#123;&#125;&#123;&#125;\n    &#x2F;&#x2F; ...first time seeing s...\n&#125;\n\n4.4.1 结构体字面值type Point struct&#123; X, Y int &#125;\n&#x2F;&#x2F;第一种类型初始化方式\np :&#x3D; Point&#123;1, 2&#125;\n&#x2F;&#x2F;第二种初始化方式,如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要\np :&#x3D;Point&#123;x:1,y:2&#125;\n\n非导出结构体或者字段，不能在其他包中进行赋值\npackage p\ntype T struct&#123; a, b int &#125; &#x2F;&#x2F; a and b are not exported\n\npackage q\nimport &quot;p&quot;\nvar _ &#x3D; p.T&#123;a: 1, b: 2&#125; &#x2F;&#x2F; compile error: can&#39;t reference a, b\nvar _ &#x3D; p.T&#123;1, 2&#125;       &#x2F;&#x2F; compile error: can&#39;t reference a, b\n\n如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，\n\nfunc Bonus(e *Employee, percent int) int &#123;\n    return e.Salary * percent &#x2F; 100\n&#125;\n\n可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：\npp :&#x3D; &amp;Point&#123;1, 2&#125;\n\n它和下面的语句是等价的\npp :&#x3D; new(Point)\n*pp &#x3D; Point&#123;1, 2&#125;\n\n4.4.2 结构体的比较首先结构体是可比较类型\n\ntype Point struct&#123; X, Y int &#125;\n\np :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;2, 1&#125;\nfmt.Println(p.X &#x3D;&#x3D; q.X &amp;&amp; p.Y &#x3D;&#x3D; q.Y) &#x2F;&#x2F; &quot;false&quot;\nfmt.Println(p &#x3D;&#x3D; q)                   &#x2F;&#x2F; &quot;false&quot;\n\n\n4.4.3 结构体嵌入和匿名成员\ntype Point struct &#123;\n    X, Y int\n&#125;\n\ntype Circle struct &#123;\n    Center Point\n    Radius int\n&#125;\n\ntype Wheel struct &#123;\n    Circle Circle\n    Spokes int\n&#125;\n\nvar w Wheel\nw.Circle.Center.X &#x3D; 8\nw.Circle.Center.Y &#x3D; 8\nw.Circle.Radius &#x3D; 5\nw.Spokes &#x3D; 20\n\n匿名成员，说白了就是只写类型不写名字.\ntype Circle struct &#123;\n    Point\n    Radius int\n&#125;\n\ntype Wheel struct &#123;\n    Circle\n    Spokes int\n&#125;\n\nvar w Wheel\nw.X &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.X &#x3D; 8\nw.Y &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.Y &#x3D; 8\nw.Radius &#x3D; 5       &#x2F;&#x2F; equivalent to w.Circle.Radius &#x3D; 5\nw.Spokes &#x3D; 20\n&#x2F;&#x2F;以下初始化是错误的\nw &#x3D; Wheel&#123;8, 8, 5, 20&#125;                       &#x2F;&#x2F; compile error: unknown fields\nw &#x3D; Wheel&#123;X: 8, Y: 8, Radius: 5, Spokes: 20&#125; &#x2F;&#x2F; compile error: unknown fields\n\n所以我们只能用下面两种方式进行初始化\n\nw &#x3D; Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;\n\nw &#x3D; Wheel&#123;\n    Circle: Circle&#123;\n        Point:  Point&#123;X: 8, Y: 8&#125;,\n        Radius: 5,\n    &#125;,\n    Spokes: 20, &#x2F;&#x2F; NOTE: trailing comma necessary here (and at Radius)\n&#125;\n\nfmt.Printf(&quot;%#v\\n&quot;, w)\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;\n\nw.X &#x3D; 42\n\nfmt.Printf(&quot;%#v\\n&quot;, w)\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;\n\n\n需要注意，但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。\n4.5 json字符串json.Marshal包代码例子\ntype Movie struct &#123;\n    Title  string\n    Year   int  &#96;json:&quot;released&quot;&#96; &#x2F;&#x2F; 这个tag指定生成json名字\n    Color  bool &#96;json:&quot;color,omitempty&quot;&#96;\n    Actors []string\n&#125;\n\nvar movies &#x3D; []Movie&#123;\n    &#123;Title: &quot;Casablanca&quot;, Year: 1942, Color: false,\n        Actors: []string&#123;&quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot;&#125;&#125;,\n    &#123;Title: &quot;Cool Hand Luke&quot;, Year: 1967, Color: true,\n        Actors: []string&#123;&quot;Paul Newman&quot;&#125;&#125;,\n    &#123;Title: &quot;Bullitt&quot;, Year: 1968, Color: true,\n        Actors: []string&#123;&quot;Steve McQueen&quot;, &quot;Jacqueline Bisset&quot;&#125;&#125;,\n    &#x2F;&#x2F; ...\n&#125;\n\n4.6 文本和HTML模板(后面需要时候着重的看)text/template和html/template,们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。模板语言支持流程控制语句模板语言demo\nconst templ &#x3D; &#96;&#123;&#123;.TotalCount&#125;&#125; issues:\n&#123;&#123;range .Items&#125;&#125;----------------------------------------\nNumber: &#123;&#123;.Number&#125;&#125;\nUser:   &#123;&#123;.User.Login&#125;&#125;\nTitle:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;\nAge:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days\n&#123;&#123;end&#125;&#125;&#96;\n\n| 操作符表示将前一个表达式的结果作为后一个函数的输入.生成模板的输出需要两个处理步骤\nvar report &#x3D; template.Must(template.New(&quot;issuelist&quot;).\n    Funcs(template.FuncMap&#123;&quot;daysAgo&quot;: daysAgo&#125;).\n    Parse(templ))\n\nfunc main() &#123;\n    result, err :&#x3D; github.SearchIssues(os.Args[1:])\n    if err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n    if err :&#x3D; report.Execute(os.Stdout, result); err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n&#125;\n\n如果想转化为html则需要编写如下代码\n\nimport &quot;html&#x2F;template&quot;\n\nvar issueList &#x3D; template.Must(template.New(&quot;issuelist&quot;).Parse(&#96;\n&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;&#x2F;h1&gt;\n&lt;table&gt;\n&lt;tr style&#x3D;&#39;text-align: left&#39;&gt;\n  &lt;th&gt;#&lt;&#x2F;th&gt;\n  &lt;th&gt;State&lt;&#x2F;th&gt;\n  &lt;th&gt;User&lt;&#x2F;th&gt;\n  &lt;th&gt;Title&lt;&#x2F;th&gt;\n&lt;&#x2F;tr&gt;\n&#123;&#123;range .Items&#125;&#125;\n&lt;tr&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Number&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;&#x2F;td&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.User.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Title&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n&#123;&#123;end&#125;&#125;\n&lt;&#x2F;table&gt;\n&#96;))\n\n注意，html&#x2F;template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text&#x2F;template包的话，这2个issue将会产生错误，其中“&lt;”四个字符将会被当作小于字符“&lt;”处理，同时“”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。\n5. 函数声明和定义\n\nswitch 控制语句\nswitch cond&#123;\n  case a :\n      fmt.Printf()\n  case b :\n      fmt.Printf()\n  case c :\n      fmt.Printf()\n&#125;\n\n5.1 错误通常，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。\n我们有几种处理错误的策略\n\n发生错误时的解析器\n\n  发生解析错误后,findLinks 函数构造了一个新的异常信息,既包含了自定义的，也包含了底层解析出错的信息\n  doc, err :&#x3D; html.Parse(resp.Body)\nresp.Body.Close()\nif err !&#x3D; nil &#123;\n    return nil, fmt.Errorf(&quot;parsing %s as HTML: %v&quot;, url,err)\n&#125;\n\n  参考宇航局事故调查2. 重试  我们需要限制重试的时间间隔或重试的次数，防止无限制的重试.3. 输出错误信息并结束程序  输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行,对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序\n  if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;\n  log.Fatalf(&quot;Site is down: %v\\n&quot;, err)\n&#125;\n\n  log.Fatalf代码更简洁，并输出自定义格式信息\n\n只是输出错误信息就可以\n\n  if err :&#x3D; Ping(); err !&#x3D; nil &#123;\n  log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)\n&#125;\n&#x2F;&#x2F;或者标准错误流输出错误信息。\n\nif err :&#x3D; Ping(); err !&#x3D; nil &#123;\n    fmt.Fprintf(os.Stderr, &quot;ping failed: %v; networking disabled\\n&quot;, err)\n&#125;\n\n\n直接忽略掉错误\n\n  dir, err :&#x3D; ioutil.TempDir(&quot;&quot;, &quot;scratch&quot;)\nif err !&#x3D; nil &#123;\n    return fmt.Errorf(&quot;failed to create temp dir: %v&quot;,err)\n&#125;\n&#x2F;&#x2F; ...use temp dir…\nos.RemoveAll(dir) &#x2F;&#x2F; ignore errors; $TMPDIR is cleaned periodically\n\n  尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响\n\n文件结尾错误\n\nio包保证任何由文件结束引起的读取失败都返\npackage io\n\nimport &quot;errors&quot;\n\n&#x2F;&#x2F; EOF is the error returned by Read when no more input is available.\nvar EOF &#x3D; errors.New(&quot;EOF&quot;)\n\nin :&#x3D; bufio.NewReader(os.Stdin)\nfor &#123;\n    r, _, err :&#x3D; in.ReadRune()\n    if err &#x3D;&#x3D; io.EOF &#123;\n        break &#x2F;&#x2F; finished reading\n    &#125;\n    if err !&#x3D; nil &#123;\n        return fmt.Errorf(&quot;read failed:%v&quot;, err)\n    &#125;\n    &#x2F;&#x2F; ...use r…\n&#125;\n\n5.2 函数值\n函数在golang中也是一种类型，可以被复制给其他变量。  \n\n很熟类型的零值是nil,调用值为nil会引起panic错误  \n\n函数值之间是不可以比较的,也不能用函数值作为map的key\n\nstrings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者\nfunc add1(r rune) rune &#123; return r + 1 &#125;\n\nfmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) &#x2F;&#x2F; &quot;IBM.:111&quot;\nfmt.Println(strings.Map(add1, &quot;VMS&quot;))      &#x2F;&#x2F; &quot;WNT&quot;\nfmt.Println(strings.Map(add1, &quot;Admix&quot;))    &#x2F;&#x2F; &quot;Benjy&quot;\n\ndemo示例\n&#x2F;&#x2F;值得学习\n&#x2F;&#x2F; forEachNode针对每个结点x，都会调用pre(x)和post(x)。\n&#x2F;&#x2F; pre和post都是可选的。\n&#x2F;&#x2F; 遍历孩子结点之前，pre被调用\n&#x2F;&#x2F; 遍历孩子结点之后，post被调用\nfunc forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123;\n    if pre !&#x3D; nil &#123;\n        pre(n)\n    &#125;\n    for c :&#x3D; n.FirstChild; c !&#x3D; nil; c &#x3D; c.NextSibling &#123;\n        forEachNode(c, pre, post)\n    &#125;\n    if post !&#x3D; nil &#123;\n        post(n)\n    &#125;\n&#125;\n\n5.3 匿名函数函数内部定义的函数可以访问整个词法环境，言外之意就是嵌套的函数可以访问外层函数的变量\n&#x2F;&#x2F; squares返回一个匿名函数。\n&#x2F;&#x2F; 该匿名函数每次被调用时都会返回下一个数的平方。\n&#x2F;&#x2F;squares 函数每次都返回一个函数类型-func()int&#123;&#125;\nfunc squares() func() int &#123;\n    var x int\n    return func() int &#123; &#x2F;&#x2F; 匿名函数\n        x++\n        return x * x\n    &#125;\n&#125;\nfunc main() &#123;\n    f :&#x3D; squares()\n    fmt.Println(f()) &#x2F;&#x2F; &quot;1&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;4&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;9&quot;\n    fmt.Println(f()) &#x2F;&#x2F; &quot;16&quot;\n&#125;\n&#x2F;&#x2F;通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。\n\n\n网页抓取的核心问题就是如何遍历图\n\n警告:捕获迭代变量\nvar rmdirs []func()\nfor _, d :&#x3D; range tempDirs() &#123;\n    dir :&#x3D; d &#x2F;&#x2F; NOTE: necessary!\n    os.MkdirAll(dir, 0755) &#x2F;&#x2F; creates parent directories too\n    rmdirs &#x3D; append(rmdirs, func() &#123;\n        os.RemoveAll(dir)\n    &#125;)\n&#125;\n&#x2F;&#x2F; ...do some work…\nfor _, rmdir :&#x3D; range rmdirs &#123;\n    rmdir() &#x2F;&#x2F; clean up\n&#125;\n&#x2F;&#x2F; \nvar rmdirs []func()\nfor _, dir :&#x3D; range tempDirs() &#123;\n    os.MkdirAll(dir, 0755)\n    rmdirs &#x3D; append(rmdirs, func() &#123;\n        os.RemoveAll(dir) &#x2F;&#x2F; NOTE: incorrect!\n    &#125;)\n&#125;\n\n\n问题出在了循环变量的作用域,循环变量dir在这个词法块中被声明，每一次迭代都是会不断地更新这个值，被range语句，解决这个问题的办法就是引入同名变量来覆盖其作用域。\n5.4 可变参数简单的可变参数例子,其实可变参数就是个切片的值传递,interface&#123;&#125;表示函数的最后一个参数可以接收任意类型\nfunc sum(vals ...int) int &#123;\n    total :&#x3D; 0\n    for _, val :&#x3D; range vals &#123;\n        total +&#x3D; val\n    &#125;\n    return total\n&#125;\n\n如果原参数就是切片该怎么传递？可以直接在实参后面加省略号\n5.5 defer函数在函数执行完成之后，不管是正常退出还是异常退出函数，最后都会被执行\n5.6 panic异常当panic发生时会在该goroutine上执行defer函数，打印对应的栈信息regexp包的使用为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。\nfunc main() &#123;\n    defer printStack()\n    f(3)\n&#125;\nfunc printStack() &#123;\n    var buf [4096]byte\n    n :&#x3D; runtime.Stack(buf[:], false)\n    os.Stdout.Write(buf[:n])\n&#125;\n\n\n将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。\n5.7 Recovery捕获异常通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所\n\n语言解析器为例说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误\n\nfunc Parse(input string) (s *Syntax, err error) &#123;\n    defer func() &#123;\n        if p :&#x3D; recover(); p !&#x3D; nil &#123;\n            err &#x3D; fmt.Errorf(&quot;internal error: %v&quot;, p)\n        &#125;\n    &#125;()\n    &#x2F;&#x2F; ...parser...\n&#125;\n\n\n虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。  \n有时我们很难完全遵循规范，举个例子，net&#x2F;http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。\n\n&#x2F;&#x2F; soleTitle returns the text of the first non-empty title element\n&#x2F;&#x2F; in doc, and an error if there was not exactly one.\n&#x2F;&#x2F;防御性panic代码\nfunc soleTitle(doc *html.Node) (title string, err error) &#123;\n    type bailout struct&#123;&#125;\n    defer func() &#123;\n        switch p :&#x3D; recover(); p &#123;\n        case nil:       &#x2F;&#x2F; no panic\n        case bailout&#123;&#125;: &#x2F;&#x2F; &quot;expected&quot; panic\n            err &#x3D; fmt.Errorf(&quot;multiple title elements&quot;)\n        default:\n            panic(p) &#x2F;&#x2F; unexpected panic; carry on panicking\n        &#125;\n    &#125;()\n    &#x2F;&#x2F; Bail out of recursion if we find more than one nonempty title.\n    forEachNode(doc, func(n *html.Node) &#123;\n        if n.Type &#x3D;&#x3D; html.ElementNode &amp;&amp; n.Data &#x3D;&#x3D; &quot;title&quot; &amp;&amp;\n            n.FirstChild !&#x3D; nil &#123;\n            if title !&#x3D; &quot;&quot; &#123;\n                panic(bailout&#123;&#125;) &#x2F;&#x2F; multiple titleelements\n            &#125;\n            title &#x3D; n.FirstChild.Data\n        &#125;\n    &#125;, nil)\n    if title &#x3D;&#x3D; &quot;&quot; &#123;\n        return &quot;&quot;, fmt.Errorf(&quot;no title element&quot;)\n    &#125;\n    return title, nil\n&#125;\n\n6. 方法6.1 方法声明\n普通函数与接收器方法接收器因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。对于一个给定的类型，其内部的方法都必须有唯一的方法名\n\n6.2 基于指针对象的方法\n不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。\n\n在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。\n\n当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们下面例子里做的这样\n  func (list *IntList) Sum() int &#123;\nif list &#x3D;&#x3D; nil &#123;\n    return 0\n&#125;\nreturn list.Value + list.Tail.Sum()\n&#125;\n\n  如果此时结构体是nil调用对象可能会发生类似于空指针异常的错误\n\n\n6.3. 通过嵌入结构体来扩展类型\n方法值  在go语言中，方法是第一公民，这一点在函数式编程中非常实用(maybe)\n  &#x2F;&#x2F;方法值demo\np :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;4, 6&#125;\n\ndistanceFromP :&#x3D; p.Distance        &#x2F;&#x2F; method value,Distance是结构体方法\nfmt.Println(distanceFromP(q))      &#x2F;&#x2F; &quot;5&quot;\nvar origin Point                   &#x2F;&#x2F; &#123;0, 0&#125;\nfmt.Println(distanceFromP(origin)) &#x2F;&#x2F; &quot;2.23606797749979&quot;, sqrt(5)\n\nscaleP :&#x3D; p.ScaleBy &#x2F;&#x2F; method value\nscaleP(2)           &#x2F;&#x2F; p becomes (2, 4)\nscaleP(3)           &#x2F;&#x2F;      then (6, 12)\nscaleP(10)          &#x2F;&#x2F;      then (60, 120)\n\n方法表达式  在面向对象中，当根据哪一个变量来决定调用哪个函数时候,方法表达式就很有用了.\n  p :&#x3D; Point&#123;1, 2&#125;\nq :&#x3D; Point&#123;4, 6&#125;\n\ndistance :&#x3D; Point.Distance   &#x2F;&#x2F; method expression\nfmt.Println(distance(p, q))  &#x2F;&#x2F; &quot;5&quot;\nfmt.Printf(&quot;%T\\n&quot;, distance) &#x2F;&#x2F; &quot;func(Point, Point) float64&quot;\n\nscale :&#x3D; (*Point).ScaleBy\nscale(&amp;p, 2)\nfmt.Println(p)            &#x2F;&#x2F; &quot;&#123;2 4&#125;&quot;\nfmt.Printf(&quot;%T\\n&quot;, scale) &#x2F;&#x2F; &quot;func(*Point, float64)&quot;\n\n\npractice demo\ntype Point struct&#123; X, Y float64 &#125;\n\nfunc (p Point) Add(q Point) Point &#123; return Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;\nfunc (p Point) Sub(q Point) Point &#123; return Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;\n\ntype Path []Point\n\nfunc (path Path) TranslateBy(offset Point, add bool) &#123;\n    var op func(p, q Point) Point\n    if add &#123;\n        op &#x3D; Point.Add\n    &#125; else &#123;\n        op &#x3D; Point.Sub\n    &#125;\n    for i :&#x3D; range path &#123;\n        &#x2F;&#x2F; Call either path[i].Add(offset) or path[i].Sub(offset).\n        path[i] &#x3D; op(path[i], offset)\n    &#125;\n&#125;\n\n6.4 封装封装提供了三方面的优点。\n\n首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可.\n\n第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由\n\nbytes.Buffer这个类型作为例子来考虑\n \ntype Buffer struct &#123;\nbuf     []byte\ninitial [64]byte\n&#x2F;* ... *&#x2F;\n&#125;\n\n&#x2F;&#x2F; Grow expands the buffer&#39;s capacity, if necessary,\n&#x2F;&#x2F; to guarantee space for another n bytes. [...]\nfunc (b *Buffer) Grow(n int) &#123;\n    if b.buf &#x3D;&#x3D; nil &#123;\n        b.buf &#x3D; b.initial[:0] &#x2F;&#x2F; use preallocated space initially\n    &#125;\n    if len(b.buf)+n &gt; cap(b.buf) &#123;\n        buf :&#x3D; make([]byte, b.Len(), 2*cap(b.buf) + n)\n        copy(buf, b.buf)\n        b.buf &#x3D; buf\n    &#125;\n&#125;\n&#x2F;&#x2F; Grow()函数式导出类型，但是stuct的字段不是到处类型\n\n只暴漏关键信息给外部使用者\n\n\n7. 接口很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用  \n只要一个物体能像鸭子一样叫那我们就可以称它为鸭子；只要一个软件能存储和查询数据我们就可以称它为数据库；只要一台机器有洗衣服和甩干的功能我们就可以称它为洗衣机。  \n为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型\n7.1. 接口约定例如fmt包\npackage fmt\n\nfunc Fprintf(w io.Writer, format string, args ...interface&#123;&#125;) (int, error)\n&#x2F;&#x2F;Printf 最后调用Fprintf 函数\nfunc Printf(format string, args ...interface&#123;&#125;) (int, error) &#123;\n    return Fprintf(os.Stdout, format, args...)\n&#125;\n&#x2F;&#x2F; Sprintf函数最后也是调用Fprintf\nfunc Sprintf(format string, args ...interface&#123;&#125;) string &#123;\n    var buf bytes.Buffer\n    Fprintf(&amp;buf, format, args...)\n    return buf.String()\n&#125;\n\nFprintf函数的F说明了文件类型也说明了所有信息要被写入到文件当中，在Printf函数中的第一个参数os.Stdout是*os.File类型实现了io.Writer接口，在Sprintf函数中的第一个参数&amp;buf是一个指向可以写入字节的内存缓冲区也该类型也是实现了io.Writer接口,用户可以自定义一个函数并实现io.Writer接口。LSP里氏替换 : fmt.Fprintf通过使用接口类型io.Writer使得只要调用者只要传入实现了该接口的类型就可以实现自由替换\n自定义bytecounter函数，实现计算int转byte长度\n\n\npackage main\n\nimport (\n &quot;fmt&quot;\n)\n\n&#x2F;&#x2F;!+bytecounter\n\ntype ByteCounter int\n\nfunc (c *ByteCounter) Write(p []byte) (int, error) &#123;\n *c +&#x3D; ByteCounter(len(p)) &#x2F;&#x2F; convert int to ByteCounter\n return len(p), nil\n&#125;\n\n&#x2F;&#x2F;!-bytecounter\n\nfunc main() &#123;\n &#x2F;&#x2F;!+main\n var c ByteCounter\n c.Write([]byte(&quot;hello&quot;))\n fmt.Println(c) &#x2F;&#x2F; &quot;5&quot;, &#x3D; len(&quot;hello&quot;)\n\n c &#x3D; 0 &#x2F;&#x2F; reset the counter\n var name &#x3D; &quot;Dolly&quot;\n fmt.Fprintf(&amp;c, &quot;hello, %s&quot;, name)\n fmt.Println(c) &#x2F;&#x2F; &quot;12&quot;, &#x3D; len(&quot;hello, Dolly&quot;)\n &#x2F;&#x2F;!-main\n&#125;\n\n\n\n因为它实现了writer接口就可以传入到Fprintf函数中.总结来说，接口约定了包使用者的行为，但是使用者想创建什么样的实例需要他自己去实现。\n7.2 接口类型通过组合定义接口\npackage io\ntype Reader interface &#123;\n    Read(p []byte) (n int, err error)\n&#125;\ntype Closer interface &#123;\n    Close() error\n&#125;\n\ntype ReadWriter interface &#123;\n    Reader\n    Writer\n&#125;\ntype ReadWriteCloser interface &#123;\n    Reader\n    Writer\n    Closer\n&#125;\n&#x2F;&#x2F; 另一种命名风格\ntype ReadWriter interface &#123;\n    Read(p []byte) (n int, err error)\n    Write(p []byte) (n int, err error)\n&#125;\n&#x2F;&#x2F;或者甚至使用一种混合的风格：\n\ntype ReadWriter interface &#123;\n    Read(p []byte) (n int, err error)\n    Writer\n&#125;\n\n7.3 实现接口的条件\n一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口.\n  var w io.Writer\n&#x2F;&#x2F;只实现了Write 方法\nw &#x3D; os.Stdout           &#x2F;&#x2F; OK: *os.File has Write method\n&#x2F;&#x2F;只实现了Write方法\nw &#x3D; new(bytes.Buffer)   &#x2F;&#x2F; OK: *bytes.Buffer has Write method\n&#x2F;&#x2F; time.Duration没有Write方法\nw &#x3D; time.Second         &#x2F;&#x2F; compile error: time.Duration lacks Write method\n\nvar rwc io.ReadWriteCloser\nrwc &#x3D; os.Stdout         &#x2F;&#x2F; OK: *os.File has Read, Write, Close methods\nrwc &#x3D; new(bytes.Buffer) &#x2F;&#x2F; compile error: *bytes.Buffer lacks Close method\n&#x2F;&#x2F; 这个规则甚至适用于等式右边本身也是一个接口类型\n&#x2F;&#x2F; rwc io.ReadWriteCloser\nw &#x3D; rwc                 &#x2F;&#x2F; OK: io.ReadWriteCloser has Write method\n&#x2F;&#x2F; w 只有Write方法\nrwc &#x3D; w                 &#x2F;&#x2F; compile error: io.Writer lacks Close method\n\n\n\n7.4 flag.Value接口在linux程序中，你会发现很多程序都支持选项，通过带上参数，程序会有很多丰富的功能比如下面demo就是简单的打印选项-period后面的值。\nvar period &#x3D; flag.Duration(&quot;period&quot;, 1*time.Second, &quot;sleep period&quot;)\n\nfunc main() &#123;\n    flag.Parse()\n    fmt.Printf(&quot;Sleeping for %v...&quot;, *period)\n    time.Sleep(*period)\n    fmt.Println()\n&#125;\n\n这里golang的flag包提供了这种功能，我们可以通过实现flag的接口自定义新的标记符号\npackage flag\n\n&#x2F;&#x2F; Value is the interface to the value stored in a flag.\ntype Value interface &#123;\n    String() string\n    Set(string) error\n&#125;\n\n\nstring() string方法格式化标记的值Set(string) error 解析它的字符串参数，并更新标记变量的值让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的celsiusFlag类型。注意celsiusFlag内嵌了一个Celsius类型，因此不用实现本身就已经有String方法了。为了实现flag.Value，我们只需要定义Set方法：代码demo如下\n\n自定义新的标记符号\n  温度的转化\n\n  package tempconv\n\nimport (\n    &quot;flag&quot;\n    &quot;fmt&quot;\n)\n\ntype Celsius float64\ntype Fahrenheit float64\n\nfunc CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9.0&#x2F;5.0 + 32.0) &#125;\nfunc FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32.0) * 5.0 &#x2F; 9.0) &#125;\n\nfunc (c Celsius) String() string &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125;\n\n&#x2F;*\n&#x2F;&#x2F;!+flagvalue\npackage flag\n\n&#x2F;&#x2F; Value is the interface to the value stored in a flag.\ntype Value interface &#123;\n    String() string\n    Set(string) error\n&#125;\n&#x2F;&#x2F;!-flagvalue\n*&#x2F;\n\n&#x2F;&#x2F;!+celsiusFlag\n&#x2F;&#x2F; *celsiusFlag satisfies the flag.Value interface.\ntype celsiusFlag struct&#123; Celsius &#125;\n\nfunc (f *celsiusFlag) Set(s string) error &#123;\n    var unit string\n    var value float64\n    fmt.Sscanf(s, &quot;%f%s&quot;, &amp;value, &amp;unit) &#x2F;&#x2F; no error check needed\n    switch unit &#123;\n    case &quot;C&quot;, &quot;°C&quot;:\n        f.Celsius &#x3D; Celsius(value)\n        return nil\n    case &quot;F&quot;, &quot;°F&quot;:\n        f.Celsius &#x3D; FToC(Fahrenheit(value))\n        return nil\n    &#125;\n    return fmt.Errorf(&quot;invalid temperature %q&quot;, s)\n&#125;\n\n&#x2F;&#x2F;!-celsiusFlag\n\n&#x2F;&#x2F;!+CelsiusFlag\n\n&#x2F;&#x2F; CelsiusFlag defines a Celsius flag with the specified name,\n&#x2F;&#x2F; default value, and usage, and returns the address of the flag variable.\n&#x2F;&#x2F; The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.\nfunc CelsiusFlag(name string, value Celsius, usage string) *Celsius &#123;\n    f :&#x3D; celsiusFlag&#123;value&#125;\n    flag.CommandLine.Var(&amp;f, name, usage)\n    return &amp;f.Celsius\n&#125;\n&#x2F;&#x2F; main函数\nvar temp &#x3D; tempconv.CelsiusFlag(&quot;temp&quot;, 20.0, &quot;the temperature&quot;)\n\nfunc main() &#123;\n    flag.Parse()\n    fmt.Println(*temp)\n&#125;\n\n  \n\n  url解析\n  \npackage main\n\nimport (\n    &quot;flag&quot;\n    &quot;fmt&quot;\n    &quot;net&#x2F;url&quot;\n)\n\ntype URLValue struct &#123;\n    URL *url.URL\n&#125;\n\nfunc (v URLValue) String() string &#123;\n    if v.URL !&#x3D; nil &#123;\n        return v.URL.String()\n    &#125;\n    return &quot;&quot;\n&#125;\n\nfunc (v URLValue) Set(s string) error &#123;\n    if u, err :&#x3D; url.Parse(s); err !&#x3D; nil &#123;\n        return err\n    &#125; else &#123;\n        *v.URL &#x3D;*u\n    &#125;\n    return nil\n&#125;\n\nvar u &#x3D; &amp;url.URL&#123;&#125;\n\nfunc main() &#123;\n    fs :&#x3D; flag.NewFlagSet(&quot;ExampleValue&quot;, flag.ExitOnError)\n    fs.Var(&amp;URLValue&#123;u&#125;, &quot;url&quot;, &quot;URL to parse&quot;)\n\n    fs.Parse([]string&#123;&quot;-url&quot;, &quot;https:&#x2F;&#x2F;golang.org&#x2F;pkg&#x2F;flag&#x2F;&quot;&#125;)\n    fmt.Printf(\\&#96;&#123;scheme: %q, host: %q, path: %q&#125;\\&#96;, u.Scheme, u.Host, u.Path)\n\n&#125;\n\n\n  \n\n7.5 接口值概念上讲接口的值,由两部分组成,是其类型(值)和具体类型的值,他们的组合被称为接口的动态类型和动态值.对于像Go语言这种静态类型的语言,类型是编译期的概念;因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。下面语句中，变量w得到了3个不同的值,他们三个的值都是相同的\nvar w io.Writer &#x2F;&#x2F;接口type Write\nw &#x3D; os.Stdout &#x2F;&#x2F; 最后返回的是*file类型,func (f *File) Write(b []byte) (n int, err error)\nw &#x3D; new(bytes.Buffer) &#x2F;&#x2F; func (b *Buffer) Write(p []byte) (n int, err error)\nw &#x3D; nil &#x2F;&#x2F; 动态类型和动态值都为空\n\nvar a *bytes.Buffer &#x2F;&#x2F;接口*bytes.Buffer\na &#x3D; nil               &#x2F;&#x2F; 动态类型不为空和动态值都为空\nfmt.Printf(&quot;%T\\n&quot;, a) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;\n\nvar w io.Writer\n\n\n在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil（图7.1）。\n一个接口值基于它的动态类型被描述为nil或!nil，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生panic:\nw.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; panic: nil pointer dereference\n\n\n如果是接口类型定义的变量那么它的动态类型和动态值都是nil，赋nil之后动态类型和动态值也全都是nil值，\n但是指针,基本类型和复合类型不会.\n\n类似于java一样，不能没有对象就调用方法，会报空指针异常,上面代码在第三行动态值写为nil这里面有个细节要明白，定义语句var w io.Writer(接口类型),其实是动态类型和动态值都是nil,进行布尔判断的时候才是为nil,w &#x3D; nil 是将动态类型和动态值都设置成nil\n\n\n第二个语句将一个*os.File类型的值赋给变量w:\nw &#x3D; os.Stdout\n\n这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为*os.File指针的类型描述符，它的动态值持有os.Stdout的拷贝;这是一个代表处理标准输出的os.File类型变量的指针7.2\n\n在第二行的赋值操作中,type已经变成`*os.file`类型,其实上面说的很啰嗦,直接就是os.Stdout是具\n体的*file类型实现了io.Writer接口\n\n\n调用一个包含*os.File类型指针的接口值的Write方法，使得(*os.File).Write方法被调用。这个调用输出“hello”。\nw.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;\n\n通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样：\nos.Stdout.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;\n\n第三个语句给接口值赋了一个*bytes.Buffer类型的值\nw &#x3D; new(bytes.Buffer)\n\n现在动态类型是*bytes.Buffer,并且动态值是一个指向新分配的缓冲区的指针Write方法的调用也使用了和之前一样的机制:\nw.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; writes &quot;hello&quot; to the bytes.Buffers\n\n这次类型描述符是*bytes.Buffer，所以调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。最后，第四个语句将nil赋给了接口值:\nw &#x3D; nil\n\n这个重置将它所有的部分都设为nil值,把变量w恢复到和它之前定义时相同的状态，在图7.1中可以看到。\n一个接口值可以持有任意大的动态值。例如,表示时间实例的time.Time类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值:\nvar x interface&#123;&#125; &#x3D; time.Now()\n\n\n这里就是创建了一个接口类型的x值,然后可以引用任何类型值\n\n\n结果可能和图7.4相似。从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型;具体的实现可能会非常不同）\n\n接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。\n然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:\n\n\n注意到原话’它们的动态类型相同并且动态值,就可以进行==操作’,要保证动态类型相等,动态值相等,则A&#x3D;&#x3D;A那么基本类型相同,复杂类型地址相等\n\n\n考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型(如基本类型和指针)要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。  \n当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用fmt包的%T动作:\n\nvar w io.Writer\nfmt.Printf(&quot;%T\\n&quot;, w) &#x2F;&#x2F; &quot;&lt;nil&gt;&quot;\nw &#x3D; os.Stdout\nfmt.Printf(&quot;%T\\n&quot;, w) &#x2F;&#x2F; &quot;*os.File&quot;\nw &#x3D; new(bytes.Buffer)\nfmt.Printf(&quot;%T\\n&quot;, w) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;\nvar buf *bytes.Buffer\nfmt.Printf(&quot;%T\\n&quot;, buf) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;\nvar x interface&#123;&#125;\nfmt.Printf(&quot;%T\\n&quot;, x) &#x2F;&#x2F; &quot;&lt;nil&gt;&quot;\n&#x2F;&#x2F; 另一个接口值相等的case\nw :&#x3D; new(bytes.Buffer)\nfmt.Printf(&quot;%T\\n&quot;, w) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;\nvar buf *bytes.Buffer\nfmt.Printf(&quot;%T\\n&quot;, buf) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;\nw &#x3D; &amp;bytes.Buffer&#123;&#125;\nbuf &#x3D; &amp;bytes.Buffer&#123;&#125;\nw!&#x3D;buf\n\n\n7.5.1. 警告:一个包含nil指针的接口不是nil接口一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。\n思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。\nconst debug &#x3D; true\n\nfunc main() &#123;\n    var buf *bytes.Buffer\n    if debug &#123;\n        buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output\n    &#125;\n    f(buf) &#x2F;&#x2F; NOTE: subtly incorrect!\n    if debug &#123;\n        &#x2F;&#x2F; ...use buf...\n    &#125;\n&#125;\n\n&#x2F;&#x2F; If out is non-nil, output will be written to it.\nfunc f(out io.Writer) &#123;\n    &#x2F;&#x2F; ...do something...\n    if out !&#x3D; nil &#123;\n        out.Write([]byte(&quot;done!\\n&quot;))\n    &#125;\n&#125;\n\n\n我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：\nif out !&#x3D; nil &#123;\n    out.Write([]byte(&quot;done!\\n&quot;)) &#x2F;&#x2F; panic: nil pointer dereference\n&#125;\n\n当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!&#x3D;nil的结果依然是true。\n\n动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者（§6.2.1），但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。\n问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：\nvar buf io.Writer &#x2F;&#x2F; 这时候是空指针，没有具体值(对象)\nif debug &#123;\n    buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output\n&#125;\nf(buf) &#x2F;&#x2F; OK\n\n\n&#x2F;&#x2F; If out is non-nil, output will be written to it.\nfunc f(out io.Writer) &#123;\n    &#x2F;&#x2F; ...do something...\n    if out !&#x3D; nil &#123; &#x2F;&#x2F; 此处判断out为nil\n        out.Write([]byte(&quot;done!\\n&quot;))\n    &#125;\n&#125;\n\n\n总结一句话就是动态类型不为nil,动态值为nil,这个变量也是不要nil\n\n\n7.6. sort.Interface接口排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要15行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。\n幸运的是，sort包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。相比之下，Go语言的sort.Sort函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型sort.Interface来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。\n一个内置的排序算法需要知道三个东西：\n\n序列的长度\n表示两个元素比较的结果，\n一种交换两个元素的方式；\n\n这就是sort.Interface的三个方法：\npackage sort\n\ntype Interface interface &#123;\n    Len() int\n    Less(i, j int) bool &#x2F;&#x2F; i, j are indices of sequence elements\n    Swap(i, j int)\n&#125;\n\n为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用sort.Sort函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型StringSlice和它的Len,Less和Swap方法\ntype StringSlice []string\nfunc (p StringSlice) Len() int           &#123; return len(p) &#125;\nfunc (p StringSlice) Less(i, j int) bool &#123; return p[i] &lt; p[j] &#125;\nfunc (p StringSlice) Swap(i, j int)      &#123; p[i], p[j] &#x3D; p[j], p[i] &#125;\n\n现在我们可以通过像下面这样将一个切片转换为一个StringSlice类型来进行排序：sort.Sort(StringSlice(names)),这个转换得到一个相同长度，容量，和基于names数组的切片值;并且这个切片值的类型有三个排序需要的方法。\n对字符串切片的排序是很常用的需要，所以sort包提供了StringSlice类型，也提供了Strings函数能让上面这些调用简化成sort.Strings(names)\n这里用到的技术很容易适用到其它排序序列中，例如我们可以忽略大小写或者含有的特殊字符。（本书使用Go程序对索引词和页码进行排序也用到了这个技术，对罗马数字做了额外逻辑处理。）对于更复杂的排序，我们使用相同的方法，但是会用更复杂的数据结构和更复杂地实现sort.Interface的方法。\n我们会运行上面的例子来对一个表格中的音乐播放列表进行排序。每个track都是单独的一行，每一列都是这个track的属性像艺术家，标题，和运行时间。想象一个图形用户界面来呈现这个表格，并且点击一个属性的顶部会使这个列表按照这个属性进行排序；再一次点击相同属性的顶部会进行逆向排序。让我们看下每个点击会发生什么响应。\n下面的变量tracks包含了一个播放列表.(One of the authors apologizes for the other author’s musical tastes)每个元素都不是Track本身而是指向它的指针。尽管我们在下面的代码中直接存储Tracks也可以工作，sort函数会交换很多对元素，所以如果每个元素都是指针而不是Track类型会更快，指针是一个机器字码长度而Track类型可能是八个或更多。\ngopl.io&#x2F;ch7&#x2F;sorting\n\n\ntype Track struct &#123;\n    Title  string\n    Artist string\n    Album  string\n    Year   int\n    Length time.Duration\n&#125;\n\nvar tracks &#x3D; []*Track&#123;\n    &#123;&quot;Go&quot;, &quot;Delilah&quot;, &quot;From the Roots Up&quot;, 2012, length(&quot;3m38s&quot;)&#125;,\n    &#123;&quot;Go&quot;, &quot;Moby&quot;, &quot;Moby&quot;, 1992, length(&quot;3m37s&quot;)&#125;,\n    &#123;&quot;Go Ahead&quot;, &quot;Alicia Keys&quot;, &quot;As I Am&quot;, 2007, length(&quot;4m36s&quot;)&#125;,\n    &#123;&quot;Ready 2 Go&quot;, &quot;Martin Solveig&quot;, &quot;Smash&quot;, 2011, length(&quot;4m24s&quot;)&#125;,\n&#125;\n\nfunc length(s string) time.Duration &#123;\n    d, err :&#x3D; time.ParseDuration(s)\n    if err !&#x3D; nil &#123;\n        panic(s)\n    &#125;\n    return d\n&#125;\n\nprintTracks函数将播放列表打印成一个表格。一个图形化的展示可能会更好点，但是这个小程序使用text/tabwriter包来生成一个列整齐对齐和隔开的表格，像下面展示的这样。注意到*tabwriter.Writer是满足io.Writer接口的。它会收集每一片写向它的数据；它的Flush方法会格式化整个表格并且将它写向os.Stdout（标准输出）。\nfunc printTracks(tracks []*Track) &#123;\n    const format &#x3D; &quot;%v\\t%v\\t%v\\t%v\\t%v\\t\\n&quot;\n    tw :&#x3D; new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, &#39; &#39;, 0)\n    fmt.Fprintf(tw, format, &quot;Title&quot;, &quot;Artist&quot;, &quot;Album&quot;, &quot;Year&quot;, &quot;Length&quot;)\n    fmt.Fprintf(tw, format, &quot;-----&quot;, &quot;------&quot;, &quot;-----&quot;, &quot;----&quot;, &quot;------&quot;)\n    for _, t :&#x3D; range tracks &#123;\n        fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)\n    &#125;\n    tw.Flush() &#x2F;&#x2F; calculate column widths and print table\n&#125;\n\n为了能按照Artist字段对播放列表进行排序，我们会像对StringSlice那样定义一个新的带有必须的Len，Less和Swap方法的切片类型。\n&#x2F;&#x2F;装*Track的数组\ntype byArtist []*Track\nfunc (x byArtist) Len() int           &#123; return len(x) &#125;\nfunc (x byArtist) Less(i, j int) bool &#123; return x[i].Artist &lt; x[j].Artist &#125;\nfunc (x byArtist) Swap(i, j int)      &#123; x[i], x[j] &#x3D; x[j], x[i] &#125;\n\n为了调用通用的排序程序，我们必须先将tracks转换为新的byArtist类型，它定义了具体的排序：sort.Sort(byArtist(tracks))(tracks和byArtist类型相同都是[]*Track)在按照artist对这个切片进行排序后，printTrack的输出如下\nTitle       Artist          Album               Year Length\n-----       ------          -----               ---- ------\nGo Ahead    Alicia Keys     As I Am             2007 4m36s\nGo          Delilah         From the Roots Up   2012 3m38s\nReady 2 Go  Martin Solveig  Smash               2011 4m24s\nGo          Moby            Moby                1992 3m37s\n\n如果用户第二次请求”按照artist排序”,我们会对tracks进行逆向排序。然而我们不需要定义一个有颠倒Less方法的新类型byReverseArtist，因为sort包中提供了Reverse函数将排序顺序转换成逆序。sort.Sort(sort.Reverse(byArtist(tracks)))在按照artist对这个切片进行逆向排序后，printTrack的输出如下\nTitle       Artist          Album               Year Length\n-----       ------          -----               ---- ------\nGo          Moby            Moby                1992 3m37s\nReady 2 Go  Martin Solveig  Smash               2011 4m24s\nGo          Delilah         From the Roots Up   2012 3m38s\nGo Ahead    Alicia Keys     As I Am             2007 4m36s\n\nsort.Reverse函数值得进行更近一步的学习，因为它使用了（§6.3）章中的组合，这是一个重要的思路。sort包定义了一个不公开的struct类型reverse，它嵌入了一个sort.Interface。reverse的Less方法调用了内嵌的sort.Interface值的Less方法，但是通过交换索引的方式使排序结果变成逆序。\npackage sort\n\ntype reverse struct&#123; Interface &#125; &#x2F;&#x2F; that is, sort.Interface\n\nfunc (r reverse) Less(i, j int) bool &#123; return r.Interface.Less(j, i) &#125;\n\nfunc Reverse(data Interface) Interface &#123; return reverse&#123;data&#125; &#125;\n\nreverse的另外两个方法Len和Swap隐式地由原有内嵌的sort.Interface提供。因为reverse是一个不公开的类型，所以导出函数Reverse返回一个包含原有sort.Interface值的reverse类型实例。\n为了可以按照不同的列进行排序，我们必须定义一个新的类型例如byYear:\ntype byYear []*Track\nfunc (x byYear) Len() int           &#123; return len(x) &#125;\nfunc (x byYear) Less(i, j int) bool &#123; return x[i].Year &lt; x[j].Year &#125;\nfunc (x byYear) Swap(i, j int)      &#123; x[i], x[j] &#x3D; x[j], x[i] &#125;\n\n在使用sort.Sort(byYear(tracks))按照年对tracks进行排序后，printTrack展示了一个按时间先后顺序的列表：\nTitle       Artist          Album               Year Length\n-----       ------          -----               ---- ------\nGo          Moby            Moby                1992 3m37s\nGo Ahead    Alicia Keys     As I Am             2007 4m36s\nReady 2 Go  Martin Solveig  Smash               2011 4m24s\nGo          Delilah         From the Roots Up   2012 3m38s\n\n对于我们需要的每个切片元素类型和每个排序函数，我们需要定义一个新的sort.Interface实现。如你所见，Len和Swap方法对于所有的切片类型都有相同的定义。下个例子，具体的类型customSort会将一个切片和函数结合，使我们只需要写比较函数就可以定义一个新的排序.顺便说下,实现了sort.Interface的具体类型不一定是切片类型；customSort是一个结构体类型\ntype customSort struct &#123;\n    t    []*Track\n    less func(x, y *Track) bool\n&#125;\n\nfunc (x customSort) Len() int           &#123; return len(x.t) &#125;\nfunc (x customSort) Less(i, j int) bool &#123; return x.less(x.t[i], x.t[j]) &#125;\nfunc (x customSort) Swap(i, j int) &#123; x.t[i], x.t[j] &#x3D; x.t[j], x.t[i] &#125;\n\n让我们定义一个多层的排序函数，它主要的排序键是标题，第二个键是年，第三个键是运行时间Length。下面是该排序的调用，其中这个排序使用了匿名排序函数：\nsort.Sort(customSort&#123;tracks, func(x, y *Track) bool &#123;\n    if x.Title !&#x3D; y.Title &#123;\n        return x.Title &lt; y.Title\n    &#125;\n    if x.Year !&#x3D; y.Year &#123;\n        return x.Year &lt; y.Year\n    &#125;\n    if x.Length !&#x3D; y.Length &#123;\n        return x.Length &lt; y.Length\n    &#125;\n    return false\n&#125;&#125;)\n\n这下面是排序的结果。注意到两个标题是“Go”的track按照标题排序是相同的顺序，但是在按照year排序上更久的那个track优先。\n\nTitle       Artist          Album               Year Length\n-----       ------          -----               ---- ------\nGo          Moby            Moby                1992 3m37s\nGo          Delilah         From the Roots Up   2012 3m38s\nGo Ahead    Alicia Keys     As I Am             2007 4m36s\nReady 2 Go  Martin Solveig  Smash               2011 4m24s\n\n尽管对长度为n的序列排序需要 O(n log n)次比较操作，检查一个序列是否已经有序至少需要n-1次比较。sort包中的IsSorted函数帮我们做这样的检查。像sort.Sort一样，它也使用sort.Interface对这个序列和它的排序函数进行抽象，但是它从不会调用Swap方法：这段代码示范了IntsAreSorted和Ints函数在IntSlice类型上的使用：\nvalues :&#x3D; []int&#123;3, 1, 4, 1&#125;\nfmt.Println(sort.IntsAreSorted(values)) &#x2F;&#x2F; &quot;false&quot;\nsort.Ints(values)\nfmt.Println(values)                     &#x2F;&#x2F; &quot;[1 1 3 4]&quot;\nfmt.Println(sort.IntsAreSorted(values)) &#x2F;&#x2F; &quot;true&quot;\nsort.Sort(sort.Reverse(sort.IntSlice(values)))\nfmt.Println(values)                     &#x2F;&#x2F; &quot;[4 3 1 1]&quot;\nfmt.Println(sort.IntsAreSorted(values)) &#x2F;&#x2F; &quot;false&quot;\n\n为了使用方便，sort包为[]int、[]string和[]float64的正常排序提供了特定版本的函数和类型。对于其他类型，例如[]int64或者[]uint，尽管路径也很简单，还是依赖我们自己实现。\n练习 7.8： 很多图形界面提供了一个有状态的多重排序表格插件：主要的排序键是最近一次点击过列头的列，第二个排序键是第二最近点击过列头的列，等等。定义一个sort.Interface的实现用在这样的表格中。比较这个实现方式和重复使用sort.Stable来排序的方式。\n练习 7.9： 使用html&#x2F;template包（§4.6）替代printTracks将tracks展示成一个HTML表格。将这个解决方案用在前一个练习中，让每次点击一个列的头部产生一个HTTP请求来排序这个表格。\n练习 7.10： sort.Interface类型也可以适用在其它地方。编写一个IsPalindrome(s sort.Interface) bool函数表明序列s是否是回文序列，换句话说反向排序不会改变这个序列。假设如果!s.Less(i, j) &amp;&amp; !s.Less(j, i)则索引i和j上的元素相等。\nsummary: \n\n对于字符串排序golang提供了sort.Strings()方法对字符串排序\n更复杂的数据结构和更复杂地实现sort.Interface的方法,要实现less(x int,y int) bool,len() int,swap(x int,y int)方法\n学习如何把信息输出到stdout通过实现writer接口\ncustomSort是Track的自定义排序实现.避免针对不同排序,重复实现排序接口\nsort包中isSorted功能,能够检查数据是否有序 - 要学习下sort和总结下sort包\n\n7.7. http.Handler接口在第一章中,我们粗略的了解了怎么用net/http包去实现网络客户端（§1.5）和服务器（§1.7）。在这个小节中，我们会对那些基于http.Handler接口的服务器API做更进一步的学习：\nnet&#x2F;http\npackage http\n\ntype Handler interface &#123;\n    ServeHTTP(w ResponseWriter, r *Request)\n&#125;\n\nfunc ListenAndServe(address string, h Handler) error\n\nListenAndServe函数需要一个例如’localhost:8000’的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。\n想象一个电子商务网站，为了销售，将数据库中物品的价格映射成美元。下面这个程序可能是能想到的最简单的实现了。它将库存清单模型化为一个命名为database的map类型，我们给这个类型一个ServeHttp方法,这样它可以满足http.Handler接口。这个handler会遍历整个map并输出物品信息\ngopl.io&#x2F;ch7&#x2F;http1\n\n\nfunc main() &#123;\n    db :&#x3D; database&#123;&quot;shoes&quot;: 50, &quot;socks&quot;: 5&#125;\n    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, db))\n&#125;\n\ntype dollars float32\n\nfunc (d dollars) String() string &#123; return fmt.Sprintf(&quot;$%.2f&quot;, d) &#125;\n\ntype database map[string]dollars\n\nfunc (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;\n    for item, price :&#x3D; range db &#123;\n        fmt.Fprintf(w, &quot;%s: %s\\n&quot;, item, price)\n    &#125;\n&#125;\n\n如果我们启动这个服务，\ngo build gopl.io&#x2F;ch7&#x2F;http1\n.&#x2F;http1 &amp;\n\n然后用1.5节中的获取程序（如果你更喜欢可以使用web浏览器）来连接服务器，我们得到下面的输出：\n$ go build gopl.io&#x2F;ch1&#x2F;fetch\n$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000\nshoes: $50.00\nsocks: $5.00\n\n目前为止，这个服务器不考虑URL，只能为每个请求列出它全部的库存清单。更真实的服务器会定义多个不同的URL，每一个都会触发一个不同的行为。让我们使用/list来调用已经存在的这个行为并且增加另一个/price调用表明单个货品的价格，像这样/price?item=socks来指定一个请求参数。\ngopl.io&#x2F;ch7&#x2F;http2\n\n\nfunc (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;\n    switch req.URL.Path &#123;\n    case &quot;&#x2F;list&quot;:\n        for item, price :&#x3D; range db &#123;\n            fmt.Fprintf(w, &quot;%s: %s\\n&quot;, item, price)\n        &#125;\n    case &quot;&#x2F;price&quot;:\n        item :&#x3D; req.URL.Query().Get(&quot;item&quot;)\n        price, ok :&#x3D; db[item]\n        if !ok &#123;\n            w.WriteHeader(http.StatusNotFound) &#x2F;&#x2F; 404\n            fmt.Fprintf(w, &quot;no such item: %q\\n&quot;, item)\n            return\n        &#125;\n        fmt.Fprintf(w, &quot;%s\\n&quot;, price)\n    default:\n        w.WriteHeader(http.StatusNotFound) &#x2F;&#x2F; 404\n        fmt.Fprintf(w, &quot;no such page: %s\\n&quot;, req.URL)\n    &#125;\n&#125;\n\n现在handler基于URL的路径部分(req.URL.Path)来决定执行什么逻辑。如果这个handler不能识别这个路径，它会通过调用w.WriteHeader(http.StatusNotFound)返回客户端一个HTTP错误；这个检查应该在向w写入任何值前完成。（顺便提一下，http.ResponseWriter是另一个接口。它在io.Writer上增加了发送HTTP相应头的方法。）等效地，我们可以使用实用的http.Error函数：\nmsg :&#x3D; fmt.Sprintf(&quot;no such page: %s\\n&quot;, req.URL)\nhttp.Error(w, msg, http.StatusNotFound) &#x2F;&#x2F; 404\n\n/price的case会调用URL的Query方法来将HTTP请求参数解析为一个map，或者更准确地说一个net/url包中url.Values(§6.2.1)类型的多重映射。然后找到第一个item参数并查找它的价格。如果这个货品没有找到会返回一个错误。\n这里是一个和新服务器会话的例子：\n$ go build gopl.io&#x2F;ch7&#x2F;http2\n$ go build gopl.io&#x2F;ch1&#x2F;fetch\n$ .&#x2F;http2 &amp;\n$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;list\nshoes: $50.00\nsocks: $5.00\n$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;socks\n$5.00\n$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;shoes\n$50.00\n$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;hat\nno such item: &quot;hat&quot;\n$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;help\nno such page: &#x2F;help\n\n显然我们可以继续向ServeHTTP方法中添加case，但在一个实际的应用中，将每个case中的逻辑定义到一个分开的方法或函数中会很实用。此外，相近的URL可能需要相似的逻辑；例如几个图片文件可能有形如&#x2F;images&#x2F;*.png的URL。因为这些原因，net&#x2F;http包提供了一个请求多路器ServeMux来简化URL和handlers的联系。一个ServeMux将一批http.Handler聚集到一个单一的http.Handler中。再一次，我们可以看到满足同一接口的不同类型是可替换的：web服务器将请求指派给任意的http.Handler 而不需要考虑它后面的具体类型。\n对于更复杂的应用，一些ServeMux可以通过组合来处理更加错综复杂的路由需求。Go语言目前没有一个权威的web框架，就像Ruby语言有Rails和python有Django。这并不是说这样的框架不存在，而是Go语言标准库中的构建模块就已经非常灵活以至于这些框架都是不必要的。此外，尽管在一个项目早期使用框架是非常方便的，但是它们带来额外的复杂度会使长期的维护更加困难。\n在下面的程序中，我们创建一个ServeMux并且使用它将URL和相应处理&#x2F;list和&#x2F;price操作的handler联系起来，这些操作逻辑都已经被分到不同的方法中。然后我们在调用ListenAndServe函数中使用ServeMux为主要的handler。\ngopl.io&#x2F;ch7&#x2F;http3\n\n\nfunc main() &#123;\n    db :&#x3D; database&#123;&quot;shoes&quot;: 50, &quot;socks&quot;: 5&#125;\n    mux :&#x3D; http.NewServeMux()\n    mux.Handle(&quot;&#x2F;list&quot;, http.HandlerFunc(db.list))\n    mux.Handle(&quot;&#x2F;price&quot;, http.HandlerFunc(db.price))\n    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, mux))\n&#125;\n\ntype database map[string]dollars\n\nfunc (db database) list(w http.ResponseWriter, req *http.Request) &#123;\n    for item, price :&#x3D; range db &#123;\n        fmt.Fprintf(w, &quot;%s: %s\\n&quot;, item, price)\n    &#125;\n&#125;\n\nfunc (db database) price(w http.ResponseWriter, req *http.Request) &#123;\n    item :&#x3D; req.URL.Query().Get(&quot;item&quot;)\n    price, ok :&#x3D; db[item]\n    if !ok &#123;\n        w.WriteHeader(http.StatusNotFound) &#x2F;&#x2F; 404\n        fmt.Fprintf(w, &quot;no such item: %q\\n&quot;, item)\n        return\n    &#125;\n    fmt.Fprintf(w, &quot;%s\\n&quot;, price)\n&#125;\n\n让我们关注这两个注册到handlers上的调用。第一个db.list是一个方法值（§6.4），它是下面这个类型的值。\nfunc(w http.ResponseWriter, req *http.Request)也就是说db.list的调用会援引一个接收者是db的database.list方法。所以db.list是一个实现了handler类似行为的函数，但是因为它没有方法（理解：该方法没有它自己的方法），所以它不满足http.Handler接口并且不能直接传给mux.Handle。\n语句http.HandlerFunc(db.list)是一个转换而非一个函数调用，因为http.HandlerFunc是一个类型。它有如下的定义：\nnet&#x2F;http\n\n\npackage http\n\ntype HandlerFunc func(w ResponseWriter, r *Request)\n\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) &#123;\n    f(w, r)\n&#125;\n\nHandlerFunc显示了在Go语言接口机制中一些不同寻常的特点。这是一个实现了接口http.Handler的方法的函数类型。ServeHTTP方法的行为是调用了它的函数本身。因此HandlerFunc是一个让函数值满足一个接口的适配器，这里函数和这个接口仅有的方法有相同的函数签名。实际上，这个技巧让一个单一的类型例如database以多种方式满足http.Handler接口：一种通过它的list方法，一种通过它的price方法等等。\n因为handler通过这种方式注册非常普遍，ServeMux有一个方便的HandleFunc方法，它帮我们简化handler注册代码成这样：\n\ngopl.io&#x2F;ch7&#x2F;http3a\n\nmux.HandleFunc(&quot;&#x2F;list&quot;, db.list)\nmux.HandleFunc(&quot;&#x2F;price&quot;, db.price)\n\n从上面的代码很容易看出应该怎么构建一个程序：由两个不同的web服务器监听不同的端口，并且定义不同的URL将它们指派到不同的handler。我们只要构建另外一个ServeMux并且再调用一次ListenAndServe（可能并行的）。但是在大多数程序中，一个web服务器就足够了。此外，在一个应用程序的多个文件中定义HTTP handler也是非常典型的，如果它们必须全部都显式地注册到这个应用的ServeMux实例上会比较麻烦。\n所以为了方便，net/http包提供了一个全局的ServeMux实例DefaultServerMux和包级别的http.Handle和http.HandleFunc函数。现在，为了使用DefaultServeMux作为服务器的主handler，我们不需要将它传给ListenAndServe函数;nil值就可以工作。\n然后服务器的主函数可以简化成：\ngopl.io&#x2F;ch7&#x2F;http4\n\nfunc main() &#123;\n    db :&#x3D; database&#123;&quot;shoes&quot;: 50, &quot;socks&quot;: 5&#125;\n    http.HandleFunc(&quot;&#x2F;list&quot;, db.list)\n    http.HandleFunc(&quot;&#x2F;price&quot;, db.price)\n    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))\n&#125;\n\n最后，一个重要的提示：就像我们在1.7节中提到的，web服务器在一个新的协程中调用每一个handler，所以当handler获取其它协程或者这个handler本身的其它请求也可以访问到变量时，一定要使用预防措施，比如锁机制。我们后面的两章中将讲到并发相关的知识。\n练习 7.11： 增加额外的handler让客户端可以创建，读取，更新和删除数据库记录。例如，一个形如 &#x2F;update?item&#x3D;socks&amp;price&#x3D;6 的请求会更新库存清单里一个货品的价格并且当这个货品不存在或价格无效时返回一个错误值。（注意：这个修改会引入变量同时更新的问题）\n练习 7.12： 修改&#x2F;list的handler让它把输出打印成一个HTML的表格而不是文本。html&#x2F;template包（§4.6）可能会对你有帮助。\n7.8. error接口从本书的开始，我们就已经创建和使用过神秘的预定义error类型，而且没有解释它究竟是什么。实际上它就是interface类型，这个类型有一个返回错误信息的单一方法：\ntype error interface &#123;\n    Error() string\n&#125;\n\n创建一个error最简单的方法就是调用errors.New函数，它会根据传入的错误信息返回一个新的error。整个errors包仅只有4行：\npackage errors\n\nfunc New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125;\n\ntype errorString struct &#123; text string &#125;\n\nfunc (e *errorString) Error() string &#123; return e.text &#125;\n\n承载errorString的类型是一个结构体而非一个字符串，这是为了保护它表示的错误避免粗心（或有意）的更新。并且因为是指针类型*errorString满足error接口而非errorString类型，所以每个New函数的调用都分配了一个独特的和其他错误不相同的实例。我们也不想要重要的error例如io.EOF和一个刚好有相同错误消息的error比较后相等。\nfmt.Println(errors.New(&quot;EOF&quot;) == errors.New(&quot;EOF&quot;)) // &quot;false&quot;调用errors.New函数是非常稀少的，因为有一个方便的封装函数fmt.Errorf，它还会处理字符串格式化。我们曾多次在第5章中用到它。\npackage fmt\n\nimport &quot;errors&quot;\n\nfunc Errorf(format string, args ...interface&#123;&#125;) error &#123;\n    return errors.New(Sprintf(format, args...))\n&#125;\n\n虽然*errorString可能是最简单的错误类型，但远非只有它一个。例如，syscall包提供了Go语言底层系统调用API。在多个平台上，它定义一个实现error接口的数字类型Errno，并且在Unix平台上，Errno的Error方法会从一个字符串表中查找错误消息，如下面展示的这样：\npackage syscall\n\ntype Errno uintptr &#x2F;&#x2F; operating system error code\n\nvar errors &#x3D; [...]string&#123;\n    1:   &quot;operation not permitted&quot;,   &#x2F;&#x2F; EPERM\n    2:   &quot;no such file or directory&quot;, &#x2F;&#x2F; ENOENT\n    3:   &quot;no such process&quot;,           &#x2F;&#x2F; ESRCH\n    &#x2F;&#x2F; ...\n&#125;\n\nfunc (e Errno) Error() string &#123;\n    if 0 &lt;&#x3D; int(e) &amp;&amp; int(e) &lt; len(errors) &#123;\n        return errors[e]\n    &#125;\n    return fmt.Sprintf(&quot;errno %d&quot;, e)\n&#125;\n\n下面的语句创建了一个持有Errno值为2的接口值，表示POSIX ENOENT状况：\nvar err error &#x3D; syscall.Errno(2)fmt.Println(err.Error()) &#x2F;&#x2F; “no such file or directory”fmt.Println(err)         &#x2F;&#x2F; “no such file or directory”err的值图形化的呈现在图7.6中。\nErrno是一个系统调用错误的高效表示方式，它通过一个有限的集合进行描述，并且它满足标准的错误接口。我们会在第7.11节了解到其它满足这个接口的类型。\n7.9 示例-表达式求值在本节中，我们会构建一个简单算术表达式的求值器。我们将使用一个接口Expr来表示Go语言中任意的表达式。现在这个接口不需要有方法，但是我们后面会为它增加一些。\n&#x2F;&#x2F; An Expr is an arithmetic expression.type Expr interface{}我们的表达式语言包括浮点数符号（小数点）；二元操作符+，-，*， 和&#x2F;；一元操作符-x和+x；调用pow(x,y)，sin(x)，和sqrt(x)的函数；例如x和pi的变量；当然也有括号和标准的优先级运算符。所有的值都是float64类型。这下面是一些表达式的例子：\nsqrt(A &#x2F; pi)\npow(x, 3) + pow(y, 3)\n(F - 32) * 5 &#x2F; 9\n\n下面的五个具体类型表示了具体的表达式类型。Var类型表示对一个变量的引用。（我们很快会知道为什么它可以被输出。）literal类型表示一个浮点型常量。unary和binary类型表示有一到两个运算对象的运算符表达式，这些操作数可以是任意的Expr类型。call类型表示对一个函数的调用；我们限制它的fn字段只能是pow，sin或者sqrt。\ngopl.io&#x2F;ch7&#x2F;eval\n\n\n&#x2F;&#x2F; A Var identifies a variable, e.g., x.\ntype Var string\n\n&#x2F;&#x2F; A literal is a numeric constant, e.g., 3.141.\ntype literal float64\n\n&#x2F;&#x2F; A unary represents a unary operator expression, e.g., -x.\ntype unary struct &#123;\n    op rune &#x2F;&#x2F; one of &#39;+&#39;, &#39;-&#39;\n    x  Expr\n&#125;\n\n&#x2F;&#x2F; A binary represents a binary operator expression, e.g., x+y.\ntype binary struct &#123;\n    op   rune &#x2F;&#x2F; one of &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;\n    x, y Expr\n&#125;\n\n&#x2F;&#x2F; A call represents a function call expression, e.g., sin(x).\ntype call struct &#123;\n    fn   string &#x2F;&#x2F; one of &quot;pow&quot;, &quot;sin&quot;, &quot;sqrt&quot;\n    args []Expr\n&#125;\n\n为了计算一个包含变量的表达式，我们需要一个environment变量将变量的名字映射成对应的值：\ntype Env map[Var]float64\n\n我们也需要每个表达式去定义一个Eval方法，这个方法会根据给定的environment变量返回表达式的值。因为每个表达式都必须提供这个方法，我们将它加入到Expr接口中。这个包只会对外公开Expr，Env，和Var类型。调用方不需要获取其它的表达式类型就可以使用这个求值器。\ntype Expr interface &#123;\n    &#x2F;&#x2F; Eval returns the value of this Expr in the environment env.\n    Eval(env Env) float64\n&#125;\n\n下面给大家展示一个具体的Eval方法。Var类型的这个方法对一个environment变量进行查找，如果这个变量没有在environment中定义过这个方法会返回一个零值，literal类型的这个方法简单的返回它真实的值。\nfunc (v Var) Eval(env Env) float64 &#123;\n    return env[v]\n&#125;\n\nfunc (l literal) Eval(_ Env) float64 &#123;\n    return float64(l)\n&#125;\n\nunary和binary的Eval方法会递归的计算它的运算对象，然后将运算符op作用到它们上。我们不将被零或无穷数除作为一个错误，因为它们都会产生一个固定的结果——无限。最后，call的这个方法会计算对于pow，sin，或者sqrt函数的参数值，然后调用对应在math包中的函数。\nfunc (u unary) Eval(env Env) float64 &#123;\n    switch u.op &#123;\n    case &#39;+&#39;:\n        return +u.x.Eval(env)\n    case &#39;-&#39;:\n        return -u.x.Eval(env)\n    &#125;\n    panic(fmt.Sprintf(&quot;unsupported unary operator: %q&quot;, u.op))\n&#125;\n\nfunc (b binary) Eval(env Env) float64 &#123;\n    switch b.op &#123;\n    case &#39;+&#39;:\n        return b.x.Eval(env) + b.y.Eval(env)\n    case &#39;-&#39;:\n        return b.x.Eval(env) - b.y.Eval(env)\n    case &#39;*&#39;:\n        return b.x.Eval(env) * b.y.Eval(env)\n    case &#39;&#x2F;&#39;:\n        return b.x.Eval(env) &#x2F; b.y.Eval(env)\n    &#125;\n    panic(fmt.Sprintf(&quot;unsupported binary operator: %q&quot;, b.op))\n&#125;\n\nfunc (c call) Eval(env Env) float64 &#123;\n    switch c.fn &#123;\n    case &quot;pow&quot;:\n        return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env))\n    case &quot;sin&quot;:\n        return math.Sin(c.args[0].Eval(env))\n    case &quot;sqrt&quot;:\n        return math.Sqrt(c.args[0].Eval(env))\n    &#125;\n    panic(fmt.Sprintf(&quot;unsupported function call: %s&quot;, c.fn))\n&#125;\n\n一些方法会失败。例如，一个call表达式可能有未知的函数或者错误的参数个数。用一个无效的运算符如!或者&lt;去构建一个unary或者binary表达式也是可能会发生的（尽管下面提到的Parse函数不会这样做）。这些错误会让Eval方法panic。其它的错误，像计算一个没有在environment变量中出现过的Var，只会让Eval方法返回一个错误的结果。所有的这些错误都可以通过在计算前检查Expr来发现。这是我们接下来要讲的Check方法的工作，但是让我们先测试Eval方法。\n下面的TestEval函数是对evaluator的一个测试。它使用了我们会在第11章讲解的testing包，但是现在知道调用t.Errof会报告一个错误就足够了。这个函数循环遍历一个表格中的输入，这个表格中定义了三个表达式和针对每个表达式不同的环境变量。第一个表达式根据给定圆的面积A计算它的半径，第二个表达式通过两个变量x和y计算两个立方体的体积之和，第三个表达式将华氏温度F转换成摄氏度。\nfunc TestEval(t *testing.T) &#123;\n    tests :&#x3D; []struct &#123;\n        expr string\n        env  Env\n        want string\n    &#125;&#123;\n        &#123;&quot;sqrt(A &#x2F; pi)&quot;, Env&#123;&quot;A&quot;: 87616, &quot;pi&quot;: math.Pi&#125;, &quot;167&quot;&#125;,\n        &#123;&quot;pow(x, 3) + pow(y, 3)&quot;, Env&#123;&quot;x&quot;: 12, &quot;y&quot;: 1&#125;, &quot;1729&quot;&#125;,\n        &#123;&quot;pow(x, 3) + pow(y, 3)&quot;, Env&#123;&quot;x&quot;: 9, &quot;y&quot;: 10&#125;, &quot;1729&quot;&#125;,\n        &#123;&quot;5 &#x2F; 9 * (F - 32)&quot;, Env&#123;&quot;F&quot;: -40&#125;, &quot;-40&quot;&#125;,\n        &#123;&quot;5 &#x2F; 9 * (F - 32)&quot;, Env&#123;&quot;F&quot;: 32&#125;, &quot;0&quot;&#125;,\n        &#123;&quot;5 &#x2F; 9 * (F - 32)&quot;, Env&#123;&quot;F&quot;: 212&#125;, &quot;100&quot;&#125;,\n    &#125;\n    var prevExpr string\n    for _, test :&#x3D; range tests &#123;\n        &#x2F;&#x2F; Print expr only when it changes.\n        if test.expr !&#x3D; prevExpr &#123;\n            fmt.Printf(&quot;\\n%s\\n&quot;, test.expr)\n            prevExpr &#x3D; test.expr\n        &#125;\n        expr, err :&#x3D; Parse(test.expr)\n        if err !&#x3D; nil &#123;\n            t.Error(err) &#x2F;&#x2F; parse error\n            continue\n        &#125;\n        got :&#x3D; fmt.Sprintf(&quot;%.6g&quot;, expr.Eval(test.env))\n        fmt.Printf(&quot;\\t%v &#x3D;&gt; %s\\n&quot;, test.env, got)\n        if got !&#x3D; test.want &#123;\n            t.Errorf(&quot;%s.Eval() in %v &#x3D; %q, want %q\\n&quot;,\n            test.expr, test.env, got, test.want)\n        &#125;\n    &#125;\n&#125;\n\n对于表格中的每一条记录，这个测试会解析它的表达式然后在环境变量中计算它，输出结果。这里我们没有空间来展示Parse函数，但是如果你使用go get下载这个包你就可以看到这个函数。\ngo test(§11.1) 命令会运行一个包的测试用例：\n$ go test -v gopl.io&#x2F;ch7&#x2F;eval\n\n这个-v标识可以让我们看到测试用例打印的输出；正常情况下像这样一个成功的测试用例会阻止打印结果的输出。这里是测试用例里fmt.Printf语句的输出：\nsqrt(A &#x2F; pi)\n    map[A:87616 pi:3.141592653589793] &#x3D;&gt; 167\n\npow(x, 3) + pow(y, 3)\n    map[x:12 y:1] &#x3D;&gt; 1729\n    map[x:9 y:10] &#x3D;&gt; 1729\n\n5 &#x2F; 9 * (F - 32)\n    map[F:-40] &#x3D;&gt; -40\n    map[F:32] &#x3D;&gt; 0\n    map[F:212] &#x3D;&gt; 100\n\n幸运的是目前为止所有的输入都是适合的格式，但是我们的运气不可能一直都有。甚至在解释型语言中，为了静态错误检查语法是非常常见的；静态错误就是不用运行程序就可以检测出来的错误。通过将静态检查和动态的部分分开，我们可以快速的检查错误并且对于多次检查只执行一次而不是每次表达式计算的时候都进行检查。\n让我们往Expr接口中增加另一个方法。Check方法对一个表达式语义树检查出静态错误。我们马上会说明它的vars参数。\ntype Expr interface &#123;\n    Eval(env Env) float64\n    &#x2F;&#x2F; Check reports errors in this Expr and adds its Vars to the set.\n    Check(vars map[Var]bool) error\n&#125;\n\n具体的Check方法展示在下面。literal和Var类型的计算不可能失败，所以这些类型的Check方法会返回一个nil值。对于unary和binary的Check方法会首先检查操作符是否有效，然后递归的检查运算单元。相似地对于call的这个方法首先检查调用的函数是否已知并且有没有正确个数的参数，然后递归的检查每一个参数。\nfunc (v Var) Check(vars map[Var]bool) error &#123;\n    vars[v] &#x3D; true\n    return nil\n&#125;\n\nfunc (literal) Check(vars map[Var]bool) error &#123;\n    return nil\n&#125;\n\nfunc (u unary) Check(vars map[Var]bool) error &#123;\n    if !strings.ContainsRune(&quot;+-&quot;, u.op) &#123;\n        return fmt.Errorf(&quot;unexpected unary op %q&quot;, u.op)\n    &#125;\n    return u.x.Check(vars)\n&#125;\n\nfunc (b binary) Check(vars map[Var]bool) error &#123;\n    if !strings.ContainsRune(&quot;+-*&#x2F;&quot;, b.op) &#123;\n        return fmt.Errorf(&quot;unexpected binary op %q&quot;, b.op)\n    &#125;\n    if err :&#x3D; b.x.Check(vars); err !&#x3D; nil &#123;\n        return err\n    &#125;\n    return b.y.Check(vars)\n&#125;\n\nfunc (c call) Check(vars map[Var]bool) error &#123;\n    arity, ok :&#x3D; numParams[c.fn]\n    if !ok &#123;\n        return fmt.Errorf(&quot;unknown function %q&quot;, c.fn)\n    &#125;\n    if len(c.args) !&#x3D; arity &#123;\n        return fmt.Errorf(&quot;call to %s has %d args, want %d&quot;,\n            c.fn, len(c.args), arity)\n    &#125;\n    for _, arg :&#x3D; range c.args &#123;\n        if err :&#x3D; arg.Check(vars); err !&#x3D; nil &#123;\n            return err\n        &#125;\n    &#125;\n    return nil\n&#125;\n\nvar numParams &#x3D; map[string]int&#123;&quot;pow&quot;: 2, &quot;sin&quot;: 1, &quot;sqrt&quot;: 1&#125;\n\n我们在两个组中有选择地列出有问题的输入和它们得出的错误。Parse函数（这里没有出现）会报出一个语法错误和Check函数会报出语义错误。\nx % 2               unexpected &#39;%&#39;\nmath.Pi             unexpected &#39;.&#39;\n!true               unexpected &#39;!&#39;\n&quot;hello&quot;             unexpected &#39;&quot;&#39;\n\nlog(10)             unknown function &quot;log&quot;\nsqrt(1, 2)          call to sqrt has 2 args, want 1\n\nCheck方法的参数是一个Var类型的集合，这个集合聚集从表达式中找到的变量名。为了保证成功的计算，这些变量中的每一个都必须出现在环境变量中。从逻辑上讲，这个集合就是调用Check方法返回的结果，但是因为这个方法是递归调用的，所以对于Check方法，填充结果到一个作为参数传入的集合中会更加的方便。调用方在初始调用时必须提供一个空的集合。\n在第3.2节中，我们绘制了一个在编译期才确定的函数f(x,y)。现在我们可以解析，检查和计算在字符串中的表达式，我们可以构建一个在运行时从客户端接收表达式的web应用并且它会绘制这个函数的表示的曲面。我们可以使用集合vars来检查表达式是否是一个只有两个变量x和y的函数——实际上是3个，因为我们为了方便会提供半径大小r。并且我们会在计算前使用Check方法拒绝有格式问题的表达式，这样我们就不会在下面函数的40000个计算过程（100x100个栅格，每一个有4个角）重复这些检查。\n这个ParseAndCheck函数混合了解析和检查步骤的过程：\ngopl.io&#x2F;ch7&#x2F;surface\n\n\nimport &quot;gopl.io&#x2F;ch7&#x2F;eval&quot;\n\nfunc parseAndCheck(s string) (eval.Expr, error) &#123;\n    if s &#x3D;&#x3D; &quot;&quot; &#123;\n        return nil, fmt.Errorf(&quot;empty expression&quot;)\n    &#125;\n    expr, err :&#x3D; eval.Parse(s)\n    if err !&#x3D; nil &#123;\n        return nil, err\n    &#125;\n    vars :&#x3D; make(map[eval.Var]bool)\n    if err :&#x3D; expr.Check(vars); err !&#x3D; nil &#123;\n        return nil, err\n    &#125;\n    for v :&#x3D; range vars &#123;\n        if v !&#x3D; &quot;x&quot; &amp;&amp; v !&#x3D; &quot;y&quot; &amp;&amp; v !&#x3D; &quot;r&quot; &#123;\n            return nil, fmt.Errorf(&quot;undefined variable: %s&quot;, v)\n        &#125;\n    &#125;\n    return expr, nil\n&#125;\n\n为了编写这个web应用，所有我们需要做的就是下面这个plot函数，这个函数有和http.HandlerFunc相似的签名：\nfunc plot(w http.ResponseWriter, r *http.Request) &#123;\n    r.ParseForm()\n    expr, err :&#x3D; parseAndCheck(r.Form.Get(&quot;expr&quot;))\n    if err !&#x3D; nil &#123;\n        http.Error(w, &quot;bad expr: &quot;+err.Error(), http.StatusBadRequest)\n        return\n    &#125;\n    w.Header().Set(&quot;Content-Type&quot;, &quot;image&#x2F;svg+xml&quot;)\n    surface(w, func(x, y float64) float64 &#123;\n        r :&#x3D; math.Hypot(x, y) &#x2F;&#x2F; distance from (0,0)\n        return expr.Eval(eval.Env&#123;&quot;x&quot;: x, &quot;y&quot;: y, &quot;r&quot;: r&#125;)\n    &#125;)\n&#125;\n\n\n这个plot函数解析和检查在HTTP请求中指定的表达式并且用它来创建一个两个变量的匿名函数。这个匿名函数和来自原来surface-plotting程序中的固定函数f有相同的签名，但是它计算一个用户提供的表达式。环境变量中定义了x，y和半径r。最后plot调用surface函数，它就是gopl.io&#x2F;ch3&#x2F;surface中的主要函数，修改后它可以接受plot中的函数和输出io.Writer作为参数，而不是使用固定的函数f和os.Stdout。图7.7中显示了通过程序产生的3个曲面。\n练习7.13为Expr增加一个String方法来打印美观的语法树。当再一次解析的时候，检查它的结果是否生成相同的语法树\n练习7.14定义一个新的满足Expr接口的具体类型并且提供一个新的操作例如对它运算单元中的最小值的计算。因为Parse函数不会创建这个新类型的实例，为了使用它你可能需要直接构造一个语法树(或者继承parser接口)\n练习7.15编写一个从标准输入中读取一个单一表达式的程序，用户及时地提供对于任意变量的值，然后在结果环境变量中计算表达式的值。优雅的处理所有遇到的错误\n练习7.16编写一个基于web的计算器程序。\n7.10. 类型断言类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。\n这里有两种可能。第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。例如：\nvar w io.Writer\nw &#x3D; os.Stdout\nf :&#x3D; w.(*os.File)      &#x2F;&#x2F; success: f &#x3D;&#x3D; os.Stdout\nc :&#x3D; w.(*bytes.Buffer) &#x2F;&#x2F; panic: interface holds *os.File, not *bytes.Buffer\n第二种，如果相反地断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。\n在下面的第一个类型断言后，w和rw都持有os.Stdout，因此它们都有一个动态类型*os.File，但是变量w是一个io.Writer类型，只对外公开了文件的Write方法，而rw变量还公开了它的Read方法。\nvar w io.Writer\nw &#x3D; os.Stdout\nrw :&#x3D; w.(io.ReadWriter) &#x2F;&#x2F; success: *os.File has both Read and Write\nw &#x3D; new(ByteCounter)\nrw &#x3D; w.(io.ReadWriter) &#x2F;&#x2F; panic: *ByteCounter has no Read method\n如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况。\nw &#x3D; rw             &#x2F;&#x2F; io.ReadWriter is assignable to io.Writer\nw &#x3D; rw.(io.Writer) &#x2F;&#x2F; fails only if rw &#x3D;&#x3D; nil\n经常地，对一个接口值的动态类型我们是不确定的，并且我们更愿意去检验它是否是一些特定的类型。如果类型断言出现在一个预期有两个结果的赋值操作中，例如如下的定义，这个操作不会在失败的时候发生panic，但是替代地返回一个额外的第二个结果，这个结果是一个标识成功与否的布尔值：\nvar w io.Writer &#x3D; os.Stdout\nf, ok :&#x3D; w.(*os.File)      &#x2F;&#x2F; success:  ok, f &#x3D;&#x3D; os.Stdout\nb, ok :&#x3D; w.(*bytes.Buffer) &#x2F;&#x2F; failure: !ok, b &#x3D;&#x3D; nil\n第二个结果通常赋值给一个命名为ok的变量。如果这个操作失败了，那么ok就是false值，第一个结果等于被断言类型的零值，在这个例子中就是一个nil的*bytes.Buffer类型。\n这个ok结果经常立即用于决定程序下面做什么。if语句的扩展格式让这个变的很简洁：\nif f, ok :&#x3D; w.(*os.File); ok &#123;\n    &#x2F;&#x2F; ...use f...\n&#125;\n\n当类型断言的操作对象是一个变量，你有时会看见原来的变量名重用而不是声明一个新的本地变量名，这个重用的变量原来的值会被覆盖（理解：其实是声明了一个同名的新的本地变量，外层原来的w不会被改变），如下面这样：\nif w, ok :&#x3D; w.(*os.File); ok &#123;\n    &#x2F;&#x2F; ...use w...\n&#125;\n\n7.11. 基于类型断言区别错误类型对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。\n一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：\n\n\npackage main\n\nimport (\n &quot;errors&quot;\n &quot;fmt&quot;\n &quot;os&quot;\n &quot;syscall&quot;\n)\n\ntype PathError struct &#123;\n Op   string\n Path string\n Err  error\n&#125;\n\nfunc (e *PathError) Error() string &#123;\n return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()\n&#125;\n\nvar ErrNotExist &#x3D; errors.New(&quot;file does not exist&quot;)\n\n&#x2F;&#x2F; IsNotExist returns a boolean indicating whether the error is known to\n&#x2F;&#x2F; report that a file or directory does not exist. It is satisfied by\n&#x2F;&#x2F; ErrNotExist as well as some syscall errors.\nfunc IsNotExist(err error) bool &#123;\n if pe, ok :&#x3D; err.(*PathError); ok &#123;\n  err &#x3D; pe.Err\n &#125;\n return err &#x3D;&#x3D; syscall.ENOENT || err &#x3D;&#x3D; ErrNotExist\n&#125;\n\nfunc main() &#123;\n _, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)\n fmt.Println(os.IsNotExist(err)) &#x2F;&#x2F; &quot;true&quot;\n&#125;\n\n7.11. 基于类型断言区别错误类型思考在os包中文件操作返回的错误集合。I&#x2F;O可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文件已经存在（对于创建操作），找不到文件（对于读取操作），和权限拒绝。os包中提供了三个帮助函数来对给定的错误值表示的失败进行分类：\npackage os\n\nfunc IsExist(err error) bool\nfunc IsNotExist(err error) bool\nfunc IsPermission(err error) bool\n对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，\nfunc IsNotExist(err error) bool &#123;\n    &#x2F;&#x2F; NOTE: not robust!\n    return strings.Contains(err.Error(), &quot;file does not exist&quot;)\n&#125;\n但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。\n一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：\npackage os\n\n&#x2F;&#x2F; PathError records an error and the operation and file path that caused it.\ntype PathError struct &#123;\n    Op   string\n    Path string\n    Err  error\n&#125;\n\nfunc (e *PathError) Error() string &#123;\n    return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()\n&#125;\n大多数调用方都不知道PathError并且通过调用错误本身的Error方法来统一处理所有的错误。尽管PathError的Error方法简单地把这些字段连接起来生成错误消息，PathError的结构保护了内部的错误组件。调用方需要使用类型断言来检测错误的具体类型以便将一种失败和另一种区分开；具体的类型可以比字符串提供更多的细节。\n_, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)\nfmt.Println(err) &#x2F;&#x2F; &quot;open &#x2F;no&#x2F;such&#x2F;file: No such file or directory&quot;\nfmt.Printf(&quot;%#v\\n&quot;, err)\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; &amp;os.PathError&#123;Op:&quot;open&quot;, Path:&quot;&#x2F;no&#x2F;such&#x2F;file&quot;, Err:0x2&#125;\n这就是三个帮助函数是怎么工作的。例如下面展示的IsNotExist，它会报出是否一个错误和syscall.ENOENT（§7.8）或者和有名的错误os.ErrNotExist相等（可以在§5.4.2中找到io.EOF）；或者是一个*PathError，它内部的错误是syscall.ENOENT和os.ErrNotExist其中之一。\n\nimport (\n    &quot;errors&quot;\n    &quot;syscall&quot;\n)\n\nvar ErrNotExist &#x3D; errors.New(&quot;file does not exist&quot;)\n\n&#x2F;&#x2F; IsNotExist returns a boolean indicating whether the error is known to\n&#x2F;&#x2F; report that a file or directory does not exist. It is satisfied by\n&#x2F;&#x2F; ErrNotExist as well as some syscall errors.\nfunc IsNotExist(err error) bool &#123;\n    if pe, ok :&#x3D; err.(*PathError); ok &#123;\n        err &#x3D; pe.Err\n    &#125;\n    return err &#x3D;&#x3D; syscall.ENOENT || err &#x3D;&#x3D; ErrNotExist\n&#125;\n下面这里是它的实际使用：\n_, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)\nfmt.Println(os.IsNotExist(err)) &#x2F;&#x2F; &quot;true&quot;\n\n如果错误消息结合成一个更大的字符串，当然PathError的结构就不再为人所知，例如通过一个对fmt.Errorf函数的调用。区别错误通常必须在失败操作后，错误传回调用者前进行。\n7.12. 通过类型断言询问行为下面这段逻辑和net&#x2F;http包中web服务器负责写入HTTP头字段（例如：”Content-type:text&#x2F;html”）的部分相似。io.Writer接口类型的变量w代表HTTP响应；写入它的字节最终被发送到某个人的web浏览器上。\nfunc writeHeader(w io.Writer, contentType string) error &#123;\n    if _, err :&#x3D; w.Write([]byte(&quot;Content-Type: &quot;)); err !&#x3D; nil &#123;\n        return err\n    &#125;\n    if _, err :&#x3D; w.Write([]byte(contentType)); err !&#x3D; nil &#123;\n        return err\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n因为Write方法需要传入一个byte切片而我们希望写入的值是一个字符串，所以我们需要使用[]byte(…)进行转换。这个转换分配内存并且做一个拷贝，但是这个拷贝在转换后几乎立马就被丢弃掉。让我们假装这是一个web服务器的核心部分并且我们的性能分析表示这个内存分配使服务器的速度变慢。这里我们可以避免掉内存分配么？\n这个io.Writer接口告诉我们关于w持有的具体类型的唯一东西：就是可以向它写入字节切片。如果我们回顾net&#x2F;http包中的内幕，我们知道在这个程序中的w变量持有的动态类型也有一个允许字符串高效写入的WriteString方法；这个方法会避免去分配一个临时的拷贝。（这可能像在黑夜中射击一样，但是许多满足io.Writer接口的重要类型同时也有WriteString方法，包括bytes.Buffer，os.File和*bufio.Writer。）\n我们不能对任意io.Writer类型的变量w，假设它也拥有WriteString方法。但是我们可以定义一个只有这个方法的新接口并且使用类型断言来检测是否w的动态类型满足这个新接口。\n&#x2F;&#x2F; writeString writes s to w.\n&#x2F;&#x2F; If w has a WriteString method, it is invoked instead of w.Write.\nfunc writeString(w io.Writer, s string) (n int, err error) &#123;\n    type stringWriter interface &#123;\n        WriteString(string) (n int, err error)\n    &#125;\n    if sw, ok :&#x3D; w.(stringWriter); ok &#123;\n        return sw.WriteString(s) &#x2F;&#x2F; avoid a copy\n    &#125;\n    return w.Write([]byte(s)) &#x2F;&#x2F; allocate temporary copy\n&#125;\n\nfunc writeHeader(w io.Writer, contentType string) error &#123;\n    if _, err :&#x3D; writeString(w, &quot;Content-Type: &quot;); err !&#x3D; nil &#123;\n        return err\n    &#125;\n    if _, err :&#x3D; writeString(w, contentType); err !&#x3D; nil &#123;\n        return err\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n为了避免重复定义，我们将这个检查移入到一个实用工具函数writeString中，但是它太有用了以致于标准库将它作为io.WriteString函数提供。这是向一个io.Writer接口写入字符串的推荐方法。\n这个例子的神奇之处在于，没有定义了WriteString方法的标准接口，也没有指定它是一个所需行为的标准接口。一个具体类型只会通过它的方法决定它是否满足stringWriter接口，而不是任何它和这个接口类型所表达的关系。它的意思就是上面的技术依赖于一个假设，这个假设就是：如果一个类型满足下面的这个接口，然后WriteString(s)方法就必须和Write([]byte(s))有相同的效果。\ninterface &#123;\n    io.Writer\n    WriteString(s string) (n int, err error)\n&#125;\n尽管io.WriteString实施了这个假设，但是调用它的函数极少可能会去实施类似的假设。定义一个特定类型的方法隐式地获取了对特定行为的协约。对于Go语言的新手，特别是那些来自有强类型语言使用背景的新手，可能会发现它缺乏显式的意图令人感到混乱，但是在实战的过程中这几乎不是一个问题。除了空接口interface{}，接口类型很少意外巧合地被实现。\n上面的writeString函数使用一个类型断言来获知一个普遍接口类型的值是否满足一个更加具体的接口类型；并且如果满足，它会使用这个更具体接口的行为。这个技术可以被很好的使用，不论这个被询问的接口是一个标准如io.ReadWriter，或者用户定义的如stringWriter接口。\n这也是fmt.Fprintf函数怎么从其它所有值中区分满足error或者fmt.Stringer接口的值。在fmt.Fprintf内部，有一个将单个操作对象转换成一个字符串的步骤，像下面这样：\npackage fmt\n\nfunc formatOneValue(x interface&#123;&#125;) string &#123;\n    if err, ok :&#x3D; x.(error); ok &#123;\n        return err.Error()\n    &#125;\n    if str, ok :&#x3D; x.(Stringer); ok &#123;\n        return str.String()\n    &#125;\n    &#x2F;&#x2F; ...all other types...\n&#125;\n如果x满足这两个接口类型中的一个，具体满足的接口决定对值的格式化方式。如果都不满足，默认的case或多或少会统一地使用反射来处理所有的其它类型；我们可以在第12章知道具体是怎么实现的。\n再一次的，它假设任何有String方法的类型都满足fmt.Stringer中约定的行为，这个行为会返回一个适合打印的字符串。\n7.13. 类型分支接口被以两种不同的方式使用。在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。\n第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。\n如果你熟悉面向对象编程，你可能会将这两种方式当作是subtype polymorphism（子类型多态）和 ad hoc polymorphism（非参数多态），但是你不需要去记住这些术语。对于本章剩下的部分，我们将会呈现一些第二种方式的例子。\n和其它那些语言一样，Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。一个调用的例子可能看起来像这样：\nimport &quot;database&#x2F;sql&quot;\n\nfunc listTracks(db sql.DB, artist string, minYear, maxYear int) &#123;\n    result, err :&#x3D; db.Exec(\n        &quot;SELECT * FROM tracks WHERE artist &#x3D; ? AND ? &lt;&#x3D; year AND year &lt;&#x3D; ?&quot;,\n        artist, minYear, maxYear)\n    &#x2F;&#x2F; ...\n&#125;\nExec方法使用SQL字面量替换在查询字符串中的每个’?’；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者nil空值。用这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对手可以通过利用输入内容中不正确的引号来控制查询语句。在Exec函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。\nfunc sqlQuote(x interface&#123;&#125;) string &#123;\n    if x &#x3D;&#x3D; nil &#123;\n        return &quot;NULL&quot;\n    &#125; else if _, ok :&#x3D; x.(int); ok &#123;\n        return fmt.Sprintf(&quot;%d&quot;, x)\n    &#125; else if _, ok :&#x3D; x.(uint); ok &#123;\n        return fmt.Sprintf(&quot;%d&quot;, x)\n    &#125; else if b, ok :&#x3D; x.(bool); ok &#123;\n        if b &#123;\n            return &quot;TRUE&quot;\n        &#125;\n        return &quot;FALSE&quot;\n    &#125; else if s, ok :&#x3D; x.(string); ok &#123;\n        return sqlQuoteString(s) &#x2F;&#x2F; (not shown)\n    &#125; else &#123;\n        panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x))\n    &#125;\n&#125;\nswitch语句可以简化if-else链，如果这个if-else链对一连串值做相等测试。一个相似的type switch（类型分支）可以简化类型断言的if-else链。\n在最简单的形式中，一个类型分支像普通的switch语句一样，它的运算对象是x.(type)——它使用了关键词字面量type——并且每个case有一到多个类型。一个类型分支基于这个接口值的动态类型使一个多路分支有效。这个nil的case和if x &#x3D;&#x3D; nil匹配，并且这个default的case和如果其它case都不匹配的情况匹配。一个对sqlQuote的类型分支可能会有这些case：\nswitch x.(type) &#123;\ncase nil:       &#x2F;&#x2F; ...\ncase int, uint: &#x2F;&#x2F; ...\ncase bool:      &#x2F;&#x2F; ...\ncase string:    &#x2F;&#x2F; ...\ndefault:        &#x2F;&#x2F; ...\n&#125;\n和（§1.8）中的普通switch语句一样，每一个case会被顺序的进行考虑，并且当一个匹配找到时，这个case中的内容会被执行。当一个或多个case类型是接口时，case的顺序就会变得很重要，因为可能会有两个case同时匹配的情况。default case相对其它case的位置是无所谓的。它不会允许落空发生。\n注意到在原来的函数中，对于bool和string情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型分支语句有一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内都有效的新变量。\nswitch x :&#x3D; x.(type) &#123; &#x2F;* ... *&#x2F; &#125;\n这里我们已经将新的变量也命名为x；和类型断言一样，重用变量名是很常见的。和一个switch语句相似地，一个类型分支隐式的创建了一个词法块，因此新变量x的定义不会和外面块中的x变量冲突。每一个case也会隐式的创建一个单独的词法块。\n使用类型分支的扩展形式来重写sqlQuote函数会让这个函数更加的清晰：\nfunc sqlQuote(x interface&#123;&#125;) string &#123;\n    switch x :&#x3D; x.(type) &#123;\n    case nil:\n        return &quot;NULL&quot;\n    case int, uint:\n        return fmt.Sprintf(&quot;%d&quot;, x) &#x2F;&#x2F; x has type interface&#123;&#125; here.\n    case bool:\n        if x &#123;\n            return &quot;TRUE&quot;\n        &#125;\n        return &quot;FALSE&quot;\n    case string:\n        return sqlQuoteString(x) &#x2F;&#x2F; (not shown)\n    default:\n        panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x))\n    &#125;\n&#125;\n在这个版本的函数中，在每个单一类型的case内部，变量x和这个case的类型相同。例如，变量x在bool的case中是bool类型和string的case中是string类型。在所有其它的情况中，变量x是switch运算对象的类型（接口）；在这个例子中运算对象是一个interface{}。当多个case需要相同的操作时，比如int和uint的情况，类型分支可以很容易的合并这些情况。\n尽管sqlQuote接受一个任意类型的参数，但是这个函数只会在它的参数匹配类型分支中的一个case时运行到结束；其它情况的它会panic出“unexpected type”消息。虽然x的类型是interface{}，但是我们把它认为是一个int，uint，bool，string，和nil值的discriminated union（可识别联合）\n7.14. 示例: 基于标记的XML解码第4.5章节展示了如何使用encoding&#x2F;json包中的Marshal和Unmarshal函数来将JSON文档转换成Go语言的数据结构。encoding&#x2F;xml包提供了一个相似的API。当我们想构造一个文档树的表示时使用encoding&#x2F;xml包会很方便，但是对于很多程序并不是必须的。encoding&#x2F;xml包也提供了一个更低层的基于标记的API用于XML解码。在基于标记的样式中，解析器消费输入并产生一个标记流；四个主要的标记类型－StartElement，EndElement，CharData，和Comment－每一个都是encoding&#x2F;xml包中的具体类型。每一个对(*xml.Decoder).Token的调用都返回一个标记。\n这里显示的是和这个API相关的部分：\nencoding&#x2F;xml\n\n\npackage xml\n\ntype Name struct &#123;\n    Local string &#x2F;&#x2F; e.g., &quot;Title&quot; or &quot;id&quot;\n&#125;\n\ntype Attr struct &#123; &#x2F;&#x2F; e.g., name&#x3D;&quot;value&quot;\n    Name  Name\n    Value string\n&#125;\n\n&#x2F;&#x2F; A Token includes StartElement, EndElement, CharData,\n&#x2F;&#x2F; and Comment, plus a few esoteric types (not shown).\ntype Token interface&#123;&#125;\ntype StartElement struct &#123; &#x2F;&#x2F; e.g., &lt;name&gt;\n    Name Name\n    Attr []Attr\n&#125;\ntype EndElement struct &#123; Name Name &#125; &#x2F;&#x2F; e.g., &lt;&#x2F;name&gt;\ntype CharData []byte                 &#x2F;&#x2F; e.g., &lt;p&gt;CharData&lt;&#x2F;p&gt;\ntype Comment []byte                  &#x2F;&#x2F; e.g., &lt;!-- Comment --&gt;\n\ntype Decoder struct&#123; &#x2F;* ... *&#x2F; &#125;\nfunc NewDecoder(io.Reader) *Decoder\nfunc (*Decoder) Token() (Token, error) &#x2F;&#x2F; returns next Token in sequence\n这个没有方法的Token接口也是一个可识别联合的例子。传统的接口如io.Reader的目的是隐藏满足它的具体类型的细节，这样就可以创造出新的实现：在这个实现中每个具体类型都被统一地对待。相反，满足可识别联合的具体类型的集合被设计为确定和暴露，而不是隐藏。可识别联合的类型几乎没有方法，操作它们的函数使用一个类型分支的case集合来进行表述，这个case集合中每一个case都有不同的逻辑。\n下面的xmlselect程序获取和打印在一个XML文档树中确定的元素下找到的文本。使用上面的API，它可以在输入上一次完成它的工作而从来不要实例化这个文档树。\ngopl.io&#x2F;ch7&#x2F;xmlselect\n\n\n&#x2F;&#x2F; Xmlselect prints the text of selected elements of an XML document.\npackage main\n\nimport (\n    &quot;encoding&#x2F;xml&quot;\n    &quot;fmt&quot;\n    &quot;io&quot;\n    &quot;os&quot;\n    &quot;strings&quot;\n)\n\nfunc main() &#123;\n    dec :&#x3D; xml.NewDecoder(os.Stdin)\n    var stack []string &#x2F;&#x2F; stack of element names\n    for &#123;\n        tok, err :&#x3D; dec.Token()\n        if err &#x3D;&#x3D; io.EOF &#123;\n            break\n        &#125; else if err !&#x3D; nil &#123;\n            fmt.Fprintf(os.Stderr, &quot;xmlselect: %v\\n&quot;, err)\n            os.Exit(1)\n        &#125;\n        switch tok :&#x3D; tok.(type) &#123;\n        case xml.StartElement:\n            stack &#x3D; append(stack, tok.Name.Local) &#x2F;&#x2F; push\n        case xml.EndElement:\n            stack &#x3D; stack[:len(stack)-1] &#x2F;&#x2F; pop\n        case xml.CharData:\n            if containsAll(stack, os.Args[1:]) &#123;\n                fmt.Printf(&quot;%s: %s\\n&quot;, strings.Join(stack, &quot; &quot;), tok)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; containsAll reports whether x contains the elements of y, in order.\nfunc containsAll(x, y []string) bool &#123;\n    for len(y) &lt;&#x3D; len(x) &#123;\n        if len(y) &#x3D;&#x3D; 0 &#123;\n            return true\n        &#125;\n        if x[0] &#x3D;&#x3D; y[0] &#123;\n            y &#x3D; y[1:]\n        &#125;\n        x &#x3D; x[1:]\n    &#125;\n    return false\n&#125;\nmain函数中的循环每遇到一个StartElement时，它把这个元素的名称压到一个栈里，并且每次遇到EndElement时，它将名称从这个栈中推出。这个API保证了StartElement和EndElement的序列可以被完全的匹配，甚至在一个糟糕的文档格式中。注释会被忽略。当xmlselect遇到一个CharData时，只有当栈中有序地包含所有通过命令行参数传入的元素名称时，它才会输出相应的文本。\n下面的命令打印出任意出现在两层div元素下的h2元素的文本。它的输入是XML的说明文档，并且它自己就是XML文档格式的。\n$ go build gopl.io&#x2F;ch1&#x2F;fetch\n$ .&#x2F;fetch http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2006&#x2F;REC-xml11-20060816 |\n    .&#x2F;xmlselect div div h2\nhtml body div div h2: 1 Introduction\nhtml body div div h2: 2 Documents\nhtml body div div h2: 3 Logical Structures\nhtml body div div h2: 4 Physical Structures\nhtml body div div h2: 5 Conformance\nhtml body div div h2: 6 Notation\nhtml body div div h2: A References\nhtml body div div h2: B Definitions for Character Normalization\n...\n练习 7.17： 扩展xmlselect程序以便让元素不仅可以通过名称选择，也可以通过它们CSS风格的属性进行选择。例如一个像这样\n\n的元素可以通过匹配id或者class，同时还有它的名称来进行选择。\n\n练习 7.18： 使用基于标记的解码API，编写一个可以读取任意XML文档并构造这个文档所代表的通用节点树的程序。节点有两种类型：CharData节点表示文本字符串，和 Element节点表示被命名的元素和它们的属性。每一个元素节点有一个子节点的切片。\n你可能发现下面的定义会对你有帮助。\nimport &quot;encoding&#x2F;xml&quot;\n\ntype Node interface&#123;&#125; &#x2F;&#x2F; CharData or *Element\n\ntype CharData string\n\ntype Element struct &#123;\n    Type     xml.Name\n    Attr     []xml.Attr\n    Children []Node\n&#125;\n\n7.15. 一些建议当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制（§6.6）来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。\n当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。\n因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）\n我们完成了对方法和接口的学习过程。Go语言对面向对象风格的编程支持良好，但这并不意味着你只能使用这一风格。不是任何事物都需要被当做一个对象；独立的函数有它们自己的用处，未封装的数据类型也是这样。观察一下，在本书前五章的例子中像input.Scan这样的方法被调用不超过二十次，与之相反的是普遍调用的函数如fmt.Printf。\n7.16. any关键字与泛型类型定义时不限制形参类型，在函数调用的时候再指定具体类型.  any其实是interface&#123;&#125;的别名泛型好处:  (1).在编译期间对类型进行检查以提高类型安全(2).通过指定类型消除强制类型转换(3).能够减少代码重复性，提供更通用的功能函数。\n\n类型泛型\npackage main\n\nimport &quot;fmt&quot;\n\ntype ListType[T int | int32 | int64 | string] []T\n\ntype MapType[K int | int32, V int64 | string] map[K]V\n\nfunc main() &#123;\n    var intList ListType[int]\n    intList &#x3D; []int&#123;1, 2, 3&#125;\n    fmt.Println(intList)\n    strList :&#x3D; ListType[string]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;\n    fmt.Println(strList)\n\n    intMap :&#x3D; MapType[int, string]&#123;1: &quot;1&quot;, 2: &quot;2&quot;&#125;\n    int32Map :&#x3D; MapType[int32, int64]&#123;1: 2, 3: 4&#125;\n    fmt.Println(intMap)\n    fmt.Println(int32Map)\n&#125;\n\n这里面的T,K,V都是占位符号,ListType只能在那三种类型中选择,同理MapType也是\n\n接口泛型\ntype GenericStackInterface[T any] interface &#123;\n  Push(element T)\n  Pop() T\n&#125;\n\n泛型函数\nfunc minInt[T int | int8 | int16 | int32](a, b T) T &#123;\nif a &lt; b &#123;\n    return a\n&#125;\n    return b\n&#125;\n\nfunc maxInt[T int | int8 | int16 | int32](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\nfunc Mix(a any) any &#123;\n\n&#125;\n&#x2F;&#x2F;还可以简化一下\ntype Numeric interface &#123;\n    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64\n&#125;\nfunc min[T Numeric](a, b T) T &#123;\nif a &lt; b &#123;\n    return a\n&#125;\n    return b\n&#125;\n\nfunc max[T Numeric](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\n&#x2F;&#x2F; go.18内置了数字类型的集合，故可以\nimport (\n&quot;golang.org&#x2F;x&#x2F;exp&#x2F;constraints&quot;\n)\n\nfunc minType[T constraints.Ordered](a, b T) T &#123;\n    if a &lt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\n\nfunc maxType[T constraints.Ordered](a, b T) T &#123;\n    if a &gt; b &#123;\n        return a\n    &#125;\n    return b\n&#125;\n\n如果进入constraints源代码查看其具体代码的话，会发现在 Ordered 类型中也是有各种数字类型组合起来的。但是有一点奇怪的地方就是这里的类型集合中，各种类型前加了一个波浪线~, 表示衍生类型，即使用 type 自定义的类型也可以被识别到，只要底层类型一致即可。比如 ~int 可以包含 int 和 type MyInt int 等多种类型\n\n\n8. Goroutines和Channels(多看看本章代码)\n8.1 goroutine通过代码示例了解goroutine的使用\nfunc main() &#123;\n    go spinner(100 * time.Millisecond)\n    const n &#x3D; 45\n    fibN :&#x3D; fib(n) &#x2F;&#x2F; slow\n    fmt.Printf(&quot;\\rFibonacci(%d) &#x3D; %d\\n&quot;, n, fibN)\n&#125;\n\nfunc spinner(delay time.Duration) &#123;\n    for &#123;\n        for _, r :&#x3D; range &#96;-\\|&#x2F;&#96; &#123;\n            fmt.Printf(&quot;\\r%c&quot;, r)\n            time.Sleep(delay)\n        &#125;\n    &#125;\n&#125;\n\nfunc fib(x int) int &#123;\n    if x &lt; 2 &#123;\n        return x\n    &#125;\n    return fib(x-1) + fib(x-2)\n&#125;\n\n8.2 channel这里应该还得看一下uber编码规范\n\n无缓冲channel\n  ch &lt;- x\nx &#x3D; &lt;-chan &#x2F;&#x2F;取出元素\n&lt;- ch &#x2F;&#x2F;取出，舍弃\nclose(ch) &#x2F;&#x2F; 关闭chan\n\n\n串联channel\n\n单方向channel\n\n\n\n缓冲channel\n  ch &#x3D; make(chan string, 3) &#x2F;&#x2F;channel容量为3\n\n8.3 基于select的多路复用\n多路复用demo\n\n\n&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.\n&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;\n\n&#x2F;&#x2F; See page 246.\n\n&#x2F;&#x2F; Countdown implements the countdown for a rocket launch.\npackage main\n\n&#x2F;&#x2F; NOTE: the ticker goroutine never terminates if the launch is aborted.\n&#x2F;&#x2F; This is a &quot;goroutine leak&quot;.\n\nimport (\n        &quot;fmt&quot;\n        &quot;os&quot;\n        &quot;time&quot;\n)\n\n&#x2F;&#x2F;!+\n\nfunc main() &#123;\n        &#x2F;&#x2F; ...create abort channel...\n\n        &#x2F;&#x2F;!-\n\n        abort :&#x3D; make(chan struct&#123;&#125;)\n        go func() &#123;\n                os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte\n                abort &lt;- struct&#123;&#125;&#123;&#125;\n        &#125;()\n\n        &#x2F;&#x2F;!+\n        fmt.Println(&quot;Commencing countdown.  Press return to abort.&quot;)\n        tick :&#x3D; time.Tick(1 * time.Second)\n        for countdown :&#x3D; 10; countdown &gt; 0; countdown-- &#123;\n                fmt.Println(countdown)\n                select &#123;\n                case &lt;-tick:\n                        &#x2F;&#x2F; Do nothing.\n                case &lt;-abort:\n                        fmt.Println(&quot;Launch aborted!&quot;)\n                        return\n                &#125;\n        &#125;\n        launch()\n&#125;\n&#x2F;&#x2F;!-\nfunc launch() &#123;\n        fmt.Println(&quot;Lift off!&quot;)\n&#125;\n\n\n\n\n\ngoroutine泄露 : 当for语句执行完后，程序已经跳转到其他部分，但是time.Tick(1 * time.Second)仍然会继续的网channel里面发送数据，这就会导致gotourine泄露，以上面为例，那么就需要合适的地方调用tick.stop()\n\nchannel的ready : 一定要等到channel准备完毕，开始接受或者发送消息\n\nchannel的轮询 : 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”\nselect &#123;\n  case &lt;-abort:\n      fmt.Printf(&quot;Launch aborted!\\n&quot;)\n      return\n  default:\n      &#x2F;&#x2F; do nothing\n&#125;\n\n8.4. 并发的退出这节主要讨论如何有效退出goroutines\n\n\ngoroutines退出代码示例\n\n\n&#x2F;&#x2F;gopl.io&#x2F;ch8&#x2F;du4\n&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.\n&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;\n\n&#x2F;&#x2F; See page 251.\n\n&#x2F;&#x2F; The du4 command computes the disk usage of the files in a directory.\npackage main\n\n&#x2F;&#x2F; The du4 variant includes cancellation:\n&#x2F;&#x2F; it terminates quickly when the user hits return.\n\nimport (\n &quot;fmt&quot;\n &quot;os&quot;\n &quot;path&#x2F;filepath&quot;\n &quot;sync&quot;\n &quot;time&quot;\n)\n\n&#x2F;&#x2F;!+1\nvar done &#x3D; make(chan struct&#123;&#125;)\n\nfunc cancelled() bool &#123;\n select &#123;\n case &lt;-done:\n  return true\n default:\n  return false\n &#125;\n&#125;\n\n&#x2F;&#x2F;!-1\n\nfunc main() &#123;\n &#x2F;&#x2F; Determine the initial directories.\n roots :&#x3D; os.Args[1:]\n if len(roots) &#x3D;&#x3D; 0 &#123;\n  roots &#x3D; []string&#123;&quot;.&quot;&#125;\n &#125;\n\n &#x2F;&#x2F;!+2\n &#x2F;&#x2F; Cancel traversal when input is detected.\n go func() &#123;\n  os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte\n  close(done)\n &#125;()\n &#x2F;&#x2F;!-2\n\n &#x2F;&#x2F; Traverse each root of the file tree in parallel.\n fileSizes :&#x3D; make(chan int64)\n var n sync.WaitGroup\n for _, root :&#x3D; range roots &#123;\n  n.Add(1)\n  go walkDir(root, &amp;n, fileSizes)\n &#125;\n go func() &#123;\n  n.Wait()\n  close(fileSizes)\n &#125;()\n\n &#x2F;&#x2F; Print the results periodically.\n tick :&#x3D; time.Tick(500 * time.Millisecond)\n var nfiles, nbytes int64\nloop:\n &#x2F;&#x2F;!+3\n for &#123;\n  select &#123;\n  case &lt;-done:\n   &#x2F;&#x2F; Drain fileSizes to allow existing goroutines to finish.\n   for range fileSizes &#123;\n    &#x2F;&#x2F; Do nothing.\n   &#125;\n   return\n  case size, ok :&#x3D; &lt;-fileSizes:\n   &#x2F;&#x2F; ...\n   &#x2F;&#x2F;!-3\n   if !ok &#123;\n    break loop &#x2F;&#x2F; fileSizes was closed\n   &#125;\n   nfiles++\n   nbytes +&#x3D; size\n  case &lt;-tick:\n   printDiskUsage(nfiles, nbytes)\n  &#125;\n &#125;\n printDiskUsage(nfiles, nbytes) &#x2F;&#x2F; final totals\n&#125;\n\nfunc printDiskUsage(nfiles, nbytes int64) &#123;\n fmt.Printf(&quot;%d files  %.1f GB\\n&quot;, nfiles, float64(nbytes)&#x2F;1e9)\n&#125;\n\n&#x2F;&#x2F; walkDir recursively walks the file tree rooted at dir\n&#x2F;&#x2F; and sends the size of each found file on fileSizes.\n&#x2F;&#x2F;!+4\nfunc walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) &#123;\n defer n.Done()\n if cancelled() &#123;\n  return\n &#125;\n for _, entry :&#x3D; range dirents(dir) &#123;\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F;!-4\n  if entry.IsDir() &#123;\n   n.Add(1)\n   subdir :&#x3D; filepath.Join(dir, entry.Name())\n   go walkDir(subdir, n, fileSizes)\n  &#125; else &#123;\n   fileSizes &lt;- entry.Size()\n  &#125;\n  &#x2F;&#x2F;!+4\n &#125;\n&#125;\n\n&#x2F;&#x2F;!-4\n\nvar sema &#x3D; make(chan struct&#123;&#125;, 20) &#x2F;&#x2F; concurrency-limiting counting semaphore\n\n&#x2F;&#x2F; dirents returns the entries of directory dir.\n&#x2F;&#x2F;!+5\nfunc dirents(dir string) []os.FileInfo &#123;\n select &#123;\n case sema &lt;- struct&#123;&#125;&#123;&#125;: &#x2F;&#x2F; acquire token\n case &lt;-done:\n  return nil &#x2F;&#x2F; cancelled\n &#125;\n defer func() &#123; &lt;-sema &#125;() &#x2F;&#x2F; release token\n\n &#x2F;&#x2F; ...read directory...\n &#x2F;&#x2F;!-5\n\n f, err :&#x3D; os.Open(dir)\n if err !&#x3D; nil &#123;\n  fmt.Fprintf(os.Stderr, &quot;du: %v\\n&quot;, err)\n  return nil\n &#125;\n defer f.Close()\n\n entries, err :&#x3D; f.Readdir(0) &#x2F;&#x2F; 0 &#x3D;&gt; no limit; read all entries\n if err !&#x3D; nil &#123;\n  fmt.Fprintf(os.Stderr, &quot;du: %v\\n&quot;, err)\n  &#x2F;&#x2F; Don&#39;t return: Readdir may return partial results.\n &#125;\n return entries\n&#125;\n\n\n\n\n9. 基于共享变量的并发(多看这章代码)避免数据竞争的三个方法\n\n并发读数据不会有数据竞争问题\n\n避免从多个goroutine中访问变量，使用独立变量\n\n临界区控制\n\n总结\n\n数据竞争: 程序在多个goroutine交叉执行操作时，导致数据不一致.  \n包级别的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。(多看看本章代码)\n\n\n\n9.1 sync.Mutex与sync.RMutex互斥锁比如银行存款查询余额的场景，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款(这句话很关键要没有)操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁\n\n总结\n避免临界区中的变量在中途被其他的goroutine修改\n使用mutex包进行互斥goroutine\n一个deferred Unlock即使在临界区发生panic时依然会执行\ngolang不支持重入锁\nsync.RWMutex.RLock()持锁，sync.RWMutex.Lock()会阻塞，相同的RWMutex.Lock()持锁，sync.RWMutex.RLock()阻塞，但是sync.RWMutex.RLock()阻塞之间不阻塞\n\n\n\n9.2 sync.Once惰性初始化如果初始化的成本太高，需要延迟的初始化对象。可考虑使用sync.Once\nsync.One的demo\n\n\n\n\n\n9.3 sync.Cond的使用\n使用场景: sync.Cond 经常用在多个goroutine等待,一个goroutine通知,如果是一读一等待使用sync.Mutx和chan就可以\n\nsync.Cond的方法\n &#x2F;&#x2F; Each Cond has an associated Locker L (often a *Mutex or *RWMutex),\n&#x2F;&#x2F; which must be held when changing the condition and\n&#x2F;&#x2F; when calling the Wait method.\n&#x2F;&#x2F; A Cond must not be copied after first use.\ntype Cond struct &#123;\n        noCopy noCopy\n        &#x2F;&#x2F; L is held while observing or changing the condition\n        L Locker\n        notify  notifyList\n        checker copyChecker\n&#125;\n\n\n Cond 实例都会关联一个锁L(互斥锁 Mutex，或读写锁RWMutex);当修改条件或者调用Wait()方法时,必须加锁\n &#x2F;&#x2F; Signal wakes one goroutine waiting on c, if there is any.\n&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L\n&#x2F;&#x2F; during the call.\n&#x2F;&#x2F; Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护\nfunc (c *Cond) Signal()\n&#x2F;&#x2F; Broadcast wakes all goroutines waiting on c.\n&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L\n&#x2F;&#x2F; during the call.\nfunc (c *Cond) Broadcast()\n\n&#x2F;&#x2F; c.L.Unlock()\n&#x2F;&#x2F; 挂起调用者所在的 goroutine,等待Broadcast或者Signal方法\nfunc (c *Cond) Wait()\n    &#x2F;&#x2F;代码片段\n    c.L.Lock()\n    for !condition() &#123;\n        c.Wait()\n    &#125;\n    ... make use of condition ...\n    c.L.Unlock()\n\n 调用Wait会自动释放锁 c.L,并挂起调用者所在的goroutine，因此当前协程会阻塞在Wait方法调用的地方。 如果其他协程调用了Signal或Broadcast唤醒了该协程,那么Wait方法在结束阻塞时,会重新给c.L加锁， 并且继续执行Wait后面的代码\n\nCond代码示例\n var done &#x3D; false\n\nfunc read(name string, c *sync.Cond) &#123;\n    c.L.Lock()\n    for !done &#123;\n        c.Wait()\n    &#125;\n    log.Println(name, &quot;starts reading&quot;)\n    c.L.Unlock()\n&#125;\n\nfunc write(name string, c *sync.Cond) &#123;\n    log.Println(name, &quot;starts writing&quot;)\n    time.Sleep(time.Second)\n    c.L.Lock()\n    done &#x3D; true\n    c.L.Unlock()\n    log.Println(name, &quot;wakes all&quot;)\n    c.Broadcast()\n&#125;\n\nfunc main() &#123;\n    cond :&#x3D; sync.NewCond(&amp;sync.Mutex&#123;&#125;)\n\n    go read(&quot;reader1&quot;, cond)\n    go read(&quot;reader2&quot;, cond)\n    go read(&quot;reader3&quot;, cond)\n    write(&quot;writer&quot;, cond)\n\n    time.Sleep(time.Second * 3)\n&#125;\n\n\n9.4. Goroutines和线程\n每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量\n\n一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩\n\nGo的运行时有自己的调度器，这个调度器比如m:n调度，n个操作系统线程调度m个gotoutine，例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。\n\nGOMAXPROCS : 变量来决定会有多少个操作系统的线程同时执行Go的代码,其默认的值是运行机器上的CPU的核心数,GOMAXPROCS是前面说的m:n调度中的n.下面代码就可以简单的看出os线程调度代码的情况\n\nfor &#123;\n    go fmt.Print(0)\n    fmt.Print(1)\n&#125;\n\n$ GOMAXPROCS&#x3D;1 go run hacker-cliché.go\n111111111111111111110000000000000000000011111...\n\n$ GOMAXPROCS&#x3D;2 go run hacker-cliché.go\n010101010101010101011001100101011010010100110...\n\n总结\n\n通过广播机制来取消goroutines\n确保主函数退出，routines也随即退出\n\n\n\n10. 包和工具现在随便一个小程序的实现都可能包含超过10000个函数。然而作者一般只需要考虑其中很小的一部分和做很少的设计，因为绝大部分代码都是由他人编写的，它们通过类似包或模块的方式被重用。\nGo语言有超过100个的标准包（译注：可以用go list std | wc -l命令查看标准包的具体数目），标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设计、共享、重用和改进，目前互联网上已经发布了非常多的Go语言开源包，它们可以通过 http://godoc.org 检索。在本章，我们将演示如何使用已有的包和创建新的包。\nGo还自带了工具箱，里面有很多用来简化工作区和包管理的小工具。在本书开始的时候，我们已经见识过如何使用工具箱自带的工具来下载、构建和运行我们的演示程序了。在本章，我们将看看这些工具的基本设计理论和尝试更多的功能，例如打印工作区中包的文档和查询相关的元数据等。在下一章，我们将探讨testing包的单元测试用法。\nsummary: \n\ngo语言拥有很多标准包，我们可以使用go list std来查看,更多的选择我们可以通过godoc进行检索\ngo这种成熟的语言自带工具箱，和包管理工具\n包的声明 ： 通过package.struct的形式访问我们的下载的package,但是也有同名的例如math/rand和crypto/rand，这种要重新指定包名，只影响当前文件，同时也解决了那些又臭又长的包名\n\n10.1. 包简介任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。\n每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以在使用它们的时候减少和其它部分名字的冲突。\n每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。\n当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。\n10.2. 导入路径每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。\nimport (\n    &quot;fmt&quot;\n    &quot;math&#x2F;rand&quot;\n    &quot;encoding&#x2F;json&quot;\n\n    &quot;golang.org&#x2F;x&#x2F;net&#x2F;html&quot;\n\n    &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;\n)\n\n就像我们在2.6.1节提到过的，Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的。在本章，我们将深入讨论Go语言工具箱的功能，包括大家经常使用的构建测试等功能。当然，也有第三方扩展的工具箱存在。例如，Google公司内部的Go语言码农，他们就使用内部的多语言构建系统（译注：Google公司使用的是类似Bazel的构建系统，支持多种编程语言，目前该构件系统还不能完整支持Windows环境），用不同的规则来处理包名字和定位包，用不同的规则来处理单元测试等等，因为这样可以更紧密适配他们内部环境。\n如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。summary: \n\n每个包都拥有全局唯一名字\ngolang拥有自己的构建工具，也可以使用第三方构建工具，例如google的bazel构建系统，有点类似于java的maven和gradle\n如果发布包建议用公司名作为前缀,并做到全球统一，这样有利于包的检索,例如上面的mysql包\n文件开头以_和.的会被忽略\n\n10.3. 包声明在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符(也称为包名)例如，math&#x2F;rand包的每个源文件的开头都包含package rand包声明语句，所以当你导入这个包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员.\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;math&#x2F;rand&quot;\n)\n\nfunc main() &#123;\n    fmt.Println(rand.Int())\n&#125;\n通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math&#x2F;rand包和crypto&#x2F;rand包的包名都是rand。稍后我们将看到如何同时导入两个有相同包名的包。\n关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。\n第二个例外，包所在的目录中可能有一些文件名是以_test.go为后缀的Go源文件（译注：前面必须有其它的字符，因为以_或.开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖，具体细节我们将在11.2.4节中介绍。\n第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in&#x2F;yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml。\nsummary: \n\n包声明语句的主要目的是定义当前包,这样就可以规范代码作用范围\n默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。我可以对包重命名\nmain包不被别人的包导入。他是构建工具的入口\n包目录下会包含_test.go结尾的文件,这种目录可以包含：一种是普通包，另一种则是测试的外部扩展包.这是测试文件,_或.开头的源文件会被构建工具忽略\n导入路径后追加版本号信息,这种情况下包的名字并不包含版本号后缀,例如“gopkg.in&#x2F;yaml.v2”\n\n\n\n10.4. 导入声明可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。下面两个导入形式是等价的，但是第二种形式更为常见。\nimport &quot;fmt&quot;\nimport &quot;os&quot;\n\nimport (\n    &quot;fmt&quot;\n    &quot;os&quot;\n)\n导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt和goimports工具都可以将不同分组导入的包独立排序。）\nimport (\n    &quot;fmt&quot;\n    &quot;html&#x2F;template&quot;\n    &quot;os&quot;\n\n    &quot;golang.org&#x2F;x&#x2F;net&#x2F;html&quot;\n    &quot;golang.org&#x2F;x&#x2F;net&#x2F;ipv4&quot;\n)\n如果我们想同时导入两个有着名字相同的包，例如math&#x2F;rand包和crypto&#x2F;rand包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。\nimport (\n    &quot;crypto&#x2F;rand&quot;\n    mrand &quot;math&#x2F;rand&quot; &#x2F;&#x2F; alternative name mrand avoids conflict\n)\n导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。\n导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以将“path”标准包重命名为pathpkg。\n每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。summary: \n\n包名可以被重命名\n\n10.5. 包的匿名导入如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数（§2.6.2）。这时候我们需要抑制“unused import”编译错误，我们可以用下划线_来重命名导入的包。像往常一样，下划线_为空白标识符，并不能被访问。\nimport _ &quot;image&#x2F;png&quot; &#x2F;&#x2F; register PNG decoder\n这个被称为包的匿名导入。它通常是用来实现一个编译时机制，然后通过在main主程序入口选择性地导入附加的包。首先，让我们看看如何使用该特性，然后再看看它是如何工作的。\n标准库的image图像包包含了一个Decode函数，用于从io.Reader接口读取数据并解码图像，它调用底层注册的图像解码器来完成任务，然后返回image.Image类型的图像。使用image.Decode很容易编写一个图像格式的转换工具，读取一种格式的图像，然后编码为另一种图像格式：\ngopl.io&#x2F;ch10&#x2F;jpeg\n\n\n&#x2F;&#x2F; The jpeg command reads a PNG image from the standard input\n&#x2F;&#x2F; and writes it as a JPEG image to the standard output.\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;image&quot;\n    &quot;image&#x2F;jpeg&quot;\n    _ &quot;image&#x2F;png&quot; &#x2F;&#x2F; register PNG decoder\n    &quot;io&quot;\n    &quot;os&quot;\n)\n\nfunc main() &#123;\n    if err :&#x3D; toJPEG(os.Stdin, os.Stdout); err !&#x3D; nil &#123;\n        fmt.Fprintf(os.Stderr, &quot;jpeg: %v\\n&quot;, err)\n        os.Exit(1)\n    &#125;\n&#125;\n\nfunc toJPEG(in io.Reader, out io.Writer) error &#123;\n    img, kind, err :&#x3D; image.Decode(in)\n    if err !&#x3D; nil &#123;\n        return err\n    &#125;\n    fmt.Fprintln(os.Stderr, &quot;Input format &#x3D;&quot;, kind)\n    return jpeg.Encode(out, img, &amp;jpeg.Options&#123;Quality: 95&#125;)\n&#125;\n如果我们将gopl.io&#x2F;ch3&#x2F;mandelbrot（§3.3）的输出导入到这个程序的标准输入，它将解码输入的PNG格式图像，然后转换为JPEG格式的图像输出（图3.3）。\n$ go build gopl.io&#x2F;ch3&#x2F;mandelbrot\n$ go build gopl.io&#x2F;ch10&#x2F;jpeg\n$ .&#x2F;mandelbrot | .&#x2F;jpeg &gt;mandelbrot.jpg\nInput format &#x3D; png\n要注意image&#x2F;png包的匿名导入语句。如果没有这一行语句，程序依然可以编译和运行，但是它将不能正确识别和解码PNG格式的图像：\n$ go build gopl.io&#x2F;ch10&#x2F;jpeg\n$ .&#x2F;mandelbrot | .&#x2F;jpeg &gt;mandelbrot.jpg\njpeg: image: unknown format\n下面的代码演示了它的工作机制。标准库还提供了GIF、PNG和JPEG等格式图像的解码器，用户也可以提供自己的解码器，但是为了保持程序体积较小，很多解码器并没有被全部包含，除非是明确需要支持的格式。image.Decode函数在解码时会依次查询支持的格式列表。每个格式驱动列表的每个入口指定了四件事情：格式的名称；一个用于描述这种图像数据开头部分模式的字符串，用于解码器检测识别；一个Decode函数用于完成解码图像工作；一个DecodeConfig函数用于解码图像的大小和颜色空间的信息。每个驱动入口是通过调用image.RegisterFormat函数注册，一般是在每个格式包的init初始化函数中调用，例如image&#x2F;png包是这样注册的：\npackage png &#x2F;&#x2F; image&#x2F;png\n\nfunc Decode(r io.Reader) (image.Image, error)\nfunc DecodeConfig(r io.Reader) (image.Config, error)\n\nfunc init() &#123;\n    const pngHeader &#x3D; &quot;\\x89PNG\\r\\n\\x1a\\n&quot;\n    image.RegisterFormat(&quot;png&quot;, pngHeader, Decode, DecodeConfig)\n&#125;\n最终的效果是，主程序只需要匿名导入特定图像驱动包就可以用image.Decode解码对应格式的图像了。\n数据库包database&#x2F;sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。例如：\nimport (\n    &quot;database&#x2F;sql&quot;\n    _ &quot;github.com&#x2F;lib&#x2F;pq&quot;              &#x2F;&#x2F; enable support for Postgres\n    _ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot; &#x2F;&#x2F; enable support for MySQL\n)\n\ndb, err &#x3D; sql.Open(&quot;postgres&quot;, dbname) &#x2F;&#x2F; OK\ndb, err &#x3D; sql.Open(&quot;mysql&quot;, dbname)    &#x2F;&#x2F; OK\ndb, err &#x3D; sql.Open(&quot;sqlite3&quot;, dbname)  &#x2F;&#x2F; returns error: unknown driver &quot;sqlite3&quot;\n练习 10.1： 扩展jpeg程序，以支持任意图像格式之间的相互转换，使用image.Decode检测支持的格式类型，然后通过flag命令行标志参数选择输出的格式。\n练习 10.2： 设计一个通用的压缩文件读取框架，用来读取ZIP（archive&#x2F;zip）和POSIX tar（archive&#x2F;tar）格式压缩的文档。使用类似上面的注册技术来扩展支持不同的压缩格式，然后根据需要通过匿名导入选择导入要支持的压缩格式的驱动包。\nsummary: 包的匿名导入\n\n包的匿名导入。它通常是用来实现一个编译时机制,可以解决相同函数，但是类型不同的调用问题，比如image/png和image/jpeg的Decode问题,感觉像是多态。\n没有image/png依然可以编译但是解析不了png格式\n同时不同的数据库的驱动程序\n初始化包级变量\n按顺序初始化包中每个文件里的 init 函数\n每个文件中可以包含多个 init 函数，按顺序执行(所以你导和不导包差距很大，匿名导入只是表明你无法使用相应包内函数)\n包名和成员名要尽量的短，并且能见名知意\n\n10.6. 包和命名在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。\n当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中最常用的包有bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包。\n尽可能让命名有描述性且无歧义。例如，类似imageutil或ioutilis的工具包命名已经足够简洁了，就无须再命名为util了。要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户重命名导入包，例如前面看到的path包。\n包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免和预定义的类型冲突，同样还有go&#x2F;types是为了避免和type关键字冲突。\n要避免包名有其它的含义。例如，2.5节中我们的温度转换包最初使用了temp包名，虽然并没有持续多久。但这是一个糟糕的尝试，因为temp几乎是临时变量的同义词。然后我们有一段时间使用了temperature作为包名，显然名字并没有表达包的真实用途。最后我们改成了和strconv标准包类似的tempconv包名，这个名字比之前的就好多了。\n现在让我们看看如何命名包的成员。由于是通过包的导入名字引入包里面的成员，例如fmt.Println，同时包含了包名和成员名信息。因此，我们一般并不需要关注Println的具体内容，因为fmt包名已经包含了这个信息。当设计一个包的时候，需要考虑包名和成员名两个部分如何很好地配合。下面有一些例子:\nbytes.Equal\nflag.Int\nhttp.Get\njson.Marshal\n我们可以看到一些常用的命名模式。strings包提供了和字符串相关的诸多操作：\npackage strings\n\nfunc Index(needle, haystack string) int\n\ntype Replacer struct&#123; &#x2F;* ... *&#x2F; &#125;\nfunc NewReplacer(oldnew ...string) *Replacer\n\ntype Reader struct&#123; &#x2F;* ... *&#x2F; &#125;\nfunc NewReader(s string) *Reader\n包名strings并没有出现在任何成员名字中。因为用户会这样引用这些成员strings.Index、strings.Replacer等。\n其它一些包，可能只描述了单一的数据类型，例如html&#x2F;template和math&#x2F;rand等，只暴露一个主要的数据结构和与它相关的方法，还有一个以New命名的函数用于创建实例。\npackage rand &#x2F;&#x2F; &quot;math&#x2F;rand&quot;\n\ntype Rand struct&#123; &#x2F;* ... *&#x2F; &#125;\nfunc New(source Source) *Rand\n\n这可能导致一些名字重复，例如template.Template或rand.Rand&#96;，这就是这些种类的包名往往特别短的原因之一。\n在另一个极端，还有像net/http包那样含有非常多的名字和种类不多的数据类型，因为它们都是要执行一个复杂的复合任务。尽管有将近二十种类型和更多的函数，但是包中最重要的成员名字却是简单明了的：Get、Post、Handle、Error、Client、Server等。\n10.7. 工具本章剩下的部分将讨论Go语言工具箱的具体功能，包括如何下载、格式化、构建、测试和安装Go语言编写的程序。\nGo语言的工具箱集合了一系列功能的命令集。它可以看作是一个包管理器（类似于Linux中的apt和rpm工具），用于包的查询、计算包的依赖关系、从远程版本控制系统下载它们等任务。它也是一个构建系统，计算文件的依赖关系，然后调用编译器、汇编器和链接器构建程序，虽然它故意被设计成没有标准的make命令那么复杂。它也是一个单元测试和基准测试的驱动程序，我们将在第11章讨论测试话题。\nGo语言工具箱的命令有着类似“瑞士军刀”的风格，带着一打的子命令，有一些我们经常用到，例如get、run、build和fmt等。你可以运行go或go help命令查看内置的帮助文档，为了查询方便，我们列出了最常用的命令：\n$ go\n...\n    build            compile packages and dependencies\n    clean            remove object files\n    doc              show documentation for package or symbol\n    env              print Go environment information\n    fmt              run gofmt on package sources\n    get              download and install packages and dependencies\n    install          compile and install packages and dependencies\n    list             list packages\n    run              compile and run Go program\n    test             test packages\n    version          print Go version\n    vet              run go tool vet on packages\n\nUse &quot;go help [command]&quot; for more information about a command.\n...\n\n为了达到零配置的设计目标，Go语言的工具箱很多地方都依赖各种约定。例如，根据给定的源文件的名称，Go语言的工具可以找到源文件对应的包，因为每个目录只包含了单一的包，并且包的导入路径和工作区的目录结构是对应的。给定一个包的导入路径，Go语言的工具可以找到与之对应的存储着实体文件的目录。它还可以根据导入路径找到存储代码的仓库的远程服务器URL。\n10.7.1. 工作区结构对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目录即可。当需要切换到不同工作区的时候，只要更新GOPATH就可以了。例如，我们在编写本书时将GOPATH设置为\n$HOME&#x2F;gobook：\n$ export GOPATH&#x3D;$HOME&#x2F;gobook\n$ go get gopl.io&#x2F;...\n当你用前面介绍的命令下载本书全部的例子源码之后，你的当前工作区的目录结构应该是这样的：\nGOPATH&#x2F;\n    src&#x2F;\n        gopl.io&#x2F;\n            .git&#x2F;\n            ch1&#x2F;\n                helloworld&#x2F;\n                    main.go\n                dup&#x2F;\n                    main.go\n                ...\n        golang.org&#x2F;x&#x2F;net&#x2F;\n            .git&#x2F;\n            html&#x2F;\n                parse.go\n                node.go\n                ...\n    bin&#x2F;\n        helloworld\n        dup\n    pkg&#x2F;\n        darwin_amd64&#x2F;\n\nGOPATH对应的工作区目录有三个子目录。其中src子目录用于存储源代码。每个包被保存在与$GOPATH&#x2F;src的相对路径为包导入路径的子目录中，例如gopl.io&#x2F;ch1&#x2F;helloworld相对应的路径目录。我们看到，一个GOPATH工作区的src目录中可能有多个独立的版本控制系统，例如gopl.io和golang.org分别对应不同的Git仓库。其中pkg子目录用于保存编译后的包的目标文件，bin子目录用于保存编译后的可执行程序，例如helloworld可执行程序。\n第二个环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为$GOROOT&#x2F;src&#x2F;fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。\n其中go env命令用于查看Go语言工具涉及的所有环境变量的值，包括未设置环境变量的默认值。GOOS环境变量用于指定目标操作系统（例如android、linux、darwin或windows），GOARCH环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然GOPATH环境变量是唯一必须要设置的，但是其它环境变量也会偶尔用到。\n$ go env\nGOPATH&#x3D;&quot;&#x2F;home&#x2F;gopher&#x2F;gobook&quot;\nGOROOT&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;go&quot;\nGOARCH&#x3D;&quot;amd64&quot;\nGOOS&#x3D;&quot;darwin&quot;\n...\n\n10.7.2. 下载包使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互联网上找到和更新包。\n使用命令go get可以下载一个单一的包或者用…下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中golang.org&#x2F;x&#x2F;net&#x2F;html自动出现在本地工作区目录的原因。\n一旦go get命令下载了包，然后就是安装包或包对应的可执行的程序。我们将在下一节再关注它的细节，现在只是展示整个下载过程是如何的简单。第一个命令是获取golint工具，它用于检测Go源代码的编程风格是否有问题。第二个命令是用golint命令对2.6.2节的gopl.io&#x2F;ch2&#x2F;popcount包代码进行编码风格检查。它友好地报告了忘记了包的文档：\n$ go get github.com&#x2F;golang&#x2F;lint&#x2F;golint\n$ $GOPATH&#x2F;bin&#x2F;golint gopl.io&#x2F;ch2&#x2F;popcount\nsrc&#x2F;gopl.io&#x2F;ch2&#x2F;popcount&#x2F;main.go:1:1:\n  package comment should be of the form &quot;Package popcount ...&quot;\n\ngo get命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。运行go help importpath获取相关的信息。\ngo get命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如golang.org&#x2F;x&#x2F;net包目录对应一个Git仓库：\n$ cd $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;net\n$ git remote -v\norigin  https:&#x2F;&#x2F;go.googlesource.com&#x2F;net (fetch)\norigin  https:&#x2F;&#x2F;go.googlesource.com&#x2F;net (push)\n需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面 https://golang.org/x/net/html 包含了如下的元数据，它告诉Go语言的工具当前包真实的Git仓库托管地址：\n$ go build gopl.io&#x2F;ch1&#x2F;fetch\n$ .&#x2F;fetch https:&#x2F;&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html | grep go-import\n&lt;meta name&#x3D;&quot;go-import&quot;\n      content&#x3D;&quot;golang.org&#x2F;x&#x2F;net git https:&#x2F;&#x2F;go.googlesource.com&#x2F;net&quot;&gt;\n\n如果指定-u命令行标志参数，go get命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码将不会被自动更新。\ngo get -u命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以复制后golang.org&#x2F;x&#x2F;net&#x2F;html导入路径可能会变为gopl.io&#x2F;vendor&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html。最新的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。不过可以通过go help gopath命令查看Vendor的帮助文档。\n(译注：墙内用户在上面这些命令的基础上，还需要学习用翻墙来go get。)\n练习 10.3: 从 http://gopl.io/ch1/helloworld?go-get=1 获取内容，查看本书的代码的真实托管的网址（go get请求HTML页面时包含了go-get参数，以区别普通的浏览器请求）。\n10.7.3. 构建包go build命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。如果包的名字是main，go build将调用链接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字。\n由于每个目录只包含一个包，因此每个对应可执行程序或者叫Unix术语中的命令的包，会要求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面，例如用于提供Go文档服务的golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;godoc命令就是放在cmd子目录（§10.7.4）。\n每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径名指定，相对路径必须以.或..开头。如果没有指定参数，那么默认指定为当前目录对应的包。下面的命令用于构建同一个包，虽然它们的写法各不相同：\n$ cd $GOPATH&#x2F;src&#x2F;gopl.io&#x2F;ch1&#x2F;helloworld\n$ go build\n或者：\n$ cd anywhere\n$ go build gopl.io&#x2F;ch1&#x2F;helloworld\n或者：\n$ cd $GOPATH\n$ go build .&#x2F;src&#x2F;gopl.io&#x2F;ch1&#x2F;helloworld\n但不能这样：\n$ cd $GOPATH\n$ go build src&#x2F;gopl.io&#x2F;ch1&#x2F;helloworld\nError: cannot find package &quot;src&#x2F;gopl.io&#x2F;ch1&#x2F;helloworld&quot;.\n也可以指定包的源文件列表，这一般只用于构建一些小程序或做一些临时性的实验。如果是main包，将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。\n$ cat quoteargs.go\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;os&quot;\n)\n\nfunc main() &#123;\n    fmt.Printf(&quot;%q\\n&quot;, os.Args[1:])\n&#125;\n$ go build quoteargs.go\n$ .&#x2F;quoteargs one &quot;two three&quot; four\\ five\n[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;]\n特别是对于这类一次性运行的程序，我们希望尽快的构建并运行它。go run命令实际上是结合了构建和运行的两个步骤：\n$ go run quoteargs.go one &quot;two three&quot; four\\ five\n[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;]\n(译注：其实也可以偷懒，直接go run *.go)\n第一行的参数列表中，第一个不是以.go结尾的将作为可执行程序的参数运行。\n默认情况下，go build命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。依赖分析和编译过程虽然都是很快的，但是随着项目增加到几十个包和成千上万行代码，依赖关系分析和编译时间的消耗将变的可观，有时候可能需要几秒种，即使这些依赖项没有改变。\ngo install命令和go build命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到$GOPATH&#x2F;pkg目录下，目录路径和 src目录路径对应，可执行程序被保存到$GOPATH&#x2F;bin目录。（很多用户会将$GOPATH&#x2F;bin添加到可执行程序的搜索列表中。）还有，go install命令和go build命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。为了方便编译依赖的包，go build -i命令将安装每个目标所依赖的包。\n因为编译对应不同的操作系统平台和CPU架构，go install命令会将编译结果安装到GOOS和GOARCH对应的目录。例如，在Mac系统，golang.org&#x2F;x&#x2F;net&#x2F;html包将被安装到$GOPATH&#x2F;pkg&#x2F;darwin_amd64目录下的golang.org&#x2F;x&#x2F;net&#x2F;html.a文件。\n针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的GOOS和GOARCH，然后运行构建命令即可。下面交叉编译的程序将输出它在编译时的操作系统和CPU类型：\n\n&#x2F;&#x2F; gopl.io&#x2F;ch10&#x2F;cross\n\n\nfunc main() &#123;\n    fmt.Println(runtime.GOOS, runtime.GOARCH)\n&#125;\n下面以64位和32位环境分别编译和执行：\n$ go build gopl.io&#x2F;ch10&#x2F;cross\n$ .&#x2F;cross\ndarwin amd64\n$ GOARCH&#x3D;386 go build gopl.io&#x2F;ch10&#x2F;cross\n$ .&#x2F;cross\ndarwin 386\n有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释参数可以提供更多的构建过程控制。例如，文件中可能包含下面的注释：\n&#x2F;&#x2F; +build linux darwin\n在包声明和包注释的前面，该构建注释参数告诉go build只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件：\n&#x2F;&#x2F; +build ignore\n更多细节，可以参考go&#x2F;build包的构建约束部分的文档。\n$ go doc go&#x2F;build\n\n10.7.4. 包文档Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。\nGo语言中的文档注释一般是完整的句子，第一行通常是摘要说明，以被注释者的名字开头。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如，下面是fmt.Fprintf的文档注释。\n&#x2F;&#x2F; Fprintf formats according to a format specifier and writes to w.\n&#x2F;&#x2F; It returns the number of bytes written and any write error encountered.\nfunc Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (int, error)\n\nFprintf函数格式化的细节在fmt包文档中描述。如果注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。\n好的文档并不需要面面俱到，文档本身应该是简洁但不可忽略的。事实上，Go语言的风格更喜欢简洁的文档，并且文档也是需要像代码一样维护的。对于一组声明语句，可以用一个精炼的句子描述，如果是显而易见的功能则并不需要注释。\n在本书中，只要空间允许，我们之前很多包声明都包含了注释文档，但你可以从标准库中发现很多更好的例子。有两个工具可以帮到你。\n首先是go doc命令，该命令打印其后所指定的实体的声明与文档注释，该实体可能是一个包：\n$ go doc time\npackage time &#x2F;&#x2F; import &quot;time&quot;\n\nPackage time provides functionality for measuring and displaying time.\n\nconst Nanosecond Duration &#x3D; 1 ...\nfunc After(d Duration) &lt;-chan Time\nfunc Sleep(d Duration)\nfunc Since(t Time) Duration\nfunc Now() Time\ntype Duration int64\ntype Time struct &#123; ... &#125;\n...many more...\n或者是某个具体的包成员：\n$ go doc time.Since\nfunc Since(t Time) Duration\n\n    Since returns the time elapsed since t.\n    It is shorthand for time.Now().Sub(t).\n或者是一个方法：\n$ go doc time.Duration.Seconds\nfunc (d Duration) Seconds() float64\n\n    Seconds returns the duration as a floating-point number of seconds.\n该命令并不需要输入完整的包导入路径或正确的大小写。下面的命令将打印encoding&#x2F;json包的(*json.Decoder).Decode方法的文档：\n$ go doc json.decode\nfunc (dec *Decoder) Decode(v interface&#123;&#125;) error\n\n    Decode reads the next JSON-encoded value from its input and stores\n    it in the value pointed to by v.\n第二个工具，名字也叫godoc，它提供可以相互交叉引用的HTML页面，但是包含和go doc命令相同以及更多的信息。图10.1演示了time包的文档，11.6节将看到godoc演示可以交互的示例程序。godoc的在线服务 https://godoc.org ，包含了成千上万的开源包的检索工具。\n你也可以在自己的工作区目录运行godoc服务。运行下面的命令，然后在浏览器查看 http://localhost:8000/pkg 页面：\n$ godoc -http :8000\n其中-analysis&#x3D;type和-analysis&#x3D;pointer命令行标志参数用于打开文档和代码中关于静态分析的结果。\n10.7.5. 内部包在Go语言程序中，包是最重要的封装机制。没有导出的标识符只在同一个包内部可以访问，而导出的标识符则是面向全宇宙都是可见的。\n有时候，一个中间的状态可能也是有用的，标识符对于一小部分信任的包是可见的，但并不是对所有调用者都可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用。\n为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包。\nnet&#x2F;http\nnet&#x2F;http&#x2F;internal&#x2F;chunked\nnet&#x2F;http&#x2F;httputil\nnet&#x2F;url\n\n10.7.6. 查询包go list命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径：\n$ go list github.com&#x2F;go-sql-driver&#x2F;mysql\ngithub.com&#x2F;go-sql-driver&#x2F;mysql\ngo list命令的参数还可以用”…”表示匹配任意的包的导入路径。我们可以用它来列出工作区中的所有包：\n$ go list ...\narchive&#x2F;tar\narchive&#x2F;zip\nbufio\nbytes\ncmd&#x2F;addr2line\ncmd&#x2F;api\n...many more...\n或者是特定子目录下的所有包：\n$ go list gopl.io&#x2F;ch3&#x2F;...\ngopl.io&#x2F;ch3&#x2F;basename1\ngopl.io&#x2F;ch3&#x2F;basename2\ngopl.io&#x2F;ch3&#x2F;comma\ngopl.io&#x2F;ch3&#x2F;mandelbrot\ngopl.io&#x2F;ch3&#x2F;netflag\ngopl.io&#x2F;ch3&#x2F;printints\ngopl.io&#x2F;ch3&#x2F;surface\n或者是和某个主题相关的所有包:\n$ go list ...xml...\nencoding&#x2F;xml\ngopl.io&#x2F;ch7&#x2F;xmlselect\ngo list命令还可以获取每个包完整的元信息，而不仅仅只是导入路径，这些元信息可以以不同格式提供给用户。其中-json命令行参数表示用JSON格式打印每个包的元信息。\n$ go list -json hash\n&#123;\n    &quot;Dir&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&#x2F;src&#x2F;hash&quot;,\n    &quot;ImportPath&quot;: &quot;hash&quot;,\n    &quot;Name&quot;: &quot;hash&quot;,\n    &quot;Doc&quot;: &quot;Package hash provides interfaces for hash functions.&quot;,\n    &quot;Target&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&#x2F;pkg&#x2F;darwin_amd64&#x2F;hash.a&quot;,\n    &quot;Goroot&quot;: true,\n    &quot;Standard&quot;: true,\n    &quot;Root&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&quot;,\n    &quot;GoFiles&quot;: [\n            &quot;hash.go&quot;\n    ],\n    &quot;Imports&quot;: [\n        &quot;io&quot;\n    ],\n    &quot;Deps&quot;: [\n        &quot;errors&quot;,\n        &quot;io&quot;,\n        &quot;runtime&quot;,\n        &quot;sync&quot;,\n        &quot;sync&#x2F;atomic&quot;,\n        &quot;unsafe&quot;\n    ]\n&#125;\n命令行参数-f则允许用户使用text&#x2F;template包（§4.6）的模板语言定义输出文本的格式。下面的命令将打印strconv包的依赖的包，然后用join模板函数将结果链接为一行，连接时每个结果之间用一个空格分隔：\n$ go list -f &#39;&#123;&#123;join .Deps &quot; &quot;&#125;&#125;&#39; strconv\nerrors math runtime unicode&#x2F;utf8 unsafe\n译注：上面的命令在Windows的命令行运行会遇到template: main:1: unclosed action的错误。产生这个错误的原因是因为命令行对命令中的” “参数进行了转义处理。可以按照下面的方法解决转义字符串的问题：\n$ go list -f &quot;&#123;&#123;join .Deps &quot; &quot;&#125;&#125;&quot; strconv\n\n下面的命令打印compress子目录下所有包的导入包列表：\n$ go list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...\ncompress&#x2F;bzip2 -&gt; bufio io sort\ncompress&#x2F;flate -&gt; bufio fmt io math sort strconv\ncompress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io time\ncompress&#x2F;lzw -&gt; bufio errors fmt io\ncompress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io\n译注：Windows下有同样有问题，要避免转义字符串的干扰：\n$ go list -f &quot;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&quot; compress&#x2F;...\ngo list命令对于一次性的交互式查询或自动化构建或测试脚本都很有帮助。我们将在11.2.4节中再次使用它。每个子命令的更多信息，包括可设置的字段和意义，可以用go help list命令查看。\n在本章，我们解释了Go语言工具中除了测试命令之外的所有重要的子命令。在下一章，我们将看到如何用go test命令去运行Go语言程序中的测试代码。\n练习 10.4： 创建一个工具，根据命令行指定的参数，报告工作区所有依赖包指定的其它包集合。提示：你需要运行go list命令两次，一次用于初始化包，一次用于所有包。你可能需要用encoding&#x2F;json（§4.5）包来分析输出的JSON格式的信息。\nsummary: go的工具\n\n工作区结构 : 当需要切换工作区的时候，只需要更新下GOPATH环境变量即可src保存源代码,pkg子目录用于保存编译后的包的目标文件,bin子目录用于保存编译后的可执行程序\n下载包 : go get命令，go get -u命令只是简单地保证每个下载最新版本，实际工作中要对包版本做精细的管理，需要vendor目录管理不同版本的包,go help gopath查看vendor帮助文档,而go get 相当于获取的是远程仓库源代码的整个库，还可以看到仓库的版本信息，go支持导入远程github仓库的代码，go get下载的包保存在哪里呢？一般他会保存在这个目录：GOPATH/src  goget详细介绍，go get是对模块代码的更新\n构建包 : 可以使用相对路径和绝对路径进行构建项目，go run其实也可以偷懒，直接go run *.go,go build -i命令将安装每个目标所依赖的包,// +build linux darwin,在包声明和包注释的前面，该构建注释参数告诉go build只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件,// +build ignore这个构建注释则表示不编译这个文件。go doc go/build\n包文档 : 专门用于保存包文档的源文件通常叫doc.go,例如 go doc time 某个具体成员结构go doc time.Since,或者具体函数go doc time.Duration.Second , 更简单的是godoc -http :8000包含了所有go包的索引，-analysis=type和-analysis=pointer命令行标志参数用于打开文档和代码中关于静态分析的结果\n内部包 : 一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包\n搜索包 : go list列出工作区相关包,还可以查看完整包的原信息,例如hash包go list -json hash\n命令行参数-f则允许用户使用text&#x2F;template包（§4.6）的模板语言定义输出文本的格式 &#x2F;&#x2F;windows环境下注意\ngo list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...\n  compress&#x2F;bzip2 -&gt; bufio io sort\n  compress&#x2F;flate -&gt; bufio fmt io math sort strconv\n  compress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io time\n  compress&#x2F;lzw -&gt; bufio errors fmt io\n  compress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io\n\n\n\n11. 测试Maurice Wilkes，第一个存储程序计算机EDSAC的设计者，1949年他在实验室爬楼梯时有一个顿悟。在《计算机先驱回忆录》（Memoirs of a Computer Pioneer）里，他回忆到：“忽然间有一种醍醐灌顶的感觉，我整个后半生的美好时光都将在寻找程序BUG中度过了”。肯定从那之后的大部分正常的码农都会同情Wilkes过分悲观的想法，虽然也许会有人困惑于他对软件开发的难度的天真看法。\n现在的程序已经远比Wilkes时代的更大也更复杂，也有许多技术可以让软件的复杂性可得到控制。其中有两种技术在实践中证明是比较有效的。第一种是代码在被正式部署前需要进行代码评审。第二种则是测试，也就是本章的讨论主题。\n我们说测试的时候一般是指自动化测试，也就是写一些小的程序用来检测被测试代码（产品代码）的行为和预期的一样，这些通常都是精心设计的执行某些特定的功能或者是通过随机性的输入待验证边界的处理。\n软件测试是一个巨大的领域。测试的任务可能已经占据了一些程序员的部分时间和另一些程序员的全部时间。和软件测试技术相关的图书或博客文章有成千上万之多。对于每一种主流的编程语言，都会有一打的用于测试的软件包，同时也有大量的测试相关的理论，而且每种都吸引了大量技术先驱和追随者。这些都足以说服那些想要编写有效测试的程序员重新学习一套全新的技能。\nGo语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的，而且它很容易延伸到基准测试和示例文档。\n在实践中，编写测试代码和编写程序本身并没有多大区别。我们编写的每一个函数也是针对每个具体的任务。我们必须小心处理边界条件，思考合适的数据结构，推断合适的输入应该产生什么样的结果输出。编写测试代码和编写普通的Go代码过程是类似的；它并不需要学习新的符号、规则和工具。\ngo test选项含义\n\n-args 传递参数到test binary(到时候补一个demo)\n-exec xprog  运行test binary ,原理如同 go run\n-i 安装test binary的相关依赖\n-json 将测试输出转化为json为了自动化处理\n-c file   定义编译后的binary的文件名,编译test binary,但是不执行\n\n\n11.1 go testgo test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。\n在*_test.go文件中，有三种类型的函数：测试函数、基准测试（benchmark）函数、示例函数。一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间。示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。我们将在11.2节讨论测试函数的所有细节，并在11.4节讨论基准测试函数的细节，然后在11.6节讨论示例函数的细节。\ngo test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。\n11.2 测试函数每个测试函数必须导入testing包。测试函数有如下的签名：\nfunc TestName(t *testing.T) &#123;\n    &#x2F;&#x2F; ...\n&#125;\n测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头：\nfunc TestSin(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125;\nfunc TestCos(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125;\nfunc TestLog(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125;\n其中t参数用于报告测试失败和附加的日志信息。让我们定义一个实例包gopl.io&#x2F;ch11&#x2F;word1，其中只有一个函数IsPalindrome用于检查一个字符串是否从前向后和从后向前读都是一样的。（下面这个实现对于一个字符串是否是回文字符串前后重复测试了两次；我们稍后会再讨论这个问题。）\ngopl.io&#x2F;ch11&#x2F;word1\n\n\n&#x2F;&#x2F; Package word provides utilities for word games.\npackage word\n\n&#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.\n&#x2F;&#x2F; (Our first attempt.)\nfunc IsPalindrome(s string) bool &#123;\n    for i :&#x3D; range s &#123;\n        if s[i] !&#x3D; s[len(s)-1-i] &#123;\n            return false\n        &#125;\n    &#125;\n    return true\n&#125;\n在相同的目录下，word_test.go测试文件中包含了TestPalindrome和TestNonPalindrome两个测试函数。每一个都是测试IsPalindrome是否给出正确的结果，并使用t.Error报告失败信息：\n\npackage word\n\nimport &quot;testing&quot;\n\nfunc TestPalindrome(t *testing.T) &#123;\n    if !IsPalindrome(&quot;detartrated&quot;) &#123;\n        t.Error(&#96;IsPalindrome(&quot;detartrated&quot;) &#x3D; false&#96;)\n    &#125;\n    if !IsPalindrome(&quot;kayak&quot;) &#123;\n        t.Error(&#96;IsPalindrome(&quot;kayak&quot;) &#x3D; false&#96;)\n    &#125;\n&#125;\n\nfunc TestNonPalindrome(t *testing.T) &#123;\n    if IsPalindrome(&quot;palindrome&quot;) &#123;\n        t.Error(&#96;IsPalindrome(&quot;palindrome&quot;) &#x3D; true&#96;)\n    &#125;\n&#125;\ngo test命令如果没有参数指定包那么将默认采用当前目录对应的包（和go build命令一样）。我们可以用下面的命令构建和运行测试。\n$ cd $GOPATH&#x2F;src&#x2F;gopl.io&#x2F;ch11&#x2F;word1\n$ go test\nok   gopl.io&#x2F;ch11&#x2F;word1  0.008s\n结果还比较满意，我们运行了这个程序， 不过没有提前退出是因为还没有遇到BUG报告。不过一个法国名为“Noelle Eve Elleon”的用户会抱怨IsPalindrome函数不能识别“été”。另外一个来自美国中部用户的抱怨则是不能识别“A man, a plan, a canal: Panama.”。执行特殊和小的BUG报告为我们提供了新的更自然的测试用例。\nfunc TestFrenchPalindrome(t *testing.T) &#123;\n    if !IsPalindrome(&quot;été&quot;) &#123;\n        t.Error(&#96;IsPalindrome(&quot;été&quot;) &#x3D; false&#96;)\n    &#125;\n&#125;\n\nfunc TestCanalPalindrome(t *testing.T) &#123;\n    input :&#x3D; &quot;A man, a plan, a canal: Panama&quot;\n    if !IsPalindrome(input) &#123;\n        t.Errorf(&#96;IsPalindrome(%q) &#x3D; false&#96;, input)\n    &#125;\n&#125;\n为了避免两次输入较长的字符串，我们使用了提供了有类似Printf格式化功能的 Errorf函数来汇报错误结果。\n当添加了这两个测试用例之后，go test返回了测试失败的信息。\n$ go test\n--- FAIL: TestFrenchPalindrome (0.00s)\n    word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false\n--- FAIL: TestCanalPalindrome (0.00s)\n    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; false\nFAIL\nFAIL    gopl.io&#x2F;ch11&#x2F;word1  0.014s\n先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯。只有这样，我们才能定位我们要真正解决的问题。\n先写测试用例的另外的好处是，运行测试通常会比手工描述报告的处理更快，这让我们可以进行快速地迭代。如果测试集有很多运行缓慢的测试，我们可以通过只选择运行某些特定的测试来加快测试速度。\n参数-v可用于打印每个测试函数的名字和运行时间：\n$ go test -v\n&#x3D;&#x3D;&#x3D; RUN TestPalindrome\n--- PASS: TestPalindrome (0.00s)\n&#x3D;&#x3D;&#x3D; RUN TestNonPalindrome\n--- PASS: TestNonPalindrome (0.00s)\n&#x3D;&#x3D;&#x3D; RUN TestFrenchPalindrome\n--- FAIL: TestFrenchPalindrome (0.00s)\n    word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false\n&#x3D;&#x3D;&#x3D; RUN TestCanalPalindrome\n--- FAIL: TestCanalPalindrome (0.00s)\n    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; false\nFAIL\nexit status 1\nFAIL    gopl.io&#x2F;ch11&#x2F;word1  0.017s\n参数-run对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被go test测试命令运行：\n$ go test -v -run&#x3D;&quot;French|Canal&quot;\n&#x3D;&#x3D;&#x3D; RUN TestFrenchPalindrome\n--- FAIL: TestFrenchPalindrome (0.00s)\n    word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false\n&#x3D;&#x3D;&#x3D; RUN TestCanalPalindrome\n--- FAIL: TestCanalPalindrome (0.00s)\n    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; false\nFAIL\nexit status 1\nFAIL    gopl.io&#x2F;ch11&#x2F;word1  0.014s\n当然，一旦我们已经修复了失败的测试用例，在我们提交代码更新之前，我们应该以不带参数的go test命令运行全部的测试用例，以确保修复失败测试的同时没有引入新的问题。\n我们现在的任务就是修复这些错误。简要分析后发现第一个BUG的原因是我们采用了 byte而不是rune序列，所以像“été”中的é等非ASCII字符不能正确处理。第二个BUG是因为没有忽略空格和字母的大小写导致的。\n针对上述两个BUG，我们仔细重写了函数：\ngopl.io&#x2F;ch11&#x2F;word2\n\n\n&#x2F;&#x2F; Package word provides utilities for word games.\npackage word\n\nimport &quot;unicode&quot;\n\n&#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.\n&#x2F;&#x2F; Letter case is ignored, as are non-letters.\nfunc IsPalindrome(s string) bool &#123;\n    var letters []rune\n    for _, r :&#x3D; range s &#123;\n        if unicode.IsLetter(r) &#123;\n            letters &#x3D; append(letters, unicode.ToLower(r))\n        &#125;\n    &#125;\n    for i :&#x3D; range letters &#123;\n        if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;\n            return false\n        &#125;\n    &#125;\n    return true\n&#125;\n同时我们也将之前的所有测试数据合并到了一个测试中的表格中。\nfunc TestIsPalindrome(t *testing.T) &#123;\n    var tests &#x3D; []struct &#123;\n        input string\n        want  bool\n    &#125;&#123;\n        &#123;&quot;&quot;, true&#125;,\n        &#123;&quot;a&quot;, true&#125;,\n        &#123;&quot;aa&quot;, true&#125;,\n        &#123;&quot;ab&quot;, false&#125;,\n        &#123;&quot;kayak&quot;, true&#125;,\n        &#123;&quot;detartrated&quot;, true&#125;,\n        &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;,\n        &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;,\n        &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;,\n        &#123;&quot;été&quot;, true&#125;,\n        &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;,\n        &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome\n        &#123;&quot;desserts&quot;, false&#125;,   &#x2F;&#x2F; semi-palindrome\n    &#125;\n    for _, test :&#x3D; range tests &#123;\n        if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123;\n            t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got)\n        &#125;\n    &#125;\n&#125;\n现在我们的新测试都通过了：\n$ go test gopl.io&#x2F;ch11&#x2F;word2\nok      gopl.io&#x2F;ch11&#x2F;word2      0.015s\n这种表格驱动的测试在Go语言中很常见。我们可以很容易地向表格添加新的测试数据，并且后面的测试逻辑也没有冗余，这样我们可以有更多的精力去完善错误信息。\n失败测试的输出并不包括调用t.Errorf时刻的堆栈调用信息。和其他编程语言或测试框架的assert断言不同，t.Errorf调用也没有引起panic异常或停止测试的执行。即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息。\n如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用t.Fatal或t.Fatalf停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。\n测试失败的信息一般的形式是“f(x) &#x3D; y, want z”，其中f(x)解释了失败的操作和对应的输入，y是实际的运行结果，z是期望的正确的结果。就像前面检查回文字符串的例子，实际的函数用于f(x)部分。显示x是表格驱动型测试中比较重要的部分，因为同一个断言可能对应不同的表格项执行多次。要避免无用和冗余的信息。在测试类似IsPalindrome返回布尔类型的函数时，可以忽略并没有额外信息的z部分。如果x、y或z是y的长度，输出一个相关部分的简明总结即可。测试的作者应该要努力帮助程序员诊断测试失败的原因。\n练习 11.1: 为4.3节中的charcount程序编写测试。\n练习 11.2: 为（§6.5）的IntSet编写一组测试，用于检查每个操作后的行为和基于内置map的集合等价，后面练习11.7将会用到。\n11.2.1. 随机测试表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行为。\n那么对于一个随机的输入，我们如何能知道希望的输出结果呢？这里有两种处理策略。第一个是编写另一个对照函数，使用简单和清晰的算法，虽然效率较低但是行为和要测试的函数是一致的，然后针对相同的随机输入检查两者的输出结果。第二种是生成的随机输入的数据遵循特定的模式，这样我们就可以知道期望的输出的模式。\n下面的例子使用的是第二种方法：randomPalindrome函数用于随机生成回文字符串。\nimport &quot;math&#x2F;rand&quot;\n\n&#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents\n&#x2F;&#x2F; are derived from the pseudo-random number generator rng.\nfunc randomPalindrome(rng *rand.Rand) string &#123;\n    n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24\n    runes :&#x3D; make([]rune, n)\n    for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;\n        r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\\u0999&#39;\n        runes[i] &#x3D; r\n        runes[n-1-i] &#x3D; r\n    &#125;\n    return string(runes)\n&#125;\n\nfunc TestRandomPalindromes(t *testing.T) &#123;\n    &#x2F;&#x2F; Initialize a pseudo-random number generator.\n    seed :&#x3D; time.Now().UTC().UnixNano()\n    t.Logf(&quot;Random seed: %d&quot;, seed)\n    rng :&#x3D; rand.New(rand.NewSource(seed))\n\n    for i :&#x3D; 0; i &lt; 1000; i++ &#123;\n        p :&#x3D; randomPalindrome(rng)\n        if !IsPalindrome(p) &#123;\n            t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)\n        &#125;\n    &#125;\n&#125;\n虽然随机测试会有不确定因素，但是它也是至关重要的，我们可以从失败测试的日志获取足够的信息。在我们的例子中，输入IsPalindrome的p参数将告诉我们真实的数据，但是对于函数将接受更复杂的输入，不需要保存所有的输入，只要日志中简单地记录随机数种子即可（像上面的方式）。有了这些随机数初始化种子，我们可以很容易修改测试代码以重现失败的随机测试。\n通过使用当前时间作为随机种子，在整个过程中的每次运行测试命令时都将探索新的随机数据。如果你使用的是定期运行的自动化测试集成系统，随机测试将特别有价值。\n练习 11.3: TestRandomPalindromes测试函数只测试了回文字符串。编写新的随机测试生成器，用于测试随机生成的非回文字符串。\n练习 11.4: 修改randomPalindrome函数，以探索IsPalindrome是否对标点和空格做了正确处理。\n译者注：拓展阅读感兴趣的读者可以再了解一下go-fuzz\n11.2.2. 测试一个命令对于测试包go test是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。如果一个包的名字是 main，那么在构建时会生成一个可执行程序，不过main包可以作为一个包被测试器代码导入。\n让我们为2.3.2节的echo程序编写一个测试。我们先将程序拆分为两个函数：echo函数完成真正的工作，main函数用于处理命令行输入参数和echo可能返回的错误。\ngopl.io&#x2F;ch11&#x2F;echo\n\n\n&#x2F;&#x2F; Echo prints its command-line arguments.\npackage main\n\nimport (\n    &quot;flag&quot;\n    &quot;fmt&quot;\n    &quot;io&quot;\n    &quot;os&quot;\n    &quot;strings&quot;\n)\n\nvar (\n    n &#x3D; flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)\n    s &#x3D; flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)\n)\n\nvar out io.Writer &#x3D; os.Stdout &#x2F;&#x2F; modified during testing\n\nfunc main() &#123;\n    flag.Parse()\n    if err :&#x3D; echo(!*n, *s, flag.Args()); err !&#x3D; nil &#123;\n        fmt.Fprintf(os.Stderr, &quot;echo: %v\\n&quot;, err)\n        os.Exit(1)\n    &#125;\n&#125;\n\nfunc echo(newline bool, sep string, args []string) error &#123;\n    fmt.Fprint(out, strings.Join(args, sep))\n    if newline &#123;\n        fmt.Fprintln(out)\n    &#125;\n    return nil\n&#125;\n在测试中我们可以用各种参数和标志调用echo函数，然后检测它的输出是否正确，我们通过增加参数来减少echo函数对全局变量的依赖。我们还增加了一个全局名为out的变量来替代直接使用os.Stdout，这样测试代码可以根据需要将out修改为不同的对象以便于检查。下面就是echo_test.go文件中的测试代码：\npackage main\n\nimport (\n    &quot;bytes&quot;\n    &quot;fmt&quot;\n    &quot;testing&quot;\n)\n\nfunc TestEcho(t *testing.T) &#123;\n    var tests &#x3D; []struct &#123;\n        newline bool\n        sep     string\n        args    []string\n        want    string\n    &#125;&#123;\n        &#123;true, &quot;&quot;, []string&#123;&#125;, &quot;\\n&quot;&#125;,\n        &#123;false, &quot;&quot;, []string&#123;&#125;, &quot;&quot;&#125;,\n        &#123;true, &quot;\\t&quot;, []string&#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;, &quot;one\\ttwo\\tthree\\n&quot;&#125;,\n        &#123;true, &quot;,&quot;, []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;, &quot;a,b,c\\n&quot;&#125;,\n        &#123;false, &quot;:&quot;, []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, &quot;1:2:3&quot;&#125;,\n    &#125;\n    for _, test :&#x3D; range tests &#123;\n        descr :&#x3D; fmt.Sprintf(&quot;echo(%v, %q, %q)&quot;,\n            test.newline, test.sep, test.args)\n\n        out &#x3D; new(bytes.Buffer) &#x2F;&#x2F; captured output\n        if err :&#x3D; echo(test.newline, test.sep, test.args); err !&#x3D; nil &#123;\n            t.Errorf(&quot;%s failed: %v&quot;, descr, err)\n            continue\n        &#125;\n        got :&#x3D; out.(*bytes.Buffer).String()\n        if got !&#x3D; test.want &#123;\n            t.Errorf(&quot;%s &#x3D; %q, want %q&quot;, descr, got, test.want)\n        &#125;\n    &#125;\n&#125;\n要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。\n通过将测试放到表格中，我们很容易添加新的测试用例。让我通过增加下面的测试用例来看看失败的情况是怎么样的：\n&#123;true, &quot;,&quot;, []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;, &quot;a b c\\n&quot;&#125;, // NOTE: wrong expectation!go test输出如下：\n$ go test gopl.io&#x2F;ch11&#x2F;echo\n--- FAIL: TestEcho (0.00s)\n    echo_test.go:31: echo(true, &quot;,&quot;, [&quot;a&quot; &quot;b&quot; &quot;c&quot;]) &#x3D; &quot;a,b,c&quot;, want &quot;a b c\\n&quot;\nFAIL\nFAIL        gopl.io&#x2F;ch11&#x2F;echo         0.006s\n错误信息描述了尝试的操作（使用Go类似语法），实际的结果和期望的结果。通过这样的错误信息，你可以在检视代码之前就很容易定位错误的原因。\n要注意的是在测试代码中并没有调用log.Fatal或os.Exit，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理。如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理。幸运的是（上面的意外只是一个插曲），我们的echo示例是比较简单的也没有需要返回非空error的情况。\n11.2.3. 白盒测试一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。相反，白盒测试有访问包内部函数和数据结构的权限，因此可以做到一些普通客户端无法实现的测试。例如，一个白盒测试可以在每个操作之后检测不变量的数据类型。（白盒测试只是一个传统的名称，其实称为clear box测试会更准确。）\n黑盒和白盒这两种测试方法是互补的。黑盒测试一般更健壮，随着软件实现的完善测试代码很少需要更新。它们可以帮助测试者了解真实客户的需求，也可以帮助发现API设计的一些不足之处。相反，白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。\n我们已经看到两种测试的例子。TestIsPalindrome测试仅仅使用导出的IsPalindrome函数，因此这是一个黑盒测试。TestEcho测试则调用了内部的echo函数，并且更新了内部的out包级变量，这两个都是未导出的，因此这是白盒测试。\n当我们准备TestEcho测试的时候，我们修改了echo函数使用包级的out变量作为输出对象，因此测试代码可以用另一个实现代替标准输出，这样可以方便对比echo输出的数据。使用类似的技术，我们可以将产品代码的其他部分也替换为一个容易测试的伪对象。使用伪对象的好处是我们可以方便配置，容易预测，更可靠，也更容易观察。同时也可以避免一些不良的副作用，例如更新生产数据库或信用卡消费行为。\n下面的代码演示了为用户提供网络存储的web服务中的配额检测逻辑。当用户使用了超过90%的存储配额之后将发送提醒邮件。（译注：一般在实现业务机器监控，包括磁盘、cpu、网络等的时候，需要类似的到达阈值&#x3D;&gt;触发报警的逻辑，所以是很实用的案例。）\ngopl.io&#x2F;ch11&#x2F;storage1\n\n\npackage storage\n\nimport (\n    &quot;fmt&quot;\n    &quot;log&quot;\n    &quot;net&#x2F;smtp&quot;\n)\n\nfunc bytesInUse(username string) int64 &#123; return 0 &#x2F;* ... *&#x2F; &#125;\n\n&#x2F;&#x2F; Email sender configuration.\n&#x2F;&#x2F; NOTE: never put passwords in source code!\nconst sender &#x3D; &quot;notifications@example.com&quot;\nconst password &#x3D; &quot;correcthorsebatterystaple&quot;\nconst hostname &#x3D; &quot;smtp.example.com&quot;\n\nconst template &#x3D; &#96;Warning: you are using %d bytes of storage,\n%d%% of your quota.&#96;\n\nfunc CheckQuota(username string) &#123;\n    used :&#x3D; bytesInUse(username)\n    const quota &#x3D; 1000000000 &#x2F;&#x2F; 1GB\n    percent :&#x3D; 100 * used &#x2F; quota\n    if percent &lt; 90 &#123;\n        return &#x2F;&#x2F; OK\n    &#125;\n    msg :&#x3D; fmt.Sprintf(template, used, percent)\n    auth :&#x3D; smtp.PlainAuth(&quot;&quot;, sender, password, hostname)\n    err :&#x3D; smtp.SendMail(hostname+&quot;:587&quot;, auth, sender,\n        []string&#123;username&#125;, []byte(msg))\n    if err !&#x3D; nil &#123;\n        log.Printf(&quot;smtp.SendMail(%s) failed: %s&quot;, username, err)\n    &#125;\n&#125;\n我们想测试这段代码，但是我们并不希望发送真实的邮件。因此我们将邮件处理逻辑放到一个私有的notifyUser函数中。\ngopl.io&#x2F;ch11&#x2F;storage2\n\n\nvar notifyUser &#x3D; func(username, msg string) &#123;\n    auth :&#x3D; smtp.PlainAuth(&quot;&quot;, sender, password, hostname)\n    err :&#x3D; smtp.SendMail(hostname+&quot;:587&quot;, auth, sender,\n        []string&#123;username&#125;, []byte(msg))\n    if err !&#x3D; nil &#123;\n        log.Printf(&quot;smtp.SendEmail(%s) failed: %s&quot;, username, err)\n    &#125;\n&#125;\n\nfunc CheckQuota(username string) &#123;\n    used :&#x3D; bytesInUse(username)\n    const quota &#x3D; 1000000000 &#x2F;&#x2F; 1GB\n    percent :&#x3D; 100 * used &#x2F; quota\n    if percent &lt; 90 &#123;\n        return &#x2F;&#x2F; OK\n    &#125;\n    msg :&#x3D; fmt.Sprintf(template, used, percent)\n    notifyUser(username, msg)\n&#125;\n现在我们可以在测试中用伪邮件发送函数替代真实的邮件发送函数。它只是简单记录要通知的用户和邮件的内容。\npackage storage\n\nimport (\n    &quot;strings&quot;\n    &quot;testing&quot;\n)\nfunc TestCheckQuotaNotifiesUser(t *testing.T) &#123;\n    var notifiedUser, notifiedMsg string\n    notifyUser &#x3D; func(user, msg string) &#123;\n        notifiedUser, notifiedMsg &#x3D; user, msg\n    &#125;\n\n    &#x2F;&#x2F; ...simulate a 980MB-used condition...\n\n    const user &#x3D; &quot;joe@example.org&quot;\n    CheckQuota(user)\n    if notifiedUser &#x3D;&#x3D; &quot;&quot; &amp;&amp; notifiedMsg &#x3D;&#x3D; &quot;&quot; &#123;\n        t.Fatalf(&quot;notifyUser not called&quot;)\n    &#125;\n    if notifiedUser !&#x3D; user &#123;\n        t.Errorf(&quot;wrong user (%s) notified, want %s&quot;,\n            notifiedUser, user)\n    &#125;\n    const wantSubstring &#x3D; &quot;98% of your quota&quot;\n    if !strings.Contains(notifiedMsg, wantSubstring) &#123;\n        t.Errorf(&quot;unexpected notification message &lt;&lt;%s&gt;&gt;, &quot;+\n            &quot;want substring %q&quot;, notifiedMsg, wantSubstring)\n    &#125;\n&#125;\n这里有一个问题：当测试函数返回后，CheckQuota将不能正常工作，因为notifyUsers依然使用的是测试函数的伪发送邮件函数（当更新全局对象的时候总会有这种风险）。 我们必须修改测试代码恢复notifyUsers原先的状态以便后续其他的测试没有影响，要确保所有的执行路径后都能恢复，包括测试失败或panic异常的情形。在这种情况下，我们建议使用defer语句来延后执行处理恢复的代码。\nfunc TestCheckQuotaNotifiesUser(t *testing.T) &#123;\n    &#x2F;&#x2F; Save and restore original notifyUser.\n    saved :&#x3D; notifyUser\n    defer func() &#123; notifyUser &#x3D; saved &#125;()\n\n    &#x2F;&#x2F; Install the test&#39;s fake notifyUser.\n    var notifiedUser, notifiedMsg string\n    notifyUser &#x3D; func(user, msg string) &#123;\n        notifiedUser, notifiedMsg &#x3D; user, msg\n    &#125;\n    &#x2F;&#x2F; ...rest of test...\n&#125;\n这种处理模式可以用来暂时保存和恢复所有的全局变量，包括命令行标志参数、调试选项和优化参数；安装和移除导致生产代码产生一些调试信息的钩子函数；还有有些诱导生产代码进入某些重要状态的改变，比如超时、错误，甚至是一些刻意制造的并发行为等因素。\n以这种方式使用全局变量是安全的，因为go test命令并不会同时并发地执行多个测试。\n11.2.4. 外部测试包考虑下这两个包：net&#x2F;url包，提供了URL解析的功能；net&#x2F;http包，提供了web服务和HTTP客户端的功能。如我们所料，上层的net&#x2F;http包依赖下层的net&#x2F;url包。然后，net&#x2F;url包中的一个测试是演示不同URL和HTTP客户端的交互行为。也就是说，一个下层包的测试代码导入了上层的包。\n这样的行为在net&#x2F;url包的测试代码中会导致包的循环依赖，正如图11.1中向上箭头所示，同时正如我们在10.1节所讲的，Go语言规范是禁止包的循环依赖的。\n不过我们可以通过外部测试包的方式解决循环依赖的问题，也就是在net&#x2F;url包所在的目录声明一个独立的url_test测试包。其中包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。我们将这个外部测试包的导入路径视作是net&#x2F;url_test会更容易理解，但实际上它并不能被其他任何包导入。\n因为外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包；包内的测试代码就无法做到这点。在设计层面，外部测试包是在所有它依赖的包的上层，正如图11.2所示。\n通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。\n我们可以用go list命令查看包对应目录中哪些Go源文件是产品代码，哪些是包内测试，还有哪些是外部测试包。我们以fmt包作为一个例子：GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分。\n$ go list -f&#x3D;&#123;&#123;.GoFiles&#125;&#125; fmt\n[doc.go format.go print.go scan.go]\nTestGoFiles表示的是fmt包内部测试代码，以_test.go为后缀文件名，不过只在测试时被构建：\n$ go list -f&#x3D;&#123;&#123;.TestGoFiles&#125;&#125; fmt\n[export_test.go]\n包的测试代码通常都在这些文件中，不过fmt包并非如此；稍后我们再解释export_test.go文件的作用。\nXTestGoFiles表示的是属于外部测试包的测试代码，也就是fmt_test包，因此它们必须先导入fmt包。同样，这些文件也只是在测试时被构建运行：\n$ go list -f&#x3D;&#123;&#123;.XTestGoFiles&#125;&#125; fmt\n[fmt_test.go scan_test.go stringer_test.go]\n有时候外部测试包也需要访问被测试包内部的代码，例如在一个为了避免循环导入而被独立到外部测试包的白盒测试。在这种情况下，我们可以通过一些技巧解决：我们在包内的一个_test.go文件中导出一个内部的实现给外部测试包。因为这些代码只有在测试时才需要，因此一般会放在export_test.go文件中。\n例如，fmt包的fmt.Scanf函数需要unicode.IsSpace函数提供的功能。但是为了避免太多的依赖，fmt包并没有导入包含巨大表格数据的unicode包；相反fmt包有一个叫isSpace内部的简易实现。\n为了确保fmt.isSpace和unicode.IsSpace函数的行为保持一致，fmt包谨慎地包含了一个测试。一个在外部测试包内的白盒测试，是无法直接访问到isSpace内部函数的，因此fmt通过一个后门导出了isSpace函数。export_test.go文件就是专门用于外部测试包的后门。\npackage fmt\nvar IsSpace &#x3D; isSpace\n这个测试文件并没有定义测试代码；它只是通过fmt.IsSpace简单导出了内部的isSpace函数，提供给外部测试包使用。这个技巧可以广泛用于位于外部测试包的白盒测试。\n11.2.5. 编写有效的测试许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测试函数的机制（通常使用反射或元数据），通过设置一些“setup”和“teardown”的钩子函数来执行测试用例运行的初始化和之后的清理操作，同时测试工具箱还提供了很多类似assert断言、值比较函数、格式化输出错误信息和停止一个失败的测试等辅助函数（通常使用异常机制）。虽然这些机制可以使得测试非常简洁，但是测试输出的日志却会像火星文一般难以理解。此外，虽然测试最终也会输出PASS或FAIL的报告，但是它们提供的信息格式却非常不利于代码维护者快速定位问题，因为失败信息的具体含义非常隐晦，比如“assert: 0 &#x3D;&#x3D; 1”或成页的海量跟踪日志。\nGo语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作，定义函数避免重复，就像普通编程那样。编写测试并不是一个机械的填空过程；一个测试也有自己的接口，尽管它的维护者也是测试仅有的一个用户。一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息。在理想情况下，维护者可以在不看代码的情况下就能根据错误信息定位错误产生的原因。一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律。\n下面的断言函数比较两个值，然后生成一个通用的错误信息，并停止程序。它很好用也确实有效，但是当测试失败的时候，打印的错误信息却几乎是没有价值的。它并没有为快速解决问题提供一个很好的入口。\nimport (\n    &quot;fmt&quot;\n    &quot;strings&quot;\n    &quot;testing&quot;\n)\n&#x2F;&#x2F; A poor assertion function.\nfunc assertEqual(x, y int) &#123;\n    if x !&#x3D; y &#123;\n        panic(fmt.Sprintf(&quot;%d !&#x3D; %d&quot;, x, y))\n    &#125;\n&#125;\nfunc TestSplit(t *testing.T) &#123;\n    words :&#x3D; strings.Split(&quot;a:b:c&quot;, &quot;:&quot;)\n    assertEqual(len(words), 3)\n    &#x2F;&#x2F; ...\n&#125;\n从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。只有在测试中出现重复模式时才采用抽象。\nfunc TestSplit(t *testing.T) &#123;\n    s, sep :&#x3D; &quot;a:b:c&quot;, &quot;:&quot;\n    words :&#x3D; strings.Split(s, sep)\n    if got, want :&#x3D; len(words), 3; got !&#x3D; want &#123;\n        t.Errorf(&quot;Split(%q, %q) returned %d words, want %d&quot;,\n            s, sep, got, want)\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n\n现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试。一旦我们写了这样结构的测试，下一步自然不是用更多的if语句来扩展测试用例，我们可以用像IsPalindrome的表驱动测试那样来准备更多的s和sep测试用例。\n前面的例子并不需要额外的辅助函数，如果有可以使测试代码更简单的方法我们也乐意接受。（我们将在13.3节看到一个类似reflect.DeepEqual辅助函数。）一个好的测试的关键是首先实现你期望的具体行为，然后才是考虑简化测试代码、避免重复。如果直接从抽象、通用的测试库着手，很难取得良好结果。\n练习11.5: 用表格驱动的技术扩展TestSplit测试，并打印期望的输出结果。\n11.2.6. 避免脆弱的测试如果一个应用程序对于新出现的但有效的输入经常失败说明程序容易出bug（不够稳健）；同样，如果一个测试仅仅对程序做了微小变化就失败则称为脆弱。就像一个不够稳健的程序会挫败它的用户一样，一个脆弱的测试同样会激怒它的维护者。最脆弱的测试代码会在程序没有任何变化的时候产生不同的结果，时好时坏，处理它们会耗费大量的时间但是并不会得到任何好处。\n当一个测试函数会产生一个复杂的输出如一个很长的字符串、一个精心设计的数据结构或一个文件时，人们很容易想预先写下一系列固定的用于对比的标杆数据。但是随着项目的发展，有些输出可能会发生变化，尽管很可能是一个改进的实现导致的。而且不仅仅是输出部分，函数复杂的输入部分可能也跟着变化了，因此测试使用的输入也就不再有效了。\n避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串。很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试。\n11.3. 测试覆盖率就其性质而言，测试不可能是完整的。计算机科学家Edsger Dijkstra曾说过：“测试能证明缺陷存在，而无法证明没有缺陷。”再多的测试也不能证明一个程序没有BUG。在最好的情况下，测试可以增强我们的信心：代码在很多重要场景下是可以正常工作的。\n对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化——即使最简单的程序的动态也是难以精确测量的——但是有启发式方法来帮助我们编写有效的测试代码。\n这些启发式方法中，语句的覆盖率是最简单和最广泛使用的。语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。在本节中，我们使用go test命令中集成的测试覆盖率工具，来度量下面代码的测试覆盖率，帮助我们识别测试和我们期望间的差距。\n下面的代码是一个表格驱动的测试，用于测试第七章的表达式求值程序：\ngopl.io&#x2F;ch7&#x2F;eval\nfunc TestCoverage(t *testing.T) {    var tests &#x3D; []struct {        input string        env   Env        want  string &#x2F;&#x2F; expected error from Parse&#x2F;Check or result from Eval    }{        {“x % 2”, nil, “unexpected ‘%’”},        {“!true”, nil, “unexpected ‘!’”},        {“log(10)”, nil, unknown function &quot;log&quot;},        {“sqrt(1, 2)”, nil, “call to sqrt has 2 args, want 1”},        {“sqrt(A &#x2F; pi)”, Env{“A”: 87616, “pi”: math.Pi}, “167”},        {“pow(x, 3) + pow(y, 3)”, Env{“x”: 9, “y”: 10}, “1729”},        {“5 &#x2F; 9 * (F - 32)”, Env{“F”: -40}, “-40”},    }\nfor _, test := range tests &#123;\n    expr, err := Parse(test.input)\n    if err == nil &#123;\n        err = expr.Check(map[Var]bool&#123;&#125;)\n    &#125;\n    if err != nil &#123;\n        if err.Error() != test.want &#123;\n            t.Errorf(&quot;%s: got %q, want %q&quot;, test.input, err, test.want)\n        &#125;\n        continue\n    &#125;\n    got := fmt.Sprintf(&quot;%.6g&quot;, expr.Eval(test.env))\n    if got != test.want &#123;\n        t.Errorf(&quot;%s: %v =&gt; %s, want %s&quot;,\n            test.input, test.env, got, test.want)\n    &#125;\n&#125;\n\n}首先，我们要确保所有的测试都正常通过：\n$ go test -v -run&#x3D;Coverage gopl.io&#x2F;ch7&#x2F;eval&#x3D;&#x3D;&#x3D; RUN TestCoverage— PASS: TestCoverage (0.00s)PASSok      gopl.io&#x2F;ch7&#x2F;eval         0.011s下面这个命令可以显示测试覆盖率工具的使用用法：\n$ go tool coverUsage of ‘go tool cover’:Given a coverage profile produced by ‘go test’:    go test -coverprofile&#x3D;c.out\nOpen a web browser displaying annotated source code:    go tool cover -html&#x3D;c.out…go tool命令运行Go工具链的底层可执行程序。这些底层可执行程序放在$GOROOT&#x2F;pkg&#x2F;tool&#x2F;${GOOS}_${GOARCH}目录。因为有go build命令的原因，我们很少直接调用这些底层工具。\n现在我们可以用-coverprofile标志参数重新运行测试：\n$ go test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;evalok      gopl.io&#x2F;ch7&#x2F;eval         0.032s      coverage: 68.5% of statements这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说，在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入c.out文件，并打印一部分执行的语句的一个总结。（如果你需要的是摘要，使用go test -cover。）\n如果使用了-covermode&#x3D;count标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。\n为了收集数据，我们运行了测试覆盖率工具，打印了测试日志，生成一个HTML报告，然后在浏览器中打开（图11.3）。\n$ go tool cover -html&#x3D;c.out\n绿色的代码块被测试覆盖到了，红色的则表示没有被覆盖到。为了清晰起见，我们将背景红色文本的背景设置成了阴影效果。我们可以马上发现unary操作的Eval方法并没有被执行到。如果我们针对这部分未被覆盖的代码添加下面的测试用例，然后重新运行上面的命令，那么我们将会看到那个红色部分的代码也变成绿色了：\n{“-x * -x”, eval.Env{“x”: 2}, “4”}不过两个panic语句依然是红色的。这是没有问题的，因为这两个语句并不会被执行到。\n实现100%的测试覆盖率听起来很美，但是在具体实践中通常是不可行的，也不是值得推荐的做法。因为那只能说明代码被执行过而已，并不意味着代码就是没有BUG的；因为对于逻辑复杂的语句需要针对不同的输入执行多次。有一些语句，例如上面的panic语句则永远都不会被执行到。另外，还有一些隐晦的错误在现实中很少遇到也很难编写对应的测试代码。测试从本质上来说是一个比较务实的工作，编写测试代码和编写应用代码的成本对比是需要考虑的。测试覆盖率工具可以帮助我们快速识别测试薄弱的地方，但是设计好的测试用例和编写应用代码一样需要严密的思考。\n11.4. 基准测试基准测试是测量一个程序在固定工作负载下的性能。在Go语言中，基准测试函数和普通测试函数写法类似，但是以Benchmark为前缀名，并且带有一个testing.B类型的参数；testing.B参数除了提供和*testing.T类似的方法，还有额外一些和性能测量相关的方法。它还提供了一个整数N，用于指定操作执行的循环次数。\n下面是IsPalindrome函数的基准测试，其中循环将执行N次。\nimport &quot;testing&quot;\n\nfunc BenchmarkIsPalindrome(b *testing.B) &#123;\n    for i :&#x3D; 0; i &lt; b.N; i++ &#123;\n        IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;)\n    &#125;\n&#125;\n我们用下面的命令运行基准测试。和普通测试不同的是，默认情况下不运行任何基准测试。我们需要通过-bench命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和-bench&#x3D;IsPalindrome参数是等价的效果。\n$ cd $GOPATH&#x2F;src&#x2F;gopl.io&#x2F;ch11&#x2F;word2\n$ go test -bench&#x3D;.\nPASS\nBenchmarkIsPalindrome-8 1000000                1035 ns&#x2F;op\nok      gopl.io&#x2F;ch11&#x2F;word2      2.179s\n结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的GOMAXPROCS的值，这对于一些与并发相关的基准测试是重要的信息。\n报告显示每次调用IsPalindrome函数花费1.035微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。\n循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过testing.B参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。\n现在我们有了一个基准测试和普通测试，我们可以很容易测试改进程序运行速度的想法。也许最明显的优化是在IsPalindrome函数中第二个循环的停止检查，这样可以避免每个比较都做两次：\nn :&#x3D; len(letters)&#x2F;2\nfor i :&#x3D; 0; i &lt; n; i++ &#123;\n    if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;\n        return false\n    &#125;\n&#125;\nreturn true\n不过很多情况下，一个显而易见的优化未必能带来预期的效果。这个改进在基准测试中只带来了4%的性能提升。\n$ go test -bench&#x3D;.\nPASS\nBenchmarkIsPalindrome-8 1000000              992 ns&#x2F;op\nok      gopl.io&#x2F;ch11&#x2F;word2      2.093s\n另一个改进想法是在开始为每个字符预先分配一个足够大的数组，这样就可以避免在append调用时可能会导致内存的多次重新分配。声明一个letters数组变量，并指定合适的大小，像下面这样，\nletters :&#x3D; make([]rune, 0, len(s))\nfor _, r :&#x3D; range s &#123;\n    if unicode.IsLetter(r) &#123;\n        letters &#x3D; append(letters, unicode.ToLower(r))\n    &#125;\n&#125;\n这个改进提升性能约35%，报告结果是基于2,000,000次迭代的平均运行时间统计。\n$ go test -bench&#x3D;.\nPASS\nBenchmarkIsPalindrome-8 2000000                      697 ns&#x2F;op\nok      gopl.io&#x2F;ch11&#x2F;word2      1.468s\n如这个例子所示，快的程序往往是伴随着较少的内存分配。-benchmem命令行标志参数将在报告中包含内存的分配数据统计。我们可以比较优化前后内存的分配情况：\n$ go test -bench&#x3D;. -benchmem\nPASS\nBenchmarkIsPalindrome    1000000   1026 ns&#x2F;op    304 B&#x2F;op  4 allocs&#x2F;op\n这是优化之后的结果：\n$ go test -bench&#x3D;. -benchmem\nPASS\nBenchmarkIsPalindrome    2000000    807 ns&#x2F;op    128 B&#x2F;op  1 allocs&#x2F;op\n用一次内存分配代替多次的内存分配节省了75%的分配调用次数和减少近一半的内存需求。\n这个基准测试告诉了我们某个具体操作所需的绝对时间，但我们往往想知道的是两个不同的操作的时间对比。例如，如果一个函数需要1ms处理1,000个元素，那么处理10000或1百万将需要多少时间呢？这样的比较揭示了渐近增长函数的运行时间。另一个例子：I&#x2F;O缓存该设置为多大呢？基准测试可以帮助我们选择在性能达标情况下所需的最小内存。第三个例子：对于一个确定的工作哪种算法更好？基准测试可以评估两种不同算法对于相同的输入在不同的场景和负载下的优缺点。\n比较型的基准测试就是普通程序代码。它们通常是单参数的函数，由几个不同数量级的基准测试函数调用，就像这样：\nfunc benchmark(b *testing.B, size int) &#123; &#x2F;* ... *&#x2F; &#125;\nfunc Benchmark10(b *testing.B)         &#123; benchmark(b, 10) &#125;\nfunc Benchmark100(b *testing.B)        &#123; benchmark(b, 100) &#125;\nfunc Benchmark1000(b *testing.B)       &#123; benchmark(b, 1000) &#125;\n通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。\n比较型的基准测试反映出的模式在程序设计阶段是很有帮助的，但是即使程序完工了也应当保留基准测试代码。因为随着项目的发展，或者是输入的增加，或者是部署到新的操作系统或不同的处理器，我们可以再次用基准测试来帮助我们改进设计。\n练习 11.6: 为2.6.2节的练习2.4和练习2.5的PopCount函数编写基准测试。看看基于表格算法在不同情况下对提升性能会有多大帮助。\n练习 11.7: 为*IntSet（§6.5）的Add、UnionWith和其他方法编写基准测试，使用大量随机输入。你可以让这些方法跑多快？选择字的大小对于性能的影响如何？IntSet和基于内建map的实现相比有多快？\n11.5. 剖析基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。每个码农都应该知道Donald Knuth在1974年的“Structured Programming with go to Statements”上所说的格言。虽然经常被解读为不重视性能的意思，但是从原文我们可以看到不同的含义：\n毫无疑问，对效率的片面追求会导致各种滥用。程序员会浪费大量的时间在非关键程序的速度上，实际上这些尝试提升效率的行为反倒可能产生很大的负面影响，特别是当调试和维护的时候。我们不应该过度纠结于细节的优化，应该说约97%的场景：过早的优化是万恶之源。\n当然我们也不应该放弃对那关键3%的优化。一个好的程序员不会因为这个比例小就裹足不前，他们会明智地观察和识别哪些是关键的代码；但是仅当关键代码已经被确认的前提下才会进行优化。对于很多程序员来说，判断哪部分是关键的性能瓶颈，是很容易犯经验上的错误的，因此一般应该借助测量工具来证明。\n当我们想仔细观察我们程序的运行速度的时候，最好的方法是性能剖析。剖析技术是基于程序执行期间一些自动抽样，然后在收尾时进行推断；最后产生的统计结果就称为剖析数据。\nGo语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。内建的go test工具对几种分析方式都提供了支持。\nCPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。\n堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。\n阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。\n只需要开启下面其中一个标志参数就可以生成各种分析文件。当同时使用多个标志参数时需要当心，因为一项分析操作可能会影响其他项的分析结果。\n$ go test -cpuprofile&#x3D;cpu.out\n$ go test -blockprofile&#x3D;block.out\n$ go test -memprofile&#x3D;mem.out\n对于一些非测试程序也很容易进行剖析，具体的实现方式，与程序是短时间运行的小工具还是长时间运行的服务会有很大不同。剖析对于长期运行的程序尤其有用，因此可以通过调用Go的runtime API来启用运行时剖析。\n一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。这是Go工具箱自带的一个工具，但并不是一个日常工具，它对应go tool pprof命令。该命令有许多特性和选项，但是最基本的是两个参数：生成这个概要文件的可执行程序和对应的剖析数据。\n为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要对应的可执行程序来解读剖析数据。虽然go test通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对应待测包的名字。\n下面的命令演示了如何收集并展示一个CPU分析文件。我们选择net&#x2F;http包的一个基准测试为例。通常最好是对业务关键代码的部分设计专门的基准测试。因为简单的基准测试几乎没法代表业务场景，因此我们用-run&#x3D;NONE参数禁止那些简单测试。\n$ go test -run&#x3D;NONE -bench&#x3D;ClientServerParallelTLS64 \\\n    -cpuprofile&#x3D;cpu.log net&#x2F;http\n PASS\n BenchmarkClientServerParallelTLS64-8  1000\n    3141325 ns&#x2F;op  143010 B&#x2F;op  1747 allocs&#x2F;op\nok       net&#x2F;http       3.395s\n\n\n$ go tool pprof -text -nodecount&#x3D;10 .&#x2F;http.test cpu.log\n2570ms of 3590ms total (71.59%)\nDropped 129 nodes (cum &lt;&#x3D; 17.95ms)\nShowing top 10 nodes out of 166 (cum &gt;&#x3D; 60ms)\n    flat  flat%   sum%     cum   cum%\n  1730ms 48.19% 48.19%  1750ms 48.75%  crypto&#x2F;elliptic.p256ReduceDegree\n   230ms  6.41% 54.60%   250ms  6.96%  crypto&#x2F;elliptic.p256Diff\n   120ms  3.34% 57.94%   120ms  3.34%  math&#x2F;big.addMulVVW\n   110ms  3.06% 61.00%   110ms  3.06%  syscall.Syscall\n    90ms  2.51% 63.51%  1130ms 31.48%  crypto&#x2F;elliptic.p256Square\n    70ms  1.95% 65.46%   120ms  3.34%  runtime.scanobject\n    60ms  1.67% 67.13%   830ms 23.12%  crypto&#x2F;elliptic.p256Mul\n    60ms  1.67% 68.80%   190ms  5.29%  math&#x2F;big.nat.montgomery\n    50ms  1.39% 70.19%    50ms  1.39%  crypto&#x2F;elliptic.p256ReduceCarry\n    50ms  1.39% 71.59%    60ms  1.67%  crypto&#x2F;elliptic.p256Sum\n\n参数-text用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。其中-nodecount&#x3D;10参数限制了只输出前10行的结果。对于严重的性能问题，这个文本格式基本可以帮助查明原因了。\n这个概要文件告诉我们，HTTPS基准测试中crypto&#x2F;elliptic.p256ReduceDegree函数占用了将近一半的CPU资源，对性能占很大比重。相比之下，如果一个概要文件中主要是runtime包的内存分配的函数，那么减少内存消耗可能是一个值得尝试的优化策略。\n对于一些更微妙的问题，你可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具，可以从 http://www.graphviz.org 下载。参数-web用于生成函数的有向图，标注有CPU的使用和最热点的函数等信息。\n这一节我们只是简单看了下Go语言的数据分析工具。如果想了解更多，可以阅读Go官方博客的“Profiling Go Programs”一文。\n11.6 示例函数第三种被go test特别对待的函数是示例函数，以Example为函数名开头。示例函数没有函数参数和返回值。下面是IsPalindrome函数对应的示例函数：\nfunc ExampleIsPalindrome() {    fmt.Println(IsPalindrome(“A man, a plan, a canal: Panama”))    fmt.Println(IsPalindrome(“palindrome”))    &#x2F;&#x2F; Output:    &#x2F;&#x2F; true    &#x2F;&#x2F; false}示例函数有三个用处。最主要的一个是作为文档：一个包的例子可以更简洁直观的方式来演示函数的用法，比文字描述更直接易懂，特别是作为一个提醒或快速参考时。一个示例函数也可以方便展示属于同一个接口的几种类型或函数之间的关系，所有的文档都必须关联到一个地方，就像一个类型或函数声明都统一到包一样。同时，示例函数和注释并不一样，示例函数是真实的Go代码，需要接受编译器的编译时检查，这样可以保证源代码更新时，示例代码不会脱节。\n根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。\n示例函数的第二个用处是，在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的&#x2F;&#x2F; Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配。\n示例函数的第三个目的提供一个真实的演练场。 http://golang.org 就是由godoc提供的文档服务，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数，就像图11.4所示的那样。这通常是学习函数使用或Go语言特性最快捷的方式。\n\n本书最后的两章是讨论reflect和unsafe包，一般的Go程序员很少使用它们，事实上也很少需要用到。因此，如果你还没有写过任何真实的Go程序的话，现在可以先去写些代码了。\nappendIndex\n\n一个测试函数是以`Test`为函数名前缀的函数\n一个基准测试函数是以`Benchmark`为函数名前缀的函数\n一个示例函数是以`Example`为函数名前缀的函数，提供一个由编译器保证正确性的示例文档\n\n```golang\n- `go test -v `会打印每个函数的名字和运行时间\n- `go test -run= `会去匹配正则表达式，只有被匹配到的才会被执行\n- `go test -v ./...` 执行所有当前目录下测试cases\n- `go test -v foo/...` 执行foo目录下所有cases\n- `go test -v foo...` 执行指定前缀的测试cases\n- `go test ...` gopath下所有测试cases\n- `go test -v hello_test.go` 执行某一文件下的测试cases,但是该文件中如果调用了其它文件中的模块会报错\n- `go test -v hello_test.go -test.run TestHello` 测试单个函数\n\n\n组织多个测试用例\n即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息,可以使用t.Fatal或t.Fatalf停止当前测试函数\n  \n  组织多测试用例\n  \n\n  func TestIsPalindrome(t *testing.T) &#123;\nvar tests &#x3D; []struct &#123;\n    input string\n    want  bool\n&#125;&#123;\n        &#123;&quot;&quot;, true&#125;,\n        &#123;&quot;a&quot;, true&#125;,\n        &#123;&quot;aa&quot;, true&#125;,\n        &#123;&quot;ab&quot;, false&#125;,\n        &#123;&quot;kayak&quot;, true&#125;,\n        &#123;&quot;detartrated&quot;, true&#125;,\n        &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;,\n        &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;,\n        &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;,\n        &#123;&quot;été&quot;, true&#125;,\n        &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;,\n        &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome\n        &#123;&quot;desserts&quot;, false&#125;,   &#x2F;&#x2F; semi-palindrome\n    &#125;\n    for _, test :&#x3D; range tests &#123;\n        if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123;\n            t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got)\n        &#125;\n    &#125;\n&#125;\n\n  \n  \n\n随机测试\n\n编写对照函数，效率低下\n生成的随机输入的数据遵循特定的模式，然后就知道期望的输出\n\n\nimport &quot;math&#x2F;rand&quot;\n\n  &#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents\n  &#x2F;&#x2F; are derived from the pseudo-random number generator rng.\n  func randomPalindrome(rng *rand.Rand) string &#123;\n      n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24\n      runes :&#x3D; make([]rune, n)\n      for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;\n          r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\\u0999&#39;\n          runes[i] &#x3D; r\n          runes[n-1-i] &#x3D; r\n      &#125;\n      return string(runes)\n  &#125;\n\n  func TestRandomPalindromes(t *testing.T) &#123;\n      &#x2F;&#x2F; Initialize a pseudo-random number generator.\n      seed :&#x3D; time.Now().UTC().UnixNano()\n      t.Logf(&quot;Random seed: %d&quot;, seed)\n      rng :&#x3D; rand.New(rand.NewSource(seed))\n\n      for i :&#x3D; 0; i &lt; 1000; i++ &#123;\n          p :&#x3D; randomPalindrome(rng)\n          if !IsPalindrome(p) &#123;\n              t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)\n          &#125;\n      &#125;\n  &#125;\n  &#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.\n  &#x2F;&#x2F; Letter case is ignored, as are non-letters.\n  func IsPalindrome(s string) bool &#123;\n      var letters []rune\n      for _, r :&#x3D; range s &#123;\n          if unicode.IsLetter(r) &#123;\n              letters &#x3D; append(letters, unicode.ToLower(r))\n          &#125;\n      &#125;\n      for i :&#x3D; range letters &#123;\n          if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;\n              return false\n          &#125;\n      &#125;\n      return true\n  &#125;\n\n\n测试一个命令(测试内部未导出函数)\n要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。要注意的是在测试代码中并没有调用log.Fatal或os.Exit，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理,如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理.导出内部函数,\n&#x2F;&#x2F; src&#x2F;bytes&#x2F;export_test.go\n  package bytes\n  &#x2F;&#x2F; Export func for testing\n  var IndexBytePortable &#x3D; indexBytePortable &#x2F;&#x2F; 赋值给包级可导出变量\n\n然后通过外部包进行测试\n\n&#x2F;&#x2F; src&#x2F;bytes&#x2F;bytes_test.go\n  package bytes_test\n\n  func TestIndexByte(t *testing.T) &#123;\n      for _, tt :&#x3D; range indexTests &#123;\n          ... 代码片段\n          posp :&#x3D; IndexBytePortable(a, b) &#x2F;&#x2F; 导出的内部方法在这里被使用\n          if posp !&#x3D; tt.i &#123;\n              t.Errorf(&#96;indexBytePortable(%q, &#39;%c&#39;) &#x3D; %v&#96;, tt.a, b, posp)\n          &#125;\n      &#125;\n  &#125;\n\n\n还有种方式就是不导出，直接在包名下写测试函数，然后进行测试源代码\n\n白盒测试\nTBC,代码的内部实现对于测试人员来说是可见的，言外之意就是能看到内部实现,测试内部实现，这个实现可能是未导出的\n\n外部测试包\npackage pprint_test\n  &#x2F;&#x2F;这时候就可以在\n  import (\n      &quot;gott&#x2F;hi&quot;\n      &#x2F;&#x2F; 导入 要进行测试的 pprint 包本身\n      &quot;gott&#x2F;pprint&quot;\n      &quot;testing&quot;\n  )\n\n  func TestPPrint(t *testing.T) &#123;\n      pprint.PPrint()\n      hi.Say()\n      t.Log(&quot;expect call PPrint&quot;)\n  &#125;\n  \n\n使用 Go 官方的代码风格：pprint_test.go 文件，因为pprint_test在 pprint 目录下，通过在 import 时，使用.选项，可以直接调用PPrint()方法\n\n编写有效的测试\n\n一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息\n一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律\n现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试\n\n\n避免脆弱的测试TBC\n\n\n 11.2 测试覆盖率\n对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化(应该是有)\n\ngo test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;eval\ngo test -run&#x3D;Coverage -covermode&#x3D;count gopl.io&#x2F;ch7&#x2F;eval\n\n 11.3 基准测试\n\n-bench也是正则匹配,BenchmarkIsPalindrome-8,8表示的是GOMAXPROCS的值,-benchmem命令行标志参数将在报告中包含内存的分配数据统计\n比较型的基准测试就是普通程序代码,它们通常是单参数的函数，由几个不同数量级的基准测试函数调用,通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。所有的测试cases都要保留，随着项目的发展，都需要做回归测试\n\n 11.4 刨析\nTBC\n 11.5 示例函数\n示例函数有三个用处。\n\n最主要的一个是作为文档，根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。\n在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的&#x2F;&#x2F; Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配\n提供一个真实的演练场，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数\n\n\n\n# 12. appendIndex\n\n1. 线程内再重启一个线程，然后就可以通过加锁，进行隔离开，但此时任然是两个线程的间的交替\n\n","dateCreated":"2022-10-08T14:02:11+08:00","dateModified":"2022-11-10T23:43:10+08:00","datePublished":"2022-10-08T14:02:11+08:00","description":"摘要: Go语言有时候被描述为”C类似语言”,或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。","headline":"go语言圣经","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://simonteo58.github.io/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"},"publisher":{"@type":"Organization","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://simonteo58.github.io/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"}</script>
    <meta name="description" content="摘要: Go语言有时候被描述为”C类似语言”,或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。">
<meta property="og:type" content="blog">
<meta property="og:title" content="go语言圣经">
<meta property="og:url" content="https://simonteo58.github.io/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/index.html">
<meta property="og:site_name" content="CoffeeMan">
<meta property="og:description" content="摘要: Go语言有时候被描述为”C类似语言”,或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://simonteo58.github.io/picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-01.png">
<meta property="og:image" content="https://simonteo58.github.io/picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-02.png">
<meta property="og:image" content="https://simonteo58.github.io/picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-03.png">
<meta property="og:image" content="https://simonteo58.github.io/picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-04.png">
<meta property="og:image" content="https://simonteo58.github.io/picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-05.png">
<meta property="og:image" content="https://simonteo58.github.io/asset/ch11-04.png">
<meta property="article:published_time" content="2022-10-08T06:02:11.553Z">
<meta property="article:modified_time" content="2022-11-10T15:43:10.946Z">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://simonteo58.github.io/picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-01.png">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-y9io9e1ok9lpsmk4fyk7quzstdgr6eztu8x2xr6n9iikjgfjbcqqpobdlqy8.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CoffeeMan
        </a>
    </div>
    
        
            <a
                class="header-right-picture open-algolia-search"
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/SimonTeo58"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/11289672/simon-teo"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/shiming_kirk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/kirk-zhang-424935235/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/zxc741208584@qq.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            go语言圣经
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-10-08T14:02:11+08:00">
	
		    Oct 08, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>摘要: Go语言有时候被描述为”C类似语言”,或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。</p>
<span id="more"></span>

<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE"><span class="toc-text">go语言项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%85%A5%E9%97%A8"><span class="toc-text">1. 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-hello-world"><span class="toc-text">1.1. hello_world</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0-os-package"><span class="toc-text">1.2 命令行参数(os package)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C"><span class="toc-text">1.3 查找重复的行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-GIF%E5%8A%A8%E7%94%BB"><span class="toc-text">1.4 GIF动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E8%8E%B7%E5%8F%96URL"><span class="toc-text">1.5 获取URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%B9%B6%E5%8F%91%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AAURL"><span class="toc-text">1.6. 并发获取多个URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Web%E6%9C%8D%E5%8A%A1"><span class="toc-text">1.7. Web服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">2. 程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%91%BD%E5%90%8D"><span class="toc-text">2.1 命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A3%B0%E6%98%8E"><span class="toc-text">2.2 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%8F%98%E9%87%8F"><span class="toc-text">2.3 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E7%AE%80%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">2.3.1 简短变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%8C%87%E9%92%88"><span class="toc-text">2.3.2 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-new%E5%87%BD%E6%95%B0"><span class="toc-text">2.3.3 new函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2.3.4. 变量的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%B5%8B%E5%80%BC"><span class="toc-text">2.4 赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC"><span class="toc-text">2.4.1 元组赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.5 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-text">2.6 包和文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2.7. 作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%95%B4%E5%9E%8B"><span class="toc-text">3.1 整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">3.2 浮点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%A4%8D%E6%95%B0"><span class="toc-text">3.3 复数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.4 布尔类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3.5 字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. 复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%95%B0%E7%BB%84"><span class="toc-text">4.1 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-slice"><span class="toc-text">4.2 slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-append%E5%87%BD%E6%95%B0"><span class="toc-text">4.2.1 append函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Map"><span class="toc-text">4.3 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">4.4 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-text">4.4.1 结构体字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">4.4.2 结构体的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98"><span class="toc-text">4.4.3 结构体嵌入和匿名成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-json%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.5 json字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%96%87%E6%9C%AC%E5%92%8CHTML%E6%A8%A1%E6%9D%BF"><span class="toc-text">4.6 文本和HTML模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0"><span class="toc-text">5. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%94%99%E8%AF%AF"><span class="toc-text">5.1 错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%87%BD%E6%95%B0%E5%80%BC"><span class="toc-text">5.2 函数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">5.3 匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">5.4 可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-defer%E5%87%BD%E6%95%B0"><span class="toc-text">5.5 defer函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-panic%E5%BC%82%E5%B8%B8"><span class="toc-text">5.6 panic异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-Recovery%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-text">5.7 Recovery捕获异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95"><span class="toc-text">6. 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E"><span class="toc-text">6.1 方法声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6.2 基于指针对象的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">6.3. 通过嵌入结构体来扩展类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%B0%81%E8%A3%85"><span class="toc-text">6.4 封装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3"><span class="toc-text">7. 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A"><span class="toc-text">7.1. 接口约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.2 接口类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">7.3 实现接口的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-flag-Value%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.4 flag.Value接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="toc-text">7.5 接口值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E8%AD%A6%E5%91%8A-%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AFnil%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.5.1. 警告:一个包含nil指针的接口不是nil接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-sort-Interface%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.6. sort.Interface接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-http-Handler%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.7. http.Handler接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-error%E6%8E%A5%E5%8F%A3"><span class="toc-text">7.8. error接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-%E7%A4%BA%E4%BE%8B-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">7.9 示例-表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-10-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">7.10. 类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.11. 基于类型断言区别错误类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">7.11. 基于类型断言区别错误类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-12-%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E8%AF%A2%E9%97%AE%E8%A1%8C%E4%B8%BA"><span class="toc-text">7.12. 通过类型断言询问行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-13-%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF"><span class="toc-text">7.13. 类型分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-14-%E7%A4%BA%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E6%A0%87%E8%AE%B0%E7%9A%84XML%E8%A7%A3%E7%A0%81"><span class="toc-text">7.14. 示例: 基于标记的XML解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-15-%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="toc-text">7.15. 一些建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-16-any%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">7.16. any关键字与泛型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Goroutines%E5%92%8CChannels"><span class="toc-text">8. Goroutines和Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-goroutine"><span class="toc-text">8.1 goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-channel"><span class="toc-text">8.2 channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">8.3 基于select的多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%80%E5%87%BA"><span class="toc-text">8.4. 并发的退出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="toc-text">9. 基于共享变量的并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-sync-Mutex%E4%B8%8Esync-RMutex%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">9.1 sync.Mutex与sync.RMutex互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-sync-Once%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">9.2 sync.Once惰性初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-sync-Cond%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">9.3 sync.Cond的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-Goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">9.4. Goroutines和线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">10. 包和工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E5%8C%85%E7%AE%80%E4%BB%8B"><span class="toc-text">10.1. 包简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%AF%BC%E5%85%A5%E8%B7%AF%E5%BE%84"><span class="toc-text">10.2. 导入路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%8C%85%E5%A3%B0%E6%98%8E"><span class="toc-text">10.3. 包声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E5%AF%BC%E5%85%A5%E5%A3%B0%E6%98%8E"><span class="toc-text">10.4. 导入声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E5%8C%85%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%85%A5"><span class="toc-text">10.5. 包的匿名导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E5%8C%85%E5%92%8C%E5%91%BD%E5%90%8D"><span class="toc-text">10.6. 包和命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-%E5%B7%A5%E5%85%B7"><span class="toc-text">10.7. 工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-1-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%BB%93%E6%9E%84"><span class="toc-text">10.7.1. 工作区结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-2-%E4%B8%8B%E8%BD%BD%E5%8C%85"><span class="toc-text">10.7.2. 下载包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-3-%E6%9E%84%E5%BB%BA%E5%8C%85"><span class="toc-text">10.7.3. 构建包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-4-%E5%8C%85%E6%96%87%E6%A1%A3"><span class="toc-text">10.7.4. 包文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-5-%E5%86%85%E9%83%A8%E5%8C%85"><span class="toc-text">10.7.5. 内部包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-6-%E6%9F%A5%E8%AF%A2%E5%8C%85"><span class="toc-text">10.7.6. 查询包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%B5%8B%E8%AF%95"><span class="toc-text">11. 测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-go-test"><span class="toc-text">11.1 go test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-text">11.2 测试函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95"><span class="toc-text">11.2.1. 随机测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="toc-text">11.2.2. 测试一个命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">11.2.3. 白盒测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-%E5%A4%96%E9%83%A8%E6%B5%8B%E8%AF%95%E5%8C%85"><span class="toc-text">11.2.4. 外部测试包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-5-%E7%BC%96%E5%86%99%E6%9C%89%E6%95%88%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-text">11.2.5. 编写有效的测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-6-%E9%81%BF%E5%85%8D%E8%84%86%E5%BC%B1%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-text">11.2.6. 避免脆弱的测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-text">11.3. 测试覆盖率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-text">11.4. 基准测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E5%89%96%E6%9E%90"><span class="toc-text">11.5. 剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0"><span class="toc-text">11.6 示例函数</span></a></li></ol></li></ol>

<h1 id="go语言项目"><a href="#go语言项目" class="headerlink" title="go语言项目"></a>go语言项目</h1><p>所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）。</p>
<p>正如Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。</p>
<p>简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。</p>
<p>Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。</p>
<p>Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。</p>
<p>Go语言鼓励当代计算机系统设计的原则，特别是局部的重要性。它的内置数据类型和大多数的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因为很少的内存分配和内存初始化代码被隐藏在库代码中了。Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存写操作，而且指针操作比其他间接操作的语言也更有效率。由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。</p>
<p>Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I&#x2F;O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且，每个Go程序结构都是如此的相似，因此，Go程序也很容易学习。使用Go语言自带工具构建Go语言项目只需要使用文件名和标识符名称，一个偶尔的特殊注释来确定所有的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范。</p>
<h1 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h1><h2 id="1-1-hello-world"><a href="#1-1-hello-world" class="headerlink" title="1.1. hello_world"></a>1.1. hello_world</h2><p>我们以现已成为传统的“hello world”案例来开始吧，这个例子首次出现于 1978 年出版的 C 语言圣经 《The C Programming Language》（译注：本书作者之一 Brian W. Kernighan 也是《The C Programming Language》一书的作者）。C 语言是直接影响 Go 语言设计的语言之一。这个例子体现了 Go 语言一些核心理念。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
package main

import &quot;fmt&quot;

func main() &#123;
    fmt.Println(&quot;Hello, 世界&quot;)
&#125;</code></pre>

<p>Go 是一门编译型语言，Go 语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。Go 语言提供的工具都通过一个单独的命令 go 调用，go 命令有一系列子命令。最简单的一个子命令就是 run。这个命令编译一个或多个以。<code>.go</code> 结尾的源文件，链接库文件，并运行最终生成的可执行文件。（本书使用$表示命令行提示符。）</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">go run helloworld.go</code></pre>

<p>毫无意外，这个命令会输出<br>Hello, 世界<br>Go 语言原生支持 Unicode，它可以处理全世界任何语言的文本。<br>如果不只是一次实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以用 build 子命令：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">go build helloworld.go</code></pre>

<p>这个命令生成一个名为 helloworld 的可执行的二进制文件(译注:Windows系统下生成的可执行文件是 helloworld.exe,增加了.exe后缀名)，之后你可以随时运行它(译注：在 Windows 系统下在命令行直接输入 helloworld.exe 命令运行),不需任何处理(译注：因为静态编译，所以不用担心在系统库更新的时候冲突，幸福感满满)</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">helloworld</code></pre>

<p>Hello, 世界</p>
<p>本书中所有示例代码上都有一行标记，利用这些标记可以从 gopl.io 网站上本书源码仓库里获取代码;<code>gopl.io/ch1/helloworld</code>执行 <code>go get gopl.io/ch1/helloworld</code>命令，就会从网上获取代码，并放到对应目录中（需要先安装 Git 或 Hg 之类的版本管理工具，并将对应的命令添加到 PATH 环境变量中。序言已经提及，需要先设置好 GOPATH 环境变量，下载的代码会放在 <code>$GOPATH/src/gopl.io/ch1/helloworld</code> 目录）。2.6 和 10.7 节有这方面更详细的介绍。</p>
<p>来讨论下程序本身。Go 语言的代码通过包(package)组织，包类似于其它语言里的库(libraries)或者模块(modules)。一个包由位于单个目录下的一个或多个 .go 源代码文件组成，目录定义包的作用。每个源文件都以一条 package 声明语句开始，这个例子里就是 package main，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p>
<p>Go 的标准库提供了 100 多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如 fmt 包，就含有格式化输出、接收输入的函数。Println 是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。</p>
<p>main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main函数也很特殊，它是整个程序执行时的入口（译注：C 系语言差不多都这样）。main 函数所做的事情就是程序做的。当然了，main 函数一般调用其它包里的函数完成很多工作（如：fmt.Println）。</p>
<p>必须告诉编译器源文件需要哪些包，这就是跟随在 package 声明后面的import声明扮演的角色。hello world 例子只用到了一个包，大多数程序需要导入多个包。</p>
<p>必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包（译注：Go 语言编译过程没有警告信息，争议特性之一）。</p>
<p>import 声明必须跟在文件的 package 声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字 func、var、const、type 定义）。这些内容的声明顺序并不重要（译注：最好还是定一下规范）。这个例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。为了节省篇幅，有些时候示例程序会省略 package 和 import 声明，但是，这些声明在源代码里有，并且必须得有才能编译。</p>
<p>一个函数的声明由 func 关键字、函数名、参数列表、返回值列表（这个例子里的 main 函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。</p>
<p>Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响 Go 代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字 break、continue、fallthrough或 return 中的一个、运算符和分隔符 ++、–、)、] 或 } 中的一个）。举个例子，函数的左括号 { 必须和 func 函数声明在同一行上，且位于末尾，不能独占一行，而在表达式 x+y 中，可在 + 后换行，不能在 + 前换行（译注：以+结尾的话不会被插入分号分隔符，但是以 x 结尾的话则会被分号分隔符，从而导致编译错误）。</p>
<p>Go 语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式（译注：这个格式化工具没有任何可以调整代码格式的参数，Go 语言就是这么任性），并且 go 工具中的 fmt 子命令会对指定包，否则默认为当前目录中所有。go 源文件应用 gofmt 命令。本书中的所有代码都被 gofmt 过。你也应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执（译注：也导致了 Go 语言的 TIOBE 排名较低，因为缺少撕逼的话题）。更重要的是，这样可以做多种自动源码转换，如果放任 Go 语言代码格式，这些转换就不大可能了。</p>
<p>很多文本编辑器都可以配置为保存文件时自动执行 gofmt，这样你的源代码总会被恰当地格式化。还有个相关的工具：goimports，可以根据代码需要，自动地添加或删除 import 声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装：</p>
<p><code>$ go get golang.org/x/tools/cmd/goimports</code><br>对于大多数用户来说，下载、编译包、运行测试用例、察看 Go 语言的文档等等常用功能都可以用 go 的工具完成节详细介绍这些知识。</p>
<p>summary:  </p>
<ol>
<li>go拥有完整的工具链，通常是go的子命令，在命令输入go关键字就可以查看子命令</li>
<li>Go 语言原生支持 Unicode，它可以处理全世界任何语言的文本。</li>
<li>编写完程序就可以编译成二进制可执行程序使用<code>go build</code><ol>
<li><code>go help build</code> 查看build文档</li>
<li>go build 选项列表及说明,语法为<code>usage: go build [-o output] [build flags] [packages]</code>  <pre class="language-text" data-language="text"><code class="language-text">-o      指定编译输出的软件名称
-i      安装作为目标的依赖关系的包(用于增量编译提速)
-a      强制重建已经是最新版本的软件包 
-n      (只是输出一些运行过程)
-p n    the number of programs, such as build commands or (指定内核数量编译程序，包括test binary)
-race   (同时检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64)
-msan   (启用与内存消毒器的互操作。仅支持linux / amd64，并且只用Clang / LLVM作为主机C编译器（少用))
-asan
-v      (打印名称)
-work   (打印临时工作目录名称)
-x      打印输出 执行命令名
-asmflags '[pattern=]arg list'   (传递每个go工具asm调用的参数)
-buildmode mode             (编译模式 go help buildmode)
-buildvcs   
-compiler name  (指定编译器)
-gccgoflags '[pattern=]arg list'  gccgo编译/连接器参数
-gcflags '[pattern=]arg list'   垃圾回收参数
-installsuffix suffix           (压缩编译后体积)
-ldflags '[pattern=]arg list'
-linkshared             (链接到以前共享库)
-mod mode
-modcacherw
-modfile file
-overlay file
-pkgdir dir     (从指定位置，而不是通常的位置安装和加载所有软件包。例如，当使用非标准配置构建时，使用-pkgdir将生成的包保留在单独的位置。)
-tags tag,list  (构建出带tag的版本.)
-trimpath
-toolexec 'cmd args'</code></pre></li>
</ol>
</li>
<li>go拥有丰富的库函数</li>
<li><code>func</code> 接收器、函数名、参数列表、返回值列表</li>
<li>函数的左括号 { 必须和 func 函数声明在同一行上，且位于末尾，不能独占一行(第一节对格式有说明)</li>
<li>gofmt工具把代码格式化为标准格式,只能服从</li>
</ol>
<h2 id="1-2-命令行参数-os-package"><a href="#1-2-命令行参数-os-package" class="headerlink" title="1.2 命令行参数(os package)"></a>1.2 命令行参数(os package)</h2><p>大多数的程序都是处理输入，产生输出；这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？一些程序生成自己的数据，但通常情况下，输入来自于程序外部：文件、网络连接、其它程序的输出、敲键盘的用户、命令行参数或其它类似输入源。下面几个例子会讨论其中几个输入源，首先是命令行参数。</p>
<p>os 包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的 Args变量获取；os 包外部使用 os.Args 访问该变量。</p>
<p>os.Args 变量是一个字符串（string）的 切片（slice）（译注：slice 和 Python 语言中的切片类似，是一个简版的动态数组），切片是 Go 语言的基础概念，稍后详细介绍。现在先把切片 s 当作数组元素序列，序列的长度动态变化，用 s[i] 访问单个元素，用 s[m:n] 获取子序列（译注：和 Python 里的语法差不多）。序列的元素数目为 len(s)。和大多数编程语言类似，区间索引时，Go 语言里也采用左闭右开形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。（译注：比如 a&#x3D;[1,2,3,4,5], a[0:3]&#x3D;[1,2,3]，不包含最后一个元素）。比如 s[m:n] 这个切片，0≤m≤n≤len(s)，包含 n-m 个元素。<br>os.Args 的第一个元素：os.Args[0]，是命令本身的名字；其它的元素则是程序启动时传给它的参数。s[m:n] 形式的切片表达式，产生从第 m 个元素到第 n-1 个元素的切片，下个例子用到的元素包含在 os.Args[1:len(os.Args)] 切片中。如果省略切片表达式的 m 或 n，会默认传入 0 或 len(s)，因此前面的切片可以简写成 os.Args[1:]。</p>
<p>下面是 Unix 里 echo 命令的一份实现，echo 把它的命令行参数打印成一行。程序导入了两个包，用括号把它们括起来写成列表形式，而没有分开写成独立的 import 声明。两种形式都合法，列表形式习惯上用得多。包导入顺序并不重要；gofmt 工具格式化时按照字母顺序对包名排序。（示例有多个版本时，我们会对示例编号，这样可以明确当前正在讨论的是哪个。）</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch1&#x2F;echo1
&#x2F;&#x2F; Echo1 prints its command-line arguments.
package main
import (
    &quot;fmt&quot;
    &quot;os&quot;
)
func main() &#123;
    var s, sep string
    for i :&#x3D; 1; i &lt; len(os.Args); i++ &#123;
        s +&#x3D; sep + os.Args[i]
        sep &#x3D; &quot; &quot;
    &#125;
    fmt.Println(s)
&#125;</code></pre>
<p>注释语句以 &#x2F;&#x2F; 开头。对于程序员来说，&#x2F;&#x2F; 之后到行末之间所有的内容都是注释，被编译器忽略。按照惯例，我们在每个包的包声明前添加注释；对于 main package，注释包含一句或几句话，从整体角度对程序做个描述。<br>var 声明定义了两个 string 类型的变量 s 和 sep。变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的 零值（zero value），数值类型是 0，字符串类型是空字符串 “”。这个例子里，声明把 s 和 sep 隐式地初始化成空字符串。第 2 章再来详细地讲解变量和声明。<br>对数值类型，Go 语言提供了常规的数值和逻辑运算符。而对 string 类型，+ 运算符连接字符串（译注：和 C++ 或者 JavaScript 是一样的）。所以表达式：sep + os.Args[i] 表示连接字符串 sep 和 os.Args。程序中使用的语句：s+&#x3D;sep+os.Args[i] 是一条 赋值语句，将 s 的旧值跟 sep 与 os.Args[i] 连接后赋值回 s，等价于：s&#x3D;s+sep+os.Args[i]。<br>运算符 +&#x3D; 是赋值运算符（assignment operator），每种数值运算符或逻辑运算符，如 + 或 *，都有对应的赋值运算符。<br>echo 程序可以每循环一次输出一个参数，这个版本却是不断地把新文本追加到末尾来构造字符串。字符串 s 开始为空，即值为 “”，每次循环会添加一些文本；第一次迭代之后，还会再插入一个空格，因此循环结束时每个参数中间都有一个空格。这是一种二次加工（quadratic process），当参数数量庞大时，开销很大，但是对于 echo，这种情形不大可能出现。本章会介绍 echo 的若干改进版，下一章解决低效问题。<br>循环索引变量 i 在 for 循环的第一部分中定义。符号 :&#x3D; 是 短变量声明（short variable declaration）的一部分，这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句。下一章有这方面更多说明。<br>自增语句 i++ 给 i 加 1；这和 i+&#x3D;1 以及 i&#x3D;i+1 都是等价的。对应的还有 i– 给 i 减 1。它们是语句，而不像 C 系的其它语言那样是表达式。所以 j&#x3D;i++ 非法，而且 ++ 和 – 都只能放在变量名后面，因此 –i 也非法。<br>Go 语言只有 for 循环这一种循环语句。for 循环有多种形式，其中一种如下所示：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">for initialization; condition; post &#123;
    &#x2F;&#x2F; zero or more statements
&#125;</code></pre>
<p>for 循环三个部分不需括号包围。大括号强制要求，左大括号必须和 post 语句在同一行。</p>
<p>initialization 语句是可选的，在循环开始前执行。initalization 如果存在，必须是一条 简单语句（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。condition 是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为 true 则执行循环体语句。post 语句在循环体执行结束后执行，之后再次对 condition 求值。condition 值为 false 时，循环结束。</p>
<p>for 循环的这三个部分每个都可以省略，如果省略 initialization 和 post，分号也可以省略：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; a traditional &quot;while&quot; loop
for condition &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>如果连 condition 也省略了，像下面这样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
&#x2F;&#x2F; a traditional infinite loop
for &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>这就变成一个无限循环，尽管如此，还可以用其他方式终止循环，如一条 break 或 return 语句。<br>for 循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片。echo 的第二版本展示了这种形式：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch1&#x2F;echo2
&#x2F;&#x2F; Echo2 prints its command-line arguments.
package main
import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() &#123;
    s, sep :&#x3D; &quot;&quot;, &quot;&quot;
    for _, arg :&#x3D; range os.Args[1:] &#123;
        s +&#x3D; sep + arg
        sep &#x3D; &quot; &quot;
    &#125;
    fmt.Println(s)
&#125;</code></pre>
<p>每次循环迭代，range 产生一对值；索引以及在该索引处的元素值。这个例子不需要索引，但 range 的语法要求，要处理元素，必须处理索引。一种思路是把索引赋值给一个临时变量（如 temp）然后忽略它的值，但 Go 语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。</p>
<p>Go 语言中这种情况的解决方法是用 空标识符（blank identifier），即 _（也就是下划线）。空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。大多数的 Go 程序员都会像上面这样使用 range 和 _ 写 echo 程序，因为隐式地而非显式地索引 os.Args，容易写对。</p>
<p>echo 的这个版本使用一条短变量声明来声明并初始化 s 和 seps，也可以将这两个变量分开声明，声明一个变量有好几种方式，下面这些都等价：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">s :&#x3D; &quot;&quot;
var s string
var s &#x3D; &quot;&quot;
var s string &#x3D; &quot;&quot;</code></pre>
<p>用哪种不用哪种，为什么呢？第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为 “”。第三种形式用得很少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。</p>
<p>如前文所述，每次循环迭代字符串 s 的内容都会更新。+&#x3D; 连接原字符串、空格和下个参数，产生新字符串，并把它赋值给 s。s 原来的内容已经不再使用，将在适当时机对它进行垃圾回收。<br>如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用 strings 包的 Join 函数：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch1&#x2F;echo3
func main() &#123;
    fmt.Println(strings.Join(os.Args[1:], &quot; &quot;))
&#125;</code></pre>
<p>最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用 Println 为我们格式化输出。<br><code>fmt.Println(os.Args[1:])</code><br>这条语句的输出结果跟 strings.Join 得到的结果很像，只是被放到了一对方括号里。切片都会被打印成这种格式。</p>
<p>练习 1.1： 修改 echo 程序，使其能够打印 os.Args[0]，即被执行命令本身的名字。<br>练习 1.2： 修改 echo 程序，使其打印每个参数的索引和值，每个一行。<br>练习 1.3： 做实验测量潜在低效的版本和使用了 strings.Join 的版本的运行时间差异。（1.6 节讲解了部分 time 包，11.4 节展示了如何写标准测试程序，以得到系统性的性能评测。）<br>summary:  </p>
<ol>
<li><code>os</code>包提供跨平台的方式。具体怎么用要<a target="_blank" rel="noopener" href="https://pkg.go.dev/os">参考文档</a>,文档主要提供了<code>type DirEntry</code>,<code>type File</code>,<code>type FileInfo</code></li>
<li>golang定义参数的方式<code>var a,b,c int=0,0,0</code>,还有海马运算符<br>   <code>s := &quot;&quot;</code><br>   <code>var s , v string</code><br>   <code>var s = &quot;&quot;</code><br>   <code>var s string = &quot;&quot;</code><br>   golang字符串类型也可以使用简单的A+B方式进行拼接<br>   string.Join()方法第一位参数是slice，然后seperator</li>
<li>for statement commonly<ol>
<li><code>for k,v := range os.Args[1:]&#123;&#125;</code></li>
<li><code>for condition &#123;&#125;</code></li>
<li><code>for &#123;&#125;</code></li>
<li><code>for i:=0;i&lt;m;i++&#123;&#125;</code></li>
</ol>
</li>
<li>切片的使用 <pre class="language-text" data-language="text"><code class="language-text">切片的基本使用，slice[m:n]可以截取切片区间，包头不包尾巴,其中包含n-m个元素
slice[1:]是从位置1直到末尾</code></pre></li>
<li>所以j&#x3D;i++非法，而且 ++ 和 – 都只能放在变量名后面，因此 –i 也非法。</li>
</ol>
<h2 id="1-3-查找重复的行"><a href="#1-3-查找重复的行" class="headerlink" title="1.3 查找重复的行"></a>1.3 查找重复的行</h2><pre class="language-golang" data-language="golang"><code class="language-golang">%d          十进制整数
%x, %o, %b  十六进制，八进制，二进制整数。
%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
%t          布尔：true或false
%c          字符(rune)(Unicode码点)
%s          字符串
%q          带双引号的字符串&quot;abc&quot;或带单引号的字符&#39;c&#39;
%v          变量的自然形式（natural format）
%T          变量的类型
%%          字面上的百分号标志（无操作数）</code></pre>

<ol>
<li><code>a := make(map[string]int)</code><ol>
<li><code>var fileMap map[string][]string 定义map</code></li>
<li><code>fileMap:= map[string][]string&#123;&quot;kirk&quot;:[1,2,3],&quot;zhang&quot;:[4,5,6]&#125;</code>定义map并初始化</li>
<li><code>fileMap:= make(map[string][]string ,5)</code> make创建map并初始化存储能力</li>
<li>增-<code>fileMap[&quot;kirk&quot;]=[1,2,3]</code></li>
<li>删-<code>delete(fileMap,&quot;kirk&quot;)</code></li>
<li>改-<code>fileMap[&quot;kirk&quot;]=[4,5,6]</code>,简介修改<code>fileMap := newFileMap</code>这时候地址就改了</li>
<li>查-<code>value, ok := myMap[&quot;1234&quot;]; !ok&#123;//处理找到的value&#125;else&#123;&#125;</code></li>
</ol>
</li>
<li>golang的传递都是值传递</li>
</ol>
<h2 id="1-4-GIF动画"><a href="#1-4-GIF动画" class="headerlink" title="1.4 GIF动画"></a>1.4 GIF动画</h2><p>没啥意思，都是介绍功能</p>
<h2 id="1-5-获取URL"><a href="#1-5-获取URL" class="headerlink" title="1.5 获取URL"></a>1.5 获取URL</h2><p>这一节主要还是<code>io</code>的例子</p>
<h2 id="1-6-并发获取多个URL"><a href="#1-6-并发获取多个URL" class="headerlink" title="1.6. 并发获取多个URL"></a>1.6. 并发获取多个URL</h2><p>开始介绍<code>go</code>关键字进行并发还有channel</p>
<h2 id="1-7-Web服务"><a href="#1-7-Web服务" class="headerlink" title="1.7. Web服务"></a>1.7. Web服务</h2><p>主要还是介绍<code>net</code>包</p>
<h1 id="2-程序结构"><a href="#2-程序结构" class="headerlink" title="2. 程序结构"></a>2. 程序结构</h1><h2 id="2-1-命名"><a href="#2-1-命名" class="headerlink" title="2.1 命名"></a>2.1 命名</h2><table>
<thead>
<tr>
<th>功能性关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>退出循环</td>
</tr>
<tr>
<td>case</td>
<td>switch case, select case</td>
</tr>
<tr>
<td>chan</td>
<td>var ch chan int, ch :&#x3D; make(chan int),ch :&#x3D; make(chan int,1)</td>
</tr>
<tr>
<td>const</td>
<td>const (a int    &#x3D; 1  b int    &#x3D; 2 c string &#x3D; “3”)</td>
</tr>
<tr>
<td>continue</td>
<td>退出循环</td>
</tr>
<tr>
<td>default</td>
<td>常见于select {}一起使用</td>
</tr>
<tr>
<td>defer</td>
<td>函数退出前执行</td>
</tr>
<tr>
<td>else</td>
<td>if else</td>
</tr>
<tr>
<td>fallthrough</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>for</td>
<td>for {}, for i:&#x3D;0;i &lt; length ;i++{}, for k,v :&#x3D; range Slice{}</td>
</tr>
<tr>
<td>func</td>
<td>func (){}</td>
</tr>
<tr>
<td>go</td>
<td>携程</td>
</tr>
<tr>
<td>if</td>
<td></td>
</tr>
<tr>
<td>import</td>
<td></td>
</tr>
<tr>
<td>interface</td>
<td>interface{} 是噩梦</td>
</tr>
<tr>
<td>map</td>
<td>a :&#x3D; make(map[int]string) ,var a map[int]string</td>
</tr>
<tr>
<td>package</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>for <em>,</em> :&#x3D; range _ {}</td>
</tr>
<tr>
<td>return</td>
<td>you know</td>
</tr>
<tr>
<td>select</td>
<td>select {case a: }</td>
</tr>
<tr>
<td>struct</td>
<td>相当于java的类,跟c的struct很像</td>
</tr>
<tr>
<td>switch</td>
<td>switch conditional {}</td>
</tr>
<tr>
<td>type</td>
<td>type A struct {}</td>
</tr>
<tr>
<td>var</td>
<td>var a , b, int &#x3D; 0,1 . var ( linkFile int &#x3D;1  dFile int &#x3D;2 )</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内建常量</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>shit</td>
</tr>
<tr>
<td>false</td>
<td>shit</td>
</tr>
<tr>
<td>iota</td>
<td>1,2,3,4….</td>
</tr>
<tr>
<td>nil</td>
<td>shit</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>golang的基本数据类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td></td>
</tr>
<tr>
<td>int8</td>
<td></td>
</tr>
<tr>
<td>int16</td>
<td></td>
</tr>
<tr>
<td>int32</td>
<td></td>
</tr>
<tr>
<td>int64</td>
<td></td>
</tr>
<tr>
<td>uint</td>
<td></td>
</tr>
<tr>
<td>uint8</td>
<td></td>
</tr>
<tr>
<td>uint16</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td></td>
</tr>
<tr>
<td>uint64</td>
<td></td>
</tr>
<tr>
<td>uintptr</td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td></td>
</tr>
<tr>
<td>float64</td>
<td></td>
</tr>
<tr>
<td>complex128</td>
<td></td>
</tr>
<tr>
<td>complex64</td>
<td></td>
</tr>
<tr>
<td>bool</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>rune</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td></td>
</tr>
<tr>
<td>error</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>常用内建函数</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>make</td>
<td></td>
</tr>
<tr>
<td>len</td>
<td></td>
</tr>
<tr>
<td>cap</td>
<td></td>
</tr>
<tr>
<td>new</td>
<td></td>
</tr>
<tr>
<td>append</td>
<td></td>
</tr>
<tr>
<td>copy</td>
<td></td>
</tr>
<tr>
<td>close</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td></td>
</tr>
<tr>
<td>complex</td>
<td></td>
</tr>
<tr>
<td>real</td>
<td></td>
</tr>
<tr>
<td>imag</td>
<td></td>
</tr>
<tr>
<td>panic</td>
<td></td>
</tr>
<tr>
<td>recover</td>
<td></td>
</tr>
</tbody></table>
<p>Go推荐使用<code>驼峰式</code>命名:</p>
<ul>
<li>一个名字必须以一个字母（Unicode字母）或下划线开头,下划线开头可能表示<code>私有的</code></li>
<li>后面可以跟任意数量的字母、数字或下划线。</li>
<li>名字的开头字母的大小写决定了名字在包外的可见性.如果一个名字是大写字母开头的(译注必须是 在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将是导出的,也就是说可以被外部的包访问,例如<code>fmt.Printf</code>,就可以在包外访问</li>
</ul>
<h2 id="2-2-声明"><a href="#2-2-声明" class="headerlink" title="2.2 声明"></a>2.2 声明</h2><p>Go语言主要有四种类型的声明语句:</p>
<ul>
<li>var</li>
<li>const</li>
<li>type</li>
<li>func</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

const boilingF &#x3D; 212.0
const var a &#x3D; 0

func main() &#123;
    var f &#x3D; boilingF
    var c &#x3D; (f - 32) * 5 &#x2F; 9
    fmt.Printf(&quot;boiling point &#x3D; %g°F or %g°C\n&quot;, f, c)
    &#x2F;&#x2F; Output:
    &#x2F;&#x2F; boiling point &#x3D; 212°F or 100°C
&#125;</code></pre>

<p><code>boilingF</code>是包一级的变量在包内可以访问。如果函数没有返回值，那么返回值列表是省略的。函数顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者</p>
<h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><p>常规声明变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var 变量名字 类型 &#x3D; 表达式</code></pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">var i ,j , k int &#x2F;&#x2F; 都是int类型
var b,f,s &#x3D;true , 2.3 ,&quot;four&quot; &#x2F;&#x2F;bool , float 64,string
var f, err &#x3D; os.Open(name) &#x2F;&#x2F; os.Open returns a file and an error</code></pre>

<ul>
<li>在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。</li>
<li><code>类型</code>和<code>表达式</code>都可以缺省,如果是<code>类型</code>缺省那么就可以通过<code>表达式</code>进行推断,如果是表达式缺省那么就会赋类型的<code>零</code>值,如果是自定义类型或者是引用类型就是内部各个字段都是<code>零</code>值.Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态</li>
</ul>
<h3 id="2-3-1-简短变量声明"><a href="#2-3-1-简短变量声明" class="headerlink" title="2.3.1 简短变量声明"></a>2.3.1 简短变量声明</h3>  <pre class="language-golang" data-language="golang"><code class="language-golang">anim :&#x3D; gif.GIF&#123;LoopCount: nframes&#125; &#x2F;&#x2F;聚合类型,引用类型
freq :&#x3D; rand.Float64() * 3.0 &#x2F;&#x2F; float
t :&#x3D; 0.0  &#x2F;&#x2F;float
f, err :&#x3D; os.Open(name) &#x2F;&#x2F;通过函数进行声明，并初始化
if err !&#x3D; nil &#123;
    return err
&#125;</code></pre>

<ul>
<li><p>例子1中声明的err是重复,第二个简短声明符的err就是赋值操作，注意该操作是在变量相同作用例子2中这种情况编译不通过,至少有一个是新声明的.[ 实际工程中尽量不要出现例子2 ]</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;例子1
in, err :&#x3D; os.Open(infile)
&#x2F;&#x2F; ...
out, err :&#x3D; os.Create(outfile)
&#x2F;&#x2F;例子2
f, err :&#x3D; os.Open(infile)
&#x2F;&#x2F; ...
f, err :&#x3D; os.Create(outfile) &#x2F;&#x2F; compile error: no new variables</code></pre></li>
</ul>
<h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><ul>
<li><p><code>任何类型</code>的指针的<code>零值</code>都是<code>nil</code>。如果p指向某个有效变量，那么<code>p != nil</code>测试为<code>真</code>。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>
</li>
<li><p>返回局部变量地址也是安全的。</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">func incr(p *int) int &#123;
    *p++ &#x2F;&#x2F; 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
    return *p
&#125;
v :&#x3D; 1
incr(&amp;v)              &#x2F;&#x2F; side effect: v is now 2
fmt.Println(incr(&amp;v)) &#x2F;&#x2F; &quot;3&quot; (and v is 3)</code></pre>
</li>
<li><p>在flag包中,应用到了<code>指针</code>技术</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">package main
import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;strings&quot;
)
var n &#x3D; flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)
var sep &#x3D; flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)

func main() &#123;
    flag.Parse() &#x2F;&#x2F;解析标志性参数位
    fmt.Print(strings.Join(flag.Args(), *sep)) &#x2F;&#x2F;flag.Args() 解析非标志参数位
    if !*n &#123;
        fmt.Println()
    &#125;
&#125;</code></pre>
<ul>
<li>在此代码例子中使用<code>flag.Args()</code>解析非标志参数位,<code>flag.Parse()</code>解析标志性参数位,to be continue</li>
</ul>
</li>
</ul>
<h3 id="2-3-3-new函数"><a href="#2-3-3-new函数" class="headerlink" title="2.3.3 new函数"></a>2.3.3 new函数</h3><p>  表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T(返回的是指针)</p>
<ul>
<li>每次new()返回新的变量地址,比如new(int)</li>
</ul>
<h3 id="2-3-4-变量的生命周期"><a href="#2-3-4-变量的生命周期" class="headerlink" title="2.3.4. 变量的生命周期"></a>2.3.4. 变量的生命周期</h3><ul>
<li><p>包一级的声明会伴随程序整个声明周期,但是函数内部则是动态,会被GC回收</p>
</li>
<li><p>函数的<code>参数变量</code>(参数列表)和<code>返回值变量</code>都是<code>局部变量</code>。它们在函数每次被调用的时候创建,下面循环的<code>变量t</code>就是动态创建,用完就扔</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;
  x :&#x3D; math.Sin(t)
  y :&#x3D; math.Sin(t*freq + phase)
  img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
      blackIndex)
&#125;</code></pre>

<p>下面也是合法的</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">for t :&#x3D; 0.0; t &lt; cycles*2*math.Pi; t +&#x3D; res &#123;
  x :&#x3D; math.Sin(t)
  y :&#x3D; math.Sin(t*freq + phase)
  img.SetColorIndex(
      size+int(x*size+0.5), size+int(y*size+0.5),
      blackIndex, &#x2F;&#x2F; 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
  )               &#x2F;&#x2F; 小括弧另起一行缩进，和大括弧的风格保存一致
&#125;</code></pre>
</li>
<li><p><code>局部变量逃逸</code>.因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。<code>编译器</code>会自动选择在<code>栈</code>上还是在<code>堆</code>上分配局部变量的存储空间,代码如下,<code>f</code>函数里的<code>x变量</code>必须在<code>堆</code>上分配,因为它在函数退出后依然可以通过包一级的<code>global变量</code>找到,<code>g</code>函数在栈上分配<code>*y</code>内存空间</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var global *int

func f() &#123;
    var x int
    x &#x3D; 1
    global &#x3D; &amp;x
&#125;

func g() &#123;
    y :&#x3D; new(int)
    *y &#x3D; 1
&#125;
</code></pre>
</li>
<li><p>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期,比如,如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。</p>
</li>
</ul>
<h2 id="2-4-赋值"><a href="#2-4-赋值" class="headerlink" title="2.4 赋值"></a>2.4 赋值</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">x &#x3D; 1                       &#x2F;&#x2F; 命名变量的赋值
*p &#x3D; true                   &#x2F;&#x2F; 通过指针间接赋值
person.name &#x3D; &quot;bob&quot;         &#x2F;&#x2F; 结构体字段赋值
count[x] &#x3D; count[x] * scale &#x2F;&#x2F; 数组、slice或map的元素赋值
</code></pre>

<h3 id="2-4-1-元组赋值"><a href="#2-4-1-元组赋值" class="headerlink" title="2.4.1 元组赋值"></a>2.4.1 元组赋值</h3>  <pre class="language-golang" data-language="golang"><code class="language-golang">x,y &#x3D; y,x; &#x2F;&#x2F;不限制数量
a[i], a[j] &#x3D; a[j], a[i];
&#x2F;&#x2F;额外的布尔类型表达某种错误类型
v, ok &#x3D; m[key]             &#x2F;&#x2F; map lookup
v, ok &#x3D; x.(T)              &#x2F;&#x2F; type assertion
v, ok &#x3D; &lt;-ch               &#x2F;&#x2F; channel receive
&#x2F;&#x2F;只做检查
v &#x3D; m[key]                &#x2F;&#x2F; map查找，失败时返回零值
v &#x3D; x.(T)                 &#x2F;&#x2F; type断言，失败时panic异常
v &#x3D; &lt;-ch                  &#x2F;&#x2F; 管道接收，失败时返回零值（阻塞不算是失败）

_, ok &#x3D; m[key]            &#x2F;&#x2F; map返回2个值
_, ok &#x3D; mm[&quot;&quot;], false     &#x2F;&#x2F; map返回1个值
_ &#x3D; mm[&quot;&quot;]                &#x2F;&#x2F; map返回1个值
&#x2F;&#x2F;复合类型隐式赋值
medals :&#x3D; []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125;
&#x2F;&#x2F;等价写法
medals[0] &#x3D; &quot;gold&quot;
medals[1] &#x3D; &quot;silver&quot;
medals[2] &#x3D; &quot;bronze&quot;</code></pre>

<ul>
<li>对于两个值是否可以用&#x3D;&#x3D;或!&#x3D;进行相等比较的能力也和可赋值能力有关系</li>
</ul>
<h2 id="2-5-类型"><a href="#2-5-类型" class="headerlink" title="2.5 类型"></a>2.5 类型</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">package tempconv

import &quot;fmt&quot;

type Celsius float64    &#x2F;&#x2F; 摄氏温度
type Fahrenheit float64 &#x2F;&#x2F; 华氏温度

const (
    AbsoluteZeroC Celsius &#x3D; -273.15 &#x2F;&#x2F; 绝对零度
    FreezingC     Celsius &#x3D; 0       &#x2F;&#x2F; 结冰点温度
    BoilingC      Celsius &#x3D; 100     &#x2F;&#x2F; 沸水温度
)

func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9&#x2F;5 + 32) &#125;

func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 &#x2F; 9) &#125;
</code></pre>

<ul>
<li>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用</li>
<li><code>Celsius</code>和<code>Fahrenheit</code>是两种不同类型,<code>Celsius(t)</code>或<code>Fahrenheit(t)</code>形式的显式转型,<code>整数</code>-&gt;<code>小数</code>回省略小数部分(CPP在这部分有很详细的讨论)</li>
<li>如果两个值有着不同的类型，则不能直接进行比较</li>
<li>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集后面详细讨论</li>
</ul>
<h2 id="2-6-包和文件"><a href="#2-6-包和文件" class="headerlink" title="2.6 包和文件"></a>2.6 包和文件</h2><ul>
<li><p><code>名字空间</code>每个包都对应一个独立的名字空间,例如，在image包中的Decode函数和在unicode&#x2F;utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问</p>
</li>
<li><p><code>包的导入</code>Go语言的规范并没有定义这些源代码的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。</p>
</li>
<li><p><code>包的初始化</code>。包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的。例如<code>func init() &#123; /* ... */ &#125;</code>,<code>init</code>不能被调用，也不能被声明。包会按照声明的顺序初始化。</p>
</li>
<li><p><code>包的初始化顺序</code>。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了</p>
<p>  复杂初始化可以用以下方式</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;可以使用匿名函数处理
var pc [256]byte &#x3D; func() (pc [256]byte) &#123;
  for i :&#x3D; range pc &#123;
      pc[i] &#x3D; pc[i&#x2F;2] + byte(i&amp;1)
  &#125;
  return
&#125;()
</code></pre></li>
</ul>
<h2 id="2-7-作用域"><a href="#2-7-作用域" class="headerlink" title="2.7. 作用域"></a>2.7. 作用域</h2><ul>
<li>不要将作用域和生命周期混为一谈，作用域是指文本域，而生命周期是指运行有效时段</li>
<li>任何在<code>函数</code>外部（也就是包级语法域）声明的名字可以在同一个<code>包</code>的任何源文件中访问的</li>
<li>对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包</li>
<li>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是<br>  函数级的作用域</li>
</ul>
<p>几种常见作用域例子</p>
<ul>
<li><p>正常情况下作用域例子</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">func f() &#123;&#125;

var g &#x3D; &quot;g&quot;

func main() &#123;
    f :&#x3D; &quot;f&quot;
    fmt.Println(f) &#x2F;&#x2F; &quot;f&quot;; local var f shadows package-level func f
    fmt.Println(g) &#x2F;&#x2F; &quot;g&quot;; package-level var
    fmt.Println(h) &#x2F;&#x2F; compile error: undefined: h
&#125;</code></pre>
</li>
<li><p>作用域嵌套,函数中可以进行词法域嵌套</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
  x :&#x3D; &quot;hello!&quot;
  for i :&#x3D; 0; i &lt; len(x); i++ &#123;
      x :&#x3D; x[i]
      if x !&#x3D; &#39;!&#39; &#123;
          x :&#x3D; x + &#39;A&#39; - &#39;a&#39;
          fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;上述代码&#96;x[]&#96;和&#96;x + &#39;A&#39; - &#39;a&#39;&#96;都是引用了外部作用域声明的x变量。
&#x2F;&#x2F;再比如下面的例子,有三个不同的x变量，</code></pre>

  <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化
&#x2F;&#x2F;词法域，一个在for循环体词法域；只有两个块是显式创建的：
func main() &#123;
  x :&#x3D; &quot;hello&quot;
  for _, x :&#x3D; range x &#123;
      x :&#x3D; x + &#39;A&#39; - &#39;a&#39;
      fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)
  &#125;
&#125;</code></pre>
</li>
<li><p>建隐式词法域,隐式作用域<br>if和switch语句也会在条件部分创建隐式词法域，代码例子如下.第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">if x :&#x3D; f(); x &#x3D;&#x3D; 0 &#123;
  fmt.Println(x)
&#125; else if y :&#x3D; g(x); x &#x3D;&#x3D; y &#123;
    fmt.Println(x, y)
&#125; else &#123;
    fmt.Println(x, y)
&#125;
fmt.Println(x, y) &#x2F;&#x2F; compile error: x and y are not visible here</code></pre>

<p>  如果不想提前声明变量还可以选择如下方式，但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">if f, err :&#x3D; os.Open(fname); err !&#x3D; nil &#123;
  return err
&#125; else &#123;
    &#x2F;&#x2F; f and err are visible here too
    f.ReadByte()
    f.Close()
&#125;</code></pre>
</li>
<li><p>屏蔽其他作用域变暗亮<br>  cwd在外部已经声明的包级变量，但是:&#x3D;语句还是将cwd和err重新声明为新的局部变量</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var cwd string

func init() &#123;
    cwd, err :&#x3D; os.Getwd() &#x2F;&#x2F; compile error: unused: cwd
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
&#125;</code></pre>

<p>  可以用赋值运算符，就不会屏蔽<code>cwd</code>变量</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var cwd string

func init() &#123;
    var err error &#x2F;&#x2F;因为是赋值运算符所以需要定义error变量
    cwd, err &#x3D; os.Getwd()
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
&#125;</code></pre></li>
</ul>
<h1 id="3-基础数据类型"><a href="#3-基础数据类型" class="headerlink" title="3.基础数据类型"></a>3.基础数据类型</h1><ul>
<li><p>整型格式控制符</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>整型以二进制方式显示</td>
</tr>
<tr>
<td>%o</td>
<td>整型以八进制方式显示</td>
</tr>
<tr>
<td>%d</td>
<td>整型以十进制方式显示,以锁为例子mutex&#x3D;&amp;((1 0) 0 0 -1073741824 0)</td>
</tr>
<tr>
<td>%x</td>
<td>整型以十六进制方式显示</td>
</tr>
<tr>
<td>%X</td>
<td>整型以十六进制、字母大写方式显示</td>
</tr>
<tr>
<td>%c</td>
<td>相应Unicode码点所表示的字符</td>
</tr>
<tr>
<td>%U</td>
<td>Unicode 字符, Unicode格式：123，等同于 “U+007B”</td>
</tr>
</tbody></table>
</li>
<li><p>浮点数格式控制</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%e</td>
<td>科学计数法,例如 -1234.456e+78</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法,例如 -1234.456E+78</td>
</tr>
<tr>
<td>%f</td>
<td>有小数点而无指数,例如 123.456</td>
</tr>
<tr>
<td>%g</td>
<td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
<tr>
<td>%G</td>
<td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
</tbody></table>
</li>
<li><p>字符串格式化</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串或切片的无解译字节</td>
</tr>
<tr>
<td>%q</td>
<td>双引号围绕的字符串，由Go语法安全地转义</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制，小写字母，每字节两个字符</td>
</tr>
<tr>
<td>%X</td>
<td>十六进制，大写字母，每字节两个字符</td>
</tr>
</tbody></table>
</li>
<li><p>指针格式化</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%p</td>
<td>十六进制表示，前缀 0x</td>
</tr>
</tbody></table>
</li>
<li><p>通用的占位符</p>
<table>
<thead>
<tr>
<th>格 式</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>%v</td>
<td>值的默认格式。只输出字段的值，没有字段名字,eg: requestVote RPC&#x3D;{1,1,0,0}</td>
</tr>
<tr>
<td>%+v</td>
<td>类似%v，但输出结构体时会添加字段名,以RWMutex为例子, &amp;{w:{state:1 sema:0} writerSem:0 readerSem:0 readerCount:-1073741824 readerWait:0}</td>
</tr>
<tr>
<td>%#v</td>
<td>相应值的Go语法表示,比如地址用十六进制表示,以RWMutex为例子, &amp;sync.RWMutex{w:sync.Mutex{state:1, sema:0x0}, writerSem:0x0, readerSem:0x0, readerCount:-1073741824, readerWait:0}</td>
</tr>
<tr>
<td>%T</td>
<td>相应值的类型的Go语法表示,比如以RWMutex为例子,rf.mu&#x3D;*sync.RWMutex</td>
</tr>
<tr>
<td>%%</td>
<td>百分号,字面上的%,非占位符含义</td>
</tr>
</tbody></table>
</li>
<li><p>控制宽度<br>  宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐</p>
<ul>
<li><p>字符串控制</p>
<pre><code><pre class="language-golang" data-language="golang"><code class="language-golang">fmt.Printf(&quot;|%s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 不设置宽度
fmt.Printf(&quot;|%5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度,  默认+， 右对齐
fmt.Printf(&quot;|%-5s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; 5个宽度, 左对齐
fmt.Printf(&quot;|%05s|&quot;, &quot;aa&quot;) &#x2F;&#x2F; |000aa|</code></pre>
</code></pre>
</li>
<li><p>浮点控制</p>
<pre><code><pre class="language-golang" data-language="golang"><code class="language-golang">a :&#x3D; 54.123456
fmt.Printf(&quot;|%f|&quot;, a)  &#x2F;&#x2F; |54.123456|
fmt.Printf(&quot;|%5.1f|&quot;, a)  &#x2F;&#x2F; | 54.1|
fmt.Printf(&quot;|%-5.1f|&quot;, a) &#x2F;&#x2F; |54.1 |
fmt.Printf(&quot;|%05.1f|&quot;, a) &#x2F;&#x2F; |054.1|</code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a>3.1 整型</h2><ol>
<li>因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节</li>
<li>Unicode和rune类型是个<code>int32</code>等价的类型,通常用于表示一个Unicode码点</li>
<li>同样byte也是<code>uint8</code>类型的等价类型</li>
<li>还有一种无符号的整数类型<code>uintptr</code>，没有指定具体的bit大小但是足以容纳指针。<code>uintptr</code>类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方</li>
<li><code>int</code>、<code>uint</code>和<code>uintptr</code>是不同类型的兄弟类型。其中<code>int</code>和<code>int32</code>也是不同的类型，即使<code>int</code>的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然</li>
<li>位元素符号</li>
<li><code>int32</code>和<code>int64</code>无法直接四则运算</li>
<li><code>fmt.Printf(&quot;%d %[1]o %#[1]o\n&quot;, o) // &quot;438 666 0666&quot;</code>中的<code>fmt</code>两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀</li>
</ol>
<h2 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2 浮点数"></a>3.2 浮点数</h2><ol>
<li>一个<code>float32</code>类型的浮点数可以提供大约<code>6</code>个十进制数的精度，而<code>float64</code>则可以提供约<code>15</code>个十进制数的精度；通常应该优先使用<code>float64</code>类型，因为<code>float32</code>类型的累计计算误差很容易扩散，并且<code>float32</code>能精确表示的正整数并不是很大</li>
<li>浮点数字面量可以直接书写</li>
<li>很大或者很小的数都可以用科学计数法来书写</li>
<li><code>fmt.Printf(&quot;x = %d e^x = %8.3f\n&quot;, x, math.Exp(float64(x)))</code>8.3是指三个小数精度，8个字符宽度,<code>%g %e %f</code>.</li>
</ol>
<h2 id="3-3-复数"><a href="#3-3-复数" class="headerlink" title="3.3 复数"></a>3.3 复数</h2><p>复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var x complex128 &#x3D; complex(1, 2) &#x2F;&#x2F; 1+2i
var y complex128 &#x3D; complex(3, 4) &#x2F;&#x2F; 3+4i
fmt.Println(x*y)                 &#x2F;&#x2F; &quot;(-5+10i)&quot;
fmt.Println(real(x*y))           &#x2F;&#x2F; &quot;-5&quot;
fmt.Println(imag(x*y))           &#x2F;&#x2F; &quot;10&quot;
</code></pre>

<h2 id="3-4-布尔类型"><a href="#3-4-布尔类型" class="headerlink" title="3.4 布尔类型"></a>3.4 布尔类型</h2><p>布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">i :&#x3D; 0
if b &#123;
    i &#x3D; 1
&#125;</code></pre>

<h2 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a>3.5 字符串</h2><ul>
<li><p>字符串可以用&#x3D;&#x3D;和&lt;进行比较；比较通过逐个字节比较完成的</p>
</li>
<li><p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故<code>s[0] = &#39;L&#39; // compile error: cannot assign to s[0]</code></p>
<ul>
<li>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中</li>
<li>可在字符串面值中写<code>十六进制</code>和<code>八进制</code>数字进行码点转义</li>
<li>原生字面值用反引号(&#96;)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.</li>
<li>通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思</li>
<li>UTF-8 [to be continue]</li>
<li><code>bytes</code>、<code>strings</code>、<code>strconv</code>和<code>unicode</code>包,四个包对字符串处理尤为重要,<code>strings</code>包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能</li>
<li>字符串和数字的转换,<code>strconv</code>包提供这类转换功能</li>
</ul>
</li>
</ul>
<h1 id="4-复合数据类型"><a href="#4-复合数据类型" class="headerlink" title="4. 复合数据类型"></a>4. 复合数据类型</h1><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>数组代码示例</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var a [3]int             &#x2F;&#x2F; array of 3 integers
fmt.Println(a[0])        &#x2F;&#x2F; print the first element
fmt.Println(a[len(a)-1]) &#x2F;&#x2F; print the last element, a[2]

&#x2F;&#x2F; Print the indices and elements.
for i, v :&#x3D; range a &#123;
    fmt.Printf(&quot;%d %d\n&quot;, i, v)
&#125;

&#x2F;&#x2F; Print the elements only.
for _, v :&#x3D; range a &#123;
    fmt.Printf(&quot;%d\n&quot;, v)
&#125;</code></pre>

<p>如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">q :&#x3D; [...]int&#123;1, 2, 3&#125;
fmt.Printf(&quot;%T\n&quot;, q) &#x2F;&#x2F; &quot;[3]int&quot;</code></pre>

<p>上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Currency int

const (
    USD Currency &#x3D; iota &#x2F;&#x2F; 美元
    EUR                 &#x2F;&#x2F; 欧元
    GBP                 &#x2F;&#x2F; 英镑
    RMB                 &#x2F;&#x2F; 人民币
)

symbol :&#x3D; [...]string&#123;USD: &quot;$&quot;, EUR: &quot;€&quot;, GBP: &quot;￡&quot;, RMB: &quot;￥&quot;&#125;

fmt.Println(RMB, symbol[RMB]) &#x2F;&#x2F; &quot;3 ￥&quot;</code></pre>

<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">r :&#x3D; [...]int&#123;99: -1&#125;</code></pre>

<p>数组进行比较是比较所有元素是否相等</p>
<h2 id="4-2-slice"><a href="#4-2-slice" class="headerlink" title="4.2 slice"></a>4.2 slice</h2><p>创建slice变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">v_len :&#x3D; make([]T, len)
v_len_cap :&#x3D; make([]T, len, cap) &#x2F;&#x2F; same as make([]T, cap)[:len]
s :&#x3D; []int&#123;0, 1, 2, 3, 4, 5&#125;</code></pre>

<p><code>slice</code>和<code>数组</code>典型的不同就是<code>slice</code>不指定长度<br><code>bytes.Equal</code>函数来判断两个字节型slice是否相等（[]byte)</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func equal(x, y []string) bool &#123;
    if len(x) !&#x3D; len(y) &#123;
        return false
    &#125;
    for i :&#x3D; range x &#123;
        if x[i] !&#x3D; y[i] &#123;
            return false
        &#125;
    &#125;
    return true
&#125;</code></pre>

<p>slice的nil值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var s []int    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; nil        &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; []int(nil) &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s &#x3D;&#x3D; nil
s &#x3D; []int&#123;&#125;    &#x2F;&#x2F; len(s) &#x3D;&#x3D; 0, s !&#x3D; nil</code></pre>

<h3 id="4-2-1-append函数"><a href="#4-2-1-append函数" class="headerlink" title="4.2.1 append函数"></a>4.2.1 append函数</h3><p>(留着放些API东西)</p>
<h2 id="4-3-Map"><a href="#4-3-Map" class="headerlink" title="4.3 Map"></a>4.3 Map</h2><p>其中K对应的key必须是支持&#x3D;&#x3D;比较运算符的数据类型,所以map可以通过测试key是否相等来判断是否已经存在<br>创建map</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">ages :&#x3D; make(map[string]int) &#x2F;&#x2F; mapping from strings to ints
ages :&#x3D; map[string]int&#123;
    &quot;alice&quot;:   31,
    &quot;charlie&quot;: 34,
&#125;
&#x2F;&#x2F;访问map数据，也是put操作
ages[&quot;alice&quot;] &#x3D; 32
&#x2F;&#x2F;删除元素
delete(ages, &quot;alice&quot;) &#x2F;&#x2F; remove element ages[&quot;alice&quot;]
&#x2F;&#x2F;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：
_ &#x3D; &amp;ages[&quot;bob&quot;] &#x2F;&#x2F; compile error: cannot take address of map element
</code></pre>

<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import &quot;sort&quot;

var names []string
for name :&#x3D; range ages &#123;
    names &#x3D; append(names, name)
&#125;
sort.Strings(names)
for _, name :&#x3D; range names &#123;
    fmt.Printf(&quot;%s\t%d\n&quot;, name, ages[name])
&#125;</code></pre>

<p>map返回两个值，第一个值是bool类型,false则说明不存在这个key。<br>map的key要求必须是可比较类型，那么如果想用slice作为key就需要写小改动</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var m &#x3D; make(map[string]int)

func k(list []string) string &#123; return fmt.Sprintf(&quot;%q&quot;, list) &#125;

func Add(list []string)       &#123; m[k(list)]++ &#125;
func Count(list []string) int &#123; return m[k(list)] &#125;</code></pre>

<h2 id="4-4-结构体"><a href="#4-4-结构体" class="headerlink" title="4.4 结构体"></a>4.4 结构体</h2><pre class="language-golang" data-language="golang"><code class="language-golang">seen :&#x3D; make(map[string]struct&#123;&#125;) &#x2F;&#x2F; set of strings
&#x2F;&#x2F; ...
if _, ok :&#x3D; seen[s]; !ok &#123;
    seen[s] &#x3D; struct&#123;&#125;&#123;&#125;
    &#x2F;&#x2F; ...first time seeing s...
&#125;</code></pre>

<h3 id="4-4-1-结构体字面值"><a href="#4-4-1-结构体字面值" class="headerlink" title="4.4.1 结构体字面值"></a>4.4.1 结构体字面值</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Point struct&#123; X, Y int &#125;
&#x2F;&#x2F;第一种类型初始化方式
p :&#x3D; Point&#123;1, 2&#125;
&#x2F;&#x2F;第二种初始化方式,如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要
p :&#x3D;Point&#123;x:1,y:2&#125;</code></pre>

<p>非导出结构体或者字段，不能在其他包中进行赋值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package p
type T struct&#123; a, b int &#125; &#x2F;&#x2F; a and b are not exported

package q
import &quot;p&quot;
var _ &#x3D; p.T&#123;a: 1, b: 2&#125; &#x2F;&#x2F; compile error: can&#39;t reference a, b
var _ &#x3D; p.T&#123;1, 2&#125;       &#x2F;&#x2F; compile error: can&#39;t reference a, b</code></pre>

<p>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
func Bonus(e *Employee, percent int) int &#123;
    return e.Salary * percent &#x2F; 100
&#125;</code></pre>

<p>可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">pp :&#x3D; &amp;Point&#123;1, 2&#125;</code></pre>

<p>它和下面的语句是等价的</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">pp :&#x3D; new(Point)
*pp &#x3D; Point&#123;1, 2&#125;</code></pre>

<h3 id="4-4-2-结构体的比较"><a href="#4-4-2-结构体的比较" class="headerlink" title="4.4.2 结构体的比较"></a>4.4.2 结构体的比较</h3><p>首先结构体是可比较类型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
type Point struct&#123; X, Y int &#125;

p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;2, 1&#125;
fmt.Println(p.X &#x3D;&#x3D; q.X &amp;&amp; p.Y &#x3D;&#x3D; q.Y) &#x2F;&#x2F; &quot;false&quot;
fmt.Println(p &#x3D;&#x3D; q)                   &#x2F;&#x2F; &quot;false&quot;
</code></pre>

<h3 id="4-4-3-结构体嵌入和匿名成员"><a href="#4-4-3-结构体嵌入和匿名成员" class="headerlink" title="4.4.3 结构体嵌入和匿名成员"></a>4.4.3 结构体嵌入和匿名成员</h3><pre class="language-golang" data-language="golang"><code class="language-golang">
type Point struct &#123;
    X, Y int
&#125;

type Circle struct &#123;
    Center Point
    Radius int
&#125;

type Wheel struct &#123;
    Circle Circle
    Spokes int
&#125;

var w Wheel
w.Circle.Center.X &#x3D; 8
w.Circle.Center.Y &#x3D; 8
w.Circle.Radius &#x3D; 5
w.Spokes &#x3D; 20</code></pre>

<p>匿名成员，说白了就是只写类型不写名字.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Circle struct &#123;
    Point
    Radius int
&#125;

type Wheel struct &#123;
    Circle
    Spokes int
&#125;

var w Wheel
w.X &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.X &#x3D; 8
w.Y &#x3D; 8            &#x2F;&#x2F; equivalent to w.Circle.Point.Y &#x3D; 8
w.Radius &#x3D; 5       &#x2F;&#x2F; equivalent to w.Circle.Radius &#x3D; 5
w.Spokes &#x3D; 20
&#x2F;&#x2F;以下初始化是错误的
w &#x3D; Wheel&#123;8, 8, 5, 20&#125;                       &#x2F;&#x2F; compile error: unknown fields
w &#x3D; Wheel&#123;X: 8, Y: 8, Radius: 5, Spokes: 20&#125; &#x2F;&#x2F; compile error: unknown fields</code></pre>

<p>所以我们只能用下面两种方式进行初始化</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
w &#x3D; Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;

w &#x3D; Wheel&#123;
    Circle: Circle&#123;
        Point:  Point&#123;X: 8, Y: 8&#125;,
        Radius: 5,
    &#125;,
    Spokes: 20, &#x2F;&#x2F; NOTE: trailing comma necessary here (and at Radius)
&#125;

fmt.Printf(&quot;%#v\n&quot;, w)
&#x2F;&#x2F; Output:
&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;

w.X &#x3D; 42

fmt.Printf(&quot;%#v\n&quot;, w)
&#x2F;&#x2F; Output:
&#x2F;&#x2F; Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;
</code></pre>

<p>需要注意，但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</p>
<h2 id="4-5-json字符串"><a href="#4-5-json字符串" class="headerlink" title="4.5 json字符串"></a>4.5 json字符串</h2><p><code>json.Marshal</code>包<br>代码例子</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Movie struct &#123;
    Title  string
    Year   int  &#96;json:&quot;released&quot;&#96; &#x2F;&#x2F; 这个tag指定生成json名字
    Color  bool &#96;json:&quot;color,omitempty&quot;&#96;
    Actors []string
&#125;

var movies &#x3D; []Movie&#123;
    &#123;Title: &quot;Casablanca&quot;, Year: 1942, Color: false,
        Actors: []string&#123;&quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot;&#125;&#125;,
    &#123;Title: &quot;Cool Hand Luke&quot;, Year: 1967, Color: true,
        Actors: []string&#123;&quot;Paul Newman&quot;&#125;&#125;,
    &#123;Title: &quot;Bullitt&quot;, Year: 1968, Color: true,
        Actors: []string&#123;&quot;Steve McQueen&quot;, &quot;Jacqueline Bisset&quot;&#125;&#125;,
    &#x2F;&#x2F; ...
&#125;</code></pre>

<h2 id="4-6-文本和HTML模板"><a href="#4-6-文本和HTML模板" class="headerlink" title="4.6 文本和HTML模板"></a>4.6 文本和HTML模板</h2><p>(后面需要时候着重的看)<br><code>text/template和html/template</code>,们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。模板语言支持流程控制语句<br>模板语言demo</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const templ &#x3D; &#96;&#123;&#123;.TotalCount&#125;&#125; issues:
&#123;&#123;range .Items&#125;&#125;----------------------------------------
Number: &#123;&#123;.Number&#125;&#125;
User:   &#123;&#123;.User.Login&#125;&#125;
Title:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;
Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days
&#123;&#123;end&#125;&#125;&#96;</code></pre>

<p><code>|</code> 操作符表示将前一个表达式的结果作为后一个函数的输入.<br>生成模板的输出需要两个处理步骤</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var report &#x3D; template.Must(template.New(&quot;issuelist&quot;).
    Funcs(template.FuncMap&#123;&quot;daysAgo&quot;: daysAgo&#125;).
    Parse(templ))

func main() &#123;
    result, err :&#x3D; github.SearchIssues(os.Args[1:])
    if err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
    if err :&#x3D; report.Execute(os.Stdout, result); err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
&#125;</code></pre>

<p>如果想转化为html则需要编写如下代码</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
import &quot;html&#x2F;template&quot;

var issueList &#x3D; template.Must(template.New(&quot;issuelist&quot;).Parse(&#96;
&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;&#x2F;h1&gt;
&lt;table&gt;
&lt;tr style&#x3D;&#39;text-align: left&#39;&gt;
  &lt;th&gt;#&lt;&#x2F;th&gt;
  &lt;th&gt;State&lt;&#x2F;th&gt;
  &lt;th&gt;User&lt;&#x2F;th&gt;
  &lt;th&gt;Title&lt;&#x2F;th&gt;
&lt;&#x2F;tr&gt;
&#123;&#123;range .Items&#125;&#125;
&lt;tr&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Number&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;&#x2F;td&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.User.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
  &lt;td&gt;&lt;a href&#x3D;&#39;&#123;&#123;.HTMLURL&#125;&#125;&#39;&gt;&#123;&#123;.Title&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;
&lt;&#x2F;tr&gt;
&#123;&#123;end&#125;&#125;
&lt;&#x2F;table&gt;
&#96;))</code></pre>

<p>注意，html&#x2F;template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text&#x2F;template包的话，这2个issue将会产生错误，其中“&lt;”四个字符将会被当作小于字符“&lt;”处理，同时“<link>”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。</p>
<h1 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h1><p>声明和定义</p>
<ul>
<li><p>switch 控制语句</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">switch cond&#123;
  case a :
      fmt.Printf()
  case b :
      fmt.Printf()
  case c :
      fmt.Printf()
&#125;</code></pre></li>
</ul>
<h2 id="5-1-错误"><a href="#5-1-错误" class="headerlink" title="5.1 错误"></a>5.1 错误</h2><p>通常，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</p>
<p>我们有几种处理错误的策略</p>
<ol>
<li>发生错误时的解析器</li>
</ol>
<p>  发生解析错误后,findLinks 函数构造了一个新的异常信息,既包含了自定义的，也包含了底层解析出错的信息</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">doc, err :&#x3D; html.Parse(resp.Body)
resp.Body.Close()
if err !&#x3D; nil &#123;
    return nil, fmt.Errorf(&quot;parsing %s as HTML: %v&quot;, url,err)
&#125;</code></pre>

<p>  参考宇航局事故调查<br>2. 重试<br>  我们需要限制重试的时间间隔或重试的次数，防止无限制的重试.<br>3. 输出错误信息并结束程序<br>  输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行,对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;
  log.Fatalf(&quot;Site is down: %v\n&quot;, err)
&#125;</code></pre>

<p>  <code>log.Fatalf</code>代码更简洁，并输出自定义格式信息</p>
<ol start="4">
<li>只是输出错误信息就可以</li>
</ol>
  <pre class="language-golang" data-language="golang"><code class="language-golang">if err :&#x3D; Ping(); err !&#x3D; nil &#123;
  log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)
&#125;
&#x2F;&#x2F;或者标准错误流输出错误信息。

if err :&#x3D; Ping(); err !&#x3D; nil &#123;
    fmt.Fprintf(os.Stderr, &quot;ping failed: %v; networking disabled\n&quot;, err)
&#125;</code></pre>

<ol start="5">
<li>直接忽略掉错误</li>
</ol>
  <pre class="language-golang" data-language="golang"><code class="language-golang">dir, err :&#x3D; ioutil.TempDir(&quot;&quot;, &quot;scratch&quot;)
if err !&#x3D; nil &#123;
    return fmt.Errorf(&quot;failed to create temp dir: %v&quot;,err)
&#125;
&#x2F;&#x2F; ...use temp dir…
os.RemoveAll(dir) &#x2F;&#x2F; ignore errors; $TMPDIR is cleaned periodically</code></pre>

<p>  尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响</p>
<ol start="6">
<li>文件结尾错误</li>
</ol>
<p>io包保证任何由文件结束引起的读取失败都返</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package io

import &quot;errors&quot;

&#x2F;&#x2F; EOF is the error returned by Read when no more input is available.
var EOF &#x3D; errors.New(&quot;EOF&quot;)

in :&#x3D; bufio.NewReader(os.Stdin)
for &#123;
    r, _, err :&#x3D; in.ReadRune()
    if err &#x3D;&#x3D; io.EOF &#123;
        break &#x2F;&#x2F; finished reading
    &#125;
    if err !&#x3D; nil &#123;
        return fmt.Errorf(&quot;read failed:%v&quot;, err)
    &#125;
    &#x2F;&#x2F; ...use r…
&#125;</code></pre>

<h2 id="5-2-函数值"><a href="#5-2-函数值" class="headerlink" title="5.2 函数值"></a>5.2 函数值</h2><ul>
<li><p>函数在golang中也是一种类型，可以被复制给其他变量。  </p>
</li>
<li><p>很熟类型的<code>零</code>值是<code>nil</code>,调用值为nil会引起<code>panic</code>错误  </p>
</li>
<li><p>函数值之间是不可以比较的,也不能用函数值作为map的key</p>
</li>
<li><p>strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func add1(r rune) rune &#123; return r + 1 &#125;

fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) &#x2F;&#x2F; &quot;IBM.:111&quot;
fmt.Println(strings.Map(add1, &quot;VMS&quot;))      &#x2F;&#x2F; &quot;WNT&quot;
fmt.Println(strings.Map(add1, &quot;Admix&quot;))    &#x2F;&#x2F; &quot;Benjy&quot;</code></pre></li>
</ul>
<p>demo示例</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;值得学习
&#x2F;&#x2F; forEachNode针对每个结点x，都会调用pre(x)和post(x)。
&#x2F;&#x2F; pre和post都是可选的。
&#x2F;&#x2F; 遍历孩子结点之前，pre被调用
&#x2F;&#x2F; 遍历孩子结点之后，post被调用
func forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123;
    if pre !&#x3D; nil &#123;
        pre(n)
    &#125;
    for c :&#x3D; n.FirstChild; c !&#x3D; nil; c &#x3D; c.NextSibling &#123;
        forEachNode(c, pre, post)
    &#125;
    if post !&#x3D; nil &#123;
        post(n)
    &#125;
&#125;</code></pre>

<h2 id="5-3-匿名函数"><a href="#5-3-匿名函数" class="headerlink" title="5.3 匿名函数"></a>5.3 匿名函数</h2><p>函数内部定义的函数可以访问整个词法环境，言外之意就是嵌套的函数可以访问外层函数的变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; squares返回一个匿名函数。
&#x2F;&#x2F; 该匿名函数每次被调用时都会返回下一个数的平方。
&#x2F;&#x2F;squares 函数每次都返回一个函数类型-func()int&#123;&#125;
func squares() func() int &#123;
    var x int
    return func() int &#123; &#x2F;&#x2F; 匿名函数
        x++
        return x * x
    &#125;
&#125;
func main() &#123;
    f :&#x3D; squares()
    fmt.Println(f()) &#x2F;&#x2F; &quot;1&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;4&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;9&quot;
    fmt.Println(f()) &#x2F;&#x2F; &quot;16&quot;
&#125;
&#x2F;&#x2F;通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</code></pre>

<blockquote>
<p>网页抓取的核心问题就是如何遍历图</p>
</blockquote>
<p>警告:捕获迭代变量</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var rmdirs []func()
for _, d :&#x3D; range tempDirs() &#123;
    dir :&#x3D; d &#x2F;&#x2F; NOTE: necessary!
    os.MkdirAll(dir, 0755) &#x2F;&#x2F; creates parent directories too
    rmdirs &#x3D; append(rmdirs, func() &#123;
        os.RemoveAll(dir)
    &#125;)
&#125;
&#x2F;&#x2F; ...do some work…
for _, rmdir :&#x3D; range rmdirs &#123;
    rmdir() &#x2F;&#x2F; clean up
&#125;
&#x2F;&#x2F; 
var rmdirs []func()
for _, dir :&#x3D; range tempDirs() &#123;
    os.MkdirAll(dir, 0755)
    rmdirs &#x3D; append(rmdirs, func() &#123;
        os.RemoveAll(dir) &#x2F;&#x2F; NOTE: incorrect!
    &#125;)
&#125;
</code></pre>

<p>问题出在了循环变量的作用域,循环变量dir在这个词法块中被声明，每一次迭代都是会不断地更新这个值，被<code>range</code>语句，解决这个问题的办法就是引入同名变量来覆盖其作用域。</p>
<h2 id="5-4-可变参数"><a href="#5-4-可变参数" class="headerlink" title="5.4 可变参数"></a>5.4 可变参数</h2><p>简单的可变参数例子,其实<code>可变参数</code>就是个切片的值传递,<code>interface&#123;&#125;</code>表示函数的最后一个参数可以接收任意类型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func sum(vals ...int) int &#123;
    total :&#x3D; 0
    for _, val :&#x3D; range vals &#123;
        total +&#x3D; val
    &#125;
    return total
&#125;</code></pre>

<p>如果原参数就是切片该怎么传递？可以直接在<code>实参</code>后面加省略号</p>
<h2 id="5-5-defer函数"><a href="#5-5-defer函数" class="headerlink" title="5.5 defer函数"></a>5.5 defer函数</h2><p>在函数执行完成之后，不管是正常退出还是异常退出函数，最后都会被执行</p>
<h2 id="5-6-panic异常"><a href="#5-6-panic异常" class="headerlink" title="5.6 panic异常"></a>5.6 panic异常</h2><p>当panic发生时会在该goroutine上执行defer函数，打印对应的栈信息<br><code>regexp</code>包的使用<br>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
    defer printStack()
    f(3)
&#125;
func printStack() &#123;
    var buf [4096]byte
    n :&#x3D; runtime.Stack(buf[:], false)
    os.Stdout.Write(buf[:n])
&#125;
</code></pre>

<p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p>
<h2 id="5-7-Recovery捕获异常"><a href="#5-7-Recovery捕获异常" class="headerlink" title="5.7 Recovery捕获异常"></a>5.7 Recovery捕获异常</h2><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所</p>
<ul>
<li>语言解析器为例<br>说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">func Parse(input string) (s *Syntax, err error) &#123;
    defer func() &#123;
        if p :&#x3D; recover(); p !&#x3D; nil &#123;
            err &#x3D; fmt.Errorf(&quot;internal error: %v&quot;, p)
        &#125;
    &#125;()
    &#x2F;&#x2F; ...parser...
&#125;</code></pre>

<ul>
<li>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。  </li>
<li>有时我们很难完全遵循规范，举个例子，net&#x2F;http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</li>
</ul>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; soleTitle returns the text of the first non-empty title element
&#x2F;&#x2F; in doc, and an error if there was not exactly one.
&#x2F;&#x2F;防御性panic代码
func soleTitle(doc *html.Node) (title string, err error) &#123;
    type bailout struct&#123;&#125;
    defer func() &#123;
        switch p :&#x3D; recover(); p &#123;
        case nil:       &#x2F;&#x2F; no panic
        case bailout&#123;&#125;: &#x2F;&#x2F; &quot;expected&quot; panic
            err &#x3D; fmt.Errorf(&quot;multiple title elements&quot;)
        default:
            panic(p) &#x2F;&#x2F; unexpected panic; carry on panicking
        &#125;
    &#125;()
    &#x2F;&#x2F; Bail out of recursion if we find more than one nonempty title.
    forEachNode(doc, func(n *html.Node) &#123;
        if n.Type &#x3D;&#x3D; html.ElementNode &amp;&amp; n.Data &#x3D;&#x3D; &quot;title&quot; &amp;&amp;
            n.FirstChild !&#x3D; nil &#123;
            if title !&#x3D; &quot;&quot; &#123;
                panic(bailout&#123;&#125;) &#x2F;&#x2F; multiple titleelements
            &#125;
            title &#x3D; n.FirstChild.Data
        &#125;
    &#125;, nil)
    if title &#x3D;&#x3D; &quot;&quot; &#123;
        return &quot;&quot;, fmt.Errorf(&quot;no title element&quot;)
    &#125;
    return title, nil
&#125;</code></pre>

<h1 id="6-方法"><a href="#6-方法" class="headerlink" title="6. 方法"></a>6. 方法</h1><h2 id="6-1-方法声明"><a href="#6-1-方法声明" class="headerlink" title="6.1 方法声明"></a>6.1 方法声明</h2><ul>
<li>普通函数与接收器方法<br><code>接收器</code>因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。对于一个给定的类型，其内部的方法都必须有唯一的方法名</li>
</ul>
<h2 id="6-2-基于指针对象的方法"><a href="#6-2-基于指针对象的方法" class="headerlink" title="6.2 基于指针对象的方法"></a>6.2 基于指针对象的方法</h2><ul>
<li><p>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。</p>
</li>
<li><p>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。</p>
</li>
<li><p>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们下面例子里做的这样</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">func (list *IntList) Sum() int &#123;
if list &#x3D;&#x3D; nil &#123;
    return 0
&#125;
return list.Value + list.Tail.Sum()
&#125;</code></pre>

<p>  如果此时结构体是<code>nil</code>调用对象可能会发生类似于空指针异常的错误</p>
</li>
</ul>
<h2 id="6-3-通过嵌入结构体来扩展类型"><a href="#6-3-通过嵌入结构体来扩展类型" class="headerlink" title="6.3. 通过嵌入结构体来扩展类型"></a>6.3. 通过嵌入结构体来扩展类型</h2><ul>
<li><p>方法值<br>  在go语言中，方法是第一公民，这一点在函数式编程中非常实用(maybe)</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;方法值demo
p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;4, 6&#125;

distanceFromP :&#x3D; p.Distance        &#x2F;&#x2F; method value,Distance是结构体方法
fmt.Println(distanceFromP(q))      &#x2F;&#x2F; &quot;5&quot;
var origin Point                   &#x2F;&#x2F; &#123;0, 0&#125;
fmt.Println(distanceFromP(origin)) &#x2F;&#x2F; &quot;2.23606797749979&quot;, sqrt(5)

scaleP :&#x3D; p.ScaleBy &#x2F;&#x2F; method value
scaleP(2)           &#x2F;&#x2F; p becomes (2, 4)
scaleP(3)           &#x2F;&#x2F;      then (6, 12)
scaleP(10)          &#x2F;&#x2F;      then (60, 120)</code></pre>
</li>
<li><p>方法表达式<br>  在面向对象中，当根据哪一个变量来决定调用哪个函数时候,方法表达式就很有用了.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">p :&#x3D; Point&#123;1, 2&#125;
q :&#x3D; Point&#123;4, 6&#125;

distance :&#x3D; Point.Distance   &#x2F;&#x2F; method expression
fmt.Println(distance(p, q))  &#x2F;&#x2F; &quot;5&quot;
fmt.Printf(&quot;%T\n&quot;, distance) &#x2F;&#x2F; &quot;func(Point, Point) float64&quot;

scale :&#x3D; (*Point).ScaleBy
scale(&amp;p, 2)
fmt.Println(p)            &#x2F;&#x2F; &quot;&#123;2 4&#125;&quot;
fmt.Printf(&quot;%T\n&quot;, scale) &#x2F;&#x2F; &quot;func(*Point, float64)&quot;
</code></pre></li>
</ul>
<p>practice demo</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Point struct&#123; X, Y float64 &#125;

func (p Point) Add(q Point) Point &#123; return Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;
func (p Point) Sub(q Point) Point &#123; return Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) &#123;
    var op func(p, q Point) Point
    if add &#123;
        op &#x3D; Point.Add
    &#125; else &#123;
        op &#x3D; Point.Sub
    &#125;
    for i :&#x3D; range path &#123;
        &#x2F;&#x2F; Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] &#x3D; op(path[i], offset)
    &#125;
&#125;</code></pre>

<h2 id="6-4-封装"><a href="#6-4-封装" class="headerlink" title="6.4 封装"></a>6.4 封装</h2><p>封装提供了三方面的优点。</p>
<ol>
<li><p>首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可.</p>
</li>
<li><p>第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由</p>
</li>
<li><p>bytes.Buffer这个类型作为例子来考虑</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">
type Buffer struct &#123;
buf     []byte
initial [64]byte
&#x2F;* ... *&#x2F;
&#125;

&#x2F;&#x2F; Grow expands the buffer&#39;s capacity, if necessary,
&#x2F;&#x2F; to guarantee space for another n bytes. [...]
func (b *Buffer) Grow(n int) &#123;
    if b.buf &#x3D;&#x3D; nil &#123;
        b.buf &#x3D; b.initial[:0] &#x2F;&#x2F; use preallocated space initially
    &#125;
    if len(b.buf)+n &gt; cap(b.buf) &#123;
        buf :&#x3D; make([]byte, b.Len(), 2*cap(b.buf) + n)
        copy(buf, b.buf)
        b.buf &#x3D; buf
    &#125;
&#125;
&#x2F;&#x2F; Grow()函数式导出类型，但是stuct的字段不是到处类型</code></pre>
</li>
<li><p>只暴漏关键信息给外部使用者</p>
</li>
</ol>
<h1 id="7-接口"><a href="#7-接口" class="headerlink" title="7. 接口"></a>7. 接口</h1><p>很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用  </p>
<p>只要一个物体能像鸭子一样叫那我们就可以称它为鸭子；只要一个软件能存储和查询数据我们就可以称它为数据库；只要一台机器有洗衣服和甩干的功能我们就可以称它为洗衣机。  </p>
<p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型</p>
<h2 id="7-1-接口约定"><a href="#7-1-接口约定" class="headerlink" title="7.1. 接口约定"></a>7.1. 接口约定</h2><p>例如<code>fmt</code>包</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package fmt

func Fprintf(w io.Writer, format string, args ...interface&#123;&#125;) (int, error)
&#x2F;&#x2F;Printf 最后调用Fprintf 函数
func Printf(format string, args ...interface&#123;&#125;) (int, error) &#123;
    return Fprintf(os.Stdout, format, args...)
&#125;
&#x2F;&#x2F; Sprintf函数最后也是调用Fprintf
func Sprintf(format string, args ...interface&#123;&#125;) string &#123;
    var buf bytes.Buffer
    Fprintf(&amp;buf, format, args...)
    return buf.String()
&#125;</code></pre>

<p><code>Fprintf</code>函数的<code>F</code>说明了文件类型也说明了所有信息要被写入到文件当中，在<code>Printf</code>函数中的第一个参数<code>os.Stdout</code>是<code>*os.File</code>类型实现了<code>io.Writer</code>接口，在<code>Sprintf</code>函数中的第一个参数<code>&amp;buf</code>是一个指向可以写入字节的内存缓冲区也该类型也是实现了<code>io.Writer</code>接口,用户可以自定义一个函数并实现<code>io.Writer</code>接口。<br><strong>LSP里氏替换</strong> : <code>fmt.Fprintf</code>通过使用接口类型<code>io.Writer</code>使得只要调用者只要传入实现了该接口的类型就可以实现自由替换</p>
<details><summary>自定义bytecounter函数，实现计算int转byte长度</summary>

<pre class="language-golang" data-language="golang"><code class="language-golang">
package main

import (
 &quot;fmt&quot;
)

&#x2F;&#x2F;!+bytecounter

type ByteCounter int

func (c *ByteCounter) Write(p []byte) (int, error) &#123;
 *c +&#x3D; ByteCounter(len(p)) &#x2F;&#x2F; convert int to ByteCounter
 return len(p), nil
&#125;

&#x2F;&#x2F;!-bytecounter

func main() &#123;
 &#x2F;&#x2F;!+main
 var c ByteCounter
 c.Write([]byte(&quot;hello&quot;))
 fmt.Println(c) &#x2F;&#x2F; &quot;5&quot;, &#x3D; len(&quot;hello&quot;)

 c &#x3D; 0 &#x2F;&#x2F; reset the counter
 var name &#x3D; &quot;Dolly&quot;
 fmt.Fprintf(&amp;c, &quot;hello, %s&quot;, name)
 fmt.Println(c) &#x2F;&#x2F; &quot;12&quot;, &#x3D; len(&quot;hello, Dolly&quot;)
 &#x2F;&#x2F;!-main
&#125;</code></pre>

</details>

<p>因为它实现了<code>writer</code>接口就可以传入到<code>Fprintf</code>函数中.总结来说，接口约定了包使用者的行为，但是使用者想创建什么样的实例需要他自己去实现。</p>
<h2 id="7-2-接口类型"><a href="#7-2-接口类型" class="headerlink" title="7.2 接口类型"></a>7.2 接口类型</h2><p>通过组合定义接口</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package io
type Reader interface &#123;
    Read(p []byte) (n int, err error)
&#125;
type Closer interface &#123;
    Close() error
&#125;

type ReadWriter interface &#123;
    Reader
    Writer
&#125;
type ReadWriteCloser interface &#123;
    Reader
    Writer
    Closer
&#125;
&#x2F;&#x2F; 另一种命名风格
type ReadWriter interface &#123;
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
&#125;
&#x2F;&#x2F;或者甚至使用一种混合的风格：

type ReadWriter interface &#123;
    Read(p []byte) (n int, err error)
    Writer
&#125;</code></pre>

<h2 id="7-3-实现接口的条件"><a href="#7-3-实现接口的条件" class="headerlink" title="7.3 实现接口的条件"></a>7.3 实现接口的条件</h2><ul>
<li><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer
&#x2F;&#x2F;只实现了Write 方法
w &#x3D; os.Stdout           &#x2F;&#x2F; OK: *os.File has Write method
&#x2F;&#x2F;只实现了Write方法
w &#x3D; new(bytes.Buffer)   &#x2F;&#x2F; OK: *bytes.Buffer has Write method
&#x2F;&#x2F; time.Duration没有Write方法
w &#x3D; time.Second         &#x2F;&#x2F; compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc &#x3D; os.Stdout         &#x2F;&#x2F; OK: *os.File has Read, Write, Close methods
rwc &#x3D; new(bytes.Buffer) &#x2F;&#x2F; compile error: *bytes.Buffer lacks Close method
&#x2F;&#x2F; 这个规则甚至适用于等式右边本身也是一个接口类型
&#x2F;&#x2F; rwc io.ReadWriteCloser
w &#x3D; rwc                 &#x2F;&#x2F; OK: io.ReadWriteCloser has Write method
&#x2F;&#x2F; w 只有Write方法
rwc &#x3D; w                 &#x2F;&#x2F; compile error: io.Writer lacks Close method</code></pre>
</li>
<li></li>
</ul>
<h2 id="7-4-flag-Value接口"><a href="#7-4-flag-Value接口" class="headerlink" title="7.4 flag.Value接口"></a>7.4 flag.Value接口</h2><p>在linux程序中，你会发现很多程序都支持选项，通过带上参数，程序会有很多丰富的功能<br>比如下面demo就是简单的打印选项-period后面的值。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var period &#x3D; flag.Duration(&quot;period&quot;, 1*time.Second, &quot;sleep period&quot;)

func main() &#123;
    flag.Parse()
    fmt.Printf(&quot;Sleeping for %v...&quot;, *period)
    time.Sleep(*period)
    fmt.Println()
&#125;</code></pre>

<p>这里golang的flag包提供了这种功能，我们可以通过实现flag的接口自定义新的标记符号</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package flag

&#x2F;&#x2F; Value is the interface to the value stored in a flag.
type Value interface &#123;
    String() string
    Set(string) error
&#125;
</code></pre>

<p><code>string() string</code>方法格式化标记的值<br><code>Set(string) error</code> 解析它的字符串参数，并更新标记变量的值<br>让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的celsiusFlag类型。<br>注意celsiusFlag内嵌了一个Celsius类型，因此不用实现本身就已经有String方法了。为了实现flag.Value，我们只需要定义Set方法：<br>代码demo如下</p>
<ul>
<li><p>自定义新的标记符号</p>
  <details><summary>温度的转化</summary>

  <pre class="language-golang" data-language="golang"><code class="language-golang">package tempconv

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

type Celsius float64
type Fahrenheit float64

func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9.0&#x2F;5.0 + 32.0) &#125;
func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32.0) * 5.0 &#x2F; 9.0) &#125;

func (c Celsius) String() string &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125;

&#x2F;*
&#x2F;&#x2F;!+flagvalue
package flag

&#x2F;&#x2F; Value is the interface to the value stored in a flag.
type Value interface &#123;
    String() string
    Set(string) error
&#125;
&#x2F;&#x2F;!-flagvalue
*&#x2F;

&#x2F;&#x2F;!+celsiusFlag
&#x2F;&#x2F; *celsiusFlag satisfies the flag.Value interface.
type celsiusFlag struct&#123; Celsius &#125;

func (f *celsiusFlag) Set(s string) error &#123;
    var unit string
    var value float64
    fmt.Sscanf(s, &quot;%f%s&quot;, &amp;value, &amp;unit) &#x2F;&#x2F; no error check needed
    switch unit &#123;
    case &quot;C&quot;, &quot;°C&quot;:
        f.Celsius &#x3D; Celsius(value)
        return nil
    case &quot;F&quot;, &quot;°F&quot;:
        f.Celsius &#x3D; FToC(Fahrenheit(value))
        return nil
    &#125;
    return fmt.Errorf(&quot;invalid temperature %q&quot;, s)
&#125;

&#x2F;&#x2F;!-celsiusFlag

&#x2F;&#x2F;!+CelsiusFlag

&#x2F;&#x2F; CelsiusFlag defines a Celsius flag with the specified name,
&#x2F;&#x2F; default value, and usage, and returns the address of the flag variable.
&#x2F;&#x2F; The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.
func CelsiusFlag(name string, value Celsius, usage string) *Celsius &#123;
    f :&#x3D; celsiusFlag&#123;value&#125;
    flag.CommandLine.Var(&amp;f, name, usage)
    return &amp;f.Celsius
&#125;
&#x2F;&#x2F; main函数
var temp &#x3D; tempconv.CelsiusFlag(&quot;temp&quot;, 20.0, &quot;the temperature&quot;)

func main() &#123;
    flag.Parse()
    fmt.Println(*temp)
&#125;</code></pre>

  </details>

  <details><summary>url解析</summary>
  <pre class="language-golang" data-language="golang"><code class="language-golang">
package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;net&#x2F;url&quot;
)

type URLValue struct &#123;
    URL *url.URL
&#125;

func (v URLValue) String() string &#123;
    if v.URL !&#x3D; nil &#123;
        return v.URL.String()
    &#125;
    return &quot;&quot;
&#125;

func (v URLValue) Set(s string) error &#123;
    if u, err :&#x3D; url.Parse(s); err !&#x3D; nil &#123;
        return err
    &#125; else &#123;
        *v.URL &#x3D;*u
    &#125;
    return nil
&#125;

var u &#x3D; &amp;url.URL&#123;&#125;

func main() &#123;
    fs :&#x3D; flag.NewFlagSet(&quot;ExampleValue&quot;, flag.ExitOnError)
    fs.Var(&amp;URLValue&#123;u&#125;, &quot;url&quot;, &quot;URL to parse&quot;)

    fs.Parse([]string&#123;&quot;-url&quot;, &quot;https:&#x2F;&#x2F;golang.org&#x2F;pkg&#x2F;flag&#x2F;&quot;&#125;)
    fmt.Printf(\&#96;&#123;scheme: %q, host: %q, path: %q&#125;\&#96;, u.Scheme, u.Host, u.Path)

&#125;
</code></pre>

  </details></li>
</ul>
<h2 id="7-5-接口值"><a href="#7-5-接口值" class="headerlink" title="7.5 接口值"></a>7.5 接口值</h2><p>概念上讲接口的值,由两部分组成,是其<code>类型(值)</code>和<code>具体类型的值</code>,他们的组合被称为接口的<code>动态类型</code>和<code>动态值</code>.<br>对于像Go语言这种静态类型的语言,类型是编译期的概念;因此一个类型不是一个值。在我们的概念模型中，<br>一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。<br>下面语句中，变量w得到了3个不同的值,他们三个的值都是相同的</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer &#x2F;&#x2F;接口type Write
w &#x3D; os.Stdout &#x2F;&#x2F; 最后返回的是*file类型,func (f *File) Write(b []byte) (n int, err error)
w &#x3D; new(bytes.Buffer) &#x2F;&#x2F; func (b *Buffer) Write(p []byte) (n int, err error)
w &#x3D; nil &#x2F;&#x2F; 动态类型和动态值都为空

var a *bytes.Buffer &#x2F;&#x2F;接口*bytes.Buffer
a &#x3D; nil               &#x2F;&#x2F; 动态类型不为空和动态值都为空
fmt.Printf(&quot;%T\n&quot;, a) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;</code></pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer</code></pre>

<p><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-01.png" alt="7.1"></p>
<p>在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil（图7.1）。</p>
<p>一个接口值基于它的动态类型被描述为<code>nil</code>或<code>!nil</code>，所以这是一个空的接口值。你可以通过使用<code>w==nil</code>或者<code>w!=nil</code>来判断接口值是否为空。调用一个空接口值上的任意方法都会产生<code>panic</code>:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; panic: nil pointer dereference</code></pre>

<text style="font-family:Courier New;color:red">
如果是接口类型定义的变量那么它的动态类型和动态值都是nil，赋nil之后动态类型和动态值也全都是nil值，
但是指针,基本类型和复合类型不会.

<p>类似于java一样，不能没有对象就调用方法，会报空指针异常,上面代码在第三行动态值写为nil<br>这里面有个细节要明白，定义语句var w io.Writer(接口类型),其实是动态类型和动态值都是nil,<br>进行布尔判断的时候才是为nil,w &#x3D; nil 是将动态类型和动态值都设置成nil</p>
</text>

<p>第二个语句将一个<code>*os.File</code>类型的值赋给变量<code>w</code>:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w &#x3D; os.Stdout</code></pre>

<p>这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用<code>io.Writer(os.Stdout)</code>是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为<code>*os.File</code>指针的类型描述符，它的动态值持有<code>os.Stdout</code>的拷贝;这是一个代表处理标准输出的<code>os.File</code>类型变量的指针7.2<br><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-02.png" alt="7.2"></p>
<text style="font-family:Courier New;color:red">
在第二行的赋值操作中,type已经变成`*os.file`类型,其实上面说的很啰嗦,直接就是os.Stdout是具
体的*file类型实现了io.Writer接口
</text>

<p>调用一个包含<code>*os.File</code>类型指针的接口值的<code>Write</code>方法，使得<code>(*os.File).Write</code>方法被调用。这个调用输出“hello”。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;</code></pre>

<p>通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法<code>Write</code>上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，<code>os.Stdout</code>。效果和下面这个直接调用一样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">os.Stdout.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; &quot;hello&quot;</code></pre>

<p>第三个语句给接口值赋了一个<code>*bytes.Buffer</code>类型的值</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w &#x3D; new(bytes.Buffer)</code></pre>

<p>现在动态类型是<code>*bytes.Buffer</code>,并且动态值是一个指向新分配的缓冲区的指针<br><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-03.png" alt="7.3"><br><code>Write</code>方法的调用也使用了和之前一样的机制:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w.Write([]byte(&quot;hello&quot;)) &#x2F;&#x2F; writes &quot;hello&quot; to the bytes.Buffers</code></pre>

<p>这次类型描述符是<code>*bytes.Buffer</code>，所以调用了<code>(*bytes.Buffer).Write</code>方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。<br>最后，第四个语句将nil赋给了接口值:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w &#x3D; nil</code></pre>

<p>这个重置将它所有的部分都设为<code>nil</code>值,把变量<code>w</code>恢复到和它之前定义时相同的状态，在图7.1中可以看到。</p>
<p>一个接口值可以持有任意大的动态值。例如,表示时间实例的time.Time类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var x interface&#123;&#125; &#x3D; time.Now()</code></pre>

<text style="font-family:Courier New;color:red">
这里就是创建了一个接口类型的x值,然后可以引用任何类型值
</text>

<p>结果可能和图7.4相似。从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型;具体的实现可能会非常不同）</p>
<p><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-04.png" alt="7.4"></p>
<p>接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是<code>nil</code>值，或者它们的动态类型相同并且动态值也根据这个动态类型的<code>==</code>操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。</p>
<p>然而，如果两个接口值的<code>动态类型</code>相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>
<text style="font-family:Courier New;color:red">

<p>注意到原话’它们的动态类型相同并且动态值,就可以进行<code>==</code>操作’,要保证动态类型相等,动态值相等,则A&#x3D;&#x3D;A<br>那么基本类型相同,复杂类型地址相等</p>
</text>

<p>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型(如基本类型和指针)要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。  </p>
<p>当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用fmt包的%T动作:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
var w io.Writer
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;&lt;nil&gt;&quot;
w &#x3D; os.Stdout
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;*os.File&quot;
w &#x3D; new(bytes.Buffer)
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;
var buf *bytes.Buffer
fmt.Printf(&quot;%T\n&quot;, buf) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;
var x interface&#123;&#125;
fmt.Printf(&quot;%T\n&quot;, x) &#x2F;&#x2F; &quot;&lt;nil&gt;&quot;
&#x2F;&#x2F; 另一个接口值相等的case
w :&#x3D; new(bytes.Buffer)
fmt.Printf(&quot;%T\n&quot;, w) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;
var buf *bytes.Buffer
fmt.Printf(&quot;%T\n&quot;, buf) &#x2F;&#x2F; &quot;*bytes.Buffer&quot;
w &#x3D; &amp;bytes.Buffer&#123;&#125;
buf &#x3D; &amp;bytes.Buffer&#123;&#125;
w!&#x3D;buf
</code></pre>

<h3 id="7-5-1-警告-一个包含nil指针的接口不是nil接口"><a href="#7-5-1-警告-一个包含nil指针的接口不是nil接口" class="headerlink" title="7.5.1. 警告:一个包含nil指针的接口不是nil接口"></a>7.5.1. 警告:一个包含nil指针的接口不是nil接口</h3><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>
<p>思考下面的程序。当debug变量设置为true时，main函数会将<code>f函数</code>的输出收集到一个bytes.Buffer类型中。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const debug &#x3D; true

func main() &#123;
    var buf *bytes.Buffer
    if debug &#123;
        buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output
    &#125;
    f(buf) &#x2F;&#x2F; NOTE: subtly incorrect!
    if debug &#123;
        &#x2F;&#x2F; ...use buf...
    &#125;
&#125;

&#x2F;&#x2F; If out is non-nil, output will be written to it.
func f(out io.Writer) &#123;
    &#x2F;&#x2F; ...do something...
    if out !&#x3D; nil &#123;
        out.Write([]byte(&quot;done!\n&quot;))
    &#125;
&#125;
</code></pre>

<p>我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if out !&#x3D; nil &#123;
    out.Write([]byte(&quot;done!\n&quot;)) &#x2F;&#x2F; panic: nil pointer dereference
&#125;</code></pre>

<p>当main函数调用函数f时，它给<code>f函数</code>的out参数赋了一个<code>*bytes.Buffer</code>的空指针，所以out的动态值是nil。然而，它的动态类型是<code>*bytes.Buffer</code>，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!&#x3D;nil的结果依然是true。</p>
<p><img src="/./../../../picture/golang%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/ch7-05.png" alt="7.5"></p>
<p>动态分配机制依然决定<code>(*bytes.Buffer).Write</code>的方法会被调用，但是这次的接收者的值是nil。对于一些如<code>*os.File</code>的类型，nil是一个有效的接收者（§6.2.1），但是<code>*bytes.Buffer</code>类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</p>
<p>问题在于尽管一个nil的<code>*bytes.Buffer</code>指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了<code>(*bytes.Buffer).Write</code>方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为<code>io.Writer</code>，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var buf io.Writer &#x2F;&#x2F; 这时候是空指针，没有具体值(对象)
if debug &#123;
    buf &#x3D; new(bytes.Buffer) &#x2F;&#x2F; enable collection of output
&#125;
f(buf) &#x2F;&#x2F; OK


&#x2F;&#x2F; If out is non-nil, output will be written to it.
func f(out io.Writer) &#123;
    &#x2F;&#x2F; ...do something...
    if out !&#x3D; nil &#123; &#x2F;&#x2F; 此处判断out为nil
        out.Write([]byte(&quot;done!\n&quot;))
    &#125;
&#125;</code></pre>

<text style="font-family:Courier New;color:red">
总结一句话就是动态类型不为nil,动态值为nil,这个变量也是不要nil
</text>

<h2 id="7-6-sort-Interface接口"><a href="#7-6-sort-Interface接口" class="headerlink" title="7.6. sort.Interface接口"></a>7.6. sort.Interface接口</h2><p>排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要15行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。</p>
<p>幸运的是，sort包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。相比之下，Go语言的<code>sort.Sort</code>函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型<code>sort.Interface</code>来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p>
<p>一个内置的排序算法需要知道三个东西：</p>
<ul>
<li>序列的长度</li>
<li>表示两个元素比较的结果，</li>
<li>一种交换两个元素的方式；</li>
</ul>
<p>这就是sort.Interface的三个方法：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package sort

type Interface interface &#123;
    Len() int
    Less(i, j int) bool &#x2F;&#x2F; i, j are indices of sequence elements
    Swap(i, j int)
&#125;</code></pre>

<p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用<code>sort.Sort</code>函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型<code>StringSlice</code>和它的<code>Len</code>,<code>Less</code>和<code>Swap</code>方法</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type StringSlice []string
func (p StringSlice) Len() int           &#123; return len(p) &#125;
func (p StringSlice) Less(i, j int) bool &#123; return p[i] &lt; p[j] &#125;
func (p StringSlice) Swap(i, j int)      &#123; p[i], p[j] &#x3D; p[j], p[i] &#125;</code></pre>

<p>现在我们可以通过像下面这样将一个切片转换为一个<code>StringSlice</code>类型来进行排序：<code>sort.Sort(StringSlice(names))</code>,这个转换得到一个相同长度，容量，和基于<code>names</code>数组的切片值;并且这个切片值的类型有三个排序需要的方法。</p>
<p>对字符串切片的排序是很常用的需要，所以<code>sort</code>包提供了<code>StringSlice</code>类型，也提供了<code>Strings</code>函数能让上面这些调用简化成<code>sort.Strings(names)</code></p>
<p>这里用到的技术很容易适用到其它排序序列中，例如我们可以忽略大小写或者含有的特殊字符。（本书使用Go程序对索引词和页码进行排序也用到了这个技术，对罗马数字做了额外逻辑处理。）对于更复杂的排序，我们使用相同的方法，但是会用更复杂的数据结构和更复杂地实现<code>sort.Interface</code>的方法。</p>
<p>我们会运行上面的例子来对一个表格中的音乐播放列表进行排序。每个track都是单独的一行，每一列都是这个track的属性像艺术家，标题，和运行时间。想象一个图形用户界面来呈现这个表格，并且点击一个属性的顶部会使这个列表按照这个属性进行排序；再一次点击相同属性的顶部会进行逆向排序。让我们看下每个点击会发生什么响应。</p>
<p>下面的变量tracks包含了一个播放列表.(One of the authors apologizes for the other author’s musical tastes)每个元素都不是Track本身而是指向它的指针。尽管我们在下面的代码中直接存储Tracks也可以工作，sort函数会交换很多对元素，所以如果每个元素都是指针而不是Track类型会更快，指针是一个机器字码长度而Track类型可能是八个或更多。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch7&#x2F;sorting


type Track struct &#123;
    Title  string
    Artist string
    Album  string
    Year   int
    Length time.Duration
&#125;

var tracks &#x3D; []*Track&#123;
    &#123;&quot;Go&quot;, &quot;Delilah&quot;, &quot;From the Roots Up&quot;, 2012, length(&quot;3m38s&quot;)&#125;,
    &#123;&quot;Go&quot;, &quot;Moby&quot;, &quot;Moby&quot;, 1992, length(&quot;3m37s&quot;)&#125;,
    &#123;&quot;Go Ahead&quot;, &quot;Alicia Keys&quot;, &quot;As I Am&quot;, 2007, length(&quot;4m36s&quot;)&#125;,
    &#123;&quot;Ready 2 Go&quot;, &quot;Martin Solveig&quot;, &quot;Smash&quot;, 2011, length(&quot;4m24s&quot;)&#125;,
&#125;

func length(s string) time.Duration &#123;
    d, err :&#x3D; time.ParseDuration(s)
    if err !&#x3D; nil &#123;
        panic(s)
    &#125;
    return d
&#125;</code></pre>

<p><code>printTracks</code>函数将播放列表打印成一个表格。一个图形化的展示可能会更好点，但是这个小程序使用<code>text/tabwriter</code>包来生成一个列整齐对齐和隔开的表格，像下面展示的这样。注意到<code>*tabwriter.Writer</code>是满足io.Writer接口的。它会收集每一片写向它的数据；它的Flush方法会格式化整个表格并且将它写向<code>os.Stdout</code>（标准输出）。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func printTracks(tracks []*Track) &#123;
    const format &#x3D; &quot;%v\t%v\t%v\t%v\t%v\t\n&quot;
    tw :&#x3D; new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, &#39; &#39;, 0)
    fmt.Fprintf(tw, format, &quot;Title&quot;, &quot;Artist&quot;, &quot;Album&quot;, &quot;Year&quot;, &quot;Length&quot;)
    fmt.Fprintf(tw, format, &quot;-----&quot;, &quot;------&quot;, &quot;-----&quot;, &quot;----&quot;, &quot;------&quot;)
    for _, t :&#x3D; range tracks &#123;
        fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)
    &#125;
    tw.Flush() &#x2F;&#x2F; calculate column widths and print table
&#125;</code></pre>

<p>为了能按照Artist字段对播放列表进行排序，我们会像对StringSlice那样定义一个新的带有必须的Len，Less和Swap方法的切片类型。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;装*Track的数组
type byArtist []*Track
func (x byArtist) Len() int           &#123; return len(x) &#125;
func (x byArtist) Less(i, j int) bool &#123; return x[i].Artist &lt; x[j].Artist &#125;
func (x byArtist) Swap(i, j int)      &#123; x[i], x[j] &#x3D; x[j], x[i] &#125;</code></pre>

<p>为了调用通用的排序程序，我们必须先将tracks转换为新的byArtist类型，它定义了具体的排序：<code>sort.Sort(byArtist(tracks))</code>(tracks和byArtist类型相同都是[]*Track)<br>在按照artist对这个切片进行排序后，printTrack的输出如下</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">Title       Artist          Album               Year Length
-----       ------          -----               ---- ------
Go Ahead    Alicia Keys     As I Am             2007 4m36s
Go          Delilah         From the Roots Up   2012 3m38s
Ready 2 Go  Martin Solveig  Smash               2011 4m24s
Go          Moby            Moby                1992 3m37s</code></pre>

<p>如果用户第二次请求”按照artist排序”,我们会对<code>tracks</code>进行逆向排序。然而我们不需要定义一个有颠倒<code>Less</code>方法的新类型<code>byReverseArtist</code>，因为sort包中提供了Reverse函数将排序顺序转换成逆序。<code>sort.Sort(sort.Reverse(byArtist(tracks)))</code>在按照artist对这个切片进行逆向排序后，printTrack的输出如下</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">Title       Artist          Album               Year Length
-----       ------          -----               ---- ------
Go          Moby            Moby                1992 3m37s
Ready 2 Go  Martin Solveig  Smash               2011 4m24s
Go          Delilah         From the Roots Up   2012 3m38s
Go Ahead    Alicia Keys     As I Am             2007 4m36s</code></pre>

<p><code>sort.Reverse</code>函数值得进行更近一步的学习，因为它使用了（§6.3）章中的组合，这是一个重要的思路。<code>sort</code>包定义了一个不公开的<code>struct</code>类型<code>reverse</code>，它嵌入了一个<code>sort.Interface</code>。<code>reverse</code>的<code>Less</code>方法调用了内嵌的<code>sort.Interface</code>值的<code>Less</code>方法，但是通过交换索引的方式使排序结果变成逆序。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package sort

type reverse struct&#123; Interface &#125; &#x2F;&#x2F; that is, sort.Interface

func (r reverse) Less(i, j int) bool &#123; return r.Interface.Less(j, i) &#125;

func Reverse(data Interface) Interface &#123; return reverse&#123;data&#125; &#125;</code></pre>

<p><code>reverse</code>的另外两个方法<code>Len</code>和<code>Swap</code>隐式地由原有内嵌的<code>sort.Interface</code>提供。因为<code>reverse</code>是一个不公开的类型，所以导出函数<code>Reverse</code>返回一个包含原有<code>sort.Interface</code>值的reverse类型实例。</p>
<p>为了可以按照不同的列进行排序，我们必须定义一个新的类型例如byYear:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type byYear []*Track
func (x byYear) Len() int           &#123; return len(x) &#125;
func (x byYear) Less(i, j int) bool &#123; return x[i].Year &lt; x[j].Year &#125;
func (x byYear) Swap(i, j int)      &#123; x[i], x[j] &#x3D; x[j], x[i] &#125;</code></pre>

<p>在使用<code>sort.Sort(byYear(tracks))</code>按照年对tracks进行排序后，printTrack展示了一个按时间先后顺序的列表：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">Title       Artist          Album               Year Length
-----       ------          -----               ---- ------
Go          Moby            Moby                1992 3m37s
Go Ahead    Alicia Keys     As I Am             2007 4m36s
Ready 2 Go  Martin Solveig  Smash               2011 4m24s
Go          Delilah         From the Roots Up   2012 3m38s</code></pre>

<p>对于我们需要的每个切片元素类型和每个排序函数，我们需要定义一个新的<code>sort.Interface</code>实现。如你所见，Len和Swap方法对于所有的切片类型都有相同的定义。下个例子，具体的类型customSort会将一个切片和函数结合，使我们只需要写比较函数就可以定义一个新的排序.顺便说下,实现了<code>sort.Interface</code>的具体类型不一定是切片类型；customSort是一个结构体类型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type customSort struct &#123;
    t    []*Track
    less func(x, y *Track) bool
&#125;

func (x customSort) Len() int           &#123; return len(x.t) &#125;
func (x customSort) Less(i, j int) bool &#123; return x.less(x.t[i], x.t[j]) &#125;
func (x customSort) Swap(i, j int) &#123; x.t[i], x.t[j] &#x3D; x.t[j], x.t[i] &#125;</code></pre>

<p>让我们定义一个多层的排序函数，它主要的排序键是标题，第二个键是年，第三个键是运行时间Length。下面是该排序的调用，其中这个排序使用了匿名排序函数：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">sort.Sort(customSort&#123;tracks, func(x, y *Track) bool &#123;
    if x.Title !&#x3D; y.Title &#123;
        return x.Title &lt; y.Title
    &#125;
    if x.Year !&#x3D; y.Year &#123;
        return x.Year &lt; y.Year
    &#125;
    if x.Length !&#x3D; y.Length &#123;
        return x.Length &lt; y.Length
    &#125;
    return false
&#125;&#125;)</code></pre>

<p>这下面是排序的结果。注意到两个标题是“Go”的track按照标题排序是相同的顺序，但是在按照year排序上更久的那个track优先。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
Title       Artist          Album               Year Length
-----       ------          -----               ---- ------
Go          Moby            Moby                1992 3m37s
Go          Delilah         From the Roots Up   2012 3m38s
Go Ahead    Alicia Keys     As I Am             2007 4m36s
Ready 2 Go  Martin Solveig  Smash               2011 4m24s</code></pre>

<p>尽管对长度为n的序列排序需要 O(n log n)次比较操作，检查一个序列是否已经有序至少需要n-1次比较。sort包中的<code>IsSorted</code>函数帮我们做这样的检查。像sort.Sort一样，它也使用sort.Interface对这个序列和它的排序函数进行抽象，但是它从不会调用Swap方法：这段代码示范了<code>IntsAreSorted</code>和<code>Ints</code>函数在IntSlice类型上的使用：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">values :&#x3D; []int&#123;3, 1, 4, 1&#125;
fmt.Println(sort.IntsAreSorted(values)) &#x2F;&#x2F; &quot;false&quot;
sort.Ints(values)
fmt.Println(values)                     &#x2F;&#x2F; &quot;[1 1 3 4]&quot;
fmt.Println(sort.IntsAreSorted(values)) &#x2F;&#x2F; &quot;true&quot;
sort.Sort(sort.Reverse(sort.IntSlice(values)))
fmt.Println(values)                     &#x2F;&#x2F; &quot;[4 3 1 1]&quot;
fmt.Println(sort.IntsAreSorted(values)) &#x2F;&#x2F; &quot;false&quot;</code></pre>

<p>为了使用方便，sort包为<code>[]int</code>、<code>[]string</code>和<code>[]float64</code>的正常排序提供了特定版本的函数和类型。对于其他类型，例如<code>[]int64</code>或者<code>[]uint</code>，尽管路径也很简单，还是依赖我们自己实现。</p>
<p>练习 7.8： 很多图形界面提供了一个有状态的多重排序表格插件：主要的排序键是最近一次点击过列头的列，第二个排序键是第二最近点击过列头的列，等等。定义一个sort.Interface的实现用在这样的表格中。比较这个实现方式和重复使用sort.Stable来排序的方式。</p>
<p>练习 7.9： 使用html&#x2F;template包（§4.6）替代printTracks将tracks展示成一个HTML表格。将这个解决方案用在前一个练习中，让每次点击一个列的头部产生一个HTTP请求来排序这个表格。</p>
<p>练习 7.10： sort.Interface类型也可以适用在其它地方。编写一个IsPalindrome(s sort.Interface) bool函数表明序列s是否是回文序列，换句话说反向排序不会改变这个序列。假设如果!s.Less(i, j) &amp;&amp; !s.Less(j, i)则索引i和j上的元素相等。</p>
<p>summary: </p>
<ol>
<li>对于字符串排序golang提供了<code>sort.Strings()</code>方法对字符串排序</li>
<li>更复杂的数据结构和更复杂地实现<code>sort.Interface</code>的方法,要实现less(x int,y int) bool,len() int,swap(x int,y int)方法</li>
<li>学习如何把信息输出到<code>stdout</code>通过实现writer接口</li>
<li>customSort是Track的自定义排序实现.避免针对不同排序,重复实现排序接口</li>
<li>sort包中isSorted功能,能够检查数据是否有序 - 要学习下sort和总结下sort包</li>
</ol>
<h2 id="7-7-http-Handler接口"><a href="#7-7-http-Handler接口" class="headerlink" title="7.7. http.Handler接口"></a>7.7. http.Handler接口</h2><p>在第一章中,我们粗略的了解了怎么用<code>net/http</code>包去实现网络客户端（§1.5）和服务器（§1.7）。在这个小节中，我们会对那些基于<code>http.Handler</code>接口的服务器API做更进一步的学习：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">net&#x2F;http
package http

type Handler interface &#123;
    ServeHTTP(w ResponseWriter, r *Request)
&#125;

func ListenAndServe(address string, h Handler) error</code></pre>

<p><code>ListenAndServe</code>函数需要一个例如’localhost:8000’的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。</p>
<p>想象一个电子商务网站，为了销售，将数据库中物品的价格映射成美元。下面这个程序可能是能想到的最简单的实现了。它将库存清单模型化为一个命名为database的map类型，我们给这个类型一个<code>ServeHttp</code>方法,这样它可以满足<code>http.Handler</code>接口。这个<code>handler</code>会遍历整个map并输出物品信息</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch7&#x2F;http1


func main() &#123;
    db :&#x3D; database&#123;&quot;shoes&quot;: 50, &quot;socks&quot;: 5&#125;
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, db))
&#125;

type dollars float32

func (d dollars) String() string &#123; return fmt.Sprintf(&quot;$%.2f&quot;, d) &#125;

type database map[string]dollars

func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;
    for item, price :&#x3D; range db &#123;
        fmt.Fprintf(w, &quot;%s: %s\n&quot;, item, price)
    &#125;
&#125;</code></pre>

<p>如果我们启动这个服务，</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">go build gopl.io&#x2F;ch7&#x2F;http1
.&#x2F;http1 &amp;</code></pre>

<p>然后用1.5节中的获取程序（如果你更喜欢可以使用web浏览器）来连接服务器，我们得到下面的输出：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000
shoes: $50.00
socks: $5.00</code></pre>

<p>目前为止，这个服务器不考虑URL，只能为每个请求列出它全部的库存清单。更真实的服务器会定义多个不同的URL，每一个都会触发一个不同的行为。让我们使用<code>/list</code>来调用已经存在的这个行为并且增加另一个<code>/price</code>调用表明单个货品的价格，像这样<code>/price?item=socks</code>来指定一个请求参数。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch7&#x2F;http2


func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;
    switch req.URL.Path &#123;
    case &quot;&#x2F;list&quot;:
        for item, price :&#x3D; range db &#123;
            fmt.Fprintf(w, &quot;%s: %s\n&quot;, item, price)
        &#125;
    case &quot;&#x2F;price&quot;:
        item :&#x3D; req.URL.Query().Get(&quot;item&quot;)
        price, ok :&#x3D; db[item]
        if !ok &#123;
            w.WriteHeader(http.StatusNotFound) &#x2F;&#x2F; 404
            fmt.Fprintf(w, &quot;no such item: %q\n&quot;, item)
            return
        &#125;
        fmt.Fprintf(w, &quot;%s\n&quot;, price)
    default:
        w.WriteHeader(http.StatusNotFound) &#x2F;&#x2F; 404
        fmt.Fprintf(w, &quot;no such page: %s\n&quot;, req.URL)
    &#125;
&#125;</code></pre>

<p>现在handler基于URL的路径部分(req.URL.Path)来决定执行什么逻辑。如果这个handler不能识别这个路径，它会通过调用w.WriteHeader(http.StatusNotFound)返回客户端一个HTTP错误；这个检查应该在向w写入任何值前完成。（顺便提一下，http.ResponseWriter是另一个接口。它在io.Writer上增加了发送HTTP相应头的方法。）等效地，我们可以使用实用的http.Error函数：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">msg :&#x3D; fmt.Sprintf(&quot;no such page: %s\n&quot;, req.URL)
http.Error(w, msg, http.StatusNotFound) &#x2F;&#x2F; 404</code></pre>

<p><code>/price</code>的case会调用URL的Query方法来将HTTP请求参数解析为一个map，或者更准确地说一个<code>net/url</code>包中<code>url.Values</code>(§6.2.1)类型的多重映射。然后找到第一个item参数并查找它的价格。如果这个货品没有找到会返回一个错误。</p>
<p>这里是一个和新服务器会话的例子：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go build gopl.io&#x2F;ch7&#x2F;http2
$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ .&#x2F;http2 &amp;
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;list
shoes: $50.00
socks: $5.00
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;socks
$5.00
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;shoes
$50.00
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;hat
no such item: &quot;hat&quot;
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;help
no such page: &#x2F;help</code></pre>

<p>显然我们可以继续向ServeHTTP方法中添加case，但在一个实际的应用中，将每个case中的逻辑定义到一个分开的方法或函数中会很实用。此外，相近的URL可能需要相似的逻辑；例如几个图片文件可能有形如&#x2F;images&#x2F;*.png的URL。因为这些原因，net&#x2F;http包提供了一个请求多路器ServeMux来简化URL和handlers的联系。一个ServeMux将一批http.Handler聚集到一个单一的http.Handler中。再一次，我们可以看到满足同一接口的不同类型是可替换的：web服务器将请求指派给任意的http.Handler 而不需要考虑它后面的具体类型。</p>
<p>对于更复杂的应用，一些ServeMux可以通过组合来处理更加错综复杂的路由需求。Go语言目前没有一个权威的web框架，就像Ruby语言有Rails和python有Django。这并不是说这样的框架不存在，而是Go语言标准库中的构建模块就已经非常灵活以至于这些框架都是不必要的。此外，尽管在一个项目早期使用框架是非常方便的，但是它们带来额外的复杂度会使长期的维护更加困难。</p>
<p>在下面的程序中，我们创建一个ServeMux并且使用它将URL和相应处理&#x2F;list和&#x2F;price操作的handler联系起来，这些操作逻辑都已经被分到不同的方法中。然后我们在调用ListenAndServe函数中使用ServeMux为主要的handler。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch7&#x2F;http3


func main() &#123;
    db :&#x3D; database&#123;&quot;shoes&quot;: 50, &quot;socks&quot;: 5&#125;
    mux :&#x3D; http.NewServeMux()
    mux.Handle(&quot;&#x2F;list&quot;, http.HandlerFunc(db.list))
    mux.Handle(&quot;&#x2F;price&quot;, http.HandlerFunc(db.price))
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, mux))
&#125;

type database map[string]dollars

func (db database) list(w http.ResponseWriter, req *http.Request) &#123;
    for item, price :&#x3D; range db &#123;
        fmt.Fprintf(w, &quot;%s: %s\n&quot;, item, price)
    &#125;
&#125;

func (db database) price(w http.ResponseWriter, req *http.Request) &#123;
    item :&#x3D; req.URL.Query().Get(&quot;item&quot;)
    price, ok :&#x3D; db[item]
    if !ok &#123;
        w.WriteHeader(http.StatusNotFound) &#x2F;&#x2F; 404
        fmt.Fprintf(w, &quot;no such item: %q\n&quot;, item)
        return
    &#125;
    fmt.Fprintf(w, &quot;%s\n&quot;, price)
&#125;</code></pre>

<p>让我们关注这两个注册到handlers上的调用。第一个db.list是一个方法值（§6.4），它是下面这个类型的值。</p>
<p>func(w http.ResponseWriter, req *http.Request)<br>也就是说db.list的调用会援引一个接收者是db的database.list方法。所以db.list是一个实现了handler类似行为的函数，但是因为它没有方法（理解：该方法没有它自己的方法），所以它不满足http.Handler接口并且不能直接传给mux.Handle。</p>
<p>语句http.HandlerFunc(db.list)是一个转换而非一个函数调用，因为http.HandlerFunc是一个类型。它有如下的定义：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">net&#x2F;http


package http

type HandlerFunc func(w ResponseWriter, r *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) &#123;
    f(w, r)
&#125;</code></pre>

<p>HandlerFunc显示了在Go语言接口机制中一些不同寻常的特点。这是一个实现了接口http.Handler的方法的函数类型。ServeHTTP方法的行为是调用了它的函数本身。因此HandlerFunc是一个让函数值满足一个接口的适配器，这里函数和这个接口仅有的方法有相同的函数签名。实际上，这个技巧让一个单一的类型例如database以多种方式满足http.Handler接口：一种通过它的list方法，一种通过它的price方法等等。</p>
<p>因为handler通过这种方式注册非常普遍，ServeMux有一个方便的HandleFunc方法，它帮我们简化handler注册代码成这样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
gopl.io&#x2F;ch7&#x2F;http3a

mux.HandleFunc(&quot;&#x2F;list&quot;, db.list)
mux.HandleFunc(&quot;&#x2F;price&quot;, db.price)</code></pre>

<p>从上面的代码很容易看出应该怎么构建一个程序：由两个不同的web服务器监听不同的端口，并且定义不同的URL将它们指派到不同的handler。我们只要构建另外一个ServeMux并且再调用一次<code>ListenAndServe</code>（可能并行的）。但是在大多数程序中，一个web服务器就足够了。此外，在一个应用程序的多个文件中定义<code>HTTP handler</code>也是非常典型的，如果它们必须全部都显式地注册到这个应用的<code>ServeMux</code>实例上会比较麻烦。</p>
<p>所以为了方便，<code>net/http</code>包提供了一个全局的<code>ServeMux</code>实例<code>DefaultServerMux</code>和包级别的<code>http.Handle</code>和<code>http.HandleFunc</code>函数。现在，为了使用<code>DefaultServeMux</code>作为服务器的主<code>handler</code>，我们不需要将它传给<code>ListenAndServe</code>函数;nil值就可以工作。</p>
<p>然后服务器的主函数可以简化成：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch7&#x2F;http4

func main() &#123;
    db :&#x3D; database&#123;&quot;shoes&quot;: 50, &quot;socks&quot;: 5&#125;
    http.HandleFunc(&quot;&#x2F;list&quot;, db.list)
    http.HandleFunc(&quot;&#x2F;price&quot;, db.price)
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))
&#125;</code></pre>

<p>最后，一个重要的提示：就像我们在1.7节中提到的，web服务器在一个新的协程中调用每一个handler，所以当handler获取其它协程或者这个handler本身的其它请求也可以访问到变量时，一定要使用预防措施，比如锁机制。我们后面的两章中将讲到并发相关的知识。</p>
<p>练习 7.11： 增加额外的handler让客户端可以创建，读取，更新和删除数据库记录。例如，一个形如 &#x2F;update?item&#x3D;socks&amp;price&#x3D;6 的请求会更新库存清单里一个货品的价格并且当这个货品不存在或价格无效时返回一个错误值。（注意：这个修改会引入变量同时更新的问题）</p>
<p>练习 7.12： 修改&#x2F;list的handler让它把输出打印成一个HTML的表格而不是文本。html&#x2F;template包（§4.6）可能会对你有帮助。</p>
<h2 id="7-8-error接口"><a href="#7-8-error接口" class="headerlink" title="7.8. error接口"></a>7.8. error接口</h2><p>从本书的开始，我们就已经创建和使用过神秘的预定义error类型，而且没有解释它究竟是什么。实际上它就是interface类型，这个类型有一个返回错误信息的单一方法：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type error interface &#123;
    Error() string
&#125;</code></pre>

<p>创建一个error最简单的方法就是调用errors.New函数，它会根据传入的错误信息返回一个新的error。整个errors包仅只有4行：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package errors

func New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125;

type errorString struct &#123; text string &#125;

func (e *errorString) Error() string &#123; return e.text &#125;</code></pre>

<p>承载errorString的类型是一个结构体而非一个字符串，这是为了保护它表示的错误避免粗心（或有意）的更新。并且因为是指针类型*errorString满足error接口而非errorString类型，所以每个New函数的调用都分配了一个独特的和其他错误不相同的实例。我们也不想要重要的error例如io.EOF和一个刚好有相同错误消息的error比较后相等。</p>
<p><code>fmt.Println(errors.New(&quot;EOF&quot;) == errors.New(&quot;EOF&quot;)) // &quot;false&quot;</code><br>调用<code>errors.New</code>函数是非常稀少的，因为有一个方便的封装函数fmt.Errorf，它还会处理字符串格式化。我们曾多次在第5章中用到它。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package fmt

import &quot;errors&quot;

func Errorf(format string, args ...interface&#123;&#125;) error &#123;
    return errors.New(Sprintf(format, args...))
&#125;</code></pre>

<p>虽然*errorString可能是最简单的错误类型，但远非只有它一个。例如，syscall包提供了Go语言底层系统调用API。在多个平台上，它定义一个实现error接口的数字类型Errno，并且在Unix平台上，Errno的Error方法会从一个字符串表中查找错误消息，如下面展示的这样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package syscall

type Errno uintptr &#x2F;&#x2F; operating system error code

var errors &#x3D; [...]string&#123;
    1:   &quot;operation not permitted&quot;,   &#x2F;&#x2F; EPERM
    2:   &quot;no such file or directory&quot;, &#x2F;&#x2F; ENOENT
    3:   &quot;no such process&quot;,           &#x2F;&#x2F; ESRCH
    &#x2F;&#x2F; ...
&#125;

func (e Errno) Error() string &#123;
    if 0 &lt;&#x3D; int(e) &amp;&amp; int(e) &lt; len(errors) &#123;
        return errors[e]
    &#125;
    return fmt.Sprintf(&quot;errno %d&quot;, e)
&#125;</code></pre>

<p>下面的语句创建了一个持有Errno值为2的接口值，表示POSIX ENOENT状况：</p>
<p>var err error &#x3D; syscall.Errno(2)<br>fmt.Println(err.Error()) &#x2F;&#x2F; “no such file or directory”<br>fmt.Println(err)         &#x2F;&#x2F; “no such file or directory”<br>err的值图形化的呈现在图7.6中。</p>
<p>Errno是一个系统调用错误的高效表示方式，它通过一个有限的集合进行描述，并且它满足标准的错误接口。我们会在第7.11节了解到其它满足这个接口的类型。</p>
<h2 id="7-9-示例-表达式求值"><a href="#7-9-示例-表达式求值" class="headerlink" title="7.9 示例-表达式求值"></a>7.9 示例-表达式求值</h2><p>在本节中，我们会构建一个简单算术表达式的求值器。我们将使用一个接口Expr来表示Go语言中任意的表达式。现在这个接口不需要有方法，但是我们后面会为它增加一些。</p>
<p>&#x2F;&#x2F; An Expr is an arithmetic expression.<br>type Expr interface{}<br>我们的表达式语言包括浮点数符号（小数点）；二元操作符+，-，*， 和&#x2F;；一元操作符-x和+x；调用pow(x,y)，sin(x)，和sqrt(x)的函数；例如x和pi的变量；当然也有括号和标准的优先级运算符。所有的值都是float64类型。这下面是一些表达式的例子：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">sqrt(A &#x2F; pi)
pow(x, 3) + pow(y, 3)
(F - 32) * 5 &#x2F; 9</code></pre>

<p>下面的五个具体类型表示了具体的表达式类型。Var类型表示对一个变量的引用。（我们很快会知道为什么它可以被输出。）literal类型表示一个浮点型常量。unary和binary类型表示有一到两个运算对象的运算符表达式，这些操作数可以是任意的Expr类型。call类型表示对一个函数的调用；我们限制它的fn字段只能是pow，sin或者sqrt。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch7&#x2F;eval


&#x2F;&#x2F; A Var identifies a variable, e.g., x.
type Var string

&#x2F;&#x2F; A literal is a numeric constant, e.g., 3.141.
type literal float64

&#x2F;&#x2F; A unary represents a unary operator expression, e.g., -x.
type unary struct &#123;
    op rune &#x2F;&#x2F; one of &#39;+&#39;, &#39;-&#39;
    x  Expr
&#125;

&#x2F;&#x2F; A binary represents a binary operator expression, e.g., x+y.
type binary struct &#123;
    op   rune &#x2F;&#x2F; one of &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;
    x, y Expr
&#125;

&#x2F;&#x2F; A call represents a function call expression, e.g., sin(x).
type call struct &#123;
    fn   string &#x2F;&#x2F; one of &quot;pow&quot;, &quot;sin&quot;, &quot;sqrt&quot;
    args []Expr
&#125;</code></pre>

<p>为了计算一个包含变量的表达式，我们需要一个environment变量将变量的名字映射成对应的值：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Env map[Var]float64</code></pre>

<p>我们也需要每个表达式去定义一个Eval方法，这个方法会根据给定的environment变量返回表达式的值。因为每个表达式都必须提供这个方法，我们将它加入到Expr接口中。这个包只会对外公开Expr，Env，和Var类型。调用方不需要获取其它的表达式类型就可以使用这个求值器。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Expr interface &#123;
    &#x2F;&#x2F; Eval returns the value of this Expr in the environment env.
    Eval(env Env) float64
&#125;</code></pre>

<p>下面给大家展示一个具体的Eval方法。Var类型的这个方法对一个environment变量进行查找，如果这个变量没有在environment中定义过这个方法会返回一个零值，literal类型的这个方法简单的返回它真实的值。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func (v Var) Eval(env Env) float64 &#123;
    return env[v]
&#125;

func (l literal) Eval(_ Env) float64 &#123;
    return float64(l)
&#125;</code></pre>

<p>unary和binary的Eval方法会递归的计算它的运算对象，然后将运算符op作用到它们上。我们不将被零或无穷数除作为一个错误，因为它们都会产生一个固定的结果——无限。最后，call的这个方法会计算对于pow，sin，或者sqrt函数的参数值，然后调用对应在math包中的函数。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func (u unary) Eval(env Env) float64 &#123;
    switch u.op &#123;
    case &#39;+&#39;:
        return +u.x.Eval(env)
    case &#39;-&#39;:
        return -u.x.Eval(env)
    &#125;
    panic(fmt.Sprintf(&quot;unsupported unary operator: %q&quot;, u.op))
&#125;

func (b binary) Eval(env Env) float64 &#123;
    switch b.op &#123;
    case &#39;+&#39;:
        return b.x.Eval(env) + b.y.Eval(env)
    case &#39;-&#39;:
        return b.x.Eval(env) - b.y.Eval(env)
    case &#39;*&#39;:
        return b.x.Eval(env) * b.y.Eval(env)
    case &#39;&#x2F;&#39;:
        return b.x.Eval(env) &#x2F; b.y.Eval(env)
    &#125;
    panic(fmt.Sprintf(&quot;unsupported binary operator: %q&quot;, b.op))
&#125;

func (c call) Eval(env Env) float64 &#123;
    switch c.fn &#123;
    case &quot;pow&quot;:
        return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env))
    case &quot;sin&quot;:
        return math.Sin(c.args[0].Eval(env))
    case &quot;sqrt&quot;:
        return math.Sqrt(c.args[0].Eval(env))
    &#125;
    panic(fmt.Sprintf(&quot;unsupported function call: %s&quot;, c.fn))
&#125;</code></pre>

<p>一些方法会失败。例如，一个call表达式可能有未知的函数或者错误的参数个数。用一个无效的运算符如!或者&lt;去构建一个unary或者binary表达式也是可能会发生的（尽管下面提到的Parse函数不会这样做）。这些错误会让Eval方法panic。其它的错误，像计算一个没有在environment变量中出现过的Var，只会让Eval方法返回一个错误的结果。所有的这些错误都可以通过在计算前检查Expr来发现。这是我们接下来要讲的Check方法的工作，但是让我们先测试Eval方法。</p>
<p>下面的TestEval函数是对evaluator的一个测试。它使用了我们会在第11章讲解的testing包，但是现在知道调用t.Errof会报告一个错误就足够了。这个函数循环遍历一个表格中的输入，这个表格中定义了三个表达式和针对每个表达式不同的环境变量。第一个表达式根据给定圆的面积A计算它的半径，第二个表达式通过两个变量x和y计算两个立方体的体积之和，第三个表达式将华氏温度F转换成摄氏度。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func TestEval(t *testing.T) &#123;
    tests :&#x3D; []struct &#123;
        expr string
        env  Env
        want string
    &#125;&#123;
        &#123;&quot;sqrt(A &#x2F; pi)&quot;, Env&#123;&quot;A&quot;: 87616, &quot;pi&quot;: math.Pi&#125;, &quot;167&quot;&#125;,
        &#123;&quot;pow(x, 3) + pow(y, 3)&quot;, Env&#123;&quot;x&quot;: 12, &quot;y&quot;: 1&#125;, &quot;1729&quot;&#125;,
        &#123;&quot;pow(x, 3) + pow(y, 3)&quot;, Env&#123;&quot;x&quot;: 9, &quot;y&quot;: 10&#125;, &quot;1729&quot;&#125;,
        &#123;&quot;5 &#x2F; 9 * (F - 32)&quot;, Env&#123;&quot;F&quot;: -40&#125;, &quot;-40&quot;&#125;,
        &#123;&quot;5 &#x2F; 9 * (F - 32)&quot;, Env&#123;&quot;F&quot;: 32&#125;, &quot;0&quot;&#125;,
        &#123;&quot;5 &#x2F; 9 * (F - 32)&quot;, Env&#123;&quot;F&quot;: 212&#125;, &quot;100&quot;&#125;,
    &#125;
    var prevExpr string
    for _, test :&#x3D; range tests &#123;
        &#x2F;&#x2F; Print expr only when it changes.
        if test.expr !&#x3D; prevExpr &#123;
            fmt.Printf(&quot;\n%s\n&quot;, test.expr)
            prevExpr &#x3D; test.expr
        &#125;
        expr, err :&#x3D; Parse(test.expr)
        if err !&#x3D; nil &#123;
            t.Error(err) &#x2F;&#x2F; parse error
            continue
        &#125;
        got :&#x3D; fmt.Sprintf(&quot;%.6g&quot;, expr.Eval(test.env))
        fmt.Printf(&quot;\t%v &#x3D;&gt; %s\n&quot;, test.env, got)
        if got !&#x3D; test.want &#123;
            t.Errorf(&quot;%s.Eval() in %v &#x3D; %q, want %q\n&quot;,
            test.expr, test.env, got, test.want)
        &#125;
    &#125;
&#125;</code></pre>

<p>对于表格中的每一条记录，这个测试会解析它的表达式然后在环境变量中计算它，输出结果。这里我们没有空间来展示Parse函数，但是如果你使用go get下载这个包你就可以看到这个函数。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">go test(§11.1) 命令会运行一个包的测试用例：
$ go test -v gopl.io&#x2F;ch7&#x2F;eval</code></pre>

<p>这个<code>-v</code>标识可以让我们看到测试用例打印的输出；正常情况下像这样一个成功的测试用例会阻止打印结果的输出。这里是测试用例里fmt.Printf语句的输出：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">sqrt(A &#x2F; pi)
    map[A:87616 pi:3.141592653589793] &#x3D;&gt; 167

pow(x, 3) + pow(y, 3)
    map[x:12 y:1] &#x3D;&gt; 1729
    map[x:9 y:10] &#x3D;&gt; 1729

5 &#x2F; 9 * (F - 32)
    map[F:-40] &#x3D;&gt; -40
    map[F:32] &#x3D;&gt; 0
    map[F:212] &#x3D;&gt; 100</code></pre>

<p>幸运的是目前为止所有的输入都是适合的格式，但是我们的运气不可能一直都有。甚至在解释型语言中，为了静态错误检查语法是非常常见的；静态错误就是不用运行程序就可以检测出来的错误。通过将静态检查和动态的部分分开，我们可以快速的检查错误并且对于多次检查只执行一次而不是每次表达式计算的时候都进行检查。</p>
<p>让我们往Expr接口中增加另一个方法。Check方法对一个表达式语义树检查出静态错误。我们马上会说明它的vars参数。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type Expr interface &#123;
    Eval(env Env) float64
    &#x2F;&#x2F; Check reports errors in this Expr and adds its Vars to the set.
    Check(vars map[Var]bool) error
&#125;</code></pre>

<p>具体的Check方法展示在下面。literal和Var类型的计算不可能失败，所以这些类型的Check方法会返回一个nil值。对于unary和binary的Check方法会首先检查操作符是否有效，然后递归的检查运算单元。相似地对于call的这个方法首先检查调用的函数是否已知并且有没有正确个数的参数，然后递归的检查每一个参数。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func (v Var) Check(vars map[Var]bool) error &#123;
    vars[v] &#x3D; true
    return nil
&#125;

func (literal) Check(vars map[Var]bool) error &#123;
    return nil
&#125;

func (u unary) Check(vars map[Var]bool) error &#123;
    if !strings.ContainsRune(&quot;+-&quot;, u.op) &#123;
        return fmt.Errorf(&quot;unexpected unary op %q&quot;, u.op)
    &#125;
    return u.x.Check(vars)
&#125;

func (b binary) Check(vars map[Var]bool) error &#123;
    if !strings.ContainsRune(&quot;+-*&#x2F;&quot;, b.op) &#123;
        return fmt.Errorf(&quot;unexpected binary op %q&quot;, b.op)
    &#125;
    if err :&#x3D; b.x.Check(vars); err !&#x3D; nil &#123;
        return err
    &#125;
    return b.y.Check(vars)
&#125;

func (c call) Check(vars map[Var]bool) error &#123;
    arity, ok :&#x3D; numParams[c.fn]
    if !ok &#123;
        return fmt.Errorf(&quot;unknown function %q&quot;, c.fn)
    &#125;
    if len(c.args) !&#x3D; arity &#123;
        return fmt.Errorf(&quot;call to %s has %d args, want %d&quot;,
            c.fn, len(c.args), arity)
    &#125;
    for _, arg :&#x3D; range c.args &#123;
        if err :&#x3D; arg.Check(vars); err !&#x3D; nil &#123;
            return err
        &#125;
    &#125;
    return nil
&#125;

var numParams &#x3D; map[string]int&#123;&quot;pow&quot;: 2, &quot;sin&quot;: 1, &quot;sqrt&quot;: 1&#125;</code></pre>

<p>我们在两个组中有选择地列出有问题的输入和它们得出的错误。Parse函数（这里没有出现）会报出一个语法错误和Check函数会报出语义错误。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">x % 2               unexpected &#39;%&#39;
math.Pi             unexpected &#39;.&#39;
!true               unexpected &#39;!&#39;
&quot;hello&quot;             unexpected &#39;&quot;&#39;

log(10)             unknown function &quot;log&quot;
sqrt(1, 2)          call to sqrt has 2 args, want 1</code></pre>

<p>Check方法的参数是一个Var类型的集合，这个集合聚集从表达式中找到的变量名。为了保证成功的计算，这些变量中的每一个都必须出现在环境变量中。从逻辑上讲，这个集合就是调用Check方法返回的结果，但是因为这个方法是递归调用的，所以对于Check方法，填充结果到一个作为参数传入的集合中会更加的方便。调用方在初始调用时必须提供一个空的集合。</p>
<p>在第3.2节中，我们绘制了一个在编译期才确定的函数f(x,y)。现在我们可以解析，检查和计算在字符串中的表达式，我们可以构建一个在运行时从客户端接收表达式的web应用并且它会绘制这个函数的表示的曲面。我们可以使用集合vars来检查表达式是否是一个只有两个变量x和y的函数——实际上是3个，因为我们为了方便会提供半径大小r。并且我们会在计算前使用Check方法拒绝有格式问题的表达式，这样我们就不会在下面函数的40000个计算过程（100x100个栅格，每一个有4个角）重复这些检查。</p>
<p>这个ParseAndCheck函数混合了解析和检查步骤的过程：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch7&#x2F;surface


import &quot;gopl.io&#x2F;ch7&#x2F;eval&quot;

func parseAndCheck(s string) (eval.Expr, error) &#123;
    if s &#x3D;&#x3D; &quot;&quot; &#123;
        return nil, fmt.Errorf(&quot;empty expression&quot;)
    &#125;
    expr, err :&#x3D; eval.Parse(s)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;
    vars :&#x3D; make(map[eval.Var]bool)
    if err :&#x3D; expr.Check(vars); err !&#x3D; nil &#123;
        return nil, err
    &#125;
    for v :&#x3D; range vars &#123;
        if v !&#x3D; &quot;x&quot; &amp;&amp; v !&#x3D; &quot;y&quot; &amp;&amp; v !&#x3D; &quot;r&quot; &#123;
            return nil, fmt.Errorf(&quot;undefined variable: %s&quot;, v)
        &#125;
    &#125;
    return expr, nil
&#125;</code></pre>

<p>为了编写这个web应用，所有我们需要做的就是下面这个plot函数，这个函数有和http.HandlerFunc相似的签名：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func plot(w http.ResponseWriter, r *http.Request) &#123;
    r.ParseForm()
    expr, err :&#x3D; parseAndCheck(r.Form.Get(&quot;expr&quot;))
    if err !&#x3D; nil &#123;
        http.Error(w, &quot;bad expr: &quot;+err.Error(), http.StatusBadRequest)
        return
    &#125;
    w.Header().Set(&quot;Content-Type&quot;, &quot;image&#x2F;svg+xml&quot;)
    surface(w, func(x, y float64) float64 &#123;
        r :&#x3D; math.Hypot(x, y) &#x2F;&#x2F; distance from (0,0)
        return expr.Eval(eval.Env&#123;&quot;x&quot;: x, &quot;y&quot;: y, &quot;r&quot;: r&#125;)
    &#125;)
&#125;
</code></pre>

<p>这个plot函数解析和检查在HTTP请求中指定的表达式并且用它来创建一个两个变量的匿名函数。这个匿名函数和来自原来surface-plotting程序中的固定函数f有相同的签名，但是它计算一个用户提供的表达式。环境变量中定义了x，y和半径r。最后plot调用surface函数，它就是gopl.io&#x2F;ch3&#x2F;surface中的主要函数，修改后它可以接受plot中的函数和输出io.Writer作为参数，而不是使用固定的函数f和os.Stdout。图7.7中显示了通过程序产生的3个曲面。</p>
<p>练习7.13为Expr增加一个String方法来打印美观的语法树。当再一次解析的时候，检查它的结果是否生成相同的语法树</p>
<p>练习7.14定义一个新的满足Expr接口的具体类型并且提供一个新的操作例如对它运算单元中的最小值的计算。因为Parse函数不会创建这个新类型的实例，为了使用它你可能需要直接构造一个语法树(或者继承parser接口)</p>
<p>练习7.15编写一个从标准输入中读取一个单一表达式的程序，用户及时地提供对于任意变量的值，然后在结果环境变量中计算表达式的值。优雅的处理所有遇到的错误</p>
<p>练习7.16编写一个基于web的计算器程序。</p>
<h2 id="7-10-类型断言"><a href="#7-10-类型断言" class="headerlink" title="7.10. 类型断言"></a>7.10. 类型断言</h2><p>类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</p>
<p>这里有两种可能。第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。例如：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer
w &#x3D; os.Stdout
f :&#x3D; w.(*os.File)      &#x2F;&#x2F; success: f &#x3D;&#x3D; os.Stdout
c :&#x3D; w.(*bytes.Buffer) &#x2F;&#x2F; panic: interface holds *os.File, not *bytes.Buffer</code></pre>
<p>第二种，如果相反地断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。</p>
<p>在下面的第一个类型断言后，w和rw都持有os.Stdout，因此它们都有一个动态类型*os.File，但是变量w是一个io.Writer类型，只对外公开了文件的Write方法，而rw变量还公开了它的Read方法。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer
w &#x3D; os.Stdout
rw :&#x3D; w.(io.ReadWriter) &#x2F;&#x2F; success: *os.File has both Read and Write
w &#x3D; new(ByteCounter)
rw &#x3D; w.(io.ReadWriter) &#x2F;&#x2F; panic: *ByteCounter has no Read method</code></pre>
<p>如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">w &#x3D; rw             &#x2F;&#x2F; io.ReadWriter is assignable to io.Writer
w &#x3D; rw.(io.Writer) &#x2F;&#x2F; fails only if rw &#x3D;&#x3D; nil</code></pre>
<p>经常地，对一个接口值的动态类型我们是不确定的，并且我们更愿意去检验它是否是一些特定的类型。如果类型断言出现在一个预期有两个结果的赋值操作中，例如如下的定义，这个操作不会在失败的时候发生panic，但是替代地返回一个额外的第二个结果，这个结果是一个标识成功与否的布尔值：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var w io.Writer &#x3D; os.Stdout
f, ok :&#x3D; w.(*os.File)      &#x2F;&#x2F; success:  ok, f &#x3D;&#x3D; os.Stdout
b, ok :&#x3D; w.(*bytes.Buffer) &#x2F;&#x2F; failure: !ok, b &#x3D;&#x3D; nil</code></pre>
<p>第二个结果通常赋值给一个命名为ok的变量。如果这个操作失败了，那么ok就是false值，第一个结果等于被断言类型的零值，在这个例子中就是一个nil的*bytes.Buffer类型。</p>
<p>这个ok结果经常立即用于决定程序下面做什么。if语句的扩展格式让这个变的很简洁：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if f, ok :&#x3D; w.(*os.File); ok &#123;
    &#x2F;&#x2F; ...use f...
&#125;</code></pre>

<p>当类型断言的操作对象是一个变量，你有时会看见原来的变量名重用而不是声明一个新的本地变量名，这个重用的变量原来的值会被覆盖（理解：其实是声明了一个同名的新的本地变量，外层原来的w不会被改变），如下面这样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">if w, ok :&#x3D; w.(*os.File); ok &#123;
    &#x2F;&#x2F; ...use w...
&#125;</code></pre>

<h2 id="7-11-基于类型断言区别错误类型"><a href="#7-11-基于类型断言区别错误类型" class="headerlink" title="7.11. 基于类型断言区别错误类型"></a>7.11. 基于类型断言区别错误类型</h2><p>对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。</p>
<p>一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">

package main

import (
 &quot;errors&quot;
 &quot;fmt&quot;
 &quot;os&quot;
 &quot;syscall&quot;
)

type PathError struct &#123;
 Op   string
 Path string
 Err  error
&#125;

func (e *PathError) Error() string &#123;
 return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()
&#125;

var ErrNotExist &#x3D; errors.New(&quot;file does not exist&quot;)

&#x2F;&#x2F; IsNotExist returns a boolean indicating whether the error is known to
&#x2F;&#x2F; report that a file or directory does not exist. It is satisfied by
&#x2F;&#x2F; ErrNotExist as well as some syscall errors.
func IsNotExist(err error) bool &#123;
 if pe, ok :&#x3D; err.(*PathError); ok &#123;
  err &#x3D; pe.Err
 &#125;
 return err &#x3D;&#x3D; syscall.ENOENT || err &#x3D;&#x3D; ErrNotExist
&#125;

func main() &#123;
 _, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)
 fmt.Println(os.IsNotExist(err)) &#x2F;&#x2F; &quot;true&quot;
&#125;</code></pre>

<h2 id="7-11-基于类型断言区别错误类型-1"><a href="#7-11-基于类型断言区别错误类型-1" class="headerlink" title="7.11. 基于类型断言区别错误类型"></a>7.11. 基于类型断言区别错误类型</h2><p>思考在os包中文件操作返回的错误集合。I&#x2F;O可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文件已经存在（对于创建操作），找不到文件（对于读取操作），和权限拒绝。os包中提供了三个帮助函数来对给定的错误值表示的失败进行分类：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package os

func IsExist(err error) bool
func IsNotExist(err error) bool
func IsPermission(err error) bool</code></pre>
<p>对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func IsNotExist(err error) bool &#123;
    &#x2F;&#x2F; NOTE: not robust!
    return strings.Contains(err.Error(), &quot;file does not exist&quot;)
&#125;</code></pre>
<p>但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。</p>
<p>一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package os

&#x2F;&#x2F; PathError records an error and the operation and file path that caused it.
type PathError struct &#123;
    Op   string
    Path string
    Err  error
&#125;

func (e *PathError) Error() string &#123;
    return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()
&#125;</code></pre>
<p>大多数调用方都不知道PathError并且通过调用错误本身的Error方法来统一处理所有的错误。尽管PathError的Error方法简单地把这些字段连接起来生成错误消息，PathError的结构保护了内部的错误组件。调用方需要使用类型断言来检测错误的具体类型以便将一种失败和另一种区分开；具体的类型可以比字符串提供更多的细节。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">_, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)
fmt.Println(err) &#x2F;&#x2F; &quot;open &#x2F;no&#x2F;such&#x2F;file: No such file or directory&quot;
fmt.Printf(&quot;%#v\n&quot;, err)
&#x2F;&#x2F; Output:
&#x2F;&#x2F; &amp;os.PathError&#123;Op:&quot;open&quot;, Path:&quot;&#x2F;no&#x2F;such&#x2F;file&quot;, Err:0x2&#125;</code></pre>
<p>这就是三个帮助函数是怎么工作的。例如下面展示的IsNotExist，它会报出是否一个错误和syscall.ENOENT（§7.8）或者和有名的错误os.ErrNotExist相等（可以在§5.4.2中找到io.EOF）；或者是一个*PathError，它内部的错误是syscall.ENOENT和os.ErrNotExist其中之一。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
import (
    &quot;errors&quot;
    &quot;syscall&quot;
)

var ErrNotExist &#x3D; errors.New(&quot;file does not exist&quot;)

&#x2F;&#x2F; IsNotExist returns a boolean indicating whether the error is known to
&#x2F;&#x2F; report that a file or directory does not exist. It is satisfied by
&#x2F;&#x2F; ErrNotExist as well as some syscall errors.
func IsNotExist(err error) bool &#123;
    if pe, ok :&#x3D; err.(*PathError); ok &#123;
        err &#x3D; pe.Err
    &#125;
    return err &#x3D;&#x3D; syscall.ENOENT || err &#x3D;&#x3D; ErrNotExist
&#125;</code></pre>
<p>下面这里是它的实际使用：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">_, err :&#x3D; os.Open(&quot;&#x2F;no&#x2F;such&#x2F;file&quot;)
fmt.Println(os.IsNotExist(err)) &#x2F;&#x2F; &quot;true&quot;</code></pre>

<p>如果错误消息结合成一个更大的字符串，当然PathError的结构就不再为人所知，例如通过一个对fmt.Errorf函数的调用。区别错误通常必须在失败操作后，错误传回调用者前进行。</p>
<h2 id="7-12-通过类型断言询问行为"><a href="#7-12-通过类型断言询问行为" class="headerlink" title="7.12. 通过类型断言询问行为"></a>7.12. 通过类型断言询问行为</h2><p>下面这段逻辑和net&#x2F;http包中web服务器负责写入HTTP头字段（例如：”Content-type:text&#x2F;html”）的部分相似。io.Writer接口类型的变量w代表HTTP响应；写入它的字节最终被发送到某个人的web浏览器上。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func writeHeader(w io.Writer, contentType string) error &#123;
    if _, err :&#x3D; w.Write([]byte(&quot;Content-Type: &quot;)); err !&#x3D; nil &#123;
        return err
    &#125;
    if _, err :&#x3D; w.Write([]byte(contentType)); err !&#x3D; nil &#123;
        return err
    &#125;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>因为Write方法需要传入一个byte切片而我们希望写入的值是一个字符串，所以我们需要使用[]byte(…)进行转换。这个转换分配内存并且做一个拷贝，但是这个拷贝在转换后几乎立马就被丢弃掉。让我们假装这是一个web服务器的核心部分并且我们的性能分析表示这个内存分配使服务器的速度变慢。这里我们可以避免掉内存分配么？</p>
<p>这个io.Writer接口告诉我们关于w持有的具体类型的唯一东西：就是可以向它写入字节切片。如果我们回顾net&#x2F;http包中的内幕，我们知道在这个程序中的w变量持有的动态类型也有一个允许字符串高效写入的WriteString方法；这个方法会避免去分配一个临时的拷贝。（这可能像在黑夜中射击一样，但是许多满足io.Writer接口的重要类型同时也有WriteString方法，包括<em>bytes.Buffer，</em>os.File和*bufio.Writer。）</p>
<p>我们不能对任意io.Writer类型的变量w，假设它也拥有WriteString方法。但是我们可以定义一个只有这个方法的新接口并且使用类型断言来检测是否w的动态类型满足这个新接口。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; writeString writes s to w.
&#x2F;&#x2F; If w has a WriteString method, it is invoked instead of w.Write.
func writeString(w io.Writer, s string) (n int, err error) &#123;
    type stringWriter interface &#123;
        WriteString(string) (n int, err error)
    &#125;
    if sw, ok :&#x3D; w.(stringWriter); ok &#123;
        return sw.WriteString(s) &#x2F;&#x2F; avoid a copy
    &#125;
    return w.Write([]byte(s)) &#x2F;&#x2F; allocate temporary copy
&#125;

func writeHeader(w io.Writer, contentType string) error &#123;
    if _, err :&#x3D; writeString(w, &quot;Content-Type: &quot;); err !&#x3D; nil &#123;
        return err
    &#125;
    if _, err :&#x3D; writeString(w, contentType); err !&#x3D; nil &#123;
        return err
    &#125;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>为了避免重复定义，我们将这个检查移入到一个实用工具函数writeString中，但是它太有用了以致于标准库将它作为io.WriteString函数提供。这是向一个io.Writer接口写入字符串的推荐方法。</p>
<p>这个例子的神奇之处在于，没有定义了WriteString方法的标准接口，也没有指定它是一个所需行为的标准接口。一个具体类型只会通过它的方法决定它是否满足stringWriter接口，而不是任何它和这个接口类型所表达的关系。它的意思就是上面的技术依赖于一个假设，这个假设就是：如果一个类型满足下面的这个接口，然后WriteString(s)方法就必须和Write([]byte(s))有相同的效果。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">interface &#123;
    io.Writer
    WriteString(s string) (n int, err error)
&#125;</code></pre>
<p>尽管io.WriteString实施了这个假设，但是调用它的函数极少可能会去实施类似的假设。定义一个特定类型的方法隐式地获取了对特定行为的协约。对于Go语言的新手，特别是那些来自有强类型语言使用背景的新手，可能会发现它缺乏显式的意图令人感到混乱，但是在实战的过程中这几乎不是一个问题。除了空接口interface{}，接口类型很少意外巧合地被实现。</p>
<p>上面的writeString函数使用一个类型断言来获知一个普遍接口类型的值是否满足一个更加具体的接口类型；并且如果满足，它会使用这个更具体接口的行为。这个技术可以被很好的使用，不论这个被询问的接口是一个标准如io.ReadWriter，或者用户定义的如stringWriter接口。</p>
<p>这也是fmt.Fprintf函数怎么从其它所有值中区分满足error或者fmt.Stringer接口的值。在fmt.Fprintf内部，有一个将单个操作对象转换成一个字符串的步骤，像下面这样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package fmt

func formatOneValue(x interface&#123;&#125;) string &#123;
    if err, ok :&#x3D; x.(error); ok &#123;
        return err.Error()
    &#125;
    if str, ok :&#x3D; x.(Stringer); ok &#123;
        return str.String()
    &#125;
    &#x2F;&#x2F; ...all other types...
&#125;</code></pre>
<p>如果x满足这两个接口类型中的一个，具体满足的接口决定对值的格式化方式。如果都不满足，默认的case或多或少会统一地使用反射来处理所有的其它类型；我们可以在第12章知道具体是怎么实现的。</p>
<p>再一次的，它假设任何有String方法的类型都满足fmt.Stringer中约定的行为，这个行为会返回一个适合打印的字符串。</p>
<h2 id="7-13-类型分支"><a href="#7-13-类型分支" class="headerlink" title="7.13. 类型分支"></a>7.13. 类型分支</h2><p>接口被以两种不同的方式使用。在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。</p>
<p>第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。</p>
<p>如果你熟悉面向对象编程，你可能会将这两种方式当作是subtype polymorphism（子类型多态）和 ad hoc polymorphism（非参数多态），但是你不需要去记住这些术语。对于本章剩下的部分，我们将会呈现一些第二种方式的例子。</p>
<p>和其它那些语言一样，Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。一个调用的例子可能看起来像这样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import &quot;database&#x2F;sql&quot;

func listTracks(db sql.DB, artist string, minYear, maxYear int) &#123;
    result, err :&#x3D; db.Exec(
        &quot;SELECT * FROM tracks WHERE artist &#x3D; ? AND ? &lt;&#x3D; year AND year &lt;&#x3D; ?&quot;,
        artist, minYear, maxYear)
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>Exec方法使用SQL字面量替换在查询字符串中的每个’?’；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者nil空值。用这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对手可以通过利用输入内容中不正确的引号来控制查询语句。在Exec函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func sqlQuote(x interface&#123;&#125;) string &#123;
    if x &#x3D;&#x3D; nil &#123;
        return &quot;NULL&quot;
    &#125; else if _, ok :&#x3D; x.(int); ok &#123;
        return fmt.Sprintf(&quot;%d&quot;, x)
    &#125; else if _, ok :&#x3D; x.(uint); ok &#123;
        return fmt.Sprintf(&quot;%d&quot;, x)
    &#125; else if b, ok :&#x3D; x.(bool); ok &#123;
        if b &#123;
            return &quot;TRUE&quot;
        &#125;
        return &quot;FALSE&quot;
    &#125; else if s, ok :&#x3D; x.(string); ok &#123;
        return sqlQuoteString(s) &#x2F;&#x2F; (not shown)
    &#125; else &#123;
        panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x))
    &#125;
&#125;</code></pre>
<p>switch语句可以简化if-else链，如果这个if-else链对一连串值做相等测试。一个相似的type switch（类型分支）可以简化类型断言的if-else链。</p>
<p>在最简单的形式中，一个类型分支像普通的switch语句一样，它的运算对象是x.(type)——它使用了关键词字面量type——并且每个case有一到多个类型。一个类型分支基于这个接口值的动态类型使一个多路分支有效。这个nil的case和if x &#x3D;&#x3D; nil匹配，并且这个default的case和如果其它case都不匹配的情况匹配。一个对sqlQuote的类型分支可能会有这些case：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">switch x.(type) &#123;
case nil:       &#x2F;&#x2F; ...
case int, uint: &#x2F;&#x2F; ...
case bool:      &#x2F;&#x2F; ...
case string:    &#x2F;&#x2F; ...
default:        &#x2F;&#x2F; ...
&#125;</code></pre>
<p>和（§1.8）中的普通switch语句一样，每一个case会被顺序的进行考虑，并且当一个匹配找到时，这个case中的内容会被执行。当一个或多个case类型是接口时，case的顺序就会变得很重要，因为可能会有两个case同时匹配的情况。default case相对其它case的位置是无所谓的。它不会允许落空发生。</p>
<p>注意到在原来的函数中，对于bool和string情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型分支语句有一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内都有效的新变量。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">switch x :&#x3D; x.(type) &#123; &#x2F;* ... *&#x2F; &#125;</code></pre>
<p>这里我们已经将新的变量也命名为x；和类型断言一样，重用变量名是很常见的。和一个switch语句相似地，一个类型分支隐式的创建了一个词法块，因此新变量x的定义不会和外面块中的x变量冲突。每一个case也会隐式的创建一个单独的词法块。</p>
<p>使用类型分支的扩展形式来重写sqlQuote函数会让这个函数更加的清晰：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func sqlQuote(x interface&#123;&#125;) string &#123;
    switch x :&#x3D; x.(type) &#123;
    case nil:
        return &quot;NULL&quot;
    case int, uint:
        return fmt.Sprintf(&quot;%d&quot;, x) &#x2F;&#x2F; x has type interface&#123;&#125; here.
    case bool:
        if x &#123;
            return &quot;TRUE&quot;
        &#125;
        return &quot;FALSE&quot;
    case string:
        return sqlQuoteString(x) &#x2F;&#x2F; (not shown)
    default:
        panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x))
    &#125;
&#125;</code></pre>
<p>在这个版本的函数中，在每个单一类型的case内部，变量x和这个case的类型相同。例如，变量x在bool的case中是bool类型和string的case中是string类型。在所有其它的情况中，变量x是switch运算对象的类型（接口）；在这个例子中运算对象是一个interface{}。当多个case需要相同的操作时，比如int和uint的情况，类型分支可以很容易的合并这些情况。</p>
<p>尽管sqlQuote接受一个任意类型的参数，但是这个函数只会在它的参数匹配类型分支中的一个case时运行到结束；其它情况的它会panic出“unexpected type”消息。虽然x的类型是interface{}，但是我们把它认为是一个int，uint，bool，string，和nil值的discriminated union（可识别联合）</p>
<h2 id="7-14-示例-基于标记的XML解码"><a href="#7-14-示例-基于标记的XML解码" class="headerlink" title="7.14. 示例: 基于标记的XML解码"></a>7.14. 示例: 基于标记的XML解码</h2><p>第4.5章节展示了如何使用encoding&#x2F;json包中的Marshal和Unmarshal函数来将JSON文档转换成Go语言的数据结构。encoding&#x2F;xml包提供了一个相似的API。当我们想构造一个文档树的表示时使用encoding&#x2F;xml包会很方便，但是对于很多程序并不是必须的。encoding&#x2F;xml包也提供了一个更低层的基于标记的API用于XML解码。在基于标记的样式中，解析器消费输入并产生一个标记流；四个主要的标记类型－StartElement，EndElement，CharData，和Comment－每一个都是encoding&#x2F;xml包中的具体类型。每一个对(*xml.Decoder).Token的调用都返回一个标记。</p>
<p>这里显示的是和这个API相关的部分：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">encoding&#x2F;xml


package xml

type Name struct &#123;
    Local string &#x2F;&#x2F; e.g., &quot;Title&quot; or &quot;id&quot;
&#125;

type Attr struct &#123; &#x2F;&#x2F; e.g., name&#x3D;&quot;value&quot;
    Name  Name
    Value string
&#125;

&#x2F;&#x2F; A Token includes StartElement, EndElement, CharData,
&#x2F;&#x2F; and Comment, plus a few esoteric types (not shown).
type Token interface&#123;&#125;
type StartElement struct &#123; &#x2F;&#x2F; e.g., &lt;name&gt;
    Name Name
    Attr []Attr
&#125;
type EndElement struct &#123; Name Name &#125; &#x2F;&#x2F; e.g., &lt;&#x2F;name&gt;
type CharData []byte                 &#x2F;&#x2F; e.g., &lt;p&gt;CharData&lt;&#x2F;p&gt;
type Comment []byte                  &#x2F;&#x2F; e.g., &lt;!-- Comment --&gt;

type Decoder struct&#123; &#x2F;* ... *&#x2F; &#125;
func NewDecoder(io.Reader) *Decoder
func (*Decoder) Token() (Token, error) &#x2F;&#x2F; returns next Token in sequence</code></pre>
<p>这个没有方法的Token接口也是一个可识别联合的例子。传统的接口如io.Reader的目的是隐藏满足它的具体类型的细节，这样就可以创造出新的实现：在这个实现中每个具体类型都被统一地对待。相反，满足可识别联合的具体类型的集合被设计为确定和暴露，而不是隐藏。可识别联合的类型几乎没有方法，操作它们的函数使用一个类型分支的case集合来进行表述，这个case集合中每一个case都有不同的逻辑。</p>
<p>下面的xmlselect程序获取和打印在一个XML文档树中确定的元素下找到的文本。使用上面的API，它可以在输入上一次完成它的工作而从来不要实例化这个文档树。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch7&#x2F;xmlselect


&#x2F;&#x2F; Xmlselect prints the text of selected elements of an XML document.
package main

import (
    &quot;encoding&#x2F;xml&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

func main() &#123;
    dec :&#x3D; xml.NewDecoder(os.Stdin)
    var stack []string &#x2F;&#x2F; stack of element names
    for &#123;
        tok, err :&#x3D; dec.Token()
        if err &#x3D;&#x3D; io.EOF &#123;
            break
        &#125; else if err !&#x3D; nil &#123;
            fmt.Fprintf(os.Stderr, &quot;xmlselect: %v\n&quot;, err)
            os.Exit(1)
        &#125;
        switch tok :&#x3D; tok.(type) &#123;
        case xml.StartElement:
            stack &#x3D; append(stack, tok.Name.Local) &#x2F;&#x2F; push
        case xml.EndElement:
            stack &#x3D; stack[:len(stack)-1] &#x2F;&#x2F; pop
        case xml.CharData:
            if containsAll(stack, os.Args[1:]) &#123;
                fmt.Printf(&quot;%s: %s\n&quot;, strings.Join(stack, &quot; &quot;), tok)
            &#125;
        &#125;
    &#125;
&#125;

&#x2F;&#x2F; containsAll reports whether x contains the elements of y, in order.
func containsAll(x, y []string) bool &#123;
    for len(y) &lt;&#x3D; len(x) &#123;
        if len(y) &#x3D;&#x3D; 0 &#123;
            return true
        &#125;
        if x[0] &#x3D;&#x3D; y[0] &#123;
            y &#x3D; y[1:]
        &#125;
        x &#x3D; x[1:]
    &#125;
    return false
&#125;</code></pre>
<p>main函数中的循环每遇到一个StartElement时，它把这个元素的名称压到一个栈里，并且每次遇到EndElement时，它将名称从这个栈中推出。这个API保证了StartElement和EndElement的序列可以被完全的匹配，甚至在一个糟糕的文档格式中。注释会被忽略。当xmlselect遇到一个CharData时，只有当栈中有序地包含所有通过命令行参数传入的元素名称时，它才会输出相应的文本。</p>
<p>下面的命令打印出任意出现在两层div元素下的h2元素的文本。它的输入是XML的说明文档，并且它自己就是XML文档格式的。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ .&#x2F;fetch http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2006&#x2F;REC-xml11-20060816 |
    .&#x2F;xmlselect div div h2
html body div div h2: 1 Introduction
html body div div h2: 2 Documents
html body div div h2: 3 Logical Structures
html body div div h2: 4 Physical Structures
html body div div h2: 5 Conformance
html body div div h2: 6 Notation
html body div div h2: A References
html body div div h2: B Definitions for Character Normalization
...</code></pre>
<p>练习 7.17： 扩展xmlselect程序以便让元素不仅可以通过名称选择，也可以通过它们CSS风格的属性进行选择。例如一个像这样</p>
<div id="page" class="wide">
的元素可以通过匹配id或者class，同时还有它的名称来进行选择。

<p>练习 7.18： 使用基于标记的解码API，编写一个可以读取任意XML文档并构造这个文档所代表的通用节点树的程序。节点有两种类型：CharData节点表示文本字符串，和 Element节点表示被命名的元素和它们的属性。每一个元素节点有一个子节点的切片。</p>
<p>你可能发现下面的定义会对你有帮助。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import &quot;encoding&#x2F;xml&quot;

type Node interface&#123;&#125; &#x2F;&#x2F; CharData or *Element

type CharData string

type Element struct &#123;
    Type     xml.Name
    Attr     []xml.Attr
    Children []Node
&#125;</code></pre>

<h2 id="7-15-一些建议"><a href="#7-15-一些建议" class="headerlink" title="7.15. 一些建议"></a>7.15. 一些建议</h2><p>当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制（§6.6）来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</p>
<p>当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。</p>
<p>因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）</p>
<p>我们完成了对方法和接口的学习过程。Go语言对面向对象风格的编程支持良好，但这并不意味着你只能使用这一风格。不是任何事物都需要被当做一个对象；独立的函数有它们自己的用处，未封装的数据类型也是这样。观察一下，在本书前五章的例子中像input.Scan这样的方法被调用不超过二十次，与之相反的是普遍调用的函数如fmt.Printf。</p>
<h2 id="7-16-any关键字与泛型"><a href="#7-16-any关键字与泛型" class="headerlink" title="7.16. any关键字与泛型"></a>7.16. any关键字与泛型</h2><p>类型定义时不限制<code>形参类型</code>，在函数调用的时候再指定<code>具体类型</code>.  <code>any</code>其实是<code>interface&#123;&#125;</code>的别名<br>泛型好处:  (1).在编译期间对类型进行检查以提高类型安全(2).通过指定类型消除强制类型转换(3).能够减少代码重复性，提供更通用的功能函数。</p>
<ul>
<li><p>类型泛型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

type ListType[T int | int32 | int64 | string] []T

type MapType[K int | int32, V int64 | string] map[K]V

func main() &#123;
    var intList ListType[int]
    intList &#x3D; []int&#123;1, 2, 3&#125;
    fmt.Println(intList)
    strList :&#x3D; ListType[string]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;
    fmt.Println(strList)

    intMap :&#x3D; MapType[int, string]&#123;1: &quot;1&quot;, 2: &quot;2&quot;&#125;
    int32Map :&#x3D; MapType[int32, int64]&#123;1: 2, 3: 4&#125;
    fmt.Println(intMap)
    fmt.Println(int32Map)
&#125;</code></pre>

<p>这里面的T,K,V都是占位符号,<code>ListType</code>只能在那三种类型中选择,同理<code>MapType</code>也是</p>
</li>
<li><p>接口泛型</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">type GenericStackInterface[T any] interface &#123;
  Push(element T)
  Pop() T
&#125;</code></pre>
</li>
<li><p>泛型函数</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func minInt[T int | int8 | int16 | int32](a, b T) T &#123;
if a &lt; b &#123;
    return a
&#125;
    return b
&#125;

func maxInt[T int | int8 | int16 | int32](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
func Mix(a any) any &#123;

&#125;
&#x2F;&#x2F;还可以简化一下
type Numeric interface &#123;
    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64
&#125;
func min[T Numeric](a, b T) T &#123;
if a &lt; b &#123;
    return a
&#125;
    return b
&#125;

func max[T Numeric](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
&#x2F;&#x2F; go.18内置了数字类型的集合，故可以
import (
&quot;golang.org&#x2F;x&#x2F;exp&#x2F;constraints&quot;
)

func minType[T constraints.Ordered](a, b T) T &#123;
    if a &lt; b &#123;
        return a
    &#125;
    return b
&#125;

func maxType[T constraints.Ordered](a, b T) T &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;</code></pre>

<p>如果进入<code>constraints</code>源代码查看其具体代码的话，会发现在 Ordered 类型中也是有各种数字类型组合起来的。但是有一点奇怪的地方就是这里的类型集合中，各种类型前加了一个波浪线~, 表示衍生类型，即使用 type 自定义的类型也可以被识别到，只要底层类型一致即可。比如 ~int 可以包含 int 和 type MyInt int 等多种类型</p>
</li>
</ul>
<h1 id="8-Goroutines和Channels"><a href="#8-Goroutines和Channels" class="headerlink" title="8. Goroutines和Channels"></a>8. Goroutines和Channels</h1><p>(多看看本章代码)</p>
<h2 id="8-1-goroutine"><a href="#8-1-goroutine" class="headerlink" title="8.1 goroutine"></a>8.1 goroutine</h2><p>通过代码示例了解<code>goroutine</code>的使用</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func main() &#123;
    go spinner(100 * time.Millisecond)
    const n &#x3D; 45
    fibN :&#x3D; fib(n) &#x2F;&#x2F; slow
    fmt.Printf(&quot;\rFibonacci(%d) &#x3D; %d\n&quot;, n, fibN)
&#125;

func spinner(delay time.Duration) &#123;
    for &#123;
        for _, r :&#x3D; range &#96;-\|&#x2F;&#96; &#123;
            fmt.Printf(&quot;\r%c&quot;, r)
            time.Sleep(delay)
        &#125;
    &#125;
&#125;

func fib(x int) int &#123;
    if x &lt; 2 &#123;
        return x
    &#125;
    return fib(x-1) + fib(x-2)
&#125;</code></pre>

<h2 id="8-2-channel"><a href="#8-2-channel" class="headerlink" title="8.2 channel"></a>8.2 channel</h2><p>这里应该还得看一下uber编码规范</p>
<ul>
<li><p>无缓冲channel</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">ch &lt;- x
x &#x3D; &lt;-chan &#x2F;&#x2F;取出元素
&lt;- ch &#x2F;&#x2F;取出，舍弃
close(ch) &#x2F;&#x2F; 关闭chan</code></pre>

<ul>
<li><p>串联channel</p>
</li>
<li><p>单方向channel</p>
</li>
</ul>
</li>
<li><p>缓冲channel</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">ch &#x3D; make(chan string, 3) &#x2F;&#x2F;channel容量为3</code></pre></li>
</ul>
<h2 id="8-3-基于select的多路复用"><a href="#8-3-基于select的多路复用" class="headerlink" title="8.3 基于select的多路复用"></a>8.3 基于select的多路复用</h2><details>
<summary>多路复用demo</summary>
<pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.
&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;

&#x2F;&#x2F; See page 246.

&#x2F;&#x2F; Countdown implements the countdown for a rocket launch.
package main

&#x2F;&#x2F; NOTE: the ticker goroutine never terminates if the launch is aborted.
&#x2F;&#x2F; This is a &quot;goroutine leak&quot;.

import (
        &quot;fmt&quot;
        &quot;os&quot;
        &quot;time&quot;
)

&#x2F;&#x2F;!+

func main() &#123;
        &#x2F;&#x2F; ...create abort channel...

        &#x2F;&#x2F;!-

        abort :&#x3D; make(chan struct&#123;&#125;)
        go func() &#123;
                os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte
                abort &lt;- struct&#123;&#125;&#123;&#125;
        &#125;()

        &#x2F;&#x2F;!+
        fmt.Println(&quot;Commencing countdown.  Press return to abort.&quot;)
        tick :&#x3D; time.Tick(1 * time.Second)
        for countdown :&#x3D; 10; countdown &gt; 0; countdown-- &#123;
                fmt.Println(countdown)
                select &#123;
                case &lt;-tick:
                        &#x2F;&#x2F; Do nothing.
                case &lt;-abort:
                        fmt.Println(&quot;Launch aborted!&quot;)
                        return
                &#125;
        &#125;
        launch()
&#125;
&#x2F;&#x2F;!-
func launch() &#123;
        fmt.Println(&quot;Lift off!&quot;)
&#125;</code></pre>

<p></pre></p>
</details>

<ul>
<li><p>goroutine泄露 : 当for语句执行完后，程序已经跳转到其他部分，但是<code>time.Tick(1 * time.Second)</code>仍然会继续的网channel里面发送数据，这就会导致gotourine泄露，以上面为例，那么就需要合适的地方调用<code>tick.stop()</code></p>
</li>
<li><p>channel的ready : 一定要等到channel准备完毕，开始接受或者发送消息</p>
</li>
<li><p>channel的轮询 : 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">select &#123;
  case &lt;-abort:
      fmt.Printf(&quot;Launch aborted!\n&quot;)
      return
  default:
      &#x2F;&#x2F; do nothing
&#125;</code></pre></li>
</ul>
<h2 id="8-4-并发的退出"><a href="#8-4-并发的退出" class="headerlink" title="8.4. 并发的退出"></a>8.4. 并发的退出</h2><p>这节主要讨论如何有效退出goroutines</p>
<details>
<summary>
<font size="3" color="orange">goroutines退出代码示例</font></summary>
<pre>

<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;gopl.io&#x2F;ch8&#x2F;du4
&#x2F;&#x2F; Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.
&#x2F;&#x2F; License: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;

&#x2F;&#x2F; See page 251.

&#x2F;&#x2F; The du4 command computes the disk usage of the files in a directory.
package main

&#x2F;&#x2F; The du4 variant includes cancellation:
&#x2F;&#x2F; it terminates quickly when the user hits return.

import (
 &quot;fmt&quot;
 &quot;os&quot;
 &quot;path&#x2F;filepath&quot;
 &quot;sync&quot;
 &quot;time&quot;
)

&#x2F;&#x2F;!+1
var done &#x3D; make(chan struct&#123;&#125;)

func cancelled() bool &#123;
 select &#123;
 case &lt;-done:
  return true
 default:
  return false
 &#125;
&#125;

&#x2F;&#x2F;!-1

func main() &#123;
 &#x2F;&#x2F; Determine the initial directories.
 roots :&#x3D; os.Args[1:]
 if len(roots) &#x3D;&#x3D; 0 &#123;
  roots &#x3D; []string&#123;&quot;.&quot;&#125;
 &#125;

 &#x2F;&#x2F;!+2
 &#x2F;&#x2F; Cancel traversal when input is detected.
 go func() &#123;
  os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte
  close(done)
 &#125;()
 &#x2F;&#x2F;!-2

 &#x2F;&#x2F; Traverse each root of the file tree in parallel.
 fileSizes :&#x3D; make(chan int64)
 var n sync.WaitGroup
 for _, root :&#x3D; range roots &#123;
  n.Add(1)
  go walkDir(root, &amp;n, fileSizes)
 &#125;
 go func() &#123;
  n.Wait()
  close(fileSizes)
 &#125;()

 &#x2F;&#x2F; Print the results periodically.
 tick :&#x3D; time.Tick(500 * time.Millisecond)
 var nfiles, nbytes int64
loop:
 &#x2F;&#x2F;!+3
 for &#123;
  select &#123;
  case &lt;-done:
   &#x2F;&#x2F; Drain fileSizes to allow existing goroutines to finish.
   for range fileSizes &#123;
    &#x2F;&#x2F; Do nothing.
   &#125;
   return
  case size, ok :&#x3D; &lt;-fileSizes:
   &#x2F;&#x2F; ...
   &#x2F;&#x2F;!-3
   if !ok &#123;
    break loop &#x2F;&#x2F; fileSizes was closed
   &#125;
   nfiles++
   nbytes +&#x3D; size
  case &lt;-tick:
   printDiskUsage(nfiles, nbytes)
  &#125;
 &#125;
 printDiskUsage(nfiles, nbytes) &#x2F;&#x2F; final totals
&#125;

func printDiskUsage(nfiles, nbytes int64) &#123;
 fmt.Printf(&quot;%d files  %.1f GB\n&quot;, nfiles, float64(nbytes)&#x2F;1e9)
&#125;

&#x2F;&#x2F; walkDir recursively walks the file tree rooted at dir
&#x2F;&#x2F; and sends the size of each found file on fileSizes.
&#x2F;&#x2F;!+4
func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) &#123;
 defer n.Done()
 if cancelled() &#123;
  return
 &#125;
 for _, entry :&#x3D; range dirents(dir) &#123;
  &#x2F;&#x2F; ...
  &#x2F;&#x2F;!-4
  if entry.IsDir() &#123;
   n.Add(1)
   subdir :&#x3D; filepath.Join(dir, entry.Name())
   go walkDir(subdir, n, fileSizes)
  &#125; else &#123;
   fileSizes &lt;- entry.Size()
  &#125;
  &#x2F;&#x2F;!+4
 &#125;
&#125;

&#x2F;&#x2F;!-4

var sema &#x3D; make(chan struct&#123;&#125;, 20) &#x2F;&#x2F; concurrency-limiting counting semaphore

&#x2F;&#x2F; dirents returns the entries of directory dir.
&#x2F;&#x2F;!+5
func dirents(dir string) []os.FileInfo &#123;
 select &#123;
 case sema &lt;- struct&#123;&#125;&#123;&#125;: &#x2F;&#x2F; acquire token
 case &lt;-done:
  return nil &#x2F;&#x2F; cancelled
 &#125;
 defer func() &#123; &lt;-sema &#125;() &#x2F;&#x2F; release token

 &#x2F;&#x2F; ...read directory...
 &#x2F;&#x2F;!-5

 f, err :&#x3D; os.Open(dir)
 if err !&#x3D; nil &#123;
  fmt.Fprintf(os.Stderr, &quot;du: %v\n&quot;, err)
  return nil
 &#125;
 defer f.Close()

 entries, err :&#x3D; f.Readdir(0) &#x2F;&#x2F; 0 &#x3D;&gt; no limit; read all entries
 if err !&#x3D; nil &#123;
  fmt.Fprintf(os.Stderr, &quot;du: %v\n&quot;, err)
  &#x2F;&#x2F; Don&#39;t return: Readdir may return partial results.
 &#125;
 return entries
&#125;</code></pre>

<p></pre></p>
</details>

<h1 id="9-基于共享变量的并发"><a href="#9-基于共享变量的并发" class="headerlink" title="9. 基于共享变量的并发"></a>9. 基于共享变量的并发</h1><p>(多看这章代码)<br>避免数据竞争的三个方法</p>
<ul>
<li><p>并发读数据不会有数据竞争问题</p>
</li>
<li><p>避免从多个goroutine中访问变量，使用独立变量</p>
</li>
<li><p>临界区控制</p>
</li>
<li><p>总结</p>
<ul>
<li>数据竞争: 程序在多个goroutine交叉执行操作时，导致数据不一致.  </li>
<li><code>包级别</code>的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。<br>(多看看本章代码)</li>
</ul>
</li>
</ul>
<h2 id="9-1-sync-Mutex与sync-RMutex互斥锁"><a href="#9-1-sync-Mutex与sync-RMutex互斥锁" class="headerlink" title="9.1 sync.Mutex与sync.RMutex互斥锁"></a>9.1 sync.Mutex与sync.RMutex互斥锁</h2><p>比如银行存款查询余额的场景，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款(这句话很关键要没有)操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁</p>
<ul>
<li>总结<ul>
<li>避免临界区中的变量在中途被其他的goroutine修改</li>
<li>使用mutex包进行互斥goroutine</li>
<li>一个deferred Unlock即使在临界区发生<code>panic</code>时依然会执行</li>
<li>golang不支持重入锁</li>
<li>sync.RWMutex.RLock()持锁，sync.RWMutex.Lock()会阻塞，相同的RWMutex.Lock()持锁，sync.RWMutex.RLock()阻塞，但是sync.RWMutex.RLock()阻塞之间不阻塞</li>
</ul>
</li>
</ul>
<h2 id="9-2-sync-Once惰性初始化"><a href="#9-2-sync-Once惰性初始化" class="headerlink" title="9.2 sync.Once惰性初始化"></a>9.2 sync.Once惰性初始化</h2><p>如果初始化的成本太高，需要延迟的初始化对象。可考虑使用<code>sync.Once</code><br><detials></p>
<summary>sync.One的demo</summary>
<pre>

<p></pre></p>
</details>

<h2 id="9-3-sync-Cond的使用"><a href="#9-3-sync-Cond的使用" class="headerlink" title="9.3 sync.Cond的使用"></a>9.3 sync.Cond的使用</h2><ol>
<li><p>使用场景: <code>sync.Cond</code> 经常用在多个goroutine等待,一个goroutine通知,如果是一读一等待使用<code>sync.Mutx</code>和<code>chan</code>就可以</p>
</li>
<li><p><code>sync.Cond</code>的<a target="_blank" rel="noopener" href="https://pkg.go.dev/sync@go1.19#Cond">方法</a></p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
&#x2F;&#x2F; which must be held when changing the condition and
&#x2F;&#x2F; when calling the Wait method.
&#x2F;&#x2F; A Cond must not be copied after first use.
type Cond struct &#123;
        noCopy noCopy
        &#x2F;&#x2F; L is held while observing or changing the condition
        L Locker
        notify  notifyList
        checker copyChecker
&#125;
</code></pre>

<p> Cond 实例都会关联一个锁<code>L</code>(互斥锁 <em>Mutex，或读写锁</em>RWMutex);当修改条件或者调用<code>Wait()</code>方法时,必须加锁</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Signal wakes one goroutine waiting on c, if there is any.
&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L
&#x2F;&#x2F; during the call.
&#x2F;&#x2F; Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护
func (c *Cond) Signal()
&#x2F;&#x2F; Broadcast wakes all goroutines waiting on c.
&#x2F;&#x2F; It is allowed but not required for the caller to hold c.L
&#x2F;&#x2F; during the call.
func (c *Cond) Broadcast()

&#x2F;&#x2F; c.L.Unlock()
&#x2F;&#x2F; 挂起调用者所在的 goroutine,等待Broadcast或者Signal方法
func (c *Cond) Wait()
    &#x2F;&#x2F;代码片段
    c.L.Lock()
    for !condition() &#123;
        c.Wait()
    &#125;
    ... make use of condition ...
    c.L.Unlock()</code></pre>

<p> 调用<code>Wait</code>会自动释放锁 <code>c.L</code>,并挂起调用者所在的<code>goroutine</code>，因此当前协程会阻塞在<code>Wait</code>方法调用的地方。<br> 如果其他协程调用了<code>Signal</code>或<code>Broadcast</code>唤醒了该协程,那么<code>Wait</code>方法在结束阻塞时,会重新给<code>c.L</code>加锁，<br> 并且继续执行<code>Wait</code>后面的代码</p>
</li>
<li><p>Cond代码示例</p>
 <pre class="language-golang" data-language="golang"><code class="language-golang">var done &#x3D; false

func read(name string, c *sync.Cond) &#123;
    c.L.Lock()
    for !done &#123;
        c.Wait()
    &#125;
    log.Println(name, &quot;starts reading&quot;)
    c.L.Unlock()
&#125;

func write(name string, c *sync.Cond) &#123;
    log.Println(name, &quot;starts writing&quot;)
    time.Sleep(time.Second)
    c.L.Lock()
    done &#x3D; true
    c.L.Unlock()
    log.Println(name, &quot;wakes all&quot;)
    c.Broadcast()
&#125;

func main() &#123;
    cond :&#x3D; sync.NewCond(&amp;sync.Mutex&#123;&#125;)

    go read(&quot;reader1&quot;, cond)
    go read(&quot;reader2&quot;, cond)
    go read(&quot;reader3&quot;, cond)
    write(&quot;writer&quot;, cond)

    time.Sleep(time.Second * 3)
&#125;
</code></pre></li>
</ol>
<h2 id="9-4-Goroutines和线程"><a href="#9-4-Goroutines和线程" class="headerlink" title="9.4. Goroutines和线程"></a>9.4. Goroutines和线程</h2><ul>
<li><p>每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量</p>
</li>
<li><p>一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩</p>
</li>
<li><p>Go的<code>运行时</code>有自己的调度器，这个调度器比如m:n调度，n个操作系统线程调度m个gotoutine，例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。</p>
</li>
<li><p>GOMAXPROCS : 变量来决定会有多少个操作系统的线程同时执行Go的代码,其默认的值是运行机器上的CPU的核心数,<code>GOMAXPROCS</code>是前面说的m:n调度中的n.下面代码就可以简单的看出os线程调度代码的情况</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
for &#123;
    go fmt.Print(0)
    fmt.Print(1)
&#125;

$ GOMAXPROCS&#x3D;1 go run hacker-cliché.go
111111111111111111110000000000000000000011111...

$ GOMAXPROCS&#x3D;2 go run hacker-cliché.go
010101010101010101011001100101011010010100110...</code></pre>
</li>
<li><p>总结</p>
<ul>
<li>通过广播机制来取消goroutines</li>
<li>确保主函数退出，routines也随即退出</li>
</ul>
</li>
</ul>
<h1 id="10-包和工具"><a href="#10-包和工具" class="headerlink" title="10. 包和工具"></a>10. 包和工具</h1><p>现在随便一个小程序的实现都可能包含超过10000个函数。然而作者一般只需要考虑其中很小的一部分和做很少的设计，因为绝大部分代码都是由他人编写的，它们通过类似包或模块的方式被重用。</p>
<p>Go语言有超过100个的标准包（译注：可以用<code>go list std</code> | wc -l命令查看标准包的具体数目），标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设计、共享、重用和改进，目前互联网上已经发布了非常多的Go语言开源包，它们可以通过 <a target="_blank" rel="noopener" href="http://godoc.org/">http://godoc.org</a> 检索。在本章，我们将演示如何使用已有的包和创建新的包。</p>
<p>Go还自带了工具箱，里面有很多用来简化工作区和包管理的小工具。在本书开始的时候，我们已经见识过如何使用工具箱自带的工具来下载、构建和运行我们的演示程序了。在本章，我们将看看这些工具的基本设计理论和尝试更多的功能，例如打印工作区中包的文档和查询相关的元数据等。在下一章，我们将探讨testing包的单元测试用法。</p>
<p>summary: </p>
<ol>
<li>go语言拥有很多标准包，我们可以使用<code>go list std</code>来查看,更多的选择我们可以通过<a target="_blank" rel="noopener" href="http://godoc.org/">godoc</a>进行检索</li>
<li>go这种成熟的语言自带工具箱，和包管理工具</li>
<li>包的声明 ： 通过<code>package.struct</code>的形式访问我们的下载的<code>package</code>,但是也有同名的例如<code>math/rand</code>和<code>crypto/rand</code>，这种要重新指定包名，只影响当前文件，同时也解决了那些又臭又长的包名</li>
</ol>
<h2 id="10-1-包简介"><a href="#10-1-包简介" class="headerlink" title="10.1. 包简介"></a>10.1. 包简介</h2><p>任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。</p>
<p>每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以在使用它们的时候减少和其它部分名字的冲突。</p>
<p>每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。</p>
<p>当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。</p>
<h2 id="10-2-导入路径"><a href="#10-2-导入路径" class="headerlink" title="10.2. 导入路径"></a>10.2. 导入路径</h2><p>每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import (
    &quot;fmt&quot;
    &quot;math&#x2F;rand&quot;
    &quot;encoding&#x2F;json&quot;

    &quot;golang.org&#x2F;x&#x2F;net&#x2F;html&quot;

    &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;
)</code></pre>

<p>就像我们在2.6.1节提到过的，Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的。在本章，我们将深入讨论Go语言工具箱的功能，包括大家经常使用的构建测试等功能。当然，也有第三方扩展的工具箱存在。例如，Google公司内部的Go语言码农，他们就使用内部的多语言构建系统（译注：Google公司使用的是类似Bazel的构建系统，支持多种编程语言，目前该构件系统还不能完整支持Windows环境），用不同的规则来处理包名字和定位包，用不同的规则来处理单元测试等等，因为这样可以更紧密适配他们内部环境。</p>
<p>如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。<br>summary: </p>
<ol>
<li>每个包都拥有全局唯一名字</li>
<li>golang拥有自己的构建工具，也可以使用第三方构建工具，例如google的bazel构建系统，有点类似于java的maven和gradle</li>
<li>如果发布包建议用公司名作为前缀,并做到全球统一，这样有利于包的检索,例如上面的mysql包</li>
<li>文件开头以<code>_</code>和<code>.</code>的会被忽略</li>
</ol>
<h2 id="10-3-包声明"><a href="#10-3-包声明" class="headerlink" title="10.3. 包声明"></a>10.3. 包声明</h2><p>在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符(也称为包名)<br>例如，math&#x2F;rand包的每个源文件的开头都包含package rand包声明语句，所以当你导入这个包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员.</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import (
    &quot;fmt&quot;
    &quot;math&#x2F;rand&quot;
)

func main() &#123;
    fmt.Println(rand.Int())
&#125;</code></pre>
<p>通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math&#x2F;rand包和crypto&#x2F;rand包的包名都是rand。稍后我们将看到如何同时导入两个有相同包名的包。</p>
<p>关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。</p>
<p>第二个例外，包所在的目录中可能有一些文件名是以_test.go为后缀的Go源文件（译注：前面必须有其它的字符，因为以_或.开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖，具体细节我们将在11.2.4节中介绍。</p>
<p>第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in&#x2F;yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml。</p>
<p>summary: </p>
<ol>
<li>包声明语句的主要目的是定义当前包,这样就可以规范代码作用范围</li>
<li>默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。我可以对包重命名<ol>
<li>main包不被别人的包导入。他是构建工具的入口</li>
<li>包目录下会包含<code>_test.go</code>结尾的文件,这种目录可以包含：一种是普通包，另一种则是测试的外部扩展包.这是测试文件,_或.开头的源文件会被构建工具忽略</li>
<li>导入路径后追加版本号信息,这种情况下包的名字并不包含版本号后缀,例如“gopkg.in&#x2F;yaml.v2”</li>
</ol>
</li>
</ol>
<h2 id="10-4-导入声明"><a href="#10-4-导入声明" class="headerlink" title="10.4. 导入声明"></a>10.4. 导入声明</h2><p>可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。下面两个导入形式是等价的，但是第二种形式更为常见。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import &quot;fmt&quot;
import &quot;os&quot;

import (
    &quot;fmt&quot;
    &quot;os&quot;
)</code></pre>
<p>导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt和goimports工具都可以将不同分组导入的包独立排序。）</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import (
    &quot;fmt&quot;
    &quot;html&#x2F;template&quot;
    &quot;os&quot;

    &quot;golang.org&#x2F;x&#x2F;net&#x2F;html&quot;
    &quot;golang.org&#x2F;x&#x2F;net&#x2F;ipv4&quot;
)</code></pre>
<p>如果我们想同时导入两个有着名字相同的包，例如math&#x2F;rand包和crypto&#x2F;rand包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import (
    &quot;crypto&#x2F;rand&quot;
    mrand &quot;math&#x2F;rand&quot; &#x2F;&#x2F; alternative name mrand avoids conflict
)</code></pre>
<p>导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。</p>
<p>导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以将“path”标准包重命名为pathpkg。</p>
<p>每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。<br>summary: </p>
<ol>
<li>包名可以被重命名</li>
</ol>
<h2 id="10-5-包的匿名导入"><a href="#10-5-包的匿名导入" class="headerlink" title="10.5. 包的匿名导入"></a>10.5. 包的匿名导入</h2><p>如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数（§2.6.2）。这时候我们需要抑制“unused import”编译错误，我们可以用下划线_来重命名导入的包。像往常一样，下划线_为空白标识符，并不能被访问。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import _ &quot;image&#x2F;png&quot; &#x2F;&#x2F; register PNG decoder</code></pre>
<p>这个被称为包的匿名导入。它通常是用来实现一个编译时机制，然后通过在main主程序入口选择性地导入附加的包。首先，让我们看看如何使用该特性，然后再看看它是如何工作的。</p>
<p>标准库的image图像包包含了一个Decode函数，用于从io.Reader接口读取数据并解码图像，它调用底层注册的图像解码器来完成任务，然后返回image.Image类型的图像。使用image.Decode很容易编写一个图像格式的转换工具，读取一种格式的图像，然后编码为另一种图像格式：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch10&#x2F;jpeg


&#x2F;&#x2F; The jpeg command reads a PNG image from the standard input
&#x2F;&#x2F; and writes it as a JPEG image to the standard output.
package main

import (
    &quot;fmt&quot;
    &quot;image&quot;
    &quot;image&#x2F;jpeg&quot;
    _ &quot;image&#x2F;png&quot; &#x2F;&#x2F; register PNG decoder
    &quot;io&quot;
    &quot;os&quot;
)

func main() &#123;
    if err :&#x3D; toJPEG(os.Stdin, os.Stdout); err !&#x3D; nil &#123;
        fmt.Fprintf(os.Stderr, &quot;jpeg: %v\n&quot;, err)
        os.Exit(1)
    &#125;
&#125;

func toJPEG(in io.Reader, out io.Writer) error &#123;
    img, kind, err :&#x3D; image.Decode(in)
    if err !&#x3D; nil &#123;
        return err
    &#125;
    fmt.Fprintln(os.Stderr, &quot;Input format &#x3D;&quot;, kind)
    return jpeg.Encode(out, img, &amp;jpeg.Options&#123;Quality: 95&#125;)
&#125;</code></pre>
<p>如果我们将gopl.io&#x2F;ch3&#x2F;mandelbrot（§3.3）的输出导入到这个程序的标准输入，它将解码输入的PNG格式图像，然后转换为JPEG格式的图像输出（图3.3）。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go build gopl.io&#x2F;ch3&#x2F;mandelbrot
$ go build gopl.io&#x2F;ch10&#x2F;jpeg
$ .&#x2F;mandelbrot | .&#x2F;jpeg &gt;mandelbrot.jpg
Input format &#x3D; png</code></pre>
<p>要注意image&#x2F;png包的匿名导入语句。如果没有这一行语句，程序依然可以编译和运行，但是它将不能正确识别和解码PNG格式的图像：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go build gopl.io&#x2F;ch10&#x2F;jpeg
$ .&#x2F;mandelbrot | .&#x2F;jpeg &gt;mandelbrot.jpg
jpeg: image: unknown format</code></pre>
<p>下面的代码演示了它的工作机制。标准库还提供了GIF、PNG和JPEG等格式图像的解码器，用户也可以提供自己的解码器，但是为了保持程序体积较小，很多解码器并没有被全部包含，除非是明确需要支持的格式。image.Decode函数在解码时会依次查询支持的格式列表。每个格式驱动列表的每个入口指定了四件事情：格式的名称；一个用于描述这种图像数据开头部分模式的字符串，用于解码器检测识别；一个Decode函数用于完成解码图像工作；一个DecodeConfig函数用于解码图像的大小和颜色空间的信息。每个驱动入口是通过调用image.RegisterFormat函数注册，一般是在每个格式包的init初始化函数中调用，例如image&#x2F;png包是这样注册的：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package png &#x2F;&#x2F; image&#x2F;png

func Decode(r io.Reader) (image.Image, error)
func DecodeConfig(r io.Reader) (image.Config, error)

func init() &#123;
    const pngHeader &#x3D; &quot;\x89PNG\r\n\x1a\n&quot;
    image.RegisterFormat(&quot;png&quot;, pngHeader, Decode, DecodeConfig)
&#125;</code></pre>
<p>最终的效果是，主程序只需要匿名导入特定图像驱动包就可以用image.Decode解码对应格式的图像了。</p>
<p>数据库包database&#x2F;sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。例如：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import (
    &quot;database&#x2F;sql&quot;
    _ &quot;github.com&#x2F;lib&#x2F;pq&quot;              &#x2F;&#x2F; enable support for Postgres
    _ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot; &#x2F;&#x2F; enable support for MySQL
)

db, err &#x3D; sql.Open(&quot;postgres&quot;, dbname) &#x2F;&#x2F; OK
db, err &#x3D; sql.Open(&quot;mysql&quot;, dbname)    &#x2F;&#x2F; OK
db, err &#x3D; sql.Open(&quot;sqlite3&quot;, dbname)  &#x2F;&#x2F; returns error: unknown driver &quot;sqlite3&quot;</code></pre>
<p>练习 10.1： 扩展jpeg程序，以支持任意图像格式之间的相互转换，使用image.Decode检测支持的格式类型，然后通过flag命令行标志参数选择输出的格式。</p>
<p>练习 10.2： 设计一个通用的压缩文件读取框架，用来读取ZIP（archive&#x2F;zip）和POSIX tar（archive&#x2F;tar）格式压缩的文档。使用类似上面的注册技术来扩展支持不同的压缩格式，然后根据需要通过匿名导入选择导入要支持的压缩格式的驱动包。</p>
<p>summary: 包的匿名导入</p>
<ol>
<li>包的匿名导入。它通常是用来实现一个编译时机制,可以解决相同函数，但是类型不同的调用问题，比如<code>image/png</code>和<code>image/jpeg</code>的Decode问题,感觉像是多态。</li>
<li>没有<code>image/png</code>依然可以编译但是解析不了png格式</li>
<li>同时不同的数据库的驱动程序</li>
<li>初始化包级变量</li>
<li>按顺序初始化包中每个文件里的 init 函数</li>
<li>每个文件中可以包含多个 init 函数，按顺序执行(所以你导和不导包差距很大，匿名导入只是表明你无法使用相应包内函数)</li>
<li>包名和成员名要尽量的短，并且能见名知意</li>
</ol>
<h2 id="10-6-包和命名"><a href="#10-6-包和命名" class="headerlink" title="10.6. 包和命名"></a>10.6. 包和命名</h2><p>在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。</p>
<p>当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中最常用的包有bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包。</p>
<p>尽可能让命名有描述性且无歧义。例如，类似imageutil或ioutilis的工具包命名已经足够简洁了，就无须再命名为util了。要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户重命名导入包，例如前面看到的path包。</p>
<p>包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免和预定义的类型冲突，同样还有go&#x2F;types是为了避免和type关键字冲突。</p>
<p>要避免包名有其它的含义。例如，2.5节中我们的温度转换包最初使用了temp包名，虽然并没有持续多久。但这是一个糟糕的尝试，因为temp几乎是临时变量的同义词。然后我们有一段时间使用了temperature作为包名，显然名字并没有表达包的真实用途。最后我们改成了和strconv标准包类似的tempconv包名，这个名字比之前的就好多了。</p>
<p>现在让我们看看如何命名包的成员。由于是通过包的导入名字引入包里面的成员，例如fmt.Println，同时包含了包名和成员名信息。因此，我们一般并不需要关注Println的具体内容，因为fmt包名已经包含了这个信息。当设计一个包的时候，需要考虑包名和成员名两个部分如何很好地配合。下面有一些例子:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">bytes.Equal
flag.Int
http.Get
json.Marshal</code></pre>
<p>我们可以看到一些常用的命名模式。strings包提供了和字符串相关的诸多操作：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package strings

func Index(needle, haystack string) int

type Replacer struct&#123; &#x2F;* ... *&#x2F; &#125;
func NewReplacer(oldnew ...string) *Replacer

type Reader struct&#123; &#x2F;* ... *&#x2F; &#125;
func NewReader(s string) *Reader</code></pre>
<p>包名strings并没有出现在任何成员名字中。因为用户会这样引用这些成员strings.Index、strings.Replacer等。</p>
<p>其它一些包，可能只描述了单一的数据类型，例如html&#x2F;template和math&#x2F;rand等，只暴露一个主要的数据结构和与它相关的方法，还有一个以New命名的函数用于创建实例。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package rand &#x2F;&#x2F; &quot;math&#x2F;rand&quot;

type Rand struct&#123; &#x2F;* ... *&#x2F; &#125;
func New(source Source) *Rand</code></pre>

<p>这可能导致一些名字重复，例如<code>template.Templat</code>e<code>或</code>rand.Rand&#96;，这就是这些种类的包名往往特别短的原因之一。</p>
<p>在另一个极端，还有像<code>net/http</code>包那样含有非常多的名字和种类不多的数据类型，因为它们都是要执行一个复杂的复合任务。尽管有将近二十种类型和更多的函数，但是包中最重要的成员名字却是简单明了的：Get、Post、Handle、Error、Client、Server等。</p>
<h2 id="10-7-工具"><a href="#10-7-工具" class="headerlink" title="10.7. 工具"></a>10.7. 工具</h2><p>本章剩下的部分将讨论Go语言工具箱的具体功能，包括如何下载、格式化、构建、测试和安装Go语言编写的程序。</p>
<p>Go语言的工具箱集合了一系列功能的命令集。它可以看作是一个包管理器（类似于Linux中的apt和rpm工具），用于包的查询、计算包的依赖关系、从远程版本控制系统下载它们等任务。它也是一个构建系统，计算文件的依赖关系，然后调用编译器、汇编器和链接器构建程序，虽然它故意被设计成没有标准的make命令那么复杂。它也是一个单元测试和基准测试的驱动程序，我们将在第11章讨论测试话题。</p>
<p>Go语言工具箱的命令有着类似“瑞士军刀”的风格，带着一打的子命令，有一些我们经常用到，例如get、run、build和fmt等。你可以运行go或go help命令查看内置的帮助文档，为了查询方便，我们列出了最常用的命令：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go
...
    build            compile packages and dependencies
    clean            remove object files
    doc              show documentation for package or symbol
    env              print Go environment information
    fmt              run gofmt on package sources
    get              download and install packages and dependencies
    install          compile and install packages and dependencies
    list             list packages
    run              compile and run Go program
    test             test packages
    version          print Go version
    vet              run go tool vet on packages

Use &quot;go help [command]&quot; for more information about a command.
...</code></pre>

<p>为了达到零配置的设计目标，Go语言的工具箱很多地方都依赖各种约定。例如，根据给定的源文件的名称，Go语言的工具可以找到源文件对应的包，因为每个目录只包含了单一的包，并且包的导入路径和工作区的目录结构是对应的。给定一个包的导入路径，Go语言的工具可以找到与之对应的存储着实体文件的目录。它还可以根据导入路径找到存储代码的仓库的远程服务器URL。</p>
<h3 id="10-7-1-工作区结构"><a href="#10-7-1-工作区结构" class="headerlink" title="10.7.1. 工作区结构"></a>10.7.1. 工作区结构</h3><p>对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目录即可。当需要切换到不同工作区的时候，只要更新GOPATH就可以了。例如，我们在编写本书时将GOPATH设置为</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$HOME&#x2F;gobook：
$ export GOPATH&#x3D;$HOME&#x2F;gobook
$ go get gopl.io&#x2F;...
当你用前面介绍的命令下载本书全部的例子源码之后，你的当前工作区的目录结构应该是这样的：
GOPATH&#x2F;
    src&#x2F;
        gopl.io&#x2F;
            .git&#x2F;
            ch1&#x2F;
                helloworld&#x2F;
                    main.go
                dup&#x2F;
                    main.go
                ...
        golang.org&#x2F;x&#x2F;net&#x2F;
            .git&#x2F;
            html&#x2F;
                parse.go
                node.go
                ...
    bin&#x2F;
        helloworld
        dup
    pkg&#x2F;
        darwin_amd64&#x2F;</code></pre>

<p>GOPATH对应的工作区目录有三个子目录。其中src子目录用于存储源代码。每个包被保存在与$GOPATH&#x2F;src的相对路径为包导入路径的子目录中，例如gopl.io&#x2F;ch1&#x2F;helloworld相对应的路径目录。我们看到，一个GOPATH工作区的src目录中可能有多个独立的版本控制系统，例如gopl.io和golang.org分别对应不同的Git仓库。其中pkg子目录用于保存编译后的包的目标文件，bin子目录用于保存编译后的可执行程序，例如helloworld可执行程序。</p>
<p>第二个环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为$GOROOT&#x2F;src&#x2F;fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。</p>
<p>其中go env命令用于查看Go语言工具涉及的所有环境变量的值，包括未设置环境变量的默认值。GOOS环境变量用于指定目标操作系统（例如android、linux、darwin或windows），GOARCH环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然GOPATH环境变量是唯一必须要设置的，但是其它环境变量也会偶尔用到。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go env
GOPATH&#x3D;&quot;&#x2F;home&#x2F;gopher&#x2F;gobook&quot;
GOROOT&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;go&quot;
GOARCH&#x3D;&quot;amd64&quot;
GOOS&#x3D;&quot;darwin&quot;
...</code></pre>

<h3 id="10-7-2-下载包"><a href="#10-7-2-下载包" class="headerlink" title="10.7.2. 下载包"></a>10.7.2. 下载包</h3><p>使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互联网上找到和更新包。</p>
<p>使用命令go get可以下载一个单一的包或者用…下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中golang.org&#x2F;x&#x2F;net&#x2F;html自动出现在本地工作区目录的原因。</p>
<p>一旦go get命令下载了包，然后就是安装包或包对应的可执行的程序。我们将在下一节再关注它的细节，现在只是展示整个下载过程是如何的简单。第一个命令是获取golint工具，它用于检测Go源代码的编程风格是否有问题。第二个命令是用golint命令对2.6.2节的gopl.io&#x2F;ch2&#x2F;popcount包代码进行编码风格检查。它友好地报告了忘记了包的文档：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go get github.com&#x2F;golang&#x2F;lint&#x2F;golint
$ $GOPATH&#x2F;bin&#x2F;golint gopl.io&#x2F;ch2&#x2F;popcount
src&#x2F;gopl.io&#x2F;ch2&#x2F;popcount&#x2F;main.go:1:1:
  package comment should be of the form &quot;Package popcount ...&quot;</code></pre>

<p>go get命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。运行go help importpath获取相关的信息。</p>
<p>go get命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如golang.org&#x2F;x&#x2F;net包目录对应一个Git仓库：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cd $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;net
$ git remote -v
origin  https:&#x2F;&#x2F;go.googlesource.com&#x2F;net (fetch)
origin  https:&#x2F;&#x2F;go.googlesource.com&#x2F;net (push)</code></pre>
<p>需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面 <a target="_blank" rel="noopener" href="https://golang.org/x/net/html">https://golang.org/x/net/html</a> 包含了如下的元数据，它告诉Go语言的工具当前包真实的Git仓库托管地址：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ .&#x2F;fetch https:&#x2F;&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html | grep go-import
&lt;meta name&#x3D;&quot;go-import&quot;
      content&#x3D;&quot;golang.org&#x2F;x&#x2F;net git https:&#x2F;&#x2F;go.googlesource.com&#x2F;net&quot;&gt;
</code></pre>
<p>如果指定-u命令行标志参数，go get命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码将不会被自动更新。</p>
<p>go get -u命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以复制后golang.org&#x2F;x&#x2F;net&#x2F;html导入路径可能会变为gopl.io&#x2F;vendor&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html。最新的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。不过可以通过go help gopath命令查看Vendor的帮助文档。</p>
<p>(译注：墙内用户在上面这些命令的基础上，还需要学习用翻墙来go get。)</p>
<p>练习 10.3: 从 <a target="_blank" rel="noopener" href="http://gopl.io/ch1/helloworld?go-get=1">http://gopl.io/ch1/helloworld?go-get=1</a> 获取内容，查看本书的代码的真实托管的网址（go get请求HTML页面时包含了go-get参数，以区别普通的浏览器请求）。</p>
<h3 id="10-7-3-构建包"><a href="#10-7-3-构建包" class="headerlink" title="10.7.3. 构建包"></a>10.7.3. 构建包</h3><p>go build命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。如果包的名字是main，go build将调用链接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字。</p>
<p>由于每个目录只包含一个包，因此每个对应可执行程序或者叫Unix术语中的命令的包，会要求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面，例如用于提供Go文档服务的golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;godoc命令就是放在cmd子目录（§10.7.4）。</p>
<p>每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径名指定，相对路径必须以.或..开头。如果没有指定参数，那么默认指定为当前目录对应的包。下面的命令用于构建同一个包，虽然它们的写法各不相同：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cd $GOPATH&#x2F;src&#x2F;gopl.io&#x2F;ch1&#x2F;helloworld
$ go build</code></pre>
<p>或者：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cd anywhere
$ go build gopl.io&#x2F;ch1&#x2F;helloworld</code></pre>
<p>或者：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cd $GOPATH
$ go build .&#x2F;src&#x2F;gopl.io&#x2F;ch1&#x2F;helloworld</code></pre>
<p>但不能这样：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cd $GOPATH
$ go build src&#x2F;gopl.io&#x2F;ch1&#x2F;helloworld
Error: cannot find package &quot;src&#x2F;gopl.io&#x2F;ch1&#x2F;helloworld&quot;.</code></pre>
<p>也可以指定包的源文件列表，这一般只用于构建一些小程序或做一些临时性的实验。如果是main包，将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ cat quoteargs.go
package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() &#123;
    fmt.Printf(&quot;%q\n&quot;, os.Args[1:])
&#125;
$ go build quoteargs.go
$ .&#x2F;quoteargs one &quot;two three&quot; four\ five
[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;]</code></pre>
<p>特别是对于这类一次性运行的程序，我们希望尽快的构建并运行它。go run命令实际上是结合了构建和运行的两个步骤：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go run quoteargs.go one &quot;two three&quot; four\ five
[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;]</code></pre>
<p>(译注：其实也可以偷懒，直接go run *.go)</p>
<p>第一行的参数列表中，第一个不是以.go结尾的将作为可执行程序的参数运行。</p>
<p>默认情况下，go build命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。依赖分析和编译过程虽然都是很快的，但是随着项目增加到几十个包和成千上万行代码，依赖关系分析和编译时间的消耗将变的可观，有时候可能需要几秒种，即使这些依赖项没有改变。</p>
<p>go install命令和go build命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到$GOPATH&#x2F;pkg目录下，目录路径和 src目录路径对应，可执行程序被保存到$GOPATH&#x2F;bin目录。（很多用户会将$GOPATH&#x2F;bin添加到可执行程序的搜索列表中。）还有，go install命令和go build命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。为了方便编译依赖的包，go build -i命令将安装每个目标所依赖的包。</p>
<p>因为编译对应不同的操作系统平台和CPU架构，go install命令会将编译结果安装到GOOS和GOARCH对应的目录。例如，在Mac系统，golang.org&#x2F;x&#x2F;net&#x2F;html包将被安装到$GOPATH&#x2F;pkg&#x2F;darwin_amd64目录下的golang.org&#x2F;x&#x2F;net&#x2F;html.a文件。</p>
<p>针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的GOOS和GOARCH，然后运行构建命令即可。下面交叉编译的程序将输出它在编译时的操作系统和CPU类型：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
&#x2F;&#x2F; gopl.io&#x2F;ch10&#x2F;cross


func main() &#123;
    fmt.Println(runtime.GOOS, runtime.GOARCH)
&#125;</code></pre>
<p>下面以64位和32位环境分别编译和执行：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go build gopl.io&#x2F;ch10&#x2F;cross
$ .&#x2F;cross
darwin amd64
$ GOARCH&#x3D;386 go build gopl.io&#x2F;ch10&#x2F;cross
$ .&#x2F;cross
darwin 386</code></pre>
<p>有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释参数可以提供更多的构建过程控制。例如，文件中可能包含下面的注释：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; +build linux darwin</code></pre>
<p>在包声明和包注释的前面，该构建注释参数告诉go build只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; +build ignore</code></pre>
<p>更多细节，可以参考go&#x2F;build包的构建约束部分的文档。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go doc go&#x2F;build</code></pre>

<h3 id="10-7-4-包文档"><a href="#10-7-4-包文档" class="headerlink" title="10.7.4. 包文档"></a>10.7.4. 包文档</h3><p>Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。</p>
<p>Go语言中的文档注释一般是完整的句子，第一行通常是摘要说明，以被注释者的名字开头。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如，下面是fmt.Fprintf的文档注释。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; Fprintf formats according to a format specifier and writes to w.
&#x2F;&#x2F; It returns the number of bytes written and any write error encountered.
func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (int, error)</code></pre>

<p>Fprintf函数格式化的细节在fmt包文档中描述。如果注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。</p>
<p>好的文档并不需要面面俱到，文档本身应该是简洁但不可忽略的。事实上，Go语言的风格更喜欢简洁的文档，并且文档也是需要像代码一样维护的。对于一组声明语句，可以用一个精炼的句子描述，如果是显而易见的功能则并不需要注释。</p>
<p>在本书中，只要空间允许，我们之前很多包声明都包含了注释文档，但你可以从标准库中发现很多更好的例子。有两个工具可以帮到你。</p>
<p>首先是go doc命令，该命令打印其后所指定的实体的声明与文档注释，该实体可能是一个包：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go doc time
package time &#x2F;&#x2F; import &quot;time&quot;

Package time provides functionality for measuring and displaying time.

const Nanosecond Duration &#x3D; 1 ...
func After(d Duration) &lt;-chan Time
func Sleep(d Duration)
func Since(t Time) Duration
func Now() Time
type Duration int64
type Time struct &#123; ... &#125;
...many more...</code></pre>
<p>或者是某个具体的包成员：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go doc time.Since
func Since(t Time) Duration

    Since returns the time elapsed since t.
    It is shorthand for time.Now().Sub(t).</code></pre>
<p>或者是一个方法：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go doc time.Duration.Seconds
func (d Duration) Seconds() float64

    Seconds returns the duration as a floating-point number of seconds.</code></pre>
<p>该命令并不需要输入完整的包导入路径或正确的大小写。下面的命令将打印encoding&#x2F;json包的(*json.Decoder).Decode方法的文档：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go doc json.decode
func (dec *Decoder) Decode(v interface&#123;&#125;) error

    Decode reads the next JSON-encoded value from its input and stores
    it in the value pointed to by v.</code></pre>
<p>第二个工具，名字也叫godoc，它提供可以相互交叉引用的HTML页面，但是包含和go doc命令相同以及更多的信息。图10.1演示了time包的文档，11.6节将看到godoc演示可以交互的示例程序。godoc的在线服务 <a target="_blank" rel="noopener" href="https://godoc.org/">https://godoc.org</a> ，包含了成千上万的开源包的检索工具。</p>
<p>你也可以在自己的工作区目录运行godoc服务。运行下面的命令，然后在浏览器查看 <a target="_blank" rel="noopener" href="http://localhost:8000/pkg">http://localhost:8000/pkg</a> 页面：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ godoc -http :8000</code></pre>
<p>其中-analysis&#x3D;type和-analysis&#x3D;pointer命令行标志参数用于打开文档和代码中关于静态分析的结果。</p>
<h3 id="10-7-5-内部包"><a href="#10-7-5-内部包" class="headerlink" title="10.7.5. 内部包"></a>10.7.5. 内部包</h3><p>在Go语言程序中，包是最重要的封装机制。没有导出的标识符只在同一个包内部可以访问，而导出的标识符则是面向全宇宙都是可见的。</p>
<p>有时候，一个中间的状态可能也是有用的，标识符对于一小部分信任的包是可见的，但并不是对所有调用者都可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用。</p>
<p>为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">net&#x2F;http
net&#x2F;http&#x2F;internal&#x2F;chunked
net&#x2F;http&#x2F;httputil
net&#x2F;url</code></pre>

<h3 id="10-7-6-查询包"><a href="#10-7-6-查询包" class="headerlink" title="10.7.6. 查询包"></a>10.7.6. 查询包</h3><p>go list命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list github.com&#x2F;go-sql-driver&#x2F;mysql
github.com&#x2F;go-sql-driver&#x2F;mysql</code></pre>
<p>go list命令的参数还可以用”…”表示匹配任意的包的导入路径。我们可以用它来列出工作区中的所有包：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list ...
archive&#x2F;tar
archive&#x2F;zip
bufio
bytes
cmd&#x2F;addr2line
cmd&#x2F;api
...many more...</code></pre>
<p>或者是特定子目录下的所有包：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list gopl.io&#x2F;ch3&#x2F;...
gopl.io&#x2F;ch3&#x2F;basename1
gopl.io&#x2F;ch3&#x2F;basename2
gopl.io&#x2F;ch3&#x2F;comma
gopl.io&#x2F;ch3&#x2F;mandelbrot
gopl.io&#x2F;ch3&#x2F;netflag
gopl.io&#x2F;ch3&#x2F;printints
gopl.io&#x2F;ch3&#x2F;surface</code></pre>
<p>或者是和某个主题相关的所有包:</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list ...xml...
encoding&#x2F;xml
gopl.io&#x2F;ch7&#x2F;xmlselect</code></pre>
<p>go list命令还可以获取每个包完整的元信息，而不仅仅只是导入路径，这些元信息可以以不同格式提供给用户。其中-json命令行参数表示用JSON格式打印每个包的元信息。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list -json hash
&#123;
    &quot;Dir&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&#x2F;src&#x2F;hash&quot;,
    &quot;ImportPath&quot;: &quot;hash&quot;,
    &quot;Name&quot;: &quot;hash&quot;,
    &quot;Doc&quot;: &quot;Package hash provides interfaces for hash functions.&quot;,
    &quot;Target&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&#x2F;pkg&#x2F;darwin_amd64&#x2F;hash.a&quot;,
    &quot;Goroot&quot;: true,
    &quot;Standard&quot;: true,
    &quot;Root&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&quot;,
    &quot;GoFiles&quot;: [
            &quot;hash.go&quot;
    ],
    &quot;Imports&quot;: [
        &quot;io&quot;
    ],
    &quot;Deps&quot;: [
        &quot;errors&quot;,
        &quot;io&quot;,
        &quot;runtime&quot;,
        &quot;sync&quot;,
        &quot;sync&#x2F;atomic&quot;,
        &quot;unsafe&quot;
    ]
&#125;</code></pre>
<p>命令行参数-f则允许用户使用text&#x2F;template包（§4.6）的模板语言定义输出文本的格式。下面的命令将打印strconv包的依赖的包，然后用join模板函数将结果链接为一行，连接时每个结果之间用一个空格分隔：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list -f &#39;&#123;&#123;join .Deps &quot; &quot;&#125;&#125;&#39; strconv
errors math runtime unicode&#x2F;utf8 unsafe</code></pre>
<p>译注：上面的命令在Windows的命令行运行会遇到template: main:1: unclosed action的错误。产生这个错误的原因是因为命令行对命令中的” “参数进行了转义处理。可以按照下面的方法解决转义字符串的问题：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list -f &quot;&#123;&#123;join .Deps &quot; &quot;&#125;&#125;&quot; strconv</code></pre>

<p>下面的命令打印compress子目录下所有包的导入包列表：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...
compress&#x2F;bzip2 -&gt; bufio io sort
compress&#x2F;flate -&gt; bufio fmt io math sort strconv
compress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io time
compress&#x2F;lzw -&gt; bufio errors fmt io
compress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io</code></pre>
<p>译注：Windows下有同样有问题，要避免转义字符串的干扰：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list -f &quot;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&quot; compress&#x2F;...</code></pre>
<p>go list命令对于一次性的交互式查询或自动化构建或测试脚本都很有帮助。我们将在11.2.4节中再次使用它。每个子命令的更多信息，包括可设置的字段和意义，可以用go help list命令查看。</p>
<p>在本章，我们解释了Go语言工具中除了测试命令之外的所有重要的子命令。在下一章，我们将看到如何用go test命令去运行Go语言程序中的测试代码。</p>
<p>练习 10.4： 创建一个工具，根据命令行指定的参数，报告工作区所有依赖包指定的其它包集合。提示：你需要运行go list命令两次，一次用于初始化包，一次用于所有包。你可能需要用encoding&#x2F;json（§4.5）包来分析输出的JSON格式的信息。</p>
<p>summary: go的工具</p>
<ol>
<li>工作区结构 : 当需要切换工作区的时候，只需要更新下GOPATH环境变量即可<code>src</code>保存源代码,<code>pkg</code>子目录用于保存编译后的包的目标文件,<code>bin</code>子目录用于保存编译后的可执行程序</li>
<li>下载包 : <code>go get</code>命令，<code>go get -u</code>命令只是简单地保证每个下载最新版本，实际工作中要对包版本做精细的管理，需要vendor目录管理不同版本的包,<code>go help gopath</code>查看vendor帮助文档,而go get 相当于获取的是远程仓库源代码的整个库，还可以看到仓库的版本信息，go支持导入远程github仓库的代码，<code>go get</code>下载的包保存在哪里呢？一般他会保存在这个目录：<code>GOPATH/src</code><br>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrbug/p/11990418.html#:~:text=go%20get%20%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8C%85,%E7%9A%84go%20%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E3%80%82">goget详细介绍</a>，<code>go get</code>是对模块代码的更新</li>
<li>构建包 : 可以使用相对路径和绝对路径进行构建项目，<code>go run</code>其实也可以偷懒，直接<code>go run *.go</code>,<code>go build -i</code>命令将安装每个目标所依赖的包,<code>// +build linux darwin</code>,在包声明和包注释的前面，该构建注释参数告诉<code>go build</code>只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件,<code>// +build ignore</code>这个构建注释则表示不编译这个文件。<code>go doc go/build</code></li>
<li>包文档 : 专门用于保存包文档的源文件通常叫<code>doc.go</code>,例如 <code>go doc time</code> 某个具体成员结构<code>go doc time.Since</code>,或者具体函数<code>go doc time.Duration.Second</code> , 更简单的是<code>godoc -http :8000</code>包含了所有go包的索引，<code>-analysis=type</code>和<code>-analysis=pointer</code>命令行标志参数用于打开文档和代码中关于静态分析的结果</li>
<li>内部包 : 一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包</li>
<li>搜索包 : <code>go list</code>列出工作区相关包,还可以查看完整包的原信息,例如<code>hash</code>包<code>go list -json hash</code><ol>
<li>命令行参数-f则允许用户使用text&#x2F;template包（§4.6）的模板语言定义输出文本的格式 <pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F;windows环境下注意
go list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...
  compress&#x2F;bzip2 -&gt; bufio io sort
  compress&#x2F;flate -&gt; bufio fmt io math sort strconv
  compress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io time
  compress&#x2F;lzw -&gt; bufio errors fmt io
  compress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io</code></pre></li>
</ol>
</li>
</ol>
<h1 id="11-测试"><a href="#11-测试" class="headerlink" title="11. 测试"></a>11. 测试</h1><p>Maurice Wilkes，第一个存储程序计算机EDSAC的设计者，1949年他在实验室爬楼梯时有一个顿悟。在《计算机先驱回忆录》（Memoirs of a Computer Pioneer）里，他回忆到：“忽然间有一种醍醐灌顶的感觉，我整个后半生的美好时光都将在寻找程序BUG中度过了”。肯定从那之后的大部分正常的码农都会同情Wilkes过分悲观的想法，虽然也许会有人困惑于他对软件开发的难度的天真看法。</p>
<p>现在的程序已经远比Wilkes时代的更大也更复杂，也有许多技术可以让软件的复杂性可得到控制。其中有两种技术在实践中证明是比较有效的。第一种是代码在被正式部署前需要进行代码评审。第二种则是测试，也就是本章的讨论主题。</p>
<p>我们说测试的时候一般是指自动化测试，也就是写一些小的程序用来检测被测试代码（产品代码）的行为和预期的一样，这些通常都是精心设计的执行某些特定的功能或者是通过随机性的输入待验证边界的处理。</p>
<p>软件测试是一个巨大的领域。测试的任务可能已经占据了一些程序员的部分时间和另一些程序员的全部时间。和软件测试技术相关的图书或博客文章有成千上万之多。对于每一种主流的编程语言，都会有一打的用于测试的软件包，同时也有大量的测试相关的理论，而且每种都吸引了大量技术先驱和追随者。这些都足以说服那些想要编写有效测试的程序员重新学习一套全新的技能。</p>
<p>Go语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的，而且它很容易延伸到基准测试和示例文档。</p>
<p>在实践中，编写测试代码和编写程序本身并没有多大区别。我们编写的每一个函数也是针对每个具体的任务。我们必须小心处理边界条件，思考合适的数据结构，推断合适的输入应该产生什么样的结果输出。编写测试代码和编写普通的Go代码过程是类似的；它并不需要学习新的符号、规则和工具。</p>
<p>go test选项含义</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">
-args 传递参数到test binary(到时候补一个demo)
-exec xprog  运行test binary ,原理如同 go run
-i 安装test binary的相关依赖
-json 将测试输出转化为json为了自动化处理
-c file   定义编译后的binary的文件名,编译test binary,但是不执行
</code></pre>

<h2 id="11-1-go-test"><a href="#11-1-go-test" class="headerlink" title="11.1 go test"></a>11.1 go test</h2><p>go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。</p>
<p>在*_test.go文件中，有三种类型的函数：测试函数、基准测试（benchmark）函数、示例函数。一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间。示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。我们将在11.2节讨论测试函数的所有细节，并在11.4节讨论基准测试函数的细节，然后在11.6节讨论示例函数的细节。</p>
<p>go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<h2 id="11-2-测试函数"><a href="#11-2-测试函数" class="headerlink" title="11.2 测试函数"></a>11.2 测试函数</h2><p>每个测试函数必须导入testing包。测试函数有如下的签名：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func TestName(t *testing.T) &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func TestSin(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125;
func TestCos(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125;
func TestLog(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125;</code></pre>
<p>其中t参数用于报告测试失败和附加的日志信息。让我们定义一个实例包gopl.io&#x2F;ch11&#x2F;word1，其中只有一个函数IsPalindrome用于检查一个字符串是否从前向后和从后向前读都是一样的。（下面这个实现对于一个字符串是否是回文字符串前后重复测试了两次；我们稍后会再讨论这个问题。）</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch11&#x2F;word1


&#x2F;&#x2F; Package word provides utilities for word games.
package word

&#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.
&#x2F;&#x2F; (Our first attempt.)
func IsPalindrome(s string) bool &#123;
    for i :&#x3D; range s &#123;
        if s[i] !&#x3D; s[len(s)-1-i] &#123;
            return false
        &#125;
    &#125;
    return true
&#125;</code></pre>
<p>在相同的目录下，word_test.go测试文件中包含了TestPalindrome和TestNonPalindrome两个测试函数。每一个都是测试IsPalindrome是否给出正确的结果，并使用t.Error报告失败信息：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
package word

import &quot;testing&quot;

func TestPalindrome(t *testing.T) &#123;
    if !IsPalindrome(&quot;detartrated&quot;) &#123;
        t.Error(&#96;IsPalindrome(&quot;detartrated&quot;) &#x3D; false&#96;)
    &#125;
    if !IsPalindrome(&quot;kayak&quot;) &#123;
        t.Error(&#96;IsPalindrome(&quot;kayak&quot;) &#x3D; false&#96;)
    &#125;
&#125;

func TestNonPalindrome(t *testing.T) &#123;
    if IsPalindrome(&quot;palindrome&quot;) &#123;
        t.Error(&#96;IsPalindrome(&quot;palindrome&quot;) &#x3D; true&#96;)
    &#125;
&#125;</code></pre>
<p>go test命令如果没有参数指定包那么将默认采用当前目录对应的包（和go build命令一样）。我们可以用下面的命令构建和运行测试。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ cd $GOPATH&#x2F;src&#x2F;gopl.io&#x2F;ch11&#x2F;word1
$ go test
ok   gopl.io&#x2F;ch11&#x2F;word1  0.008s</code></pre>
<p>结果还比较满意，我们运行了这个程序， 不过没有提前退出是因为还没有遇到BUG报告。不过一个法国名为“Noelle Eve Elleon”的用户会抱怨IsPalindrome函数不能识别“été”。另外一个来自美国中部用户的抱怨则是不能识别“A man, a plan, a canal: Panama.”。执行特殊和小的BUG报告为我们提供了新的更自然的测试用例。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func TestFrenchPalindrome(t *testing.T) &#123;
    if !IsPalindrome(&quot;été&quot;) &#123;
        t.Error(&#96;IsPalindrome(&quot;été&quot;) &#x3D; false&#96;)
    &#125;
&#125;

func TestCanalPalindrome(t *testing.T) &#123;
    input :&#x3D; &quot;A man, a plan, a canal: Panama&quot;
    if !IsPalindrome(input) &#123;
        t.Errorf(&#96;IsPalindrome(%q) &#x3D; false&#96;, input)
    &#125;
&#125;</code></pre>
<p>为了避免两次输入较长的字符串，我们使用了提供了有类似Printf格式化功能的 Errorf函数来汇报错误结果。</p>
<p>当添加了这两个测试用例之后，go test返回了测试失败的信息。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go test
--- FAIL: TestFrenchPalindrome (0.00s)
    word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false
--- FAIL: TestCanalPalindrome (0.00s)
    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; false
FAIL
FAIL    gopl.io&#x2F;ch11&#x2F;word1  0.014s</code></pre>
<p>先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯。只有这样，我们才能定位我们要真正解决的问题。</p>
<p>先写测试用例的另外的好处是，运行测试通常会比手工描述报告的处理更快，这让我们可以进行快速地迭代。如果测试集有很多运行缓慢的测试，我们可以通过只选择运行某些特定的测试来加快测试速度。</p>
<p>参数-v可用于打印每个测试函数的名字和运行时间：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go test -v
&#x3D;&#x3D;&#x3D; RUN TestPalindrome
--- PASS: TestPalindrome (0.00s)
&#x3D;&#x3D;&#x3D; RUN TestNonPalindrome
--- PASS: TestNonPalindrome (0.00s)
&#x3D;&#x3D;&#x3D; RUN TestFrenchPalindrome
--- FAIL: TestFrenchPalindrome (0.00s)
    word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false
&#x3D;&#x3D;&#x3D; RUN TestCanalPalindrome
--- FAIL: TestCanalPalindrome (0.00s)
    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; false
FAIL
exit status 1
FAIL    gopl.io&#x2F;ch11&#x2F;word1  0.017s</code></pre>
<p>参数-run对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被go test测试命令运行：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go test -v -run&#x3D;&quot;French|Canal&quot;
&#x3D;&#x3D;&#x3D; RUN TestFrenchPalindrome
--- FAIL: TestFrenchPalindrome (0.00s)
    word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false
&#x3D;&#x3D;&#x3D; RUN TestCanalPalindrome
--- FAIL: TestCanalPalindrome (0.00s)
    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; false
FAIL
exit status 1
FAIL    gopl.io&#x2F;ch11&#x2F;word1  0.014s</code></pre>
<p>当然，一旦我们已经修复了失败的测试用例，在我们提交代码更新之前，我们应该以不带参数的go test命令运行全部的测试用例，以确保修复失败测试的同时没有引入新的问题。</p>
<p>我们现在的任务就是修复这些错误。简要分析后发现第一个BUG的原因是我们采用了 byte而不是rune序列，所以像“été”中的é等非ASCII字符不能正确处理。第二个BUG是因为没有忽略空格和字母的大小写导致的。</p>
<p>针对上述两个BUG，我们仔细重写了函数：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch11&#x2F;word2


&#x2F;&#x2F; Package word provides utilities for word games.
package word

import &quot;unicode&quot;

&#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.
&#x2F;&#x2F; Letter case is ignored, as are non-letters.
func IsPalindrome(s string) bool &#123;
    var letters []rune
    for _, r :&#x3D; range s &#123;
        if unicode.IsLetter(r) &#123;
            letters &#x3D; append(letters, unicode.ToLower(r))
        &#125;
    &#125;
    for i :&#x3D; range letters &#123;
        if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;
            return false
        &#125;
    &#125;
    return true
&#125;</code></pre>
<p>同时我们也将之前的所有测试数据合并到了一个测试中的表格中。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func TestIsPalindrome(t *testing.T) &#123;
    var tests &#x3D; []struct &#123;
        input string
        want  bool
    &#125;&#123;
        &#123;&quot;&quot;, true&#125;,
        &#123;&quot;a&quot;, true&#125;,
        &#123;&quot;aa&quot;, true&#125;,
        &#123;&quot;ab&quot;, false&#125;,
        &#123;&quot;kayak&quot;, true&#125;,
        &#123;&quot;detartrated&quot;, true&#125;,
        &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;,
        &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;,
        &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;,
        &#123;&quot;été&quot;, true&#125;,
        &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;,
        &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome
        &#123;&quot;desserts&quot;, false&#125;,   &#x2F;&#x2F; semi-palindrome
    &#125;
    for _, test :&#x3D; range tests &#123;
        if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123;
            t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got)
        &#125;
    &#125;
&#125;</code></pre>
<p>现在我们的新测试都通过了：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ go test gopl.io&#x2F;ch11&#x2F;word2
ok      gopl.io&#x2F;ch11&#x2F;word2      0.015s</code></pre>
<p>这种表格驱动的测试在Go语言中很常见。我们可以很容易地向表格添加新的测试数据，并且后面的测试逻辑也没有冗余，这样我们可以有更多的精力去完善错误信息。</p>
<p>失败测试的输出并不包括调用t.Errorf时刻的堆栈调用信息。和其他编程语言或测试框架的assert断言不同，t.Errorf调用也没有引起panic异常或停止测试的执行。即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息。</p>
<p>如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用t.Fatal或t.Fatalf停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。</p>
<p>测试失败的信息一般的形式是“f(x) &#x3D; y, want z”，其中f(x)解释了失败的操作和对应的输入，y是实际的运行结果，z是期望的正确的结果。就像前面检查回文字符串的例子，实际的函数用于f(x)部分。显示x是表格驱动型测试中比较重要的部分，因为同一个断言可能对应不同的表格项执行多次。要避免无用和冗余的信息。在测试类似IsPalindrome返回布尔类型的函数时，可以忽略并没有额外信息的z部分。如果x、y或z是y的长度，输出一个相关部分的简明总结即可。测试的作者应该要努力帮助程序员诊断测试失败的原因。</p>
<p>练习 11.1: 为4.3节中的charcount程序编写测试。</p>
<p>练习 11.2: 为（§6.5）的IntSet编写一组测试，用于检查每个操作后的行为和基于内置map的集合等价，后面练习11.7将会用到。</p>
<h3 id="11-2-1-随机测试"><a href="#11-2-1-随机测试" class="headerlink" title="11.2.1. 随机测试"></a>11.2.1. 随机测试</h3><p>表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行为。</p>
<p>那么对于一个随机的输入，我们如何能知道希望的输出结果呢？这里有两种处理策略。第一个是编写另一个对照函数，使用简单和清晰的算法，虽然效率较低但是行为和要测试的函数是一致的，然后针对相同的随机输入检查两者的输出结果。第二种是生成的随机输入的数据遵循特定的模式，这样我们就可以知道期望的输出的模式。</p>
<p>下面的例子使用的是第二种方法：randomPalindrome函数用于随机生成回文字符串。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import &quot;math&#x2F;rand&quot;

&#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents
&#x2F;&#x2F; are derived from the pseudo-random number generator rng.
func randomPalindrome(rng *rand.Rand) string &#123;
    n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24
    runes :&#x3D; make([]rune, n)
    for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;
        r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\u0999&#39;
        runes[i] &#x3D; r
        runes[n-1-i] &#x3D; r
    &#125;
    return string(runes)
&#125;

func TestRandomPalindromes(t *testing.T) &#123;
    &#x2F;&#x2F; Initialize a pseudo-random number generator.
    seed :&#x3D; time.Now().UTC().UnixNano()
    t.Logf(&quot;Random seed: %d&quot;, seed)
    rng :&#x3D; rand.New(rand.NewSource(seed))

    for i :&#x3D; 0; i &lt; 1000; i++ &#123;
        p :&#x3D; randomPalindrome(rng)
        if !IsPalindrome(p) &#123;
            t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)
        &#125;
    &#125;
&#125;</code></pre>
<p>虽然随机测试会有不确定因素，但是它也是至关重要的，我们可以从失败测试的日志获取足够的信息。在我们的例子中，输入IsPalindrome的p参数将告诉我们真实的数据，但是对于函数将接受更复杂的输入，不需要保存所有的输入，只要日志中简单地记录随机数种子即可（像上面的方式）。有了这些随机数初始化种子，我们可以很容易修改测试代码以重现失败的随机测试。</p>
<p>通过使用当前时间作为随机种子，在整个过程中的每次运行测试命令时都将探索新的随机数据。如果你使用的是定期运行的自动化测试集成系统，随机测试将特别有价值。</p>
<p>练习 11.3: TestRandomPalindromes测试函数只测试了回文字符串。编写新的随机测试生成器，用于测试随机生成的非回文字符串。</p>
<p>练习 11.4: 修改randomPalindrome函数，以探索IsPalindrome是否对标点和空格做了正确处理。</p>
<p>译者注：拓展阅读感兴趣的读者可以再了解一下go-fuzz</p>
<h3 id="11-2-2-测试一个命令"><a href="#11-2-2-测试一个命令" class="headerlink" title="11.2.2. 测试一个命令"></a>11.2.2. 测试一个命令</h3><p>对于测试包go test是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。如果一个包的名字是 main，那么在构建时会生成一个可执行程序，不过main包可以作为一个包被测试器代码导入。</p>
<p>让我们为2.3.2节的echo程序编写一个测试。我们先将程序拆分为两个函数：echo函数完成真正的工作，main函数用于处理命令行输入参数和echo可能返回的错误。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch11&#x2F;echo


&#x2F;&#x2F; Echo prints its command-line arguments.
package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

var (
    n &#x3D; flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)
    s &#x3D; flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)
)

var out io.Writer &#x3D; os.Stdout &#x2F;&#x2F; modified during testing

func main() &#123;
    flag.Parse()
    if err :&#x3D; echo(!*n, *s, flag.Args()); err !&#x3D; nil &#123;
        fmt.Fprintf(os.Stderr, &quot;echo: %v\n&quot;, err)
        os.Exit(1)
    &#125;
&#125;

func echo(newline bool, sep string, args []string) error &#123;
    fmt.Fprint(out, strings.Join(args, sep))
    if newline &#123;
        fmt.Fprintln(out)
    &#125;
    return nil
&#125;</code></pre>
<p>在测试中我们可以用各种参数和标志调用echo函数，然后检测它的输出是否正确，我们通过增加参数来减少echo函数对全局变量的依赖。我们还增加了一个全局名为out的变量来替代直接使用os.Stdout，这样测试代码可以根据需要将out修改为不同的对象以便于检查。下面就是echo_test.go文件中的测试代码：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package main

import (
    &quot;bytes&quot;
    &quot;fmt&quot;
    &quot;testing&quot;
)

func TestEcho(t *testing.T) &#123;
    var tests &#x3D; []struct &#123;
        newline bool
        sep     string
        args    []string
        want    string
    &#125;&#123;
        &#123;true, &quot;&quot;, []string&#123;&#125;, &quot;\n&quot;&#125;,
        &#123;false, &quot;&quot;, []string&#123;&#125;, &quot;&quot;&#125;,
        &#123;true, &quot;\t&quot;, []string&#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;, &quot;one\ttwo\tthree\n&quot;&#125;,
        &#123;true, &quot;,&quot;, []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;, &quot;a,b,c\n&quot;&#125;,
        &#123;false, &quot;:&quot;, []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, &quot;1:2:3&quot;&#125;,
    &#125;
    for _, test :&#x3D; range tests &#123;
        descr :&#x3D; fmt.Sprintf(&quot;echo(%v, %q, %q)&quot;,
            test.newline, test.sep, test.args)

        out &#x3D; new(bytes.Buffer) &#x2F;&#x2F; captured output
        if err :&#x3D; echo(test.newline, test.sep, test.args); err !&#x3D; nil &#123;
            t.Errorf(&quot;%s failed: %v&quot;, descr, err)
            continue
        &#125;
        got :&#x3D; out.(*bytes.Buffer).String()
        if got !&#x3D; test.want &#123;
            t.Errorf(&quot;%s &#x3D; %q, want %q&quot;, descr, got, test.want)
        &#125;
    &#125;
&#125;</code></pre>
<p>要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。</p>
<p>通过将测试放到表格中，我们很容易添加新的测试用例。让我通过增加下面的测试用例来看看失败的情况是怎么样的：</p>
<p><code>&#123;true, &quot;,&quot;, []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;, &quot;a b c\n&quot;&#125;, // NOTE: wrong expectation!</code><br>go test输出如下：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go test gopl.io&#x2F;ch11&#x2F;echo
--- FAIL: TestEcho (0.00s)
    echo_test.go:31: echo(true, &quot;,&quot;, [&quot;a&quot; &quot;b&quot; &quot;c&quot;]) &#x3D; &quot;a,b,c&quot;, want &quot;a b c\n&quot;
FAIL
FAIL        gopl.io&#x2F;ch11&#x2F;echo         0.006s</code></pre>
<p>错误信息描述了尝试的操作（使用Go类似语法），实际的结果和期望的结果。通过这样的错误信息，你可以在检视代码之前就很容易定位错误的原因。</p>
<p>要注意的是在测试代码中并没有调用log.Fatal或os.Exit，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理。如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理。幸运的是（上面的意外只是一个插曲），我们的echo示例是比较简单的也没有需要返回非空error的情况。</p>
<h3 id="11-2-3-白盒测试"><a href="#11-2-3-白盒测试" class="headerlink" title="11.2.3. 白盒测试"></a>11.2.3. 白盒测试</h3><p>一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。相反，白盒测试有访问包内部函数和数据结构的权限，因此可以做到一些普通客户端无法实现的测试。例如，一个白盒测试可以在每个操作之后检测不变量的数据类型。（白盒测试只是一个传统的名称，其实称为clear box测试会更准确。）</p>
<p>黑盒和白盒这两种测试方法是互补的。黑盒测试一般更健壮，随着软件实现的完善测试代码很少需要更新。它们可以帮助测试者了解真实客户的需求，也可以帮助发现API设计的一些不足之处。相反，白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。</p>
<p>我们已经看到两种测试的例子。TestIsPalindrome测试仅仅使用导出的IsPalindrome函数，因此这是一个黑盒测试。TestEcho测试则调用了内部的echo函数，并且更新了内部的out包级变量，这两个都是未导出的，因此这是白盒测试。</p>
<p>当我们准备TestEcho测试的时候，我们修改了echo函数使用包级的out变量作为输出对象，因此测试代码可以用另一个实现代替标准输出，这样可以方便对比echo输出的数据。使用类似的技术，我们可以将产品代码的其他部分也替换为一个容易测试的伪对象。使用伪对象的好处是我们可以方便配置，容易预测，更可靠，也更容易观察。同时也可以避免一些不良的副作用，例如更新生产数据库或信用卡消费行为。</p>
<p>下面的代码演示了为用户提供网络存储的web服务中的配额检测逻辑。当用户使用了超过90%的存储配额之后将发送提醒邮件。（译注：一般在实现业务机器监控，包括磁盘、cpu、网络等的时候，需要类似的到达阈值&#x3D;&gt;触发报警的逻辑，所以是很实用的案例。）</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch11&#x2F;storage1


package storage

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&#x2F;smtp&quot;
)

func bytesInUse(username string) int64 &#123; return 0 &#x2F;* ... *&#x2F; &#125;

&#x2F;&#x2F; Email sender configuration.
&#x2F;&#x2F; NOTE: never put passwords in source code!
const sender &#x3D; &quot;notifications@example.com&quot;
const password &#x3D; &quot;correcthorsebatterystaple&quot;
const hostname &#x3D; &quot;smtp.example.com&quot;

const template &#x3D; &#96;Warning: you are using %d bytes of storage,
%d%% of your quota.&#96;

func CheckQuota(username string) &#123;
    used :&#x3D; bytesInUse(username)
    const quota &#x3D; 1000000000 &#x2F;&#x2F; 1GB
    percent :&#x3D; 100 * used &#x2F; quota
    if percent &lt; 90 &#123;
        return &#x2F;&#x2F; OK
    &#125;
    msg :&#x3D; fmt.Sprintf(template, used, percent)
    auth :&#x3D; smtp.PlainAuth(&quot;&quot;, sender, password, hostname)
    err :&#x3D; smtp.SendMail(hostname+&quot;:587&quot;, auth, sender,
        []string&#123;username&#125;, []byte(msg))
    if err !&#x3D; nil &#123;
        log.Printf(&quot;smtp.SendMail(%s) failed: %s&quot;, username, err)
    &#125;
&#125;</code></pre>
<p>我们想测试这段代码，但是我们并不希望发送真实的邮件。因此我们将邮件处理逻辑放到一个私有的notifyUser函数中。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">gopl.io&#x2F;ch11&#x2F;storage2


var notifyUser &#x3D; func(username, msg string) &#123;
    auth :&#x3D; smtp.PlainAuth(&quot;&quot;, sender, password, hostname)
    err :&#x3D; smtp.SendMail(hostname+&quot;:587&quot;, auth, sender,
        []string&#123;username&#125;, []byte(msg))
    if err !&#x3D; nil &#123;
        log.Printf(&quot;smtp.SendEmail(%s) failed: %s&quot;, username, err)
    &#125;
&#125;

func CheckQuota(username string) &#123;
    used :&#x3D; bytesInUse(username)
    const quota &#x3D; 1000000000 &#x2F;&#x2F; 1GB
    percent :&#x3D; 100 * used &#x2F; quota
    if percent &lt; 90 &#123;
        return &#x2F;&#x2F; OK
    &#125;
    msg :&#x3D; fmt.Sprintf(template, used, percent)
    notifyUser(username, msg)
&#125;</code></pre>
<p>现在我们可以在测试中用伪邮件发送函数替代真实的邮件发送函数。它只是简单记录要通知的用户和邮件的内容。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package storage

import (
    &quot;strings&quot;
    &quot;testing&quot;
)
func TestCheckQuotaNotifiesUser(t *testing.T) &#123;
    var notifiedUser, notifiedMsg string
    notifyUser &#x3D; func(user, msg string) &#123;
        notifiedUser, notifiedMsg &#x3D; user, msg
    &#125;

    &#x2F;&#x2F; ...simulate a 980MB-used condition...

    const user &#x3D; &quot;joe@example.org&quot;
    CheckQuota(user)
    if notifiedUser &#x3D;&#x3D; &quot;&quot; &amp;&amp; notifiedMsg &#x3D;&#x3D; &quot;&quot; &#123;
        t.Fatalf(&quot;notifyUser not called&quot;)
    &#125;
    if notifiedUser !&#x3D; user &#123;
        t.Errorf(&quot;wrong user (%s) notified, want %s&quot;,
            notifiedUser, user)
    &#125;
    const wantSubstring &#x3D; &quot;98% of your quota&quot;
    if !strings.Contains(notifiedMsg, wantSubstring) &#123;
        t.Errorf(&quot;unexpected notification message &lt;&lt;%s&gt;&gt;, &quot;+
            &quot;want substring %q&quot;, notifiedMsg, wantSubstring)
    &#125;
&#125;</code></pre>
<p>这里有一个问题：当测试函数返回后，CheckQuota将不能正常工作，因为notifyUsers依然使用的是测试函数的伪发送邮件函数（当更新全局对象的时候总会有这种风险）。 我们必须修改测试代码恢复notifyUsers原先的状态以便后续其他的测试没有影响，要确保所有的执行路径后都能恢复，包括测试失败或panic异常的情形。在这种情况下，我们建议使用defer语句来延后执行处理恢复的代码。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func TestCheckQuotaNotifiesUser(t *testing.T) &#123;
    &#x2F;&#x2F; Save and restore original notifyUser.
    saved :&#x3D; notifyUser
    defer func() &#123; notifyUser &#x3D; saved &#125;()

    &#x2F;&#x2F; Install the test&#39;s fake notifyUser.
    var notifiedUser, notifiedMsg string
    notifyUser &#x3D; func(user, msg string) &#123;
        notifiedUser, notifiedMsg &#x3D; user, msg
    &#125;
    &#x2F;&#x2F; ...rest of test...
&#125;</code></pre>
<p>这种处理模式可以用来暂时保存和恢复所有的全局变量，包括命令行标志参数、调试选项和优化参数；安装和移除导致生产代码产生一些调试信息的钩子函数；还有有些诱导生产代码进入某些重要状态的改变，比如超时、错误，甚至是一些刻意制造的并发行为等因素。</p>
<p>以这种方式使用全局变量是安全的，因为go test命令并不会同时并发地执行多个测试。</p>
<h3 id="11-2-4-外部测试包"><a href="#11-2-4-外部测试包" class="headerlink" title="11.2.4. 外部测试包"></a>11.2.4. 外部测试包</h3><p>考虑下这两个包：net&#x2F;url包，提供了URL解析的功能；net&#x2F;http包，提供了web服务和HTTP客户端的功能。如我们所料，上层的net&#x2F;http包依赖下层的net&#x2F;url包。然后，net&#x2F;url包中的一个测试是演示不同URL和HTTP客户端的交互行为。也就是说，一个下层包的测试代码导入了上层的包。</p>
<p>这样的行为在net&#x2F;url包的测试代码中会导致包的循环依赖，正如图11.1中向上箭头所示，同时正如我们在10.1节所讲的，Go语言规范是禁止包的循环依赖的。</p>
<p>不过我们可以通过外部测试包的方式解决循环依赖的问题，也就是在net&#x2F;url包所在的目录声明一个独立的url_test测试包。其中包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。我们将这个外部测试包的导入路径视作是net&#x2F;url_test会更容易理解，但实际上它并不能被其他任何包导入。</p>
<p>因为外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包；包内的测试代码就无法做到这点。在设计层面，外部测试包是在所有它依赖的包的上层，正如图11.2所示。</p>
<p>通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。</p>
<p>我们可以用go list命令查看包对应目录中哪些Go源文件是产品代码，哪些是包内测试，还有哪些是外部测试包。我们以fmt包作为一个例子：GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list -f&#x3D;&#123;&#123;.GoFiles&#125;&#125; fmt
[doc.go format.go print.go scan.go]</code></pre>
<p>TestGoFiles表示的是fmt包内部测试代码，以_test.go为后缀文件名，不过只在测试时被构建：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list -f&#x3D;&#123;&#123;.TestGoFiles&#125;&#125; fmt
[export_test.go]</code></pre>
<p>包的测试代码通常都在这些文件中，不过fmt包并非如此；稍后我们再解释export_test.go文件的作用。</p>
<p>XTestGoFiles表示的是属于外部测试包的测试代码，也就是fmt_test包，因此它们必须先导入fmt包。同样，这些文件也只是在测试时被构建运行：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go list -f&#x3D;&#123;&#123;.XTestGoFiles&#125;&#125; fmt
[fmt_test.go scan_test.go stringer_test.go]</code></pre>
<p>有时候外部测试包也需要访问被测试包内部的代码，例如在一个为了避免循环导入而被独立到外部测试包的白盒测试。在这种情况下，我们可以通过一些技巧解决：我们在包内的一个_test.go文件中导出一个内部的实现给外部测试包。因为这些代码只有在测试时才需要，因此一般会放在export_test.go文件中。</p>
<p>例如，fmt包的fmt.Scanf函数需要unicode.IsSpace函数提供的功能。但是为了避免太多的依赖，fmt包并没有导入包含巨大表格数据的unicode包；相反fmt包有一个叫isSpace内部的简易实现。</p>
<p>为了确保fmt.isSpace和unicode.IsSpace函数的行为保持一致，fmt包谨慎地包含了一个测试。一个在外部测试包内的白盒测试，是无法直接访问到isSpace内部函数的，因此fmt通过一个后门导出了isSpace函数。export_test.go文件就是专门用于外部测试包的后门。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package fmt
var IsSpace &#x3D; isSpace</code></pre>
<p>这个测试文件并没有定义测试代码；它只是通过fmt.IsSpace简单导出了内部的isSpace函数，提供给外部测试包使用。这个技巧可以广泛用于位于外部测试包的白盒测试。</p>
<h3 id="11-2-5-编写有效的测试"><a href="#11-2-5-编写有效的测试" class="headerlink" title="11.2.5. 编写有效的测试"></a>11.2.5. 编写有效的测试</h3><p>许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测试函数的机制（通常使用反射或元数据），通过设置一些“setup”和“teardown”的钩子函数来执行测试用例运行的初始化和之后的清理操作，同时测试工具箱还提供了很多类似assert断言、值比较函数、格式化输出错误信息和停止一个失败的测试等辅助函数（通常使用异常机制）。虽然这些机制可以使得测试非常简洁，但是测试输出的日志却会像火星文一般难以理解。此外，虽然测试最终也会输出PASS或FAIL的报告，但是它们提供的信息格式却非常不利于代码维护者快速定位问题，因为失败信息的具体含义非常隐晦，比如“assert: 0 &#x3D;&#x3D; 1”或成页的海量跟踪日志。</p>
<p>Go语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作，定义函数避免重复，就像普通编程那样。编写测试并不是一个机械的填空过程；一个测试也有自己的接口，尽管它的维护者也是测试仅有的一个用户。一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息。在理想情况下，维护者可以在不看代码的情况下就能根据错误信息定位错误产生的原因。一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律。</p>
<p>下面的断言函数比较两个值，然后生成一个通用的错误信息，并停止程序。它很好用也确实有效，但是当测试失败的时候，打印的错误信息却几乎是没有价值的。它并没有为快速解决问题提供一个很好的入口。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;testing&quot;
)
&#x2F;&#x2F; A poor assertion function.
func assertEqual(x, y int) &#123;
    if x !&#x3D; y &#123;
        panic(fmt.Sprintf(&quot;%d !&#x3D; %d&quot;, x, y))
    &#125;
&#125;
func TestSplit(t *testing.T) &#123;
    words :&#x3D; strings.Split(&quot;a:b:c&quot;, &quot;:&quot;)
    assertEqual(len(words), 3)
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。只有在测试中出现重复模式时才采用抽象。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func TestSplit(t *testing.T) &#123;
    s, sep :&#x3D; &quot;a:b:c&quot;, &quot;:&quot;
    words :&#x3D; strings.Split(s, sep)
    if got, want :&#x3D; len(words), 3; got !&#x3D; want &#123;
        t.Errorf(&quot;Split(%q, %q) returned %d words, want %d&quot;,
            s, sep, got, want)
    &#125;
    &#x2F;&#x2F; ...
&#125;</code></pre>

<p>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试。一旦我们写了这样结构的测试，下一步自然不是用更多的if语句来扩展测试用例，我们可以用像IsPalindrome的表驱动测试那样来准备更多的s和sep测试用例。</p>
<p>前面的例子并不需要额外的辅助函数，如果有可以使测试代码更简单的方法我们也乐意接受。（我们将在13.3节看到一个类似reflect.DeepEqual辅助函数。）一个好的测试的关键是首先实现你期望的具体行为，然后才是考虑简化测试代码、避免重复。如果直接从抽象、通用的测试库着手，很难取得良好结果。</p>
<p>练习11.5: 用表格驱动的技术扩展TestSplit测试，并打印期望的输出结果。</p>
<h3 id="11-2-6-避免脆弱的测试"><a href="#11-2-6-避免脆弱的测试" class="headerlink" title="11.2.6. 避免脆弱的测试"></a>11.2.6. 避免脆弱的测试</h3><p>如果一个应用程序对于新出现的但有效的输入经常失败说明程序容易出bug（不够稳健）；同样，如果一个测试仅仅对程序做了微小变化就失败则称为脆弱。就像一个不够稳健的程序会挫败它的用户一样，一个脆弱的测试同样会激怒它的维护者。最脆弱的测试代码会在程序没有任何变化的时候产生不同的结果，时好时坏，处理它们会耗费大量的时间但是并不会得到任何好处。</p>
<p>当一个测试函数会产生一个复杂的输出如一个很长的字符串、一个精心设计的数据结构或一个文件时，人们很容易想预先写下一系列固定的用于对比的标杆数据。但是随着项目的发展，有些输出可能会发生变化，尽管很可能是一个改进的实现导致的。而且不仅仅是输出部分，函数复杂的输入部分可能也跟着变化了，因此测试使用的输入也就不再有效了。</p>
<p>避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串。很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试。</p>
<h2 id="11-3-测试覆盖率"><a href="#11-3-测试覆盖率" class="headerlink" title="11.3. 测试覆盖率"></a>11.3. 测试覆盖率</h2><p>就其性质而言，测试不可能是完整的。计算机科学家Edsger Dijkstra曾说过：“测试能证明缺陷存在，而无法证明没有缺陷。”再多的测试也不能证明一个程序没有BUG。在最好的情况下，测试可以增强我们的信心：代码在很多重要场景下是可以正常工作的。</p>
<p>对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化——即使最简单的程序的动态也是难以精确测量的——但是有启发式方法来帮助我们编写有效的测试代码。</p>
<p>这些启发式方法中，语句的覆盖率是最简单和最广泛使用的。语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。在本节中，我们使用go test命令中集成的测试覆盖率工具，来度量下面代码的测试覆盖率，帮助我们识别测试和我们期望间的差距。</p>
<p>下面的代码是一个表格驱动的测试，用于测试第七章的表达式求值程序：</p>
<p>gopl.io&#x2F;ch7&#x2F;eval</p>
<p>func TestCoverage(t *testing.T) {<br>    var tests &#x3D; []struct {<br>        input string<br>        env   Env<br>        want  string &#x2F;&#x2F; expected error from Parse&#x2F;Check or result from Eval<br>    }{<br>        {“x % 2”, nil, “unexpected ‘%’”},<br>        {“!true”, nil, “unexpected ‘!’”},<br>        {“log(10)”, nil, <code>unknown function &quot;log&quot;</code>},<br>        {“sqrt(1, 2)”, nil, “call to sqrt has 2 args, want 1”},<br>        {“sqrt(A &#x2F; pi)”, Env{“A”: 87616, “pi”: math.Pi}, “167”},<br>        {“pow(x, 3) + pow(y, 3)”, Env{“x”: 9, “y”: 10}, “1729”},<br>        {“5 &#x2F; 9 * (F - 32)”, Env{“F”: -40}, “-40”},<br>    }</p>
<pre><code>for _, test := range tests &#123;
    expr, err := Parse(test.input)
    if err == nil &#123;
        err = expr.Check(map[Var]bool&#123;&#125;)
    &#125;
    if err != nil &#123;
        if err.Error() != test.want &#123;
            t.Errorf(&quot;%s: got %q, want %q&quot;, test.input, err, test.want)
        &#125;
        continue
    &#125;
    got := fmt.Sprintf(&quot;%.6g&quot;, expr.Eval(test.env))
    if got != test.want &#123;
        t.Errorf(&quot;%s: %v =&gt; %s, want %s&quot;,
            test.input, test.env, got, test.want)
    &#125;
&#125;
</code></pre>
<p>}<br>首先，我们要确保所有的测试都正常通过：</p>
<p>$ go test -v -run&#x3D;Coverage gopl.io&#x2F;ch7&#x2F;eval<br>&#x3D;&#x3D;&#x3D; RUN TestCoverage<br>— PASS: TestCoverage (0.00s)<br>PASS<br>ok      gopl.io&#x2F;ch7&#x2F;eval         0.011s<br>下面这个命令可以显示测试覆盖率工具的使用用法：</p>
<p>$ go tool cover<br>Usage of ‘go tool cover’:<br>Given a coverage profile produced by ‘go test’:<br>    go test -coverprofile&#x3D;c.out</p>
<p>Open a web browser displaying annotated source code:<br>    go tool cover -html&#x3D;c.out<br>…<br>go tool命令运行Go工具链的底层可执行程序。这些底层可执行程序放在$GOROOT&#x2F;pkg&#x2F;tool&#x2F;${GOOS}_${GOARCH}目录。因为有go build命令的原因，我们很少直接调用这些底层工具。</p>
<p>现在我们可以用-coverprofile标志参数重新运行测试：</p>
<p>$ go test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;eval<br>ok      gopl.io&#x2F;ch7&#x2F;eval         0.032s      coverage: 68.5% of statements<br>这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说，在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入c.out文件，并打印一部分执行的语句的一个总结。（如果你需要的是摘要，使用go test -cover。）</p>
<p>如果使用了-covermode&#x3D;count标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。</p>
<p>为了收集数据，我们运行了测试覆盖率工具，打印了测试日志，生成一个HTML报告，然后在浏览器中打开（图11.3）。</p>
<p>$ go tool cover -html&#x3D;c.out</p>
<p>绿色的代码块被测试覆盖到了，红色的则表示没有被覆盖到。为了清晰起见，我们将背景红色文本的背景设置成了阴影效果。我们可以马上发现unary操作的Eval方法并没有被执行到。如果我们针对这部分未被覆盖的代码添加下面的测试用例，然后重新运行上面的命令，那么我们将会看到那个红色部分的代码也变成绿色了：</p>
<p>{“-x * -x”, eval.Env{“x”: 2}, “4”}<br>不过两个panic语句依然是红色的。这是没有问题的，因为这两个语句并不会被执行到。</p>
<p>实现100%的测试覆盖率听起来很美，但是在具体实践中通常是不可行的，也不是值得推荐的做法。因为那只能说明代码被执行过而已，并不意味着代码就是没有BUG的；因为对于逻辑复杂的语句需要针对不同的输入执行多次。有一些语句，例如上面的panic语句则永远都不会被执行到。另外，还有一些隐晦的错误在现实中很少遇到也很难编写对应的测试代码。测试从本质上来说是一个比较务实的工作，编写测试代码和编写应用代码的成本对比是需要考虑的。测试覆盖率工具可以帮助我们快速识别测试薄弱的地方，但是设计好的测试用例和编写应用代码一样需要严密的思考。</p>
<h2 id="11-4-基准测试"><a href="#11-4-基准测试" class="headerlink" title="11.4. 基准测试"></a>11.4. 基准测试</h2><p>基准测试是测量一个程序在固定工作负载下的性能。在Go语言中，基准测试函数和普通测试函数写法类似，但是以Benchmark为前缀名，并且带有一个<em>testing.B类型的参数；</em>testing.B参数除了提供和*testing.T类似的方法，还有额外一些和性能测量相关的方法。它还提供了一个整数N，用于指定操作执行的循环次数。</p>
<p>下面是IsPalindrome函数的基准测试，其中循环将执行N次。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">import &quot;testing&quot;

func BenchmarkIsPalindrome(b *testing.B) &#123;
    for i :&#x3D; 0; i &lt; b.N; i++ &#123;
        IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;)
    &#125;
&#125;</code></pre>
<p>我们用下面的命令运行基准测试。和普通测试不同的是，默认情况下不运行任何基准测试。我们需要通过-bench命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和-bench&#x3D;IsPalindrome参数是等价的效果。</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">$ cd $GOPATH&#x2F;src&#x2F;gopl.io&#x2F;ch11&#x2F;word2
$ go test -bench&#x3D;.
PASS
BenchmarkIsPalindrome-8 1000000                1035 ns&#x2F;op
ok      gopl.io&#x2F;ch11&#x2F;word2      2.179s</code></pre>
<p>结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的GOMAXPROCS的值，这对于一些与并发相关的基准测试是重要的信息。</p>
<p>报告显示每次调用IsPalindrome函数花费1.035微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。</p>
<p>循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过testing.B参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。</p>
<p>现在我们有了一个基准测试和普通测试，我们可以很容易测试改进程序运行速度的想法。也许最明显的优化是在IsPalindrome函数中第二个循环的停止检查，这样可以避免每个比较都做两次：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">n :&#x3D; len(letters)&#x2F;2
for i :&#x3D; 0; i &lt; n; i++ &#123;
    if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;
        return false
    &#125;
&#125;
return true</code></pre>
<p>不过很多情况下，一个显而易见的优化未必能带来预期的效果。这个改进在基准测试中只带来了4%的性能提升。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go test -bench&#x3D;.
PASS
BenchmarkIsPalindrome-8 1000000              992 ns&#x2F;op
ok      gopl.io&#x2F;ch11&#x2F;word2      2.093s</code></pre>
<p>另一个改进想法是在开始为每个字符预先分配一个足够大的数组，这样就可以避免在append调用时可能会导致内存的多次重新分配。声明一个letters数组变量，并指定合适的大小，像下面这样，</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">letters :&#x3D; make([]rune, 0, len(s))
for _, r :&#x3D; range s &#123;
    if unicode.IsLetter(r) &#123;
        letters &#x3D; append(letters, unicode.ToLower(r))
    &#125;
&#125;</code></pre>
<p>这个改进提升性能约35%，报告结果是基于2,000,000次迭代的平均运行时间统计。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go test -bench&#x3D;.
PASS
BenchmarkIsPalindrome-8 2000000                      697 ns&#x2F;op
ok      gopl.io&#x2F;ch11&#x2F;word2      1.468s</code></pre>
<p>如这个例子所示，快的程序往往是伴随着较少的内存分配。-benchmem命令行标志参数将在报告中包含内存的分配数据统计。我们可以比较优化前后内存的分配情况：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go test -bench&#x3D;. -benchmem
PASS
BenchmarkIsPalindrome    1000000   1026 ns&#x2F;op    304 B&#x2F;op  4 allocs&#x2F;op</code></pre>
<p>这是优化之后的结果：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go test -bench&#x3D;. -benchmem
PASS
BenchmarkIsPalindrome    2000000    807 ns&#x2F;op    128 B&#x2F;op  1 allocs&#x2F;op</code></pre>
<p>用一次内存分配代替多次的内存分配节省了75%的分配调用次数和减少近一半的内存需求。</p>
<p>这个基准测试告诉了我们某个具体操作所需的绝对时间，但我们往往想知道的是两个不同的操作的时间对比。例如，如果一个函数需要1ms处理1,000个元素，那么处理10000或1百万将需要多少时间呢？这样的比较揭示了渐近增长函数的运行时间。另一个例子：I&#x2F;O缓存该设置为多大呢？基准测试可以帮助我们选择在性能达标情况下所需的最小内存。第三个例子：对于一个确定的工作哪种算法更好？基准测试可以评估两种不同算法对于相同的输入在不同的场景和负载下的优缺点。</p>
<p>比较型的基准测试就是普通程序代码。它们通常是单参数的函数，由几个不同数量级的基准测试函数调用，就像这样：</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">func benchmark(b *testing.B, size int) &#123; &#x2F;* ... *&#x2F; &#125;
func Benchmark10(b *testing.B)         &#123; benchmark(b, 10) &#125;
func Benchmark100(b *testing.B)        &#123; benchmark(b, 100) &#125;
func Benchmark1000(b *testing.B)       &#123; benchmark(b, 1000) &#125;</code></pre>
<p>通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。</p>
<p>比较型的基准测试反映出的模式在程序设计阶段是很有帮助的，但是即使程序完工了也应当保留基准测试代码。因为随着项目的发展，或者是输入的增加，或者是部署到新的操作系统或不同的处理器，我们可以再次用基准测试来帮助我们改进设计。</p>
<p>练习 11.6: 为2.6.2节的练习2.4和练习2.5的PopCount函数编写基准测试。看看基于表格算法在不同情况下对提升性能会有多大帮助。</p>
<p>练习 11.7: 为*IntSet（§6.5）的Add、UnionWith和其他方法编写基准测试，使用大量随机输入。你可以让这些方法跑多快？选择字的大小对于性能的影响如何？IntSet和基于内建map的实现相比有多快？</p>
<h2 id="11-5-剖析"><a href="#11-5-剖析" class="headerlink" title="11.5. 剖析"></a>11.5. 剖析</h2><p>基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。每个码农都应该知道Donald Knuth在1974年的“Structured Programming with go to Statements”上所说的格言。虽然经常被解读为不重视性能的意思，但是从原文我们可以看到不同的含义：</p>
<p>毫无疑问，对效率的片面追求会导致各种滥用。程序员会浪费大量的时间在非关键程序的速度上，实际上这些尝试提升效率的行为反倒可能产生很大的负面影响，特别是当调试和维护的时候。我们不应该过度纠结于细节的优化，应该说约97%的场景：过早的优化是万恶之源。</p>
<p>当然我们也不应该放弃对那关键3%的优化。一个好的程序员不会因为这个比例小就裹足不前，他们会明智地观察和识别哪些是关键的代码；但是仅当关键代码已经被确认的前提下才会进行优化。对于很多程序员来说，判断哪部分是关键的性能瓶颈，是很容易犯经验上的错误的，因此一般应该借助测量工具来证明。</p>
<p>当我们想仔细观察我们程序的运行速度的时候，最好的方法是性能剖析。剖析技术是基于程序执行期间一些自动抽样，然后在收尾时进行推断；最后产生的统计结果就称为剖析数据。</p>
<p>Go语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。内建的go test工具对几种分析方式都提供了支持。</p>
<p>CPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。</p>
<p>堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。</p>
<p>阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。</p>
<p>只需要开启下面其中一个标志参数就可以生成各种分析文件。当同时使用多个标志参数时需要当心，因为一项分析操作可能会影响其他项的分析结果。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go test -cpuprofile&#x3D;cpu.out
$ go test -blockprofile&#x3D;block.out
$ go test -memprofile&#x3D;mem.out</code></pre>
<p>对于一些非测试程序也很容易进行剖析，具体的实现方式，与程序是短时间运行的小工具还是长时间运行的服务会有很大不同。剖析对于长期运行的程序尤其有用，因此可以通过调用Go的runtime API来启用运行时剖析。</p>
<p>一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。这是Go工具箱自带的一个工具，但并不是一个日常工具，它对应go tool pprof命令。该命令有许多特性和选项，但是最基本的是两个参数：生成这个概要文件的可执行程序和对应的剖析数据。</p>
<p>为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要对应的可执行程序来解读剖析数据。虽然go test通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对应待测包的名字。</p>
<p>下面的命令演示了如何收集并展示一个CPU分析文件。我们选择net&#x2F;http包的一个基准测试为例。通常最好是对业务关键代码的部分设计专门的基准测试。因为简单的基准测试几乎没法代表业务场景，因此我们用-run&#x3D;NONE参数禁止那些简单测试。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go test -run&#x3D;NONE -bench&#x3D;ClientServerParallelTLS64 \
    -cpuprofile&#x3D;cpu.log net&#x2F;http
 PASS
 BenchmarkClientServerParallelTLS64-8  1000
    3141325 ns&#x2F;op  143010 B&#x2F;op  1747 allocs&#x2F;op
ok       net&#x2F;http       3.395s
</code></pre>
<pre class="language-bash" data-language="bash"><code class="language-bash">
$ go tool pprof -text -nodecount&#x3D;10 .&#x2F;http.test cpu.log
2570ms of 3590ms total (71.59%)
Dropped 129 nodes (cum &lt;&#x3D; 17.95ms)
Showing top 10 nodes out of 166 (cum &gt;&#x3D; 60ms)
    flat  flat%   sum%     cum   cum%
  1730ms 48.19% 48.19%  1750ms 48.75%  crypto&#x2F;elliptic.p256ReduceDegree
   230ms  6.41% 54.60%   250ms  6.96%  crypto&#x2F;elliptic.p256Diff
   120ms  3.34% 57.94%   120ms  3.34%  math&#x2F;big.addMulVVW
   110ms  3.06% 61.00%   110ms  3.06%  syscall.Syscall
    90ms  2.51% 63.51%  1130ms 31.48%  crypto&#x2F;elliptic.p256Square
    70ms  1.95% 65.46%   120ms  3.34%  runtime.scanobject
    60ms  1.67% 67.13%   830ms 23.12%  crypto&#x2F;elliptic.p256Mul
    60ms  1.67% 68.80%   190ms  5.29%  math&#x2F;big.nat.montgomery
    50ms  1.39% 70.19%    50ms  1.39%  crypto&#x2F;elliptic.p256ReduceCarry
    50ms  1.39% 71.59%    60ms  1.67%  crypto&#x2F;elliptic.p256Sum
</code></pre>
<p>参数-text用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。其中-nodecount&#x3D;10参数限制了只输出前10行的结果。对于严重的性能问题，这个文本格式基本可以帮助查明原因了。</p>
<p>这个概要文件告诉我们，HTTPS基准测试中crypto&#x2F;elliptic.p256ReduceDegree函数占用了将近一半的CPU资源，对性能占很大比重。相比之下，如果一个概要文件中主要是runtime包的内存分配的函数，那么减少内存消耗可能是一个值得尝试的优化策略。</p>
<p>对于一些更微妙的问题，你可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具，可以从 <a target="_blank" rel="noopener" href="http://www.graphviz.org/">http://www.graphviz.org</a> 下载。参数-web用于生成函数的有向图，标注有CPU的使用和最热点的函数等信息。</p>
<p>这一节我们只是简单看了下Go语言的数据分析工具。如果想了解更多，可以阅读Go官方博客的“Profiling Go Programs”一文。</p>
<h2 id="11-6-示例函数"><a href="#11-6-示例函数" class="headerlink" title="11.6 示例函数"></a>11.6 示例函数</h2><p>第三种被go test特别对待的函数是示例函数，以Example为函数名开头。示例函数没有函数参数和返回值。下面是IsPalindrome函数对应的示例函数：</p>
<p>func ExampleIsPalindrome() {<br>    fmt.Println(IsPalindrome(“A man, a plan, a canal: Panama”))<br>    fmt.Println(IsPalindrome(“palindrome”))<br>    &#x2F;&#x2F; Output:<br>    &#x2F;&#x2F; true<br>    &#x2F;&#x2F; false<br>}<br>示例函数有三个用处。最主要的一个是作为文档：一个包的例子可以更简洁直观的方式来演示函数的用法，比文字描述更直接易懂，特别是作为一个提醒或快速参考时。一个示例函数也可以方便展示属于同一个接口的几种类型或函数之间的关系，所有的文档都必须关联到一个地方，就像一个类型或函数声明都统一到包一样。同时，示例函数和注释并不一样，示例函数是真实的Go代码，需要接受编译器的编译时检查，这样可以保证源代码更新时，示例代码不会脱节。</p>
<p>根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。</p>
<p>示例函数的第二个用处是，在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的&#x2F;&#x2F; Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配。</p>
<p>示例函数的第三个目的提供一个真实的演练场。 <a target="_blank" rel="noopener" href="http://golang.org/">http://golang.org</a> 就是由godoc提供的文档服务，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数，就像图11.4所示的那样。这通常是学习函数使用或Go语言特性最快捷的方式。</p>
<p><img src="/./asset/ch11-04.png" alt="示例函数"></p>
<p>本书最后的两章是讨论reflect和unsafe包，一般的Go程序员很少使用它们，事实上也很少需要用到。因此，如果你还没有写过任何真实的Go程序的话，现在可以先去写些代码了。</p>
<p>appendIndex</p>
<pre class="language-text" data-language="text"><code class="language-text">
一个测试函数是以`Test`为函数名前缀的函数
一个基准测试函数是以`Benchmark`为函数名前缀的函数
一个示例函数是以`Example`为函数名前缀的函数，提供一个由编译器保证正确性的示例文档

```golang
- `go test -v `会打印每个函数的名字和运行时间
- `go test -run= `会去匹配正则表达式，只有被匹配到的才会被执行
- `go test -v ./...` 执行所有当前目录下测试cases
- `go test -v foo/...` 执行foo目录下所有cases
- `go test -v foo...` 执行指定前缀的测试cases
- `go test ...` gopath下所有测试cases
- `go test -v hello_test.go` 执行某一文件下的测试cases,但是该文件中如果调用了其它文件中的模块会报错
- `go test -v hello_test.go -test.run TestHello` 测试单个函数</code></pre>

<ul>
<li><p>组织多个测试用例</p>
<p>即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息,可以使用<code>t.Fatal</code>或<code>t.Fatalf</code>停止当前测试函数</p>
  <details>
  <summary>组织多测试用例</summary>
  <pre>

  <pre class="language-golang" data-language="golang"><code class="language-golang">func TestIsPalindrome(t *testing.T) &#123;
var tests &#x3D; []struct &#123;
    input string
    want  bool
&#125;&#123;
        &#123;&quot;&quot;, true&#125;,
        &#123;&quot;a&quot;, true&#125;,
        &#123;&quot;aa&quot;, true&#125;,
        &#123;&quot;ab&quot;, false&#125;,
        &#123;&quot;kayak&quot;, true&#125;,
        &#123;&quot;detartrated&quot;, true&#125;,
        &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;,
        &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;,
        &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;,
        &#123;&quot;été&quot;, true&#125;,
        &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;,
        &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome
        &#123;&quot;desserts&quot;, false&#125;,   &#x2F;&#x2F; semi-palindrome
    &#125;
    for _, test :&#x3D; range tests &#123;
        if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123;
            t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got)
        &#125;
    &#125;
&#125;</code></pre>

<p>  </pre></p>
  </details>
</li>
<li><p>随机测试</p>
<ol>
<li>编写对照函数，效率低下</li>
<li>生成的随机输入的数据遵循特定的模式，然后就知道期望的输出</li>
</ol>
<pre class="language-golang" data-language="golang"><code class="language-golang">
import &quot;math&#x2F;rand&quot;

  &#x2F;&#x2F; randomPalindrome returns a palindrome whose length and contents
  &#x2F;&#x2F; are derived from the pseudo-random number generator rng.
  func randomPalindrome(rng *rand.Rand) string &#123;
      n :&#x3D; rng.Intn(25) &#x2F;&#x2F; random length up to 24
      runes :&#x3D; make([]rune, n)
      for i :&#x3D; 0; i &lt; (n+1)&#x2F;2; i++ &#123;
          r :&#x3D; rune(rng.Intn(0x1000)) &#x2F;&#x2F; random rune up to &#39;\u0999&#39;
          runes[i] &#x3D; r
          runes[n-1-i] &#x3D; r
      &#125;
      return string(runes)
  &#125;

  func TestRandomPalindromes(t *testing.T) &#123;
      &#x2F;&#x2F; Initialize a pseudo-random number generator.
      seed :&#x3D; time.Now().UTC().UnixNano()
      t.Logf(&quot;Random seed: %d&quot;, seed)
      rng :&#x3D; rand.New(rand.NewSource(seed))

      for i :&#x3D; 0; i &lt; 1000; i++ &#123;
          p :&#x3D; randomPalindrome(rng)
          if !IsPalindrome(p) &#123;
              t.Errorf(&quot;IsPalindrome(%q) &#x3D; false&quot;, p)
          &#125;
      &#125;
  &#125;
  &#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.
  &#x2F;&#x2F; Letter case is ignored, as are non-letters.
  func IsPalindrome(s string) bool &#123;
      var letters []rune
      for _, r :&#x3D; range s &#123;
          if unicode.IsLetter(r) &#123;
              letters &#x3D; append(letters, unicode.ToLower(r))
          &#125;
      &#125;
      for i :&#x3D; range letters &#123;
          if letters[i] !&#x3D; letters[len(letters)-1-i] &#123;
              return false
          &#125;
      &#125;
      return true
  &#125;
</code></pre>
</li>
<li><p>测试一个命令(测试内部未导出函数)</p>
<p>要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。要注意的是在测试代码中并没有调用<code>log.Fatal</code>或<code>os.Exit</code>，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理,如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理.导出内部函数,</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; src&#x2F;bytes&#x2F;export_test.go
  package bytes
  &#x2F;&#x2F; Export func for testing
  var IndexBytePortable &#x3D; indexBytePortable &#x2F;&#x2F; 赋值给包级可导出变量</code></pre>

<p>然后通过外部包进行测试</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">
&#x2F;&#x2F; src&#x2F;bytes&#x2F;bytes_test.go
  package bytes_test

  func TestIndexByte(t *testing.T) &#123;
      for _, tt :&#x3D; range indexTests &#123;
          ... 代码片段
          posp :&#x3D; IndexBytePortable(a, b) &#x2F;&#x2F; 导出的内部方法在这里被使用
          if posp !&#x3D; tt.i &#123;
              t.Errorf(&#96;indexBytePortable(%q, &#39;%c&#39;) &#x3D; %v&#96;, tt.a, b, posp)
          &#125;
      &#125;
  &#125;
</code></pre>

<p>还有种方式就是不导出，直接在包名下写测试函数，然后进行测试源代码</p>
</li>
<li><p>白盒测试</p>
<p>TBC,代码的内部实现对于测试人员来说是可见的，言外之意就是能看到内部实现,测试内部实现，这个实现可能是未导出的</p>
</li>
<li><p>外部测试包</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">package pprint_test
  &#x2F;&#x2F;这时候就可以在
  import (
      &quot;gott&#x2F;hi&quot;
      &#x2F;&#x2F; 导入 要进行测试的 pprint 包本身
      &quot;gott&#x2F;pprint&quot;
      &quot;testing&quot;
  )

  func TestPPrint(t *testing.T) &#123;
      pprint.PPrint()
      hi.Say()
      t.Log(&quot;expect call PPrint&quot;)
  &#125;
  </code></pre>

<p>使用 Go 官方的代码风格：pprint_test.go 文件，因为pprint_test在 pprint 目录下，通过在 import 时，使用<code>.</code>选项，可以直接调用PPrint()方法</p>
</li>
<li><p>编写有效的测试</p>
<ol>
<li>一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息</li>
<li>一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律</li>
<li>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试</li>
</ol>
</li>
<li><p>避免脆弱的测试<br>TBC</p>
</li>
</ul>
<p> 11.2 测试覆盖率</p>
<p>对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化(应该是有)</p>
<ol>
<li>go test -run&#x3D;Coverage -coverprofile&#x3D;c.out gopl.io&#x2F;ch7&#x2F;eval</li>
<li>go test -run&#x3D;Coverage -covermode&#x3D;count gopl.io&#x2F;ch7&#x2F;eval</li>
</ol>
<p> 11.3 基准测试</p>
<ol start="3">
<li><code>-bench</code>也是正则匹配,BenchmarkIsPalindrome-8,8表示的是GOMAXPROCS的值,<code>-benchmem</code>命令行标志参数将在报告中包含内存的分配数据统计</li>
<li>比较型的基准测试就是普通程序代码,它们通常是单参数的函数，由几个不同数量级的基准测试函数调用,通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。所有的测试cases都要保留，随着项目的发展，都需要做回归测试</li>
</ol>
<p> 11.4 刨析</p>
<p>TBC</p>
<p> 11.5 示例函数</p>
<p>示例函数有三个用处。</p>
<ol>
<li>最主要的一个是作为文档，根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。</li>
<li>在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的&#x2F;&#x2F; Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配</li>
<li>提供一个真实的演练场，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数</li>
</ol>
<pre><code>

# 12. appendIndex

1. 线程内再重启一个线程，然后就可以通过加锁，进行隔离开，但此时任然是两个线程的间的交替
</code></pre>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/11/oracle/Oracle_EBR/"
                    data-tooltip="Edition-Based Redefinition Technical Deep Dive"
                    aria-label="PREVIOUS: Edition-Based Redefinition Technical Deep Dive"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/08/golang/golang_standard_doc/go_documentation/"
                    data-tooltip="go标准库阅读与解析"
                    aria-label="NEXT: go标准库阅读与解析"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/11/oracle/Oracle_EBR/"
                    data-tooltip="Edition-Based Redefinition Technical Deep Dive"
                    aria-label="PREVIOUS: Edition-Based Redefinition Technical Deep Dive"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/08/golang/golang_standard_doc/go_documentation/"
                    data-tooltip="go标准库阅读与解析"
                    aria-label="NEXT: go标准库阅读与解析"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href=""
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"
                        aria-label="global.share_on_wechat"
                    >
                        <i class="fa-foo_bar" aria-hidden="true"></i><span>global.share_on_wechat</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Canton
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-4u8r0fo0pgap8c0kebqie2krcfxcv3h259cjxizeggkmknhnwzjt04ztqpi1.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'ca29b9a1203b5920918d',
              clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
              repo: 'SimonTeo58.github.io',
              owner: 'SimonTeo58',
              admin: ['SimonTeo58'],
              id: '2022/10/08/golang/go语言圣经/go语言圣经/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
