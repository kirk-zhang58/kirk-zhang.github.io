
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CoffeeMan">
    <title>go标准库阅读与解析 - CoffeeMan</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://simonteo58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg"},"articleBody":"abstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.\n\n\n\npackage tar  Package tar implements access to tar archives.\n  Tape(封装,胶带) archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.\nConstants  const (\n  &#x2F;&#x2F; Type &#39;0&#39; indicates a regular file.\n  TypeReg  &#x3D; &#39;0&#39;\n  TypeRegA &#x3D; &#39;\\x00&#39; &#x2F;&#x2F; Deprecated: Use TypeReg instead.\n\n  &#x2F;&#x2F; Type &#39;1&#39; to &#39;6&#39; are header-only flags and may not have a data body.\n  TypeLink    &#x3D; &#39;1&#39; &#x2F;&#x2F; Hard link\n  TypeSymlink &#x3D; &#39;2&#39; &#x2F;&#x2F; Symbolic link\n  TypeChar    &#x3D; &#39;3&#39; &#x2F;&#x2F; Character device node\n  TypeBlock   &#x3D; &#39;4&#39; &#x2F;&#x2F; Block device node\n  TypeDir     &#x3D; &#39;5&#39; &#x2F;&#x2F; Directory\n  TypeFifo    &#x3D; &#39;6&#39; &#x2F;&#x2F; FIFO node\n\n  &#x2F;&#x2F; Type &#39;7&#39; is reserved.\n  TypeCont &#x3D; &#39;7&#39;\n\n  &#x2F;&#x2F; Type &#39;x&#39; is used by the PAX format to store key-value records that\n  &#x2F;&#x2F; are only relevant to the next file.\n  &#x2F;&#x2F; This package transparently handles these types.\n  TypeXHeader &#x3D; &#39;x&#39;\n\n  &#x2F;&#x2F; Type &#39;g&#39; is used by the PAX format to store key-value records that\n  &#x2F;&#x2F; are relevant to all subsequent files.\n  &#x2F;&#x2F; This package only supports parsing and composing such headers,\n  &#x2F;&#x2F; but does not currently support persisting the global state across files.\n  TypeXGlobalHeader &#x3D; &#39;g&#39;\n\n  &#x2F;&#x2F; Type &#39;S&#39; indicates a sparse file in the GNU format.\n  TypeGNUSparse &#x3D; &#39;S&#39;\n\n  &#x2F;&#x2F; Types &#39;L&#39; and &#39;K&#39; are used by the GNU format for a meta file\n  &#x2F;&#x2F; used to store the path or link name for the next file.\n  &#x2F;&#x2F; This package transparently handles these types.\n  TypeGNULongName &#x3D; &#39;L&#39;\n  TypeGNULongLink &#x3D; &#39;K&#39;\n)\n\nVariables  var (\n  ErrHeader          &#x3D; errors.New(&quot;archive&#x2F;tar: invalid tar header&quot;)\n  ErrWriteTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: write too long&quot;)\n  ErrFieldTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: header field too long&quot;)\n  ErrWriteAfterClose &#x3D; errors.New(&quot;archive&#x2F;tar: write after close&quot;)\n)\n\ntype Format  type Format int\n\n  Format represents the tar archive format.The original tar format was introduced in Unix V7. Since then, there have been multiple competing(相互竞争) formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.\n  The following table captures the capabilities of each format:\n                    |  USTAR |       PAX |       GNU\n------------------+--------+-----------+----------\nName              |   256B | unlimited | unlimited\nLinkname          |   100B | unlimited | unlimited\nSize              | uint33 | unlimited |    uint89\nMode              | uint21 |    uint21 |    uint57\nUid&#x2F;Gid           | uint21 | unlimited |    uint57\nUname&#x2F;Gname       |    32B | unlimited |       32B\nModTime           | uint33 | unlimited |     int89\nAccessTime        |    n&#x2F;a | unlimited |     int89\nChangeTime        |    n&#x2F;a | unlimited |     int89\nDevmajor&#x2F;Devminor | uint21 |    uint21 |    uint57\n------------------+--------+-----------+----------\nstring encoding   |  ASCII |     UTF-8 |    binary\nsub-second times  |     no |       yes |        no\nsparse files      |     no |       yes |       yes\n\n  The table’s upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).\n  The table’s lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.\n  The Writer currently provides no support for sparse files.\n  const (\n\n&#x2F;&#x2F; FormatUnknown indicates that the format is unknown.\nFormatUnknown Format\n&#x2F;&#x2F; FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.\n&#x2F;&#x2F;\n&#x2F;&#x2F; While this format is compatible with most tar readers,\n&#x2F;&#x2F; the format has several limitations making it unsuitable for some usages.\n&#x2F;&#x2F; Most notably, it cannot support sparse files, files larger than 8GiB,\n&#x2F;&#x2F; filenames larger than 256 characters, and non-ASCII filenames.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Reference:\n&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;pax.html#tag_20_92_13_06\nFormatUSTAR\n&#x2F;&#x2F; FormatPAX represents the PAX header format defined in POSIX.1-2001.\n&#x2F;&#x2F;\n&#x2F;&#x2F; PAX extends USTAR by writing a special file with Typeflag TypeXHeader\n&#x2F;&#x2F; preceding the original header. This file contains a set of key-value\n&#x2F;&#x2F; records, which are used to overcome USTAR\\&#39;s shortcomings, in addition to\n&#x2F;&#x2F; providing the ability to have sub-second resolution for timestamps.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Some newer formats add their own extensions to PAX by defining their\n&#x2F;&#x2F; own keys and assigning certain semantic meaning to the associated values.\n&#x2F;&#x2F; For example, sparse file support in PAX is implemented using keys\n&#x2F;&#x2F; defined by the GNU manual (e.g., &quot;GNU.sparse.map&quot;).\n&#x2F;&#x2F;\n&#x2F;&#x2F; Reference:\n&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;utilities&#x2F;pax.html\nFormatPAX\n&#x2F;&#x2F; FormatGNU represents the GNU header format.\n&#x2F;&#x2F;\n&#x2F;&#x2F; The GNU header format is older than the USTAR and PAX standards and\n&#x2F;&#x2F; is not compatible with them. The GNU format supports\n&#x2F;&#x2F; arbitrary file sizes, filenames of arbitrary encoding and length,\n&#x2F;&#x2F; sparse files, and other features.\n&#x2F;&#x2F;\n&#x2F;&#x2F; It is recommended that PAX be chosen over GNU unless the target\n&#x2F;&#x2F; application can only parse GNU formatted archives.\n&#x2F;&#x2F;\n&#x2F;&#x2F; Reference:\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;tar&#x2F;manual&#x2F;html_node&#x2F;Standard.html\nFormatGNU\n)\n\n\nfunc (f Format) String() string  打印tar的格式\ntype Header    type Header struct &#123;\n  &#x2F;&#x2F; Typeflag is the type of header entry.\n  &#x2F;&#x2F; The zero value is automatically promoted to either TypeReg or TypeDir\n  &#x2F;&#x2F; depending on the presence of a trailing slash in Name.\n  Typeflag byte\n\n  Name     string &#x2F;&#x2F; Name of file entry\n  Linkname string &#x2F;&#x2F; Target name of link (valid for TypeLink or TypeSymlink)\n\n  Size  int64  &#x2F;&#x2F; Logical file size in bytes\n  Mode  int64  &#x2F;&#x2F; Permission and mode bits\n  Uid   int    &#x2F;&#x2F; User ID of owner\n  Gid   int    &#x2F;&#x2F; Group ID of owner\n  Uname string &#x2F;&#x2F; User name of owner\n  Gname string &#x2F;&#x2F; Group name of owner\n\n  &#x2F;&#x2F; If the Format is unspecified, then Writer.WriteHeader rounds ModTime\n  &#x2F;&#x2F; to the nearest second and ignores the AccessTime and ChangeTime fields.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; To use AccessTime or ChangeTime, specify the Format as PAX or GNU.\n  &#x2F;&#x2F; To use sub-second resolution, specify the Format as PAX.\n  ModTime    time.Time &#x2F;&#x2F; Modification time\n  AccessTime time.Time &#x2F;&#x2F; Access time (requires either PAX or GNU support)\n  ChangeTime time.Time &#x2F;&#x2F; Change time (requires either PAX or GNU support)\n\n  Devmajor int64 &#x2F;&#x2F; Major device number (valid for TypeChar or TypeBlock)\n  Devminor int64 &#x2F;&#x2F; Minor device number (valid for TypeChar or TypeBlock)\n\n  &#x2F;&#x2F; Xattrs stores extended attributes as PAX records under the\n  &#x2F;&#x2F; &quot;SCHILY.xattr.&quot; namespace.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; The following are semantically equivalent:\n  &#x2F;&#x2F;  h.Xattrs[key] &#x3D; value\n  &#x2F;&#x2F;  h.PAXRecords[&quot;SCHILY.xattr.&quot;+key] &#x3D; value\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; When Writer.WriteHeader is called, the contents of Xattrs will take\n  &#x2F;&#x2F; precedence over those in PAXRecords.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; Deprecated: Use PAXRecords instead.\n  Xattrs map[string]string\n\n  &#x2F;&#x2F; PAXRecords is a map of PAX extended header records.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; User-defined records should have keys of the following form:\n  &#x2F;&#x2F;\tVENDOR.keyword\n  &#x2F;&#x2F; Where VENDOR is some namespace in all uppercase, and keyword may\n  &#x2F;&#x2F; not contain the &#39;&#x3D;&#39; character (e.g., &quot;GOLANG.pkg.version&quot;).\n  &#x2F;&#x2F; The key and value should be non-empty UTF-8 strings.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; When Writer.WriteHeader is called, PAX records derived from the\n  &#x2F;&#x2F; other fields in Header take precedence over PAXRecords.\n  PAXRecords map[string]string\n\n  &#x2F;&#x2F; Format specifies the format of the tar header.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; This is set by Reader.Next as a best-effort guess at the format.\n  &#x2F;&#x2F; Since the Reader liberally reads some non-compliant files,\n  &#x2F;&#x2F; it is possible for this to be FormatUnknown.\n  &#x2F;&#x2F;\n  &#x2F;&#x2F; If the format is unspecified when Writer.WriteHeader is called,\n  &#x2F;&#x2F; then it uses the first format (in the order of USTAR, PAX, GNU)\n  &#x2F;&#x2F; capable of encoding this Header (see Format).\n  Format Format\n&#125;\n\n\nfunc FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)func (h*Header) FileInfo() fs.FileInfotype Readerfunc NewReader(r io.Reader) *Readerfunc (tr*Reader) Next() (*Header, error)func (tr*Reader) Read(b []byte) (int, error)type Writerfunc NewWriter(w io.Writer) *Writerfunc (tw*Writer) Close() errorfunc (tw *Writer) Flush() errorfunc (tw*Writer) Write(b []byte) (int, error)func (tw Writer) WriteHeader(hdrHeader) errorzip packagePackage zip provides support for reading and writing ZIP archives.\nConstants  const (\n  Store   uint16 &#x3D; 0 &#x2F;&#x2F; no compression\n  Deflate uint16 &#x3D; 8 &#x2F;&#x2F; DEFLATE compressed\n)\n\nVariables  var (\n  ErrFormat    &#x3D; errors.New(&quot;zip: not a valid zip file&quot;)\n  ErrAlgorithm &#x3D; errors.New(&quot;zip: unsupported compression algorithm&quot;)\n  ErrChecksum  &#x3D; errors.New(&quot;zip: checksum error&quot;)\n)\n\n\nfunc RegisterCompressor(method uint16, comp Compressor)func RegisterDecompressor(method uint16, dcomp Decompressor)type Compressortype Decompressortype Filefunc (f *File) DataOffset() (offset int64, err error)func (f*File) Open() (io.ReadCloser, error)func (f *File) OpenRaw() (io.Reader, error)type FileHeaderfunc FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)func (h *FileHeader) FileInfo() fs.FileInfofunc (h*FileHeader) ModTime() time.TimeDEPRECATEDfunc (h *FileHeader) Mode() (mode fs.FileMode)func (h*FileHeader) SetModTime(t time.Time)DEPRECATEDfunc (h *FileHeader) SetMode(mode fs.FileMode)type ReadCloserfunc OpenReader(name string) (*ReadCloser, error)func (rc *ReadCloser) Close() errortype Readerfunc NewReader(r io.ReaderAt, size int64) (*Reader, error)func (r *Reader) Open(name string) (fs.File, error)func (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)type Writerfunc NewWriter(w io.Writer) *Writerfunc (w*Writer) Close() errorfunc (w *Writer) Copy(f*File) errorfunc (w *Writer) Create(name string) (io.Writer, error)func (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)func (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)func (w*Writer) Flush() errorfunc (w *Writer) RegisterCompressor(method uint16, comp Compressor)func (w*Writer) SetComment(comment string) errorfunc (w *Writer) SetOffset(n int64)bufioPackage bufio implements buffered I&#x2F;O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual(adj.本文的,按原文的) I&#x2F;O.\nConstants\nconst (\n\t&#x2F;&#x2F; MaxScanTokenSize is the maximum size used to buffer a token\n\t&#x2F;&#x2F; unless the user provides an explicit buffer with Scanner.Buffer.\n\t&#x2F;&#x2F; The actual maximum token size may be smaller as the buffer\n\t&#x2F;&#x2F; may need to include, for instance, a newline.\n\tMaxScanTokenSize &#x3D; 64 * 1024\n)\nVariables\nvar (\n\tErrInvalidUnreadByte &#x3D; errors.New(&quot;bufio: invalid use of UnreadByte&quot;)\n\tErrInvalidUnreadRune &#x3D; errors.New(&quot;bufio: invalid use of UnreadRune&quot;)\n\tErrBufferFull        &#x3D; errors.New(&quot;bufio: buffer full&quot;)\n\tErrNegativeCount     &#x3D; errors.New(&quot;bufio: negative count&quot;)\n)\nvar (\n\tErrTooLong         &#x3D; errors.New(&quot;bufio.Scanner: token too long&quot;)\n\tErrNegativeAdvance &#x3D; errors.New(&quot;bufio.Scanner: SplitFunc returns negative advance count&quot;)\n\tErrAdvanceTooFar   &#x3D; errors.New(&quot;bufio.Scanner: SplitFunc returns advance count beyond input&quot;)\n\tErrBadReadCount    &#x3D; errors.New(&quot;bufio.Scanner: Read returned impossible count&quot;)\n)\nErrors returned by Scanner.\nvar ErrFinalToken &#x3D; errors.New(&quot;final token&quot;)\n\nErrFinalToken is a special sentinel error value. It is intended to be returned by a Split(vt.分离) function to indicate that the token being delivered with the error is the last token and scanning should stop after this one. After ErrFinalToken is received by Scan, scanning stops with no error. The value is useful to stop processing early or when it is necessary to deliver a final empty token. One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value.\nfunc ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)ScanBytes is a split function for a Scanner that returns each byte as a token.\nfunc ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)type ReadWritertype ReadWriter struct &#123;\n\t*Reader\n\t*Writer\n&#125;\n\nfunc NewReadWriter(r *Reader, w *Writer) *ReadWritertype Readertype Reader struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc NewReader(rd io.Reader) *Readerfunc NewReaderSize(rd io.Reader, size int) *Readerfunc (b *Reader) Buffered() intfunc (b *Reader) Discard(n int) (discarded int, err error)func (b *Reader) Peek(n int) ([]byte, error)func (b *Reader) Read(p []byte) (n int, err error)func (b *Reader) ReadByte() (byte, error)func (b *Reader) ReadBytes(delim byte) ([]byte, error)func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)func (b *Reader) ReadRune() (r rune, size int, err error)func (b *Reader) ReadSlice(delim byte) (line []byte, err error)func (b *Reader) ReadString(delim byte) (string, error)func (b *Reader) Reset(r io.Reader)func (b *Reader) Size() intfunc (b *Reader) UnreadByte() errorfunc (b *Reader) UnreadRune() errorfunc (b *Reader) WriteTo(w io.Writer) (n int64, err error)type Scannertype Scanner struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc NewScanner(r io.Reader) *Scannerfunc (s *Scanner) Buffer(buf []byte, max int)func (s *Scanner) Bytes() []bytefunc (s *Scanner) Err() errorfunc (s *Scanner) Scan() boolfunc (s *Scanner) Split(split SplitFunc)func (s *Scanner) Text() stringtype SplitFunctype SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)\n\ntype Writertype Writer struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n\nfunc NewWriter(w io.Writer) *Writerfunc NewWriterSize(w io.Writer, size int) *Writerfunc (b *Writer) Available() intfunc (b *Writer) AvailableBuffer() []bytefunc (b *Writer) Buffered() intfunc (b *Writer) Flush() errorfunc (b *Writer) ReadFrom(r io.Reader) (n int64, err error)func (b *Writer) Reset(w io.Writer)func (b *Writer) Size() intfunc (b *Writer) Write(p []byte) (nn int, err error)func (b *Writer) WriteByte(c byte) errorfunc (b *Writer) WriteRune(r rune) (size int, err error)func (b *Writer) WriteString(s string) (int, error)builtinPackage builtin provides documentation for Go’s predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language’s special identifiers.\nConstants\nconst (\n\ttrue  &#x3D; 0 &#x3D;&#x3D; 0 &#x2F;&#x2F; Untyped bool.\n\tfalse &#x3D; 0 !&#x3D; 0 &#x2F;&#x2F; Untyped bool.\n)\nconst iota &#x3D; 0 &#x2F;&#x2F; Untyped int.\n\nvariables\nvar nil Type &#x2F;&#x2F; Type must be a pointer, channel, func, interface, map, or slice type\n\nfunc append(slice []Type, elems …Type) []Typefunc cap(v Type) intfunc close(c chan&lt;- Type)func complex(r, i FloatType) ComplexTypefunc copy(dst, src []Type) intfunc delete(m map[Type]Type1, key Type)func imag(c ComplexType) FloatTypefunc len(v Type) intfunc make(t Type, size …IntegerType) Typefunc new(Type) *Typefunc panic(v any)func print(args …Type)func println(args …Type)func real(c ComplexType) FloatTypefunc recover() anytype ComplexTypetype FloatTypetype IntegerTypetype Typetype Type1type anytype booltype bytetype comparabletype complex128type complex64type errortype float32type float64type inttype int16type int32type int64type int8type runetype stringtype uinttype uint16type uint32type uint64type uint8type uintptrbytesPackage bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.\nconstants\nconst MinRead &#x3D; 512\n\nvariables\nvar ErrTooLarge &#x3D; errors.New(&quot;bytes.Buffer: too large&quot;)\n\nfunc Compare(a, b []byte) intfunc Contains(b, subslice []byte) boolfunc ContainsAny(b []byte, chars string) boolfunc ContainsRune(b []byte, r rune) boolfunc Count(s, sep []byte) intfunc Cut(s, sep []byte) (before, after []byte, found bool)func Equal(a, b []byte) boolfunc EqualFold(s, t []byte) boolfunc Fields(s []byte) [][]bytefunc FieldsFunc(s []byte, f func(rune) bool) [][]bytefunc HasPrefix(s, prefix []byte) boolfunc HasSuffix(s, suffix []byte) boolfunc Index(s, sep []byte) intfunc IndexAny(s []byte, chars string) intfunc IndexByte(b []byte, c byte) intfunc IndexFunc(s []byte, f func(r rune) bool) intfunc IndexRune(s []byte, r rune) intfunc Join(s [][]byte, sep []byte) []bytefunc LastIndex(s, sep []byte) intfunc LastIndexAny(s []byte, chars string) intfunc LastIndexByte(s []byte, c byte) intfunc LastIndexFunc(s []byte, f func(r rune) bool) intfunc Map(mapping func(r rune) rune, s []byte) []bytefunc Repeat(b []byte, count int) []bytefunc Replace(s, old, new []byte, n int) []bytefunc ReplaceAll(s, old, new []byte) []bytefunc Runes(s []byte) []runefunc Split(s, sep []byte) [][]bytefunc SplitAfter(s, sep []byte) [][]bytefunc SplitAfterN(s, sep []byte, n int) [][]bytefunc SplitN(s, sep []byte, n int) [][]bytefunc Title(s []byte) []byteDEPRECATEDfunc ToLower(s []byte) []bytefunc ToLowerSpecial(c unicode.SpecialCase, s []byte) []bytefunc ToTitle(s []byte) []bytefunc ToTitleSpecial(c unicode.SpecialCase, s []byte) []bytefunc ToUpper(s []byte) []bytefunc ToUpperSpecial(c unicode.SpecialCase, s []byte) []bytefunc ToValidUTF8(s, replacement []byte) []bytefunc Trim(s []byte, cutset string) []bytefunc TrimFunc(s []byte, f func(r rune) bool) []bytefunc TrimLeft(s []byte, cutset string) []bytefunc TrimLeftFunc(s []byte, f func(r rune) bool) []bytefunc TrimPrefix(s, prefix []byte) []bytefunc TrimRight(s []byte, cutset string) []bytefunc TrimRightFunc(s []byte, f func(r rune) bool) []bytefunc TrimSpace(s []byte) []bytefunc TrimSuffix(s, suffix []byte) []bytetype Bufferfunc NewBuffer(buf []byte) *Bufferfunc NewBufferString(s string) *Bufferfunc (b *Buffer) Bytes() []bytefunc (b *Buffer) Cap() intfunc (b *Buffer) Grow(n int)func (b *Buffer) Len() intfunc (b *Buffer) Next(n int) []bytefunc (b *Buffer) Read(p []byte) (n int, err error)func (b *Buffer) ReadByte() (byte, error)func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)func (b *Buffer) ReadRune() (r rune, size int, err error)func (b *Buffer) ReadString(delim byte) (line string, err error)func (b *Buffer) Reset()func (b *Buffer) String() stringfunc (b *Buffer) Truncate(n int)func (b *Buffer) UnreadByte() errorfunc (b *Buffer) UnreadRune() errorfunc (b *Buffer) Write(p []byte) (n int, err error)func (b *Buffer) WriteByte(c byte) errorfunc (b *Buffer) WriteRune(r rune) (n int, err error)func (b *Buffer) WriteString(s string) (n int, err error)func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)type Readerfunc NewReader(b []byte) *Readerfunc (r *Reader) Len() intfunc (r *Reader) Read(b []byte) (n int, err error)func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)func (r *Reader) ReadByte() (byte, error)func (r *Reader) ReadRune() (ch rune, size int, err error)func (r *Reader) Reset(b []byte)func (r *Reader) Seek(offset int64, whence int) (int64, error)func (r *Reader) Size() int64func (r *Reader) UnreadByte() errorfunc (r *Reader) UnreadRune() errorfunc (r *Reader) WriteTo(w io.Writer) (n int64, err error)compressbzip2Package bzip2 implements bzip2 decompression.\nfunc NewReader(r io.Reader) io.Readertype StructuralErrorfunc (s StructuralError) Error() stringflatePackage flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats.\nConstants\nconst (\n\tNoCompression      &#x3D; 0\n\tBestSpeed          &#x3D; 1\n\tBestCompression    &#x3D; 9\n\tDefaultCompression &#x3D; -1\n\n\t&#x2F;&#x2F; HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman\n\t&#x2F;&#x2F; entropy encoding. This mode is useful in compressing data that has\n\t&#x2F;&#x2F; already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)\n\t&#x2F;&#x2F; that lacks an entropy encoder. Compression gains are achieved when\n\t&#x2F;&#x2F; certain bytes in the input stream occur more frequently than others.\n\t&#x2F;&#x2F;\n\t&#x2F;&#x2F; Note that HuffmanOnly produces a compressed output that is\n\t&#x2F;&#x2F; RFC 1951 compliant. That is, any valid DEFLATE decompressor will\n\t&#x2F;&#x2F; continue to be able to decompress this output.\n\tHuffmanOnly &#x3D; -2\n)\nfunc NewReader(r io.Reader) io.ReadCloserfunc NewReaderDict(r io.Reader, dict []byte) io.ReadClosertype CorruptInputErrorfunc (e CorruptInputError) Error() stringtype InternalErrorfunc (e InternalError) Error() stringtype ReadErrorDEPRECATEDfunc (e *ReadError) Error() stringtype Readertype Resettertype WriteErrorDEPRECATEDfunc (e *WriteError) Error() stringtype Writerfunc NewWriter(w io.Writer, level int) (*Writer, error)func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)func (w *Writer) Close() errorfunc (w *Writer) Flush() errorfunc (w *Writer) Reset(dst io.Writer)func (w *Writer) Write(data []byte) (n int, err error)gzipPackage gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.\nConstants\nconst (\n\tNoCompression      &#x3D; flate.NoCompression\n\tBestSpeed          &#x3D; flate.BestSpeed\n\tBestCompression    &#x3D; flate.BestCompression\n\tDefaultCompression &#x3D; flate.DefaultCompression\n\tHuffmanOnly        &#x3D; flate.HuffmanOnly\n)\nThese constants are copied from the flate package, so that code that imports “compress&#x2F;gzip” does not also have to import “compress&#x2F;flate”.\nVariables\nvar (\n\t&#x2F;&#x2F; ErrChecksum is returned when reading GZIP data that has an invalid checksum.\n\tErrChecksum &#x3D; errors.New(&quot;gzip: invalid checksum&quot;)\n\t&#x2F;&#x2F; ErrHeader is returned when reading GZIP data that has an invalid header.\n\tErrHeader &#x3D; errors.New(&quot;gzip: invalid header&quot;)\n)\ntype Headertype Header struct &#123;\n\tComment string    &#x2F;&#x2F; comment\n\tExtra   []byte    &#x2F;&#x2F; &quot;extra data&quot;\n\tModTime time.Time &#x2F;&#x2F; modification time\n\tName    string    &#x2F;&#x2F; file name\n\tOS      byte      &#x2F;&#x2F; operating system type\n&#125;\ntype Readertype Reader struct &#123;\n\tHeader &#x2F;&#x2F; valid after NewReader or Reader.Reset\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc NewReader(r io.Reader) (*Reader, error)func (z *Reader) Close() errorfunc (z *Reader) Multistream(ok bool)func (z *Reader) Read(p []byte) (n int, err error)func (z *Reader) Reset(r io.Reader) errortype Writertype Writer struct &#123;\n\tHeader &#x2F;&#x2F; written at first call to Write, Flush, or Close\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n\nfunc NewWriter(w io.Writer) *Writerfunc NewWriterLevel(w io.Writer, level int) (*Writer, error)func (z *Writer) Close() errorfunc (z *Writer) Flush() errorfunc (z *Writer) Reset(w io.Writer)func (z *Writer) Write(p []byte) (int, error)lzwPackage lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19.\nIn particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.\nThe TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org&#x2F;x&#x2F;image&#x2F;tiff&#x2F;lzw package for an implementation.\nfunc NewReader(r io.Reader, order Order, litWidth int) io.ReadCloserfunc NewWriter(w io.Writer, order Order, litWidth int) io.WriteClosertype Ordertype Order int\ntype Readertype Reader struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc (r *Reader) Close() errorfunc (r *Reader) Read(b []byte) (int, error)func (r *Reader) Reset(src io.Reader, order Order, litWidth int)type Writertype Writer struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n\n\nfunc (w *Writer) Close() errorfunc (w *Writer) Reset(dst io.Writer, order Order, litWidth int)func (w *Writer) Write(p []byte) (n int, err error)compress&#x2F;zlibOverviewPackage zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.\nThe implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:\nvar b bytes.Buffer\nw :&#x3D; zlib.NewWriter(&amp;b)\nw.Write([]byte(&quot;hello, world\\n&quot;))\nw.Close()\nand to read that data back:\nr, err :&#x3D; zlib.NewReader(&amp;b)\nio.Copy(os.Stdout, r)\nr.Close()\nConstantsVariables\nfunc NewReader(r io.Reader) (io.ReadCloser, error)func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)type Resettertype Resetter interface &#123;\n\t&#x2F;&#x2F; Reset discards any buffered data and resets the Resetter as if it was\n\t&#x2F;&#x2F; newly initialized with the given reader.\n\tReset(r io.Reader, dict []byte) error\n&#125;\ntype Writertype Writer struct &#123;\n\t&#x2F;&#x2F; contains filtered or unexported fields\n&#125;\nfunc NewWriter(w io.Writer) *Writerfunc NewWriterLevel(w io.Writer, level int) (*Writer, error)func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)func (z *Writer) Close() errorfunc (z *Writer) Flush() errorfunc (z *Writer) Reset(w io.Writer)func (z *Writer) Write(p []byte) (n int, err error)containercontainer&#x2F;heapOverviewPackage heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.\nThe minimum element in the tree is the root, at index 0.\nA heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source.\nfunc Fix(h Interface, i int)func Init(h Interface)func Pop(h Interface) anyfunc Push(h Interface, x any)func Remove(h Interface, i int) anytype Interfacecontainer&#x2F;listOverviewPackage list implements a doubly linked list.\nTo iterate over a list (where l is a *List):\nfor e :&#x3D; l.Front(); e !&#x3D; nil; e &#x3D; e.Next() &#123;\n\t&#x2F;&#x2F; do something with e.Value\n&#125;\n\n\ntype Elementfunc (e *Element) Next() *Elementfunc (e *Element) Prev() *Elementtype Listfunc New() *Listfunc (l *List) Back() *Elementfunc (l *List) Front() *Elementfunc (l *List) Init() *Listfunc (l *List) InsertAfter(v any, mark *Element) *Elementfunc (l *List) InsertBefore(v any, mark *Element) *Elementfunc (l *List) Len() intfunc (l *List) MoveAfter(e, mark *Element)func (l *List) MoveBefore(e, mark *Element)func (l *List) MoveToBack(e *Element)func (l *List) MoveToFront(e *Element)func (l *List) PushBack(v any) *Elementfunc (l *List) PushBackList(other *List)func (l *List) PushFront(v any) *Elementfunc (l *List) PushFrontList(other *List)func (l *List) Remove(e *Element) anytime packageConstants  const (\n  Layout      &#x3D; &quot;01&#x2F;02 03:04:05PM &#39;06 -0700&quot; &#x2F;&#x2F; The reference time, in numerical order.\n  ANSIC       &#x3D; &quot;Mon Jan _2 15:04:05 2006&quot;\n  UnixDate    &#x3D; &quot;Mon Jan _2 15:04:05 MST 2006&quot;\n  RubyDate    &#x3D; &quot;Mon Jan 02 15:04:05 -0700 2006&quot;\n  RFC822      &#x3D; &quot;02 Jan 06 15:04 MST&quot;\n  RFC822Z     &#x3D; &quot;02 Jan 06 15:04 -0700&quot; &#x2F;&#x2F; RFC822 with numeric zone\n  RFC850      &#x3D; &quot;Monday, 02-Jan-06 15:04:05 MST&quot;\n  RFC1123     &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 MST&quot;\n  RFC1123Z    &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 -0700&quot; &#x2F;&#x2F; RFC1123 with numeric zone\n  RFC3339     &#x3D; &quot;2006-01-02T15:04:05Z07:00&quot;\n  RFC3339Nano &#x3D; &quot;2006-01-02T15:04:05.999999999Z07:00&quot;\n  Kitchen     &#x3D; &quot;3:04PM&quot;\n  &#x2F;&#x2F; Handy time stamps.\n  Stamp      &#x3D; &quot;Jan _2 15:04:05&quot;\n  StampMilli &#x3D; &quot;Jan _2 15:04:05.000&quot;\n  StampMicro &#x3D; &quot;Jan _2 15:04:05.000000&quot;\n  StampNano  &#x3D; &quot;Jan _2 15:04:05.000000000&quot;\n)\nfunc After(d Duration) &lt;-chan Time  After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.这里需要注意，这个After(d Duration)是指返回一次的时间戳，想要使用还要再次初始化\nfunc Sleep(d Duration)func Tick(d Duration) &lt;-chan Timetype Durationfunc ParseDuration(s string) (Duration, error)func Since(t Time) Durationfunc Until(t Time) Durationfunc (d Duration) Abs() Durationfunc (d Duration) Hours() float64func (d Duration) Microseconds() int64func (d Duration) Milliseconds() int64func (d Duration) Minutes() float64func (d Duration) Nanoseconds() int64func (d Duration) Round(m Duration) Durationfunc (d Duration) Seconds() float64func (d Duration) String() stringfunc (d Duration) Truncate(m Duration) Durationtype Locationfunc FixedZone(name string, offset int) *Locationfunc LoadLocation(name string) (*Location, error)func LoadLocationFromTZData(name string, data []byte) (*Location, error)func (l*Location) String() stringtype Monthfunc (m Month) String() stringtype ParseErrorfunc (e *ParseError) Error() stringtype Ticker  A Ticker holds a channel that delivers “ticks” of a clock at intervals.\nfunc NewTicker(d Duration) *Ticker  NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.\nfunc (t *Ticker) Reset(d Duration)  Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic.\nfunc (t *Ticker) Stop()  Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous “tick”.\ntype Timefunc Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Timefunc Now() Timefunc Parse(layout, value string) (Time, error)func ParseInLocation(layout, value string, loc *Location) (Time, error)func Unix(sec int64, nsec int64) Timefunc UnixMicro(usec int64) Timefunc UnixMilli(msec int64) Timefunc (t Time) Add(d Duration) Timefunc (t Time) AddDate(years int, months int, days int) Timefunc (t Time) After(u Time) boolfunc (t Time) AppendFormat(b []byte, layout string) []bytefunc (t Time) Before(u Time) boolfunc (t Time) Clock() (hour, min, sec int)func (t Time) Date() (year int, month Month, day int)func (t Time) Day() intfunc (t Time) Equal(u Time) boolfunc (t Time) Format(layout string) stringfunc (t Time) GoString() stringfunc (t *Time) GobDecode(data []byte) errorfunc (t Time) GobEncode() ([]byte, error)func (t Time) Hour() intfunc (t Time) ISOWeek() (year, week int)func (t Time) In(loc*Location) Timefunc (t Time) IsDST() boolfunc (t Time) IsZero() boolfunc (t Time) Local() Timefunc (t Time) Location() *Locationfunc (t Time) MarshalBinary() ([]byte, error)func (t Time) MarshalJSON() ([]byte, error)func (t Time) MarshalText() ([]byte, error)func (t Time) Minute() intfunc (t Time) Month() Monthfunc (t Time) Nanosecond() intfunc (t Time) Round(d Duration) Timefunc (t Time) Second() intfunc (t Time) String() stringfunc (t Time) Sub(u Time) Durationfunc (t Time) Truncate(d Duration) Timefunc (t Time) UTC() Timefunc (t Time) Unix() int64func (t Time) UnixMicro() int64func (t Time) UnixMilli() int64func (t Time) UnixNano() int64func (t*Time) UnmarshalBinary(data []byte) errorfunc (t *Time) UnmarshalJSON(data []byte) errorfunc (t*Time) UnmarshalText(data []byte) errorfunc (t Time) Weekday() Weekdayfunc (t Time) Year() intfunc (t Time) YearDay() intfunc (t Time) Zone() (name string, offset int)func (t Time) ZoneBounds() (start, end Time)type Timer  type Timer struct &#123;\n  C &lt;-chan Time\n  &#x2F;&#x2F; contains filtered or unexported fields\n&#125;\n\n  这里的C用于接收\nfunc AfterFunc(d Duration, f func()) *Timerfunc NewTimer(d Duration)*Timerfunc (t *Timer) Reset(d Duration) boolfunc (t*Timer) Stop() booltype Weekdayfunc (d Weekday) String() stringrandfunction not method of randfunc ExpFloat64() float64func Float32() float32func Float64() float64func Int() intfunc Int31() int32func Int31n(n int32) int32func Int63() int64func Int63n(n int64) int64func Intn(n int) intfunc NormFloat64() float64func Perm(n int) []intfunc Read(p []byte) (n int, err error)func Seed(seed int64)func Shuffle(n int, swap func(i, j int))func Uint32() uint32func Uint64() uint64type Randfunc New(src Source) *Randfunc (r*Rand) ExpFloat64() float64func (r *Rand) Float32() float32func (r*Rand) Float64() float64func (r *Rand) Int() intfunc (r*Rand) Int31() int32func (r *Rand) Int31n(n int32) int32func (r*Rand) Int63() int64func (r *Rand) Int63n(n int64) int64func (r*Rand) Intn(n int) intfunc (r *Rand) NormFloat64() float64func (r*Rand) Perm(n int) []intfunc (r *Rand) Read(p []byte) (n int, err error)func (r*Rand) Seed(seed int64)  Seed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。\nfunc (r *Rand) Shuffle(n int, swap func(i, j int))func (r*Rand) Uint32() uint32func (r *Rand) Uint64() uint64type Sourcefunc NewSource(seed int64) Source  NewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。\n  randomSource :&#x3D; NewSource(time.Now().UnixNano())\nrandSeed :&#x3D; New(randomSource) &#x2F;&#x2F;这时候就可以使用rand的method\nrandomInt :&#x3D; randSeed.Intn(300)&#x2F;&#x2F;[0,300)的整数\n\n\ntype Source64  Source64是一个也可以直接生成[0, 1&lt;&lt;64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。  Source64的结构\n  type Source64 interface &#123;\n    Source\n    Uint64() uint64\n&#125;\n\ntype Zipffunc NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipffunc (z *Zipf) Uint64() uint64","dateCreated":"2022-10-08T07:48:06+08:00","dateModified":"2022-11-03T01:06:57+08:00","datePublished":"2022-10-08T07:48:06+08:00","description":"abstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.","headline":"go标准库阅读与解析","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://simonteo58.github.io/2022/10/08/golang/go%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3/"},"publisher":{"@type":"Organization","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://simonteo58.github.io/2022/10/08/golang/go%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3/","keywords":"golang"}</script>
    <meta name="description" content="abstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.">
<meta property="og:type" content="blog">
<meta property="og:title" content="go标准库阅读与解析">
<meta property="og:url" content="https://simonteo58.github.io/2022/10/08/golang/go%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="CoffeeMan">
<meta property="og:description" content="abstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-07T23:48:06.892Z">
<meta property="article:modified_time" content="2022-11-02T17:06:57.811Z">
<meta property="article:author" content="kirkzhang">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-y9io9e1ok9lpsmk4fyk7quzstdgr6eztu8x2xr6n9iikjgfjbcqqpobdlqy8.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CoffeeMan
        </a>
    </div>
    
        
            <a
                class="header-right-picture open-algolia-search"
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/SimonTeo58"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/11289672/simon-teo"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/shiming_kirk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/kirk-zhang-424935235/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/zxc741208584@qq.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            go标准库阅读与解析
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-10-08T07:48:06+08:00">
	
		    Oct 08, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>abstarct: Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</p>
<span id="more"></span>
<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#package-tar"><span class="toc-text">package tar</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Constants"><span class="toc-text">Constants</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Variables"><span class="toc-text">Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Format"><span class="toc-text">type Format</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-f-Format-String-string"><span class="toc-text">func (f Format) String() string</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Header"><span class="toc-text">type Header</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error"><span class="toc-text">func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-h-Header-FileInfo-fs-FileInfo"><span class="toc-text">func (h*Header) FileInfo() fs.FileInfo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Reader"><span class="toc-text">type Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReader-r-io-Reader-Reader"><span class="toc-text">func NewReader(r io.Reader) *Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-tr-Reader-Next-Header-error"><span class="toc-text">func (tr*Reader) Next() (*Header, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-tr-Reader-Read-b-byte-int-error"><span class="toc-text">func (tr*Reader) Read(b []byte) (int, error)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Writer"><span class="toc-text">type Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriter-w-io-Writer-Writer"><span class="toc-text">func NewWriter(w io.Writer) *Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-tw-Writer-Close-error"><span class="toc-text">func (tw*Writer) Close() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-tw-Writer-Flush-error"><span class="toc-text">func (tw *Writer) Flush() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-tw-Writer-Write-b-byte-int-error"><span class="toc-text">func (tw*Writer) Write(b []byte) (int, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-tw-Writer-WriteHeader-hdrHeader-error"><span class="toc-text">func (tw Writer) WriteHeader(hdrHeader) error</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zip-package"><span class="toc-text">zip package</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Constants-1"><span class="toc-text">Constants</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Variables-1"><span class="toc-text">Variables</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-RegisterCompressor-method-uint16-comp-Compressor"><span class="toc-text">func RegisterCompressor(method uint16, comp Compressor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-RegisterDecompressor-method-uint16-dcomp-Decompressor"><span class="toc-text">func RegisterDecompressor(method uint16, dcomp Decompressor)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Compressor"><span class="toc-text">type Compressor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Decompressor"><span class="toc-text">type Decompressor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-File"><span class="toc-text">type File</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-f-File-DataOffset-offset-int64-err-error"><span class="toc-text">func (f *File) DataOffset() (offset int64, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-f-File-Open-io-ReadCloser-error"><span class="toc-text">func (f*File) Open() (io.ReadCloser, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-f-File-OpenRaw-io-Reader-error"><span class="toc-text">func (f *File) OpenRaw() (io.Reader, error)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-FileHeader"><span class="toc-text">type FileHeader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error"><span class="toc-text">func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-h-FileHeader-FileInfo-fs-FileInfo"><span class="toc-text">func (h *FileHeader) FileInfo() fs.FileInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-h-FileHeader-ModTime-time-TimeDEPRECATED"><span class="toc-text">func (h*FileHeader) ModTime() time.TimeDEPRECATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-h-FileHeader-Mode-mode-fs-FileMode"><span class="toc-text">func (h *FileHeader) Mode() (mode fs.FileMode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED"><span class="toc-text">func (h*FileHeader) SetModTime(t time.Time)DEPRECATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-h-FileHeader-SetMode-mode-fs-FileMode"><span class="toc-text">func (h *FileHeader) SetMode(mode fs.FileMode)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-ReadCloser"><span class="toc-text">type ReadCloser</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-OpenReader-name-string-ReadCloser-error"><span class="toc-text">func OpenReader(name string) (*ReadCloser, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-rc-ReadCloser-Close-error"><span class="toc-text">func (rc *ReadCloser) Close() error</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Reader-1"><span class="toc-text">type Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReader-r-io-ReaderAt-size-int64-Reader-error"><span class="toc-text">func NewReader(r io.ReaderAt, size int64) (*Reader, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-Open-name-string-fs-File-error"><span class="toc-text">func (r *Reader) Open(name string) (fs.File, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor"><span class="toc-text">func (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Writer-1"><span class="toc-text">type Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriter-w-io-Writer-Writer-1"><span class="toc-text">func NewWriter(w io.Writer) *Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-Close-error"><span class="toc-text">func (w*Writer) Close() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-Copy-f-File-error"><span class="toc-text">func (w *Writer) Copy(f*File) error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-Create-name-string-io-Writer-error"><span class="toc-text">func (w *Writer) Create(name string) (io.Writer, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error"><span class="toc-text">func (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error"><span class="toc-text">func (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-Flush-error"><span class="toc-text">func (w*Writer) Flush() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor"><span class="toc-text">func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-SetComment-comment-string-error"><span class="toc-text">func (w*Writer) SetComment(comment string) error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-w-Writer-SetOffset-n-int64"><span class="toc-text">func (w *Writer) SetOffset(n int64)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bufio"><span class="toc-text">bufio</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ScanBytes-data-byte-atEOF-bool-advance-int-token-byte-err-error"><span class="toc-text">func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ScanLines-data-byte-atEOF-bool-advance-int-token-byte-err-error"><span class="toc-text">func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ScanRunes-data-byte-atEOF-bool-advance-int-token-byte-err-error"><span class="toc-text">func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ScanWords-data-byte-atEOF-bool-advance-int-token-byte-err-error"><span class="toc-text">func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-ReadWriter"><span class="toc-text">type ReadWriter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReadWriter-r-Reader-w-Writer-ReadWriter"><span class="toc-text">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Reader-2"><span class="toc-text">type Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-NewReader-rd-io-Reader-Reader"><span class="toc-text">func NewReader(rd io.Reader) *Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-NewReaderSize-rd-io-Reader-size-int-Reader"><span class="toc-text">func NewReaderSize(rd io.Reader, size int) *Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-Buffered-int"><span class="toc-text">func (b *Reader) Buffered() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-Discard-n-int-discarded-int-err-error"><span class="toc-text">func (b *Reader) Discard(n int) (discarded int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-Peek-n-int-byte-error"><span class="toc-text">func (b *Reader) Peek(n int) ([]byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-Read-p-byte-n-int-err-error"><span class="toc-text">func (b *Reader) Read(p []byte) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-ReadByte-byte-error"><span class="toc-text">func (b *Reader) ReadByte() (byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-ReadBytes-delim-byte-byte-error"><span class="toc-text">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-ReadLine-line-byte-isPrefix-bool-err-error"><span class="toc-text">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-ReadRune-r-rune-size-int-err-error"><span class="toc-text">func (b *Reader) ReadRune() (r rune, size int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-ReadSlice-delim-byte-line-byte-err-error"><span class="toc-text">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-ReadString-delim-byte-string-error"><span class="toc-text">func (b *Reader) ReadString(delim byte) (string, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-Reset-r-io-Reader"><span class="toc-text">func (b *Reader) Reset(r io.Reader)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-Size-int"><span class="toc-text">func (b *Reader) Size() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-UnreadByte-error"><span class="toc-text">func (b *Reader) UnreadByte() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-UnreadRune-error"><span class="toc-text">func (b *Reader) UnreadRune() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Reader-WriteTo-w-io-Writer-n-int64-err-error"><span class="toc-text">func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Scanner"><span class="toc-text">type Scanner</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-NewScanner-r-io-Reader-Scanner"><span class="toc-text">func NewScanner(r io.Reader) *Scanner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-s-Scanner-Buffer-buf-byte-max-int"><span class="toc-text">func (s *Scanner) Buffer(buf []byte, max int)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-s-Scanner-Bytes-byte"><span class="toc-text">func (s *Scanner) Bytes() []byte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-s-Scanner-Err-error"><span class="toc-text">func (s *Scanner) Err() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-s-Scanner-Scan-bool"><span class="toc-text">func (s *Scanner) Scan() bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-s-Scanner-Split-split-SplitFunc"><span class="toc-text">func (s *Scanner) Split(split SplitFunc)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-s-Scanner-Text-string"><span class="toc-text">func (s *Scanner) Text() string</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-SplitFunc"><span class="toc-text">type SplitFunc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Writer-2"><span class="toc-text">type Writer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-NewWriter-w-io-Writer-Writer-2"><span class="toc-text">func NewWriter(w io.Writer) *Writer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-NewWriterSize-w-io-Writer-size-int-Writer"><span class="toc-text">func NewWriterSize(w io.Writer, size int) *Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-Available-int"><span class="toc-text">func (b *Writer) Available() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-AvailableBuffer-byte"><span class="toc-text">func (b *Writer) AvailableBuffer() []byte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-Buffered-int"><span class="toc-text">func (b *Writer) Buffered() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-Flush-error"><span class="toc-text">func (b *Writer) Flush() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-ReadFrom-r-io-Reader-n-int64-err-error"><span class="toc-text">func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-Reset-w-io-Writer"><span class="toc-text">func (b *Writer) Reset(w io.Writer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-Size-int"><span class="toc-text">func (b *Writer) Size() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-Write-p-byte-nn-int-err-error"><span class="toc-text">func (b *Writer) Write(p []byte) (nn int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-WriteByte-c-byte-error"><span class="toc-text">func (b *Writer) WriteByte(c byte) error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-WriteRune-r-rune-size-int-err-error"><span class="toc-text">func (b *Writer) WriteRune(r rune) (size int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Writer-WriteString-s-string-int-error"><span class="toc-text">func (b *Writer) WriteString(s string) (int, error)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#builtin"><span class="toc-text">builtin</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#func-append-slice-Type-elems-%E2%80%A6Type-Type"><span class="toc-text">func append(slice []Type, elems …Type) []Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-cap-v-Type-int"><span class="toc-text">func cap(v Type) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-close-c-chan-lt-Type"><span class="toc-text">func close(c chan&lt;- Type)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-complex-r-i-FloatType-ComplexType"><span class="toc-text">func complex(r, i FloatType) ComplexType</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-copy-dst-src-Type-int"><span class="toc-text">func copy(dst, src []Type) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-delete-m-map-Type-Type1-key-Type"><span class="toc-text">func delete(m map[Type]Type1, key Type)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-imag-c-ComplexType-FloatType"><span class="toc-text">func imag(c ComplexType) FloatType</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-len-v-Type-int"><span class="toc-text">func len(v Type) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-make-t-Type-size-%E2%80%A6IntegerType-Type"><span class="toc-text">func make(t Type, size …IntegerType) Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-new-Type-Type"><span class="toc-text">func new(Type) *Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-panic-v-any"><span class="toc-text">func panic(v any)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-print-args-%E2%80%A6Type"><span class="toc-text">func print(args …Type)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-println-args-%E2%80%A6Type"><span class="toc-text">func println(args …Type)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-real-c-ComplexType-FloatType"><span class="toc-text">func real(c ComplexType) FloatType</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-recover-any"><span class="toc-text">func recover() any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-ComplexType"><span class="toc-text">type ComplexType</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-FloatType"><span class="toc-text">type FloatType</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-IntegerType"><span class="toc-text">type IntegerType</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Type"><span class="toc-text">type Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Type1"><span class="toc-text">type Type1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-any"><span class="toc-text">type any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-bool"><span class="toc-text">type bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-byte"><span class="toc-text">type byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-comparable"><span class="toc-text">type comparable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-complex128"><span class="toc-text">type complex128</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-complex64"><span class="toc-text">type complex64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-error"><span class="toc-text">type error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-float32"><span class="toc-text">type float32</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-float64"><span class="toc-text">type float64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-int"><span class="toc-text">type int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-int16"><span class="toc-text">type int16</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-int32"><span class="toc-text">type int32</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-int64"><span class="toc-text">type int64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-int8"><span class="toc-text">type int8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-rune"><span class="toc-text">type rune</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-string"><span class="toc-text">type string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-uint"><span class="toc-text">type uint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-uint16"><span class="toc-text">type uint16</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-uint32"><span class="toc-text">type uint32</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-uint64"><span class="toc-text">type uint64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-uint8"><span class="toc-text">type uint8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-uintptr"><span class="toc-text">type uintptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bytes"><span class="toc-text">bytes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Compare-a-b-byte-int"><span class="toc-text">func Compare(a, b []byte) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Contains-b-subslice-byte-bool"><span class="toc-text">func Contains(b, subslice []byte) bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ContainsAny-b-byte-chars-string-bool"><span class="toc-text">func ContainsAny(b []byte, chars string) bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ContainsRune-b-byte-r-rune-bool"><span class="toc-text">func ContainsRune(b []byte, r rune) bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Count-s-sep-byte-int"><span class="toc-text">func Count(s, sep []byte) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Cut-s-sep-byte-before-after-byte-found-bool"><span class="toc-text">func Cut(s, sep []byte) (before, after []byte, found bool)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Equal-a-b-byte-bool"><span class="toc-text">func Equal(a, b []byte) bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-EqualFold-s-t-byte-bool"><span class="toc-text">func EqualFold(s, t []byte) bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Fields-s-byte-byte"><span class="toc-text">func Fields(s []byte) [][]byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-FieldsFunc-s-byte-f-func-rune-bool-byte"><span class="toc-text">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-HasPrefix-s-prefix-byte-bool"><span class="toc-text">func HasPrefix(s, prefix []byte) bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-HasSuffix-s-suffix-byte-bool"><span class="toc-text">func HasSuffix(s, suffix []byte) bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Index-s-sep-byte-int"><span class="toc-text">func Index(s, sep []byte) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-IndexAny-s-byte-chars-string-int"><span class="toc-text">func IndexAny(s []byte, chars string) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-IndexByte-b-byte-c-byte-int"><span class="toc-text">func IndexByte(b []byte, c byte) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-IndexFunc-s-byte-f-func-r-rune-bool-int"><span class="toc-text">func IndexFunc(s []byte, f func(r rune) bool) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-IndexRune-s-byte-r-rune-int"><span class="toc-text">func IndexRune(s []byte, r rune) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Join-s-byte-sep-byte-byte"><span class="toc-text">func Join(s [][]byte, sep []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-LastIndex-s-sep-byte-int"><span class="toc-text">func LastIndex(s, sep []byte) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-LastIndexAny-s-byte-chars-string-int"><span class="toc-text">func LastIndexAny(s []byte, chars string) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-LastIndexByte-s-byte-c-byte-int"><span class="toc-text">func LastIndexByte(s []byte, c byte) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-LastIndexFunc-s-byte-f-func-r-rune-bool-int"><span class="toc-text">func LastIndexFunc(s []byte, f func(r rune) bool) int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Map-mapping-func-r-rune-rune-s-byte-byte"><span class="toc-text">func Map(mapping func(r rune) rune, s []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Repeat-b-byte-count-int-byte"><span class="toc-text">func Repeat(b []byte, count int) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Replace-s-old-new-byte-n-int-byte"><span class="toc-text">func Replace(s, old, new []byte, n int) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ReplaceAll-s-old-new-byte-byte"><span class="toc-text">func ReplaceAll(s, old, new []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Runes-s-byte-rune"><span class="toc-text">func Runes(s []byte) []rune</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Split-s-sep-byte-byte"><span class="toc-text">func Split(s, sep []byte) [][]byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-SplitAfter-s-sep-byte-byte"><span class="toc-text">func SplitAfter(s, sep []byte) [][]byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-SplitAfterN-s-sep-byte-n-int-byte"><span class="toc-text">func SplitAfterN(s, sep []byte, n int) [][]byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-SplitN-s-sep-byte-n-int-byte"><span class="toc-text">func SplitN(s, sep []byte, n int) [][]byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Title-s-byte-byteDEPRECATED"><span class="toc-text">func Title(s []byte) []byteDEPRECATED</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ToLower-s-byte-byte"><span class="toc-text">func ToLower(s []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ToLowerSpecial-c-unicode-SpecialCase-s-byte-byte"><span class="toc-text">func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ToTitle-s-byte-byte"><span class="toc-text">func ToTitle(s []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ToTitleSpecial-c-unicode-SpecialCase-s-byte-byte"><span class="toc-text">func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ToUpper-s-byte-byte"><span class="toc-text">func ToUpper(s []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ToUpperSpecial-c-unicode-SpecialCase-s-byte-byte"><span class="toc-text">func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-ToValidUTF8-s-replacement-byte-byte"><span class="toc-text">func ToValidUTF8(s, replacement []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-Trim-s-byte-cutset-string-byte"><span class="toc-text">func Trim(s []byte, cutset string) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-TrimFunc-s-byte-f-func-r-rune-bool-byte"><span class="toc-text">func TrimFunc(s []byte, f func(r rune) bool) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-TrimLeft-s-byte-cutset-string-byte"><span class="toc-text">func TrimLeft(s []byte, cutset string) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-TrimLeftFunc-s-byte-f-func-r-rune-bool-byte"><span class="toc-text">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-TrimPrefix-s-prefix-byte-byte"><span class="toc-text">func TrimPrefix(s, prefix []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-TrimRight-s-byte-cutset-string-byte"><span class="toc-text">func TrimRight(s []byte, cutset string) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-TrimRightFunc-s-byte-f-func-r-rune-bool-byte"><span class="toc-text">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-TrimSpace-s-byte-byte"><span class="toc-text">func TrimSpace(s []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-TrimSuffix-s-suffix-byte-byte"><span class="toc-text">func TrimSuffix(s, suffix []byte) []byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Buffer"><span class="toc-text">type Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-NewBuffer-buf-byte-Buffer"><span class="toc-text">func NewBuffer(buf []byte) *Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-NewBufferString-s-string-Buffer"><span class="toc-text">func NewBufferString(s string) *Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Bytes-byte"><span class="toc-text">func (b *Buffer) Bytes() []byte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Cap-int"><span class="toc-text">func (b *Buffer) Cap() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Grow-n-int"><span class="toc-text">func (b *Buffer) Grow(n int)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Len-int"><span class="toc-text">func (b *Buffer) Len() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Next-n-int-byte"><span class="toc-text">func (b *Buffer) Next(n int) []byte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Read-p-byte-n-int-err-error"><span class="toc-text">func (b *Buffer) Read(p []byte) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-ReadByte-byte-error"><span class="toc-text">func (b *Buffer) ReadByte() (byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-ReadBytes-delim-byte-line-byte-err-error"><span class="toc-text">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-ReadFrom-r-io-Reader-n-int64-err-error"><span class="toc-text">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-ReadRune-r-rune-size-int-err-error"><span class="toc-text">func (b *Buffer) ReadRune() (r rune, size int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-ReadString-delim-byte-line-string-err-error"><span class="toc-text">func (b *Buffer) ReadString(delim byte) (line string, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Reset"><span class="toc-text">func (b *Buffer) Reset()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-String-string"><span class="toc-text">func (b *Buffer) String() string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Truncate-n-int"><span class="toc-text">func (b *Buffer) Truncate(n int)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-UnreadByte-error"><span class="toc-text">func (b *Buffer) UnreadByte() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-UnreadRune-error"><span class="toc-text">func (b *Buffer) UnreadRune() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-Write-p-byte-n-int-err-error"><span class="toc-text">func (b *Buffer) Write(p []byte) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-WriteByte-c-byte-error"><span class="toc-text">func (b *Buffer) WriteByte(c byte) error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-WriteRune-r-rune-n-int-err-error"><span class="toc-text">func (b *Buffer) WriteRune(r rune) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-WriteString-s-string-n-int-err-error"><span class="toc-text">func (b *Buffer) WriteString(s string) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-b-Buffer-WriteTo-w-io-Writer-n-int64-err-error"><span class="toc-text">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Reader-3"><span class="toc-text">type Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#func-NewReader-b-byte-Reader"><span class="toc-text">func NewReader(b []byte) *Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-Len-int"><span class="toc-text">func (r *Reader) Len() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-Read-b-byte-n-int-err-error"><span class="toc-text">func (r *Reader) Read(b []byte) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-ReadAt-b-byte-off-int64-n-int-err-error"><span class="toc-text">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-ReadByte-byte-error"><span class="toc-text">func (r *Reader) ReadByte() (byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-ReadRune-ch-rune-size-int-err-error"><span class="toc-text">func (r *Reader) ReadRune() (ch rune, size int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-Reset-b-byte"><span class="toc-text">func (r *Reader) Reset(b []byte)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-Seek-offset-int64-whence-int-int64-error"><span class="toc-text">func (r *Reader) Seek(offset int64, whence int) (int64, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-Size-int64"><span class="toc-text">func (r *Reader) Size() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-UnreadByte-error"><span class="toc-text">func (r *Reader) UnreadByte() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-UnreadRune-error"><span class="toc-text">func (r *Reader) UnreadRune() error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Reader-WriteTo-w-io-Writer-n-int64-err-error"><span class="toc-text">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#compress"><span class="toc-text">compress</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bzip2"><span class="toc-text">bzip2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReader-r-io-Reader-io-Reader"><span class="toc-text">func NewReader(r io.Reader) io.Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-StructuralError"><span class="toc-text">type StructuralError</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-s-StructuralError-Error-string"><span class="toc-text">func (s StructuralError) Error() string</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flate"><span class="toc-text">flate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReader-r-io-Reader-io-ReadCloser"><span class="toc-text">func NewReader(r io.Reader) io.ReadCloser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReaderDict-r-io-Reader-dict-byte-io-ReadCloser"><span class="toc-text">func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-CorruptInputError"><span class="toc-text">type CorruptInputError</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-e-CorruptInputError-Error-string"><span class="toc-text">func (e CorruptInputError) Error() string</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-InternalError"><span class="toc-text">type InternalError</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-e-InternalError-Error-string"><span class="toc-text">func (e InternalError) Error() string</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-ReadErrorDEPRECATED"><span class="toc-text">type ReadErrorDEPRECATED</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-e-ReadError-Error-string"><span class="toc-text">func (e *ReadError) Error() string</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Reader-4"><span class="toc-text">type Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Resetter"><span class="toc-text">type Resetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-WriteErrorDEPRECATED"><span class="toc-text">type WriteErrorDEPRECATED</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-e-WriteError-Error-string"><span class="toc-text">func (e *WriteError) Error() string</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Writer-3"><span class="toc-text">type Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriter-w-io-Writer-level-int-Writer-error"><span class="toc-text">func NewWriter(w io.Writer, level int) (*Writer, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriterDict-w-io-Writer-level-int-dict-byte-Writer-error"><span class="toc-text">func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-w-Writer-Close-error-1"><span class="toc-text">func (w *Writer) Close() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-w-Writer-Flush-error-1"><span class="toc-text">func (w *Writer) Flush() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-w-Writer-Reset-dst-io-Writer"><span class="toc-text">func (w *Writer) Reset(dst io.Writer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-w-Writer-Write-data-byte-n-int-err-error"><span class="toc-text">func (w *Writer) Write(data []byte) (n int, err error)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gzip"><span class="toc-text">gzip</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Header-1"><span class="toc-text">type Header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Reader-5"><span class="toc-text">type Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReader-r-io-Reader-Reader-error"><span class="toc-text">func NewReader(r io.Reader) (*Reader, error)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Reader-Close-error"><span class="toc-text">func (z *Reader) Close() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Reader-Multistream-ok-bool"><span class="toc-text">func (z *Reader) Multistream(ok bool)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Reader-Read-p-byte-n-int-err-error"><span class="toc-text">func (z *Reader) Read(p []byte) (n int, err error)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Reader-Reset-r-io-Reader-error"><span class="toc-text">func (z *Reader) Reset(r io.Reader) error</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Writer-4"><span class="toc-text">type Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriter-w-io-Writer-Writer-3"><span class="toc-text">func NewWriter(w io.Writer) *Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriterLevel-w-io-Writer-level-int-Writer-error"><span class="toc-text">func NewWriterLevel(w io.Writer, level int) (*Writer, error)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Writer-Close-error"><span class="toc-text">func (z *Writer) Close() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Writer-Flush-error"><span class="toc-text">func (z *Writer) Flush() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Writer-Reset-w-io-Writer"><span class="toc-text">func (z *Writer) Reset(w io.Writer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Writer-Write-p-byte-int-error"><span class="toc-text">func (z *Writer) Write(p []byte) (int, error)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lzw"><span class="toc-text">lzw</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReader-r-io-Reader-order-Order-litWidth-int-io-ReadCloser"><span class="toc-text">func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriter-w-io-Writer-order-Order-litWidth-int-io-WriteCloser"><span class="toc-text">func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Order"><span class="toc-text">type Order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Reader-6"><span class="toc-text">type Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-r-Reader-Close-error"><span class="toc-text">func (r *Reader) Close() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-r-Reader-Read-b-byte-int-error"><span class="toc-text">func (r *Reader) Read(b []byte) (int, error)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-r-Reader-Reset-src-io-Reader-order-Order-litWidth-int"><span class="toc-text">func (r *Reader) Reset(src io.Reader, order Order, litWidth int)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Writer-5"><span class="toc-text">type Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-w-Writer-Close-error-2"><span class="toc-text">func (w *Writer) Close() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-w-Writer-Reset-dst-io-Writer-order-Order-litWidth-int"><span class="toc-text">func (w *Writer) Reset(dst io.Writer, order Order, litWidth int)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-w-Writer-Write-p-byte-n-int-err-error"><span class="toc-text">func (w *Writer) Write(p []byte) (n int, err error)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compress-x2F-zlib"><span class="toc-text">compress&#x2F;zlib</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReader-r-io-Reader-io-ReadCloser-error"><span class="toc-text">func NewReader(r io.Reader) (io.ReadCloser, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewReaderDict-r-io-Reader-dict-byte-io-ReadCloser-error"><span class="toc-text">func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Resetter-1"><span class="toc-text">type Resetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Writer-6"><span class="toc-text">type Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriter-w-io-Writer-Writer-4"><span class="toc-text">func NewWriter(w io.Writer) *Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriterLevel-w-io-Writer-level-int-Writer-error-1"><span class="toc-text">func NewWriterLevel(w io.Writer, level int) (*Writer, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewWriterLevelDict-w-io-Writer-level-int-dict-byte-Writer-error"><span class="toc-text">func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Writer-Close-error-1"><span class="toc-text">func (z *Writer) Close() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Writer-Flush-error-1"><span class="toc-text">func (z *Writer) Flush() error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Writer-Reset-w-io-Writer-1"><span class="toc-text">func (z *Writer) Reset(w io.Writer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-z-Writer-Write-p-byte-n-int-err-error"><span class="toc-text">func (z *Writer) Write(p []byte) (n int, err error)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#container"><span class="toc-text">container</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#container-x2F-heap"><span class="toc-text">container&#x2F;heap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Fix-h-Interface-i-int"><span class="toc-text">func Fix(h Interface, i int)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Init-h-Interface"><span class="toc-text">func Init(h Interface)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Pop-h-Interface-any"><span class="toc-text">func Pop(h Interface) any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Push-h-Interface-x-any"><span class="toc-text">func Push(h Interface, x any)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Remove-h-Interface-i-int-any"><span class="toc-text">func Remove(h Interface, i int) any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Interface"><span class="toc-text">type Interface</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#container-x2F-list"><span class="toc-text">container&#x2F;list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Element"><span class="toc-text">type Element</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-e-Element-Next-Element"><span class="toc-text">func (e *Element) Next() *Element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-e-Element-Prev-Element"><span class="toc-text">func (e *Element) Prev() *Element</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-List"><span class="toc-text">type List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-New-List"><span class="toc-text">func New() *List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-Back-Element"><span class="toc-text">func (l *List) Back() *Element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-Front-Element"><span class="toc-text">func (l *List) Front() *Element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-Init-List"><span class="toc-text">func (l *List) Init() *List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-InsertAfter-v-any-mark-Element-Element"><span class="toc-text">func (l *List) InsertAfter(v any, mark *Element) *Element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-InsertBefore-v-any-mark-Element-Element"><span class="toc-text">func (l *List) InsertBefore(v any, mark *Element) *Element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-Len-int"><span class="toc-text">func (l *List) Len() int</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-MoveAfter-e-mark-Element"><span class="toc-text">func (l *List) MoveAfter(e, mark *Element)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-MoveBefore-e-mark-Element"><span class="toc-text">func (l *List) MoveBefore(e, mark *Element)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-MoveToBack-e-Element"><span class="toc-text">func (l *List) MoveToBack(e *Element)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-MoveToFront-e-Element"><span class="toc-text">func (l *List) MoveToFront(e *Element)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-PushBack-v-any-Element"><span class="toc-text">func (l *List) PushBack(v any) *Element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-PushBackList-other-List"><span class="toc-text">func (l *List) PushBackList(other *List)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-PushFront-v-any-Element"><span class="toc-text">func (l *List) PushFront(v any) *Element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-PushFrontList-other-List"><span class="toc-text">func (l *List) PushFrontList(other *List)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-l-List-Remove-e-Element-any"><span class="toc-text">func (l *List) Remove(e *Element) any</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time-package"><span class="toc-text">time package</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-After-d-Duration-lt-chan-Time"><span class="toc-text">func After(d Duration) &lt;-chan Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Sleep-d-Duration"><span class="toc-text">func Sleep(d Duration)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Tick-d-Duration-lt-chan-Time"><span class="toc-text">func Tick(d Duration) &lt;-chan Time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Duration"><span class="toc-text">type Duration</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-ParseDuration-s-string-Duration-error"><span class="toc-text">func ParseDuration(s string) (Duration, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Since-t-Time-Duration"><span class="toc-text">func Since(t Time) Duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Until-t-Time-Duration"><span class="toc-text">func Until(t Time) Duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Abs-Duration"><span class="toc-text">func (d Duration) Abs() Duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Hours-float64"><span class="toc-text">func (d Duration) Hours() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Microseconds-int64"><span class="toc-text">func (d Duration) Microseconds() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Milliseconds-int64"><span class="toc-text">func (d Duration) Milliseconds() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Minutes-float64"><span class="toc-text">func (d Duration) Minutes() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Nanoseconds-int64"><span class="toc-text">func (d Duration) Nanoseconds() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Round-m-Duration-Duration"><span class="toc-text">func (d Duration) Round(m Duration) Duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Seconds-float64"><span class="toc-text">func (d Duration) Seconds() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-String-string"><span class="toc-text">func (d Duration) String() string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Duration-Truncate-m-Duration-Duration"><span class="toc-text">func (d Duration) Truncate(m Duration) Duration</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Location"><span class="toc-text">type Location</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-FixedZone-name-string-offset-int-Location"><span class="toc-text">func FixedZone(name string, offset int) *Location</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-LoadLocation-name-string-Location-error"><span class="toc-text">func LoadLocation(name string) (*Location, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-LoadLocationFromTZData-name-string-data-byte-Location-error"><span class="toc-text">func LoadLocationFromTZData(name string, data []byte) (*Location, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-l-Location-String-string"><span class="toc-text">func (l*Location) String() string</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Month"><span class="toc-text">type Month</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-m-Month-String-string"><span class="toc-text">func (m Month) String() string</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-ParseError"><span class="toc-text">type ParseError</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-e-ParseError-Error-string"><span class="toc-text">func (e *ParseError) Error() string</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Ticker"><span class="toc-text">type Ticker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewTicker-d-Duration-Ticker"><span class="toc-text">func NewTicker(d Duration) *Ticker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Ticker-Reset-d-Duration"><span class="toc-text">func (t *Ticker) Reset(d Duration)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Ticker-Stop"><span class="toc-text">func (t *Ticker) Stop()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Time"><span class="toc-text">type Time</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Date-year-int-month-Month-day-hour-min-sec-nsec-int-loc-Location-Time"><span class="toc-text">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Now-Time"><span class="toc-text">func Now() Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Parse-layout-value-string-Time-error"><span class="toc-text">func Parse(layout, value string) (Time, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-ParseInLocation-layout-value-string-loc-Location-Time-error"><span class="toc-text">func ParseInLocation(layout, value string, loc *Location) (Time, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Unix-sec-int64-nsec-int64-Time"><span class="toc-text">func Unix(sec int64, nsec int64) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-UnixMicro-usec-int64-Time"><span class="toc-text">func UnixMicro(usec int64) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-UnixMilli-msec-int64-Time"><span class="toc-text">func UnixMilli(msec int64) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Add-d-Duration-Time"><span class="toc-text">func (t Time) Add(d Duration) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-AddDate-years-int-months-int-days-int-Time"><span class="toc-text">func (t Time) AddDate(years int, months int, days int) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-After-u-Time-bool"><span class="toc-text">func (t Time) After(u Time) bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-AppendFormat-b-byte-layout-string-byte"><span class="toc-text">func (t Time) AppendFormat(b []byte, layout string) []byte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Before-u-Time-bool"><span class="toc-text">func (t Time) Before(u Time) bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Clock-hour-min-sec-int"><span class="toc-text">func (t Time) Clock() (hour, min, sec int)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Date-year-int-month-Month-day-int"><span class="toc-text">func (t Time) Date() (year int, month Month, day int)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Day-int"><span class="toc-text">func (t Time) Day() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Equal-u-Time-bool"><span class="toc-text">func (t Time) Equal(u Time) bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Format-layout-string-string"><span class="toc-text">func (t Time) Format(layout string) string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-GoString-string"><span class="toc-text">func (t Time) GoString() string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-GobDecode-data-byte-error"><span class="toc-text">func (t *Time) GobDecode(data []byte) error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-GobEncode-byte-error"><span class="toc-text">func (t Time) GobEncode() ([]byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Hour-int"><span class="toc-text">func (t Time) Hour() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-ISOWeek-year-week-int"><span class="toc-text">func (t Time) ISOWeek() (year, week int)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-In-loc-Location-Time"><span class="toc-text">func (t Time) In(loc*Location) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-IsDST-bool"><span class="toc-text">func (t Time) IsDST() bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-IsZero-bool"><span class="toc-text">func (t Time) IsZero() bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Local-Time"><span class="toc-text">func (t Time) Local() Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Location-Location"><span class="toc-text">func (t Time) Location() *Location</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-MarshalBinary-byte-error"><span class="toc-text">func (t Time) MarshalBinary() ([]byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-MarshalJSON-byte-error"><span class="toc-text">func (t Time) MarshalJSON() ([]byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-MarshalText-byte-error"><span class="toc-text">func (t Time) MarshalText() ([]byte, error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Minute-int"><span class="toc-text">func (t Time) Minute() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Month-Month"><span class="toc-text">func (t Time) Month() Month</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Nanosecond-int"><span class="toc-text">func (t Time) Nanosecond() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Round-d-Duration-Time"><span class="toc-text">func (t Time) Round(d Duration) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Second-int"><span class="toc-text">func (t Time) Second() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-String-string"><span class="toc-text">func (t Time) String() string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Sub-u-Time-Duration"><span class="toc-text">func (t Time) Sub(u Time) Duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Truncate-d-Duration-Time"><span class="toc-text">func (t Time) Truncate(d Duration) Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-UTC-Time"><span class="toc-text">func (t Time) UTC() Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Unix-int64"><span class="toc-text">func (t Time) Unix() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-UnixMicro-int64"><span class="toc-text">func (t Time) UnixMicro() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-UnixMilli-int64"><span class="toc-text">func (t Time) UnixMilli() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-UnixNano-int64"><span class="toc-text">func (t Time) UnixNano() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-UnmarshalBinary-data-byte-error"><span class="toc-text">func (t*Time) UnmarshalBinary(data []byte) error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-UnmarshalJSON-data-byte-error"><span class="toc-text">func (t *Time) UnmarshalJSON(data []byte) error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-UnmarshalText-data-byte-error"><span class="toc-text">func (t*Time) UnmarshalText(data []byte) error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Weekday-Weekday"><span class="toc-text">func (t Time) Weekday() Weekday</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Year-int"><span class="toc-text">func (t Time) Year() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-YearDay-int"><span class="toc-text">func (t Time) YearDay() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-Zone-name-string-offset-int"><span class="toc-text">func (t Time) Zone() (name string, offset int)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Time-ZoneBounds-start-end-Time"><span class="toc-text">func (t Time) ZoneBounds() (start, end Time)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-Timer"><span class="toc-text">type Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-AfterFunc-d-Duration-f-func-Timer"><span class="toc-text">func AfterFunc(d Duration, f func()) *Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewTimer-d-Duration-Timer"><span class="toc-text">func NewTimer(d Duration)*Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Timer-Reset-d-Duration-bool"><span class="toc-text">func (t *Timer) Reset(d Duration) bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Timer-Stop-bool"><span class="toc-text">func (t*Timer) Stop() bool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Weekday"><span class="toc-text">type Weekday</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-d-Weekday-String-string"><span class="toc-text">func (d Weekday) String() string</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rand"><span class="toc-text">rand</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#function-not-method-of-rand"><span class="toc-text">function not method of rand</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-ExpFloat64-float64"><span class="toc-text">func ExpFloat64() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Float32-float32"><span class="toc-text">func Float32() float32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Float64-float64"><span class="toc-text">func Float64() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Int-int"><span class="toc-text">func Int() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Int31-int32"><span class="toc-text">func Int31() int32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Int31n-n-int32-int32"><span class="toc-text">func Int31n(n int32) int32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Int63-int64"><span class="toc-text">func Int63() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Int63n-n-int64-int64"><span class="toc-text">func Int63n(n int64) int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Intn-n-int-int"><span class="toc-text">func Intn(n int) int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NormFloat64-float64"><span class="toc-text">func NormFloat64() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Perm-n-int-int"><span class="toc-text">func Perm(n int) []int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Read-p-byte-n-int-err-error"><span class="toc-text">func Read(p []byte) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Seed-seed-int64"><span class="toc-text">func Seed(seed int64)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Shuffle-n-int-swap-func-i-j-int"><span class="toc-text">func Shuffle(n int, swap func(i, j int))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Uint32-uint32"><span class="toc-text">func Uint32() uint32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Uint64-uint64"><span class="toc-text">func Uint64() uint64</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Rand"><span class="toc-text">type Rand</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-New-src-Source-Rand"><span class="toc-text">func New(src Source) *Rand</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-ExpFloat64-float64"><span class="toc-text">func (r*Rand) ExpFloat64() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Float32-float32"><span class="toc-text">func (r *Rand) Float32() float32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Float64-float64"><span class="toc-text">func (r*Rand) Float64() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Int-int"><span class="toc-text">func (r *Rand) Int() int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Int31-int32"><span class="toc-text">func (r*Rand) Int31() int32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Int31n-n-int32-int32"><span class="toc-text">func (r *Rand) Int31n(n int32) int32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Int63-int64"><span class="toc-text">func (r*Rand) Int63() int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Int63n-n-int64-int64"><span class="toc-text">func (r *Rand) Int63n(n int64) int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Intn-n-int-int"><span class="toc-text">func (r*Rand) Intn(n int) int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-NormFloat64-float64"><span class="toc-text">func (r *Rand) NormFloat64() float64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Perm-n-int-int"><span class="toc-text">func (r*Rand) Perm(n int) []int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Read-p-byte-n-int-err-error"><span class="toc-text">func (r *Rand) Read(p []byte) (n int, err error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Seed-seed-int64"><span class="toc-text">func (r*Rand) Seed(seed int64)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Shuffle-n-int-swap-func-i-j-int"><span class="toc-text">func (r *Rand) Shuffle(n int, swap func(i, j int))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Uint32-uint32"><span class="toc-text">func (r*Rand) Uint32() uint32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-r-Rand-Uint64-uint64"><span class="toc-text">func (r *Rand) Uint64() uint64</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Source"><span class="toc-text">type Source</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewSource-seed-int64-Source"><span class="toc-text">func NewSource(seed int64) Source</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Source64"><span class="toc-text">type Source64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-Zipf"><span class="toc-text">type Zipf</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf"><span class="toc-text">func NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-z-Zipf-Uint64-uint64"><span class="toc-text">func (z *Zipf) Uint64() uint64</span></a></li></ol></li></ol></li></ol>

<h1 id="package-tar"><a href="#package-tar" class="headerlink" title="package tar"></a>package tar</h1><p>  Package tar implements access to tar archives.</p>
<p>  Tape(封装,胶带) archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.</p>
<h2 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  &#x2F;&#x2F; Type &#39;0&#39; indicates a regular file.
  TypeReg  &#x3D; &#39;0&#39;
  TypeRegA &#x3D; &#39;\x00&#39; &#x2F;&#x2F; Deprecated: Use TypeReg instead.

  &#x2F;&#x2F; Type &#39;1&#39; to &#39;6&#39; are header-only flags and may not have a data body.
  TypeLink    &#x3D; &#39;1&#39; &#x2F;&#x2F; Hard link
  TypeSymlink &#x3D; &#39;2&#39; &#x2F;&#x2F; Symbolic link
  TypeChar    &#x3D; &#39;3&#39; &#x2F;&#x2F; Character device node
  TypeBlock   &#x3D; &#39;4&#39; &#x2F;&#x2F; Block device node
  TypeDir     &#x3D; &#39;5&#39; &#x2F;&#x2F; Directory
  TypeFifo    &#x3D; &#39;6&#39; &#x2F;&#x2F; FIFO node

  &#x2F;&#x2F; Type &#39;7&#39; is reserved.
  TypeCont &#x3D; &#39;7&#39;

  &#x2F;&#x2F; Type &#39;x&#39; is used by the PAX format to store key-value records that
  &#x2F;&#x2F; are only relevant to the next file.
  &#x2F;&#x2F; This package transparently handles these types.
  TypeXHeader &#x3D; &#39;x&#39;

  &#x2F;&#x2F; Type &#39;g&#39; is used by the PAX format to store key-value records that
  &#x2F;&#x2F; are relevant to all subsequent files.
  &#x2F;&#x2F; This package only supports parsing and composing such headers,
  &#x2F;&#x2F; but does not currently support persisting the global state across files.
  TypeXGlobalHeader &#x3D; &#39;g&#39;

  &#x2F;&#x2F; Type &#39;S&#39; indicates a sparse file in the GNU format.
  TypeGNUSparse &#x3D; &#39;S&#39;

  &#x2F;&#x2F; Types &#39;L&#39; and &#39;K&#39; are used by the GNU format for a meta file
  &#x2F;&#x2F; used to store the path or link name for the next file.
  &#x2F;&#x2F; This package transparently handles these types.
  TypeGNULongName &#x3D; &#39;L&#39;
  TypeGNULongLink &#x3D; &#39;K&#39;
)</code></pre>

<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">var (
  ErrHeader          &#x3D; errors.New(&quot;archive&#x2F;tar: invalid tar header&quot;)
  ErrWriteTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: write too long&quot;)
  ErrFieldTooLong    &#x3D; errors.New(&quot;archive&#x2F;tar: header field too long&quot;)
  ErrWriteAfterClose &#x3D; errors.New(&quot;archive&#x2F;tar: write after close&quot;)
)</code></pre>

<h2 id="type-Format"><a href="#type-Format" class="headerlink" title="type Format"></a>type Format</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">type Format int</code></pre>

<p>  Format represents the tar archive format.The original tar format was introduced in Unix V7. Since then, there have been multiple competing(相互竞争) formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the <strong>USTAR</strong>, <strong>PAX</strong>, and <strong>GNU</strong> formats, each with their own advantages and limitations.</p>
<p>  The following table captures the capabilities of each format:</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">                  |  USTAR |       PAX |       GNU
------------------+--------+-----------+----------
Name              |   256B | unlimited | unlimited
Linkname          |   100B | unlimited | unlimited
Size              | uint33 | unlimited |    uint89
Mode              | uint21 |    uint21 |    uint57
Uid&#x2F;Gid           | uint21 | unlimited |    uint57
Uname&#x2F;Gname       |    32B | unlimited |       32B
ModTime           | uint33 | unlimited |     int89
AccessTime        |    n&#x2F;a | unlimited |     int89
ChangeTime        |    n&#x2F;a | unlimited |     int89
Devmajor&#x2F;Devminor | uint21 |    uint21 |    uint57
------------------+--------+-----------+----------
string encoding   |  ASCII |     UTF-8 |    binary
sub-second times  |     no |       yes |        no
sparse files      |     no |       yes |       yes</code></pre>

<p>  The table’s upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</p>
<p>  The table’s lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</p>
<p>  The Writer currently provides no support for sparse files.</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">const (

&#x2F;&#x2F; FormatUnknown indicates that the format is unknown.
FormatUnknown Format
&#x2F;&#x2F; FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.
&#x2F;&#x2F;
&#x2F;&#x2F; While this format is compatible with most tar readers,
&#x2F;&#x2F; the format has several limitations making it unsuitable for some usages.
&#x2F;&#x2F; Most notably, it cannot support sparse files, files larger than 8GiB,
&#x2F;&#x2F; filenames larger than 256 characters, and non-ASCII filenames.
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;pax.html#tag_20_92_13_06
FormatUSTAR
&#x2F;&#x2F; FormatPAX represents the PAX header format defined in POSIX.1-2001.
&#x2F;&#x2F;
&#x2F;&#x2F; PAX extends USTAR by writing a special file with Typeflag TypeXHeader
&#x2F;&#x2F; preceding the original header. This file contains a set of key-value
&#x2F;&#x2F; records, which are used to overcome USTAR\&#39;s shortcomings, in addition to
&#x2F;&#x2F; providing the ability to have sub-second resolution for timestamps.
&#x2F;&#x2F;
&#x2F;&#x2F; Some newer formats add their own extensions to PAX by defining their
&#x2F;&#x2F; own keys and assigning certain semantic meaning to the associated values.
&#x2F;&#x2F; For example, sparse file support in PAX is implemented using keys
&#x2F;&#x2F; defined by the GNU manual (e.g., &quot;GNU.sparse.map&quot;).
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; http:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;utilities&#x2F;pax.html
FormatPAX
&#x2F;&#x2F; FormatGNU represents the GNU header format.
&#x2F;&#x2F;
&#x2F;&#x2F; The GNU header format is older than the USTAR and PAX standards and
&#x2F;&#x2F; is not compatible with them. The GNU format supports
&#x2F;&#x2F; arbitrary file sizes, filenames of arbitrary encoding and length,
&#x2F;&#x2F; sparse files, and other features.
&#x2F;&#x2F;
&#x2F;&#x2F; It is recommended that PAX be chosen over GNU unless the target
&#x2F;&#x2F; application can only parse GNU formatted archives.
&#x2F;&#x2F;
&#x2F;&#x2F; Reference:
&#x2F;&#x2F; https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;tar&#x2F;manual&#x2F;html_node&#x2F;Standard.html
FormatGNU
)
</code></pre>

<h3 id="func-f-Format-String-string"><a href="#func-f-Format-String-string" class="headerlink" title="func (f Format) String() string"></a>func (f Format) String() string</h3><p>  打印tar的格式</p>
<h2 id="type-Header"><a href="#type-Header" class="headerlink" title="type Header"></a>type Header</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">  type Header struct &#123;
  &#x2F;&#x2F; Typeflag is the type of header entry.
  &#x2F;&#x2F; The zero value is automatically promoted to either TypeReg or TypeDir
  &#x2F;&#x2F; depending on the presence of a trailing slash in Name.
  Typeflag byte

  Name     string &#x2F;&#x2F; Name of file entry
  Linkname string &#x2F;&#x2F; Target name of link (valid for TypeLink or TypeSymlink)

  Size  int64  &#x2F;&#x2F; Logical file size in bytes
  Mode  int64  &#x2F;&#x2F; Permission and mode bits
  Uid   int    &#x2F;&#x2F; User ID of owner
  Gid   int    &#x2F;&#x2F; Group ID of owner
  Uname string &#x2F;&#x2F; User name of owner
  Gname string &#x2F;&#x2F; Group name of owner

  &#x2F;&#x2F; If the Format is unspecified, then Writer.WriteHeader rounds ModTime
  &#x2F;&#x2F; to the nearest second and ignores the AccessTime and ChangeTime fields.
  &#x2F;&#x2F;
  &#x2F;&#x2F; To use AccessTime or ChangeTime, specify the Format as PAX or GNU.
  &#x2F;&#x2F; To use sub-second resolution, specify the Format as PAX.
  ModTime    time.Time &#x2F;&#x2F; Modification time
  AccessTime time.Time &#x2F;&#x2F; Access time (requires either PAX or GNU support)
  ChangeTime time.Time &#x2F;&#x2F; Change time (requires either PAX or GNU support)

  Devmajor int64 &#x2F;&#x2F; Major device number (valid for TypeChar or TypeBlock)
  Devminor int64 &#x2F;&#x2F; Minor device number (valid for TypeChar or TypeBlock)

  &#x2F;&#x2F; Xattrs stores extended attributes as PAX records under the
  &#x2F;&#x2F; &quot;SCHILY.xattr.&quot; namespace.
  &#x2F;&#x2F;
  &#x2F;&#x2F; The following are semantically equivalent:
  &#x2F;&#x2F;  h.Xattrs[key] &#x3D; value
  &#x2F;&#x2F;  h.PAXRecords[&quot;SCHILY.xattr.&quot;+key] &#x3D; value
  &#x2F;&#x2F;
  &#x2F;&#x2F; When Writer.WriteHeader is called, the contents of Xattrs will take
  &#x2F;&#x2F; precedence over those in PAXRecords.
  &#x2F;&#x2F;
  &#x2F;&#x2F; Deprecated: Use PAXRecords instead.
  Xattrs map[string]string

  &#x2F;&#x2F; PAXRecords is a map of PAX extended header records.
  &#x2F;&#x2F;
  &#x2F;&#x2F; User-defined records should have keys of the following form:
  &#x2F;&#x2F;	VENDOR.keyword
  &#x2F;&#x2F; Where VENDOR is some namespace in all uppercase, and keyword may
  &#x2F;&#x2F; not contain the &#39;&#x3D;&#39; character (e.g., &quot;GOLANG.pkg.version&quot;).
  &#x2F;&#x2F; The key and value should be non-empty UTF-8 strings.
  &#x2F;&#x2F;
  &#x2F;&#x2F; When Writer.WriteHeader is called, PAX records derived from the
  &#x2F;&#x2F; other fields in Header take precedence over PAXRecords.
  PAXRecords map[string]string

  &#x2F;&#x2F; Format specifies the format of the tar header.
  &#x2F;&#x2F;
  &#x2F;&#x2F; This is set by Reader.Next as a best-effort guess at the format.
  &#x2F;&#x2F; Since the Reader liberally reads some non-compliant files,
  &#x2F;&#x2F; it is possible for this to be FormatUnknown.
  &#x2F;&#x2F;
  &#x2F;&#x2F; If the format is unspecified when Writer.WriteHeader is called,
  &#x2F;&#x2F; then it uses the first format (in the order of USTAR, PAX, GNU)
  &#x2F;&#x2F; capable of encoding this Header (see Format).
  Format Format
&#125;
</code></pre>

<h3 id="func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error"><a href="#func-FileInfoHeader-fi-fs-FileInfo-link-string-Header-error" class="headerlink" title="func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)"></a>func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)</h3><h3 id="func-h-Header-FileInfo-fs-FileInfo"><a href="#func-h-Header-FileInfo-fs-FileInfo" class="headerlink" title="func (h*Header) FileInfo() fs.FileInfo"></a>func (h*Header) FileInfo() fs.FileInfo</h3><h2 id="type-Reader"><a href="#type-Reader" class="headerlink" title="type Reader"></a>type Reader</h2><h3 id="func-NewReader-r-io-Reader-Reader"><a href="#func-NewReader-r-io-Reader-Reader" class="headerlink" title="func NewReader(r io.Reader) *Reader"></a>func NewReader(r io.Reader) *Reader</h3><h3 id="func-tr-Reader-Next-Header-error"><a href="#func-tr-Reader-Next-Header-error" class="headerlink" title="func (tr*Reader) Next() (*Header, error)"></a>func (tr*Reader) Next() (*Header, error)</h3><h3 id="func-tr-Reader-Read-b-byte-int-error"><a href="#func-tr-Reader-Read-b-byte-int-error" class="headerlink" title="func (tr*Reader) Read(b []byte) (int, error)"></a>func (tr*Reader) Read(b []byte) (int, error)</h3><h2 id="type-Writer"><a href="#type-Writer" class="headerlink" title="type Writer"></a>type Writer</h2><h3 id="func-NewWriter-w-io-Writer-Writer"><a href="#func-NewWriter-w-io-Writer-Writer" class="headerlink" title="func NewWriter(w io.Writer) *Writer"></a>func NewWriter(w io.Writer) *Writer</h3><h3 id="func-tw-Writer-Close-error"><a href="#func-tw-Writer-Close-error" class="headerlink" title="func (tw*Writer) Close() error"></a>func (tw*Writer) Close() error</h3><h3 id="func-tw-Writer-Flush-error"><a href="#func-tw-Writer-Flush-error" class="headerlink" title="func (tw *Writer) Flush() error"></a>func (tw *Writer) Flush() error</h3><h3 id="func-tw-Writer-Write-b-byte-int-error"><a href="#func-tw-Writer-Write-b-byte-int-error" class="headerlink" title="func (tw*Writer) Write(b []byte) (int, error)"></a>func (tw*Writer) Write(b []byte) (int, error)</h3><h3 id="func-tw-Writer-WriteHeader-hdrHeader-error"><a href="#func-tw-Writer-WriteHeader-hdrHeader-error" class="headerlink" title="func (tw Writer) WriteHeader(hdrHeader) error"></a>func (tw <em>Writer) WriteHeader(hdr</em>Header) error</h3><h1 id="zip-package"><a href="#zip-package" class="headerlink" title="zip package"></a>zip package</h1><p>Package zip provides support for reading and writing ZIP archives.</p>
<h2 id="Constants-1"><a href="#Constants-1" class="headerlink" title="Constants"></a>Constants</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  Store   uint16 &#x3D; 0 &#x2F;&#x2F; no compression
  Deflate uint16 &#x3D; 8 &#x2F;&#x2F; DEFLATE compressed
)</code></pre>

<h2 id="Variables-1"><a href="#Variables-1" class="headerlink" title="Variables"></a>Variables</h2>  <pre class="language-golang" data-language="golang"><code class="language-golang">var (
  ErrFormat    &#x3D; errors.New(&quot;zip: not a valid zip file&quot;)
  ErrAlgorithm &#x3D; errors.New(&quot;zip: unsupported compression algorithm&quot;)
  ErrChecksum  &#x3D; errors.New(&quot;zip: checksum error&quot;)
)
</code></pre>

<h3 id="func-RegisterCompressor-method-uint16-comp-Compressor"><a href="#func-RegisterCompressor-method-uint16-comp-Compressor" class="headerlink" title="func RegisterCompressor(method uint16, comp Compressor)"></a>func RegisterCompressor(method uint16, comp Compressor)</h3><h3 id="func-RegisterDecompressor-method-uint16-dcomp-Decompressor"><a href="#func-RegisterDecompressor-method-uint16-dcomp-Decompressor" class="headerlink" title="func RegisterDecompressor(method uint16, dcomp Decompressor)"></a>func RegisterDecompressor(method uint16, dcomp Decompressor)</h3><h2 id="type-Compressor"><a href="#type-Compressor" class="headerlink" title="type Compressor"></a>type Compressor</h2><h2 id="type-Decompressor"><a href="#type-Decompressor" class="headerlink" title="type Decompressor"></a>type Decompressor</h2><h2 id="type-File"><a href="#type-File" class="headerlink" title="type File"></a>type File</h2><h3 id="func-f-File-DataOffset-offset-int64-err-error"><a href="#func-f-File-DataOffset-offset-int64-err-error" class="headerlink" title="func (f *File) DataOffset() (offset int64, err error)"></a>func (f *File) DataOffset() (offset int64, err error)</h3><h3 id="func-f-File-Open-io-ReadCloser-error"><a href="#func-f-File-Open-io-ReadCloser-error" class="headerlink" title="func (f*File) Open() (io.ReadCloser, error)"></a>func (f*File) Open() (io.ReadCloser, error)</h3><h3 id="func-f-File-OpenRaw-io-Reader-error"><a href="#func-f-File-OpenRaw-io-Reader-error" class="headerlink" title="func (f *File) OpenRaw() (io.Reader, error)"></a>func (f *File) OpenRaw() (io.Reader, error)</h3><h2 id="type-FileHeader"><a href="#type-FileHeader" class="headerlink" title="type FileHeader"></a>type FileHeader</h2><h3 id="func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error"><a href="#func-FileInfoHeader-fi-fs-FileInfo-FileHeader-error" class="headerlink" title="func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)"></a>func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</h3><h3 id="func-h-FileHeader-FileInfo-fs-FileInfo"><a href="#func-h-FileHeader-FileInfo-fs-FileInfo" class="headerlink" title="func (h *FileHeader) FileInfo() fs.FileInfo"></a>func (h *FileHeader) FileInfo() fs.FileInfo</h3><h3 id="func-h-FileHeader-ModTime-time-TimeDEPRECATED"><a href="#func-h-FileHeader-ModTime-time-TimeDEPRECATED" class="headerlink" title="func (h*FileHeader) ModTime() time.TimeDEPRECATED"></a>func (h*FileHeader) ModTime() time.TimeDEPRECATED</h3><h3 id="func-h-FileHeader-Mode-mode-fs-FileMode"><a href="#func-h-FileHeader-Mode-mode-fs-FileMode" class="headerlink" title="func (h *FileHeader) Mode() (mode fs.FileMode)"></a>func (h *FileHeader) Mode() (mode fs.FileMode)</h3><h3 id="func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED"><a href="#func-h-FileHeader-SetModTime-t-time-Time-DEPRECATED" class="headerlink" title="func (h*FileHeader) SetModTime(t time.Time)DEPRECATED"></a>func (h*FileHeader) SetModTime(t time.Time)DEPRECATED</h3><h3 id="func-h-FileHeader-SetMode-mode-fs-FileMode"><a href="#func-h-FileHeader-SetMode-mode-fs-FileMode" class="headerlink" title="func (h *FileHeader) SetMode(mode fs.FileMode)"></a>func (h *FileHeader) SetMode(mode fs.FileMode)</h3><h2 id="type-ReadCloser"><a href="#type-ReadCloser" class="headerlink" title="type ReadCloser"></a>type ReadCloser</h2><h3 id="func-OpenReader-name-string-ReadCloser-error"><a href="#func-OpenReader-name-string-ReadCloser-error" class="headerlink" title="func OpenReader(name string) (*ReadCloser, error)"></a>func OpenReader(name string) (*ReadCloser, error)</h3><h3 id="func-rc-ReadCloser-Close-error"><a href="#func-rc-ReadCloser-Close-error" class="headerlink" title="func (rc *ReadCloser) Close() error"></a>func (rc *ReadCloser) Close() error</h3><h2 id="type-Reader-1"><a href="#type-Reader-1" class="headerlink" title="type Reader"></a>type Reader</h2><h3 id="func-NewReader-r-io-ReaderAt-size-int64-Reader-error"><a href="#func-NewReader-r-io-ReaderAt-size-int64-Reader-error" class="headerlink" title="func NewReader(r io.ReaderAt, size int64) (*Reader, error)"></a>func NewReader(r io.ReaderAt, size int64) (*Reader, error)</h3><h3 id="func-r-Reader-Open-name-string-fs-File-error"><a href="#func-r-Reader-Open-name-string-fs-File-error" class="headerlink" title="func (r *Reader) Open(name string) (fs.File, error)"></a>func (r *Reader) Open(name string) (fs.File, error)</h3><h3 id="func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor"><a href="#func-z-Reader-RegisterDecompressor-method-uint16-dcomp-Decompressor" class="headerlink" title="func (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)"></a>func (z*Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</h3><h2 id="type-Writer-1"><a href="#type-Writer-1" class="headerlink" title="type Writer"></a>type Writer</h2><h3 id="func-NewWriter-w-io-Writer-Writer-1"><a href="#func-NewWriter-w-io-Writer-Writer-1" class="headerlink" title="func NewWriter(w io.Writer) *Writer"></a>func NewWriter(w io.Writer) *Writer</h3><h3 id="func-w-Writer-Close-error"><a href="#func-w-Writer-Close-error" class="headerlink" title="func (w*Writer) Close() error"></a>func (w*Writer) Close() error</h3><h3 id="func-w-Writer-Copy-f-File-error"><a href="#func-w-Writer-Copy-f-File-error" class="headerlink" title="func (w *Writer) Copy(f*File) error"></a>func (w *Writer) Copy(f*File) error</h3><h3 id="func-w-Writer-Create-name-string-io-Writer-error"><a href="#func-w-Writer-Create-name-string-io-Writer-error" class="headerlink" title="func (w *Writer) Create(name string) (io.Writer, error)"></a>func (w *Writer) Create(name string) (io.Writer, error)</h3><h3 id="func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error"><a href="#func-w-Writer-CreateHeader-fh-FileHeader-io-Writer-error" class="headerlink" title="func (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)"></a>func (w*Writer) CreateHeader(fh*FileHeader) (io.Writer, error)</h3><h3 id="func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error"><a href="#func-w-Writer-CreateRaw-fh-FileHeader-io-Writer-error" class="headerlink" title="func (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)"></a>func (w*Writer) CreateRaw(fh*FileHeader) (io.Writer, error)</h3><h3 id="func-w-Writer-Flush-error"><a href="#func-w-Writer-Flush-error" class="headerlink" title="func (w*Writer) Flush() error"></a>func (w*Writer) Flush() error</h3><h3 id="func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor"><a href="#func-w-Writer-RegisterCompressor-method-uint16-comp-Compressor" class="headerlink" title="func (w *Writer) RegisterCompressor(method uint16, comp Compressor)"></a>func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</h3><h3 id="func-w-Writer-SetComment-comment-string-error"><a href="#func-w-Writer-SetComment-comment-string-error" class="headerlink" title="func (w*Writer) SetComment(comment string) error"></a>func (w*Writer) SetComment(comment string) error</h3><h3 id="func-w-Writer-SetOffset-n-int64"><a href="#func-w-Writer-SetOffset-n-int64" class="headerlink" title="func (w *Writer) SetOffset(n int64)"></a>func (w *Writer) SetOffset(n int64)</h3><h1 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h1><p>Package bufio implements buffered I&#x2F;O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual(adj.本文的,按原文的) I&#x2F;O.</p>
<p><strong>Constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	&#x2F;&#x2F; MaxScanTokenSize is the maximum size used to buffer a token
	&#x2F;&#x2F; unless the user provides an explicit buffer with Scanner.Buffer.
	&#x2F;&#x2F; The actual maximum token size may be smaller as the buffer
	&#x2F;&#x2F; may need to include, for instance, a newline.
	MaxScanTokenSize &#x3D; 64 * 1024
)</code></pre>
<p><strong>Variables</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var (
	ErrInvalidUnreadByte &#x3D; errors.New(&quot;bufio: invalid use of UnreadByte&quot;)
	ErrInvalidUnreadRune &#x3D; errors.New(&quot;bufio: invalid use of UnreadRune&quot;)
	ErrBufferFull        &#x3D; errors.New(&quot;bufio: buffer full&quot;)
	ErrNegativeCount     &#x3D; errors.New(&quot;bufio: negative count&quot;)
)
var (
	ErrTooLong         &#x3D; errors.New(&quot;bufio.Scanner: token too long&quot;)
	ErrNegativeAdvance &#x3D; errors.New(&quot;bufio.Scanner: SplitFunc returns negative advance count&quot;)
	ErrAdvanceTooFar   &#x3D; errors.New(&quot;bufio.Scanner: SplitFunc returns advance count beyond input&quot;)
	ErrBadReadCount    &#x3D; errors.New(&quot;bufio.Scanner: Read returned impossible count&quot;)
)
Errors returned by Scanner.
var ErrFinalToken &#x3D; errors.New(&quot;final token&quot;)
</code></pre>
<p><code>ErrFinalToken</code> is a special sentinel error value. It is intended to be returned by a Split(vt.分离) function to indicate that the token being delivered with the error is the last token and scanning should stop after this one. After ErrFinalToken is received by Scan, scanning stops with no error. The value is useful to stop processing early or when it is necessary to deliver a final empty token. One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value.</p>
<h2 id="func-ScanBytes-data-byte-atEOF-bool-advance-int-token-byte-err-error"><a href="#func-ScanBytes-data-byte-atEOF-bool-advance-int-token-byte-err-error" class="headerlink" title="func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)"></a>func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</h2><p>ScanBytes is a split function for a Scanner that returns each byte as a token.</p>
<h2 id="func-ScanLines-data-byte-atEOF-bool-advance-int-token-byte-err-error"><a href="#func-ScanLines-data-byte-atEOF-bool-advance-int-token-byte-err-error" class="headerlink" title="func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)"></a>func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</h2><h2 id="func-ScanRunes-data-byte-atEOF-bool-advance-int-token-byte-err-error"><a href="#func-ScanRunes-data-byte-atEOF-bool-advance-int-token-byte-err-error" class="headerlink" title="func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)"></a>func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)</h2><h2 id="func-ScanWords-data-byte-atEOF-bool-advance-int-token-byte-err-error"><a href="#func-ScanWords-data-byte-atEOF-bool-advance-int-token-byte-err-error" class="headerlink" title="func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)"></a>func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</h2><h2 id="type-ReadWriter"><a href="#type-ReadWriter" class="headerlink" title="type ReadWriter"></a>type ReadWriter</h2><pre class="language-goalng" data-language="goalng"><code class="language-goalng">type ReadWriter struct &#123;
	*Reader
	*Writer
&#125;</code></pre>

<h3 id="func-NewReadWriter-r-Reader-w-Writer-ReadWriter"><a href="#func-NewReadWriter-r-Reader-w-Writer-ReadWriter" class="headerlink" title="func NewReadWriter(r *Reader, w *Writer) *ReadWriter"></a>func NewReadWriter(r *Reader, w *Writer) *ReadWriter</h3><h2 id="type-Reader-2"><a href="#type-Reader-2" class="headerlink" title="type Reader"></a>type Reader</h2><pre class="language-golang" data-language="golang"><code class="language-golang">type Reader struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<h2 id="func-NewReader-rd-io-Reader-Reader"><a href="#func-NewReader-rd-io-Reader-Reader" class="headerlink" title="func NewReader(rd io.Reader) *Reader"></a>func NewReader(rd io.Reader) *Reader</h2><h2 id="func-NewReaderSize-rd-io-Reader-size-int-Reader"><a href="#func-NewReaderSize-rd-io-Reader-size-int-Reader" class="headerlink" title="func NewReaderSize(rd io.Reader, size int) *Reader"></a>func NewReaderSize(rd io.Reader, size int) *Reader</h2><h3 id="func-b-Reader-Buffered-int"><a href="#func-b-Reader-Buffered-int" class="headerlink" title="func (b *Reader) Buffered() int"></a>func (b *Reader) Buffered() int</h3><h3 id="func-b-Reader-Discard-n-int-discarded-int-err-error"><a href="#func-b-Reader-Discard-n-int-discarded-int-err-error" class="headerlink" title="func (b *Reader) Discard(n int) (discarded int, err error)"></a>func (b *Reader) Discard(n int) (discarded int, err error)</h3><h3 id="func-b-Reader-Peek-n-int-byte-error"><a href="#func-b-Reader-Peek-n-int-byte-error" class="headerlink" title="func (b *Reader) Peek(n int) ([]byte, error)"></a>func (b *Reader) Peek(n int) ([]byte, error)</h3><h3 id="func-b-Reader-Read-p-byte-n-int-err-error"><a href="#func-b-Reader-Read-p-byte-n-int-err-error" class="headerlink" title="func (b *Reader) Read(p []byte) (n int, err error)"></a>func (b *Reader) Read(p []byte) (n int, err error)</h3><h3 id="func-b-Reader-ReadByte-byte-error"><a href="#func-b-Reader-ReadByte-byte-error" class="headerlink" title="func (b *Reader) ReadByte() (byte, error)"></a>func (b *Reader) ReadByte() (byte, error)</h3><h3 id="func-b-Reader-ReadBytes-delim-byte-byte-error"><a href="#func-b-Reader-ReadBytes-delim-byte-byte-error" class="headerlink" title="func (b *Reader) ReadBytes(delim byte) ([]byte, error)"></a>func (b *Reader) ReadBytes(delim byte) ([]byte, error)</h3><h3 id="func-b-Reader-ReadLine-line-byte-isPrefix-bool-err-error"><a href="#func-b-Reader-ReadLine-line-byte-isPrefix-bool-err-error" class="headerlink" title="func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)"></a>func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</h3><h3 id="func-b-Reader-ReadRune-r-rune-size-int-err-error"><a href="#func-b-Reader-ReadRune-r-rune-size-int-err-error" class="headerlink" title="func (b *Reader) ReadRune() (r rune, size int, err error)"></a>func (b *Reader) ReadRune() (r rune, size int, err error)</h3><h3 id="func-b-Reader-ReadSlice-delim-byte-line-byte-err-error"><a href="#func-b-Reader-ReadSlice-delim-byte-line-byte-err-error" class="headerlink" title="func (b *Reader) ReadSlice(delim byte) (line []byte, err error)"></a>func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</h3><h3 id="func-b-Reader-ReadString-delim-byte-string-error"><a href="#func-b-Reader-ReadString-delim-byte-string-error" class="headerlink" title="func (b *Reader) ReadString(delim byte) (string, error)"></a>func (b *Reader) ReadString(delim byte) (string, error)</h3><h3 id="func-b-Reader-Reset-r-io-Reader"><a href="#func-b-Reader-Reset-r-io-Reader" class="headerlink" title="func (b *Reader) Reset(r io.Reader)"></a>func (b *Reader) Reset(r io.Reader)</h3><h3 id="func-b-Reader-Size-int"><a href="#func-b-Reader-Size-int" class="headerlink" title="func (b *Reader) Size() int"></a>func (b *Reader) Size() int</h3><h3 id="func-b-Reader-UnreadByte-error"><a href="#func-b-Reader-UnreadByte-error" class="headerlink" title="func (b *Reader) UnreadByte() error"></a>func (b *Reader) UnreadByte() error</h3><h3 id="func-b-Reader-UnreadRune-error"><a href="#func-b-Reader-UnreadRune-error" class="headerlink" title="func (b *Reader) UnreadRune() error"></a>func (b *Reader) UnreadRune() error</h3><h3 id="func-b-Reader-WriteTo-w-io-Writer-n-int64-err-error"><a href="#func-b-Reader-WriteTo-w-io-Writer-n-int64-err-error" class="headerlink" title="func (b *Reader) WriteTo(w io.Writer) (n int64, err error)"></a>func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</h3><h2 id="type-Scanner"><a href="#type-Scanner" class="headerlink" title="type Scanner"></a>type Scanner</h2><pre class="language-golang" data-language="golang"><code class="language-golang">type Scanner struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<h2 id="func-NewScanner-r-io-Reader-Scanner"><a href="#func-NewScanner-r-io-Reader-Scanner" class="headerlink" title="func NewScanner(r io.Reader) *Scanner"></a>func NewScanner(r io.Reader) *Scanner</h2><h3 id="func-s-Scanner-Buffer-buf-byte-max-int"><a href="#func-s-Scanner-Buffer-buf-byte-max-int" class="headerlink" title="func (s *Scanner) Buffer(buf []byte, max int)"></a>func (s *Scanner) Buffer(buf []byte, max int)</h3><h3 id="func-s-Scanner-Bytes-byte"><a href="#func-s-Scanner-Bytes-byte" class="headerlink" title="func (s *Scanner) Bytes() []byte"></a>func (s *Scanner) Bytes() []byte</h3><h3 id="func-s-Scanner-Err-error"><a href="#func-s-Scanner-Err-error" class="headerlink" title="func (s *Scanner) Err() error"></a>func (s *Scanner) Err() error</h3><h3 id="func-s-Scanner-Scan-bool"><a href="#func-s-Scanner-Scan-bool" class="headerlink" title="func (s *Scanner) Scan() bool"></a>func (s *Scanner) Scan() bool</h3><h3 id="func-s-Scanner-Split-split-SplitFunc"><a href="#func-s-Scanner-Split-split-SplitFunc" class="headerlink" title="func (s *Scanner) Split(split SplitFunc)"></a>func (s *Scanner) Split(split SplitFunc)</h3><h3 id="func-s-Scanner-Text-string"><a href="#func-s-Scanner-Text-string" class="headerlink" title="func (s *Scanner) Text() string"></a>func (s *Scanner) Text() string</h3><h2 id="type-SplitFunc"><a href="#type-SplitFunc" class="headerlink" title="type SplitFunc"></a>type SplitFunc</h2><pre class="language-golang" data-language="golang"><code class="language-golang">type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
</code></pre>
<h2 id="type-Writer-2"><a href="#type-Writer-2" class="headerlink" title="type Writer"></a>type Writer</h2><pre class="language-golng" data-language="golng"><code class="language-golng">type Writer struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>

<h2 id="func-NewWriter-w-io-Writer-Writer-2"><a href="#func-NewWriter-w-io-Writer-Writer-2" class="headerlink" title="func NewWriter(w io.Writer) *Writer"></a>func NewWriter(w io.Writer) *Writer</h2><h2 id="func-NewWriterSize-w-io-Writer-size-int-Writer"><a href="#func-NewWriterSize-w-io-Writer-size-int-Writer" class="headerlink" title="func NewWriterSize(w io.Writer, size int) *Writer"></a>func NewWriterSize(w io.Writer, size int) *Writer</h2><h3 id="func-b-Writer-Available-int"><a href="#func-b-Writer-Available-int" class="headerlink" title="func (b *Writer) Available() int"></a>func (b *Writer) Available() int</h3><h3 id="func-b-Writer-AvailableBuffer-byte"><a href="#func-b-Writer-AvailableBuffer-byte" class="headerlink" title="func (b *Writer) AvailableBuffer() []byte"></a>func (b *Writer) AvailableBuffer() []byte</h3><h3 id="func-b-Writer-Buffered-int"><a href="#func-b-Writer-Buffered-int" class="headerlink" title="func (b *Writer) Buffered() int"></a>func (b *Writer) Buffered() int</h3><h3 id="func-b-Writer-Flush-error"><a href="#func-b-Writer-Flush-error" class="headerlink" title="func (b *Writer) Flush() error"></a>func (b *Writer) Flush() error</h3><h3 id="func-b-Writer-ReadFrom-r-io-Reader-n-int64-err-error"><a href="#func-b-Writer-ReadFrom-r-io-Reader-n-int64-err-error" class="headerlink" title="func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)"></a>func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</h3><h3 id="func-b-Writer-Reset-w-io-Writer"><a href="#func-b-Writer-Reset-w-io-Writer" class="headerlink" title="func (b *Writer) Reset(w io.Writer)"></a>func (b *Writer) Reset(w io.Writer)</h3><h3 id="func-b-Writer-Size-int"><a href="#func-b-Writer-Size-int" class="headerlink" title="func (b *Writer) Size() int"></a>func (b *Writer) Size() int</h3><h3 id="func-b-Writer-Write-p-byte-nn-int-err-error"><a href="#func-b-Writer-Write-p-byte-nn-int-err-error" class="headerlink" title="func (b *Writer) Write(p []byte) (nn int, err error)"></a>func (b *Writer) Write(p []byte) (nn int, err error)</h3><h3 id="func-b-Writer-WriteByte-c-byte-error"><a href="#func-b-Writer-WriteByte-c-byte-error" class="headerlink" title="func (b *Writer) WriteByte(c byte) error"></a>func (b *Writer) WriteByte(c byte) error</h3><h3 id="func-b-Writer-WriteRune-r-rune-size-int-err-error"><a href="#func-b-Writer-WriteRune-r-rune-size-int-err-error" class="headerlink" title="func (b *Writer) WriteRune(r rune) (size int, err error)"></a>func (b *Writer) WriteRune(r rune) (size int, err error)</h3><h3 id="func-b-Writer-WriteString-s-string-int-error"><a href="#func-b-Writer-WriteString-s-string-int-error" class="headerlink" title="func (b *Writer) WriteString(s string) (int, error)"></a>func (b *Writer) WriteString(s string) (int, error)</h3><h1 id="builtin"><a href="#builtin" class="headerlink" title="builtin"></a>builtin</h1><p>Package builtin provides documentation for Go’s predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language’s special identifiers.</p>
<p><strong>Constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	true  &#x3D; 0 &#x3D;&#x3D; 0 &#x2F;&#x2F; Untyped bool.
	false &#x3D; 0 !&#x3D; 0 &#x2F;&#x2F; Untyped bool.
)
const iota &#x3D; 0 &#x2F;&#x2F; Untyped int.</code></pre>

<p><strong>variables</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var nil Type &#x2F;&#x2F; Type must be a pointer, channel, func, interface, map, or slice type</code></pre>

<h2 id="func-append-slice-Type-elems-…Type-Type"><a href="#func-append-slice-Type-elems-…Type-Type" class="headerlink" title="func append(slice []Type, elems …Type) []Type"></a>func append(slice []Type, elems …Type) []Type</h2><h2 id="func-cap-v-Type-int"><a href="#func-cap-v-Type-int" class="headerlink" title="func cap(v Type) int"></a>func cap(v Type) int</h2><h2 id="func-close-c-chan-lt-Type"><a href="#func-close-c-chan-lt-Type" class="headerlink" title="func close(c chan&lt;- Type)"></a>func close(c chan&lt;- Type)</h2><h2 id="func-complex-r-i-FloatType-ComplexType"><a href="#func-complex-r-i-FloatType-ComplexType" class="headerlink" title="func complex(r, i FloatType) ComplexType"></a>func complex(r, i FloatType) ComplexType</h2><h2 id="func-copy-dst-src-Type-int"><a href="#func-copy-dst-src-Type-int" class="headerlink" title="func copy(dst, src []Type) int"></a>func copy(dst, src []Type) int</h2><h2 id="func-delete-m-map-Type-Type1-key-Type"><a href="#func-delete-m-map-Type-Type1-key-Type" class="headerlink" title="func delete(m map[Type]Type1, key Type)"></a>func delete(m map[Type]Type1, key Type)</h2><h2 id="func-imag-c-ComplexType-FloatType"><a href="#func-imag-c-ComplexType-FloatType" class="headerlink" title="func imag(c ComplexType) FloatType"></a>func imag(c ComplexType) FloatType</h2><h2 id="func-len-v-Type-int"><a href="#func-len-v-Type-int" class="headerlink" title="func len(v Type) int"></a>func len(v Type) int</h2><h2 id="func-make-t-Type-size-…IntegerType-Type"><a href="#func-make-t-Type-size-…IntegerType-Type" class="headerlink" title="func make(t Type, size …IntegerType) Type"></a>func make(t Type, size …IntegerType) Type</h2><h2 id="func-new-Type-Type"><a href="#func-new-Type-Type" class="headerlink" title="func new(Type) *Type"></a>func new(Type) *Type</h2><h2 id="func-panic-v-any"><a href="#func-panic-v-any" class="headerlink" title="func panic(v any)"></a>func panic(v any)</h2><h2 id="func-print-args-…Type"><a href="#func-print-args-…Type" class="headerlink" title="func print(args …Type)"></a>func print(args …Type)</h2><h2 id="func-println-args-…Type"><a href="#func-println-args-…Type" class="headerlink" title="func println(args …Type)"></a>func println(args …Type)</h2><h2 id="func-real-c-ComplexType-FloatType"><a href="#func-real-c-ComplexType-FloatType" class="headerlink" title="func real(c ComplexType) FloatType"></a>func real(c ComplexType) FloatType</h2><h2 id="func-recover-any"><a href="#func-recover-any" class="headerlink" title="func recover() any"></a>func recover() any</h2><h2 id="type-ComplexType"><a href="#type-ComplexType" class="headerlink" title="type ComplexType"></a>type ComplexType</h2><h2 id="type-FloatType"><a href="#type-FloatType" class="headerlink" title="type FloatType"></a>type FloatType</h2><h2 id="type-IntegerType"><a href="#type-IntegerType" class="headerlink" title="type IntegerType"></a>type IntegerType</h2><h2 id="type-Type"><a href="#type-Type" class="headerlink" title="type Type"></a>type Type</h2><h2 id="type-Type1"><a href="#type-Type1" class="headerlink" title="type Type1"></a>type Type1</h2><h2 id="type-any"><a href="#type-any" class="headerlink" title="type any"></a>type any</h2><h2 id="type-bool"><a href="#type-bool" class="headerlink" title="type bool"></a>type bool</h2><h2 id="type-byte"><a href="#type-byte" class="headerlink" title="type byte"></a>type byte</h2><h2 id="type-comparable"><a href="#type-comparable" class="headerlink" title="type comparable"></a>type comparable</h2><h2 id="type-complex128"><a href="#type-complex128" class="headerlink" title="type complex128"></a>type complex128</h2><h2 id="type-complex64"><a href="#type-complex64" class="headerlink" title="type complex64"></a>type complex64</h2><h2 id="type-error"><a href="#type-error" class="headerlink" title="type error"></a>type error</h2><h2 id="type-float32"><a href="#type-float32" class="headerlink" title="type float32"></a>type float32</h2><h2 id="type-float64"><a href="#type-float64" class="headerlink" title="type float64"></a>type float64</h2><h2 id="type-int"><a href="#type-int" class="headerlink" title="type int"></a>type int</h2><h2 id="type-int16"><a href="#type-int16" class="headerlink" title="type int16"></a>type int16</h2><h2 id="type-int32"><a href="#type-int32" class="headerlink" title="type int32"></a>type int32</h2><h2 id="type-int64"><a href="#type-int64" class="headerlink" title="type int64"></a>type int64</h2><h2 id="type-int8"><a href="#type-int8" class="headerlink" title="type int8"></a>type int8</h2><h2 id="type-rune"><a href="#type-rune" class="headerlink" title="type rune"></a>type rune</h2><h2 id="type-string"><a href="#type-string" class="headerlink" title="type string"></a>type string</h2><h2 id="type-uint"><a href="#type-uint" class="headerlink" title="type uint"></a>type uint</h2><h2 id="type-uint16"><a href="#type-uint16" class="headerlink" title="type uint16"></a>type uint16</h2><h2 id="type-uint32"><a href="#type-uint32" class="headerlink" title="type uint32"></a>type uint32</h2><h2 id="type-uint64"><a href="#type-uint64" class="headerlink" title="type uint64"></a>type uint64</h2><h2 id="type-uint8"><a href="#type-uint8" class="headerlink" title="type uint8"></a>type uint8</h2><h2 id="type-uintptr"><a href="#type-uintptr" class="headerlink" title="type uintptr"></a>type uintptr</h2><h1 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h1><p>Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.</p>
<p><strong>constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const MinRead &#x3D; 512</code></pre>

<p><strong>variables</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var ErrTooLarge &#x3D; errors.New(&quot;bytes.Buffer: too large&quot;)
</code></pre>
<h2 id="func-Compare-a-b-byte-int"><a href="#func-Compare-a-b-byte-int" class="headerlink" title="func Compare(a, b []byte) int"></a>func Compare(a, b []byte) int</h2><h2 id="func-Contains-b-subslice-byte-bool"><a href="#func-Contains-b-subslice-byte-bool" class="headerlink" title="func Contains(b, subslice []byte) bool"></a>func Contains(b, subslice []byte) bool</h2><h2 id="func-ContainsAny-b-byte-chars-string-bool"><a href="#func-ContainsAny-b-byte-chars-string-bool" class="headerlink" title="func ContainsAny(b []byte, chars string) bool"></a>func ContainsAny(b []byte, chars string) bool</h2><h2 id="func-ContainsRune-b-byte-r-rune-bool"><a href="#func-ContainsRune-b-byte-r-rune-bool" class="headerlink" title="func ContainsRune(b []byte, r rune) bool"></a>func ContainsRune(b []byte, r rune) bool</h2><h2 id="func-Count-s-sep-byte-int"><a href="#func-Count-s-sep-byte-int" class="headerlink" title="func Count(s, sep []byte) int"></a>func Count(s, sep []byte) int</h2><h2 id="func-Cut-s-sep-byte-before-after-byte-found-bool"><a href="#func-Cut-s-sep-byte-before-after-byte-found-bool" class="headerlink" title="func Cut(s, sep []byte) (before, after []byte, found bool)"></a>func Cut(s, sep []byte) (before, after []byte, found bool)</h2><h2 id="func-Equal-a-b-byte-bool"><a href="#func-Equal-a-b-byte-bool" class="headerlink" title="func Equal(a, b []byte) bool"></a>func Equal(a, b []byte) bool</h2><h2 id="func-EqualFold-s-t-byte-bool"><a href="#func-EqualFold-s-t-byte-bool" class="headerlink" title="func EqualFold(s, t []byte) bool"></a>func EqualFold(s, t []byte) bool</h2><h2 id="func-Fields-s-byte-byte"><a href="#func-Fields-s-byte-byte" class="headerlink" title="func Fields(s []byte) [][]byte"></a>func Fields(s []byte) [][]byte</h2><h2 id="func-FieldsFunc-s-byte-f-func-rune-bool-byte"><a href="#func-FieldsFunc-s-byte-f-func-rune-bool-byte" class="headerlink" title="func FieldsFunc(s []byte, f func(rune) bool) [][]byte"></a>func FieldsFunc(s []byte, f func(rune) bool) [][]byte</h2><h2 id="func-HasPrefix-s-prefix-byte-bool"><a href="#func-HasPrefix-s-prefix-byte-bool" class="headerlink" title="func HasPrefix(s, prefix []byte) bool"></a>func HasPrefix(s, prefix []byte) bool</h2><h2 id="func-HasSuffix-s-suffix-byte-bool"><a href="#func-HasSuffix-s-suffix-byte-bool" class="headerlink" title="func HasSuffix(s, suffix []byte) bool"></a>func HasSuffix(s, suffix []byte) bool</h2><h2 id="func-Index-s-sep-byte-int"><a href="#func-Index-s-sep-byte-int" class="headerlink" title="func Index(s, sep []byte) int"></a>func Index(s, sep []byte) int</h2><h2 id="func-IndexAny-s-byte-chars-string-int"><a href="#func-IndexAny-s-byte-chars-string-int" class="headerlink" title="func IndexAny(s []byte, chars string) int"></a>func IndexAny(s []byte, chars string) int</h2><h2 id="func-IndexByte-b-byte-c-byte-int"><a href="#func-IndexByte-b-byte-c-byte-int" class="headerlink" title="func IndexByte(b []byte, c byte) int"></a>func IndexByte(b []byte, c byte) int</h2><h2 id="func-IndexFunc-s-byte-f-func-r-rune-bool-int"><a href="#func-IndexFunc-s-byte-f-func-r-rune-bool-int" class="headerlink" title="func IndexFunc(s []byte, f func(r rune) bool) int"></a>func IndexFunc(s []byte, f func(r rune) bool) int</h2><h2 id="func-IndexRune-s-byte-r-rune-int"><a href="#func-IndexRune-s-byte-r-rune-int" class="headerlink" title="func IndexRune(s []byte, r rune) int"></a>func IndexRune(s []byte, r rune) int</h2><h2 id="func-Join-s-byte-sep-byte-byte"><a href="#func-Join-s-byte-sep-byte-byte" class="headerlink" title="func Join(s [][]byte, sep []byte) []byte"></a>func Join(s [][]byte, sep []byte) []byte</h2><h2 id="func-LastIndex-s-sep-byte-int"><a href="#func-LastIndex-s-sep-byte-int" class="headerlink" title="func LastIndex(s, sep []byte) int"></a>func LastIndex(s, sep []byte) int</h2><h2 id="func-LastIndexAny-s-byte-chars-string-int"><a href="#func-LastIndexAny-s-byte-chars-string-int" class="headerlink" title="func LastIndexAny(s []byte, chars string) int"></a>func LastIndexAny(s []byte, chars string) int</h2><h2 id="func-LastIndexByte-s-byte-c-byte-int"><a href="#func-LastIndexByte-s-byte-c-byte-int" class="headerlink" title="func LastIndexByte(s []byte, c byte) int"></a>func LastIndexByte(s []byte, c byte) int</h2><h2 id="func-LastIndexFunc-s-byte-f-func-r-rune-bool-int"><a href="#func-LastIndexFunc-s-byte-f-func-r-rune-bool-int" class="headerlink" title="func LastIndexFunc(s []byte, f func(r rune) bool) int"></a>func LastIndexFunc(s []byte, f func(r rune) bool) int</h2><h2 id="func-Map-mapping-func-r-rune-rune-s-byte-byte"><a href="#func-Map-mapping-func-r-rune-rune-s-byte-byte" class="headerlink" title="func Map(mapping func(r rune) rune, s []byte) []byte"></a>func Map(mapping func(r rune) rune, s []byte) []byte</h2><h2 id="func-Repeat-b-byte-count-int-byte"><a href="#func-Repeat-b-byte-count-int-byte" class="headerlink" title="func Repeat(b []byte, count int) []byte"></a>func Repeat(b []byte, count int) []byte</h2><h2 id="func-Replace-s-old-new-byte-n-int-byte"><a href="#func-Replace-s-old-new-byte-n-int-byte" class="headerlink" title="func Replace(s, old, new []byte, n int) []byte"></a>func Replace(s, old, new []byte, n int) []byte</h2><h2 id="func-ReplaceAll-s-old-new-byte-byte"><a href="#func-ReplaceAll-s-old-new-byte-byte" class="headerlink" title="func ReplaceAll(s, old, new []byte) []byte"></a>func ReplaceAll(s, old, new []byte) []byte</h2><h2 id="func-Runes-s-byte-rune"><a href="#func-Runes-s-byte-rune" class="headerlink" title="func Runes(s []byte) []rune"></a>func Runes(s []byte) []rune</h2><h2 id="func-Split-s-sep-byte-byte"><a href="#func-Split-s-sep-byte-byte" class="headerlink" title="func Split(s, sep []byte) [][]byte"></a>func Split(s, sep []byte) [][]byte</h2><h2 id="func-SplitAfter-s-sep-byte-byte"><a href="#func-SplitAfter-s-sep-byte-byte" class="headerlink" title="func SplitAfter(s, sep []byte) [][]byte"></a>func SplitAfter(s, sep []byte) [][]byte</h2><h2 id="func-SplitAfterN-s-sep-byte-n-int-byte"><a href="#func-SplitAfterN-s-sep-byte-n-int-byte" class="headerlink" title="func SplitAfterN(s, sep []byte, n int) [][]byte"></a>func SplitAfterN(s, sep []byte, n int) [][]byte</h2><h2 id="func-SplitN-s-sep-byte-n-int-byte"><a href="#func-SplitN-s-sep-byte-n-int-byte" class="headerlink" title="func SplitN(s, sep []byte, n int) [][]byte"></a>func SplitN(s, sep []byte, n int) [][]byte</h2><h2 id="func-Title-s-byte-byteDEPRECATED"><a href="#func-Title-s-byte-byteDEPRECATED" class="headerlink" title="func Title(s []byte) []byteDEPRECATED"></a>func Title(s []byte) []byteDEPRECATED</h2><h2 id="func-ToLower-s-byte-byte"><a href="#func-ToLower-s-byte-byte" class="headerlink" title="func ToLower(s []byte) []byte"></a>func ToLower(s []byte) []byte</h2><h2 id="func-ToLowerSpecial-c-unicode-SpecialCase-s-byte-byte"><a href="#func-ToLowerSpecial-c-unicode-SpecialCase-s-byte-byte" class="headerlink" title="func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte"></a>func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</h2><h2 id="func-ToTitle-s-byte-byte"><a href="#func-ToTitle-s-byte-byte" class="headerlink" title="func ToTitle(s []byte) []byte"></a>func ToTitle(s []byte) []byte</h2><h2 id="func-ToTitleSpecial-c-unicode-SpecialCase-s-byte-byte"><a href="#func-ToTitleSpecial-c-unicode-SpecialCase-s-byte-byte" class="headerlink" title="func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte"></a>func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</h2><h2 id="func-ToUpper-s-byte-byte"><a href="#func-ToUpper-s-byte-byte" class="headerlink" title="func ToUpper(s []byte) []byte"></a>func ToUpper(s []byte) []byte</h2><h2 id="func-ToUpperSpecial-c-unicode-SpecialCase-s-byte-byte"><a href="#func-ToUpperSpecial-c-unicode-SpecialCase-s-byte-byte" class="headerlink" title="func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte"></a>func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</h2><h2 id="func-ToValidUTF8-s-replacement-byte-byte"><a href="#func-ToValidUTF8-s-replacement-byte-byte" class="headerlink" title="func ToValidUTF8(s, replacement []byte) []byte"></a>func ToValidUTF8(s, replacement []byte) []byte</h2><h2 id="func-Trim-s-byte-cutset-string-byte"><a href="#func-Trim-s-byte-cutset-string-byte" class="headerlink" title="func Trim(s []byte, cutset string) []byte"></a>func Trim(s []byte, cutset string) []byte</h2><h2 id="func-TrimFunc-s-byte-f-func-r-rune-bool-byte"><a href="#func-TrimFunc-s-byte-f-func-r-rune-bool-byte" class="headerlink" title="func TrimFunc(s []byte, f func(r rune) bool) []byte"></a>func TrimFunc(s []byte, f func(r rune) bool) []byte</h2><h2 id="func-TrimLeft-s-byte-cutset-string-byte"><a href="#func-TrimLeft-s-byte-cutset-string-byte" class="headerlink" title="func TrimLeft(s []byte, cutset string) []byte"></a>func TrimLeft(s []byte, cutset string) []byte</h2><h2 id="func-TrimLeftFunc-s-byte-f-func-r-rune-bool-byte"><a href="#func-TrimLeftFunc-s-byte-f-func-r-rune-bool-byte" class="headerlink" title="func TrimLeftFunc(s []byte, f func(r rune) bool) []byte"></a>func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</h2><h2 id="func-TrimPrefix-s-prefix-byte-byte"><a href="#func-TrimPrefix-s-prefix-byte-byte" class="headerlink" title="func TrimPrefix(s, prefix []byte) []byte"></a>func TrimPrefix(s, prefix []byte) []byte</h2><h2 id="func-TrimRight-s-byte-cutset-string-byte"><a href="#func-TrimRight-s-byte-cutset-string-byte" class="headerlink" title="func TrimRight(s []byte, cutset string) []byte"></a>func TrimRight(s []byte, cutset string) []byte</h2><h2 id="func-TrimRightFunc-s-byte-f-func-r-rune-bool-byte"><a href="#func-TrimRightFunc-s-byte-f-func-r-rune-bool-byte" class="headerlink" title="func TrimRightFunc(s []byte, f func(r rune) bool) []byte"></a>func TrimRightFunc(s []byte, f func(r rune) bool) []byte</h2><h2 id="func-TrimSpace-s-byte-byte"><a href="#func-TrimSpace-s-byte-byte" class="headerlink" title="func TrimSpace(s []byte) []byte"></a>func TrimSpace(s []byte) []byte</h2><h2 id="func-TrimSuffix-s-suffix-byte-byte"><a href="#func-TrimSuffix-s-suffix-byte-byte" class="headerlink" title="func TrimSuffix(s, suffix []byte) []byte"></a>func TrimSuffix(s, suffix []byte) []byte</h2><h2 id="type-Buffer"><a href="#type-Buffer" class="headerlink" title="type Buffer"></a>type Buffer</h2><h2 id="func-NewBuffer-buf-byte-Buffer"><a href="#func-NewBuffer-buf-byte-Buffer" class="headerlink" title="func NewBuffer(buf []byte) *Buffer"></a>func NewBuffer(buf []byte) *Buffer</h2><h2 id="func-NewBufferString-s-string-Buffer"><a href="#func-NewBufferString-s-string-Buffer" class="headerlink" title="func NewBufferString(s string) *Buffer"></a>func NewBufferString(s string) *Buffer</h2><h3 id="func-b-Buffer-Bytes-byte"><a href="#func-b-Buffer-Bytes-byte" class="headerlink" title="func (b *Buffer) Bytes() []byte"></a>func (b *Buffer) Bytes() []byte</h3><h3 id="func-b-Buffer-Cap-int"><a href="#func-b-Buffer-Cap-int" class="headerlink" title="func (b *Buffer) Cap() int"></a>func (b *Buffer) Cap() int</h3><h3 id="func-b-Buffer-Grow-n-int"><a href="#func-b-Buffer-Grow-n-int" class="headerlink" title="func (b *Buffer) Grow(n int)"></a>func (b *Buffer) Grow(n int)</h3><h3 id="func-b-Buffer-Len-int"><a href="#func-b-Buffer-Len-int" class="headerlink" title="func (b *Buffer) Len() int"></a>func (b *Buffer) Len() int</h3><h3 id="func-b-Buffer-Next-n-int-byte"><a href="#func-b-Buffer-Next-n-int-byte" class="headerlink" title="func (b *Buffer) Next(n int) []byte"></a>func (b *Buffer) Next(n int) []byte</h3><h3 id="func-b-Buffer-Read-p-byte-n-int-err-error"><a href="#func-b-Buffer-Read-p-byte-n-int-err-error" class="headerlink" title="func (b *Buffer) Read(p []byte) (n int, err error)"></a>func (b *Buffer) Read(p []byte) (n int, err error)</h3><h3 id="func-b-Buffer-ReadByte-byte-error"><a href="#func-b-Buffer-ReadByte-byte-error" class="headerlink" title="func (b *Buffer) ReadByte() (byte, error)"></a>func (b *Buffer) ReadByte() (byte, error)</h3><h3 id="func-b-Buffer-ReadBytes-delim-byte-line-byte-err-error"><a href="#func-b-Buffer-ReadBytes-delim-byte-line-byte-err-error" class="headerlink" title="func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)"></a>func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</h3><h3 id="func-b-Buffer-ReadFrom-r-io-Reader-n-int64-err-error"><a href="#func-b-Buffer-ReadFrom-r-io-Reader-n-int64-err-error" class="headerlink" title="func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)"></a>func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</h3><h3 id="func-b-Buffer-ReadRune-r-rune-size-int-err-error"><a href="#func-b-Buffer-ReadRune-r-rune-size-int-err-error" class="headerlink" title="func (b *Buffer) ReadRune() (r rune, size int, err error)"></a>func (b *Buffer) ReadRune() (r rune, size int, err error)</h3><h3 id="func-b-Buffer-ReadString-delim-byte-line-string-err-error"><a href="#func-b-Buffer-ReadString-delim-byte-line-string-err-error" class="headerlink" title="func (b *Buffer) ReadString(delim byte) (line string, err error)"></a>func (b *Buffer) ReadString(delim byte) (line string, err error)</h3><h3 id="func-b-Buffer-Reset"><a href="#func-b-Buffer-Reset" class="headerlink" title="func (b *Buffer) Reset()"></a>func (b *Buffer) Reset()</h3><h3 id="func-b-Buffer-String-string"><a href="#func-b-Buffer-String-string" class="headerlink" title="func (b *Buffer) String() string"></a>func (b *Buffer) String() string</h3><h3 id="func-b-Buffer-Truncate-n-int"><a href="#func-b-Buffer-Truncate-n-int" class="headerlink" title="func (b *Buffer) Truncate(n int)"></a>func (b *Buffer) Truncate(n int)</h3><h3 id="func-b-Buffer-UnreadByte-error"><a href="#func-b-Buffer-UnreadByte-error" class="headerlink" title="func (b *Buffer) UnreadByte() error"></a>func (b *Buffer) UnreadByte() error</h3><h3 id="func-b-Buffer-UnreadRune-error"><a href="#func-b-Buffer-UnreadRune-error" class="headerlink" title="func (b *Buffer) UnreadRune() error"></a>func (b *Buffer) UnreadRune() error</h3><h3 id="func-b-Buffer-Write-p-byte-n-int-err-error"><a href="#func-b-Buffer-Write-p-byte-n-int-err-error" class="headerlink" title="func (b *Buffer) Write(p []byte) (n int, err error)"></a>func (b *Buffer) Write(p []byte) (n int, err error)</h3><h3 id="func-b-Buffer-WriteByte-c-byte-error"><a href="#func-b-Buffer-WriteByte-c-byte-error" class="headerlink" title="func (b *Buffer) WriteByte(c byte) error"></a>func (b *Buffer) WriteByte(c byte) error</h3><h3 id="func-b-Buffer-WriteRune-r-rune-n-int-err-error"><a href="#func-b-Buffer-WriteRune-r-rune-n-int-err-error" class="headerlink" title="func (b *Buffer) WriteRune(r rune) (n int, err error)"></a>func (b *Buffer) WriteRune(r rune) (n int, err error)</h3><h3 id="func-b-Buffer-WriteString-s-string-n-int-err-error"><a href="#func-b-Buffer-WriteString-s-string-n-int-err-error" class="headerlink" title="func (b *Buffer) WriteString(s string) (n int, err error)"></a>func (b *Buffer) WriteString(s string) (n int, err error)</h3><h3 id="func-b-Buffer-WriteTo-w-io-Writer-n-int64-err-error"><a href="#func-b-Buffer-WriteTo-w-io-Writer-n-int64-err-error" class="headerlink" title="func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)"></a>func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</h3><h2 id="type-Reader-3"><a href="#type-Reader-3" class="headerlink" title="type Reader"></a>type Reader</h2><h2 id="func-NewReader-b-byte-Reader"><a href="#func-NewReader-b-byte-Reader" class="headerlink" title="func NewReader(b []byte) *Reader"></a>func NewReader(b []byte) *Reader</h2><h3 id="func-r-Reader-Len-int"><a href="#func-r-Reader-Len-int" class="headerlink" title="func (r *Reader) Len() int"></a>func (r *Reader) Len() int</h3><h3 id="func-r-Reader-Read-b-byte-n-int-err-error"><a href="#func-r-Reader-Read-b-byte-n-int-err-error" class="headerlink" title="func (r *Reader) Read(b []byte) (n int, err error)"></a>func (r *Reader) Read(b []byte) (n int, err error)</h3><h3 id="func-r-Reader-ReadAt-b-byte-off-int64-n-int-err-error"><a href="#func-r-Reader-ReadAt-b-byte-off-int64-n-int-err-error" class="headerlink" title="func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)"></a>func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</h3><h3 id="func-r-Reader-ReadByte-byte-error"><a href="#func-r-Reader-ReadByte-byte-error" class="headerlink" title="func (r *Reader) ReadByte() (byte, error)"></a>func (r *Reader) ReadByte() (byte, error)</h3><h3 id="func-r-Reader-ReadRune-ch-rune-size-int-err-error"><a href="#func-r-Reader-ReadRune-ch-rune-size-int-err-error" class="headerlink" title="func (r *Reader) ReadRune() (ch rune, size int, err error)"></a>func (r *Reader) ReadRune() (ch rune, size int, err error)</h3><h3 id="func-r-Reader-Reset-b-byte"><a href="#func-r-Reader-Reset-b-byte" class="headerlink" title="func (r *Reader) Reset(b []byte)"></a>func (r *Reader) Reset(b []byte)</h3><h3 id="func-r-Reader-Seek-offset-int64-whence-int-int64-error"><a href="#func-r-Reader-Seek-offset-int64-whence-int-int64-error" class="headerlink" title="func (r *Reader) Seek(offset int64, whence int) (int64, error)"></a>func (r *Reader) Seek(offset int64, whence int) (int64, error)</h3><h3 id="func-r-Reader-Size-int64"><a href="#func-r-Reader-Size-int64" class="headerlink" title="func (r *Reader) Size() int64"></a>func (r *Reader) Size() int64</h3><h3 id="func-r-Reader-UnreadByte-error"><a href="#func-r-Reader-UnreadByte-error" class="headerlink" title="func (r *Reader) UnreadByte() error"></a>func (r *Reader) UnreadByte() error</h3><h3 id="func-r-Reader-UnreadRune-error"><a href="#func-r-Reader-UnreadRune-error" class="headerlink" title="func (r *Reader) UnreadRune() error"></a>func (r *Reader) UnreadRune() error</h3><h3 id="func-r-Reader-WriteTo-w-io-Writer-n-int64-err-error"><a href="#func-r-Reader-WriteTo-w-io-Writer-n-int64-err-error" class="headerlink" title="func (r *Reader) WriteTo(w io.Writer) (n int64, err error)"></a>func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</h3><h1 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h1><h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>Package bzip2 implements bzip2 decompression.</p>
<h3 id="func-NewReader-r-io-Reader-io-Reader"><a href="#func-NewReader-r-io-Reader-io-Reader" class="headerlink" title="func NewReader(r io.Reader) io.Reader"></a>func NewReader(r io.Reader) io.Reader</h3><h3 id="type-StructuralError"><a href="#type-StructuralError" class="headerlink" title="type StructuralError"></a>type StructuralError</h3><h3 id="func-s-StructuralError-Error-string"><a href="#func-s-StructuralError-Error-string" class="headerlink" title="func (s StructuralError) Error() string"></a>func (s StructuralError) Error() string</h3><h2 id="flate"><a href="#flate" class="headerlink" title="flate"></a>flate</h2><p>Package flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats.</p>
<p><strong>Constants</strong></p>
<pre class="language-golang" data-language="golang"><code class="language-golang">const (
	NoCompression      &#x3D; 0
	BestSpeed          &#x3D; 1
	BestCompression    &#x3D; 9
	DefaultCompression &#x3D; -1

	&#x2F;&#x2F; HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman
	&#x2F;&#x2F; entropy encoding. This mode is useful in compressing data that has
	&#x2F;&#x2F; already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)
	&#x2F;&#x2F; that lacks an entropy encoder. Compression gains are achieved when
	&#x2F;&#x2F; certain bytes in the input stream occur more frequently than others.
	&#x2F;&#x2F;
	&#x2F;&#x2F; Note that HuffmanOnly produces a compressed output that is
	&#x2F;&#x2F; RFC 1951 compliant. That is, any valid DEFLATE decompressor will
	&#x2F;&#x2F; continue to be able to decompress this output.
	HuffmanOnly &#x3D; -2
)</code></pre>
<h3 id="func-NewReader-r-io-Reader-io-ReadCloser"><a href="#func-NewReader-r-io-Reader-io-ReadCloser" class="headerlink" title="func NewReader(r io.Reader) io.ReadCloser"></a>func NewReader(r io.Reader) io.ReadCloser</h3><h3 id="func-NewReaderDict-r-io-Reader-dict-byte-io-ReadCloser"><a href="#func-NewReaderDict-r-io-Reader-dict-byte-io-ReadCloser" class="headerlink" title="func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser"></a>func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser</h3><h3 id="type-CorruptInputError"><a href="#type-CorruptInputError" class="headerlink" title="type CorruptInputError"></a>type CorruptInputError</h3><h4 id="func-e-CorruptInputError-Error-string"><a href="#func-e-CorruptInputError-Error-string" class="headerlink" title="func (e CorruptInputError) Error() string"></a>func (e CorruptInputError) Error() string</h4><h3 id="type-InternalError"><a href="#type-InternalError" class="headerlink" title="type InternalError"></a>type InternalError</h3><h4 id="func-e-InternalError-Error-string"><a href="#func-e-InternalError-Error-string" class="headerlink" title="func (e InternalError) Error() string"></a>func (e InternalError) Error() string</h4><h3 id="type-ReadErrorDEPRECATED"><a href="#type-ReadErrorDEPRECATED" class="headerlink" title="type ReadErrorDEPRECATED"></a>type ReadErrorDEPRECATED</h3><h4 id="func-e-ReadError-Error-string"><a href="#func-e-ReadError-Error-string" class="headerlink" title="func (e *ReadError) Error() string"></a>func (e *ReadError) Error() string</h4><h3 id="type-Reader-4"><a href="#type-Reader-4" class="headerlink" title="type Reader"></a>type Reader</h3><h3 id="type-Resetter"><a href="#type-Resetter" class="headerlink" title="type Resetter"></a>type Resetter</h3><h3 id="type-WriteErrorDEPRECATED"><a href="#type-WriteErrorDEPRECATED" class="headerlink" title="type WriteErrorDEPRECATED"></a>type WriteErrorDEPRECATED</h3><h4 id="func-e-WriteError-Error-string"><a href="#func-e-WriteError-Error-string" class="headerlink" title="func (e *WriteError) Error() string"></a>func (e *WriteError) Error() string</h4><h3 id="type-Writer-3"><a href="#type-Writer-3" class="headerlink" title="type Writer"></a>type Writer</h3><h3 id="func-NewWriter-w-io-Writer-level-int-Writer-error"><a href="#func-NewWriter-w-io-Writer-level-int-Writer-error" class="headerlink" title="func NewWriter(w io.Writer, level int) (*Writer, error)"></a>func NewWriter(w io.Writer, level int) (*Writer, error)</h3><h3 id="func-NewWriterDict-w-io-Writer-level-int-dict-byte-Writer-error"><a href="#func-NewWriterDict-w-io-Writer-level-int-dict-byte-Writer-error" class="headerlink" title="func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)"></a>func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)</h3><h4 id="func-w-Writer-Close-error-1"><a href="#func-w-Writer-Close-error-1" class="headerlink" title="func (w *Writer) Close() error"></a>func (w *Writer) Close() error</h4><h4 id="func-w-Writer-Flush-error-1"><a href="#func-w-Writer-Flush-error-1" class="headerlink" title="func (w *Writer) Flush() error"></a>func (w *Writer) Flush() error</h4><h4 id="func-w-Writer-Reset-dst-io-Writer"><a href="#func-w-Writer-Reset-dst-io-Writer" class="headerlink" title="func (w *Writer) Reset(dst io.Writer)"></a>func (w *Writer) Reset(dst io.Writer)</h4><h4 id="func-w-Writer-Write-data-byte-n-int-err-error"><a href="#func-w-Writer-Write-data-byte-n-int-err-error" class="headerlink" title="func (w *Writer) Write(data []byte) (n int, err error)"></a>func (w *Writer) Write(data []byte) (n int, err error)</h4><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.</p>
<p><strong>Constants</strong></p>
<pre class="language-none"><code class="language-none">const (
	NoCompression      &#x3D; flate.NoCompression
	BestSpeed          &#x3D; flate.BestSpeed
	BestCompression    &#x3D; flate.BestCompression
	DefaultCompression &#x3D; flate.DefaultCompression
	HuffmanOnly        &#x3D; flate.HuffmanOnly
)</code></pre>
<p>These constants are copied from the flate package, so that code that imports “compress&#x2F;gzip” does not also have to import “compress&#x2F;flate”.</p>
<p><strong>Variables</strong></p>
<pre class="language-none"><code class="language-none">var (
	&#x2F;&#x2F; ErrChecksum is returned when reading GZIP data that has an invalid checksum.
	ErrChecksum &#x3D; errors.New(&quot;gzip: invalid checksum&quot;)
	&#x2F;&#x2F; ErrHeader is returned when reading GZIP data that has an invalid header.
	ErrHeader &#x3D; errors.New(&quot;gzip: invalid header&quot;)
)</code></pre>
<h3 id="type-Header-1"><a href="#type-Header-1" class="headerlink" title="type Header"></a>type Header</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Header struct &#123;
	Comment string    &#x2F;&#x2F; comment
	Extra   []byte    &#x2F;&#x2F; &quot;extra data&quot;
	ModTime time.Time &#x2F;&#x2F; modification time
	Name    string    &#x2F;&#x2F; file name
	OS      byte      &#x2F;&#x2F; operating system type
&#125;</code></pre>
<h3 id="type-Reader-5"><a href="#type-Reader-5" class="headerlink" title="type Reader"></a>type Reader</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Reader struct &#123;
	Header &#x2F;&#x2F; valid after NewReader or Reader.Reset
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<h3 id="func-NewReader-r-io-Reader-Reader-error"><a href="#func-NewReader-r-io-Reader-Reader-error" class="headerlink" title="func NewReader(r io.Reader) (*Reader, error)"></a>func NewReader(r io.Reader) (*Reader, error)</h3><h4 id="func-z-Reader-Close-error"><a href="#func-z-Reader-Close-error" class="headerlink" title="func (z *Reader) Close() error"></a>func (z *Reader) Close() error</h4><h4 id="func-z-Reader-Multistream-ok-bool"><a href="#func-z-Reader-Multistream-ok-bool" class="headerlink" title="func (z *Reader) Multistream(ok bool)"></a>func (z *Reader) Multistream(ok bool)</h4><h4 id="func-z-Reader-Read-p-byte-n-int-err-error"><a href="#func-z-Reader-Read-p-byte-n-int-err-error" class="headerlink" title="func (z *Reader) Read(p []byte) (n int, err error)"></a>func (z *Reader) Read(p []byte) (n int, err error)</h4><h4 id="func-z-Reader-Reset-r-io-Reader-error"><a href="#func-z-Reader-Reset-r-io-Reader-error" class="headerlink" title="func (z *Reader) Reset(r io.Reader) error"></a>func (z *Reader) Reset(r io.Reader) error</h4><h3 id="type-Writer-4"><a href="#type-Writer-4" class="headerlink" title="type Writer"></a>type Writer</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Writer struct &#123;
	Header &#x2F;&#x2F; written at first call to Write, Flush, or Close
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;
</code></pre>
<h3 id="func-NewWriter-w-io-Writer-Writer-3"><a href="#func-NewWriter-w-io-Writer-Writer-3" class="headerlink" title="func NewWriter(w io.Writer) *Writer"></a>func NewWriter(w io.Writer) *Writer</h3><h3 id="func-NewWriterLevel-w-io-Writer-level-int-Writer-error"><a href="#func-NewWriterLevel-w-io-Writer-level-int-Writer-error" class="headerlink" title="func NewWriterLevel(w io.Writer, level int) (*Writer, error)"></a>func NewWriterLevel(w io.Writer, level int) (*Writer, error)</h3><h4 id="func-z-Writer-Close-error"><a href="#func-z-Writer-Close-error" class="headerlink" title="func (z *Writer) Close() error"></a>func (z *Writer) Close() error</h4><h4 id="func-z-Writer-Flush-error"><a href="#func-z-Writer-Flush-error" class="headerlink" title="func (z *Writer) Flush() error"></a>func (z *Writer) Flush() error</h4><h4 id="func-z-Writer-Reset-w-io-Writer"><a href="#func-z-Writer-Reset-w-io-Writer" class="headerlink" title="func (z *Writer) Reset(w io.Writer)"></a>func (z *Writer) Reset(w io.Writer)</h4><h4 id="func-z-Writer-Write-p-byte-int-error"><a href="#func-z-Writer-Write-p-byte-int-error" class="headerlink" title="func (z *Writer) Write(p []byte) (int, error)"></a>func (z *Writer) Write(p []byte) (int, error)</h4><h2 id="lzw"><a href="#lzw" class="headerlink" title="lzw"></a>lzw</h2><p>Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19.</p>
<p>In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.</p>
<p>The TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org&#x2F;x&#x2F;image&#x2F;tiff&#x2F;lzw package for an implementation.</p>
<h3 id="func-NewReader-r-io-Reader-order-Order-litWidth-int-io-ReadCloser"><a href="#func-NewReader-r-io-Reader-order-Order-litWidth-int-io-ReadCloser" class="headerlink" title="func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser"></a>func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser</h3><h3 id="func-NewWriter-w-io-Writer-order-Order-litWidth-int-io-WriteCloser"><a href="#func-NewWriter-w-io-Writer-order-Order-litWidth-int-io-WriteCloser" class="headerlink" title="func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser"></a>func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser</h3><h3 id="type-Order"><a href="#type-Order" class="headerlink" title="type Order"></a>type Order</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Order int</code></pre>
<h3 id="type-Reader-6"><a href="#type-Reader-6" class="headerlink" title="type Reader"></a>type Reader</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Reader struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<h4 id="func-r-Reader-Close-error"><a href="#func-r-Reader-Close-error" class="headerlink" title="func (r *Reader) Close() error"></a>func (r *Reader) Close() error</h4><h4 id="func-r-Reader-Read-b-byte-int-error"><a href="#func-r-Reader-Read-b-byte-int-error" class="headerlink" title="func (r *Reader) Read(b []byte) (int, error)"></a>func (r *Reader) Read(b []byte) (int, error)</h4><h4 id="func-r-Reader-Reset-src-io-Reader-order-Order-litWidth-int"><a href="#func-r-Reader-Reset-src-io-Reader-order-Order-litWidth-int" class="headerlink" title="func (r *Reader) Reset(src io.Reader, order Order, litWidth int)"></a>func (r *Reader) Reset(src io.Reader, order Order, litWidth int)</h4><h3 id="type-Writer-5"><a href="#type-Writer-5" class="headerlink" title="type Writer"></a>type Writer</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Writer struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>


<h4 id="func-w-Writer-Close-error-2"><a href="#func-w-Writer-Close-error-2" class="headerlink" title="func (w *Writer) Close() error"></a>func (w *Writer) Close() error</h4><h4 id="func-w-Writer-Reset-dst-io-Writer-order-Order-litWidth-int"><a href="#func-w-Writer-Reset-dst-io-Writer-order-Order-litWidth-int" class="headerlink" title="func (w *Writer) Reset(dst io.Writer, order Order, litWidth int)"></a>func (w *Writer) Reset(dst io.Writer, order Order, litWidth int)</h4><h4 id="func-w-Writer-Write-p-byte-n-int-err-error"><a href="#func-w-Writer-Write-p-byte-n-int-err-error" class="headerlink" title="func (w *Writer) Write(p []byte) (n int, err error)"></a>func (w *Writer) Write(p []byte) (n int, err error)</h4><h2 id="compress-x2F-zlib"><a href="#compress-x2F-zlib" class="headerlink" title="compress&#x2F;zlib"></a>compress&#x2F;zlib</h2><p><strong>Overview</strong><br>Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.</p>
<p>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">var b bytes.Buffer
w :&#x3D; zlib.NewWriter(&amp;b)
w.Write([]byte(&quot;hello, world\n&quot;))
w.Close()</code></pre>
<p>and to read that data back:</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">r, err :&#x3D; zlib.NewReader(&amp;b)
io.Copy(os.Stdout, r)
r.Close()</code></pre>
<p><strong>Constants</strong><br><strong>Variables</strong></p>
<h3 id="func-NewReader-r-io-Reader-io-ReadCloser-error"><a href="#func-NewReader-r-io-Reader-io-ReadCloser-error" class="headerlink" title="func NewReader(r io.Reader) (io.ReadCloser, error)"></a>func NewReader(r io.Reader) (io.ReadCloser, error)</h3><h3 id="func-NewReaderDict-r-io-Reader-dict-byte-io-ReadCloser-error"><a href="#func-NewReaderDict-r-io-Reader-dict-byte-io-ReadCloser-error" class="headerlink" title="func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)"></a>func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)</h3><h3 id="type-Resetter-1"><a href="#type-Resetter-1" class="headerlink" title="type Resetter"></a>type Resetter</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Resetter interface &#123;
	&#x2F;&#x2F; Reset discards any buffered data and resets the Resetter as if it was
	&#x2F;&#x2F; newly initialized with the given reader.
	Reset(r io.Reader, dict []byte) error
&#125;</code></pre>
<h3 id="type-Writer-6"><a href="#type-Writer-6" class="headerlink" title="type Writer"></a>type Writer</h3><pre class="language-golang" data-language="golang"><code class="language-golang">type Writer struct &#123;
	&#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>
<h3 id="func-NewWriter-w-io-Writer-Writer-4"><a href="#func-NewWriter-w-io-Writer-Writer-4" class="headerlink" title="func NewWriter(w io.Writer) *Writer"></a>func NewWriter(w io.Writer) *Writer</h3><h3 id="func-NewWriterLevel-w-io-Writer-level-int-Writer-error-1"><a href="#func-NewWriterLevel-w-io-Writer-level-int-Writer-error-1" class="headerlink" title="func NewWriterLevel(w io.Writer, level int) (*Writer, error)"></a>func NewWriterLevel(w io.Writer, level int) (*Writer, error)</h3><h3 id="func-NewWriterLevelDict-w-io-Writer-level-int-dict-byte-Writer-error"><a href="#func-NewWriterLevelDict-w-io-Writer-level-int-dict-byte-Writer-error" class="headerlink" title="func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)"></a>func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)</h3><h4 id="func-z-Writer-Close-error-1"><a href="#func-z-Writer-Close-error-1" class="headerlink" title="func (z *Writer) Close() error"></a>func (z *Writer) Close() error</h4><h4 id="func-z-Writer-Flush-error-1"><a href="#func-z-Writer-Flush-error-1" class="headerlink" title="func (z *Writer) Flush() error"></a>func (z *Writer) Flush() error</h4><h4 id="func-z-Writer-Reset-w-io-Writer-1"><a href="#func-z-Writer-Reset-w-io-Writer-1" class="headerlink" title="func (z *Writer) Reset(w io.Writer)"></a>func (z *Writer) Reset(w io.Writer)</h4><h4 id="func-z-Writer-Write-p-byte-n-int-err-error"><a href="#func-z-Writer-Write-p-byte-n-int-err-error" class="headerlink" title="func (z *Writer) Write(p []byte) (n int, err error)"></a>func (z *Writer) Write(p []byte) (n int, err error)</h4><h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><h2 id="container-x2F-heap"><a href="#container-x2F-heap" class="headerlink" title="container&#x2F;heap"></a>container&#x2F;heap</h2><p><strong>Overview</strong><br>Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.</p>
<p>The minimum element in the tree is the root, at index 0.</p>
<p>A heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source.</p>
<h3 id="func-Fix-h-Interface-i-int"><a href="#func-Fix-h-Interface-i-int" class="headerlink" title="func Fix(h Interface, i int)"></a>func Fix(h Interface, i int)</h3><h3 id="func-Init-h-Interface"><a href="#func-Init-h-Interface" class="headerlink" title="func Init(h Interface)"></a>func Init(h Interface)</h3><h3 id="func-Pop-h-Interface-any"><a href="#func-Pop-h-Interface-any" class="headerlink" title="func Pop(h Interface) any"></a>func Pop(h Interface) any</h3><h3 id="func-Push-h-Interface-x-any"><a href="#func-Push-h-Interface-x-any" class="headerlink" title="func Push(h Interface, x any)"></a>func Push(h Interface, x any)</h3><h3 id="func-Remove-h-Interface-i-int-any"><a href="#func-Remove-h-Interface-i-int-any" class="headerlink" title="func Remove(h Interface, i int) any"></a>func Remove(h Interface, i int) any</h3><h3 id="type-Interface"><a href="#type-Interface" class="headerlink" title="type Interface"></a>type Interface</h3><h2 id="container-x2F-list"><a href="#container-x2F-list" class="headerlink" title="container&#x2F;list"></a>container&#x2F;list</h2><p><strong>Overview</strong><br>Package list implements a doubly linked list.</p>
<p>To iterate over a list (where l is a *List):</p>
<pre class="language-golang" data-language="golang"><code class="language-golang">for e :&#x3D; l.Front(); e !&#x3D; nil; e &#x3D; e.Next() &#123;
	&#x2F;&#x2F; do something with e.Value
&#125;
</code></pre>

<h3 id="type-Element"><a href="#type-Element" class="headerlink" title="type Element"></a>type Element</h3><h4 id="func-e-Element-Next-Element"><a href="#func-e-Element-Next-Element" class="headerlink" title="func (e *Element) Next() *Element"></a>func (e *Element) Next() *Element</h4><h4 id="func-e-Element-Prev-Element"><a href="#func-e-Element-Prev-Element" class="headerlink" title="func (e *Element) Prev() *Element"></a>func (e *Element) Prev() *Element</h4><h3 id="type-List"><a href="#type-List" class="headerlink" title="type List"></a>type List</h3><h3 id="func-New-List"><a href="#func-New-List" class="headerlink" title="func New() *List"></a>func New() *List</h3><h4 id="func-l-List-Back-Element"><a href="#func-l-List-Back-Element" class="headerlink" title="func (l *List) Back() *Element"></a>func (l *List) Back() *Element</h4><h4 id="func-l-List-Front-Element"><a href="#func-l-List-Front-Element" class="headerlink" title="func (l *List) Front() *Element"></a>func (l *List) Front() *Element</h4><h4 id="func-l-List-Init-List"><a href="#func-l-List-Init-List" class="headerlink" title="func (l *List) Init() *List"></a>func (l *List) Init() *List</h4><h4 id="func-l-List-InsertAfter-v-any-mark-Element-Element"><a href="#func-l-List-InsertAfter-v-any-mark-Element-Element" class="headerlink" title="func (l *List) InsertAfter(v any, mark *Element) *Element"></a>func (l *List) InsertAfter(v any, mark *Element) *Element</h4><h4 id="func-l-List-InsertBefore-v-any-mark-Element-Element"><a href="#func-l-List-InsertBefore-v-any-mark-Element-Element" class="headerlink" title="func (l *List) InsertBefore(v any, mark *Element) *Element"></a>func (l *List) InsertBefore(v any, mark *Element) *Element</h4><h4 id="func-l-List-Len-int"><a href="#func-l-List-Len-int" class="headerlink" title="func (l *List) Len() int"></a>func (l *List) Len() int</h4><h4 id="func-l-List-MoveAfter-e-mark-Element"><a href="#func-l-List-MoveAfter-e-mark-Element" class="headerlink" title="func (l *List) MoveAfter(e, mark *Element)"></a>func (l *List) MoveAfter(e, mark *Element)</h4><h4 id="func-l-List-MoveBefore-e-mark-Element"><a href="#func-l-List-MoveBefore-e-mark-Element" class="headerlink" title="func (l *List) MoveBefore(e, mark *Element)"></a>func (l *List) MoveBefore(e, mark *Element)</h4><h4 id="func-l-List-MoveToBack-e-Element"><a href="#func-l-List-MoveToBack-e-Element" class="headerlink" title="func (l *List) MoveToBack(e *Element)"></a>func (l *List) MoveToBack(e *Element)</h4><h4 id="func-l-List-MoveToFront-e-Element"><a href="#func-l-List-MoveToFront-e-Element" class="headerlink" title="func (l *List) MoveToFront(e *Element)"></a>func (l *List) MoveToFront(e *Element)</h4><h4 id="func-l-List-PushBack-v-any-Element"><a href="#func-l-List-PushBack-v-any-Element" class="headerlink" title="func (l *List) PushBack(v any) *Element"></a>func (l *List) PushBack(v any) *Element</h4><h4 id="func-l-List-PushBackList-other-List"><a href="#func-l-List-PushBackList-other-List" class="headerlink" title="func (l *List) PushBackList(other *List)"></a>func (l *List) PushBackList(other *List)</h4><h4 id="func-l-List-PushFront-v-any-Element"><a href="#func-l-List-PushFront-v-any-Element" class="headerlink" title="func (l *List) PushFront(v any) *Element"></a>func (l *List) PushFront(v any) *Element</h4><h4 id="func-l-List-PushFrontList-other-List"><a href="#func-l-List-PushFrontList-other-List" class="headerlink" title="func (l *List) PushFrontList(other *List)"></a>func (l *List) PushFrontList(other *List)</h4><h4 id="func-l-List-Remove-e-Element-any"><a href="#func-l-List-Remove-e-Element-any" class="headerlink" title="func (l *List) Remove(e *Element) any"></a>func (l *List) Remove(e *Element) any</h4><h1 id="time-package"><a href="#time-package" class="headerlink" title="time package"></a>time package</h1><p><strong>Constants</strong><br>  <pre class="language-golang" data-language="golang"><code class="language-golang">const (
  Layout      &#x3D; &quot;01&#x2F;02 03:04:05PM &#39;06 -0700&quot; &#x2F;&#x2F; The reference time, in numerical order.
  ANSIC       &#x3D; &quot;Mon Jan _2 15:04:05 2006&quot;
  UnixDate    &#x3D; &quot;Mon Jan _2 15:04:05 MST 2006&quot;
  RubyDate    &#x3D; &quot;Mon Jan 02 15:04:05 -0700 2006&quot;
  RFC822      &#x3D; &quot;02 Jan 06 15:04 MST&quot;
  RFC822Z     &#x3D; &quot;02 Jan 06 15:04 -0700&quot; &#x2F;&#x2F; RFC822 with numeric zone
  RFC850      &#x3D; &quot;Monday, 02-Jan-06 15:04:05 MST&quot;
  RFC1123     &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 MST&quot;
  RFC1123Z    &#x3D; &quot;Mon, 02 Jan 2006 15:04:05 -0700&quot; &#x2F;&#x2F; RFC1123 with numeric zone
  RFC3339     &#x3D; &quot;2006-01-02T15:04:05Z07:00&quot;
  RFC3339Nano &#x3D; &quot;2006-01-02T15:04:05.999999999Z07:00&quot;
  Kitchen     &#x3D; &quot;3:04PM&quot;
  &#x2F;&#x2F; Handy time stamps.
  Stamp      &#x3D; &quot;Jan _2 15:04:05&quot;
  StampMilli &#x3D; &quot;Jan _2 15:04:05.000&quot;
  StampMicro &#x3D; &quot;Jan _2 15:04:05.000000&quot;
  StampNano  &#x3D; &quot;Jan _2 15:04:05.000000000&quot;
)</code></pre></p>
<h3 id="func-After-d-Duration-lt-chan-Time"><a href="#func-After-d-Duration-lt-chan-Time" class="headerlink" title="func After(d Duration) &lt;-chan Time"></a>func After(d Duration) &lt;-chan Time</h3><p>  After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.这里需要注意，这个After(d Duration)是指返回一次的时间戳，想要使用还要再次初始化</p>
<h3 id="func-Sleep-d-Duration"><a href="#func-Sleep-d-Duration" class="headerlink" title="func Sleep(d Duration)"></a>func Sleep(d Duration)</h3><h3 id="func-Tick-d-Duration-lt-chan-Time"><a href="#func-Tick-d-Duration-lt-chan-Time" class="headerlink" title="func Tick(d Duration) &lt;-chan Time"></a>func Tick(d Duration) &lt;-chan Time</h3><h2 id="type-Duration"><a href="#type-Duration" class="headerlink" title="type Duration"></a>type Duration</h2><h3 id="func-ParseDuration-s-string-Duration-error"><a href="#func-ParseDuration-s-string-Duration-error" class="headerlink" title="func ParseDuration(s string) (Duration, error)"></a>func ParseDuration(s string) (Duration, error)</h3><h3 id="func-Since-t-Time-Duration"><a href="#func-Since-t-Time-Duration" class="headerlink" title="func Since(t Time) Duration"></a>func Since(t Time) Duration</h3><h3 id="func-Until-t-Time-Duration"><a href="#func-Until-t-Time-Duration" class="headerlink" title="func Until(t Time) Duration"></a>func Until(t Time) Duration</h3><h3 id="func-d-Duration-Abs-Duration"><a href="#func-d-Duration-Abs-Duration" class="headerlink" title="func (d Duration) Abs() Duration"></a>func (d Duration) Abs() Duration</h3><h3 id="func-d-Duration-Hours-float64"><a href="#func-d-Duration-Hours-float64" class="headerlink" title="func (d Duration) Hours() float64"></a>func (d Duration) Hours() float64</h3><h3 id="func-d-Duration-Microseconds-int64"><a href="#func-d-Duration-Microseconds-int64" class="headerlink" title="func (d Duration) Microseconds() int64"></a>func (d Duration) Microseconds() int64</h3><h3 id="func-d-Duration-Milliseconds-int64"><a href="#func-d-Duration-Milliseconds-int64" class="headerlink" title="func (d Duration) Milliseconds() int64"></a>func (d Duration) Milliseconds() int64</h3><h3 id="func-d-Duration-Minutes-float64"><a href="#func-d-Duration-Minutes-float64" class="headerlink" title="func (d Duration) Minutes() float64"></a>func (d Duration) Minutes() float64</h3><h3 id="func-d-Duration-Nanoseconds-int64"><a href="#func-d-Duration-Nanoseconds-int64" class="headerlink" title="func (d Duration) Nanoseconds() int64"></a>func (d Duration) Nanoseconds() int64</h3><h3 id="func-d-Duration-Round-m-Duration-Duration"><a href="#func-d-Duration-Round-m-Duration-Duration" class="headerlink" title="func (d Duration) Round(m Duration) Duration"></a>func (d Duration) Round(m Duration) Duration</h3><h3 id="func-d-Duration-Seconds-float64"><a href="#func-d-Duration-Seconds-float64" class="headerlink" title="func (d Duration) Seconds() float64"></a>func (d Duration) Seconds() float64</h3><h3 id="func-d-Duration-String-string"><a href="#func-d-Duration-String-string" class="headerlink" title="func (d Duration) String() string"></a>func (d Duration) String() string</h3><h3 id="func-d-Duration-Truncate-m-Duration-Duration"><a href="#func-d-Duration-Truncate-m-Duration-Duration" class="headerlink" title="func (d Duration) Truncate(m Duration) Duration"></a>func (d Duration) Truncate(m Duration) Duration</h3><h2 id="type-Location"><a href="#type-Location" class="headerlink" title="type Location"></a>type Location</h2><h3 id="func-FixedZone-name-string-offset-int-Location"><a href="#func-FixedZone-name-string-offset-int-Location" class="headerlink" title="func FixedZone(name string, offset int) *Location"></a>func FixedZone(name string, offset int) *Location</h3><h3 id="func-LoadLocation-name-string-Location-error"><a href="#func-LoadLocation-name-string-Location-error" class="headerlink" title="func LoadLocation(name string) (*Location, error)"></a>func LoadLocation(name string) (*Location, error)</h3><h3 id="func-LoadLocationFromTZData-name-string-data-byte-Location-error"><a href="#func-LoadLocationFromTZData-name-string-data-byte-Location-error" class="headerlink" title="func LoadLocationFromTZData(name string, data []byte) (*Location, error)"></a>func LoadLocationFromTZData(name string, data []byte) (*Location, error)</h3><h3 id="func-l-Location-String-string"><a href="#func-l-Location-String-string" class="headerlink" title="func (l*Location) String() string"></a>func (l*Location) String() string</h3><h2 id="type-Month"><a href="#type-Month" class="headerlink" title="type Month"></a>type Month</h2><h3 id="func-m-Month-String-string"><a href="#func-m-Month-String-string" class="headerlink" title="func (m Month) String() string"></a>func (m Month) String() string</h3><h2 id="type-ParseError"><a href="#type-ParseError" class="headerlink" title="type ParseError"></a>type ParseError</h2><h3 id="func-e-ParseError-Error-string"><a href="#func-e-ParseError-Error-string" class="headerlink" title="func (e *ParseError) Error() string"></a>func (e *ParseError) Error() string</h3><h2 id="type-Ticker"><a href="#type-Ticker" class="headerlink" title="type Ticker"></a>type Ticker</h2><p>  A Ticker holds a channel that delivers “ticks” of a clock at <strong>intervals</strong>.</p>
<h3 id="func-NewTicker-d-Duration-Ticker"><a href="#func-NewTicker-d-Duration-Ticker" class="headerlink" title="func NewTicker(d Duration) *Ticker"></a>func NewTicker(d Duration) *Ticker</h3><p>  NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. <strong>The ticker will adjust the time interval or drop ticks to make up for slow receivers</strong>. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</p>
<h3 id="func-t-Ticker-Reset-d-Duration"><a href="#func-t-Ticker-Reset-d-Duration" class="headerlink" title="func (t *Ticker) Reset(d Duration)"></a>func (t *Ticker) Reset(d Duration)</h3><p>  Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic.</p>
<h3 id="func-t-Ticker-Stop"><a href="#func-t-Ticker-Stop" class="headerlink" title="func (t *Ticker) Stop()"></a>func (t *Ticker) Stop()</h3><p>  Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous “tick”.</p>
<h2 id="type-Time"><a href="#type-Time" class="headerlink" title="type Time"></a>type Time</h2><h3 id="func-Date-year-int-month-Month-day-hour-min-sec-nsec-int-loc-Location-Time"><a href="#func-Date-year-int-month-Month-day-hour-min-sec-nsec-int-loc-Location-Time" class="headerlink" title="func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time"></a>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</h3><h3 id="func-Now-Time"><a href="#func-Now-Time" class="headerlink" title="func Now() Time"></a>func Now() Time</h3><h3 id="func-Parse-layout-value-string-Time-error"><a href="#func-Parse-layout-value-string-Time-error" class="headerlink" title="func Parse(layout, value string) (Time, error)"></a>func Parse(layout, value string) (Time, error)</h3><h3 id="func-ParseInLocation-layout-value-string-loc-Location-Time-error"><a href="#func-ParseInLocation-layout-value-string-loc-Location-Time-error" class="headerlink" title="func ParseInLocation(layout, value string, loc *Location) (Time, error)"></a>func ParseInLocation(layout, value string, loc *Location) (Time, error)</h3><h3 id="func-Unix-sec-int64-nsec-int64-Time"><a href="#func-Unix-sec-int64-nsec-int64-Time" class="headerlink" title="func Unix(sec int64, nsec int64) Time"></a>func Unix(sec int64, nsec int64) Time</h3><h3 id="func-UnixMicro-usec-int64-Time"><a href="#func-UnixMicro-usec-int64-Time" class="headerlink" title="func UnixMicro(usec int64) Time"></a>func UnixMicro(usec int64) Time</h3><h3 id="func-UnixMilli-msec-int64-Time"><a href="#func-UnixMilli-msec-int64-Time" class="headerlink" title="func UnixMilli(msec int64) Time"></a>func UnixMilli(msec int64) Time</h3><h3 id="func-t-Time-Add-d-Duration-Time"><a href="#func-t-Time-Add-d-Duration-Time" class="headerlink" title="func (t Time) Add(d Duration) Time"></a>func (t Time) Add(d Duration) Time</h3><h3 id="func-t-Time-AddDate-years-int-months-int-days-int-Time"><a href="#func-t-Time-AddDate-years-int-months-int-days-int-Time" class="headerlink" title="func (t Time) AddDate(years int, months int, days int) Time"></a>func (t Time) AddDate(years int, months int, days int) Time</h3><h3 id="func-t-Time-After-u-Time-bool"><a href="#func-t-Time-After-u-Time-bool" class="headerlink" title="func (t Time) After(u Time) bool"></a>func (t Time) After(u Time) bool</h3><h3 id="func-t-Time-AppendFormat-b-byte-layout-string-byte"><a href="#func-t-Time-AppendFormat-b-byte-layout-string-byte" class="headerlink" title="func (t Time) AppendFormat(b []byte, layout string) []byte"></a>func (t Time) AppendFormat(b []byte, layout string) []byte</h3><h3 id="func-t-Time-Before-u-Time-bool"><a href="#func-t-Time-Before-u-Time-bool" class="headerlink" title="func (t Time) Before(u Time) bool"></a>func (t Time) Before(u Time) bool</h3><h3 id="func-t-Time-Clock-hour-min-sec-int"><a href="#func-t-Time-Clock-hour-min-sec-int" class="headerlink" title="func (t Time) Clock() (hour, min, sec int)"></a>func (t Time) Clock() (hour, min, sec int)</h3><h3 id="func-t-Time-Date-year-int-month-Month-day-int"><a href="#func-t-Time-Date-year-int-month-Month-day-int" class="headerlink" title="func (t Time) Date() (year int, month Month, day int)"></a>func (t Time) Date() (year int, month Month, day int)</h3><h3 id="func-t-Time-Day-int"><a href="#func-t-Time-Day-int" class="headerlink" title="func (t Time) Day() int"></a>func (t Time) Day() int</h3><h3 id="func-t-Time-Equal-u-Time-bool"><a href="#func-t-Time-Equal-u-Time-bool" class="headerlink" title="func (t Time) Equal(u Time) bool"></a>func (t Time) Equal(u Time) bool</h3><h3 id="func-t-Time-Format-layout-string-string"><a href="#func-t-Time-Format-layout-string-string" class="headerlink" title="func (t Time) Format(layout string) string"></a>func (t Time) Format(layout string) string</h3><h3 id="func-t-Time-GoString-string"><a href="#func-t-Time-GoString-string" class="headerlink" title="func (t Time) GoString() string"></a>func (t Time) GoString() string</h3><h3 id="func-t-Time-GobDecode-data-byte-error"><a href="#func-t-Time-GobDecode-data-byte-error" class="headerlink" title="func (t *Time) GobDecode(data []byte) error"></a>func (t *Time) GobDecode(data []byte) error</h3><h3 id="func-t-Time-GobEncode-byte-error"><a href="#func-t-Time-GobEncode-byte-error" class="headerlink" title="func (t Time) GobEncode() ([]byte, error)"></a>func (t Time) GobEncode() ([]byte, error)</h3><h3 id="func-t-Time-Hour-int"><a href="#func-t-Time-Hour-int" class="headerlink" title="func (t Time) Hour() int"></a>func (t Time) Hour() int</h3><h3 id="func-t-Time-ISOWeek-year-week-int"><a href="#func-t-Time-ISOWeek-year-week-int" class="headerlink" title="func (t Time) ISOWeek() (year, week int)"></a>func (t Time) ISOWeek() (year, week int)</h3><h3 id="func-t-Time-In-loc-Location-Time"><a href="#func-t-Time-In-loc-Location-Time" class="headerlink" title="func (t Time) In(loc*Location) Time"></a>func (t Time) In(loc*Location) Time</h3><h3 id="func-t-Time-IsDST-bool"><a href="#func-t-Time-IsDST-bool" class="headerlink" title="func (t Time) IsDST() bool"></a>func (t Time) IsDST() bool</h3><h3 id="func-t-Time-IsZero-bool"><a href="#func-t-Time-IsZero-bool" class="headerlink" title="func (t Time) IsZero() bool"></a>func (t Time) IsZero() bool</h3><h3 id="func-t-Time-Local-Time"><a href="#func-t-Time-Local-Time" class="headerlink" title="func (t Time) Local() Time"></a>func (t Time) Local() Time</h3><h3 id="func-t-Time-Location-Location"><a href="#func-t-Time-Location-Location" class="headerlink" title="func (t Time) Location() *Location"></a>func (t Time) Location() *Location</h3><h3 id="func-t-Time-MarshalBinary-byte-error"><a href="#func-t-Time-MarshalBinary-byte-error" class="headerlink" title="func (t Time) MarshalBinary() ([]byte, error)"></a>func (t Time) MarshalBinary() ([]byte, error)</h3><h3 id="func-t-Time-MarshalJSON-byte-error"><a href="#func-t-Time-MarshalJSON-byte-error" class="headerlink" title="func (t Time) MarshalJSON() ([]byte, error)"></a>func (t Time) MarshalJSON() ([]byte, error)</h3><h3 id="func-t-Time-MarshalText-byte-error"><a href="#func-t-Time-MarshalText-byte-error" class="headerlink" title="func (t Time) MarshalText() ([]byte, error)"></a>func (t Time) MarshalText() ([]byte, error)</h3><h3 id="func-t-Time-Minute-int"><a href="#func-t-Time-Minute-int" class="headerlink" title="func (t Time) Minute() int"></a>func (t Time) Minute() int</h3><h3 id="func-t-Time-Month-Month"><a href="#func-t-Time-Month-Month" class="headerlink" title="func (t Time) Month() Month"></a>func (t Time) Month() Month</h3><h3 id="func-t-Time-Nanosecond-int"><a href="#func-t-Time-Nanosecond-int" class="headerlink" title="func (t Time) Nanosecond() int"></a>func (t Time) Nanosecond() int</h3><h3 id="func-t-Time-Round-d-Duration-Time"><a href="#func-t-Time-Round-d-Duration-Time" class="headerlink" title="func (t Time) Round(d Duration) Time"></a>func (t Time) Round(d Duration) Time</h3><h3 id="func-t-Time-Second-int"><a href="#func-t-Time-Second-int" class="headerlink" title="func (t Time) Second() int"></a>func (t Time) Second() int</h3><h3 id="func-t-Time-String-string"><a href="#func-t-Time-String-string" class="headerlink" title="func (t Time) String() string"></a>func (t Time) String() string</h3><h3 id="func-t-Time-Sub-u-Time-Duration"><a href="#func-t-Time-Sub-u-Time-Duration" class="headerlink" title="func (t Time) Sub(u Time) Duration"></a>func (t Time) Sub(u Time) Duration</h3><h3 id="func-t-Time-Truncate-d-Duration-Time"><a href="#func-t-Time-Truncate-d-Duration-Time" class="headerlink" title="func (t Time) Truncate(d Duration) Time"></a>func (t Time) Truncate(d Duration) Time</h3><h3 id="func-t-Time-UTC-Time"><a href="#func-t-Time-UTC-Time" class="headerlink" title="func (t Time) UTC() Time"></a>func (t Time) UTC() Time</h3><h3 id="func-t-Time-Unix-int64"><a href="#func-t-Time-Unix-int64" class="headerlink" title="func (t Time) Unix() int64"></a>func (t Time) Unix() int64</h3><h3 id="func-t-Time-UnixMicro-int64"><a href="#func-t-Time-UnixMicro-int64" class="headerlink" title="func (t Time) UnixMicro() int64"></a>func (t Time) UnixMicro() int64</h3><h3 id="func-t-Time-UnixMilli-int64"><a href="#func-t-Time-UnixMilli-int64" class="headerlink" title="func (t Time) UnixMilli() int64"></a>func (t Time) UnixMilli() int64</h3><h3 id="func-t-Time-UnixNano-int64"><a href="#func-t-Time-UnixNano-int64" class="headerlink" title="func (t Time) UnixNano() int64"></a>func (t Time) UnixNano() int64</h3><h3 id="func-t-Time-UnmarshalBinary-data-byte-error"><a href="#func-t-Time-UnmarshalBinary-data-byte-error" class="headerlink" title="func (t*Time) UnmarshalBinary(data []byte) error"></a>func (t*Time) UnmarshalBinary(data []byte) error</h3><h3 id="func-t-Time-UnmarshalJSON-data-byte-error"><a href="#func-t-Time-UnmarshalJSON-data-byte-error" class="headerlink" title="func (t *Time) UnmarshalJSON(data []byte) error"></a>func (t *Time) UnmarshalJSON(data []byte) error</h3><h3 id="func-t-Time-UnmarshalText-data-byte-error"><a href="#func-t-Time-UnmarshalText-data-byte-error" class="headerlink" title="func (t*Time) UnmarshalText(data []byte) error"></a>func (t*Time) UnmarshalText(data []byte) error</h3><h3 id="func-t-Time-Weekday-Weekday"><a href="#func-t-Time-Weekday-Weekday" class="headerlink" title="func (t Time) Weekday() Weekday"></a>func (t Time) Weekday() Weekday</h3><h3 id="func-t-Time-Year-int"><a href="#func-t-Time-Year-int" class="headerlink" title="func (t Time) Year() int"></a>func (t Time) Year() int</h3><h3 id="func-t-Time-YearDay-int"><a href="#func-t-Time-YearDay-int" class="headerlink" title="func (t Time) YearDay() int"></a>func (t Time) YearDay() int</h3><h3 id="func-t-Time-Zone-name-string-offset-int"><a href="#func-t-Time-Zone-name-string-offset-int" class="headerlink" title="func (t Time) Zone() (name string, offset int)"></a>func (t Time) Zone() (name string, offset int)</h3><h3 id="func-t-Time-ZoneBounds-start-end-Time"><a href="#func-t-Time-ZoneBounds-start-end-Time" class="headerlink" title="func (t Time) ZoneBounds() (start, end Time)"></a>func (t Time) ZoneBounds() (start, end Time)</h3><h3 id="type-Timer"><a href="#type-Timer" class="headerlink" title="type Timer"></a>type Timer</h3>  <pre class="language-golang" data-language="golang"><code class="language-golang">type Timer struct &#123;
  C &lt;-chan Time
  &#x2F;&#x2F; contains filtered or unexported fields
&#125;</code></pre>

<p>  这里的C用于接收</p>
<h3 id="func-AfterFunc-d-Duration-f-func-Timer"><a href="#func-AfterFunc-d-Duration-f-func-Timer" class="headerlink" title="func AfterFunc(d Duration, f func()) *Timer"></a>func AfterFunc(d Duration, f func()) *Timer</h3><h3 id="func-NewTimer-d-Duration-Timer"><a href="#func-NewTimer-d-Duration-Timer" class="headerlink" title="func NewTimer(d Duration)*Timer"></a>func NewTimer(d Duration)*Timer</h3><h3 id="func-t-Timer-Reset-d-Duration-bool"><a href="#func-t-Timer-Reset-d-Duration-bool" class="headerlink" title="func (t *Timer) Reset(d Duration) bool"></a>func (t *Timer) Reset(d Duration) bool</h3><h3 id="func-t-Timer-Stop-bool"><a href="#func-t-Timer-Stop-bool" class="headerlink" title="func (t*Timer) Stop() bool"></a>func (t*Timer) Stop() bool</h3><h2 id="type-Weekday"><a href="#type-Weekday" class="headerlink" title="type Weekday"></a>type Weekday</h2><h3 id="func-d-Weekday-String-string"><a href="#func-d-Weekday-String-string" class="headerlink" title="func (d Weekday) String() string"></a>func (d Weekday) String() string</h3><h1 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h1><h2 id="function-not-method-of-rand"><a href="#function-not-method-of-rand" class="headerlink" title="function not method of rand"></a>function not method of rand</h2><h3 id="func-ExpFloat64-float64"><a href="#func-ExpFloat64-float64" class="headerlink" title="func ExpFloat64() float64"></a>func ExpFloat64() float64</h3><h3 id="func-Float32-float32"><a href="#func-Float32-float32" class="headerlink" title="func Float32() float32"></a>func Float32() float32</h3><h3 id="func-Float64-float64"><a href="#func-Float64-float64" class="headerlink" title="func Float64() float64"></a>func Float64() float64</h3><h3 id="func-Int-int"><a href="#func-Int-int" class="headerlink" title="func Int() int"></a>func Int() int</h3><h3 id="func-Int31-int32"><a href="#func-Int31-int32" class="headerlink" title="func Int31() int32"></a>func Int31() int32</h3><h3 id="func-Int31n-n-int32-int32"><a href="#func-Int31n-n-int32-int32" class="headerlink" title="func Int31n(n int32) int32"></a>func Int31n(n int32) int32</h3><h3 id="func-Int63-int64"><a href="#func-Int63-int64" class="headerlink" title="func Int63() int64"></a>func Int63() int64</h3><h3 id="func-Int63n-n-int64-int64"><a href="#func-Int63n-n-int64-int64" class="headerlink" title="func Int63n(n int64) int64"></a>func Int63n(n int64) int64</h3><h3 id="func-Intn-n-int-int"><a href="#func-Intn-n-int-int" class="headerlink" title="func Intn(n int) int"></a>func Intn(n int) int</h3><h3 id="func-NormFloat64-float64"><a href="#func-NormFloat64-float64" class="headerlink" title="func NormFloat64() float64"></a>func NormFloat64() float64</h3><h3 id="func-Perm-n-int-int"><a href="#func-Perm-n-int-int" class="headerlink" title="func Perm(n int) []int"></a>func Perm(n int) []int</h3><h3 id="func-Read-p-byte-n-int-err-error"><a href="#func-Read-p-byte-n-int-err-error" class="headerlink" title="func Read(p []byte) (n int, err error)"></a>func Read(p []byte) (n int, err error)</h3><h3 id="func-Seed-seed-int64"><a href="#func-Seed-seed-int64" class="headerlink" title="func Seed(seed int64)"></a>func Seed(seed int64)</h3><h3 id="func-Shuffle-n-int-swap-func-i-j-int"><a href="#func-Shuffle-n-int-swap-func-i-j-int" class="headerlink" title="func Shuffle(n int, swap func(i, j int))"></a>func Shuffle(n int, swap func(i, j int))</h3><h3 id="func-Uint32-uint32"><a href="#func-Uint32-uint32" class="headerlink" title="func Uint32() uint32"></a>func Uint32() uint32</h3><h3 id="func-Uint64-uint64"><a href="#func-Uint64-uint64" class="headerlink" title="func Uint64() uint64"></a>func Uint64() uint64</h3><h2 id="type-Rand"><a href="#type-Rand" class="headerlink" title="type Rand"></a>type Rand</h2><h3 id="func-New-src-Source-Rand"><a href="#func-New-src-Source-Rand" class="headerlink" title="func New(src Source) *Rand"></a>func New(src Source) *Rand</h3><h3 id="func-r-Rand-ExpFloat64-float64"><a href="#func-r-Rand-ExpFloat64-float64" class="headerlink" title="func (r*Rand) ExpFloat64() float64"></a>func (r*Rand) ExpFloat64() float64</h3><h3 id="func-r-Rand-Float32-float32"><a href="#func-r-Rand-Float32-float32" class="headerlink" title="func (r *Rand) Float32() float32"></a>func (r *Rand) Float32() float32</h3><h3 id="func-r-Rand-Float64-float64"><a href="#func-r-Rand-Float64-float64" class="headerlink" title="func (r*Rand) Float64() float64"></a>func (r*Rand) Float64() float64</h3><h3 id="func-r-Rand-Int-int"><a href="#func-r-Rand-Int-int" class="headerlink" title="func (r *Rand) Int() int"></a>func (r *Rand) Int() int</h3><h3 id="func-r-Rand-Int31-int32"><a href="#func-r-Rand-Int31-int32" class="headerlink" title="func (r*Rand) Int31() int32"></a>func (r*Rand) Int31() int32</h3><h3 id="func-r-Rand-Int31n-n-int32-int32"><a href="#func-r-Rand-Int31n-n-int32-int32" class="headerlink" title="func (r *Rand) Int31n(n int32) int32"></a>func (r *Rand) Int31n(n int32) int32</h3><h3 id="func-r-Rand-Int63-int64"><a href="#func-r-Rand-Int63-int64" class="headerlink" title="func (r*Rand) Int63() int64"></a>func (r*Rand) Int63() int64</h3><h3 id="func-r-Rand-Int63n-n-int64-int64"><a href="#func-r-Rand-Int63n-n-int64-int64" class="headerlink" title="func (r *Rand) Int63n(n int64) int64"></a>func (r *Rand) Int63n(n int64) int64</h3><h3 id="func-r-Rand-Intn-n-int-int"><a href="#func-r-Rand-Intn-n-int-int" class="headerlink" title="func (r*Rand) Intn(n int) int"></a>func (r*Rand) Intn(n int) int</h3><h3 id="func-r-Rand-NormFloat64-float64"><a href="#func-r-Rand-NormFloat64-float64" class="headerlink" title="func (r *Rand) NormFloat64() float64"></a>func (r *Rand) NormFloat64() float64</h3><h3 id="func-r-Rand-Perm-n-int-int"><a href="#func-r-Rand-Perm-n-int-int" class="headerlink" title="func (r*Rand) Perm(n int) []int"></a>func (r*Rand) Perm(n int) []int</h3><h3 id="func-r-Rand-Read-p-byte-n-int-err-error"><a href="#func-r-Rand-Read-p-byte-n-int-err-error" class="headerlink" title="func (r *Rand) Read(p []byte) (n int, err error)"></a>func (r *Rand) Read(p []byte) (n int, err error)</h3><h3 id="func-r-Rand-Seed-seed-int64"><a href="#func-r-Rand-Seed-seed-int64" class="headerlink" title="func (r*Rand) Seed(seed int64)"></a>func (r*Rand) Seed(seed int64)</h3><p>  Seed使用提供的种子值将生成器初始化为一个确定的状态。Seed不应该与其他Rand方法并发调用。</p>
<h3 id="func-r-Rand-Shuffle-n-int-swap-func-i-j-int"><a href="#func-r-Rand-Shuffle-n-int-swap-func-i-j-int" class="headerlink" title="func (r *Rand) Shuffle(n int, swap func(i, j int))"></a>func (r *Rand) Shuffle(n int, swap func(i, j int))</h3><h3 id="func-r-Rand-Uint32-uint32"><a href="#func-r-Rand-Uint32-uint32" class="headerlink" title="func (r*Rand) Uint32() uint32"></a>func (r*Rand) Uint32() uint32</h3><h3 id="func-r-Rand-Uint64-uint64"><a href="#func-r-Rand-Uint64-uint64" class="headerlink" title="func (r *Rand) Uint64() uint64"></a>func (r *Rand) Uint64() uint64</h3><h2 id="type-Source"><a href="#type-Source" class="headerlink" title="type Source"></a>type Source</h2><h3 id="func-NewSource-seed-int64-Source"><a href="#func-NewSource-seed-int64-Source" class="headerlink" title="func NewSource(seed int64) Source"></a>func NewSource(seed int64) Source</h3><p>  NewSource返回一个新的伪随机源，其种子为给定值。与顶级函数使用的默认Source不同，这个Source对于多个goroutine的并发使用是不安全的。</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">randomSource :&#x3D; NewSource(time.Now().UnixNano())
randSeed :&#x3D; New(randomSource) &#x2F;&#x2F;这时候就可以使用rand的method
randomInt :&#x3D; randSeed.Intn(300)&#x2F;&#x2F;[0,300)的整数
</code></pre>

<h2 id="type-Source64"><a href="#type-Source64" class="headerlink" title="type Source64"></a>type Source64</h2><p>  Source64是一个也可以直接生成[0, 1&lt;&lt;64]范围内的均匀分布的伪随机uint64值的Source。如果一个Rand r的底层Source s实现了Source64，那么r.Uint64返回对s.Uint64的一次调用结果，而不是对s.Int63的两次调用。<br>  Source64的结构</p>
  <pre class="language-golang" data-language="golang"><code class="language-golang">type Source64 interface &#123;
    Source
    Uint64() uint64
&#125;</code></pre>

<h2 id="type-Zipf"><a href="#type-Zipf" class="headerlink" title="type Zipf"></a>type Zipf</h2><h3 id="func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf"><a href="#func-NewZipf-r-Rand-s-float64-v-float64-imax-uint64-Zipf" class="headerlink" title="func NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipf"></a>func NewZipf(r *Rand, s float64, v float64, imax uint64)*Zipf</h3><h3 id="func-z-Zipf-Uint64-uint64"><a href="#func-z-Zipf-Uint64-uint64" class="headerlink" title="func (z *Zipf) Uint64() uint64"></a>func (z *Zipf) Uint64() uint64</h3>
            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/golang/" rel="tag">golang</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"
                    data-tooltip="go语言圣经"
                    aria-label="PREVIOUS: go语言圣经"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/07/archive/compact_wsl2/"
                    data-tooltip="压缩wsl2的磁盘"
                    aria-label="NEXT: 压缩wsl2的磁盘"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/08/golang/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"
                    data-tooltip="go语言圣经"
                    aria-label="PREVIOUS: go语言圣经"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/07/archive/compact_wsl2/"
                    data-tooltip="压缩wsl2的磁盘"
                    aria-label="NEXT: 压缩wsl2的磁盘"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href=""
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/08/golang/go%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3/"
                        aria-label="global.share_on_wechat"
                    >
                        <i class="fa-foo_bar" aria-hidden="true"></i><span>global.share_on_wechat</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Canton
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-4u8r0fo0pgap8c0kebqie2krcfxcv3h259cjxizeggkmknhnwzjt04ztqpi1.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'ca29b9a1203b5920918d',
              clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
              repo: 'SimonTeo58.github.io',
              owner: 'SimonTeo58',
              admin: ['SimonTeo58'],
              id: '2022/10/08/golang/go标准文档/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
