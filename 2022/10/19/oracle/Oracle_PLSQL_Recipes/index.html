
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CoffeeMan">
    <title>Oracle PLSQL Recipes - CoffeeMan</title>
    <meta name="author" content="kirkzhang">
    
    
        <link rel="icon" href="https://simonteo58.github.io/assets/images/cover-v1.2.0.jpg">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg"},"articleBody":"摘要: 其实这个讲PLSQL有点基础\n\n\n\n\n1 PL&#x2F;SQL Fundamentals1.1 创建plsql代码块如和创建一个可以执行的plsql代码块？\n-- demo 1\nbegin\n  -- 中间写代码\nend;\n\n-- demo 2\n\n\ndeclare\n\n-- 定义变量\n\nbegin \n -- 业务逻辑\nend;\n\n在实际的开发当中，这些代码块会进行嵌套，第一层代码块定义的变量，内层的代码块也可以直接使用\n1.2 在plsql种执行plsql代码块如何在sqlplus中执行plsql代码?\n登录sqlplus就可以直接输入自己的代码，然后end;结束代码块，并且接着输入/,这时候sqlplus解释器就可以执行代码了。但是有一点需要明确，如果你的代码块是以declare开头的，那么就会直接输出到屏幕\nsql&gt; begin\nDBMS_OUTPUT.put_line(&quot;hello world&quot;)\nend;\n&#x2F;\n\n但是如果你想创建package,function,procedure,可以使用如下语句，方便后面的调用\nSQL&gt; CREATE OR REPLACE PROCEDURE hello_world AS \n BEGIN \n DBMS_OUTPUT.PUT_LINE(&#39;Hello World&#39;); \n END; \n &#x2F; \n\n1.3 store code in script如果你想通过sql脚本执行代码，该如何运行？\nSET SERVEROUTPUT ON;\nDECLARE \n counter NUMBER;\nBEGIN \n  FOR counter IN REVERSE 0..10 LOOP \n  DBMS_OUTPUT.PUT_LINE (counter); \n  END LOOP; \nEND;\n&#x2F;\n你可以保存你的plsql代码在脚本里,重要一步是要保证你的文件扩展名是.sqlSQL Developer supports a number of additionalextensions for more specific types of PL&#x2F;SQL. \n1.4 执行你的脚本登录sqlplus，然后跳(Traverse)到你的脚本目录\n@绝对路径\n@相对路径\nsqlplus username&#x2F;password@database my_stored_script.sql \n\n1.5 接受用户的输入从键盘中sqlplus使用&amp;符号来接受来自键盘的输入\nDECLARE\n emp_count NUMBER; \nBEGIN \n SELECT count(*) \n INTO emp_count \n FROM employees \n WHERE department_id &#x3D; &amp;department_id; \nEND; \n\n但是如果你想从键盘接受一个输入，但是后面又想继续使用，则可以使用如下方法\nDECLARE\n emp_count NUMBER; \nBEGIN \n  SELECT count(*) \n  INTO emp_count \n  FROM employees \n  WHERE department_id &#x3D; &amp;&amp;department_id; \n  DBMS_OUTPUT.PUT_LINE(&#39;The employee count is: &#39; || emp_count || \n  &#39; for the department with an ID of: &#39; || &amp;department_id); \nEND;\n\n\n另外还有一种方法就是定义变量来承接从键盘来的输入,但是要注意这个变量定义的类型,如果是numeric类型的，如果是varchar2类型则需要用单引号,见如下代码\nDECLARE \n    first varchar2(20); \n    last varchar2(25); \n    emp_last VARCHAR2(25) :&#x3D; &#39;&amp;last_name&#39;; \n    emp_count NUMBER; \nBEGIN \n    SELECT count(*) \n    INTO emp_count \n    FROM employees \n    WHERE last_name &#x3D; emp_last; \n IF emp_count &gt; 1 THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;More than 1 employee exists with that name.&#39;); \n ELSE \n    SELECT first_name, last_name \n    INTO first, last \n    FROM employees \n    WHERE last_name &#x3D; emp_last; \n    DBMS_OUTPUT.PUT_LINE(&#39;The matching employee is: &#39; || \n    first || &#39; &#39; || last); \n END IF; \nEXCEPTION \n    WHEN NO_DATA_FOUND THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;Please enter a different last name.&#39;); \nEND; \n\n1.6 Displaying Results in SQL*PlusSET SERVEROUTPUT ON is issued, then the default buffer size is 20,000 bytes.Any content that surpasses that size will be cut off. To increase the buffer, simply set the size of bufferyou’d like to use when turning the SERVEROUTPUT on: \n1.7 Commenting Your Code1.8 Referencing a Block of Code如何引用一个代码块?\n给一个代码块添加label标签,比如下面的代码\n\n&lt;&lt;dept_block&gt;&gt;\nDECLARE \n  dept_name varchar2(30); \nBEGIN \n  SELECT department_name \n  INTO dept_name \n  FROM departments \n  WHERE department_id &#x3D; 230;\n  DBMS_OUTPUT.PUT_LINE(dept_name);\nEND dept_block;\n\n\n1.9. Referring to Variables from Nested Blocks如果code block是嵌套关系那么该如何使用具有相同名字的变量,可以使用label来区分不同的变量名字\n&lt;&lt;outer_block&gt;&gt;\nDECLARE\n  mgr_id NUMBER(6) :&#x3D; &#39;&amp;current_manager_id&#39;;\n  dept_count number :&#x3D; 0;\nBEGIN\n\nSELECT count(*)\n    INTO dept_count \n    FROM departments \n    WHERE manager_id &#x3D; outer_block.mgr_id;\n\n IF dept_count &gt; 0 THEN \n    &lt;&lt;inner_block&gt;&gt; \n    DECLARE \n      dept_name VARCHAR2(30); \n      mgr_id NUMBER(6):&#x3D; &#39;&amp;new_manager_id&#39;; \n    BEGIN \n    SELECT department_name \n    INTO dept_name \n    FROM departments \n    WHERE manager_id &#x3D; outer_block.mgr_id; \n\n    UPDATE departments \n    SET manager_id &#x3D; inner_block.mgr_id \n    WHERE manager_id &#x3D; outer_block.mgr_id; \n    DBMS_OUTPUT.PUT_LINE \n    (&#39;Department manager ID has been changed for &#39; || dept_name); \n    END inner_block; \n ELSE \n    DBMS_OUTPUT.PUT_LINE(&#39;There are no departments listed for the manager&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;There are no departments listed for the manager&#39;); \nEND outer_block; \n\n但是inner block创建的变量，outside block是不会读取到的,外部块变量在内部块中是可见的，而不需要完全限定名称，并且不需要块标签\n1.10. Ignoring Substitution Variables转义那些sqlplus使用的特殊字符\nSQL&gt; SET ESCAPE &#39;\\&#39; \nSQL&gt; INSERT INTO DEPARTMENTS VALUES( \n  departments_seq.nextval, \n  &#39;Shipping \\&amp; Receiving&#39;, \n  null, \n null);\n\n还有另外一种\nSQL&gt; SET DEFINE OFF\nINSERT INTO DEPARTMENTS VALUES( \ndepartments_seq.nextval, \n&#39;Importing &amp; Exporting&#39;, \nnull, \nnull); \n\n\n1.11. Changing the Substitution Variable Character如果你对改变替换变量符号(&amp;)为其他的符号\n可以使用set define ^, 你也可以使用任意其他的符号来替换\nSQL&gt; SET DEFINE ^\nSQL&gt; SELECT department_name \n     FROM departments \n     WHERE department_id &#x3D; ^dept_id;\n\n1.12. Creating a Variable to Match a Database Column Type如果向查数据库中某一个表的数据，该如何将查询结果赋值给变量呢？可以使用%type关键字,会将一列的数据赋值给变量,而%rowtype则是返回一列的数据给变量\n\nDECLARE\n dept_name departments.department_name%TYPE; \n dept_id NUMBER(6) :&#x3D; &amp;department_id; \nBEGIN \n SELECT department_name \n INTO dept_name \n FROM departments \n WHERE department_id &#x3D; dept_id; \n DBMS_OUTPUT.PUT_LINE(&#39;The department with the given ID is: &#39; || dept_name); \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No department for the given ID&#39;); \nEND;\n\n2.基础sql\n2.1 Retrieving a Single Row from the Databaseproblem\nYou are interested in returning one row from a database table via a query that searches for an exactmatch.\nsolution 1你可以使用select ... into ...语法\nDECLARE\n    first VARCHAR2(20);  -- varchar2(20)一定是要兼容的数据库表字段的\n    last VARCHAR2(25); \n    email VARCHAR2(25); \nBEGIN \n    SELECT first_name, last_name, email \n    INTO first, last, email \n    FROM employees \n    WHERE employee_id &#x3D; 100; \n    DBMS_OUTPUT.PUT_LINE( \n    &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); \nEXCEPTION \nWHEN NO_DATA_FOUND THEN \n    DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given ID&#39;); \nWHEN TOO_MANY_ROWS THEN\n    DBMS_OUTPUT.PUT_LINE(&#39;More than one employee matches the given ID&#39;); \nEND; \n\nsolution 2\nDECLARE\n CURSOR emp_cursor IS \n SELECT first_name, last_name, email \n FROM employees \n WHERE employee_id &#x3D; &amp;emp_id; \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n OPEN emp_cursor; \n FETCH emp_cursor INTO first, last, email; \n IF emp_cursor%NOTFOUND THEN \n      RAISE NO_DATA_FOUND; \n ELSE \n -- Perform second fetch to see if more than one row is returned \n    FETCH emp_cursor INTO first, last, email; \n    IF emp_cursor%FOUND THEN \n      RAISE TOO_MANY_ROWS; \n    ELSE \n      DBMS_OUTPUT.PUT_LINE( \n      &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); \n      END IF;\n END IF; \nCLOSE emp_cursor; \n\n\nhow it works\nsolution 1: One is to issue a SELECT…INTO statement,which is a statement designed to return just one row.The other approach is to open a cursor, fetch the  one row, and close the cursorsolution 2: We keep an open mind on that point. Consider that if youare expecting exactly one row to bereturned, getting multiple rows back represents an exception case that you must somehow deal with.The cursor-based solution makes it easy to simply ignore that exception case, but ignoring a conditionthat you do not expect to occur does not change the fact that it has occurred. Although a cursor is used,the cases where no data is returned or where too many rows are returnedgiven the user-supplied EMPLOYEE_IDstill remain a reality. However, since cursors are specifically designed to deal with zero rows or morethan one row coming back from a query, no exceptions will be raised if these situations occur. For this reason,Solution #2 contains some conditional logic that is used to manually raise the desired exceptions.In the event that the user supplies the block with an invalid EMPLOYEE_ID, the cursor will not fetch any data. The %NOTFOUND attribute of the cursor will be checked to see whether the cursor successfully fetched data. If not, then the NO_DATA_FOUND exception is raised. If the cursor is successful in retrieving data, then a second FETCH statement is issued to see whether more thanone row will be returned. If more than one row is returned, then the TOO_MANY_ROWS exception is raised;otherwise, the expected output is displayed. In any event, the output that is displayed using either of thesolutions will be the same whether successful or not.\n2.2. Qualifying Column and Variable Names（变量和表列名相同)ProblemYou have a variable and a column sharing the same name. You want to refer to both in the same SQLstatement.For example, you decide that you’d like to search for records where LAST_NAME is not equal to a lastname that is provided by a user via an argument to a procedure call. Suppose you have declared avariable LAST_NAME, and you want to alter the query to read as follows: \nSELECT first_name, last_name, email\n INTO first, last, email \n FROM employees \nWHERE last_name &#x3D; last_name; \nHow does PL&#x2F;SQL know which LAST_NAME you are referring to since both the table column name andthe variable name are the same? You need a way to differentiate your references. \nSolutionYou can use the dot notation to fully qualify the local variable name with the procedure name so thatPL&#x2F;SQL can differentiate between the two. The altered query, including the fully qualifiedprocedure_name.variable solution, would read as follows: \nCREATE OR REPLACE PROCEDURE retrieve_emp_info(last_name IN VARCHAR2) AS \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n SELECT first_name, last_name, email \n INTO first, last, email \n FROM employees \n WHERE last_name &#x3D; retrieve_emp_info.last_name; \n DBMS_OUTPUT.PUT_LINE( \n &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last_name || &#39; - &#39; || email); \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name &#39; || last_name); \nEND; \n\nHow It Works\nPL&#x2F;SQL name resolution(方法) becomes very important in circumstances such as these, and by fully qualifyingthe names, you can be sure that your code will work as expected. The solution used dot notation to fullyqualify the variable name. \nThe column name could have been qualified with the table name, as in EMPLOYEES.LAST_NAME.However, there’s no need to qualify the column name in this case. Because the reference occurs within aSELECT, the closest resolution for LAST_NAME becomes the table column of that name. So, in this particularcase, it is necessary only to qualify references to variable names in the enclosing PL&#x2F;SQL block. \nIf you are executing a simple BEGIN…END block, then you also have the option of fully qualifying thevariable using the dot notation along with the block label. For the purposes of this demonstration, let’ssay that the code block shown in the solution was labeled &lt;&gt;. You could then fully qualify avariable named description as follows: \nside note:\n\n\n&lt;&lt;emp_info&gt;&gt;\nDECLARE \n last_name VARCHAR2(25) :&#x3D; &#39;Fay&#39;; \n first VARCHAR2(20); \n last VARCHAR2(25); \n email VARCHAR2(25); \nBEGIN \n SELECT first_name, last_name, email \n INTO first, last, email \n FROM employees \n WHERE last_name &#x3D; emp_info.last_name; \nEND; \n\nIn this example, the LAST_NAME that is declared in the code block is used within the SELECT..INTOquery, and it is fully qualified with the code block label.\n\n\nsummary: \n\nwhile code block contain same variable name as parameter, we could use “procedure”(including package name i though) name qualify parameter name at where clause statement.\nactualy you could use table name qualify parameter name in code block, but no more works on it,due to in your select statement,it had been qualified by table name.\nand so on , if you use label on your code block, as case shown above\n\n\n\n2.3. Declaring Variable Types That Match Column TypesProblemYou want to declare some variables in your code block that match the same datatypes as some columnsin a particular table. If the datatype on one of those columns changes, you’d like the code block toautomatically update the variable type to match that of the updated column\nNoteSharp-eyed readers will notice that we cover this problem redundantly in Chapter 1. We cover thisproblem here as well, because the solution is fundamental to working in PL&#x2F;SQL, especially to working with SQL inPL&#x2F;SQL. We don’t want you to miss what we discuss in this recipe. It is that important.\nSolutionUse the %TYPE attribute(n.属性) on table columns to identify(v.确定) the types of data that will be returned into your local variables. Instead of providing a hard-coded datatype for a variable, append %TYPE to the database column name. Doing so will apply the datatype from the specified column to the variable you are declaring.\nIn the following example, the same SELECT INTO query is issued, as in the previous problem, to retrieve an employee record from the database. However, in this case, the variables are declared using the %TYPE attribute rather than designating a specified datatype for each.\nDECLARE \n  first   employees.first_name%TYPE;\n  last    employees.last_name%TYPE;\n  email   employees.email%TYPE;\nBEGIN \nSELECT \n  first_name, \n  last_name, \n  email INTO first, last, email \nFROM \n  employees \nWHERE \n  employee_id &#x3D; &amp; emp_id;\n  DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email);\nEXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;No matching employee was found, please try again.&#39;);\nWHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&#39;An unknown error has occured, please try again.&#39;);\nEND;\n\nAs you can see from the solution, the code block looks essentially the same as the one in the previous recipe. The only difference is that here the %TYPE attribute of each database column is being used in order to declare your local variable types.\nHow It WorksThe %TYPE attribute can become a significant time-saver and savior for declaring variable types, especially if the underlying database column types are subject(会发生变化) to change. This attribute enables the local variable to assume the same datatype of its corresponding database column type at runtime. Retrieving several columns into local application variables can become tedious(沉闷的) if you need to continually verify that the datatypes of each variable are the same as those of the columns whose data they will consume.The%TYPE attribute can be used when defining variables, constants, fields, and parameters. Using %TYPE assures(保证) that the variables you declare will always remain synchronized with the datatypes of their corresponding columns.\n\nsummary: \nat all above explained that we could use `%TYPE` attribute to define variable which the same as table datatype\n\n\n2.4. Returning Queried Data into a PL&#x2F;SQL RecordProblemInstead of retrieving only a select few columns via a database query, you’d rather return the entirematching row. It can be a time-consuming task to replicate each of the table’s columns in yourapplication by creating a local variable for each along with selecting the correct datatypes. Although youcan certainly make use of the %TYPE attribute while declaring the variables, you’d rather retrieve theentire row into a single object. Furthermore, you’d like the object that the data is going to be stored intoto have the ability to assume the same datatypes for each of the columns being returned just as youwould by using the %TYPE attribute.SolutionMake use of the %ROWTYPE attribute for the particular database table that you are querying. The %ROWTYPEattribute returns a record type that represents a database row from the specified table. For instance, thefollowing example demonstrates how the %ROWTYPE attribute can store an entire employee table row for acursor: \nDECLARE \n CURSOR emp_cur IS \n SELECT * \n FROM employees \n WHERE employee_id &#x3D; &amp;emp_id; \n -- Declaring a local variable using the ROWTYPE attribute \n -- of the employees table \n emp_rec employees%ROWTYPE; \nBEGIN \n OPEN emp_cur; \n FETCH emp_cur INTO emp_rec; \n IF emp_cur%FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || emp_rec.first_name || &#39; &#39; || \n emp_rec.last_name || &#39; - &#39; || emp_rec.email); \n ELSE \n  DBMS_OUTPUT.PUT_LINE(&#39;No matching employee for the given ID&#39;);\n END IF; \n CLOSE emp_cur; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given emp ID’); \nEND; \n\n\nHow It WorksThe %ROWTYPE attribute represents an entire database table row as a record type. Each of thecorresponding table columns is represented within the record as a variable, and each variable in therecord inherits its type from the respective table column.Using the %ROWTYPE attribute offers several advantages to declaring each variable individually. Forstarters, declaring a single record type is much more productive than declaring several local variables tocorrespond to each of the columns of a table. Also, if any of the table columns’ datatypes is everadjusted, then your code will not break because the %ROWTYPE attribute works in much the same manneras the %TYPE attribute of a column in that it will automatically maintain the same datatypes as thecorresponding table columns. Therefore, if a column with a type of VARCHAR2(10) is changed toVARCHAR2(100), that change will ripple(vt.在…上形成波痕) through into your record definition.Using %ROWTYPE also makes your code much easier to read because you are not littering(n.乱丢废物) localvariables throughout. Instead, you can use the dot notation to reference each of the different columnsthat the record type returned by %ROWTYPE consists of. For instance, in the solution, the first_name,last_name, and email columns are referenced from the emp_rec record type. \n2.5. Creating Your Own Records to Receive Query ResultsProblemYou want to query the database, return several columns from one or more tables, and store them intolocal variables of a code block for processing. Rather than placing the values of the columns intoseparate variables, you want to create a single variable that contains all the values.summary: return several columns from one or more tables.\nSolutionCreate a database RECORD containing variables to hold the data you want to retrieve from the database.Since a RECORD can hold multiple variables of different datatypes, they work nicely for grouping data thathas been retrieved as a result of a query.In the following example, the database is queried for the name and position of a player. The datathat is returned is used to populate(vt.居住于；构成人口) a PL&#x2F;SQL RECORD containing three separate variables: first name, lastname, and position. \nDECLARE\n  TYPE emp_info IS RECORD(first employees.first_name%TYPE, \n                         last employees.last_name%TYPE, \n                         email employees.email%TYPE); \n  emp_info_rec emp_info;  -- 用emp_info 类型定义了emp_info_rec变量\n\nBEGIN \n SELECT first_name, last_name, email \n INTO emp_info_rec \n FROM employees \n WHERE last_name &#x3D; &#39;Vargas&#39;; \n DBMS_OUTPUT.PUT_LINE(&#39;The queried employee&#39;&#39;s email address is &#39; || emp_info_rec.email); \n EXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); \nEND; \n\nHow It WorksRecords are useful for passing similar data around within an application, but they are also quite usefulfor simply retrieving data and organizing it nicely as is the case with the solution to this recipe. To createa record, you first declare a record TYPE. This declaration can consist of one or more different datatypesthat represent columns of one or more database tables. Once the record type is declared, you create avariable and define it as an instance of the record type. This variable is then used to populate and work with the data stored in the record. \nCursor work very well with records of data. When declaring a cursor, you can select particularcolumns of data to return into your record. The record variable then takes on the type of cursor%ROWTYPE.In the following example, a cursor is used to determine which fields you want to return from EMPLOYEES.That cursor’s %ROWTYPE attribute is then used to define a record variable that is used for holding thequeried data. \nDECLARE\n CURSOR emp_cur IS \n SELECT first_name, last_name, email \n FROM employees \n WHERE employee_id &#x3D; 100; \n emp_rec emp_cur%ROWTYPE; \nBEGIN \n OPEN emp_cur; \n FETCH emp_cur INTO emp_rec; \n IF emp_cur %FOUND THEN \nCLOSE emp_cur; \n DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || \n &#39;&#39;&#39;s email is &#39; || emp_rec.email); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the provided ID number&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); \nEND; \nAs you can see in this example, the cursor %ROWTYPE attribute creates a record type using thecolumns that are queried by the cursor. The result is easy-to-read code that gains all the positive effectsof declaring record types via the %ROWTYPE attribute. \n2.6. Looping Through Rows from a QueryProblemA query that you are issuing to the database will return many rows. You want to loop through those rowsand process them accordingly. \nSolution #1There are a couple of different solutions for looping through rows from a query. One is to work directlywith a SELECT statement and use a FOR loop along with it. In the following example, you will see thistechnique in action:\nSET SERVEROUTPUT ON; \nBEGIN \n FOR emp IN \n ( \n SELECT first_name, last_name, email \n FROM employees \n WHERE commission_pct is not NULL \n ) \n LOOP \n DBMS_OUTPUT.PUT_LINE(emp.first_name || &#39; &#39; || emp.last_name || &#39; - &#39; || emp.email); \n END LOOP; \nEND; \n\nSolution #2Similarly, you can choose to use a FOR loop along with a cursor. Here’s an example: \nSET SERVEROUTPUT ON; \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, email \n FROM employees \nWHERE commission_pct is not NULL; \n      emp_rec emp_cur%ROWTYPE;\nBEGIN \n FOR emp_rec IN emp_cur LOOP \n DBMS_OUTPUT.PUT_LINE( \n emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_rec.email); \n END LOOP; \nEND; \n\nHow It WorksThe loop that is used in the first solution is also known as an implicit(adj.含蓄的,暗示的) cursor FOR loop. No variables need to be explicitly defined in that solution, because the FOR loop will automatically create a record using the results of the query. That record will take the name provided in the FOR variable_name IN clause. Thatrecord variable can then be used to reference the different columns that are returned by the query. As demonstrated in the second solution to this recipe, a cursor is also a very useful way to loop through the results of a query. This technique is also known as an explicit cursor FOR loop. This technique is very similar to looping through the results of an explicitly listed query. Neither solution requires you to explicitly open and close a cursor. In both cases, the opening andclosing is done on your behalf by the FOR loop processing. As you can see, the FOR loop with the SELECT query in the first example is a bit more concise(adj.简明的,简洁的), and there are fewer lines of code. The first example also contains no declarations. In the second example, with the cursor, there are two declarations that account for more lines of code. However, using the cursor is a standard technique that provides for more reusable code. For instance, you can elect to use the cursor any number of times, and you’ll need to write the query only once when declaring the cursor. On the contrary, if you wanted to reuse the query in the first example, then you would have to rewrite it,and having to write the same query multiple times opens the door to errors and inconsistencies. We recommend Solution #2. \n2.7. Obtaining Environment and Session InformationProblemYou want to obtain environment and session information such as the name and IP address of thecurrent user so that the values can be stored into local variables for logging purposes.SolutionMake use of the SYS_CONTEXT() built-in function to query the database for the user’s information. Once youhave obtained the information, then store it into a local variable. At that point, you can do whateveryou’d like with it, such as save it in a logging table. The following code block demonstrates thistechnique: \n&lt;&lt;obtain_user_info&gt;&gt;\nDECLARE \n  username varchar2(100); \n  ip_address varchar2(100); \nBEGIN\n  SELECT SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), SYS_CONTEXT(&#39;USERENV&#39;,&#39;IP_ADDRESS&#39;) \n  INTO username, ip_address \n  FROM DUAL; \n  DBMS_OUTPUT.PUT_LINE(&#39;The connected user is: &#39; || username || &#39;, and the IP address\n  is &#39; || \n  ip_address); \nEND; \nOnce this code block has been run, then the user’s information should be stored into the localvariables that have been declared within it. \nHow It WorksYou can use the SYS_CONTEXT function to obtain important information regarding the current user’senvironment, among other things. It is often times used for auditing(n.审计;查帐) purposes so that a particular codeblock can grab(vi.攫取;夺取) important information about the connected user such as you’ve seen in the solution tothis recipe. The SYS_CONTEXT function allows you to define a namespace and then place parameterswithin it so that they can be retrieved for use at a later time. The general syntax for the use ofSYS_CONTEXT is as follows: \nSYS_CONTEXT(&#39;namespace&#39;,&#39;parameter&#39;[,length]) \nA namespace can be any valid SQL identifier, and it must be created using the CREATE_CONTEXTstatement. The parameter must be a string or evaluate to a string, and it must be set using theDBMS_SESSION.SET_CONTEXT procedure. The call to SYS_CONTEXT with a valid namespace and parameterwill result in the return of a value that has a VARCHAR2 datatype. The default maximum length of thereturned value is 256 bytes. However, this default maximum length can be overridden by specifying thelength when calling SYS_CONTEXT. The length is an optional parameter. The range of values for the lengthis 1 to 4000, and if you specify an invalid value, then the default of 256 will be used.The USERENV namespace is automatically available for use because it is a built-in namespaceprovided by Oracle. The USERENV namespace contains session information for the current user. Table 2-1lists the parameters that are available to use with the USERENV namespace.Table 2-1. USERENV Parameter Listing \n-- Parameter          Description \nACTION                Identifies the position in the application name.\nAUDITED_CURSORID      Returns the cursor ID of the SQL that triggered the audit. \nAUTHENTICATED_DATA    Returns the data being used to authenticate the user. \nAUTHENTICATION_TYPE   Identifies how the user was authenticated. \nBG_JOB_ID             If an Oracle Database background process was used to establish the connection, then this returns the job ID of the current session. If no \n                      background process was established, then NULL is returned. \nCLIENT_IDENTIFIER     Returns identifier that is set by the application. \nCLIENT_INFO           Returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. \nCURRENT_SCHEMA        Returns the current session’s default schema.\nCURRENT_SCHEMAID      Returns the current schema’s identifier.\nCURRENT_SQL           Returns the first 4KB of the triggering SQL.\nDB_DOMAIN             Returns the value specified in the DB_DOMAIN parameter. \nDB_NAME               Returns the value specified in the DB_NAME parameter. \nDB_UNIQUE_NAME        Returns the value specified in the DB_UNIQUE_NAME parameter. \nENTRYID               Returns the current audit entry number. \nEXTERNAL_NAME         Returns the external name of the database user. \nFG_JOB_ID             If an Oracle Database foreground process was used to establish the connection, then this returns the job ID of the current session. If no \n                      foreground process was established, then NULL is returned. \nGLOBAL_CONTEXT_MEMORY Returns the number being used by the globally accessed context in the \n                      System Global Area.   \nHOST                  Returns the host name of the machine from which the client has connected. \nINSTANCE              Returns the instance ID number of the current instance. \nIP_ADDRESS            Returns the IP address of the machine from which the client has connected. \nISDBA                 Returns TRUE if the user was authenticated as a DBA. \nLANG                  Returns the ISO abbreviation of the language name. \nLANGUAGE              Returns the language and territory used by the session, along with the \n                      character set. \nMODULE                Returns the application name. This name has to be set via the\n                      DBMS_APPLICATION_INFO package. \nNETWORK_PROTOCOL      Returns the network protocol being used for communication. \nNLS_CALENDAR          Returns the current calendar of the current session. \nNLS_CURRENCY          Returns the currency of the current session. \nNLS_DATE_FORMAT       Returns the date format for the session. \nNLS_DATE_LANGUAGE     Returns the language being used for expressing dates. \nNLS_SORT              Returns the BINARY or linguistic sort basis. \nNLS_TERRITORY         Returns the territory of the current session. \nOS_USER               Returns the operating system user name of the client that initiated the \n                      session. \nPROXY_USER            Returns the name of the database that opened the current session on behalf \n                      of SESSION_USER. \nPROXY_USERID          Returns the identifier of the database user who opened the current session on behalf of the SESSION_USER. \nSERVICE_NAME          Returns the name of the service to which a given session is connected. \nSESSION_USER          Returns the database user name through which the current user is authenticated. \nSESSION_USERID        Returns the identifier of the database user name by which the current user is authenticated. \nSESSIONID             Returns the auditing session identifier. \nSTATEMENTID           Returns the auditing statement identifier. \nTERMINAL              Returns the operating system identifier for the client of the current session. \nWhen SYS_CONTEXT is used within any query, it is most commonly issued against the DUAL table. TheDUAL table is installed along with the data dictionary when the Oracle Database is created. This table isreally a dummy(adj.虚拟的,假的) table that contains one column that is appropriately named DUMMY. This column containsthe value X.\nSQL&gt; desc dual;\n Name Null? Type \n ----------------------------------------- -------- ---------------------------- \nDUMMY VARCHAR2(1) \nAmong other things, DUAL is useful for obtaining values from the database when no actual table isneeded. Our solution case is such a situation.\n2.8. Formatting Query ResultsProblemYour boss asks you to print the results from a couple of queries in a nicely formatted manner.SolutionUse a combination of different built-in formatting functions along with the concatenation operator (||)to create a nice-looking basic report. The RPAD and LPAD functions along with the concatenation operatorare used together in the following example that displays a list of employees from a company: \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, phone_number \n FROM employees; \n emp_rec employees%ROWTYPE; \nBEGIN \n FOR emp_rec IN emp_cur LOOP \n IF emp_rec.phone_number IS NOT NULL THEN \n DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 35,&#39;.&#39;) || \n emp_rec.phone_number); \n ELSE \n DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || \n &#39; does not have a phone number.&#39;); \n END IF; \n END LOOP; \nEND; \nThe following is another variant of the same report, but this time dashes are used instead of using \ndots to space out the report: \nDECLARE \n CURSOR emp_cur IS \n SELECT first_name, last_name, phone_number \n FROM employees; \n emp_rec employees%ROWTYPE; \nBEGIN \n FOR emp_rec IN emp_cur LOOP \n  IF emp_rec.phone_number IS NOT NULL THEN\n  --CHECK FOR INTERNATIONAL PHONE NUMBERS\n        IF length(emp_rec.phone_number) &gt; 12 THEN\n          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,18));\n        ELSE\n          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,12));\n        END IF;\n      ELSE\n        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;does not have a phone number.&#39;);\n    END IF;\n  END LOOP;\nEND;\n\nHow It WorksThe RPAD and LPAD functions are used to return the data in a formatted manner. The RPAD function takes astring of text and pads it on the right by the number of spaces provided by the second parameter. Thesyntax for the RPAD function is as follows:\nRPAD(input_text, n, character) -- append n piece characters on the right\n\nIn this syntax, n is the number of spaces used to pad. Similarly, the LPAD function pads on the left ofthe provided string. The syntax is exactly the same as RPAD; the only difference is the direction of thepadding. The combination of these two functions, along with the concatenation operator (||), providesfor some excellent formatting options.  \nIt is important to look at the data being returned before you try to format it, especially to considerwhat formatting options will look best when generating output for presentation. In the case of theexamples in this recipe, the latter example would be the most reasonable choice of formatting for thedata being returned, since the phone number includes dots in it. The first example uses dots to space outthe report, so too many dots may make the output difficult to read. Know your data, and then choose theappropriate PL&#x2F;SQL built-ins to format accordingly.  \nNote When using DBMS_OUTPUT to display data, please be sure to pay attention to the size of the buffer. You canset the buffer size from 2,000 to 1,000,000 bytes by passing the size you desire to the DBMS_OUTPUT.ENABLE procedure.If you attempt to display content over this size limit, then Oracle will raise an exception.\nOracle provides a number of built-in functions to use when formatting strings. Two others that areespecially useful are LTRIM(&lt;string&gt;) and RTRIM(&lt;string&gt;). These remove leading and trailing spaces,respectively. See your Oracle SQL Reference manual for a complete list of available string functions.\n2.9. Updating Rows Returned by a QueryProblem  You’ve queried the database and retrieved a row into a variable. You want to update some valuescontained in the row and commit them to the database.Solution  First, retrieve the database row that you want to update. Second, update the values in the row that needto be changed, and then issue an UPDATE statement to modify the database with the updated values. Inthe following example, a procedure is created that queries a table of employees for a particularemployee. The resulting employee’s department ID is then updated with the new one unless theemployee is already a member of the given department.\nCREATE OR REPLACE PROCEDURE change_emp_dept(emp_id IN NUMBER, \n dept_id IN NUMBER) AS \n emp_row employees%ROWTYPE; \n dept departments.department_name%TYPE; \n rec_count number :&#x3D; 0; \nBEGIN \n SELECT count(*) \n INTO rec_count \n FROM employees \n WHERE employee_id &#x3D; emp_id; \n IF rec_count &#x3D; 1 THEN \n SELECT * \n INTO emp_row \n FROM employees \n WHERE employee_id &#x3D; emp_id; \n IF emp_row.department_id !&#x3D; dept_id THEN \n emp_row.department_id :&#x3D; dept_id; \n UPDATE employees SET ROW &#x3D; emp_row \n WHERE employee_id &#x3D; emp_id; \n SELECT department_name \n INTO dept \n from departments \n WHERE department_id &#x3D; dept_id; \n DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || emp_row.first_name || &#39; &#39; || \n emp_row.last_name || &#39; is now in department: &#39; || dept); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;The employee is already in that department...no change&#39;); \n END IF; \nELSIF rec_count &gt; 1 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The employee ID you entered is not unique&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;No employee records match the given employee ID&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Invalid employee or department ID, try again&#39;); \n WHEN OTHERS THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Unsuccessful change, please check ID numbers and try again&#39;); \nEND; \nAs you can see, the example queries the database into a record declared using the %ROWTYPEattribute. The value that needs to be updated is then modified using the data contained in the record.Lastly, using the SET ROW clause updates the table with the modified record.How It WorksAs you’ve seen in the solution to the recipe, it is possible to update the values of a row returned by aquery using the UPDATE...SET ROW syntax. In many cases, using a single UPDATE statement can solve thistype of transaction. However, in some scenarios where you need to evaluate the current value of aparticular column, then this solution is the correct choice.\nUsing the UPDATE ROW statement, you can update entire database rows with a single variable of eitherthe %ROWTYPE or RECORD type. The UPDATE statement also allows you to return values after the update byadding the RETURNING clause to the end of the statement followed(v.跟着,听从) by the column names to return and thevariables that will receive their values. Take a look at this next example:\nDECLARE\n first        employees.first_name%TYPE; \n last         employees.last_name%TYPE; \n new_salary   employees.salary%TYPE; \nBEGIN \n UPDATE employees \n SET salary &#x3D; salary + (salary * .03) \n WHERE employee_id &#x3D; 100  RETURNING first_name, last_name,salary INTO first, last, new_salary; \n DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || first || &#39; &#39; || last || &#39; now has a salary of: &#39; || new_salary); \nEND; \nAs you can see, the example outputs the new values that are the result of the update statement.Using the RETURNING clause saves a step in that you are not required to requery the table after the updatein order to display the updated results.\n2.10. Updating Rows Returned by a CursorProblemYou’ve created a cursor to use for querying your data. You want to loop through the results using a cursor for loop and update the data as needed.SolutionUse the WHERE_CURRENT_OF clause within your loop to update the current data row in the iteration. In thefollowing example, the EMPLOYEES table is queried for all employees in a particular department. Theresults of the query are then iterated using a FOR loop, and the salary is increased for each employeerecord that is returned.\n\nDECLARE \n CURSOR emp_sal_cur IS \n SELECT * \n FROM employees \n WHERE department_id &#x3D; 60 \n FOR UPDATE;        --cursor should use &#96;FOR UPDATE&#96; clause statement\n\n emp_sal_rec emp_sal_cur%ROWTYPE; -- cursor also would define varable using ROWTYPE keyword\n\n BEGIN \n FOR emp_sal_rec IN emp_sal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;Old Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); \n    UPDATE employees \n    SET salary &#x3D; salary + (salary * .025) \n    WHERE CURRENT OF emp_sal_cur;  -- current of your_cursor\n END LOOP; \n\n -- Display the updated salaries \n FOR emp_sal_rec IN emp_sal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;New Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); \n END LOOP; \nEND;\n\nAn update on the EMPLOYEES table occurs with each iteration of the loop. The second loop in thisexample simply displays the new salary result for each employee that was returned by the cursor query.How It WorksUpdating values when iterating a cursor can be handy(adj.便利的,手边的), especially when working with a number of(大量) rows.There is one main difference between a cursor that allows updating and one(cursor) that does not. Thatdifference is the addition of the FOR UPDATE clause in the cursor declaration. By using the FOR UPDATEclause of the SELECT statement, you are causing the database to lock the rows that have been read by thequery. This lock is to ensure that nobody else can modify the rows while you are working with them. Thelock creates a read-only block on the table rows so that if someone else attempts to modify them whileyou have them locked, then they will have to wait until you have performed either a COMMIT or a ROLLBACK.The FOR UPDATE clause has an optional NOWAIT keyword. By including this keyword, you will ensurethat your query does not block your transaction if someone else already has the rows that you arequerying blocked. The NOWAIT keyword tells Oracle not to wait if the requested rows are already locked,and control is immediately passed back to your program so that it can continue to run. If the NOWAITkeyword is omitted and the rows are already locked, then your program will stop and wait until the lockhas been released.\nYou can use the cursor with any style of loop, as you’ve seen in previous recipes. No matter whichtype of loop you choose, the UPDATE must be coded using the WHERE CURRENT OF your_cursor clause to update thecurrent row in the cursor iteration. You will need to be sure to commit the changes after this block hasbeen run, and in many circumstances the COMMIT statement can be coded into this block once it has beentested and verified to work correctly. As with any UPDATE statement, if you fail to COMMIT your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to yourschema only until you disconnect. Issuing a COMMIT after your UPDATE statements have been issued is alsoa good practice in this case because it will release the lock on the rows you had queried via the cursor sothat someone else can update them if needed. If you determine the data that was updated by the codeblock is incorrect, then a ROLLBACK will also release the lock.\n\n\nsummary:\n\nif you wanna update data of cursor that returned by select, you can use WHERE CURRENT OF emp_sal_cur and for update\nBy using the FOR UPDATE clause of the SELECT statement,data lock is data level\nwether FOR UPDATE clause update table data or cursor only?(it should be commit changes for table)\nif you fail to COMMIT your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to yourschema only until you disconnec\nCOMMIT and ROLLBACK either release lock\n\n \n\n2.11. Deleting Rows Returned by a CursorProblemThere are a series of database rows that you’d like to delete. You’ve created a cursor FOR LOOP, and you want to delete some or all rows that have been queried with the cursor.SolutionUse a DELETE statement within a FOR LOOP to delete the rows that are retrieved by the cursor. If you create a cursor using the FOR UPDATE clause, then you will be able to use the WHERE CURRENT OF clause along with the DELETE statement to eliminate the current row within each iteration of the cursor. The following example shows how this can be done to remove all job history for a given department ID:\nCREATE OR REPLACE PROCEDURE remove_job_history(dept_id IN NUMBER) AS \n\n CURSOR job_history_cur IS \n SELECT * \n FROM job_history \n WHERE department_id &#x3D; dept_id \n FOR UPDATE; \n    job_history_rec job_history_cur%ROWTYPE; \n BEGIN \n  FOR job_history_rec IN job_history_cur LOOP \n    DELETE FROM job_history WHERE CURRENT OF job_history_cur; \n    DBMS_OUTPUT.PUT_LINE(&#39;Job history removed for department &#39; || dept_id); \n  END LOOP; \nEND; \nUsing this technique, the job history for the department with the given ID will be removed from the JOB_HISTORY table.\nHow It WorksMuch like updating rows using a cursor, the deletion of rows uses the WHERE CURRENT OF clause within the DELETE statement to remove each row. The cursor query must contain the FOR UPDATE clause in order to lock the rows that you are reading until a COMMIT or ROLLBACK has been issued. As mentioned in the previous recipe, the NOWAIT keyword is optional, and it can be used to allow control to be immediately returned to your program if someone else already has locks on the rows that you are interested in updating. In each iteration of the loop, the DELETE statement is used along with the WHERE CURRENT OF clause to remove the current cursor record from the database. Once the loop has been completed, then all the rows that had been queried via the cursor should have been deleted. This technique is especially useful if you are going to be performing some further processing on each of the records and then deleting them. One such case would be if you wanted to write each of the records to a history table prior to deleting them. In any case, the cursor FOR loop deletion technique is a great way to remove rows from the database and work with the data along the way.\n2.12. Performing a TransactionProblemYou need to complete a series of INSERT or UPDATE statements in order to process a complete transaction. In doing so, you need to ensure that if one of the statements fails, that all of the statements are canceled so that the transaction is not partially processed.SolutionUse the transaction control mechanisms that are part of PL&#x2F;SQL, as well as SQL itself, in order to control your transactions. When all your statements have been completed successfully, issue a COMMIT to make them final. On the other hand, if one of the statements does not complete successfully, then perform a ROLLBACK to undo all the other changes that have been made and bring the database back to the state that it was in prior(美[‘praɪɚ],adj.优先的,在先的,在前的) to the transaction occurring.In the following example, the code block entails the body of a script that is to be executed in order to create a new department and add some employees to it. The department change involves an INSERT and UPDATE statement to complete.\nDECLARE\n -- Query all programmers who make more than 4000 \n -- as they will be moved to the new &#39;Web Development&#39; department \n CURSOR new_dept_cur IS \n    SELECT * \n    FROM employees \n    WHERE job_id &#x3D; &#39;IT_PROG&#39;\n    AND salary &gt; 4000 \n    FOR UPDATE; \n new_dept_rec         new_dept_cur%ROWTYPE; \n current_department   departments.department_id%TYPE; \nBEGIN \n -- Create a new department \n INSERT INTO departments values( \n                                DEPARTMENTS_SEQ.nextval, -- Department ID (sequence value) \n                                &#39;Web Development&#39;, -- Department Title \n                                103 -- Manager ID \n                                1700); -- Location ID \n -- Obtain the current department ID…the new department ID \n SELECT DEPARTMENTS_SEQ.currval \n INTO current_department \n FROM DUAL; \n\n -- Assign all employees to the new department \n FOR new_dept_rec IN new_dept_cur LOOP \n      UPDATE employees \n      SET department_id &#x3D; current_department \n      WHERE CURRENT OF new_dept_cur; \n END LOOP;\n\n COMMIT;\n      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); \nEND;\nAs you can see, a transaction was performed in this block of code. It is important to roll back changes if errors occur along the way so that the transaction is not partially completed.\nHow It WorksTransaction control is built into the Oracle Database. Any database changes that are made within a code block are visible to the current session only until a COMMIT has been made. The changes that have been made by the statements can be rolled back via the ROLLBACK command up until the point that a COMMIT is issued. Oracle uses table and row locks to ensure that data that has been updated in one session cannot be seen in another session until a COMMIT occurs. A transaction is started when the first statement after the last COMMIT or ROLLBACK is processed or when a session is created. It ends when a COMMIT or ROLLBACK occurs. A transaction is not bound to a single code block, and any code block may contain one or more transactions. Oracle provides a SAVEPOINT command, which places a marker at the current database state so as to allow you to roll back to that point in time in a transaction. Oracle Database automatically issues a SAVEPOINT prior to processing the first statement in any transaction.\nAs a rule of thumb, it is always a good idea to have exception handling in place in case an exceptionoccurs. However, if an unhandled exception occurs, then the database will roll back the statement that caused the exception, not the entire transaction. Therefore, it is up to the program to handle exceptions and issue the ROLLBACK command if the entire transaction should be undone. If a database crashes and goes down during a transaction, then when the database is restarted, all uncommitted statements are rolled back. All transactions are completed when a COMMIT or ROLLBACK is issued.\n2.13. Ensuring That Multiple Queries “See” the Same DataProblemYou are issuing a set of queries against the database, and you need to ensure that none of the table rows change throughout the course of the queries being made.SolutionSet up a read-only transaction in which the current transaction will see the data only as an unchanged snapshot in time. To do so, use the SET TRANSACTION statement to begin a read-only transaction and establish a snapshot of the data so it will be consistent and unchanged from all other updates being made. For instance, the following example displays a block that sets up read-only queries against the database for dollar values from a bank account:\nDECLARE \n daily_atm_total NUMBER(12,2); \n weekly_atm_total NUMBER(12,2); \nBEGIN \n COMMIT; -- ends previous transaction \n SET TRANSACTION READ ONLY NAME &#39;ATM Weekly Summary&#39;; \n SELECT SUM (wd_amt) INTO daily_atm_total FROM atm_withdrawals \n WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE, &#39;MM-DD-YYYY&#39;); \n SELECT SUM (weekly_total) INTO weekly_atm_total FROM atm_withdrawals \n WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE - 7, &#39;MM-DD-YYYY&#39;); \n DBMS_OUTPUT.PUT_LINE(daily_atm_total || &#39; - &#39; || weekly_atm_total); \n COMMIT; -- ends read-only transaction \nEND; \nQuerying the database using read-only transactions will ensure that someone will see the correct values in a situation such as the one depicted(vt.描述,描画) in this example.\nHow It Worksoften times there are situations when you need to ensure that the data being queried throughout a transaction’s life cycle is unchanged by other users’ updates. The classic case is when someone goes to withdraw money from the bank and their spouse(n.配偶) is at an ATM machine depositing into the account at the same time. If read consistency were not in place, the individual may view their account balance and see that there was plenty of money to withdraw, and then they’d go to take the money out and receive an error because the spouse had canceled the deposit(美 [dɪ’pɑzɪt]n.存款,押金) instead. A read-only transaction allows for read consistency until a COMMIT has been issued. If the spouse had confirmed the deposit, then the next query on the account would reflect the additional funds (assuming that the bank were to release them to the account in real time).Situations such as these require that you provide an environment that is essentially isolated from the outside world. You can use the SET TRANSACTION command to start a read-only transaction, set an isolation level, and assign the current transaction to a rollback segment. The SET TRANSACTION statement must be the first statement in a read-only transaction, and it can appear only once in the transaction. Note that there are some statement restrictions when using a read-only transaction. Only SELECT INTO, OPEN, FETCH, CLOSE, LOCK TABLE, COMMIT, and ROLLBACK statements can be used; other statements are not allowed.\n2.14. Executing One Transaction from Within Another(nested tracsaction)ProblemYou are executing a transaction, and you are faced with the need to suspend your current work, issue a completely separate transaction, and then pick up your current work. For example, say you want to log entries into a log table. The log entries should be persisted separately from the current transaction such that if the transaction fails or is rolled back, the log entries will still be completed.SolutionStart an autonomous transaction to make the log entry. This will ensure that the log entry is performed separately from the current transaction. In the following example, an employee is deleted from the EMPLOYEES table. Hence, a job is ended, and the job history must be recorded into the JOB_HISTORY table. In the case that something fails within the transaction, the log entry into the JOB_HISTORY table must be intact(adj.完整的,原封不动的). This log entry cannot be rolled back because it is performed using an autonomous transaction.The code to encapsulate(美 [ɪn’kæpsjə’let],vt.压缩,将…装入胶囊) the autonomous transaction needs to be placed into a named block that can be called when the logging needs to be performed. The following piece of code creates a PL&#x2F;SQL procedure that performs the log entry using an autonomous transaction. (You will learn more about procedures in Chapter 4.) Specifically notice(n.通知,布告) the declaration of PRAGMA AUTONOMOUS_TRANSACTION. That pragma specifies that the procedure executes as a separate transaction, independent of any calling transaction.\nCREATE OR REPLACE PROCEDURE log_job_history ( emp_id IN \n                                              employees.employee_id%TYPE, \n                                              Job_id IN jobs.job_id%TYPE, \n                                              Department_id IN employees.department_id%TYPE, \n                                              employee_start IN DATE) AS \n  PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN \n INSERT INTO job_history \n VALUES (emp_id, \n employee_start, \n sysdate, \n job_id, \n department_id); \n COMMIT; \nEND;\n\nThe LOG_JOB_HISTORY procedure inserts an entry into the log table separately from the transaction that is taking place in the calling code block. The following code performs the job termination, and it calls the log_substitution procedure to record the history:\nDECLARE\n CURSOR dept_removal_cur IS \n    SELECT * \n    FROM employees \n    WHERE department_id &#x3D; 10 \n    FOR UPDATE; \n dept_removal_rec dept_removal_cur%ROWTYPE; \nBEGIN \n -- Delete all employees from the database who reside in department 10 \n FOR dept_removal_rec IN dept_removal_cur LOOP \n    DBMS_OUTPUT.PUT_LINE(&#39;DELETING RECORD NOW&#39;); \n    DELETE FROM employees WHERE CURRENT OF dept_removal_cur; \n    -- Log the termination \n    log_job_history(dept_removal_rec.employee_id, \n                      dept_removal_rec.job_id, \n                      dept_removal_rec.department_id, \n                      dept_removal_rec.hire_date);\n END LOOP; \n    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); \nEXCEPTION \n -- Handles all errors \n WHEN NO_DATA_FOUND THEN\n    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been rolled back due to errors, please try again.&#39;); \n    ROLLBACK; \nEND;\nIf this code block is executed and then rolled back, the entry into the job history table remains,because it is performed as a separate, autonomous transaction.How It WorksAn autonomous transaction is a transaction that is called by another transaction and that runs separately from the calling transaction. Autonomous transactions commit or roll back without affecting the calling transaction. They also have the full functionality of regular transactions; they merely(adv.仅仅,只不过,只是) run separately from the main transaction. They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.\nAn autonomous transaction must be created with a top-level code block, trigger, procedure,function, or stand-alone named piece of code. In the solution, you saw that a procedure was created to run as an autonomous transaction. That is because it is not possible to create an autonomous transaction within a nested code block. To name a transaction as autonomous, you must place the statement PRAGMA AUTONOMOUS_TRANSACTION within the declaration section of a block encompassing(adj.包含的,包容的,环绕) the transaction. To end the transaction, perform a COMMIT or ROLLBACK.\n\n\nsummary: \n\nThey allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.\n\n\n\n2.15. Finding and Removing Duplicate Table RowsProblemYou have found that for some reason your database contains a table that has duplicate records. You areworking with a database that unfortunately does not use primary key values, so you must manually enforce data integrity. You need a way to remove the duplicate records. However, any query you write to remove one record will also remove its duplicate.SolutionThe solution to this issue involves two steps. First you need to query the database to find all duplicaterows, and then you need to run a statement to delete one of each duplicate record that is found.The following code block queries the EMPLOYEES table for duplicate rows. When a duplicate is found,it is returned along with a count of duplicates found.\n&lt;&lt;duplicate_emp_qry&gt;&gt;\nDECLARE\nCURSOR emp_cur IS\n  SELECT *\n  FROM employees\n  ORDER BY employee_id;\n  emp_count\n  number :&#x3D; 0;\n  total_count\n  number :&#x3D; 0;\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(&#39;You will see each duplicated employee listed more &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;than once in the list below. This will allow you to &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;review the list and ensure that indeed...there are more &#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;than one of these employee records in the table.&#39;);\n  DBMS_OUTPUT.PUT_LINE(&#39;Duplicated Employees: &#39;);\n-- Loop through each player in the table\nFOR emp_rec IN emp_cur LOOP\n-- Select the number of records in the table that have the same ID as the current record\nSELECT count(*)\nINTO emp_count\nFROM employees\nWHERE employee_id &#x3D; emp_rec.employee_id;\n-- If the count is greater than one then a duplicate has been found, so print it out.\nIF emp_count &gt; 1 THEN \n DBMS_OUTPUT.PUT_LINE(emp_rec.employee_id || &#39; - &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_count); \n total_count :&#x3D; total_count + 1; \n END IF; \n END LOOP; \nEND;\nIf the table includes a duplicate, then it is printed out as follows:You will see each duplicated employee listed more than once in the list below. This will allow you to review the list and ensure that indeed…there are morethan one of these employees in the table.Duplicated Employees:100 - Steven King - 2100 – Steven King - 2PL&#x2F;SQL procedure successfully completed.  \nNext, you need to delete the duplicated rows that have been found. The following DELETE statementwill ensure that one of the duplicates is removed:DELETE FROM employees A WHERE ROWID &gt; (SELECT min(rowid) FROM employees BWHERE A.employee_id &#x3D; B.employee_id);\nHow It WorksUsually using primary keys prohibits the entry of duplicate rows into a database table. However, many legacy databases still in use today do not include such constraints. In rare situations, a duplicate key and values are entered into the database that can cause issues when querying data or assigning values. The method shown in the solution for finding duplicate rows is very basic. The solution loops through each record in the table, and during each pass, it queries the table for the number of records found that match the current record’s EMPLOYEE_ID. If the number found is greater than one, then you know that you have found a duplicate. The solution presented here for finding duplicates will work on any table provided that you have a column of data that should contain logically unique values. In the example, each record should contain a different EMPLOYEE_ID, so if there is more than one record with the same EMPLOYEE_ID value, then a duplicate is found. If the table you are working with does not contain any unique columns, then you can concatenate a number of columns in order to obtain a unique combination. For instance, if EMPLOYEES did not contain an EMPLOYEE_ID column, then you could concatenate the FIRST_NAME, LAST_NAME, and EMAIL columns to obtain a unique combination. More likely than not, there will not be two employees in the table with the same name and e-mail address. The second part of the solution involves removing one or more duplicate records from the set. To do so, you have to look at a pseudocolumn known as the ROWID. The ROWID is a pseudocolumn (invisible column) that is found in each table in an Oracle Database that uniquely identifies each row. By comparing these unique ROWID values, you can delete just one of the records, not both. The DELETE statement actually finds the rows that contain the same uniquely identified column(s) and then removes the row with the larger ROWID value.\n3. Looping and Logic3.1. Choosing When to Execute CodeProblemYour code contains a condition, and you are interested in executing code to perform specific actions if the condition evaluates to TRUE, FALSE, or NULL.SolutionUse an IF-THEN statement to evaluate an expression (or condition) and determine which code to executeas a result. The following example depicts a very simple IF-THEN statement that evaluates one variable to see whether it contains a larger value than another variable. If so, then the statements contained within the IF-THEN statement are executed; otherwise, they are ignored. \nDECLARE \n value_one NUMBER :&#x3D; &amp;value_one; \n value_two NUMBER :&#x3D; &amp;value_two; \nBEGIN \n IF value_one &gt; value_two THEN \n DBMS_OUTPUT.PUT_LINE(&#39;value_one is greater than value_two&#39;); \n END IF; \nEND; \nAs you can see from the example, if value_one is greater than value_two, a line of output will be printed stating so. Otherwise, the IF statement is bypassed, and processing continues.How It WorksAs shown in the solution, the general format for the IF-THEN statement is as follows:\nIF condition THEN\n Statements to be executed \n …\nEND IF; \nThe IF-THEN statement is one of the most frequently used conditional statements. If a given condition evaluates to TRUE, then the code contained within the IF-THEN statement is executed. If the condition evaluates to FALSE or NULL, then the statement is exited. However, it is possible to incorporate(vt.包含,吸收) a different set of statements if the condition is not satisfied. Please see Recipe 3-2 for an example. Any number of IF-THEN statements can be nested within one another. The statements within the IF-THEN will be executed if the condition that is specified evaluates to TRUE.\n3-2. Choosing Between Two Mutually Exclusive ConditionsProblemYou have two conditions that are mutually(美 [‘mjutʃuəli]adv.互相地,互助) exclusive. You want to execute one set of statements if thefirst condition evaluates to TRUE. Otherwise, if the first condition is FALSE or NULL, then execute a differentset of statements.SolutionUse an IF-ELSE statement to evaluate the condition and execute the statements that correspond to it ifthe condition evaluates to TRUE. In the following example, a given employee ID is used to query theEMPLOYEES table. If that employee exists, then the employee record will be retrieved. If not found, then amessage will be displayed stating that no match was found. \nDECLARE \n employee employees%ROWTYPE; \n emp_count number :&#x3D; 0; \nBEGIN \n SELECT count(*) \n INTO emp_count \n FROM employees \n WHERE employee_id &#x3D; 100; \n IF emp_count &gt; 0 THEN \n SELECT * \n INTO employee \n FROM employees \n WHERE employee_id &#x3D; 100; \n IF employee.manager_id IS NOT NULL THEN \n DBMS_OUTPUT.PUT_LINE(employee.first_name || &#39; &#39; || employee.last_name || \n &#39; has an assigned manager.&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(employee.first_name || &#39; &#39; || employee.last_name || \n &#39; does not have an assigned manager.&#39;); \nEND IF; \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;The given employee ID does not match any records, &#39;|| \n &#39; please try again&#39;); \n END IF; \nEXCEPTION \n WHEN NO_DATA_FOUND THEN \n DBMS_OUTPUT.PUT_LINE(&#39;Try another employee ID.&#39;); \nEND; \nIn the real world, the employee ID would not be hard-coded into the example. However, this example provides a good scenario for evaluating mutually exclusive conditions and also nesting IF statements.How It WorksThe IF-ELSE statement syntax is basically the same as the IF-THEN syntax, except that a different set ofstatements is executed in the ELSE clause when the condition evaluates to FALSE or NULL. Therefore, if thefirst condition is FALSE or NULL, then the control automatically drops down into the statements containedwithin the ELSE clause and executes them.\n3.3. Evaluating Multiple Mutually Exclusive ConditionsProblemYour application has multiple conditions to evaluate, and each of them is mutually exclusive. If one ofthe conditions evaluates to FALSE, you’d like to evaluate the next one. You want that process to continueuntil there are no more conditions.Two solutions are possible: one using IF and the other using CASE.\nSolution #1Use an IF-ELSIF-ELSE statement to perform an evaluation of all mutually exclusive conditions. The following example is a SQL*Plus script that queries how many countries are in a specified region.\nIf the region that is typed as input when the following example executes matches any of the regions specified by the conditions in the IF statement, then subsequent statements are executed. However, a default message is displayed if the input does not match any region.\nDECLARE\n Region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; \n country_count number :&#x3D; 0; \nBEGIN \n IF upper(region) &#x3D; &#39;EUROPE&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 1; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Europe region.&#39;); \n ELSIF upper(region) &#x3D; &#39;AMERICAS&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 2; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Americas region.&#39;); \n ELSIF upper(region) &#x3D; &#39;ASIA&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 3; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Asia region.&#39;); \n ELSIF upper(region) &#x3D; &#39;MIDDLE EAST AND AFRICA&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 4; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Middle East and Africa region.&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); \n END IF; \nEND; \nSolution #2You can use the searched CASE statement to evaluate a boolean expression to determine which statements to execute among multiple, mutually exclusive conditions. The next example is a SQL*Plus script that performs the same tasks as Solution #1 but this time using a searched CASE statement:\nDECLARE\n region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; \n country_count number :&#x3D; 0; \nBEGIN \n CASE \n WHEN upper(region) &#x3D; &#39;EUROPE&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 1; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Europe region.&#39;); \n WHEN upper(region) &#x3D; &#39;AMERICAS&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 2; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Americas region.&#39;); \n WHEN upper(region) &#x3D; &#39;ASIA&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 3; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Asia region.&#39;); \n WHEN upper(region) &#x3D; &#39;MIDDLE EAST AND AFRICA&#39; THEN \n SELECT count(*) \n INTO country_count \n FROM countries \n WHERE region_id &#x3D; 4; \n DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || \n &#39;the Middle East and Africa region.&#39;); \n ELSE \n DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); \n END CASE; \nEND; \n\nHow It WorksIF-ELSIF-ELSE can be used to evaluate any number of conditions. It functions such that if the firstcondition in the IF-ELSIF-ELSE statement evaluates to TRUE, then the statements within its block areexecuted, and all others are bypassed. Similarly, if the first condition evaluates to FALSE and the secondcondition evaluates to TRUE, then the second condition’s statements will be executed, others will beignored, and so on.\nCASE\n WHEN &lt;&lt;boolean_expression&gt;&gt; THEN &lt;&lt;statements&gt;&gt; \n[ELSE statements]; \n\n\n3.4 Driving from an Expression Having Multiple OutcomesProblemYou have a single expression that yields multiple outcomes. You are interested in evaluating the expression and performing a different set of statements depending upon the outcome.SolutionUse a CASE statement to evaluate your expression, and decide which set of statements to execute depending upon the outcome. In the following example, a SQL*Plus script accepts a region entry, which is being evaluated to determine the set of statements to be executed. Based upon the value of the region, the corresponding set of statements is executed, and once those statements have been executed, then the control is passed to the statement immediately following the CASE statement. \nDECLARE \n region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; \n country_count number :&#x3D; 0; \nBEGIN \n CASE upper(region) \n WHEN &#39;EUROPE&#39; THEN \n    SELECT count(*) \n    INTO country_count \n    FROM countries \n    WHERE region_id &#x3D; 1; \n    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Europe region.&#39;); \n WHEN &#39;AMERICAS&#39; THEN \n    SELECT count(*) \n    INTO country_count \n    FROM countries \n    WHERE region_id &#x3D; 2; \n    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; ||&#39;the Americas region.&#39;); \n WHEN &#39;ASIA&#39; THEN \n    SELECT count(*) \n    INTO country_count \n    FROM countries \n    WHERE region_id &#x3D; 3; \n    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Asia region.&#39;); \n WHEN &#39;MIDDLE EAST AND AFRICA&#39; THEN \n    SELECT count(*) \n    INTO country_count \n    FROM countries \n    WHERE region_id &#x3D; 4; \n    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Middle East and Africa region.&#39;); \n ELSE \n    DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); \n END CASE; \nEND; \n\n\nHow It WorksThere are two different types of CASE statements that can be used—those being the searched CASE and the simple CASE statement. The solution to this recipe demonstrates the simple CASE. For an example of a searched CASE statement, please see Recipe 3-3.\nThe simple CASE statement begins with the keyword CASE followed by a single expression called a selector. The selector is evaluated one time, and it can evaluate to any PL&#x2F;SQL type other than BLOB, BFILE, an object type, a record, or a collection type. The selector is followed by a series of WHEN clauses. The WHEN clauses are evaluated sequentially to determine whether the value of the selector equals the result from any of the WHEN clause expressions. If a match is found, then the corresponding WHEN clause is executed.\nThe CASE statement can include any number of WHEN clauses, and much like an IF statement, it can be followed with a trailing ELSE clause that will be executed if none of the WHEN expressions matches. If the ELSE clause is omitted, a predefined exception will be raised if the CASE statement does not match any of the WHEN clauses. The END CASE keywords end the statement.\n3.5. Looping Until a Specified Condition Is MetProblemYou want to loop through a set of statements until a specified condition evaluates to true.SolutionUse a simple LOOP statement along with an EXIT clause to define a condition that will end the iteration.The following example shows a simple LOOP that will print out each employee with a department_id equalto 90:\nDECLARE\nCURSOR emp_cur IS\nSELECT *\nFROM employees\nWHERE department_id &#x3D; 90;\nemp_rec employees%ROWTYPE;\n\nBEGIN\nOPEN emp_cur;\nLOOP\n  FETCH emp_cur into emp_rec;\n  IF emp_cur%FOUND THEN\n    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;-&#39;|| emp_rec.email);\n  ELSE\n    EXIT;\n  END IF;\nEND LOOP;\nCLOSE emp_cur;\nEND;\n\n\nAs you can see from the example, the cursor is opened prior to the start of the loop. Inside the loop,the cursor is fetched into emp_rec, and emp_rec is evaluated to see whether it contains anything using thecursor %FOUND attribute. If emp_cur%FOUND is FALSE, then the loop is exited using the EXIT keyword.How It WorksThe simple LOOP structure is very easy to use for generating a loop in your code. The LOOP keyword is usedto start the loop, and the END LOOP keywords are used to terminate it. Every simple loop must contain anEXIT or GOTO statement; otherwise, the loop will become infinite and run indefinitely.You can use a couple of different styles for the EXIT. When used alone, the EXIT keyword causes aloop to be terminated immediately, and control is passed to the first statement following the loop. Youcan use the EXIT-WHEN statement to terminate the loop based upon the evaluation of a condition after theWHEN statement. If the condition evaluates to TRUE, then the loop is terminated; otherwise, it willcontinue.The following example shows the same LOOP as the example in the solution, but instead of using anIF statement to evaluate the content of emp_rec, the EXIT-WHEN statement is used:\nDECLARE\nCURSOR emp_cur IS\nSELECT *\nFROM employees\nWHERE department_id &#x3D; 90;\nemp_rec employees%ROWTYPE;\nBEGIN\nOPEN emp_cur;\n LOOP \n FETCH emp_cur into emp_rec; \n EXIT WHEN emp_cur%NOTFOUND; \n      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39;-&#39; || emp_rec.email); \n END LOOP; \n CLOSE emp_cur; \nEND; \nYou can use a loop to iterate over any number of things including cursors or collections of data. Asyou will see in some of the coming recipes, different forms of loops work better in differentcircumstances. \n3.6. Iterating Cursor Results Until All Rows Have Been ReturnedProblemYou have created a cursor and retrieved a number of rows from the database. As a result, you want toloop through the results and do some processing on them.SolutionUse a standard FOR loop to iterate through the records. Within each iteration of the loop, process thecurrent record. The following code shows the use of a FOR loop to iterate through the records retrievedfrom the cursor and display each employee name and e-mail. Each iteration of the loop returns anemployee with the job_id of ‘ST_MAN’, and the loop will continue to execute until the cursor has beenexhausted.\nDECLARE \n CURSOR emp_cur IS \n SELECT * \n FROM employees \n WHERE job_id &#x3D; &#39;ST_MAN&#39;; \n emp_rec employees%ROWTYPE; \nBEGIN \n FOR emp_rec IN emp_cur LOOP \n DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || \n &#39; - &#39; || emp_rec.email); \n END LOOP; \nEND; \n\nHere are the results:Matthew Weiss - MWEISSAdam Fripp - AFRIPPPayam Kaufling - PKAUFLINShanta Vollman - SVOLLMANKevin Mourgos - KMOURGOSPL&#x2F;SQL procedure successfully completed\nAs you can see, the employee records that meet the specified criteria are displayed.\n3.7. Iterating Until a Condition Evaluates to FALSEProblemYou want to iterate over a series of statements until a specified condition no longer evaluates to TRUE.SolutionUse a WHILE statement to test the condition, and execute the series of statements if the conditionevaluates to TRUE; otherwise, skip the statements completely. The following example shows a WHILEstatement evaluating the current value of a variable and looping through until the value of the variablereaches ten. Within the loop, this variable is being multiplied by two and printing out its current value.\nDECLARE \n myValue NUMBER :&#x3D; 1; \nBEGIN \nWHILE myValue &lt; 10 LOOP \n DBMS_OUTPUT.PUT_LINE(&#39;The current value is: &#39; || myValue); \n myValue :&#x3D; myValue * 2; \n END LOOP;\nEND;\n\nHere are the results:The current value is: 1The current value is: 2The current value is: 4The current value is: 8PL&#x2F;SQL procedure successfully completed.The important thing to note in this example is that the value of myValue is increased with eachiteration of the loop as to eventually meet the condition specified in the WHILE loop.\nHow It WorksThe WHILE loop tests a condition at the top of the loop, and if it evaluates to TRUE, then the statements within the loop are executed, and control is returned to the start of the loop where the condition is tested again. If the condition does not evaluate to TRUE, the loop is bypassed, and control goes to the next statement after the END LOOP. If the condition never fails, then an infinite loop is formed, so it is important to ensure that the condition will eventually evaluate to FALSE. It is important to note that the statements in the loop will never be executed if the condition evaluates to FALSE during the first pass. This situation is different from the simple loop that alwaysiterates at least once because the EXIT condition is usually evaluated elsewhere in the loop. To ensure that a WHILE loop is always executed at least one time, you must ensure that the condition evaluates to TRUE at least once. One way to do this is to use a flag variable that is evaluated with each iteration of the loop. Set the flag equal to FALSE prior to starting the loop, and then set it to TRUE when a certain condition is met inside the loop. The following pseudocode depicts such a solution:\nBEGIN \n flag &#x3D; FALSE; \n WHILE flag &#x3D; TRUE LOOP \nPerform statements \n flag &#x3D; Boolean expression; \n END LOOP; \nEND; \nAs mentioned previously, the boolean expression that is assigned to the flag in this case musteventually evaluate to FALSE; otherwise, an infinite loop will occur.\n3.8.Bypassing the Current Loop IterationProblemIf a specified conditional statement evaluates to TRUE, you want to terminate the current loop iteration ofthe loop early and start the next iteration immediately.SolutionUse a CONTINUE statement along with a condition to end the current iteration. In the following example, a loop is used to iterate through the records in the employees table. The primary reason for the loop is to print out a list of employees who receive a salary greater than 15,000. If an employee does not receive more than 15,000, then nothing is printed out, and the loop continues to the next iteration.\nDECLARE \n    CURSOR emp_cur is \n    SELECT * \n    FROM employees; \n    emp_rec emp_cur%ROWTYPE; \nBEGIN \n    DBMS_OUTPUT.PUT_LINE(&#39;Employees with salary &gt; 15000: &#39;); \nOPEN emp_cur;\n LOOP \n FETCH emp_cur INTO emp_rec; \n EXIT WHEN emp_cur%NOTFOUND; \n IF emp_rec.salary &lt; 15000 THEN \n CONTINUE;\n ELSE \n    DBMS_OUTPUT.PUT_LINE(&#39;Employee: &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name); \n END IF; \n END LOOP; \n CLOSE emp_cur; \nEND; \n\nHere are some sample results:Employees with salary &gt; 15000:Employee: Steven KingEmployee: Neena KochharEmployee: Lex De HaanPL&#x2F;SQL procedure successfully completed.How It WorksYou can use the CONTINUE statement in any loop to unconditionally halt execution of the current iterationof the loop and move to the next. As shown in the solution, the CONTINUE statement is usuallyencompassed within some conditional statement so that it is invoked only when that certain conditionis met. \nYou can use the CONTINUE statement along with a label in order to jump to a specified point in theprogram. Rather than merely using CONTINUE to bypass the current loop iteration, specifying a label willallow you to resume programming in an outer loop. For more information regarding the use of theCONTINUE statement along with labels in nested loops, please see Recipe 3-13.As an alternative to specifying CONTINUE from within an IF statement, you can choose to write aCONTINUE WHEN statement. For example, the following two approaches yield identical results: \n IF team_rec.total_points &lt; 10 THEN \n CONTINUE; \nor \n CONTINUE WHEN rec.total_points &lt; 10; \n\nUsing the CONTINUE WHEN format, the loop will stop its current iteration if the condition in the WHENclause is met. Otherwise, the iteration will ignore the statement altogether.\n3.9. Iterating a Fixed Number of TimesProblemYou are interested in executing the contents of a loop a specified number of times. For example, you areinterested in executing a loop ten times, and you need to number each line of output in the range by thecurrent loop index.SolutionWrite a FOR loop. Use a variable to store the current index of the loop while looping through a range ofnumbers from one to ten in ascending order. The following lines of code will iterate ten times through aloop and print out the current index in each pass:\nBEGIN \n FOR idx IN 1..10 LOOP \n DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx); \n END LOOP; \nEND;\nHere is the result: \nThe current index is: 1 \nThe current index is: 2 \nThe current index is: 3 \nThe current index is: 4 \nThe current index is: 5 \nThe current index is: 6 \nThe current index is: 7 \nThe current index is: 8 \nThe current index is: 9\nThe current index is: 10\nPL&#x2F;SQL procedure successfully completed.How It WorksThe FOR loop will increment by one through the given range for each iteration until it reaches the end.The loop is opened using the keyword FOR, followed by a variable that will be used as the index for theloop. Following the index variable is the IN keyword, which is used to signify that the index variableshould increment one by one through the given range, which is listed after the IN keyword. The loop isterminated using the END LOOP keywords.Each statement contained within the loop is executed once for each iteration of the loop. The indexvariable can be used within the loop, but it cannot be changed. As shown in the solution, you may usethe index for printing purposes, and it is oftentimes used in calculations as well.The REVERSE keyword should be placed directly after the IN keyword and before the range that youspecify. The REVERSE keyword has no effect when working with cursors. If you need to iterate throughcursor results in a specific order, then specify an ORDER BY clause in your SELECT statement. \nIterating in Increments Other Than One3-11. Iterating in Increments Other Than OneProblemRather than iterating through a range of numbers one at a time, you want to increment by some othervalue. For example, you might want to increment through even values such as 2, 4, 6, and so forth.SolutionMultiply the loop index by two (or by whatever other multiplier you need) to achieve the effect ofincrementing through all even numbers. As you can see in the following example, an even number isalways generated when the index is multiplied by two: \nBEGIN \n FOR idx IN 1..5 LOOP \n DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx*2); \n END LOOP; \nEND;\nHere is the result:The current index is: 2The current index is: 4The current index is: 6The current index is: 8The current index is: 10PL&#x2F;SQL procedure successfully completed.How It WorksUnlike some other languages, PL&#x2F;SQL does not include a STEP clause that can be used while looping. Towork around that limitation, you will need to write your own stepping algorithm. In the solution to thisrecipe, you can see that the algorithm was quite easy; you simply multiply the index by two to achievethe desired result. In this solution, assigning the range of 1..5 as the index produces the effect of iteratingthrough all even numbers from 2..10 when the current index is multiplied by two.Using similar techniques, you can increment through ranges of numbers in various intervals.However, sometimes this can become troublesome if you are attempting to step by anything other thaneven numbers. You can see an example of this in the next recipe.\n3.12. Stepping Through a Loop Based on Odd-Numbered IncrementsProblemRather than iterating through a range of numbers by even increments, you prefer to loop through therange using odd increments.SolutionUse the built-in MOD function to determine whether the current index is odd. If it is odd, then print outthe value; otherwise, continue to the next iteration. The following example shows how to implement thissolution:\nBEGIN \n FOR idx IN 1..10 LOOP \n IF MOD(idx,2) !&#x3D; 0 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx); \n END IF; \n END LOOP; \nEND; \n\nResults:The current index is: 1The current index is: 3The current index is: 5The current index is: 7The current index is: 9PL&#x2F;SQL procedure successfully completed.How It WorksThe solution depicts one possible workaround for a STEP replacement. Using the MOD function todetermine whether a number is odd works quite well. The MOD function, otherwise known as the modulusfunction, is used to return the remainder from the division of the two numbers that are passed into thefunction. Therefore, this function is useful for determining even or odd numbers. In this case, if anyvalue is returned from MOD, then the number is assumed to be odd, and the statements within the IFstatement will be executed.Such a technique may be useful in the case of iterating through a collection of data such as a table. Ifyou want to grab every other record from the collection, then performing a stepping solution such as thisor the solution from Recipe 3-11 will allow you to achieve the desired result. You could easily use theresulting index from this technique as the index for a collection.\n3.13. Exiting an Outer Loop PrematurelyProblemYour code contains a nested loop, and you want the inner loop to have the ability to exit from both loopsand stop iteration completely.SolutionUse loop labels for both loops and then reference either loop within an EXIT statement by following theEXIT keyword with a loop label. The following example prints out a series of numbers. During eachiteration, the inner loop will increment until it reaches an odd number. At that point, it will pass controlto the outer loop again. The outer loop will be exited when the index for the inner loop is greater than orequal to the number ten. \nBEGIN \n &lt;&lt;outer&gt;&gt; for idx1 in 1 .. 10 loop \n &lt;&lt;inner&gt;&gt; for idx2 in 1 .. 10 loop \n dbms_output.put(idx2); \n exit inner when idx2 &gt; idx1 * 2; \n exit outer when idx2 &#x3D; 10; \n END LOOP; \n DBMS_OUTPUT.NEW_LINE; \n END LOOP; \n DBMS_OUTPUT.NEW_LINE; \nEND;\nResults:12312345123456712345678912345678910PL&#x2F;SQL procedure successfully completed.How It WorksAny loop in PL&#x2F;SQL can be labeled using a similar style to labels for code blocks. The label can be anyvalid identifier surrounded by angle brackets before the loop, and optionally the identifier can be placedat the end after the END LOOP clause. The result of such a labeling mechanism is that you will have adistinct start and end to the loops and more control over loop execution.In the solution to this recipe, the label helps identify the outer loop so that it can be terminated withthe EXIT clause. Without a label, the EXIT will terminate the innermost FOR loop. However, the label canalso be used to help identify the loop’s index. In the solution, this is not necessary because the outer loopindex was named differently than the inner loop index. If both indexes were named the same, then youcould use the loop label along with the index name to fully qualify the index. The following exampledemonstrates this technique:\nBEGIN\n&lt;&lt;outer&gt;&gt; FOR idx IN 1 .. 10 LOOP\n&lt;&lt;inner&gt;&gt; FOR idx IN 1 .. 10 LOOP\n  DBMS_OUTPUT.PUT(inner.idx);\nEXIT inner WHEN inner.idx &gt; outer.idx * 2;\nEXIT outer WHEN inner.idx &#x3D; 10;\nEND LOOP;\n  DBMS_OUTPUT.NEW_LINE;\nEND LOOP;\n  DBMS_OUTPUT.NEW_LINE;\nEND;\n\nThis code will display the same results as the example given in the solution to this recipe. The onlydifference is that in this example the index name is the same in both the inner and outer loops. Analternative technique to end the current iteration of an inner loop is to use the CONTINUE statement. ACONTINUE statement can reference the label of a loop that is within the same scope. Therefore, an innerloop can exit its current iteration and proceed to an outer loop, as the following example demonstrates:\n\nBEGIN\n&lt;&lt;outer&gt;&gt; for idx1 in 1 .. 10 loop\n&lt;&lt;inner&gt;&gt; for idx2 in 1 .. 10 loop\ndbms_output.put(idx2);\nexit inner when idx2 &gt; idx1 * 2;\nexit outer when idx2 &#x3D; 10;\nEND LOOP;\nCONTINUE outer;\nEND LOOP;\nDBMS_OUTPUT.NEW_LINE;\nEND;\nIn this example, the same code that is used in the solution to this recipe is rewritten to incorporate aCONTINUE statement. This statement is used to move control of execution back to the outer loop. Whenthe CONTINUE statement is reached, execution of the current loop is immediately halted, and processingcontinues to the loop designated by the label.\n3.14. Jumping to a Designated Location in CodeProblemYou want your code to stop executing and jump to a different, designated location.SolutionUse a GOTO statement along with a label name to cause code execution to jump into the position wherethe label is located.The following example shows the GOTO statement in action. The user is prompted to enter a numericvalue, and that value is then evaluated to determine whether it is greater than ten. In either case, amessage is printed, and then the code jumps to the end_msg label. If the number entered is a negativenumber, then the code jumps to the bad_input label where an error message is printed.\nDECLARE\n in_number number :&#x3D; 0; \nBEGIN \n in_number :&#x3D; &#39;&amp;input_number&#39;; \n IF in_number &gt; 10 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The number you entered is greater than ten&#39;); \n GOTO end_msg; \n ELSIF in_number &lt;&#x3D; 10 and in_number &gt; 0 THEN \n DBMS_OUTPUT.PUT_LINE(&#39;The number you entered is less than or equal to ten&#39;); \n GOTO end_msg; \n ELSE \n -- Entered a negative number \n GOTO bad_input; \n END IF; \n &lt;&lt; bad_input &gt;&gt; \n DBMS_OUTPUT.PUT_LINE(&#39;Invalid input. No negatives allowed.&#39;); \n &lt;&lt; end_msg &gt;&gt; \n DBMS_OUTPUT.PUT_LINE(&#39;Thank you for playing..&#39;); \nEND; \nHow It WorksThe GOTO statement is used to branch code unconditionally. Code can be branched to any label withinthe same scope as the GOTO. In the solution, the GOTO statement causes the code to branch to a parentcode block. You could just as easily branch to a loop within the current or outer block. However, youcannot branch to a label within a subblock, IF statement, or LOOP. \nYou should use this statement sparingly because arbitrary branching makes code difficult to read. Useconditional statements to branch whenever possible, because that’s why they were put into thelanguage. As you can see from the solution, the same code could have been written printing the “Invalidnumber” message within the ELSE clause. There are usually better alternatives to using GOTO. \n","dateCreated":"2022-10-19T23:51:33+08:00","dateModified":"2022-11-02T23:09:37+08:00","datePublished":"2022-10-19T23:51:33+08:00","description":"摘要: 其实这个讲PLSQL有点基础","headline":"Oracle PLSQL Recipes","image":[null,"https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://simonteo58.github.io/2022/10/19/oracle/Oracle_PLSQL_Recipes/"},"publisher":{"@type":"Organization","name":"kirkzhang","sameAs":["https://github.com/SimonTeo58","https://stackoverflow.com/users/11289672/simon-teo","https://twitter.com/shiming_kirk","https://www.linkedin.com/in/kirk-zhang-424935235/","zxc741208584@qq.com"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://simonteo58.github.io/2022/10/19/oracle/Oracle_PLSQL_Recipes/","thumbnailUrl":"https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"}</script>
    <meta name="description" content="摘要: 其实这个讲PLSQL有点基础">
<meta property="og:type" content="blog">
<meta property="og:title" content="Oracle PLSQL Recipes">
<meta property="og:url" content="https://simonteo58.github.io/2022/10/19/oracle/Oracle_PLSQL_Recipes/index.html">
<meta property="og:site_name" content="CoffeeMan">
<meta property="og:description" content="摘要: 其实这个讲PLSQL有点基础">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png">
<meta property="article:published_time" content="2022-10-19T15:51:33.289Z">
<meta property="article:modified_time" content="2022-11-02T15:09:37.641Z">
<meta property="article:author" content="kirkzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png">
<meta name="twitter:creator" content="@shiming_kirk">
    
        <link rel="publisher" href="https://plus.google.com/nil"/>
    
    
        
    
    
        <meta property="og:image" content="https://simonteo58.github.io/assets/images/avatar.jpg"/>
    
    
    
        <meta property="og:image" content="https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-y9io9e1ok9lpsmk4fyk7quzstdgr6eztu8x2xr6n9iikjgfjbcqqpobdlqy8.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CoffeeMan
        </a>
    </div>
    
        
            <a
                class="header-right-picture open-algolia-search"
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">kirkzhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/SimonTeo58"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/11289672/simon-teo"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/shiming_kirk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/kirk-zhang-424935235/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/zxc741208584@qq.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    "
             style="background-image:url('https://user-images.githubusercontent.com/46363359/199011812-44a2e355-c72a-4252-bac9-37ecded0cb54.jpg');"
             data-behavior="2">
            
        </div>

            <div id="main" data-behavior="2"
                 class="hasCover
                        hasCoverMetaOut
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Oracle PLSQL Recipes
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-10-19T23:51:33+08:00">
	
		    Oct 19, 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/oracle/">oracle</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>摘要: 其实这个讲PLSQL有点基础</p>
<span id="more"></span>
<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-PL-x2F-SQL-Fundamentals"><span class="toc-text">1 PL&#x2F;SQL Fundamentals</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%88%9B%E5%BB%BAplsql%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">1.1 创建plsql代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%9C%A8plsql%E7%A7%8D%E6%89%A7%E8%A1%8Cplsql%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">1.2 在plsql种执行plsql代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-store-code-in-script"><span class="toc-text">1.3 store code in script</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%89%A7%E8%A1%8C%E4%BD%A0%E7%9A%84%E8%84%9A%E6%9C%AC"><span class="toc-text">1.4 执行你的脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%8E%A5%E5%8F%97%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5%E4%BB%8E%E9%94%AE%E7%9B%98%E4%B8%AD"><span class="toc-text">1.5 接受用户的输入从键盘中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Displaying-Results-in-SQL-Plus"><span class="toc-text">1.6 Displaying Results in SQL*Plus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Commenting-Your-Code"><span class="toc-text">1.7 Commenting Your Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-Referencing-a-Block-of-Code"><span class="toc-text">1.8 Referencing a Block of Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-Referring-to-Variables-from-Nested-Blocks"><span class="toc-text">1.9. Referring to Variables from Nested Blocks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-Ignoring-Substitution-Variables"><span class="toc-text">1.10. Ignoring Substitution Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-Changing-the-Substitution-Variable-Character"><span class="toc-text">1.11. Changing the Substitution Variable Character</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-Creating-a-Variable-to-Match-a-Database-Column-Type"><span class="toc-text">1.12. Creating a Variable to Match a Database Column Type</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E7%A1%80sql"><span class="toc-text">2.基础sql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Retrieving-a-Single-Row-from-the-Database"><span class="toc-text">2.1 Retrieving a Single Row from the Database</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Qualifying-Column-and-Variable-Names%EF%BC%88%E5%8F%98%E9%87%8F%E5%92%8C%E8%A1%A8%E5%88%97%E5%90%8D%E7%9B%B8%E5%90%8C"><span class="toc-text">2.2. Qualifying Column and Variable Names（变量和表列名相同)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Declaring-Variable-Types-That-Match-Column-Types"><span class="toc-text">2.3. Declaring Variable Types That Match Column Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record"><span class="toc-text">2.4. Returning Queried Data into a PL&#x2F;SQL Record</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Creating-Your-Own-Records-to-Receive-Query-Results"><span class="toc-text">2.5. Creating Your Own Records to Receive Query Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Looping-Through-Rows-from-a-Query"><span class="toc-text">2.6. Looping Through Rows from a Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Obtaining-Environment-and-Session-Information"><span class="toc-text">2.7. Obtaining Environment and Session Information</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Formatting-Query-Results"><span class="toc-text">2.8. Formatting Query Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-Updating-Rows-Returned-by-a-Query"><span class="toc-text">2.9. Updating Rows Returned by a Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-Updating-Rows-Returned-by-a-Cursor"><span class="toc-text">2.10. Updating Rows Returned by a Cursor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-Deleting-Rows-Returned-by-a-Cursor"><span class="toc-text">2.11. Deleting Rows Returned by a Cursor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-Performing-a-Transaction"><span class="toc-text">2.12. Performing a Transaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-Ensuring-That-Multiple-Queries-%E2%80%9CSee%E2%80%9D-the-Same-Data"><span class="toc-text">2.13. Ensuring That Multiple Queries “See” the Same Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-Executing-One-Transaction-from-Within-Another"><span class="toc-text">2.14. Executing One Transaction from Within Another</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-Finding-and-Removing-Duplicate-Table-Rows"><span class="toc-text">2.15. Finding and Removing Duplicate Table Rows</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Looping-and-Logic"><span class="toc-text">3. Looping and Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Choosing-When-to-Execute-Code"><span class="toc-text">3.1. Choosing When to Execute Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Choosing-Between-Two-Mutually-Exclusive-Conditions"><span class="toc-text">3-2. Choosing Between Two Mutually Exclusive Conditions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Evaluating-Multiple-Mutually-Exclusive-Conditions"><span class="toc-text">3.3. Evaluating Multiple Mutually Exclusive Conditions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Driving-from-an-Expression-Having-Multiple-Outcomes"><span class="toc-text">3.4 Driving from an Expression Having Multiple Outcomes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Looping-Until-a-Specified-Condition-Is-Met"><span class="toc-text">3.5. Looping Until a Specified Condition Is Met</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Iterating-Cursor-Results-Until-All-Rows-Have-Been-Returned"><span class="toc-text">3.6. Iterating Cursor Results Until All Rows Have Been Returned</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Iterating-Until-a-Condition-Evaluates-to-FALSE"><span class="toc-text">3.7. Iterating Until a Condition Evaluates to FALSE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-Bypassing-the-Current-Loop-Iteration"><span class="toc-text">3.8.Bypassing the Current Loop Iteration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Iterating-a-Fixed-Number-of-Times"><span class="toc-text">3.9. Iterating a Fixed Number of Times</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterating-in-Increments-Other-Than-One"><span class="toc-text">Iterating in Increments Other Than One</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-Stepping-Through-a-Loop-Based-on-Odd-Numbered-Increments"><span class="toc-text">3.12. Stepping Through a Loop Based on Odd-Numbered Increments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-Exiting-an-Outer-Loop-Prematurely"><span class="toc-text">3.13. Exiting an Outer Loop Prematurely</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-Jumping-to-a-Designated-Location-in-Code"><span class="toc-text">3.14. Jumping to a Designated Location in Code</span></a></li></ol></li></ol>


<h1 id="1-PL-x2F-SQL-Fundamentals"><a href="#1-PL-x2F-SQL-Fundamentals" class="headerlink" title="1 PL&#x2F;SQL Fundamentals"></a>1 PL&#x2F;SQL Fundamentals</h1><h2 id="1-1-创建plsql代码块"><a href="#1-1-创建plsql代码块" class="headerlink" title="1.1 创建plsql代码块"></a>1.1 创建plsql代码块</h2><p>如和创建一个可以执行的plsql代码块？</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- demo 1
begin
  -- 中间写代码
end;

-- demo 2


declare

-- 定义变量

begin 
 -- 业务逻辑
end;</code></pre>

<p>在实际的开发当中，这些代码块会进行嵌套，第一层代码块定义的变量，内层的代码块也可以直接使用</p>
<h2 id="1-2-在plsql种执行plsql代码块"><a href="#1-2-在plsql种执行plsql代码块" class="headerlink" title="1.2 在plsql种执行plsql代码块"></a>1.2 在plsql种执行plsql代码块</h2><p>如何在sqlplus中执行plsql代码?</p>
<p>登录sqlplus就可以直接输入自己的代码，然后<code>end;</code>结束代码块，并且接着输入<code>/</code>,这时候sqlplus解释器就可以执行代码了。<br>但是有一点需要明确，如果你的代码块是以<code>declare</code>开头的，那么就会直接输出到屏幕</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">sql&gt; begin
DBMS_OUTPUT.put_line(&quot;hello world&quot;)
end;
&#x2F;</code></pre>

<p>但是如果你想创建package,function,procedure,可以使用如下语句，方便后面的调用</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; CREATE OR REPLACE PROCEDURE hello_world AS 
 BEGIN 
 DBMS_OUTPUT.PUT_LINE(&#39;Hello World&#39;); 
 END; 
 &#x2F; </code></pre>

<h2 id="1-3-store-code-in-script"><a href="#1-3-store-code-in-script" class="headerlink" title="1.3 store code in script"></a>1.3 store code in script</h2><p>如果你想通过sql脚本执行代码，该如何运行？</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SET SERVEROUTPUT ON;
DECLARE 
 counter NUMBER;
BEGIN 
  FOR counter IN REVERSE 0..10 LOOP 
  DBMS_OUTPUT.PUT_LINE (counter); 
  END LOOP; 
END;
&#x2F;</code></pre>
<p>你可以保存你的plsql代码在脚本里,重要一步是要保证你的文件扩展名是<code>.sql</code><br>SQL Developer supports a number of additionalextensions for more specific types of PL&#x2F;SQL. </p>
<h2 id="1-4-执行你的脚本"><a href="#1-4-执行你的脚本" class="headerlink" title="1.4 执行你的脚本"></a>1.4 执行你的脚本</h2><p>登录sqlplus，然后跳(Traverse)到你的脚本目录</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">@绝对路径
@相对路径
sqlplus username&#x2F;password@database my_stored_script.sql </code></pre>

<h2 id="1-5-接受用户的输入从键盘中"><a href="#1-5-接受用户的输入从键盘中" class="headerlink" title="1.5 接受用户的输入从键盘中"></a>1.5 接受用户的输入从键盘中</h2><p>sqlplus使用&amp;符号来接受来自键盘的输入</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 emp_count NUMBER; 
BEGIN 
 SELECT count(*) 
 INTO emp_count 
 FROM employees 
 WHERE department_id &#x3D; &amp;department_id; 
END; </code></pre>

<p>但是如果你想从键盘接受一个输入，但是后面又想继续使用，则可以使用如下方法</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 emp_count NUMBER; 
BEGIN 
  SELECT count(*) 
  INTO emp_count 
  FROM employees 
  WHERE department_id &#x3D; &amp;&amp;department_id; 
  DBMS_OUTPUT.PUT_LINE(&#39;The employee count is: &#39; || emp_count || 
  &#39; for the department with an ID of: &#39; || &amp;department_id); 
END;
</code></pre>

<p>另外还有一种方法就是定义变量来承接从键盘来的输入,但是要注意这个变量定义的类型,如果是numeric类型的，如果是varchar2类型则需要用<code>单引号</code>,见如下代码</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
    first varchar2(20); 
    last varchar2(25); 
    emp_last VARCHAR2(25) :&#x3D; &#39;&amp;last_name&#39;; 
    emp_count NUMBER; 
BEGIN 
    SELECT count(*) 
    INTO emp_count 
    FROM employees 
    WHERE last_name &#x3D; emp_last; 
 IF emp_count &gt; 1 THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;More than 1 employee exists with that name.&#39;); 
 ELSE 
    SELECT first_name, last_name 
    INTO first, last 
    FROM employees 
    WHERE last_name &#x3D; emp_last; 
    DBMS_OUTPUT.PUT_LINE(&#39;The matching employee is: &#39; || 
    first || &#39; &#39; || last); 
 END IF; 
EXCEPTION 
    WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;Please enter a different last name.&#39;); 
END; </code></pre>

<h2 id="1-6-Displaying-Results-in-SQL-Plus"><a href="#1-6-Displaying-Results-in-SQL-Plus" class="headerlink" title="1.6 Displaying Results in SQL*Plus"></a>1.6 Displaying Results in SQL*Plus</h2><p><code>SET SERVEROUTPUT ON</code> is issued, then the default buffer size is 20,000 bytes.<br>Any content that surpasses that size will be cut off. To increase the buffer, simply set the size of buffer<br>you’d like to use when turning the SERVEROUTPUT on: </p>
<h2 id="1-7-Commenting-Your-Code"><a href="#1-7-Commenting-Your-Code" class="headerlink" title="1.7 Commenting Your Code"></a>1.7 Commenting Your Code</h2><h2 id="1-8-Referencing-a-Block-of-Code"><a href="#1-8-Referencing-a-Block-of-Code" class="headerlink" title="1.8 Referencing a Block of Code"></a>1.8 Referencing a Block of Code</h2><p>如何引用一个代码块?</p>
<p>给一个代码块添加label标签,比如下面的代码</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
&lt;&lt;dept_block&gt;&gt;
DECLARE 
  dept_name varchar2(30); 
BEGIN 
  SELECT department_name 
  INTO dept_name 
  FROM departments 
  WHERE department_id &#x3D; 230;
  DBMS_OUTPUT.PUT_LINE(dept_name);
END dept_block;
</code></pre>

<h2 id="1-9-Referring-to-Variables-from-Nested-Blocks"><a href="#1-9-Referring-to-Variables-from-Nested-Blocks" class="headerlink" title="1.9. Referring to Variables from Nested Blocks"></a>1.9. Referring to Variables from Nested Blocks</h2><p>如果code block是嵌套关系那么该如何使用具有相同名字的变量,可以使用label来区分不同的变量名字</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;outer_block&gt;&gt;
DECLARE
  mgr_id NUMBER(6) :&#x3D; &#39;&amp;current_manager_id&#39;;
  dept_count number :&#x3D; 0;
BEGIN

SELECT count(*)
    INTO dept_count 
    FROM departments 
    WHERE manager_id &#x3D; outer_block.mgr_id;

 IF dept_count &gt; 0 THEN 
    &lt;&lt;inner_block&gt;&gt; 
    DECLARE 
      dept_name VARCHAR2(30); 
      mgr_id NUMBER(6):&#x3D; &#39;&amp;new_manager_id&#39;; 
    BEGIN 
    SELECT department_name 
    INTO dept_name 
    FROM departments 
    WHERE manager_id &#x3D; outer_block.mgr_id; 

    UPDATE departments 
    SET manager_id &#x3D; inner_block.mgr_id 
    WHERE manager_id &#x3D; outer_block.mgr_id; 
    DBMS_OUTPUT.PUT_LINE 
    (&#39;Department manager ID has been changed for &#39; || dept_name); 
    END inner_block; 
 ELSE 
    DBMS_OUTPUT.PUT_LINE(&#39;There are no departments listed for the manager&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;There are no departments listed for the manager&#39;); 
END outer_block; </code></pre>

<p>但是inner block创建的变量，outside block是不会读取到的,外部块变量在内部块中是可见的，而不需要完全限定名称，并且不需要块标签</p>
<h2 id="1-10-Ignoring-Substitution-Variables"><a href="#1-10-Ignoring-Substitution-Variables" class="headerlink" title="1.10. Ignoring Substitution Variables"></a>1.10. Ignoring Substitution Variables</h2><p>转义那些sqlplus使用的特殊字符</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; SET ESCAPE &#39;\&#39; 
SQL&gt; INSERT INTO DEPARTMENTS VALUES( 
  departments_seq.nextval, 
  &#39;Shipping \&amp; Receiving&#39;, 
  null, 
 null);</code></pre>

<p>还有另外一种</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; SET DEFINE OFF
INSERT INTO DEPARTMENTS VALUES( 
departments_seq.nextval, 
&#39;Importing &amp; Exporting&#39;, 
null, 
null); 
</code></pre>

<h2 id="1-11-Changing-the-Substitution-Variable-Character"><a href="#1-11-Changing-the-Substitution-Variable-Character" class="headerlink" title="1.11. Changing the Substitution Variable Character"></a>1.11. Changing the Substitution Variable Character</h2><p>如果你对改变替换变量符号(&amp;)为其他的符号</p>
<p>可以使用<code>set define ^</code>, 你也可以使用任意其他的符号来替换</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; SET DEFINE ^
SQL&gt; SELECT department_name 
     FROM departments 
     WHERE department_id &#x3D; ^dept_id;</code></pre>

<h2 id="1-12-Creating-a-Variable-to-Match-a-Database-Column-Type"><a href="#1-12-Creating-a-Variable-to-Match-a-Database-Column-Type" class="headerlink" title="1.12. Creating a Variable to Match a Database Column Type"></a>1.12. Creating a Variable to Match a Database Column Type</h2><p>如果向查数据库中某一个表的数据，该如何将查询结果赋值给变量呢？<br>可以使用<code>%type</code>关键字,会将一列的数据赋值给变量,而<code>%rowtype</code>则是返回一列的数据给变量</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
DECLARE
 dept_name departments.department_name%TYPE; 
 dept_id NUMBER(6) :&#x3D; &amp;department_id; 
BEGIN 
 SELECT department_name 
 INTO dept_name 
 FROM departments 
 WHERE department_id &#x3D; dept_id; 
 DBMS_OUTPUT.PUT_LINE(&#39;The department with the given ID is: &#39; || dept_name); 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No department for the given ID&#39;); 
END;</code></pre>

<h1 id="2-基础sql"><a href="#2-基础sql" class="headerlink" title="2.基础sql"></a>2.基础sql</h1><p><img src="https://user-images.githubusercontent.com/46363359/199057521-a7d91465-6cdc-4eba-9b15-6ed482995d71.png" alt="图文无关,在写文章时听张学友的歌"></p>
<h2 id="2-1-Retrieving-a-Single-Row-from-the-Database"><a href="#2-1-Retrieving-a-Single-Row-from-the-Database" class="headerlink" title="2.1 Retrieving a Single Row from the Database"></a>2.1 Retrieving a Single Row from the Database</h2><p><strong>problem</strong></p>
<p>You are interested in returning one row from a database table via a query that searches for an exact<br>match.</p>
<p><strong>solution 1</strong><br>你可以使用<code>select ... into ...</code>语法</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
    first VARCHAR2(20);  -- varchar2(20)一定是要兼容的数据库表字段的
    last VARCHAR2(25); 
    email VARCHAR2(25); 
BEGIN 
    SELECT first_name, last_name, email 
    INTO first, last, email 
    FROM employees 
    WHERE employee_id &#x3D; 100; 
    DBMS_OUTPUT.PUT_LINE( 
    &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); 
EXCEPTION 
WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given ID&#39;); 
WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE(&#39;More than one employee matches the given ID&#39;); 
END; </code></pre>

<p><strong>solution 2</strong></p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR emp_cursor IS 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE employee_id &#x3D; &amp;emp_id; 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 OPEN emp_cursor; 
 FETCH emp_cursor INTO first, last, email; 
 IF emp_cursor%NOTFOUND THEN 
      RAISE NO_DATA_FOUND; 
 ELSE 
 -- Perform second fetch to see if more than one row is returned 
    FETCH emp_cursor INTO first, last, email; 
    IF emp_cursor%FOUND THEN 
      RAISE TOO_MANY_ROWS; 
    ELSE 
      DBMS_OUTPUT.PUT_LINE( 
      &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email); 
      END IF;
 END IF; 
CLOSE emp_cursor; 
</code></pre>

<p><strong>how it works</strong></p>
<p>solution 1: One is to issue a SELECT…INTO statement,which is a statement designed to return just one row.<br>The other approach is to open a cursor, fetch the  one row, and close the cursor<br>solution 2: We keep an open mind on that point. Consider that if youare expecting exactly one row to be<br>returned, getting multiple rows back represents an exception case that you must somehow deal with.<br>The cursor-based solution makes it easy to simply ignore that exception case, but ignoring a condition<br>that you do not expect to occur does not change the fact that it has occurred. Although a cursor is used,<br>the cases where no data is returned or where too many rows are returnedgiven the user-supplied EMPLOYEE_ID<br>still remain a reality. However, since cursors are specifically designed to deal with zero rows or more<br>than one row coming back from a query, no exceptions will be raised if these situations occur. For this reason,<br>Solution #2 contains some conditional logic that is used to manually raise the desired exceptions.In the event that the user supplies the block with an invalid EMPLOYEE_ID, the cursor will not fetch any data. The %NOTFOUND attribute of the cursor will be checked to see whether the cursor successfully fetched data. If not, then the NO_DATA_FOUND exception is raised. If the cursor is successful in retrieving data, then a second FETCH statement is issued to see whether more than<br>one row will be returned. If more than one row is returned, then the TOO_MANY_ROWS exception is raised;<br>otherwise, the expected output is displayed. In any event, the output that is displayed using either of the<br>solutions will be the same whether successful or not.</p>
<h2 id="2-2-Qualifying-Column-and-Variable-Names（变量和表列名相同"><a href="#2-2-Qualifying-Column-and-Variable-Names（变量和表列名相同" class="headerlink" title="2.2. Qualifying Column and Variable Names（变量和表列名相同)"></a>2.2. Qualifying Column and Variable Names（变量和表列名相同)</h2><p><strong>Problem</strong><br>You have a variable and a column sharing the same name. You want to refer to both in the same SQL<br>statement.<br>For example, you decide that you’d like to search for records where LAST_NAME is not equal to a last<br>name that is provided by a user via an argument to a procedure call. Suppose you have declared a<br>variable LAST_NAME, and you want to alter the query to read as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SELECT first_name, last_name, email
 INTO first, last, email 
 FROM employees 
WHERE last_name &#x3D; last_name; </code></pre>
<p>How does PL&#x2F;SQL know which LAST_NAME you are referring to since both the table column name and<br>the variable name are the same? You need a way to differentiate your references. </p>
<p><strong>Solution</strong><br>You can use the dot notation to fully qualify the local variable name with the procedure name so that<br>PL&#x2F;SQL can differentiate between the two. The altered query, including the fully qualified<br>procedure_name.variable solution, would read as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE retrieve_emp_info(last_name IN VARCHAR2) AS 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 SELECT first_name, last_name, email 
 INTO first, last, email 
 FROM employees 
 WHERE last_name &#x3D; retrieve_emp_info.last_name; 
 DBMS_OUTPUT.PUT_LINE( 
 &#39;Employee Information for ID: &#39; || first || &#39; &#39; || last_name || &#39; - &#39; || email); 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name &#39; || last_name); 
END; </code></pre>

<p><strong>How It Works</strong></p>
<p>PL&#x2F;SQL name resolution(方法) becomes very important in circumstances such as these, and by fully qualifying<br>the names, you can be sure that your code will work as expected. The solution used dot notation to fully<br>qualify the variable name. </p>
<p>The column name could have been qualified with the table name, as in EMPLOYEES.LAST_NAME.<br>However, there’s no need to qualify the column name in this case. Because the reference occurs within a<br>SELECT, the closest resolution for LAST_NAME becomes the table column of that name. So, in this particular<br>case, it is necessary only to qualify references to variable names in the enclosing PL&#x2F;SQL block. </p>
<p>If you are executing a simple BEGIN…END block, then you also have the option of fully qualifying the<br>variable using the dot notation along with the block label. For the purposes of this demonstration, let’s<br>say that the code block shown in the solution was labeled &lt;<emp_info>&gt;. You could then fully qualify a<br>variable named description as follows: </p>
<pre class="language-text" data-language="text"><code class="language-text">side note:
</code></pre>

<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;emp_info&gt;&gt;
DECLARE 
 last_name VARCHAR2(25) :&#x3D; &#39;Fay&#39;; 
 first VARCHAR2(20); 
 last VARCHAR2(25); 
 email VARCHAR2(25); 
BEGIN 
 SELECT first_name, last_name, email 
 INTO first, last, email 
 FROM employees 
 WHERE last_name &#x3D; emp_info.last_name; 
END; </code></pre>

<p>In this example, the LAST_NAME that is declared in the code block is used within the SELECT..INTO<br>query, and it is fully qualified with the code block label.</p>
<text style="font-family:Courier New;color:red">

<p>summary: </br></p>
<ol>
<li>while code block contain same variable name as parameter, we could use “procedure”(including package name i though) name qualify parameter name at where clause statement.</li>
<li>actualy you could use table name qualify parameter name in code block, but no more works on it,due to in your select statement,<br>it had been qualified by table name.</li>
<li>and so on , if you use label on your code block, as case shown above</li>
</ol>
</text>

<h2 id="2-3-Declaring-Variable-Types-That-Match-Column-Types"><a href="#2-3-Declaring-Variable-Types-That-Match-Column-Types" class="headerlink" title="2.3. Declaring Variable Types That Match Column Types"></a>2.3. Declaring Variable Types That Match Column Types</h2><p><strong>Problem</strong><br>You want to declare some variables in your code block that match the same datatypes as some columns<br>in a particular table. If the datatype on one of those columns changes, you’d like the code block to<br>automatically update the variable type to match that of the updated column</p>
<p><strong>Note</strong><br>Sharp-eyed readers will notice that we cover this problem redundantly in Chapter 1. We cover this<br>problem here as well, because the solution is fundamental to working in PL&#x2F;SQL, especially to working with SQL in<br>PL&#x2F;SQL. We don’t want you to miss what we discuss in this recipe. It is that important.</p>
<p><strong>Solution</strong><br>Use the <code>%TYPE</code> attribute(n.属性) on table columns to identify(v.确定) the types of data that will be returned into your local variables. Instead of providing a hard-coded datatype for a variable, append %TYPE to the database column name. Doing so will apply the datatype from the specified column to the variable you are declaring.</p>
<p>In the following example, the same <code>SELECT INTO</code> query is issued, as in the previous problem, to retrieve an employee record from the database. However, in this case, the variables are declared using the <code>%TYPE</code> attribute rather than designating a specified datatype for each.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
  first   employees.first_name%TYPE;
  last    employees.last_name%TYPE;
  email   employees.email%TYPE;
BEGIN 
SELECT 
  first_name, 
  last_name, 
  email INTO first, last, email 
FROM 
  employees 
WHERE 
  employee_id &#x3D; &amp; emp_id;
  DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || first || &#39; &#39; || last || &#39; - &#39; || email);
EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;No matching employee was found, please try again.&#39;);
WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&#39;An unknown error has occured, please try again.&#39;);
END;</code></pre>

<p>As you can see from the solution, the code block looks essentially the same as the one in the previous recipe. The only difference is that here the <code>%TYPE</code> attribute of each database column is being used in order to declare your local variable types.</p>
<p><strong>How It Works</strong><br>The <code>%TYPE</code> attribute can become a significant time-saver and savior for declaring variable types, especially if the underlying database column types are subject(会发生变化) to change. This attribute enables the local variable to assume the same datatype of its corresponding database column type at runtime. Retrieving several columns into local application variables can become tedious(<code>沉闷的</code>) if you need to continually verify that the datatypes of each variable are the same as those of the columns whose data they will consume.The<code>%TYPE</code> attribute can be used when defining variables, constants, fields, and parameters. Using <code>%TYPE</code> assures(<code>保证</code>) that the variables you declare will always remain synchronized with the datatypes of their corresponding columns.</p>
<text style="font-family:Courier New;color:red">
summary: </br>
at all above explained that we could use `%TYPE` attribute to define variable which the same as table datatype
</text>

<h2 id="2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record"><a href="#2-4-Returning-Queried-Data-into-a-PL-x2F-SQL-Record" class="headerlink" title="2.4. Returning Queried Data into a PL&#x2F;SQL Record"></a>2.4. Returning Queried Data into a PL&#x2F;SQL Record</h2><p><strong>Problem</strong><br>Instead of retrieving only a select few columns via a database query, you’d rather return the entire<br>matching row. It can be a time-consuming task to replicate each of the table’s columns in your<br>application by creating a local variable for each along with selecting the correct datatypes. Although you<br>can certainly make use of the <code>%TYPE</code> attribute while declaring the variables, you’d rather retrieve the<br>entire row into a single object. Furthermore, you’d like the object that the data is going to be stored into<br>to have the ability to assume the same datatypes for each of the columns being returned just as you<br>would by using the <code>%TYPE</code> attribute.<br><strong>Solution</strong><br>Make use of the <code>%ROWTYPE</code> attribute for the particular database table that you are querying. The <code>%ROWTYPE</code><br>attribute returns a record type that represents a database row from the specified table. For instance, the<br>following example demonstrates how the %ROWTYPE attribute can store an entire employee table row for a<br>cursor: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 CURSOR emp_cur IS 
 SELECT * 
 FROM employees 
 WHERE employee_id &#x3D; &amp;emp_id; 
 -- Declaring a local variable using the ROWTYPE attribute 
 -- of the employees table 
 emp_rec employees%ROWTYPE; 
BEGIN 
 OPEN emp_cur; 
 FETCH emp_cur INTO emp_rec; 
 IF emp_cur%FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Employee Information for ID: &#39; || emp_rec.first_name || &#39; &#39; || 
 emp_rec.last_name || &#39; - &#39; || emp_rec.email); 
 ELSE 
  DBMS_OUTPUT.PUT_LINE(&#39;No matching employee for the given ID&#39;);
 END IF; 
 CLOSE emp_cur; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the given emp ID’); 
END; 
</code></pre>

<p><strong>How It Works</strong><br>The <code>%ROWTYPE</code> attribute represents an entire database table row as a record type. Each of the<br>corresponding table columns is represented within the record as a variable, and each variable in the<br>record inherits its type from the respective table column.<br>Using the <code>%ROWTYPE</code> attribute offers several advantages to declaring each variable individually. For<br>starters, declaring a single record type is much more productive than declaring several local variables to<br>correspond to each of the columns of a table. Also, if any of the table columns’ datatypes is ever<br>adjusted, then your code will not break because the <code>%ROWTYPE</code> attribute works in much the same manner<br>as the <code>%TYPE</code> attribute of a column in that it will automatically maintain the same datatypes as the<br>corresponding table columns. Therefore, if a column with a type of <code>VARCHAR2(10)</code> is changed to<br><code>VARCHAR2(100)</code>, that change will ripple(vt.在…上形成波痕) through into your record definition.<br>Using <code>%ROWTYPE</code> also makes your code much easier to read because you are not littering(n.乱丢废物) local<br>variables throughout. Instead, you can use the dot notation to reference each of the different columns<br>that the record type returned by <code>%ROWTYPE</code> consists of. For instance, in the solution, the <code>first_name</code>,<br><code>last_name</code>, and <code>email</code> columns are referenced from the <code>emp_rec</code> record type. </p>
<h2 id="2-5-Creating-Your-Own-Records-to-Receive-Query-Results"><a href="#2-5-Creating-Your-Own-Records-to-Receive-Query-Results" class="headerlink" title="2.5. Creating Your Own Records to Receive Query Results"></a>2.5. Creating Your Own Records to Receive Query Results</h2><p><strong>Problem</strong><br>You want to query the database, return several columns from one or more tables, and store them into<br>local variables of a code block for processing. Rather than placing the values of the columns into<br>separate variables, you want to create a single variable that contains all the values.<br><text style="font-family:Courier New;color:red"><br>summary: </br><br>return several columns from one or more tables.<br></text></p>
<p><strong>Solution</strong><br>Create a database RECORD containing variables to hold the data you want to retrieve from the database.<br>Since a RECORD can hold multiple variables of different datatypes, they work nicely for grouping data that<br>has been retrieved as a result of a query.<br>In the following example, the database is queried for the name and position of a player. The data<br>that is returned is used to populate(vt.居住于；构成人口) a PL&#x2F;SQL RECORD containing three separate variables: first name, last<br>name, and position. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
  TYPE emp_info IS RECORD(first employees.first_name%TYPE, 
                         last employees.last_name%TYPE, 
                         email employees.email%TYPE); 
  emp_info_rec emp_info;  -- 用emp_info 类型定义了emp_info_rec变量

BEGIN 
 SELECT first_name, last_name, email 
 INTO emp_info_rec 
 FROM employees 
 WHERE last_name &#x3D; &#39;Vargas&#39;; 
 DBMS_OUTPUT.PUT_LINE(&#39;The queried employee&#39;&#39;s email address is &#39; || emp_info_rec.email); 
 EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); 
END; </code></pre>

<p><strong>How It Works</strong><br>Records are useful for passing similar data around within an application, but they are also quite useful<br>for simply retrieving data and organizing it nicely as is the case with the solution to this recipe. To create<br>a record, you first declare a record TYPE. This declaration can consist of one or more different datatypes<br>that represent columns of one or more database tables. Once the record type is declared, you create a<br>variable and define it as an instance of the record type. This variable is then used to populate and work with the data stored in the record. </p>
<p><code>Cursor</code> work very well with records of data. When declaring a cursor, you can select particular<br>columns of data to return into your record. The record variable then takes on the type of cursor%ROWTYPE.<br>In the following example, a cursor is used to determine which fields you want to return from EMPLOYEES.<br>That cursor’s %ROWTYPE attribute is then used to define a record variable that is used for holding the<br>queried data. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR emp_cur IS 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE employee_id &#x3D; 100; 
 emp_rec emp_cur%ROWTYPE; 
BEGIN 
 OPEN emp_cur; 
 FETCH emp_cur INTO emp_rec; 
 IF emp_cur %FOUND THEN 
CLOSE emp_cur; 
 DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || 
 &#39;&#39;&#39;s email is &#39; || emp_rec.email); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the provided ID number&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee matches the last name provided&#39;); 
END; </code></pre>
<p>As you can see in this example, the cursor <code>%ROWTYPE</code> attribute creates a record type using the<br>columns that are queried by the cursor. The result is easy-to-read code that gains all the positive effects<br>of declaring record types via the <code>%ROWTYPE</code> attribute. </p>
<h2 id="2-6-Looping-Through-Rows-from-a-Query"><a href="#2-6-Looping-Through-Rows-from-a-Query" class="headerlink" title="2.6. Looping Through Rows from a Query"></a>2.6. Looping Through Rows from a Query</h2><p><strong>Problem</strong><br>A query that you are issuing to the database will return many rows. You want to loop through those rows<br>and process them accordingly. </p>
<p><strong>Solution #1</strong><br>There are a couple of different solutions for looping through rows from a query. One is to work directly<br>with a SELECT statement and use a FOR loop along with it. In the following example, you will see this<br>technique in action:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SET SERVEROUTPUT ON; 
BEGIN 
 FOR emp IN 
 ( 
 SELECT first_name, last_name, email 
 FROM employees 
 WHERE commission_pct is not NULL 
 ) 
 LOOP 
 DBMS_OUTPUT.PUT_LINE(emp.first_name || &#39; &#39; || emp.last_name || &#39; - &#39; || emp.email); 
 END LOOP; 
END; </code></pre>

<p><strong>Solution #2</strong><br>Similarly, you can choose to use a FOR loop along with a cursor. Here’s an example: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SET SERVEROUTPUT ON; 
DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, email 
 FROM employees 
WHERE commission_pct is not NULL; 
      emp_rec emp_cur%ROWTYPE;
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
 DBMS_OUTPUT.PUT_LINE( 
 emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_rec.email); 
 END LOOP; 
END; </code></pre>

<p><strong>How It Works</strong><br>The <code>loop</code> that is used in the first solution is also known as an implicit(adj.含蓄的,暗示的) cursor FOR loop. No variables need to be explicitly defined in that solution, because the FOR loop will automatically create a record using the results of the query. That record will take the name provided in the FOR variable_name IN clause. That<br>record variable can then be used to reference the different columns that are returned by the query. As demonstrated in the second solution to this recipe, a cursor is also a very useful way to loop through the results of a query. This technique is also known as an explicit cursor FOR loop. This technique is very similar to looping through the results of an explicitly listed query. Neither solution requires you to explicitly open and close a cursor. In both cases, the opening and<br>closing is done on your behalf by the FOR loop processing. As you can see, the <code>FOR loop</code> with the <code>SELECT query</code> in the first example is a bit more concise(adj.简明的,简洁的), and there are fewer lines of code. The first example also contains no declarations. In the second example, with the cursor, there are two declarations that account for more lines of code. However, using the cursor is a standard technique that provides for more reusable code. For instance, you can elect to use the cursor any number of times, and you’ll need to write the query only once when declaring the cursor. On the contrary, if you wanted to reuse the query in the first example, then you would have to rewrite it,<br>and having to write the same query multiple times opens the door to errors and inconsistencies. We recommend Solution #2. </p>
<h2 id="2-7-Obtaining-Environment-and-Session-Information"><a href="#2-7-Obtaining-Environment-and-Session-Information" class="headerlink" title="2.7. Obtaining Environment and Session Information"></a>2.7. Obtaining Environment and Session Information</h2><p><strong>Problem</strong><br>You want to obtain environment and session information such as the name and IP address of the<br>current user so that the values can be stored into local variables for logging purposes.<br><strong>Solution</strong><br>Make use of the <code>SYS_CONTEXT()</code> built-in function to query the database for the user’s information. Once you<br>have obtained the information, then store it into a local variable. At that point, you can do whatever<br>you’d like with it, such as save it in a logging table. The following code block demonstrates this<br>technique: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;obtain_user_info&gt;&gt;
DECLARE 
  username varchar2(100); 
  ip_address varchar2(100); 
BEGIN
  SELECT SYS_CONTEXT(&#39;USERENV&#39;,&#39;SESSION_USER&#39;), SYS_CONTEXT(&#39;USERENV&#39;,&#39;IP_ADDRESS&#39;) 
  INTO username, ip_address 
  FROM DUAL; 
  DBMS_OUTPUT.PUT_LINE(&#39;The connected user is: &#39; || username || &#39;, and the IP address
  is &#39; || 
  ip_address); 
END; </code></pre>
<p>Once this code block has been run, then the user’s information should be stored into the local<br>variables that have been declared within it. </p>
<p><strong>How It Works</strong><br>You can use the <code>SYS_CONTEXT</code> function to obtain important information regarding the current user’s<br>environment, among other things. It is often times used for auditing(n.审计;查帐) purposes so that a particular code<br>block can grab(vi.攫取;夺取) important information about the connected user such as you’ve seen in the solution to<br>this recipe. The SYS_CONTEXT function allows you to define a namespace and then place parameters<br>within it so that they can be retrieved for use at a later time. The general syntax for the use of<br><code>SYS_CONTEXT</code> is as follows: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SYS_CONTEXT(&#39;namespace&#39;,&#39;parameter&#39;[,length]) </code></pre>
<p>A namespace can be any valid SQL identifier, and it must be created using the CREATE_CONTEXT<br>statement. The parameter must be a string or evaluate to a string, and it must be set using the<br>DBMS_SESSION.SET_CONTEXT procedure. The call to SYS_CONTEXT with a valid namespace and parameter<br>will result in the return of a value that has a VARCHAR2 datatype. The default maximum length of the<br>returned value is 256 bytes. However, this default maximum length can be overridden by specifying the<br>length when calling SYS_CONTEXT. The length is an optional parameter. The range of values for the length<br>is 1 to 4000, and if you specify an invalid value, then the default of 256 will be used.<br>The USERENV namespace is automatically available for use because it is a built-in namespace<br>provided by Oracle. The USERENV namespace contains session information for the current user. Table 2-1<br>lists the parameters that are available to use with the USERENV namespace.<br>Table 2-1. USERENV Parameter Listing </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">-- Parameter          Description 
ACTION                Identifies the position in the application name.
AUDITED_CURSORID      Returns the cursor ID of the SQL that triggered the audit. 
AUTHENTICATED_DATA    Returns the data being used to authenticate the user. 
AUTHENTICATION_TYPE   Identifies how the user was authenticated. 
BG_JOB_ID             If an Oracle Database background process was used to establish the connection, then this returns the job ID of the current session. If no 
                      background process was established, then NULL is returned. 
CLIENT_IDENTIFIER     Returns identifier that is set by the application. 
CLIENT_INFO           Returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. 
CURRENT_SCHEMA        Returns the current session’s default schema.
CURRENT_SCHEMAID      Returns the current schema’s identifier.
CURRENT_SQL           Returns the first 4KB of the triggering SQL.
DB_DOMAIN             Returns the value specified in the DB_DOMAIN parameter. 
DB_NAME               Returns the value specified in the DB_NAME parameter. 
DB_UNIQUE_NAME        Returns the value specified in the DB_UNIQUE_NAME parameter. 
ENTRYID               Returns the current audit entry number. 
EXTERNAL_NAME         Returns the external name of the database user. 
FG_JOB_ID             If an Oracle Database foreground process was used to establish the connection, then this returns the job ID of the current session. If no 
                      foreground process was established, then NULL is returned. 
GLOBAL_CONTEXT_MEMORY Returns the number being used by the globally accessed context in the 
                      System Global Area.   
HOST                  Returns the host name of the machine from which the client has connected. 
INSTANCE              Returns the instance ID number of the current instance. 
IP_ADDRESS            Returns the IP address of the machine from which the client has connected. 
ISDBA                 Returns TRUE if the user was authenticated as a DBA. 
LANG                  Returns the ISO abbreviation of the language name. 
LANGUAGE              Returns the language and territory used by the session, along with the 
                      character set. 
MODULE                Returns the application name. This name has to be set via the
                      DBMS_APPLICATION_INFO package. 
NETWORK_PROTOCOL      Returns the network protocol being used for communication. 
NLS_CALENDAR          Returns the current calendar of the current session. 
NLS_CURRENCY          Returns the currency of the current session. 
NLS_DATE_FORMAT       Returns the date format for the session. 
NLS_DATE_LANGUAGE     Returns the language being used for expressing dates. 
NLS_SORT              Returns the BINARY or linguistic sort basis. 
NLS_TERRITORY         Returns the territory of the current session. 
OS_USER               Returns the operating system user name of the client that initiated the 
                      session. 
PROXY_USER            Returns the name of the database that opened the current session on behalf 
                      of SESSION_USER. 
PROXY_USERID          Returns the identifier of the database user who opened the current session on behalf of the SESSION_USER. 
SERVICE_NAME          Returns the name of the service to which a given session is connected. 
SESSION_USER          Returns the database user name through which the current user is authenticated. 
SESSION_USERID        Returns the identifier of the database user name by which the current user is authenticated. 
SESSIONID             Returns the auditing session identifier. 
STATEMENTID           Returns the auditing statement identifier. 
TERMINAL              Returns the operating system identifier for the client of the current session. </code></pre>
<p>When <code>SYS_CONTEXT</code> is used within any query, it is most commonly issued against the <code>DUAL</code> table. The<br><code>DUAL</code> table is installed along with the data dictionary when the Oracle Database is created. This table is<br>really a dummy(adj.虚拟的,假的) table that contains one column that is appropriately named <code>DUMMY</code>. This column contains<br>the value <code>X</code>.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">SQL&gt; desc dual;
 Name Null? Type 
 ----------------------------------------- -------- ---------------------------- 
DUMMY VARCHAR2(1) </code></pre>
<p>Among other things, <code>DUAL</code> is useful for obtaining values from the database when no actual table is<br>needed. Our solution case is such a situation.</p>
<h2 id="2-8-Formatting-Query-Results"><a href="#2-8-Formatting-Query-Results" class="headerlink" title="2.8. Formatting Query Results"></a>2.8. Formatting Query Results</h2><p><strong>Problem</strong><br>Your boss asks you to print the results from a couple of queries in a nicely formatted manner.<br><strong>Solution</strong><br>Use a combination of different built-in formatting functions along with the concatenation operator (||)<br>to create a nice-looking basic report. The RPAD and LPAD functions along with the concatenation operator<br>are used together in the following example that displays a list of employees from a company: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, phone_number 
 FROM employees; 
 emp_rec employees%ROWTYPE; 
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
 IF emp_rec.phone_number IS NOT NULL THEN 
 DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 35,&#39;.&#39;) || 
 emp_rec.phone_number); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || 
 &#39; does not have a phone number.&#39;); 
 END IF; 
 END LOOP; 
END; 
The following is another variant of the same report, but this time dashes are used instead of using 
dots to space out the report: 
DECLARE 
 CURSOR emp_cur IS 
 SELECT first_name, last_name, phone_number 
 FROM employees; 
 emp_rec employees%ROWTYPE; 
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
  IF emp_rec.phone_number IS NOT NULL THEN
  --CHECK FOR INTERNATIONAL PHONE NUMBERS
        IF length(emp_rec.phone_number) &gt; 12 THEN
          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,18));
        ELSE
          DBMS_OUTPUT.PUT_LINE(RPAD(emp_rec.first_name || &#39; &#39; || emp_rec.last_name, 20)||&#39;-&#39;|| LPAD(emp_rec.phone_number,12));
        END IF;
      ELSE
        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;does not have a phone number.&#39;);
    END IF;
  END LOOP;
END;</code></pre>

<p><strong>How It Works</strong><br>The <code>RPAD</code> and <code>LPAD</code> functions are used to return the data in a formatted manner. The <code>RPAD</code> function takes a<br>string of text and pads it on the right by the number of spaces provided by the second parameter. The<br>syntax for the <code>RPAD</code> function is as follows:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">RPAD(input_text, n, character) -- append n piece characters on the right</code></pre>

<p>In this syntax, <code>n</code> is the number of spaces used to pad. Similarly, the <code>LPAD</code> function pads on the left of<br>the provided string. The syntax is exactly the same as <code>RPAD</code>; the only difference is the direction of the<br>padding. The combination of these two functions, along with the concatenation operator (<code>||</code>), provides<br>for some excellent formatting options.  </p>
<p>It is important to look at the data being returned before you try to format it, especially to consider<br>what formatting options will look best when generating output for presentation. In the case of the<br>examples in this recipe, the latter example would be the most reasonable choice of formatting for the<br>data being returned, since the phone number includes dots in it. The first example uses dots to space out<br>the report, so too many dots may make the output difficult to read. Know your data, and then choose the<br>appropriate PL&#x2F;SQL built-ins to format accordingly.  </p>
<p>Note When using <code>DBMS_OUTPUT</code> to display data, please be sure to pay attention to the size of the buffer. You can<br>set the buffer size from 2,000 to 1,000,000 bytes by passing the size you desire to the <code>DBMS_OUTPUT.ENABLE</code> procedure.<br>If you attempt to display content over this size limit, then Oracle will raise an exception.</p>
<p>Oracle provides a number of built-in functions to use when formatting strings. Two others that are<br>especially useful are <code>LTRIM(&lt;string&gt;)</code> and <code>RTRIM(&lt;string&gt;)</code>. These remove leading and trailing spaces,<br>respectively. See your Oracle SQL Reference manual for a complete list of available string functions.</p>
<h2 id="2-9-Updating-Rows-Returned-by-a-Query"><a href="#2-9-Updating-Rows-Returned-by-a-Query" class="headerlink" title="2.9. Updating Rows Returned by a Query"></a>2.9. Updating Rows Returned by a Query</h2><p><strong>Problem</strong><br>  You’ve queried the database and retrieved a row into a variable. You want to update some values<br>contained in the row and commit them to the database.<br><strong>Solution</strong><br>  First, retrieve the database row that you want to update. Second, update the values in the row that need<br>to be changed, and then issue an UPDATE statement to modify the database with the updated values. In<br>the following example, a procedure is created that queries a table of employees for a particular<br>employee. The resulting employee’s department ID is then updated with the new one unless the<br>employee is already a member of the given department.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE change_emp_dept(emp_id IN NUMBER, 
 dept_id IN NUMBER) AS 
 emp_row employees%ROWTYPE; 
 dept departments.department_name%TYPE; 
 rec_count number :&#x3D; 0; 
BEGIN 
 SELECT count(*) 
 INTO rec_count 
 FROM employees 
 WHERE employee_id &#x3D; emp_id; 
 IF rec_count &#x3D; 1 THEN 
 SELECT * 
 INTO emp_row 
 FROM employees 
 WHERE employee_id &#x3D; emp_id; 
 IF emp_row.department_id !&#x3D; dept_id THEN 
 emp_row.department_id :&#x3D; dept_id; 
 UPDATE employees SET ROW &#x3D; emp_row 
 WHERE employee_id &#x3D; emp_id; 
 SELECT department_name 
 INTO dept 
 from departments 
 WHERE department_id &#x3D; dept_id; 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || emp_row.first_name || &#39; &#39; || 
 emp_row.last_name || &#39; is now in department: &#39; || dept); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee is already in that department...no change&#39;); 
 END IF; 
ELSIF rec_count &gt; 1 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee ID you entered is not unique&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;No employee records match the given employee ID&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Invalid employee or department ID, try again&#39;); 
 WHEN OTHERS THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Unsuccessful change, please check ID numbers and try again&#39;); 
END; </code></pre>
<p>As you can see, the example queries the database into a record declared using the <code>%ROWTYPE</code><br>attribute. The value that needs to be updated is then modified using the data contained in the record.<br>Lastly, using the SET ROW clause updates the table with the modified record.<br><strong>How It Works</strong><br>As you’ve seen in the solution to the recipe, it is possible to update the values of a row returned by a<br>query using the <code>UPDATE...SET</code> ROW syntax. In many cases, using a single <code>UPDATE</code> statement can solve this<br>type of transaction. However, in some scenarios where you need to evaluate the current value of a<br>particular column, then this solution is the correct choice.</p>
<p>Using the <code>UPDATE</code> ROW statement, you can update entire database rows with a single variable of either<br>the <code>%ROWTYPE</code> or <code>RECORD</code> type. The <code>UPDATE</code> statement also allows you to return values after the update by<br>adding the <code>RETURNING</code> clause to the end of the statement followed(v.跟着,听从) by the column names to return and the<br>variables that will receive their values. Take a look at this next example:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 first        employees.first_name%TYPE; 
 last         employees.last_name%TYPE; 
 new_salary   employees.salary%TYPE; 
BEGIN 
 UPDATE employees 
 SET salary &#x3D; salary + (salary * .03) 
 WHERE employee_id &#x3D; 100  RETURNING first_name, last_name,salary INTO first, last, new_salary; 
 DBMS_OUTPUT.PUT_LINE(&#39;The employee &#39; || first || &#39; &#39; || last || &#39; now has a salary of: &#39; || new_salary); 
END; </code></pre>
<p>As you can see, the example outputs the new values that are the result of the update statement.<br>Using the RETURNING clause saves a step in that you are not required to requery the table after the update<br>in order to display the updated results.</p>
<h2 id="2-10-Updating-Rows-Returned-by-a-Cursor"><a href="#2-10-Updating-Rows-Returned-by-a-Cursor" class="headerlink" title="2.10. Updating Rows Returned by a Cursor"></a>2.10. Updating Rows Returned by a Cursor</h2><p><strong>Problem</strong><br>You’ve created a cursor to use for querying your data. You want to loop through the results using a cursor for loop and update the data as needed.<br><strong>Solution</strong><br>Use the <code>WHERE_CURRENT_OF</code> clause within your loop to update the current data row in the iteration. In the<br>following example, the EMPLOYEES table is queried for all employees in a particular department. The<br>results of the query are then iterated using a FOR loop, and the salary is increased for each employee<br>record that is returned.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
DECLARE 
 CURSOR emp_sal_cur IS 
 SELECT * 
 FROM employees 
 WHERE department_id &#x3D; 60 
 FOR UPDATE;        --cursor should use &#96;FOR UPDATE&#96; clause statement

 emp_sal_rec emp_sal_cur%ROWTYPE; -- cursor also would define varable using ROWTYPE keyword

 BEGIN 
 FOR emp_sal_rec IN emp_sal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;Old Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); 
    UPDATE employees 
    SET salary &#x3D; salary + (salary * .025) 
    WHERE CURRENT OF emp_sal_cur;  -- current of your_cursor
 END LOOP; 

 -- Display the updated salaries 
 FOR emp_sal_rec IN emp_sal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;New Salary: &#39; || emp_sal_rec.last_name || &#39; - &#39; || emp_sal_rec.salary); 
 END LOOP; 
END;
</code></pre>
<p>An update on the <code>EMPLOYEES</code> table occurs with each iteration of the loop. The second loop in this<br>example simply displays the new salary result for each employee that was returned by the cursor query.<br><strong>How It Works</strong><br>Updating values when iterating a cursor can be handy(adj.便利的,手边的), especially when working with a number of(大量) rows.<br>There is one main difference between a cursor that allows updating and one(cursor) that does not. That<br>difference is the addition of the <code>FOR UPDATE</code> clause in the cursor declaration. By using the <code>FOR UPDATE</code><br>clause of the <code>SELECT</code> statement, you are causing the database to lock the rows that have been read by the<br>query. This lock is to ensure that nobody else can modify the rows while you are working with them. The<br>lock creates a read-only block on the table rows so that if someone else attempts to modify them while<br>you have them locked, then they will have to wait until you have performed either a <code>COMMIT</code> or a <code>ROLLBACK</code>.<br>The <code>FOR UPDATE</code> clause has an optional <code>NOWAIT</code> keyword. By including this keyword, you will ensure<br>that your query does not block your transaction if someone else already has the rows that you are<br>querying blocked. The <code>NOWAIT</code> keyword tells Oracle not to wait if the requested rows are already locked,<br>and control is immediately passed back to your program so that it can continue to run. If the <code>NOWAIT</code><br>keyword is omitted and the rows are already locked, then your program will stop and wait until the lock<br>has been released.</p>
<p>You can use the cursor with any style of loop, as you’ve seen in previous recipes. No matter which<br>type of loop you choose, the <code>UPDATE</code> must be coded using the <code>WHERE CURRENT OF your_cursor</code> clause to update the<br>current row in the cursor iteration. You will need to be sure to commit the changes after this block has<br>been run, and in many circumstances the <code>COMMIT</code> statement can be coded into this block once it has been<br>tested and verified to work correctly. As with any <code>UPDATE</code> statement, if you fail to <code>COMMIT</code> your changes,<br>then the UPDATE will not save any changes to the database, and the updated data will be visible to your<br>schema only until you disconnect. Issuing a <code>COMMIT</code> after your <code>UPDATE</code> statements have been issued is also<br>a good practice in this case because it will release the lock on the rows you had queried via the cursor so<br>that someone else can update them if needed. If you determine the data that was updated by the code<br>block is incorrect, then a <code>ROLLBACK</code> will also release the lock.</p>
<text style="font-family:Courier New;color:red">

<p>summary:</br></p>
<ol>
<li>if you wanna update data of cursor that returned by select, you can use <code>WHERE CURRENT OF emp_sal_cur</code> and <code>for update</code></li>
<li>By using the <code>FOR UPDATE</code> clause of the <code>SELECT</code> statement,data lock is data level</li>
<li>wether <code>FOR UPDATE</code> clause update table data or cursor only?(it should be commit changes for table)</li>
<li>if you fail to <code>COMMIT</code> your changes,then the UPDATE will not save any changes to the database, and the updated data will be visible to your<br>schema only until you disconnec</li>
<li><code>COMMIT</code> and <code>ROLLBACK</code> either release lock</li>
</ol>
</text> 

<h2 id="2-11-Deleting-Rows-Returned-by-a-Cursor"><a href="#2-11-Deleting-Rows-Returned-by-a-Cursor" class="headerlink" title="2.11. Deleting Rows Returned by a Cursor"></a>2.11. Deleting Rows Returned by a Cursor</h2><p><strong>Problem</strong><br>There are a series of database rows that you’d like to delete. You’ve created a cursor <code>FOR LOOP</code>, and you want to delete some or all rows that have been queried with the cursor.<br><strong>Solution</strong><br>Use a <code>DELETE</code> statement within a <code>FOR LOOP</code> to delete the rows that are retrieved by the <code>cursor</code>. If you create a cursor using the <code>FOR UPDATE</code> clause, then you will be able to use the <code>WHERE CURRENT OF</code> clause along with the <code>DELETE</code> statement to eliminate the current row within each iteration of the cursor. The following example shows how this can be done to remove all job history for a given department ID:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE remove_job_history(dept_id IN NUMBER) AS 

 CURSOR job_history_cur IS 
 SELECT * 
 FROM job_history 
 WHERE department_id &#x3D; dept_id 
 FOR UPDATE; 
    job_history_rec job_history_cur%ROWTYPE; 
 BEGIN 
  FOR job_history_rec IN job_history_cur LOOP 
    DELETE FROM job_history WHERE CURRENT OF job_history_cur; 
    DBMS_OUTPUT.PUT_LINE(&#39;Job history removed for department &#39; || dept_id); 
  END LOOP; 
END; </code></pre>
<p>Using this technique, the job history for the department with the given ID will be removed from the <code>JOB_HISTORY</code> table.</p>
<p><strong>How It Works</strong><br>Much like updating rows using a cursor, the deletion of rows uses the <code>WHERE CURRENT OF</code> clause within the <code>DELETE</code> statement to remove each row. The cursor query must contain the <code>FOR UPDATE</code> clause in order to lock the rows that you are reading until a <code>COMMIT</code> or <code>ROLLBACK</code> has been issued. As mentioned in the previous recipe, the <code>NOWAIT</code> keyword is optional, and it can be used to allow control to be immediately returned to your program if someone else already has locks on the rows that you are interested in updating. In each iteration of the loop, the DELETE statement is used along with the <code>WHERE CURRENT OF</code> clause to remove the current cursor record from the database. Once the loop has been completed, then all the rows that had been queried via the cursor should have been deleted. This technique is especially useful if you are going to be performing some further processing on each of the records and then deleting them. One such case would be if you wanted to write each of the records to a history table prior to deleting them. In any case, the cursor <code>FOR loop</code> deletion technique is a great way to remove rows from the database and work with the data along the way.</p>
<h2 id="2-12-Performing-a-Transaction"><a href="#2-12-Performing-a-Transaction" class="headerlink" title="2.12. Performing a Transaction"></a>2.12. Performing a Transaction</h2><p><strong>Problem</strong><br>You need to complete a series of <code>INSERT</code> or <code>UPDATE</code> statements in order to process a complete transaction. In doing so, you need to ensure that if one of the statements fails, that all of the statements are canceled so that the transaction is not partially processed.<br><strong>Solution</strong><br>Use the transaction control mechanisms that are part of PL&#x2F;SQL, as well as SQL itself, in order to control your transactions. When all your statements have been completed successfully, issue a <code>COMMIT</code> to make them final. On the other hand, if one of the statements does not complete successfully, then perform a <code>ROLLBACK</code> to undo all the other changes that have been made and bring the database back to the state that it was in prior(美[‘praɪɚ],adj.优先的,在先的,在前的) to the transaction occurring.In the following example, the code block entails the body of a script that is to be executed in order to create a new department and add some employees to it. The department change involves an INSERT and UPDATE statement to complete.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 -- Query all programmers who make more than 4000 
 -- as they will be moved to the new &#39;Web Development&#39; department 
 CURSOR new_dept_cur IS 
    SELECT * 
    FROM employees 
    WHERE job_id &#x3D; &#39;IT_PROG&#39;
    AND salary &gt; 4000 
    FOR UPDATE; 
 new_dept_rec         new_dept_cur%ROWTYPE; 
 current_department   departments.department_id%TYPE; 
BEGIN 
 -- Create a new department 
 INSERT INTO departments values( 
                                DEPARTMENTS_SEQ.nextval, -- Department ID (sequence value) 
                                &#39;Web Development&#39;, -- Department Title 
                                103 -- Manager ID 
                                1700); -- Location ID 
 -- Obtain the current department ID…the new department ID 
 SELECT DEPARTMENTS_SEQ.currval 
 INTO current_department 
 FROM DUAL; 

 -- Assign all employees to the new department 
 FOR new_dept_rec IN new_dept_cur LOOP 
      UPDATE employees 
      SET department_id &#x3D; current_department 
      WHERE CURRENT OF new_dept_cur; 
 END LOOP;

 COMMIT;
      DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); 
END;</code></pre>
<p>As you can see, a transaction was performed in this block of code. It is important to roll back changes if errors occur along the way so that the transaction is not partially completed.</p>
<p><strong>How It Works</strong><br>Transaction control is built into the Oracle Database. Any database changes that are made within a code block are visible to the current session only until a COMMIT has been made. The changes that have been made by the statements can be rolled back via the ROLLBACK command up until the point that a COMMIT is issued. Oracle uses table and row locks to ensure that data that has been updated in one session cannot be seen in another session until a COMMIT occurs. A transaction is started when the first statement after the last COMMIT or ROLLBACK is processed or when a session is created. It ends when a COMMIT or ROLLBACK occurs. A transaction is not bound to a single code block, and any code block may contain one or more transactions. Oracle provides a SAVEPOINT command, which places a marker at the current database state so as to allow you to roll back to that point in time in a transaction. Oracle Database automatically issues a SAVEPOINT prior to processing the first statement in any transaction.</p>
<p>As a rule of thumb, it is always a good idea to have exception handling in place in case an exceptionoccurs. However, if an unhandled exception occurs, then the database will roll back the statement that caused the exception, not the entire transaction. Therefore, it is up to the program to handle exceptions and issue the ROLLBACK command if the entire transaction should be undone. If a database crashes and goes down during a transaction, then when the database is restarted, all uncommitted statements are rolled back. All transactions are completed when a COMMIT or ROLLBACK is issued.</p>
<h2 id="2-13-Ensuring-That-Multiple-Queries-“See”-the-Same-Data"><a href="#2-13-Ensuring-That-Multiple-Queries-“See”-the-Same-Data" class="headerlink" title="2.13. Ensuring That Multiple Queries “See” the Same Data"></a>2.13. Ensuring That Multiple Queries “See” the Same Data</h2><p><strong>Problem</strong><br>You are issuing a set of queries against the database, and you need to ensure that none of the table rows change throughout the course of the queries being made.<br><strong>Solution</strong><br>Set up a read-only transaction in which the current transaction will see the data only as an unchanged snapshot in time. To do so, use the SET TRANSACTION statement to begin a read-only transaction and establish a snapshot of the data so it will be consistent and unchanged from all other updates being made. For instance, the following example displays a block that sets up read-only queries against the database for dollar values from a bank account:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 daily_atm_total NUMBER(12,2); 
 weekly_atm_total NUMBER(12,2); 
BEGIN 
 COMMIT; -- ends previous transaction 
 SET TRANSACTION READ ONLY NAME &#39;ATM Weekly Summary&#39;; 
 SELECT SUM (wd_amt) INTO daily_atm_total FROM atm_withdrawals 
 WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE, &#39;MM-DD-YYYY&#39;); 
 SELECT SUM (weekly_total) INTO weekly_atm_total FROM atm_withdrawals 
 WHERE to_char(wd_date, &#39;MM-DD-YYYY&#39;) &#x3D; to_char(SYSDATE - 7, &#39;MM-DD-YYYY&#39;); 
 DBMS_OUTPUT.PUT_LINE(daily_atm_total || &#39; - &#39; || weekly_atm_total); 
 COMMIT; -- ends read-only transaction 
END; </code></pre>
<p>Querying the database using read-only transactions will ensure that someone will see the correct values in a situation such as the one depicted(vt.描述,描画) in this example.</p>
<p><strong>How It Works</strong><br>often times there are situations when you need to ensure that the data being queried throughout a transaction’s life cycle is unchanged by other users’ updates. The classic case is when someone goes to withdraw money from the bank and their spouse(n.配偶) is at an ATM machine depositing into the account at the same time. If read consistency were not in place, the individual may view their account balance and see that there was plenty of money to withdraw, and then they’d go to take the money out and receive an error because the spouse had canceled the deposit(美 [dɪ’pɑzɪt]n.存款,押金) instead. A read-only transaction allows for read consistency until a <code>COMMIT</code> has been issued. If the spouse had confirmed the deposit, then the next query on the account would reflect the additional funds (assuming that the bank were to release them to the account in real time).<br>Situations such as these require that you provide an environment that is essentially isolated from the outside world. You can use the SET TRANSACTION command to start a read-only transaction, set an isolation level, and assign the current transaction to a <code>rollback</code> segment. The SET TRANSACTION statement must be the first statement in a read-only transaction, and it can appear only once in the transaction. Note that there are some statement restrictions when using a read-only transaction. Only <code>SELECT INTO</code>, <code>OPEN</code>, <code>FETCH</code>, <code>CLOSE</code>, <code>LOCK TABLE</code>, <code>COMMIT</code>, and <code>ROLLBACK</code> statements can be used; other statements are not allowed.</p>
<h2 id="2-14-Executing-One-Transaction-from-Within-Another"><a href="#2-14-Executing-One-Transaction-from-Within-Another" class="headerlink" title="2.14. Executing One Transaction from Within Another"></a>2.14. Executing One Transaction from Within Another</h2><p>(nested tracsaction)<br><strong>Problem</strong><br>You are executing a transaction, and you are faced with the need to suspend your current work, issue a completely separate transaction, and then pick up your current work. For example, say you want to log entries into a log table. The log entries should be persisted separately from the current transaction such that if the transaction fails or is rolled back, the log entries will still be completed.<br><strong>Solution</strong><br>Start an autonomous transaction to make the log entry. This will ensure that the log entry is performed separately from the current transaction. In the following example, an employee is deleted from the EMPLOYEES table. Hence, a job is ended, and the job history must be recorded into the <code>JOB_HISTORY</code> table. In the case that something fails within the transaction, the log entry into the <code>JOB_HISTORY</code> table must be intact(adj.完整的,原封不动的). This log entry cannot be rolled back because it is performed using an autonomous transaction.The code to encapsulate(美 [ɪn’kæpsjə’let],vt.压缩,将…装入胶囊) the autonomous transaction needs to be placed into a named block that can be called when the logging needs to be performed. The following piece of code creates a PL&#x2F;SQL procedure that performs the log entry using an autonomous transaction. (You will learn more about procedures in Chapter 4.) Specifically notice(n.通知,布告) the declaration of <code>PRAGMA AUTONOMOUS_TRANSACTION</code>. That pragma specifies that the procedure executes as a separate transaction, independent of any calling transaction.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CREATE OR REPLACE PROCEDURE log_job_history ( emp_id IN 
                                              employees.employee_id%TYPE, 
                                              Job_id IN jobs.job_id%TYPE, 
                                              Department_id IN employees.department_id%TYPE, 
                                              employee_start IN DATE) AS 
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN 
 INSERT INTO job_history 
 VALUES (emp_id, 
 employee_start, 
 sysdate, 
 job_id, 
 department_id); 
 COMMIT; 
END;
</code></pre>
<p>The <code>LOG_JOB_HISTORY</code> procedure inserts an entry into the log table separately from the transaction that is taking place in the calling code block. The following code performs the job termination, and it calls the <code>log_substitution</code> procedure to record the history:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 CURSOR dept_removal_cur IS 
    SELECT * 
    FROM employees 
    WHERE department_id &#x3D; 10 
    FOR UPDATE; 
 dept_removal_rec dept_removal_cur%ROWTYPE; 
BEGIN 
 -- Delete all employees from the database who reside in department 10 
 FOR dept_removal_rec IN dept_removal_cur LOOP 
    DBMS_OUTPUT.PUT_LINE(&#39;DELETING RECORD NOW&#39;); 
    DELETE FROM employees WHERE CURRENT OF dept_removal_cur; 
    -- Log the termination 
    log_job_history(dept_removal_rec.employee_id, 
                      dept_removal_rec.job_id, 
                      dept_removal_rec.department_id, 
                      dept_removal_rec.hire_date);
 END LOOP; 
    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been successfully completed.&#39;); 
EXCEPTION 
 -- Handles all errors 
 WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE(&#39;The transaction has been rolled back due to errors, please try again.&#39;); 
    ROLLBACK; 
END;</code></pre>
<p>If this code block is executed and then rolled back, the entry into the job history table remains,because it is performed as a separate, autonomous transaction.<br><strong>How It Works</strong><br>An autonomous transaction is a transaction that is called by another transaction and that runs separately from the calling transaction. Autonomous transactions commit or roll back without affecting the calling transaction. They also have the full functionality of regular transactions; they merely(adv.仅仅,只不过,只是) run separately from the main transaction. They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.</p>
<p>An autonomous transaction must be created with a top-level code block, trigger, procedure,function, or stand-alone named piece of code. In the solution, you saw that a procedure was created to run as an autonomous transaction. That is because it is not possible to create an autonomous transaction within a nested code block. To name a transaction as autonomous, you must place the statement PRAGMA AUTONOMOUS_TRANSACTION within the declaration section of a block encompassing(adj.包含的,包容的,环绕) the transaction. To end the transaction, perform a COMMIT or ROLLBACK.</p>
<text style="font-family:Courier New;color:red">

<p>summary: </br></p>
<ol>
<li>They allow parallel activity to occur. Even if the main transaction fails or is rolled back, the autonomous transaction can be committed or rolled back independently of any other transactions in progress.</li>
</ol>
</text>

<h2 id="2-15-Finding-and-Removing-Duplicate-Table-Rows"><a href="#2-15-Finding-and-Removing-Duplicate-Table-Rows" class="headerlink" title="2.15. Finding and Removing Duplicate Table Rows"></a>2.15. Finding and Removing Duplicate Table Rows</h2><p><strong>Problem</strong><br>You have found that for some reason your database contains a table that has duplicate records. You areworking with a database that unfortunately does not use primary key values, so you must manually enforce data integrity. You need a way to remove the duplicate records. However, any query you write to remove one record will also remove its duplicate.<br><strong>Solution</strong><br>The solution to this issue involves two steps. First you need to query the database to find all duplicaterows, and then you need to run a statement to delete one of each duplicate record that is found.The following code block queries the EMPLOYEES table for duplicate rows. When a duplicate is found,it is returned along with a count of duplicates found.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">&lt;&lt;duplicate_emp_qry&gt;&gt;
DECLARE
CURSOR emp_cur IS
  SELECT *
  FROM employees
  ORDER BY employee_id;
  emp_count
  number :&#x3D; 0;
  total_count
  number :&#x3D; 0;
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;You will see each duplicated employee listed more &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;than once in the list below. This will allow you to &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;review the list and ensure that indeed...there are more &#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;than one of these employee records in the table.&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;Duplicated Employees: &#39;);
-- Loop through each player in the table
FOR emp_rec IN emp_cur LOOP
-- Select the number of records in the table that have the same ID as the current record
SELECT count(*)
INTO emp_count
FROM employees
WHERE employee_id &#x3D; emp_rec.employee_id;
-- If the count is greater than one then a duplicate has been found, so print it out.
IF emp_count &gt; 1 THEN 
 DBMS_OUTPUT.PUT_LINE(emp_rec.employee_id || &#39; - &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39; - &#39; || emp_count); 
 total_count :&#x3D; total_count + 1; 
 END IF; 
 END LOOP; 
END;</code></pre>
<p>If the table includes a duplicate, then it is printed out as follows:<br>You will see each duplicated employee listed more than once in the list below. This will allow you to review the list and ensure that indeed…there are more<br>than one of these employees in the table.<br>Duplicated Employees:<br>100 - Steven King - 2<br>100 – Steven King - 2<br>PL&#x2F;SQL procedure successfully completed.  </p>
<p>Next, you need to delete the duplicated rows that have been found. The following DELETE statement<br>will ensure that one of the duplicates is removed:<br>DELETE FROM employees A WHERE ROWID &gt; (<br>SELECT min(rowid) FROM employees B<br>WHERE A.employee_id &#x3D; B.employee_id);</p>
<p><strong>How It Works</strong><br>Usually using primary keys prohibits the entry of duplicate rows into a database table. However, many legacy databases still in use today do not include such constraints. In rare situations, a duplicate key and values are entered into the database that can cause issues when querying data or assigning values. The method shown in the solution for finding duplicate rows is very basic. The solution loops through each record in the table, and during each pass, it queries the table for the number of records found that match the current record’s EMPLOYEE_ID. If the number found is greater than one, then you know that you have found a duplicate. The solution presented here for finding duplicates will work on any table provided that you have a column of data that should contain logically unique values. In the example, each record should contain a different EMPLOYEE_ID, so if there is more than one record with the same EMPLOYEE_ID value, then a duplicate is found. If the table you are working with does not contain any unique columns, then you can concatenate a number of columns in order to obtain a unique combination. For instance, if EMPLOYEES did not contain an EMPLOYEE_ID column, then you could concatenate the FIRST_NAME, LAST_NAME, and EMAIL columns to obtain a unique combination. More likely than not, there will not be two employees in the table with the same name and e-mail address. The second part of the solution involves removing one or more duplicate records from the set. To do so, you have to look at a pseudocolumn known as the ROWID. The ROWID is a pseudocolumn (invisible column) that is found in each table in an Oracle Database that uniquely identifies each row. By comparing these unique ROWID values, you can delete just one of the records, not both. The DELETE statement actually finds the rows that contain the same uniquely identified column(s) and then removes the row with the larger ROWID value.</p>
<h1 id="3-Looping-and-Logic"><a href="#3-Looping-and-Logic" class="headerlink" title="3. Looping and Logic"></a>3. Looping and Logic</h1><h2 id="3-1-Choosing-When-to-Execute-Code"><a href="#3-1-Choosing-When-to-Execute-Code" class="headerlink" title="3.1. Choosing When to Execute Code"></a>3.1. Choosing When to Execute Code</h2><p><strong>Problem</strong><br>Your code contains a condition, and you are interested in executing code to perform specific actions if the condition evaluates to <code>TRUE</code>, <code>FALSE</code>, or <code>NULL</code>.<br><strong>Solution</strong><br>Use an <code>IF-THEN</code> statement to evaluate an expression (or condition) and determine which code to execute<br>as a result. The following example depicts a very simple <code>IF-THEN</code> statement that evaluates one variable to see whether it contains a larger value than another variable. If so, then the statements contained within the <code>IF-THEN</code> statement are executed; otherwise, they are ignored. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 value_one NUMBER :&#x3D; &amp;value_one; 
 value_two NUMBER :&#x3D; &amp;value_two; 
BEGIN 
 IF value_one &gt; value_two THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;value_one is greater than value_two&#39;); 
 END IF; 
END; </code></pre>
<p>As you can see from the example, if value_one is greater than value_two, a line of output will be printed stating so. Otherwise, the IF statement is bypassed, and processing continues.<br><strong>How It Works</strong><br>As shown in the solution, the general format for the IF-THEN statement is as follows:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">IF condition THEN
 Statements to be executed 
 …
END IF; </code></pre>
<p>The <code>IF-THEN</code> statement is one of the most frequently used conditional statements. If a given condition evaluates to <code>TRUE</code>, then the code contained within the IF-THEN statement is executed. If the condition evaluates to FALSE or NULL, then the statement is exited. However, it is possible to incorporate(vt.包含,吸收) a different set of statements if the condition is not satisfied. Please see Recipe 3-2 for an example. Any number of <code>IF-THEN</code> statements can be nested within one another. The statements within the <code>IF-THEN</code> will be executed if the condition that is specified evaluates to <code>TRUE</code>.</p>
<h2 id="3-2-Choosing-Between-Two-Mutually-Exclusive-Conditions"><a href="#3-2-Choosing-Between-Two-Mutually-Exclusive-Conditions" class="headerlink" title="3-2. Choosing Between Two Mutually Exclusive Conditions"></a>3-2. Choosing Between Two Mutually Exclusive Conditions</h2><p><strong>Problem</strong><br>You have two conditions that are mutually(美 [‘mjutʃuəli]adv.互相地,互助) exclusive. You want to execute one set of statements if the<br>first condition evaluates to TRUE. Otherwise, if the first condition is FALSE or NULL, then execute a different<br>set of statements.<br><strong>Solution</strong><br>Use an IF-ELSE statement to evaluate the condition and execute the statements that correspond to it if<br>the condition evaluates to TRUE. In the following example, a given employee ID is used to query the<br>EMPLOYEES table. If that employee exists, then the employee record will be retrieved. If not found, then a<br>message will be displayed stating that no match was found. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 employee employees%ROWTYPE; 
 emp_count number :&#x3D; 0; 
BEGIN 
 SELECT count(*) 
 INTO emp_count 
 FROM employees 
 WHERE employee_id &#x3D; 100; 
 IF emp_count &gt; 0 THEN 
 SELECT * 
 INTO employee 
 FROM employees 
 WHERE employee_id &#x3D; 100; 
 IF employee.manager_id IS NOT NULL THEN 
 DBMS_OUTPUT.PUT_LINE(employee.first_name || &#39; &#39; || employee.last_name || 
 &#39; has an assigned manager.&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(employee.first_name || &#39; &#39; || employee.last_name || 
 &#39; does not have an assigned manager.&#39;); 
END IF; 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;The given employee ID does not match any records, &#39;|| 
 &#39; please try again&#39;); 
 END IF; 
EXCEPTION 
 WHEN NO_DATA_FOUND THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;Try another employee ID.&#39;); 
END; </code></pre>
<p>In the real world, the employee ID would not be hard-coded into the example. However, this example provides a good scenario for evaluating mutually exclusive conditions and also nesting IF statements.<br><strong>How It Works</strong><br>The <code>IF-ELSE</code> statement syntax is basically the same as the <code>IF-THEN</code> syntax, except that a different set of<br>statements is executed in the ELSE clause when the condition evaluates to FALSE or NULL. Therefore, if the<br>first condition is FALSE or NULL, then the control automatically drops down into the statements contained<br>within the ELSE clause and executes them.</p>
<h2 id="3-3-Evaluating-Multiple-Mutually-Exclusive-Conditions"><a href="#3-3-Evaluating-Multiple-Mutually-Exclusive-Conditions" class="headerlink" title="3.3. Evaluating Multiple Mutually Exclusive Conditions"></a>3.3. Evaluating Multiple Mutually Exclusive Conditions</h2><p><strong>Problem</strong><br>Your application has multiple conditions to evaluate, and each of them is mutually exclusive. If one of<br>the conditions evaluates to FALSE, you’d like to evaluate the next one. You want that process to continue<br>until there are no more conditions.<br>Two solutions are possible: one using IF and the other using <code>CASE</code>.</p>
<p><strong>Solution #1</strong><br>Use an <code>IF-ELSIF-ELSE</code> statement to perform an evaluation of all mutually exclusive conditions. The following example is a SQL*Plus script that queries how many countries are in a specified region.</p>
<p>If the region that is typed as input when the following example executes matches any of the regions specified by the conditions in the IF statement, then subsequent statements are executed. However, a default message is displayed if the input does not match any region.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 Region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; 
 country_count number :&#x3D; 0; 
BEGIN 
 IF upper(region) &#x3D; &#39;EUROPE&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 1; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Europe region.&#39;); 
 ELSIF upper(region) &#x3D; &#39;AMERICAS&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 2; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Americas region.&#39;); 
 ELSIF upper(region) &#x3D; &#39;ASIA&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 3; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Asia region.&#39;); 
 ELSIF upper(region) &#x3D; &#39;MIDDLE EAST AND AFRICA&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 4; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Middle East and Africa region.&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); 
 END IF; 
END; </code></pre>
<p><strong>Solution #2</strong><br>You can use the searched <code>CASE</code> statement to evaluate a boolean expression to determine which statements to execute among multiple, mutually exclusive conditions. The next example is a SQL*Plus script that performs the same tasks as <strong>Solution #1</strong> but this time using a searched <code>CASE</code> statement:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; 
 country_count number :&#x3D; 0; 
BEGIN 
 CASE 
 WHEN upper(region) &#x3D; &#39;EUROPE&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 1; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Europe region.&#39;); 
 WHEN upper(region) &#x3D; &#39;AMERICAS&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 2; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Americas region.&#39;); 
 WHEN upper(region) &#x3D; &#39;ASIA&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 3; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Asia region.&#39;); 
 WHEN upper(region) &#x3D; &#39;MIDDLE EAST AND AFRICA&#39; THEN 
 SELECT count(*) 
 INTO country_count 
 FROM countries 
 WHERE region_id &#x3D; 4; 
 DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || 
 &#39;the Middle East and Africa region.&#39;); 
 ELSE 
 DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); 
 END CASE; 
END; 
</code></pre>
<p><strong>How It Works</strong><br>IF-ELSIF-ELSE can be used to evaluate any number of conditions. It functions such that if the first<br>condition in the IF-ELSIF-ELSE statement evaluates to TRUE, then the statements within its block are<br>executed, and all others are bypassed. Similarly, if the first condition evaluates to FALSE and the second<br>condition evaluates to TRUE, then the second condition’s statements will be executed, others will be<br>ignored, and so on.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">CASE
 WHEN &lt;&lt;boolean_expression&gt;&gt; THEN &lt;&lt;statements&gt;&gt; 
[ELSE statements]; </code></pre>


<h2 id="3-4-Driving-from-an-Expression-Having-Multiple-Outcomes"><a href="#3-4-Driving-from-an-Expression-Having-Multiple-Outcomes" class="headerlink" title="3.4 Driving from an Expression Having Multiple Outcomes"></a>3.4 Driving from an Expression Having Multiple Outcomes</h2><p><strong>Problem</strong><br>You have a single expression that yields multiple outcomes. You are interested in evaluating the expression and performing a different set of statements depending upon the outcome.<br><strong>Solution</strong><br>Use a CASE statement to evaluate your expression, and decide which set of statements to execute depending upon the outcome. In the following example, a SQL*Plus script accepts a region entry, which is being evaluated to determine the set of statements to be executed. Based upon the value of the region, the corresponding set of statements is executed, and once those statements have been executed, then the control is passed to the statement immediately following the CASE statement. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 region regions.region_name%TYPE :&#x3D; &#39;&amp;region&#39;; 
 country_count number :&#x3D; 0; 
BEGIN 
 CASE upper(region) 
 WHEN &#39;EUROPE&#39; THEN 
    SELECT count(*) 
    INTO country_count 
    FROM countries 
    WHERE region_id &#x3D; 1; 
    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Europe region.&#39;); 
 WHEN &#39;AMERICAS&#39; THEN 
    SELECT count(*) 
    INTO country_count 
    FROM countries 
    WHERE region_id &#x3D; 2; 
    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; ||&#39;the Americas region.&#39;); 
 WHEN &#39;ASIA&#39; THEN 
    SELECT count(*) 
    INTO country_count 
    FROM countries 
    WHERE region_id &#x3D; 3; 
    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Asia region.&#39;); 
 WHEN &#39;MIDDLE EAST AND AFRICA&#39; THEN 
    SELECT count(*) 
    INTO country_count 
    FROM countries 
    WHERE region_id &#x3D; 4; 
    DBMS_OUTPUT.PUT_LINE(&#39;There are &#39; || country_count || &#39; countries in &#39; || &#39;the Middle East and Africa region.&#39;); 
 ELSE 
    DBMS_OUTPUT.PUT_LINE(&#39;You have entered an invaid region, please try again&#39;); 
 END CASE; 
END; 
</code></pre>

<p><strong>How It Works</strong><br>There are two different types of CASE statements that can be used—those being the searched CASE and the simple CASE statement. The solution to this recipe demonstrates the simple CASE. For an example of a searched CASE statement, please see Recipe 3-3.</p>
<p>The simple CASE statement begins with the keyword CASE followed by a single expression called a selector. The selector is evaluated one time, and it can evaluate to any PL&#x2F;SQL type other than BLOB, BFILE, an object type, a record, or a collection type. The selector is followed by a series of WHEN clauses. The WHEN clauses are evaluated sequentially to determine whether the value of the selector equals the result from any of the WHEN clause expressions. If a match is found, then the corresponding WHEN clause is executed.</p>
<p>The CASE statement can include any number of WHEN clauses, and much like an IF statement, it can be followed with a trailing ELSE clause that will be executed if none of the WHEN expressions matches. If the ELSE clause is omitted, a predefined exception will be raised if the CASE statement does not match any of the WHEN clauses. The END CASE keywords end the statement.</p>
<h2 id="3-5-Looping-Until-a-Specified-Condition-Is-Met"><a href="#3-5-Looping-Until-a-Specified-Condition-Is-Met" class="headerlink" title="3.5. Looping Until a Specified Condition Is Met"></a>3.5. Looping Until a Specified Condition Is Met</h2><p><strong>Problem</strong><br>You want to loop through a set of statements until a specified condition evaluates to true.<br><strong>Solution</strong><br>Use a simple <code>LOOP</code> statement along with an <code>EXIT</code> clause to define a condition that will end the iteration.<br>The following example shows a simple LOOP that will print out each employee with a department_id equal<br>to 90:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
CURSOR emp_cur IS
SELECT *
FROM employees
WHERE department_id &#x3D; 90;
emp_rec employees%ROWTYPE;

BEGIN
OPEN emp_cur;
LOOP
  FETCH emp_cur into emp_rec;
  IF emp_cur%FOUND THEN
    DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name ||&#39;-&#39;|| emp_rec.email);
  ELSE
    EXIT;
  END IF;
END LOOP;
CLOSE emp_cur;
END;
</code></pre>

<p>As you can see from the example, the cursor is opened prior to the start of the loop. Inside the loop,<br>the cursor is fetched into emp_rec, and emp_rec is evaluated to see whether it contains anything using the<br>cursor %FOUND attribute. If emp_cur%FOUND is FALSE, then the loop is exited using the EXIT keyword.<br><strong>How It Works</strong><br>The simple LOOP structure is very easy to use for generating a loop in your code. The LOOP keyword is used<br>to start the loop, and the END LOOP keywords are used to terminate it. Every simple loop must contain an<br>EXIT or GOTO statement; otherwise, the loop will become infinite and run indefinitely.<br>You can use a couple of different styles for the EXIT. When used alone, the EXIT keyword causes a<br>loop to be terminated immediately, and control is passed to the first statement following the loop. You<br>can use the EXIT-WHEN statement to terminate the loop based upon the evaluation of a condition after the<br>WHEN statement. If the condition evaluates to TRUE, then the loop is terminated; otherwise, it will<br>continue.<br>The following example shows the same LOOP as the example in the solution, but instead of using an<br>IF statement to evaluate the content of emp_rec, the <code>EXIT-WHEN</code> statement is used:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
CURSOR emp_cur IS
SELECT *
FROM employees
WHERE department_id &#x3D; 90;
emp_rec employees%ROWTYPE;
BEGIN
OPEN emp_cur;
 LOOP 
 FETCH emp_cur into emp_rec; 
 EXIT WHEN emp_cur%NOTFOUND; 
      DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || &#39;-&#39; || emp_rec.email); 
 END LOOP; 
 CLOSE emp_cur; 
END; </code></pre>
<p>You can use a loop to iterate over any number of things including cursors or collections of data. As<br>you will see in some of the coming recipes, different forms of loops work better in different<br>circumstances. </p>
<h2 id="3-6-Iterating-Cursor-Results-Until-All-Rows-Have-Been-Returned"><a href="#3-6-Iterating-Cursor-Results-Until-All-Rows-Have-Been-Returned" class="headerlink" title="3.6. Iterating Cursor Results Until All Rows Have Been Returned"></a>3.6. Iterating Cursor Results Until All Rows Have Been Returned</h2><p><strong>Problem</strong><br>You have created a cursor and retrieved a number of rows from the database. As a result, you want to<br>loop through the results and do some processing on them.<br><strong>Solution</strong><br>Use a standard FOR loop to iterate through the records. Within each iteration of the loop, process the<br>current record. The following code shows the use of a FOR loop to iterate through the records retrieved<br>from the cursor and display each employee name and e-mail. Each iteration of the loop returns an<br>employee with the job_id of ‘ST_MAN’, and the loop will continue to execute until the cursor has been<br>exhausted.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 CURSOR emp_cur IS 
 SELECT * 
 FROM employees 
 WHERE job_id &#x3D; &#39;ST_MAN&#39;; 
 emp_rec employees%ROWTYPE; 
BEGIN 
 FOR emp_rec IN emp_cur LOOP 
 DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || &#39; &#39; || emp_rec.last_name || 
 &#39; - &#39; || emp_rec.email); 
 END LOOP; 
END; </code></pre>

<p>Here are the results:<br>Matthew Weiss - MWEISS<br>Adam Fripp - AFRIPP<br>Payam Kaufling - PKAUFLIN<br>Shanta Vollman - SVOLLMAN<br>Kevin Mourgos - KMOURGOS<br>PL&#x2F;SQL procedure successfully completed</p>
<p>As you can see, the employee records that meet the specified criteria are displayed.</p>
<h2 id="3-7-Iterating-Until-a-Condition-Evaluates-to-FALSE"><a href="#3-7-Iterating-Until-a-Condition-Evaluates-to-FALSE" class="headerlink" title="3.7. Iterating Until a Condition Evaluates to FALSE"></a>3.7. Iterating Until a Condition Evaluates to FALSE</h2><p><strong>Problem</strong><br>You want to iterate over a series of statements until a specified condition no longer evaluates to TRUE.<br><strong>Solution</strong><br>Use a WHILE statement to test the condition, and execute the series of statements if the condition<br>evaluates to TRUE; otherwise, skip the statements completely. The following example shows a WHILE<br>statement evaluating the current value of a variable and looping through until the value of the variable<br>reaches ten. Within the loop, this variable is being multiplied by two and printing out its current value.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
 myValue NUMBER :&#x3D; 1; 
BEGIN 
WHILE myValue &lt; 10 LOOP 
 DBMS_OUTPUT.PUT_LINE(&#39;The current value is: &#39; || myValue); 
 myValue :&#x3D; myValue * 2; 
 END LOOP;
END;</code></pre>

<p>Here are the results:<br>The current value is: 1<br>The current value is: 2<br>The current value is: 4<br>The current value is: 8<br>PL&#x2F;SQL procedure successfully completed.<br>The important thing to note in this example is that the value of myValue is increased with each<br>iteration of the loop as to eventually meet the condition specified in the <code>WHILE</code> loop.</p>
<p><strong>How It Works</strong><br>The WHILE loop tests a condition at the top of the loop, and if it evaluates to TRUE, then the statements within the loop are executed, and control is returned to the start of the loop where the condition is tested again. If the condition does not evaluate to TRUE, the loop is bypassed, and control goes to the next statement after the END LOOP. If the condition never fails, then an infinite loop is formed, so it is important to ensure that the condition will eventually evaluate to FALSE. It is important to note that the statements in the loop will never be executed if the condition evaluates to FALSE during the first pass. This situation is different from the simple loop that always<br>iterates at least once because the EXIT condition is usually evaluated elsewhere in the loop. To ensure that a WHILE loop is always executed at least one time, you must ensure that the condition evaluates to TRUE at least once. One way to do this is to use a flag variable that is evaluated with each iteration of the loop. Set the flag equal to FALSE prior to starting the loop, and then set it to TRUE when a certain condition is met inside the loop. The following pseudocode depicts such a solution:</p>
<pre class="language-none"><code class="language-none">BEGIN 
 flag &#x3D; FALSE; 
 WHILE flag &#x3D; TRUE LOOP 
Perform statements 
 flag &#x3D; Boolean expression; 
 END LOOP; 
END; </code></pre>
<p>As mentioned previously, the boolean expression that is assigned to the flag in this case must<br>eventually evaluate to FALSE; otherwise, an infinite loop will occur.</p>
<h2 id="3-8-Bypassing-the-Current-Loop-Iteration"><a href="#3-8-Bypassing-the-Current-Loop-Iteration" class="headerlink" title="3.8.Bypassing the Current Loop Iteration"></a>3.8.Bypassing the Current Loop Iteration</h2><p><strong>Problem</strong><br>If a specified conditional statement evaluates to TRUE, you want to terminate the current loop iteration of<br>the loop early and start the next iteration immediately.<br><strong>Solution</strong><br>Use a CONTINUE statement along with a condition to end the current iteration. In the following example, a loop is used to iterate through the records in the employees table. The primary reason for the loop is to print out a list of employees who receive a salary greater than 15,000. If an employee does not receive more than 15,000, then nothing is printed out, and the loop continues to the next iteration.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE 
    CURSOR emp_cur is 
    SELECT * 
    FROM employees; 
    emp_rec emp_cur%ROWTYPE; 
BEGIN 
    DBMS_OUTPUT.PUT_LINE(&#39;Employees with salary &gt; 15000: &#39;); 
OPEN emp_cur;
 LOOP 
 FETCH emp_cur INTO emp_rec; 
 EXIT WHEN emp_cur%NOTFOUND; 
 IF emp_rec.salary &lt; 15000 THEN 
 CONTINUE;
 ELSE 
    DBMS_OUTPUT.PUT_LINE(&#39;Employee: &#39; || emp_rec.first_name || &#39; &#39; || emp_rec.last_name); 
 END IF; 
 END LOOP; 
 CLOSE emp_cur; 
END; </code></pre>

<p>Here are some sample results:<br>Employees with salary &gt; 15000:<br>Employee: Steven King<br>Employee: Neena Kochhar<br>Employee: Lex De Haan<br>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>You can use the CONTINUE statement in any loop to unconditionally halt execution of the current iteration<br>of the loop and move to the next. As shown in the solution, the CONTINUE statement is usually<br>encompassed within some conditional statement so that it is invoked only when that certain condition<br>is met. </p>
<p>You can use the CONTINUE statement along with a label in order to jump to a specified point in the<br>program. Rather than merely using CONTINUE to bypass the current loop iteration, specifying a label will<br>allow you to resume programming in an outer loop. For more information regarding the use of the<br>CONTINUE statement along with labels in nested loops, please see Recipe 3-13.<br>As an alternative to specifying CONTINUE from within an IF statement, you can choose to write a<br>CONTINUE WHEN statement. For example, the following two approaches yield identical results: </p>
<pre class="language-sql" data-language="sql"><code class="language-sql"> IF team_rec.total_points &lt; 10 THEN 
 CONTINUE; 
or 
 CONTINUE WHEN rec.total_points &lt; 10; </code></pre>

<p>Using the <code>CONTINUE WHEN</code> format, the loop will stop its current iteration if the condition in the WHEN<br>clause is met. Otherwise, the iteration will ignore the statement altogether.</p>
<h2 id="3-9-Iterating-a-Fixed-Number-of-Times"><a href="#3-9-Iterating-a-Fixed-Number-of-Times" class="headerlink" title="3.9. Iterating a Fixed Number of Times"></a>3.9. Iterating a Fixed Number of Times</h2><p><strong>Problem</strong><br>You are interested in executing the contents of a loop a specified number of times. For example, you are<br>interested in executing a loop ten times, and you need to number each line of output in the range by the<br>current loop index.<br><strong>Solution</strong><br>Write a FOR loop. Use a variable to store the current index of the loop while looping through a range of<br>numbers from one to ten in ascending order. The following lines of code will iterate ten times through a<br>loop and print out the current index in each pass:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
 FOR idx IN 1..10 LOOP 
 DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx); 
 END LOOP; 
END;</code></pre>
<pre class="language-none"><code class="language-none">Here is the result: 
The current index is: 1 
The current index is: 2 
The current index is: 3 
The current index is: 4 
The current index is: 5 
The current index is: 6 
The current index is: 7 
The current index is: 8 
The current index is: 9
The current index is: 10</code></pre>
<p>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>The FOR loop will increment by one through the given range for each iteration until it reaches the end.<br>The loop is opened using the keyword FOR, followed by a variable that will be used as the index for the<br>loop. Following the index variable is the IN keyword, which is used to signify that the index variable<br>should increment one by one through the given range, which is listed after the IN keyword. The loop is<br>terminated using the END LOOP keywords.<br>Each statement contained within the loop is executed once for each iteration of the loop. The index<br>variable can be used within the loop, but it cannot be changed. As shown in the solution, you may use<br>the index for printing purposes, and it is oftentimes used in calculations as well.<br>The REVERSE keyword should be placed directly after the IN keyword and before the range that you<br>specify. The REVERSE keyword has no effect when working with cursors. If you need to iterate through<br>cursor results in a specific order, then specify an ORDER BY clause in your SELECT statement. </p>
<h2 id="Iterating-in-Increments-Other-Than-One"><a href="#Iterating-in-Increments-Other-Than-One" class="headerlink" title="Iterating in Increments Other Than One"></a>Iterating in Increments Other Than One</h2><p>3-11. Iterating in Increments Other Than One<br><strong>Problem</strong><br>Rather than iterating through a range of numbers one at a time, you want to increment by some other<br>value. For example, you might want to increment through even values such as 2, 4, 6, and so forth.<br><strong>Solution</strong><br>Multiply the loop index by two (or by whatever other multiplier you need) to achieve the effect of<br>incrementing through all even numbers. As you can see in the following example, an even number is<br>always generated when the index is multiplied by two: </p>
<pre class="language-none"><code class="language-none">BEGIN 
 FOR idx IN 1..5 LOOP 
 DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx*2); 
 END LOOP; 
END;</code></pre>
<p>Here is the result:<br>The current index is: 2<br>The current index is: 4<br>The current index is: 6<br>The current index is: 8<br>The current index is: 10<br>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>Unlike some other languages, PL&#x2F;SQL does not include a STEP clause that can be used while looping. To<br>work around that limitation, you will need to write your own stepping algorithm. In the solution to this<br>recipe, you can see that the algorithm was quite easy; you simply multiply the index by two to achieve<br>the desired result. In this solution, assigning the range of 1..5 as the index produces the effect of iterating<br>through all even numbers from 2..10 when the current index is multiplied by two.<br>Using similar techniques, you can increment through ranges of numbers in various intervals.<br>However, sometimes this can become troublesome if you are attempting to step by anything other than<br>even numbers. You can see an example of this in the next recipe.</p>
<h2 id="3-12-Stepping-Through-a-Loop-Based-on-Odd-Numbered-Increments"><a href="#3-12-Stepping-Through-a-Loop-Based-on-Odd-Numbered-Increments" class="headerlink" title="3.12. Stepping Through a Loop Based on Odd-Numbered Increments"></a>3.12. Stepping Through a Loop Based on Odd-Numbered Increments</h2><p><strong>Problem</strong><br>Rather than iterating through a range of numbers by even increments, you prefer to loop through the<br>range using odd increments.<br><strong>Solution</strong><br>Use the built-in MOD function to determine whether the current index is odd. If it is odd, then print out<br>the value; otherwise, continue to the next iteration. The following example shows how to implement this<br>solution:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
 FOR idx IN 1..10 LOOP 
 IF MOD(idx,2) !&#x3D; 0 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The current index is: &#39; || idx); 
 END IF; 
 END LOOP; 
END; </code></pre>

<p>Results:<br>The current index is: 1<br>The current index is: 3<br>The current index is: 5<br>The current index is: 7<br>The current index is: 9<br>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>The solution depicts one possible workaround for a STEP replacement. Using the MOD function to<br>determine whether a number is odd works quite well. The MOD function, otherwise known as the modulus<br>function, is used to return the remainder from the division of the two numbers that are passed into the<br>function. Therefore, this function is useful for determining even or odd numbers. In this case, if any<br>value is returned from MOD, then the number is assumed to be odd, and the statements within the IF<br>statement will be executed.<br>Such a technique may be useful in the case of iterating through a collection of data such as a table. If<br>you want to grab every other record from the collection, then performing a stepping solution such as this<br>or the solution from Recipe 3-11 will allow you to achieve the desired result. You could easily use the<br>resulting index from this technique as the index for a collection.</p>
<h2 id="3-13-Exiting-an-Outer-Loop-Prematurely"><a href="#3-13-Exiting-an-Outer-Loop-Prematurely" class="headerlink" title="3.13. Exiting an Outer Loop Prematurely"></a>3.13. Exiting an Outer Loop Prematurely</h2><p><strong>Problem</strong><br>Your code contains a nested loop, and you want the inner loop to have the ability to exit from both loops<br>and stop iteration completely.<br><strong>Solution</strong><br>Use loop labels for both loops and then reference either loop within an EXIT statement by following the<br>EXIT keyword with a loop label. The following example prints out a series of numbers. During each<br>iteration, the inner loop will increment until it reaches an odd number. At that point, it will pass control<br>to the outer loop again. The outer loop will be exited when the index for the inner loop is greater than or<br>equal to the number ten. </p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN 
 &lt;&lt;outer&gt;&gt; for idx1 in 1 .. 10 loop 
 &lt;&lt;inner&gt;&gt; for idx2 in 1 .. 10 loop 
 dbms_output.put(idx2); 
 exit inner when idx2 &gt; idx1 * 2; 
 exit outer when idx2 &#x3D; 10; 
 END LOOP; 
 DBMS_OUTPUT.NEW_LINE; 
 END LOOP; 
 DBMS_OUTPUT.NEW_LINE; 
END;</code></pre>
<p>Results:<br>123<br>12345<br>1234567<br>123456789<br>12345678910<br>PL&#x2F;SQL procedure successfully completed.<br><strong>How It Works</strong><br>Any loop in PL&#x2F;SQL can be labeled using a similar style to labels for code blocks. The label can be any<br>valid identifier surrounded by angle brackets before the loop, and optionally the identifier can be placed<br>at the end after the END LOOP clause. The result of such a labeling mechanism is that you will have a<br>distinct start and end to the loops and more control over loop execution.<br>In the solution to this recipe, the label helps identify the outer loop so that it can be terminated with<br>the EXIT clause. Without a label, the EXIT will terminate the innermost FOR loop. However, the label can<br>also be used to help identify the loop’s index. In the solution, this is not necessary because the outer loop<br>index was named differently than the inner loop index. If both indexes were named the same, then you<br>could use the loop label along with the index name to fully qualify the index. The following example<br>demonstrates this technique:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">BEGIN
&lt;&lt;outer&gt;&gt; FOR idx IN 1 .. 10 LOOP
&lt;&lt;inner&gt;&gt; FOR idx IN 1 .. 10 LOOP
  DBMS_OUTPUT.PUT(inner.idx);
EXIT inner WHEN inner.idx &gt; outer.idx * 2;
EXIT outer WHEN inner.idx &#x3D; 10;
END LOOP;
  DBMS_OUTPUT.NEW_LINE;
END LOOP;
  DBMS_OUTPUT.NEW_LINE;
END;</code></pre>

<p>This code will display the same results as the example given in the solution to this recipe. The only<br>difference is that in this example the index name is the same in both the inner and outer loops. An<br>alternative technique to end the current iteration of an inner loop is to use the CONTINUE statement. A<br>CONTINUE statement can reference the label of a loop that is within the same scope. Therefore, an inner<br>loop can exit its current iteration and proceed to an outer loop, as the following example demonstrates:</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">
BEGIN
&lt;&lt;outer&gt;&gt; for idx1 in 1 .. 10 loop
&lt;&lt;inner&gt;&gt; for idx2 in 1 .. 10 loop
dbms_output.put(idx2);
exit inner when idx2 &gt; idx1 * 2;
exit outer when idx2 &#x3D; 10;
END LOOP;
CONTINUE outer;
END LOOP;
DBMS_OUTPUT.NEW_LINE;
END;</code></pre>
<p>In this example, the same code that is used in the solution to this recipe is rewritten to incorporate a<br>CONTINUE statement. This statement is used to move control of execution back to the outer loop. When<br>the CONTINUE statement is reached, execution of the current loop is immediately halted, and processing<br>continues to the loop designated by the label.</p>
<h2 id="3-14-Jumping-to-a-Designated-Location-in-Code"><a href="#3-14-Jumping-to-a-Designated-Location-in-Code" class="headerlink" title="3.14. Jumping to a Designated Location in Code"></a>3.14. Jumping to a Designated Location in Code</h2><p><strong>Problem</strong><br>You want your code to stop executing and jump to a different, designated location.<br><strong>Solution</strong><br>Use a GOTO statement along with a label name to cause code execution to jump into the position where<br>the label is located.<br>The following example shows the GOTO statement in action. The user is prompted to enter a numeric<br>value, and that value is then evaluated to determine whether it is greater than ten. In either case, a<br>message is printed, and then the code jumps to the end_msg label. If the number entered is a negative<br>number, then the code jumps to the bad_input label where an error message is printed.</p>
<pre class="language-sql" data-language="sql"><code class="language-sql">DECLARE
 in_number number :&#x3D; 0; 
BEGIN 
 in_number :&#x3D; &#39;&amp;input_number&#39;; 
 IF in_number &gt; 10 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The number you entered is greater than ten&#39;); 
 GOTO end_msg; 
 ELSIF in_number &lt;&#x3D; 10 and in_number &gt; 0 THEN 
 DBMS_OUTPUT.PUT_LINE(&#39;The number you entered is less than or equal to ten&#39;); 
 GOTO end_msg; 
 ELSE 
 -- Entered a negative number 
 GOTO bad_input; 
 END IF; 
 &lt;&lt; bad_input &gt;&gt; 
 DBMS_OUTPUT.PUT_LINE(&#39;Invalid input. No negatives allowed.&#39;); 
 &lt;&lt; end_msg &gt;&gt; 
 DBMS_OUTPUT.PUT_LINE(&#39;Thank you for playing..&#39;); 
END; </code></pre>
<p><strong>How It Works</strong><br>The GOTO statement is used to branch code unconditionally. Code can be branched to any label within<br>the same scope as the GOTO. In the solution, the GOTO statement causes the code to branch to a parent<br>code block. You could just as easily branch to a loop within the current or outer block. However, you<br>cannot branch to a label within a subblock, IF statement, or LOOP. </p>
<p>You should use this statement sparingly because arbitrary branching makes code difficult to read. Use<br>conditional statements to branch whenever possible, because that’s why they were put into the<br>language. As you can see from the solution, the same code could have been written printing the “Invalid<br>number” message within the ELSE clause. There are usually better alternatives to using GOTO. </p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/20/archive/iso8583%E7%AE%80%E4%BB%8B/"
                    data-tooltip="iso8583简介"
                    aria-label="PREVIOUS: iso8583简介"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/19/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E5%8E%9F%E7%94%9F%E5%AE%B6%E5%BA%AD%E5%A6%82%E4%BD%95%E4%BF%AE%E8%A1%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%A7%E6%A0%BC%E7%BC%BA%E9%99%B7/"
                    data-tooltip="原生家庭如何修补自己的性格缺陷"
                    aria-label="NEXT: 原生家庭如何修补自己的性格缺陷"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/19/oracle/Oracle_PLSQL_Recipes/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 kirkzhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/20/archive/iso8583%E7%AE%80%E4%BB%8B/"
                    data-tooltip="iso8583简介"
                    aria-label="PREVIOUS: iso8583简介"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/19/%E9%9D%9E%E6%8A%80%E6%9C%AF%E7%B1%BB/%E5%8E%9F%E7%94%9F%E5%AE%B6%E5%BA%AD%E5%A6%82%E4%BD%95%E4%BF%AE%E8%A1%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%A7%E6%A0%BC%E7%BC%BA%E9%99%B7/"
                    data-tooltip="原生家庭如何修补自己的性格缺陷"
                    aria-label="NEXT: 原生家庭如何修补自己的性格缺陷"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href=""
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/19/oracle/Oracle_PLSQL_Recipes/"
                    title="global.share_on_wechat"
                    aria-label="global.share_on_wechat"
                >
                    <i class="fa-foo_bar" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href=""
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.foo_bar.com/sharer/sharer.php?u=https://simonteo58.github.io/2022/10/19/oracle/Oracle_PLSQL_Recipes/"
                        aria-label="global.share_on_wechat"
                    >
                        <i class="fa-foo_bar" aria-hidden="true"></i><span>global.share_on_wechat</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">kirkzhang</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Canton
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-4u8r0fo0pgap8c0kebqie2krcfxcv3h259cjxizeggkmknhnwzjt04ztqpi1.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'ca29b9a1203b5920918d',
              clientSecret: 'b1b2a10320acecd54ae9427f140164b2e63d13f5',
              repo: 'SimonTeo58.github.io',
              owner: 'SimonTeo58',
              admin: ['SimonTeo58'],
              id: '2022/10/19/oracle/Oracle_PLSQL_Recipes/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
