---
title: 算法导论 ch02
categories:
- 算法
mathjax: true
---


Our ﬁrst algorithm, insertion sort, solves the sorting problem introduced in Chapter 1:
<!-- more -->

## 2.1 插入排序

**Input**: A sequence of n numbers ( $a_1; a_2;.... a_n$ ).
**Output**: A permutation(n.[数]排列) (reordering) $a^1_1; a^1_2$....) of the input sequence such that $a^1_1$<$a^1_2$...
The numbers that we wish to sort are also known as the keys. Although conceptually(adv.概念地) we are sorting a sequence, the input comes to us in the form of an array with n elements.In this book, we shall typically describe algorithms as programs written in a pseudocode(美 [ˈsju:doˌkod]) that is similar in many respects to C, C++, Java, Python, or Pascal. If you have been introduced to any of these languages, you should have little trouble 

**Figure 2.1** Sorting a hand of cards using insertion sort.

插入排序有点像我们抓拍时候的场景，一个手拿牌并不断的按照顺序将手里的牌排序。

**Figure 2.2** The operation of INSERTION-SORT on the array A = (5; 2; 4; 6; 1; 3). Array indices(n. 指数目录) appear above the rectangles, and values stored in the array positions appear within the rectangles.(a)–(e) The iterations of the for loop of lines 1–8. In each iteration, the black rectangle holds thekey taken from A(j) , which is compared with the values in shaded rectangles to its left in the test of line 5. Shaded arrows show array values moved one position to the right in line 6, and black arrows indicate where the key moves to in line 8. (f) The ﬁnal sorted array.

## 2.2 迭代不变量和插入排序的正确性

what is In fact,elements A[1...j-1] are the elements originally in positions 1 through j 1, but now in sorted order. We state these properties of A[1...j-1] formally as a **loop invariant**: At the start of each iteration of the for loop of lines 1–8, the subarray A[1...j-1] consists of the elements originally in A[1...j-1] , but in sorted order.

Initialization: It is true prior to the ﬁrst iteration of the loop.
Maintenance: If it is true before an iteration of the loop, it remains true before the
next iteration. Termination: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct.

三属性的解释  
**Initialization**: We start by showing that the loop invariant holds before the ﬁrst
loop iteration, when j = 2. The subarray A[1...j-1] , therefore, consists
of just the single element AŒ1 , which is in fact the original element in AŒ1 .
Moreover, this subarray is sorted (trivially, of course), which shows that the
loop invariant holds prior to the ﬁrst iteration of the loop.

**Maintenance**: Next, we tackle the second property: showing that each iteration
maintains the loop invariant. Informally, the body of the for loop works by
moving A[j-1] , A[j-2] , A[j-3] , and so on by one position to the right
until it ﬁnds the proper position for AŒj (lines 4–7), at which point it inserts
the value of AŒj (line 8). The subarray A[1...j-1] then consists of the elements
originally in A[1...j-1] , but in sorted order. Incrementing j for the next iteration
of the for loop then preserves the loop invariant.A more formal treatment of the second property would require us to state and
show a loop invariant for the while loop of lines 5–7. At this point, however,we prefer not to get bogged down in such formalism, and so we rely on our
informal analysis to show that the second property holds for the outer loop.

**Termination**: Finally, we examine what happens when the loop terminates. The
condition causing the for loop to terminate is that j > A.length=n. Because
each loop iteration increases j by 1, we must have j=n+1 at that time.
Substituting n+1 for j in the wording of loop invariant, we have that the
subarray A[1...n] consists of the elements originally in A[1...n] , but in sorted
order. Observing that the subarray A[1...n] is the entire array, we conclude that
the entire array is sorted. Hence, the algorithm is correct.

这章节还规定了伪代码规范，适用于以后所有章节

```golang
package algorithm
import "fmt"
var cards = []int{7, 6, 5, 4, 3, 2, 1}
/*
插入排序
*/
func insertSort() {
	for i := 1; i < len(cards); i++ {
		kingValue := cards[i]
		for j := i - 1; j >= 0; j-- {
			if kingValue < cards[j] {
				cards[j+1] = cards[j]
				cards[j] = kingValue
			}
		}

	}
	fmt.Println(cards)
}

```