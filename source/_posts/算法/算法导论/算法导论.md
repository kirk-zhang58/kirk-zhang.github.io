---
title: 算法导论
categories:
- 算法
---

## 1.1算法
非形式地说,算法(algorithm)就是任何定义良好的计算过程,该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出.
这样算法就是把输入转换成输出的计算步骤的一个序列。
我们也可以把算法看成是用于求解良说明的计算问题的工具。一般来说，问题陈述说明了期望的输入!输出关系。算法则描述--个特定的计算过程来实现该输人/输出关系。
例如，我们可能需要把一个数列排成非递减序。实际上，这个问题经常出现，并且为引人许多标准的设计技术和分析工具提供了足够的理由。下面是我们关于排序问题的形式定义。
输入:n个数的一个序列(a，az , …，a〉。
输出:输人序列的一个排列<ai，a2，…，a>，满足aa…a。
例如，给定输入序列《31，41，59，26，41，58)，排序算法将返回序列〈26，31，41，41，58,59》作为输出。这样的输人序列称为排序问题的一个实例(instance)。一般来说，问题实例由计算该问题解所必需的(满足问题陈述中强加的各种约束的>输入组成。
因为许多程序使用排序作为一个中间步，所以排序是计算机科学中的一个基本操作。因此，已有许多好的排序算法供我们任意使用。对于给定应用，哪个算法最好依赖于以下因素:将被排序的项数、这些项已被稍微排序的程度、关于项值的可能限制、计算机的体系结构，以及将使用的存储设备的种类(主存、磁盘或者磁带)。
若对每个输入实例算法都以正确的输出停机，则称该算法是正确的，并称正确的算法解决了给定的计算问题。不正确的算法对某些输人实例可能根本不停机，也可能以不正确的回答停机。与人们期望的相反，不正确的算法只要其错误率可控有时可能是有用的。在第31章，当我们研究求大素数算法时，将看到一个具有可控错误率的算法例子。但是通常我们只关心正确的算法。
算法可以用英语说明，也可以说明成计算机程序，甚至说明成硬件设计。唯一的要求是这个说明必须精确描述所要遵循的计算过程。
算法解决哪种问题
排序绝不是已开发算法的唯一计算问题(当看到本书的厚度时，你可能觉得算法也同样多)。算法的实际应用无处不在,包括以下例子:
·人类基因工程已经取得重大进展，其目标是识别人类DNA中的所有10万个基因，确定构成人类 DNA的30亿个化学基对的序列，在数据库中存储这类信息并为数据分析开发工具。这些工作都需要复杂的算法。虽然对涉及的各种问题的求解超出了本书的范围，但是求解这些生物问题的许多方法采用了本书多章内容的思想，从而使得科学家能够有效地使用资源以完成任务。因为可以从实验技术中提取更多的信息，所以既能节省人和机器的时间又能节省金钱。
·互联网使得全世界的人都能快速地访问与检索大量信息。借助于一些聪明的算法，互联网上的网站能够管理和处理这些海量数据。必须使用算法的问题示例包括为数据传输寻找好的路由(求解这些问题的技术在第24章给出)，使用一个搜索引擎来快速地找到特定



## 15.动态规划

简单讲跟分治方法很像，但是分治是将将问题分解然后一个一个解决，但是动态规划是找子问题重叠的情况，既不同的子问题有公共的子问题，及将子问题求解一遍再将其保存到表格中。传统的递归时间复杂度会有2的N次幂，而用DP改写就会有N的2次幂

### 15.1 钢条切割

一个钢条，按照不同长度切割可以卖出不同价格
| length | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| price  | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 30   |

1. 传统递归
其实是尝试遍了所有的可能性。所以开销很大
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b543d0ff04056b6813faff9f3c32e~tplv-k3u1fbpfcp-watermark.image?)
就如上图，每一个分治就是一种可能

2. 自底向上的动态规划

```cpp
// Cut-Rod with bottom-up method
int BottomUpCutRod(const std::vector<int> &p, const int &n)
{
    std::vector<int> r{0};
    for (auto j = 1; j <= n; ++j)
    {
        int q = INT8_MIN;
        for (auto i = 1; i <= j; ++i)
        {
            q = std::max(q, p.at(i) + r.at(j - i));
        }
        r.push_back(q);
    }
    return r.at(n);
}
```

### 15.2 最大子序和

这道题是来自leetcode.给你一个整数数组 nums,请你找出一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和。子数组 是数组中的一个连续部分。
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb52e9f8c446efbe01435060ce41c4~tplv-k3u1fbpfcp-watermark.image?)

```golang
 // {-2, 1, -3, 4, -1, 2, 1, -5, 4}
func maxSubArray(nums []int) int {


 if len(nums) == 0 {
  return 0
 }
 res := -32768
 f_n := -1

 for i := 0; i < len(nums); i++ {
  f_n = Max(nums[i], f_n+nums[i])
  res = Max(f_n, res)
 }
 return res
}

func Max(a int, b int) int {

 if a >= b {
  return a
 }
 return b
}
```

这里主要是使用了**kadane**算法,使用一个变量跟踪最大值，f_n = Max(nums[i], f_n+nums[i])是kadane的核心思想，如果我下个位置的数字大于你们前面的和，说明前面的结果就不是最大整数和
