---
title: 算法导论
categories:
- 算法
---

## 1.1算法

非正式地讲,算法是任何公认的计算程序,它以一些数值或一组数值作为输入,在一定的时间内产生一些数值或一组数值作为输出.
因此,一个算法是一连串的计算步骤.因此,算法是将输入转化为输出的一系列计算步骤.

你也可以把算法看作是解决一个精心设计的计算问题的工具.问题的陈述以一般条款(term)规定了问题实例所需的输入/输出关系,
通常是任意大的输入.算法描述了一个特定的计算程序,用于实现所有实例的输入/输出关系. 进而完成所有问题的输入/输出关系.

举个例子,假设你需要将一串数字按单调递增的顺序排序.这个问题在实践中经常出现,并提供了许多标准设计技术和为分析工具提供了肥沃的土壤(提供了很多理论时间机会).下面是我们如何正式确定排序问题的.
Input: A sequence of n numbers (a1,a2....ani)
Output:一个输入序列的排列组合（重新排序）(a1',a2'....an'),即(a1'小于 a2' 小于 ...an')(这表示排序的意思,是一种广义定义)



## 15.动态规划

简单讲跟分治方法很像,但是分治是将将问题分解然后一个一个解决,但是动态规划是找子问题重叠的情况,既不同的子问题有公共的子问题,及将子问题求解一遍再将其保存到表格中.传统的递归时间复杂度会有2的N次幂,而用DP改写就会有N的2次幂

### 15.1 钢条切割

一个钢条,按照不同长度切割可以卖出不同价格
| length | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| price  | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 30   |

1. 传统递归
其实是尝试遍了所有的可能性.所以开销很大
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b543d0ff04056b6813faff9f3c32e~tplv-k3u1fbpfcp-watermark.image?)
就如上图,每一个分治就是一种可能

2. 自底向上的动态规划

```cpp
// Cut-Rod with bottom-up method
int BottomUpCutRod(const std::vector<int> &p, const int &n)
{
    std::vector<int> r{0};
    for (auto j = 1; j <= n; ++j)
    {
        int q = INT8_MIN;
        for (auto i = 1; i <= j; ++i)
        {
            q = std::max(q, p.at(i) + r.at(j - i));
        }
        r.push_back(q);
    }
    return r.at(n);
}
```

### 15.2 最大子序和

这道题是来自leetcode.给你一个整数数组 nums,请你找出一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和.子数组 是数组中的一个连续部分.
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb52e9f8c446efbe01435060ce41c4~tplv-k3u1fbpfcp-watermark.image?)

```golang
 // {-2, 1, -3, 4, -1, 2, 1, -5, 4}
func maxSubArray(nums []int) int {


 if len(nums) == 0 {
  return 0
 }
 res := -32768
 f_n := -1

 for i := 0; i < len(nums); i++ {
  f_n = Max(nums[i], f_n+nums[i])
  res = Max(f_n, res)
 }
 return res
}

func Max(a int, b int) int {

 if a >= b {
  return a
 }
 return b
}
```

这里主要是使用了**kadane**算法,使用一个变量跟踪最大值,f_n = Max(nums[i], f_n+nums[i])是kadane的核心思想,如果我下个位置的数字大于你们前面的和,说明前面的结果就不是最大整数和
