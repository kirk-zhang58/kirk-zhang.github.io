---
title: 算法导论 ch15
categories:
- 算法
---


## 15.动态规划

简单讲跟分治方法很像,但是分治是将将问题分解然后一个一个解决,但是动态规划是找子问题重叠的情况,既不同的子问题有公共的子问题,及将子问题求解一遍再将其保存到表格中.传统的递归时间复杂度会有2的N次幂,而用DP改写就会有N的2次幂

<!-- more -->

### 15.1 钢条切割

一个钢条,按照不同长度切割可以卖出不同价格
| length | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| price  | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 30   |

1. 传统递归
其实是尝试遍了所有的可能性.所以开销很大
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b543d0ff04056b6813faff9f3c32e~tplv-k3u1fbpfcp-watermark.image?)
就如上图,每一个分治就是一种可能

2. 自底向上的动态规划

```cpp
// Cut-Rod with bottom-up method
int BottomUpCutRod(const std::vector<int> &p, const int &n)
{
    std::vector<int> r{0};
    for (auto j = 1; j <= n; ++j)
    {
        int q = INT8_MIN;
        for (auto i = 1; i <= j; ++i)
        {
            q = std::max(q, p.at(i) + r.at(j - i));
        }
        r.push_back(q);
    }
    return r.at(n);
}
```

### 15.2 最大子序和

这道题是来自leetcode.给你一个整数数组 nums,请你找出一个具有最大和的连续子数组（子数组最少包含一个元素）,返回其最大和.子数组 是数组中的一个连续部分.
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb52e9f8c446efbe01435060ce41c4~tplv-k3u1fbpfcp-watermark.image?)

```golang
 // {-2, 1, -3, 4, -1, 2, 1, -5, 4}
func maxSubArray(nums []int) int {


 if len(nums) == 0 {
  return 0
 }
 res := -32768
 f_n := -1

 for i := 0; i < len(nums); i++ {
  f_n = Max(nums[i], f_n+nums[i])
  res = Max(f_n, res)
 }
 return res
}

func Max(a int, b int) int {

 if a >= b {
  return a
 }
 return b
}
```

这里主要是使用了**kadane**算法,使用一个变量跟踪最大值,f_n = Max(nums[i], f_n+nums[i])是kadane的核心思想,如果我下个位置的数字大于你们前面的和,说明前面的结果就不是最大整数和