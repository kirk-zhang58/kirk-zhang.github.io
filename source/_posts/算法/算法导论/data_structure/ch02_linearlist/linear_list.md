---
title: 王道数据结构
categories: 
- 算法
thumbnailImagePosition: bottom
coverImage: https://user-images.githubusercontent.com/46363359/204004628-f2a1b8e5-1d4a-47bb-9b9b-e49dc87eee1c.jpg
metaAlignment: center
coverMeta: out
---

对付看吧,虽然打心眼里感觉不是什么好书

<!-- more -->
<!-- toc -->

# 2. 线性表

## 2.1 线性表的定义和基本操作

### 2.1.1. 线性表的定义

线性表是具有相同数据类型的n个数据的有序序列，其中n为表长，出第一个元素外，只有唯一一个直接前驱，除最后一个元素外，只有唯一一个后继。
故可总结:
1. 表中元素有限.
2. 表元素具有逻辑上的顺序,表中元素有先后顺序.
3. 表中元素都是数据元素，每个元素都是单个元素.
4. 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间.
5. 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竞表示什么内容.

### 2.1.2 线性表的基本操作

```c
InitList(&L)        //初始化表，构建一个空的线性表
Length(L)           //秋表长
LocateElem(L,e)     //按值查找
GetElem(L，i)       //按位查找操作。获取表L中第  个位置的元素的值。
ListInsert(&l,i,e)  //插入操作。在表L中的第个位置上插入指定元素 e。
ListDelete(&L,i,se) //删除操作。删除表中第 个位置的元素，并用e 返回删除元素的值。
PrintList(L)        //输出操作。按前后顺序输出线性表工的所有元素值。
Empty(L)            //判空操作。若L为空表，则返 true，否则返回 false。
DestroyList(&L)     //销毁操作。销毁线件表，并释放线性表工所占用的内存空间
```

## 2.2 线性表的顺序表示

### 2.2.1 顺序表的定义

线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在线性表的起始位置,第i个元素的存储位置后面紧接着存储的是第i+1个元素，称为元素在线性表中的位序。因此，顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。假设线性表 L存储的起始位置为 LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如图 2.1 所示如下。

|数组下标|顺序表|内存地址|
|---|---|---|
|0|$a_1$|LOC(A)|
|1|$a_2$|LOC(A)+sizeof(ElemType)|
|2|$a_3$|LOC(A)+(i-1)sizeof(ElemType)|

每个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，线性表中的任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。则线性表的顺序存储类型描述是

```c
#define MaxSize 50
typedef struct {P
    ElemType data[Maxsize];
    int length;
} SqList
```
一维数组可以是静态分配的，也可以是动态分配的。  
- 在静态分配时，由于数组的大小和空问事先已经固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。
- 而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为线性表一次性地划分所有空间。比如高级语言当中的java的linkList，golang的slice

```c
typedef struct(
    ElemType *data //变量名的指针
    int MaxSize,length;
) SegList;

// C的初始动态分配语句为
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
// C++的初始动态分配语何为
L.data=new ElemType[Initsize] //初始化指定长度;
```
顺序表最主要的特点是随机访问，即通过首地址和元素序号可在时间 O(1)内找到指定的元素。
顺序表的存储密度高，每个结点只存储数据元素。顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素
