---
title: 王道数据结构
categories: 
- 算法
thumbnailImagePosition: bottom
coverImage: https://user-images.githubusercontent.com/46363359/204004628-f2a1b8e5-1d4a-47bb-9b9b-e49dc87eee1c.jpg
metaAlignment: center
coverMeta: out
mathjax: true

---

对付看吧,虽然打心眼里感觉不是什么好书

<!-- more -->
<!-- toc -->

# 2. 线性表

## 2.1 线性表的定义和基本操作

### 2.1.1. 线性表的定义

线性表是具有相同数据类型的n个数据的有序序列，其中n为表长，出第一个元素外，只有唯一一个直接前驱，除最后一个元素外，只有唯一一个后继。
故可总结:
1. 表中元素有限.
2. 表元素具有逻辑上的顺序,表中元素有先后顺序.
3. 表中元素都是数据元素，每个元素都是单个元素.
4. 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间.
5. 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竞表示什么内容.

### 2.1.2 线性表的基本操作

```c
InitList(&L)        //初始化表，构建一个空的线性表
Length(L)           //秋表长
LocateElem(L,e)     //按值查找
GetElem(L，i)       //按位查找操作。获取表L中第  个位置的元素的值。
ListInsert(&l,i,e)  //插入操作。在表L中的第个位置上插入指定元素 e。
ListDelete(&L,i,se) //删除操作。删除表中第 个位置的元素，并用e 返回删除元素的值。
PrintList(L)        //输出操作。按前后顺序输出线性表工的所有元素值。
Empty(L)            //判空操作。若L为空表，则返 true，否则返回 false。
DestroyList(&L)     //销毁操作。销毁线件表，并释放线性表工所占用的内存空间
```

## 2.2 线性表的顺序表示

### 2.2.1 顺序表的定义

线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在线性表的起始位置,第i个元素的存储位置后面紧接着存储的是第i+1个元素，称为元素在线性表中的位序。因此，顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。假设线性表 L存储的起始位置为 LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如图 2.1 所示如下。

|数组下标|顺序表|内存地址|
|---|---|---|
|0|$a_1$|LOC(A)|
|1|$a_2$|LOC(A)+sizeof(ElemType)|
|2|$a_3$|LOC(A)+(i-1)sizeof(ElemType)|

每个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，线性表中的任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。则线性表的顺序存储类型描述是

```c
#define MaxSize 50
typedef struct {P
    ElemType data[Maxsize];
    int length;
} SqList
```
一维数组可以是静态分配的，也可以是动态分配的。  
- 在静态分配时，由于数组的大小和空问事先已经固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。
- 而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为线性表一次性地划分所有空间。比如高级语言当中的java的linkList，golang的slice

```c
typedef struct(
    ElemType *data //变量名的指针
    int MaxSize,length;
) SegList;

// C的初始动态分配语句为
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
// C++的初始动态分配语何为
L.data=new ElemType[Initsize] //初始化指定长度;
```
顺序表最主要的特点是随机访问，即通过首地址和元素序号可在时间 O(1)内找到指定的元素。
顺序表的存储密度高，每个结点只存储数据元素。顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素

### 2.2.2 顺序表上基本操作的实现

1. 插入数据
在顺序表L的i位置插入元素e

```java
// 1,2,3,4,5,6
// 0,1,2,3,4,5
public void insert(int[] *listArray, int index, Object obj) throws Exception {
         // TODO Auto-generated method stub
         //如果当前线性表已满，那就不允许插入数据
         if (size == maxSize) {
             throw new Exception("顺序表已满，无法插入！");
         }
         //插入位置编号是否合法
         if (index < 0 || index > size) {
             throw new Exception("参数错误！");
         }
         //移动元素
         for (int j = size - 1; j >= index; j--) {
             listArray[j + 1] = listArray[j];
         }
 
         listArray[index] = obj;  //不管当前线性表的size是否为零，这句话都能正常执行，即都能正常插入
         size++;
}

```
最好情况: 在表尾插入(i=n+1)，元素后移语句不执行
最坏情况: 最表头插入(i=1),元素后移语句将被执行n次
平均情况: 假设$p_i=1/(n+1)$,则在长度为n的线性表中插入一个节点所需移动的平均次数

$\sum_{i=1}^{n+1}p_i(n+1-i)=\sum_{i=1}^{n+1}\cfrac{1}{(n+1)}(n-i+1)=\cfrac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\cfrac{1}{n+1}\cfrac{n(n+1)}{2}=\cfrac{n}{2}$

2. 删除操作

删除顺序表 L中第 i (1<=i<=L.length)个位置的元素，用引用变量 e 返回。若i的输入不合法，则返回false，否则，将被删元素赋给引用变量 e，并将第 +1个元素及其后的所有元素依次往前移动一个位置，返回 true。

```java
// 注意L的数据结构

bool ListDelete(SqList &L , int i , Elementype &e){
    if (i<1||i>L.length){
        return false
    }
    e=L.data[i-1]
    for (int j=i;j<L.length;j++){
        L.data[j-1]=L.data[j]
    }
    L.length--
    return true
}

```

最好情况:删除表尾元素(即i=n)，无须移动元素，时间复杂度为 O(1)。
最坏情况:删除表头元素(即i= 1)，需移动除表头元素外的所有元素，时间复杂度为 O(n)
平均情况:假设 $p_i=\cfrac{1}{n}$ 是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为

$\sum_{i=1}^{n}p_i(n-i)=\sum_{i=1}^{n}\cfrac{1}{n}(n-i)=\cfrac{n(n-1)}{2n}=\cfrac{n-1}{2}$

因此，线性表删除算法的平均实践复杂度为O(n)

3. 按值查找

查找第一个元素值等于e的元素

```java
int LocateElem(SqList L,ElemType e){
    int i;
    for (i=0;i<L.length;i++){
        if (L.data[i]==e){
            return i+1
        }
    }
}

```

最好情况: 查找的元素就在表头，仅需比较一次，时间复杂度为 O(1)。
最坏情况:查找的元素在表尾(或不存在) 时，需要比较 n 次，时间复杂度为 (O)
平均情况:假设 $p_i=\cfrac{1}{n}$ 是查的素在第 (1<=i<=L.length)个位置上的概率则在长度为 n 的线性表中查找值为 e 的元素所需比较的平均次数为

$\sum_{i=1}^{n}p_i*i=\sum_{i=1}^{n}\cfrac{i}{n}=\cfrac{n(n+1)}{2n}=\cfrac{n+1}{2}$

因此线性查找算法的平均复杂度为O(n)

## 2.3 线性表的链式表示

顺序表可以随时存取表中的任意一个元素，它的存储位置可以用一个简单直观的公式表示。但是链式存储线性表时，不需要移动大量的元素，它通过建立起数据之间的逻辑链接关系，因而插入和删除不需要移动元素，而只需要修改指针。

### 2.3.1 单链表的表示

线性表的链式存储又叫单链表，它是通过一组任意的存储单元来存储线性表中的数据元素，为了建立数据元素之间的线性关系，对每个链表节点，除存放元素自身的信息外，还需要放一个指向后继几点的指针，单链表的结构如下图所示 [ data | next ]
```c

typedef struct LNode{
    ElemType data;
    struct LNode *next;
} *LinkList;

```
利用单链表可以解决顺序表需要大量存储单元的缺点。但是但李娜表附加指针域，也存在浪费存储空间的缺点，由于单链表的元素离散地分布在存储空间中，所以单链表的非**随机存取**的存储结构，即不能直接找到表中某个特定的节点。当找到特定的节点时需要从表头依次遍历。  
**头指针**来标识一个单链表，如单链表L.  
**头节点**通常是data为空的节点，也可以记录些链表的长度信息等等
头节点和头指针的区分:不管带不带头节点，头指针都始终指向链表的第一个节点，而头节点是带头结点的链表中的第一个节点，节点内通常不存储信息
引入头节点，可以带来两个优点：
1. 由于第一个数据节点的位置被存放在头节点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理
2. 无论链表是否为空，其头指针都指向头节点非空指针，因此空表和非空表的处理也就得到了统一

### 2.3.2 单链表上的基本操作

1. 采用头插法建立单链表

该方法是从一个空表开始的，生成新节点，并将读取到的数据存储到新节点的数据域中，然后将新节点插入到当前链表的表头，即头节点之后


头插法建立单链表的算法如下:
```c

LinkList List_HeadInsert(LinkList &L){
    LNode *s , int x;

    L=(LinkList)malloc(sizeof(LNode)); //创建头节点
    L->next=null; //初始化为空链表
    scanf("%d",&x);
    while(x!=9999){
        s=(LNode*)malloc(sizeof(LNode));
        s->data=x;
        s->next=L->next; //说白了也就是把s的
        L->next=s;
        scanf("%d",&x);
    }
    return L;
}

```
采用头插法建立单链表的算法虽然简单，但是生成的链表中的节点的输入顺序和链表中元素的顺序是相反的，若希望一致可采用尾插法，插入时间复杂度O(1)，读取时间复杂度为O(n)

2. 尾插法建立单链表

头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针 r，使其始终指向当前链表的尾结点，如图 2.6 所示。采用尾插法的算法如下
```c
LinkList List_TailInsert(LinkList &L){
    int x;
    L=(LinkList)malloc*(sizeof(LNode))
    LNode *s,*r =L;
    scanf("%d",&x);
    while(x!=9999){
        s=(LNode *)malloc(sizeof(LNode));
        s->data=x;
        r->next=s;
        r=s;
        scanf("%d",&x);
    }
    r->next=NULL;
    return L;
}

```

3. 按照序号查找节点值

在单链表中从第一个结点出发，顺指针 next 域逐个往下搜索，直到找到第i个结点为止否则返回最后一个结点指针域 NULL。

```c
LNode *GetElem(LinkList L, int i ){
    int j=1;
    LNode *p=L->next;
    if (i==0)
        return L;
    if (i<1)
        return NULL;
    while(p&&j<i){
        p=p->next;
        j++
    }
    return p;
}

```

4.  按照值查找表节点

从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针;若整个单链表中没有这样的结点，则返回 NULL。
```c
LNode *LocateElem(LinkList L,ElemType e){
    LNode *p = L->next;
    while(!p=NULL&&p->data!=e){
        p=p->data;

    }
    return p
}
时间复杂度尾O(n)


```

5. 插入节点操作

插入结点操作将值为 x 的新结点插入到单链表的第 i 个位置上。先检插入位的合法性然后找到待插入位置的前驱结点，即第 i-1 个结点，再在其后插入新结点。算法首先调用按序号查找算法 GetElem(L,i-1)，查找第 i-1 个结点。假设返回的第 i-1个结点为 \*p，然后令新结点 \*s 的指针域指向\*p 的后继结点，再令结点\*p 的指针域指新插入

实现插入节点的代码片段如下

```c
p=GetElem(L,i-1);
s->next=p->next;
p->next=s;
```

算法中，语句2和3的顺序不能颠倒，否则，当先执行 p->next=s 后，指向其原后继的指针就不存在，再执行 s->next=p->next 时，相当于执行了 s->next=s，显然是错误的。本算法主要的时间开销在于查找第 i-1 个元素，时间复杂度为 O(n)若在给定的结点后面插入新结点则时间复杂度仅为 0(1)。

扩展:对某一结点进行前插操作。
前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反。在单链表插入算法中，通常都采用后插操作。

以上面的算法为例，首先调用函数 GetElem()找到第 i-1 个结点，即插入结点的前驱结点后，再对其执行后插操作。由此可知，对结点的前插操作均可转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为 O(n)。

此外，可采用另一种方式将其转化为后插操作来实现，i设待插入结点为\*s，将\*s 插入到\*p的前面。我们仍然将\*s 插入到\*p 的后面，然后将 p->data与 s->data 交换，这样既满足了逻辑关系，又能使得时间复杂度为 O(1)。算法的代码片段如下:

```c
s->next=p->next;
p->next=s;
temp=p->data;
p->data=s->data;
s->data=temp;

```

6. 删除节点操作

删除结点操作是将单链表的第i个结点删除。光检查删除位置的合法性，后查找表中第 i-1个结点，即被删结点的前驱结点，再将其删除。其操作过程如图 2.8 所示。
假设结点\*p 为找到的被删结点的前驱结点，为实现这一操作后的逻辑关系的变化，仅需修改\*p的指针域，即将\*p 的指针域 next 指向\*q 的下一结点.

```c
p=GetElem(L,i-1);//查找删除位置的前驱结点
q=p->next;//令g 指向被删除结点
p->next=q->next; //将*q 结点从链中“断开”
free(q); //放结点的存储空间
```
和插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为 O(n).
扩展:删除结点*P。

要删除某个给定结点*p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后执行删除操作，算法的时间复杂度为 O(n)。

其实，删除结点\*p的操作可用删除\*p 的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为 O(1)。实现上述操作的代码片段如下:

```c
q=p->next;//令指向*p 的后继结点
p->data=p->next->data;//和后继结点交换数据域
p->next=q->next;//将*a 结点从链中“断开”
free(q);//释放后继结点的存储空间
```

7. 求表长的操作

求表长操作就是计算单链表中数据结点(不含头结点)的个数，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加 1，直到访问到空结点为止。算法的时间复杂度为 O(n)。
需要注意的是，因为单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。单链表是整个链表的基础，读者一定要熟练掌握单链表的基本操作算法。在设计算法时，建议先通过图示的方法理清算法的思路，然后进行算法的编写.

### 2.3.3 双链表

单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为 0(1)，访问前驱结点的时间复杂度为 O(n)。
为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针 prior 利 next，分别指向其前驱结点和后继结点，如图 2.9所示。

双链表中结点类型的描述如下
```c
typedef struct DNodef{ //定义双链表结点类型
    ElemType data; //数据域
    struct DNode *prior,*next; //前驱和后继指针

}DNode，*DLinklist; 
```
双链表在单链表的结点中增加了一个指向其前驱的 prior 指针，因此双链表中的按值查找利按位查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同这是因为“链”变化时也需要对 pror 指针做出修改，其关键是保证在修改的过程中不断链。此外，双链表可以很方便地找到其前驱结点，因此，插入、删除操作的时间复杂度仅为 O(1)。

1. 双链表的插入操作

```c
s->next=p->next; //将结点*s 插入到结点*p 之后
p->next->prior=s;
s->prior=p;
p->next=s;
```
上述代码的语句顺序不是唯一的，但也不是任意的，1和2两步必须在4步之前，否则\*p的后继结点的指针就会丢掉，导致插入失败。为了加深理解，读者可以在纸上画出示意图。若问题改成要求在结点\*p 之前插入结点\*s，请读者思考具体的操作步骤.

2. 双链表的删除操作

删除操作的代码片段如下
```c

p->next=g->next; //图2.11中步骤1
g->next->prior=p;//图2.11中步骤2
free(g) //释放结点空间;

```
若问题改成要求删除结点\*q 的前驱结点\*p，请读者思考具体的操作步骤。在建立双链表的操作中，也可采用如同单链表的头插法和尾插法，但在操作上需要注意指针的变化和单链表有所不同。


### 2.3.4 循环链表

1. 循环单链表

循环单链表和单链表的区别在于，表中最后一个结点的指针不是 NULL，而改为指向头结点从而整个链表形成一个环，如图 2.12 所示。
在循环单链表中，表尾结点*r 的 next 域指向L，故表中没有指针域为 NULL 的结点，因此循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。

循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环””，
此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。其原因是，若设的是头指针，对表尾进行操作需要 0(n)的时间复杂度，而设的是尾指针 r，r->next 即为头指针，对表头与表尾进行操作都只需要 0(1)的时间复杂度。

2. 循环双链表

由循环单链表的定义不难推出循环双链表。不同的是在循环双链表中，头结点的 prior 指针还要指向表尾结点，如图 2.13 所示。

在循环双链表 L 中，某结点*p 为尾结点时，p->next==L:当循环双链表为空表时，其头结点的 prior 城和 next 域都等于L。

### 2.3.5 静态链表

静态链表借助数组来描述线性表的链式存储结构，结点也有数据域 data 和指针域 next与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址(数组下标)，又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。静态链表和单链表的对应关系如图 2.14 所示。

```c
#define MaxSize 50
typedef struct {
    ElemType data;
    int next;
} SLinkList[MaxSize];
```

静态链表以next==-1 作为其结束的标志。静链表的插入、删除操作与动态链表的相同只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言(如 Basic)中，这是一种非常巧妙的设计方法。

### 2.3.6 顺序表和链表的比较

1. 存取(读写)方式
顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。例如在第i个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次
2. 逻辑结构与物理结构
采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。
3. 查找、插入和删除操作
对于按值查找，顺序表无序时，两者的时间复杂度均为 O(n):顺序表有序时，可采用折半查找，此时的时间复杂度为 O(log2n)。
对于按序号查找，顺序表支持随机访问，时间复杂度仅为 0(1)，而链表的平均时间复杂度为O(n)。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。
4. 空间分配
顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置;预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。

在实际中应该怎样选取存储结构呢?

1. 基于存储的考虑
难以估计线性表的长度或存储规模时，不宜采用顺序表;链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。
2. 基于运算的考虑
在顺序表中按序号访问a;的时间复杂度为 O(1)，而表中按序号访问的时间复杂度为O(n)因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。
在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大日表较长时，这一点是不应忽视的:在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。
3. 基于环境的考虑
顺序表容易实现，任何高级语言中都有数组类型，链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。
总之，两种存储结构各有长短，选择哪一种山实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表(即动态性较强)宜选择链式存储
**注意**:只有熟练学握顺序存储和链式存储，才能深刻理解它们各自的优缺点.