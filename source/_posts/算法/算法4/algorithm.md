---
title: 《算法4》
categories: 
- 算法
thumbnailImagePosition: bottom
coverImage: https://user-images.githubusercontent.com/46363359/205700654-f2577dc7-9b49-4509-9bd1-14ba5c23ae6f.jpg
metaAlignment: center
coverMeta: out
---

本书大部分内容来自Sedgewick的算法系列图书。本质上，本书和该系列的第1版和第2版最接近，但还包含了作者多年教学和学习的经验。Sedgewick的《C算法（第3版）》、《C++算法（第3版）》、《Java算法（第3版）》更适合用做参考书或是高级课程的教材，而本书则是专门为大学一、二年级学生设计的一学期教材

<!-- more -->

<!-- toc -->

# 第一章 算法

summary:
1. 更像是java语法基础通识

本书的目的是研究多种重要而实用的算法，即适合用计算机实现的解决问题的方法。和算法关系最紧密的是数据结构，即便于算法操作的组织数据的方法。本章介绍的就是学习算法和数据结构所需要的基本工具。
首先要介绍的是我们的基础编程模型。本书中的程序只用到了 Java 语言的一小部分，以及我们自己编写的用于封装输入输出以及统计的一些库。1.1 节总结了相关的语法、语言特性和书中将会
用到的库。
接下来我们的重点是数据抽象并**定义抽象数据类型**(ADT)以进行模块化编程。在 1.2 节中我们介绍了用Java 实现抽象数据类型的过程，包括定义它的应用程序编程接口(API)然后通过Java的类机制来实现它以供各种用例使用。
之后，作为重要而实用的例子，我们将学习三种基础的抽象数据类型:背包、队列和栈。1.3节用数组、变长数组和链表实现了背包、队列和栈的 API，它们是全书算法实现的起点和样板。性能是算法研究的一个核心问题。1.4 节描述了分析算法性能的方法。我们的基本做法是科学式的，即先对性能提出假设，建立数学模型，然后用多种实验验证它们，必要时重复这个过程。我们用一个连通性问题作为例子结束本章，它的解法所用到的算法和数据结构可以实现经典的union-find 抽象数据结构。

**算法**
编写一段计算机程序一般都是实现一种已有的方法来解决某个问题。这种方法大多和使用的编程语言无关一它适用于各种计算机以及编程语言。是这种方法而非计算机程序本身描述了解决问题的步骤。在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。算法是计算机科学的基础，是这个领域研究的核心。
要定义一个算法，我们可以用自然语言描述解决某个问题的过程或是编写一段程序来实现这个过程。如发明于 2300 多年前的欧几里德算法所示，其目的是找到两个数的最大公约数

```java
// Java语言描述
Public static int gcd(int p,int q){
if(q == 0) return p;
intr=p%q;
return gcd(q，r);
}
```

自然语言描述:计算两个非负整数p和g的最大公约数:若q是0，则最大公约数为p。否则，将p 除以q得到余数r,p和g的最大公约数即为q和r的最大公约数。

## 1.1 基础编程模型

我们学习算法的方法是用 Java 编程语言编写的程序来实现算法。这样做是出于以下原因:
 - 程序是对算法精确、优雅和完全的描述;
 - 可以通过运行程序来学习算法的各种性质;
 - 可以在应用程序中直接使用这些算法。
相比用自然语言描述算法，这些是重要而巨大的优势
这样做的一个缺点是我们要使用特定的编程语言，这会使分离算法的思想和实现细节变得困难。我们在实现算法时考虑到了这一点，只使用了大多数现代编程语言都具有且能够充分描述算法所必需的语法。
我们仅使用了 Java 的一个子集。尽管我们没有明确地说明这个子集的范围，但你也会看到我们只使用了很少的 Java 特性，而且会优先使用大多数现代编程语言所共有的语法。:我们的代码是完整的，因此希望你能下载这些代码并用我们的测试数据或是你自己的来运行它们。

我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为**基础编程模型**。本节以及 1.2 节会详细说明这个模型，相关内容自成一体，主要是作为文档供读者查阅，以便理解本书的代码。我们的另一本人门级的书籍《 An Introduction to Programming in Java: An Interdisciplinary approach 》也使用了这个模型。

作为参考，图 1.1.1 所示的是一个完整的 Java 程序。它说明了我们的基础编模型的许多基本特点。在讨论语言特性时我们会用这段代码作为例子，但可以先不用考虑代码的实际意义(它实现了经典的二分查找算法，并在白名单过滤应用中对算法进行了检验，请见 1.1.10 节)。我们假设你具备某种主流语言编程的经验，因此你应该知道这段代码中的大多数要点。图中的注释应该能够解答你的任何疑问。因为图中的代码某种程度上反映了本书代码的风格，而且对各种Java 编程惯例和语言构造，在用法上我们都力求一致，所以即使是经验丰富的 Java 程序员也应该看一看。

### 1.1.1 java程序的基本结构

summary:
1. javac 编译java代码
2. java xxx.class 文件执行


段 Java程序(类)或者是一个静态方法(函数)库，或者定义了一个数据类型。要创建静态方法库和定义数据类型,会用到下面五种语法，它们是Java语言的基础,也是大多数现代语言所共有的。
- 原始数据类型:它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式
- 语句:语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句:声明、赋值、条件、循环、调用和返回。
- 数组:数组是多个同种数据类型的值的集合。
- 静态方法:静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。
- 字符串:字符串是一连串的字符，Java 内置了对它们的一此操作。
- 标准输入/输出:标准输入输出是程序与外界联系的桥梁。
- 数据抽象，数据抽象封装和重用代码,使我们可以定义非原始数据类型，进而支持面向对象编程。我们将在本节学习前五种语法，数据抽象是下一节的主题。运行 Java 程序需要和操作系统或开发环境打交道。为了清晰和简洁，我们把这种输人命令执行程序的环境称为虚拟终端。请登录本书的网站去了解如何使用虚拟终端，或是现代系统中许多其他高级的编程开发环境的使用方法。在例子中BinarySearch 类有两个静态方法rank()和 main0。第一个方法 rank() 含有四条语句: 两条声明语句，一条循环语句(该语句中又有一条赋值语句和两条条件语句)和一条返回语句。

第二个方法 main(包含三条语句:一条声明语句、一条调用语句和一个循环语句(该语句中又包含一条赋值语句和一条条件语句 )。
要执行一个Java 程序，首先需要用 javac 命令编译它，然后再用 java 命令运行它。例如，要运行 BinarySearch，首先要输人 javac BinarySearch.java ( 这将生成一个叫 BinarySearchclass的文件，其中含有这个程序的Java 字节码):然后再输人java BinarySearch (接着是一个白名单文件名)把控制权移交给这段字节码程序。为了理解这段程序，我们接下来要详细介绍原始数据类型和表达式，各种 Java 语句、数组、静态方法、字符串和输人输出。


### 1.1.2 原始数据类型与表达式

summary:
1. `+、-、*、/`都是被重载过的最重要的是运算结果与运算值是相似的，这也意味着我们经常需要处理近似值,例如，5/3 的值是1而 5.0/3,0 的值是 1.66666666666667


数据类型就是一组数据和对其所能进行的操作的集合。首先考虑以下 4 种Jva 语言最基本的原始数据类型:
 - 整型，及其算术运算符(int);
 - 浮点型，及其算术运算符(double);
 - 布尔型，它的值 {true，false]及其逻辑操作(boolean); 
 - 字符型，它的值是你能够输入的英文字母数字字符和符号(char)。接下来我们看看如何指明这些类型的值和对这些类型的操作。
Java 程序控制的是用标识符命名的变量。每个变量都有自己的类型并存储了一个合法的值。在Java代码中，我们用类似数学表达式的表达式来实现对各种类型的操作。对于原始类型来说，我们用标识符来引用变量，用`+、、*、/`等运算符来指定操作，用字面量，例如1或者3.14 来表示值，用形如`(x+2.236)/2` 的表达式来表示对值的操作。表达式的目的就是计算某种数据类型的值。表 1.1.1 对这些基本内容进行了说明

|术语|例子|定义|
|---|---|---|
|原始数据类型|int double boolean char |组数据和对其所能进行的操作的集合(Java 语言内置)|
|标识符|a abc Ab$ a_b ab123 lo hi|由字母、数字、下划线和 $组成的字符串，首字符不能是数字|
|变量|任意标识符(emoji也可以)|表示某种数据类型的值|
|字面值|int double boolean char ||
|表达式|||

只要能够指定值域和在此值域上的操作，就能定义一个数据类型。表 1.1.2 总结了 Java 的int、double、boolean和 char 类型的相关信息。许多现代编程语言中的基本数据类型和它们都很相似。对于 int 和 double 来说，这些操作是我们熟悉的算数运算;对于 boolean 来说则是逻辑运算。需要注意的重要一点是，`+、-、*、/`都是被重载过的一一根据上下文，同样的运算符对不同类型会执行不同的操作。这些初级运算的关键性质是运算产生的数据的数据类型和参与运算的数据的数据类型是相同的。这也意味着我们经常需要处理近似值，因为很多情况下由表达式定义的准确值并非参与表达式运算的值。例如，5/3 的值是1而 5.0/3,0 的值是 1.66666666666667，两者都很接近但并不准确地等于 5/3。下表并不完整，我们会在本节最后的答疑部分中讨论更多运算符和偶尔需要考虑到的各种异常情况。

java中的原始数据类型
|类型|值域|运算符|典型表达式|值|
|---|---|---|---|---|
|int||||
|double||||
|boolean||||
|char||||

**表达式**
**类型转换**
**比较**
**其他类型**

### 1.1.3 语句

**声明语句**
**赋值语句**
**条件语句**
**循环语句**

### 1.1.4 简单标记法

### 1.1.5 数组

### 1.1.6 静态方法

### 1.1.7 API

### 1.1.8 字符串

### 1.1.9 输入输出

### 1.1.10 二分查找

### 1.1.11 展望

在本节中，我们描述了一个精巧而完整的编程模型，数十年来它一直在(并且现在仍在)为广大程序员服务。但现代编程技术已经更进一步。前进的这一步被称为**数据抽象**，有时也被称为面向对象编程，它是我们下一节的主题。简单地说，数据抽象的主要思想是鼓励程序定义自己的数据类型(一系列值和对这些值的操作，而不仅仅是那些操作预定义的数据类型的静态方法。面向对象编程在最近几十年得到了广泛的应用，数据抽象已经成为现代程序开发的核心。我们在本书中“拥抱”数据抽象的原因主要有三。
- 它允许我们通过模块化编程复用代码。例如，第 2 章中的排序算法和第 3 章中的二分查找以及其他算法，都允许调用者用同一段代码处理任意类型的数据(而不仅限于整数)，包括调用者自定义的数据类型。
- 它使我们可以轻易构造多种所谓的链式数据结构，它们比数组更灵活，在许多情况下都是高效算法的基础。
- 借助它我们可以准确地定义所面对的算法问题。比如 1.5 节中的 nion-fnd 算法、2.4 节中的优先队列算法和第 3 章中的符号表算法，它们解决问题的方式都是定义数据结构并高效地实现它们的一组操作。这些问题都能够用数据抽象很好地解决。

## 1.2 数据抽象

summary:
1. java主要就是使用class来定义新的引用类型数据类型，这种风格也叫面向对象编程
2. 抽象教据类型(ADT)是一种能够对使用者隐藏数据表示的数据类型。用Java类来实现抽象数据类型和用一组静态方法实现一个函数库并没有什么不同。抽象数据类型的主要不同之处在于它将数据和函数的实现关联，并将数据的表示方式隐藏起来。在使用抽象数据类型时，我们的注意力集中在 API 描述的操作上而不会去关心数据的表示:在实现抽象数据类型时，我们的注意力集中在数据本身并将实现对该数据的各种操作。
3. 相同问题的不同算法实现，他们之间会有显著的性能差异，我们可以将抽象数据类型的知识应用到实践中

抽象数据类型之所以重要是因为在程序设计上它们支持封装。在本书中，我们将通过它们: 
- 以适用于各种用途的API形式准确地定义问题
- 用API的实现描述算法和数据结构。
我们研究同一个问题的不同算法的主要原因在于它们的性能特点不同。抽象数据类型正适合于对算法的这种研究，因为它确保我们可以随时将算法性能的知识应用于实践中:可以在不修改任何用例代码的情况下用一种算法替换另一种算法并改进所有用例的性能.

### 1.2.1 使用抽象数据类型

summary:
1. 使用一种数据类型不一定非要知道它是如何实现的。比如接下来的counter计数器程序，要使用它首先要知道如何定义数据类型的操作，以及选择编写并实现
2. API可以说明抽象数据类型的行为，可以说明自定义的数据类型提供的功能


**抽象数据类型的API**

summary:
1. 通过问题和需求，作者构建了如下的抽象数据类型counter
2. 抽象数据类型和静态方法库的区别和相同点

我们使用应用程序编程接口（API）来说明抽象数据类型的行为。它将列出所有构造函数和实例方法（即操作）并简要描述它们的功用，如表1.2.1中Counter的API所示。
尽管数据类型定义的基础是一组值的集合，但在API可见的仅是对它们的操作，而非它们的意义。因此，抽象数据类型的定义和静态方法库（请见1.1.6.3节)之间有许多共同之处:
- 两者的实现均为Java类;
- 实例方法可能接受0个或多个指定类型的参数，由括号表示并由逗号分隔;
- 它们可能会返回一个指定类型的值，也可能不会(用void表示)。

当然，它们也有三个显著的不同。

- API中可能会出现若干个名称和类名相同且没有返回值的函数。这些特殊的函数被称为**构造函数**。在本例中，Counter对象有一个接受一个String参数的构造函数。
- 实例方法不需要static关键字。它们不是静态方法一它们的目的就是操作该数据类型中的值。
- 某些实例方法的存在是为了尊重Java的习惯——我们将此类方法称为继承的方法并在API中将它们显示为灰色。

|return value| function name | describe|
|---|---|---|
||Counter(string id)|通过一个string类型的id进行初始化|
|void|increment()|计数器加1|
|int| tally|该对象创建后计数器加一的次数|
|string |toString()|对象字符串表示|

和静态方法库的 API一样，抽象数据类型的 API也是和用例之间的一份契约，因此它是开发任何用例代码以及实现任意数据类型的起点。在本例中，这份 API告诉我们可以通过构造函数Counter()、实例方法 increment() 和 tay()，以及继承的 toString() 方法使用Counter类型的对象。

**继承方法**

summary:
我们常常会提供实现来重载默认实现，并在此时在 API中加上 toString()方法来重载抽象数据类型的toString方法，还有跟多

根据Java 的约定，任意数据类型都能通过在API中包含特定的方法从 Java 的内在机制中获益。例如Java中的所有数据类型都会继承 toString()方法来返回用String 表示的该类型的值。Java 会在用`+`运算符将任意数据类型的值和 String 值连接时调用该方法。该方法的默认实现并不实用(它会返回用字符串表示的该数据类型值的内存地址)，因此我们常常会提供实现来重载默认实现，并在此时在 API中加上 toString()方法。此类方法的例子还包括 equals(),compareTo()和hashCode()。

**用例代码**

这节讲的很浅显，但是可以了解下java的classpath机制，说白了就是我们编写出的代码，实现的抽象数据类型和函数库

**对象**

summary: 作者提供的理解对象的思路非常有意思，或许可以学习并记忆
1. 对象的标识份能够将一个对象区别于另一个对象。可以认为对象的标识就是它在内存中的位置
2. 对象的行为(方法)就是数据类型的操作，对象的数据类型的实现就是维护**对象**的身份，告诉别人who you are
3. 对象的状态可以为用例代码提供信息，或是产生某种副作用，或是被数据类型的操作所改变(这句话不是太理解)
4. **引用**是访问对象的一种方式，也用来区别基础数据类型，可以认为引用就是内存地址
般来说，可以声明一个变量 heads 并将它通过以下代码和 Counter 类型的数据关联起来:
Counter heads;
但如何为它赋值或是对它进行操作呢?这个问题的答案涉及数据抽象中的一个基础概念:对象是能够承载数据类型的值的实体。所有对象都有三大重要特性:状态、标识和行为。对象的状态即数据类型中的值。对象的标识份能够将一个对象区别于另一个对象。可以认为对象的标识就是它在内存中的位置。对象的行为就是数据类型的操作。数据类型的实现的唯一职责就是维护一个对象的身份，这样用例代码在使用数据类型时只需遵守描述对象行为的API即可，而无需关注对象状态的表示方法。对象的状态可以为用例代码提供信息，或是产生某种副作用，或是被数据类型的操作所改变。但数据类型的值的表示细节和用例代码是无关的。**引用**是访问对象的一种方式。Java 使用术语引用类型以示和原始数据类型(变量和值相关联)的区别。不同的Java实现中引用的实现细节也各不相同，但可以认为引用就是内存地址，如图 1.2.1 所示(简洁起见，图中的内存地址为三位数)。

**创建对象**


## 1.3 背包，队列和栈

## 1.4 算法分析



# 第二章 排序

在计算时代早期，大家普遍认为 30% 的计算周期都用在了排序上。如果今天这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序的重要性降低了
即使你只是使用标准库中的排序函数，学习排序算法仍然有三大实际意义:
- 对排序算法的分析将有助于你全面理解本书中比较算法性能的方法:
- 类似的技术也能有效解决其他类型的问题；
- 排序算法常常是我们解决其他问题的第一步

## 2.1 初级排序算法

作为对排序算法领域的第一次探索，我们将学习两种初级的排序算法以及其中一种的一个变体。深入学习这些相对简单的算法的原因在于：
第一，我们将通过它们熟悉一些术语和简单的技巧；
第二，这些简单的算法在某些情况下比我们之后将会讨论的复杂算法更有效；
第三，以后你会发现，它们
有助于我们改进复杂算法的效率。

### 2.1.1 游戏规则

我们关注的主要对象是重新排列数组元素的算法，其中每个元素都有一个主键。排序算法的目标就是将所有元素的主键按照某种方式排列（通常是按照大小或是字母顺序）。排序后索引较大的主键大于等于索引较小的主键。元素和主键的具体性质在不同的应用中千差万别。在 Java 中，元素通常都是对象，对主键的抽象描述则是通过一种内置的机制（请见 2.1.1.4 节中的 Comparable 接口）来完成的。

“排序算法类模版”中的 Example 类展示了我们的习惯约定：我们会将排序代码放在类的sort() 方法中，该类还将包含辅助函数 less() 和 exch()（可能还有其他辅助函数）以及一个示例用例 main()。Example 类还包含了一些早期调试使用的代码：测试用例 main() 将标准输入得到的字符串排序，并用私有方法 show() 打印字符数组的内容。我们还会在本章中遇到各种用于比较不同算法并研究它们的性能的测试用例。为了区别不同的排序算法，我们为相应的类取了不同的名字，用例可以根据名字调用不同的实现，例如 Insertion.sort()、Merge.sort()、Quick.sort() 等。

大多数情况下，我们的排序代码只会通过两个方法操作数据：less() 方法对元素进行比较，exch() 方法将元素交换位置。exch() 方法的实现很简单，通过 Comparable 接口实现 less() 方法也不困难。将数据操作限制在这两个方法中使得代码的可读性和可移植性更好，更容易验证代码的正确性、分析性能以及排序算法之间的比较。在学习具体的排序算法实现之前，我们先讨论几个对于所有排序算法都很重要的问题


这个类展示的是数组排序实现的框架。对于我们学习的每种排序算法，我们都会为这样一个类实现一个 sort() 方法并将 Example 改为算法的名称。测试用例会将标准输入得到的字符串排序，但是这段
代码使我们的排序方法适用于任意实现了 Comparable 接口的数据类型。

#### 2.1.1.1 验证