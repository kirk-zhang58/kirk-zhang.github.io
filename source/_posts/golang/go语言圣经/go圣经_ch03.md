---
title: go语言圣经-chapter03-基础数据类型
categories:
- golang
tag: golang
---



# 3.基础数据类型

- 整型格式控制符
    |格 式	| 描 述|
    |---|---|
    |%b	| 整型以二进制方式显示|
    |%o	| 整型以八进制方式显示|
    |%d	| 整型以十进制方式显示|
    |%x	| 整型以十六进制方式显示|
    |%X	| 整型以十六进制、字母大写方式显示|
    |%c	| 相应Unicode码点所表示的字符|
    |%U	| Unicode 字符, Unicode格式：123，等同于 "U+007B"|

- 浮点数格式控制
    |格 式	| 描 述|
    |---|---|
    |%e	|科学计数法,例如 -1234.456e+78|
    |%E	|科学计数法,例如 -1234.456E+78|
    |%f	|有小数点而无指数,例如 123.456|
    |%g	|根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出|
    |%G	|根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出|

- 字符串格式化
    |格 式	|描 述|
    |---|---|
    |%s| 字符串或切片的无解译字节|
    |%q| 双引号围绕的字符串，由Go语法安全地转义|
    |%x| 十六进制，小写字母，每字节两个字符|
    |%X| 十六进制，大写字母，每字节两个字符|

- 指针格式化
    |格 式	|描 述|
    |---|---|
    |%p|十六进制表示，前缀 0x|
- 通用的占位符
    |格 式|	描 述|
    |---|---|
    |%v	|   值的默认格式。|
    |%+v|   类似%v，但输出结构体时会添加字段名|
    |%#v|   相应值的Go语法表示|
    |%T	|   相应值的类型的Go语法表示|
    |%%	|   百分号,字面上的%,非占位符含义|

- 控制宽度
    宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐
    - 字符串控制

        ```golang
        fmt.Printf("|%s|", "aa") // 不设置宽度
        fmt.Printf("|%5s|", "aa") // 5个宽度,  默认+， 右对齐
        fmt.Printf("|%-5s|", "aa") // 5个宽度, 左对齐

        fmt.Printf("|%05s|", "aa") // |000aa|

        ```

    - 浮点控制

        ```golang
        a := 54.123456
        fmt.Printf("|%f|", a)  // |54.123456|
        fmt.Printf("|%5.1f|", a)  // | 54.1|
        fmt.Printf("|%-5.1f|", a) // |54.1 |
        fmt.Printf("|%05.1f|", a) // |054.1|
        ```



## 3.1 整型

1. 因为不同的编译器即使在相同的硬件平台上可能产生不同的大小字节
2. Unicode和rune类型是个`int32`等价的类型,通常用于表示一个Unicode码点
3. 同样byte也是`uint8`类型的等价类型
4. 还有一种无符号的整数类型`uintptr`，没有指定具体的bit大小但是足以容纳指针。`uintptr`类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方
5. `int`、`uint`和`uintptr`是不同类型的兄弟类型。其中`int`和`int32`也是不同的类型，即使`int`的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然
6. 位元素符号
7. `int32`和`int64`无法直接四则运算
8. `fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"`中的`fmt`两个使用技巧.(1)%之后的[1]副词告诉Printf函数再次使用第一个操作数.(2)后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀

## 3.2 浮点数

1. 一个`float32`类型的浮点数可以提供大约`6`个十进制数的精度，而`float64`则可以提供约`15`个十进制数的精度；通常应该优先使用`float64`类型，因为`float32`类型的累计计算误差很容易扩散，并且`float32`能精确表示的正整数并不是很大
2. 浮点数字面量可以直接书写
3. 很大或者很小的数都可以用科学计数法来书写
4. `fmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))`8.3是指三个小数精度，8个字符宽度,`%g %e %f`.

## 3.3 复数

复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部:
```golang
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"

```

## 3.4 布尔类型

布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换:

```golang
i := 0
if b {
    i = 1
}
```

## 3.5 字符串

- 字符串可以用==和<进行比较；比较通过逐个字节比较完成的
- 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变.故`s[0] = 'L' // compile error: cannot assign to s[0]`

  - 因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中
  - 可在字符串面值中写`十六进制`和`八进制`数字进行码点转义
  - 原生字面值用反引号(`)说明字面值不转义,而且字符串无法使用( 反引号 )，但是可以使用八进制和十六进制(泛化转义字符)进行转化.
  - 通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思
  - UTF-8 [to be continue]
  - `bytes`、`strings`、`strconv`和`unicode`包,四个包对字符串处理尤为重要,`strings`包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能
  - 字符串和数字的转换,`strconv`包提供这类转换功能